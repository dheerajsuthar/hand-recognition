/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@tensorflow/tfjs-converter/dist/tf-converter.esm.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-converter/dist/tf-converter.esm.js ***!
  \**************************************************************************/
/*! exports provided: FrozenModel, loadFrozenModel, version_converter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FrozenModel", function() { return FrozenModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadFrozenModel", function() { return loadFrozenModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version_converter", function() { return version; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var __assign=Object.assign||function(e){for(var t,a=1,r=arguments.length;a<r;a++)for(var n in t=arguments[a])Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e};function __awaiter(e,t,a,r){return new(a||(a=Promise))(function(n,o){function s(e){try{p(r.next(e))}catch(e){o(e)}}function i(e){try{p(r.throw(e))}catch(e){o(e)}}function p(e){e.done?n(e.value):new a(function(t){t(e.value)}).then(s,i)}p((r=r.apply(e,t||[])).next())})}function __generator(e,t){var a,r,n,o,s={label:0,sent:function(){if(1&n[0])throw n[1];return n[1]},trys:[],ops:[]};return o={next:i(0),throw:i(1),return:i(2)},"function"==typeof Symbol&&(o[Symbol.iterator]=function(){return this}),o;function i(o){return function(i){return function(o){if(a)throw new TypeError("Generator is already executing.");for(;s;)try{if(a=1,r&&(n=r[2&o[0]?"return":o[0]?"throw":"next"])&&!(n=n.call(r,o[1])).done)return n;switch(r=0,n&&(o=[0,n.value]),o[0]){case 0:case 1:n=o;break;case 4:return s.label++,{value:o[1],done:!1};case 5:s.label++,r=o[1],o=[0];continue;case 7:o=s.ops.pop(),s.trys.pop();continue;default:if(!(n=(n=s.trys).length>0&&n[n.length-1])&&(6===o[0]||2===o[0])){s=0;continue}if(3===o[0]&&(!n||o[1]>n[0]&&o[1]<n[3])){s.label=o[1];break}if(6===o[0]&&s.label<n[1]){s.label=n[1],n=o;break}if(n&&s.label<n[2]){s.label=n[2],s.ops.push(o);break}n[2]&&s.ops.pop(),s.trys.pop();continue}o=t.call(e,s)}catch(e){o=[6,e],r=0}finally{a=n=0}if(5&o[0])throw o[1];return{value:o[0]?o[1]:void 0,done:!0}}([o,i])}}}var commonjsGlobal="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};function createCommonjsModule(e,t){return e(t={exports:{}},t.exports),t.exports}var aspromise=asPromise;function asPromise(e,t){for(var a=new Array(arguments.length-1),r=0,n=2,o=!0;n<arguments.length;)a[r++]=arguments[n++];return new Promise(function(n,s){a[r]=function(e){if(o)if(o=!1,e)s(e);else{for(var t=new Array(arguments.length-1),a=0;a<t.length;)t[a++]=arguments[a];n.apply(null,t)}};try{e.apply(t||null,a)}catch(e){o&&(o=!1,s(e))}})}var base64_1=createCommonjsModule(function(e,t){var a=t;a.length=function(e){var t=e.length;if(!t)return 0;for(var a=0;--t%4>1&&"="===e.charAt(t);)++a;return Math.ceil(3*e.length)/4-a};for(var r=new Array(64),n=new Array(123),o=0;o<64;)n[r[o]=o<26?o+65:o<52?o+71:o<62?o-4:o-59|43]=o++;a.encode=function(e,t,a){for(var n,o=null,s=[],i=0,p=0;t<a;){var m=e[t++];switch(p){case 0:s[i++]=r[m>>2],n=(3&m)<<4,p=1;break;case 1:s[i++]=r[n|m>>4],n=(15&m)<<2,p=2;break;case 2:s[i++]=r[n|m>>6],s[i++]=r[63&m],p=0}i>8191&&((o||(o=[])).push(String.fromCharCode.apply(String,s)),i=0)}return p&&(s[i++]=r[n],s[i++]=61,1===p&&(s[i++]=61)),o?(i&&o.push(String.fromCharCode.apply(String,s.slice(0,i))),o.join("")):String.fromCharCode.apply(String,s.slice(0,i))};a.decode=function(e,t,a){for(var r,o=a,s=0,i=0;i<e.length;){var p=e.charCodeAt(i++);if(61===p&&s>1)break;if(void 0===(p=n[p]))throw Error("invalid encoding");switch(s){case 0:r=p,s=1;break;case 1:t[a++]=r<<2|(48&p)>>4,r=p,s=2;break;case 2:t[a++]=(15&r)<<4|(60&p)>>2,r=p,s=3;break;case 3:t[a++]=(3&r)<<6|p,s=0}}if(1===s)throw Error("invalid encoding");return a-o},a.test=function(e){return/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(e)}}),eventemitter=EventEmitter;function EventEmitter(){this._listeners={}}EventEmitter.prototype.on=function(e,t,a){return(this._listeners[e]||(this._listeners[e]=[])).push({fn:t,ctx:a||this}),this},EventEmitter.prototype.off=function(e,t){if(void 0===e)this._listeners={};else if(void 0===t)this._listeners[e]=[];else for(var a=this._listeners[e],r=0;r<a.length;)a[r].fn===t?a.splice(r,1):++r;return this},EventEmitter.prototype.emit=function(e){var t=this._listeners[e];if(t){for(var a=[],r=1;r<arguments.length;)a.push(arguments[r++]);for(r=0;r<t.length;)t[r].fn.apply(t[r++].ctx,a)}return this};var float_1=factory(factory);function factory(e){return"undefined"!=typeof Float32Array?function(){var t=new Float32Array([-0]),a=new Uint8Array(t.buffer),r=128===a[3];function n(e,r,n){t[0]=e,r[n]=a[0],r[n+1]=a[1],r[n+2]=a[2],r[n+3]=a[3]}function o(e,r,n){t[0]=e,r[n]=a[3],r[n+1]=a[2],r[n+2]=a[1],r[n+3]=a[0]}function s(e,r){return a[0]=e[r],a[1]=e[r+1],a[2]=e[r+2],a[3]=e[r+3],t[0]}function i(e,r){return a[3]=e[r],a[2]=e[r+1],a[1]=e[r+2],a[0]=e[r+3],t[0]}e.writeFloatLE=r?n:o,e.writeFloatBE=r?o:n,e.readFloatLE=r?s:i,e.readFloatBE=r?i:s}():function(){function t(e,t,a,r){var n=t<0?1:0;if(n&&(t=-t),0===t)e(1/t>0?0:2147483648,a,r);else if(isNaN(t))e(2143289344,a,r);else if(t>3.4028234663852886e38)e((n<<31|2139095040)>>>0,a,r);else if(t<1.1754943508222875e-38)e((n<<31|Math.round(t/1.401298464324817e-45))>>>0,a,r);else{var o=Math.floor(Math.log(t)/Math.LN2);e((n<<31|o+127<<23|8388607&Math.round(t*Math.pow(2,-o)*8388608))>>>0,a,r)}}function a(e,t,a){var r=e(t,a),n=2*(r>>31)+1,o=r>>>23&255,s=8388607&r;return 255===o?s?NaN:n*(1/0):0===o?1.401298464324817e-45*n*s:n*Math.pow(2,o-150)*(s+8388608)}e.writeFloatLE=t.bind(null,writeUintLE),e.writeFloatBE=t.bind(null,writeUintBE),e.readFloatLE=a.bind(null,readUintLE),e.readFloatBE=a.bind(null,readUintBE)}(),"undefined"!=typeof Float64Array?function(){var t=new Float64Array([-0]),a=new Uint8Array(t.buffer),r=128===a[7];function n(e,r,n){t[0]=e,r[n]=a[0],r[n+1]=a[1],r[n+2]=a[2],r[n+3]=a[3],r[n+4]=a[4],r[n+5]=a[5],r[n+6]=a[6],r[n+7]=a[7]}function o(e,r,n){t[0]=e,r[n]=a[7],r[n+1]=a[6],r[n+2]=a[5],r[n+3]=a[4],r[n+4]=a[3],r[n+5]=a[2],r[n+6]=a[1],r[n+7]=a[0]}function s(e,r){return a[0]=e[r],a[1]=e[r+1],a[2]=e[r+2],a[3]=e[r+3],a[4]=e[r+4],a[5]=e[r+5],a[6]=e[r+6],a[7]=e[r+7],t[0]}function i(e,r){return a[7]=e[r],a[6]=e[r+1],a[5]=e[r+2],a[4]=e[r+3],a[3]=e[r+4],a[2]=e[r+5],a[1]=e[r+6],a[0]=e[r+7],t[0]}e.writeDoubleLE=r?n:o,e.writeDoubleBE=r?o:n,e.readDoubleLE=r?s:i,e.readDoubleBE=r?i:s}():function(){function t(e,t,a,r,n,o){var s=r<0?1:0;if(s&&(r=-r),0===r)e(0,n,o+t),e(1/r>0?0:2147483648,n,o+a);else if(isNaN(r))e(0,n,o+t),e(2146959360,n,o+a);else if(r>1.7976931348623157e308)e(0,n,o+t),e((s<<31|2146435072)>>>0,n,o+a);else{var i;if(r<2.2250738585072014e-308)e((i=r/5e-324)>>>0,n,o+t),e((s<<31|i/4294967296)>>>0,n,o+a);else{var p=Math.floor(Math.log(r)/Math.LN2);1024===p&&(p=1023),e(4503599627370496*(i=r*Math.pow(2,-p))>>>0,n,o+t),e((s<<31|p+1023<<20|1048576*i&1048575)>>>0,n,o+a)}}}function a(e,t,a,r,n){var o=e(r,n+t),s=e(r,n+a),i=2*(s>>31)+1,p=s>>>20&2047,m=4294967296*(1048575&s)+o;return 2047===p?m?NaN:i*(1/0):0===p?5e-324*i*m:i*Math.pow(2,p-1075)*(m+4503599627370496)}e.writeDoubleLE=t.bind(null,writeUintLE,0,4),e.writeDoubleBE=t.bind(null,writeUintBE,4,0),e.readDoubleLE=a.bind(null,readUintLE,0,4),e.readDoubleBE=a.bind(null,readUintBE,4,0)}(),e}function writeUintLE(e,t,a){t[a]=255&e,t[a+1]=e>>>8&255,t[a+2]=e>>>16&255,t[a+3]=e>>>24}function writeUintBE(e,t,a){t[a]=e>>>24,t[a+1]=e>>>16&255,t[a+2]=e>>>8&255,t[a+3]=255&e}function readUintLE(e,t){return(e[t]|e[t+1]<<8|e[t+2]<<16|e[t+3]<<24)>>>0}function readUintBE(e,t){return(e[t]<<24|e[t+1]<<16|e[t+2]<<8|e[t+3])>>>0}var inquire_1=inquire;function inquire(moduleName){try{var mod$$1=eval("quire".replace(/^/,"re"))(moduleName);if(mod$$1&&(mod$$1.length||Object.keys(mod$$1).length))return mod$$1}catch(e){}return null}var utf8_1=createCommonjsModule(function(e,t){var a=t;a.length=function(e){for(var t=0,a=0,r=0;r<e.length;++r)(a=e.charCodeAt(r))<128?t+=1:a<2048?t+=2:55296==(64512&a)&&56320==(64512&e.charCodeAt(r+1))?(++r,t+=4):t+=3;return t},a.read=function(e,t,a){if(a-t<1)return"";for(var r,n=null,o=[],s=0;t<a;)(r=e[t++])<128?o[s++]=r:r>191&&r<224?o[s++]=(31&r)<<6|63&e[t++]:r>239&&r<365?(r=((7&r)<<18|(63&e[t++])<<12|(63&e[t++])<<6|63&e[t++])-65536,o[s++]=55296+(r>>10),o[s++]=56320+(1023&r)):o[s++]=(15&r)<<12|(63&e[t++])<<6|63&e[t++],s>8191&&((n||(n=[])).push(String.fromCharCode.apply(String,o)),s=0);return n?(s&&n.push(String.fromCharCode.apply(String,o.slice(0,s))),n.join("")):String.fromCharCode.apply(String,o.slice(0,s))},a.write=function(e,t,a){for(var r,n,o=a,s=0;s<e.length;++s)(r=e.charCodeAt(s))<128?t[a++]=r:r<2048?(t[a++]=r>>6|192,t[a++]=63&r|128):55296==(64512&r)&&56320==(64512&(n=e.charCodeAt(s+1)))?(r=65536+((1023&r)<<10)+(1023&n),++s,t[a++]=r>>18|240,t[a++]=r>>12&63|128,t[a++]=r>>6&63|128,t[a++]=63&r|128):(t[a++]=r>>12|224,t[a++]=r>>6&63|128,t[a++]=63&r|128);return a-o}}),pool_1=pool;function pool(e,t,a){var r=a||8192,n=r>>>1,o=null,s=r;return function(a){if(a<1||a>n)return e(a);s+a>r&&(o=e(r),s=0);var i=t.call(o,s,s+=a);return 7&s&&(s=1+(7|s)),i}}var longbits=LongBits;function LongBits(e,t){this.lo=e>>>0,this.hi=t>>>0}var zero=LongBits.zero=new LongBits(0,0);zero.toNumber=function(){return 0},zero.zzEncode=zero.zzDecode=function(){return this},zero.length=function(){return 1};var zeroHash=LongBits.zeroHash="\0\0\0\0\0\0\0\0";LongBits.fromNumber=function(e){if(0===e)return zero;var t=e<0;t&&(e=-e);var a=e>>>0,r=(e-a)/4294967296>>>0;return t&&(r=~r>>>0,a=~a>>>0,++a>4294967295&&(a=0,++r>4294967295&&(r=0))),new LongBits(a,r)},LongBits.from=function(e){if("number"==typeof e)return LongBits.fromNumber(e);if(minimal.isString(e)){if(!minimal.Long)return LongBits.fromNumber(parseInt(e,10));e=minimal.Long.fromString(e)}return e.low||e.high?new LongBits(e.low>>>0,e.high>>>0):zero},LongBits.prototype.toNumber=function(e){if(!e&&this.hi>>>31){var t=1+~this.lo>>>0,a=~this.hi>>>0;return t||(a=a+1>>>0),-(t+4294967296*a)}return this.lo+4294967296*this.hi},LongBits.prototype.toLong=function(e){return minimal.Long?new minimal.Long(0|this.lo,0|this.hi,Boolean(e)):{low:0|this.lo,high:0|this.hi,unsigned:Boolean(e)}};var charCodeAt=String.prototype.charCodeAt;LongBits.fromHash=function(e){return e===zeroHash?zero:new LongBits((charCodeAt.call(e,0)|charCodeAt.call(e,1)<<8|charCodeAt.call(e,2)<<16|charCodeAt.call(e,3)<<24)>>>0,(charCodeAt.call(e,4)|charCodeAt.call(e,5)<<8|charCodeAt.call(e,6)<<16|charCodeAt.call(e,7)<<24)>>>0)},LongBits.prototype.toHash=function(){return String.fromCharCode(255&this.lo,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,255&this.hi,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)},LongBits.prototype.zzEncode=function(){var e=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^e)>>>0,this.lo=(this.lo<<1^e)>>>0,this},LongBits.prototype.zzDecode=function(){var e=-(1&this.lo);return this.lo=((this.lo>>>1|this.hi<<31)^e)>>>0,this.hi=(this.hi>>>1^e)>>>0,this},LongBits.prototype.length=function(){var e=this.lo,t=(this.lo>>>28|this.hi<<4)>>>0,a=this.hi>>>24;return 0===a?0===t?e<16384?e<128?1:2:e<2097152?3:4:t<16384?t<128?5:6:t<2097152?7:8:a<128?9:10};var minimal=createCommonjsModule(function(e,t){var a=t;function r(e,t,a){for(var r=Object.keys(t),n=0;n<r.length;++n)void 0!==e[r[n]]&&a||(e[r[n]]=t[r[n]]);return e}function n(e){function t(e,a){if(!(this instanceof t))return new t(e,a);Object.defineProperty(this,"message",{get:function(){return e}}),Error.captureStackTrace?Error.captureStackTrace(this,t):Object.defineProperty(this,"stack",{value:(new Error).stack||""}),a&&r(this,a)}return(t.prototype=Object.create(Error.prototype)).constructor=t,Object.defineProperty(t.prototype,"name",{get:function(){return e}}),t.prototype.toString=function(){return this.name+": "+this.message},t}a.asPromise=aspromise,a.base64=base64_1,a.EventEmitter=eventemitter,a.float=float_1,a.inquire=inquire_1,a.utf8=utf8_1,a.pool=pool_1,a.LongBits=longbits,a.emptyArray=Object.freeze?Object.freeze([]):[],a.emptyObject=Object.freeze?Object.freeze({}):{},a.isNode=Boolean(commonjsGlobal.process&&commonjsGlobal.process.versions&&commonjsGlobal.process.versions.node),a.isInteger=Number.isInteger||function(e){return"number"==typeof e&&isFinite(e)&&Math.floor(e)===e},a.isString=function(e){return"string"==typeof e||e instanceof String},a.isObject=function(e){return e&&"object"==typeof e},a.isset=a.isSet=function(e,t){var a=e[t];return!(null==a||!e.hasOwnProperty(t))&&("object"!=typeof a||(Array.isArray(a)?a.length:Object.keys(a).length)>0)},a.Buffer=function(){try{var e=a.inquire("buffer").Buffer;return e.prototype.utf8Write?e:null}catch(e){return null}}(),a._Buffer_from=null,a._Buffer_allocUnsafe=null,a.newBuffer=function(e){return"number"==typeof e?a.Buffer?a._Buffer_allocUnsafe(e):new a.Array(e):a.Buffer?a._Buffer_from(e):"undefined"==typeof Uint8Array?e:new Uint8Array(e)},a.Array="undefined"!=typeof Uint8Array?Uint8Array:Array,a.Long=commonjsGlobal.dcodeIO&&commonjsGlobal.dcodeIO.Long||a.inquire("long"),a.key2Re=/^true|false|0|1$/,a.key32Re=/^-?(?:0|[1-9][0-9]*)$/,a.key64Re=/^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/,a.longToHash=function(e){return e?a.LongBits.from(e).toHash():a.LongBits.zeroHash},a.longFromHash=function(e,t){var r=a.LongBits.fromHash(e);return a.Long?a.Long.fromBits(r.lo,r.hi,t):r.toNumber(Boolean(t))},a.merge=r,a.lcFirst=function(e){return e.charAt(0).toLowerCase()+e.substring(1)},a.newError=n,a.ProtocolError=n("ProtocolError"),a.oneOfGetter=function(e){for(var t={},a=0;a<e.length;++a)t[e[a]]=1;return function(){for(var e=Object.keys(this),a=e.length-1;a>-1;--a)if(1===t[e[a]]&&void 0!==this[e[a]]&&null!==this[e[a]])return e[a]}},a.oneOfSetter=function(e){return function(t){for(var a=0;a<e.length;++a)e[a]!==t&&delete this[e[a]]}},a.toJSONOptions={longs:String,enums:String,bytes:String,json:!0},a._configure=function(){var e=a.Buffer;e?(a._Buffer_from=e.from!==Uint8Array.from&&e.from||function(t,a){return new e(t,a)},a._Buffer_allocUnsafe=e.allocUnsafe||function(t){return new e(t)}):a._Buffer_from=a._Buffer_allocUnsafe=null}}),writer=Writer,BufferWriter,LongBits$1=minimal.LongBits,base64=minimal.base64,utf8=minimal.utf8;function Op(e,t,a){this.fn=e,this.len=t,this.next=void 0,this.val=a}function noop(){}function State(e){this.head=e.head,this.tail=e.tail,this.len=e.len,this.next=e.states}function Writer(){this.len=0,this.head=new Op(noop,0,0),this.tail=this.head,this.states=null}function writeByte(e,t,a){t[a]=255&e}function writeVarint32(e,t,a){for(;e>127;)t[a++]=127&e|128,e>>>=7;t[a]=e}function VarintOp(e,t){this.len=e,this.next=void 0,this.val=t}function writeVarint64(e,t,a){for(;e.hi;)t[a++]=127&e.lo|128,e.lo=(e.lo>>>7|e.hi<<25)>>>0,e.hi>>>=7;for(;e.lo>127;)t[a++]=127&e.lo|128,e.lo=e.lo>>>7;t[a++]=e.lo}function writeFixed32(e,t,a){t[a]=255&e,t[a+1]=e>>>8&255,t[a+2]=e>>>16&255,t[a+3]=e>>>24}Writer.create=minimal.Buffer?function(){return(Writer.create=function(){return new BufferWriter})()}:function(){return new Writer},Writer.alloc=function(e){return new minimal.Array(e)},minimal.Array!==Array&&(Writer.alloc=minimal.pool(Writer.alloc,minimal.Array.prototype.subarray)),Writer.prototype._push=function(e,t,a){return this.tail=this.tail.next=new Op(e,t,a),this.len+=t,this},VarintOp.prototype=Object.create(Op.prototype),VarintOp.prototype.fn=writeVarint32,Writer.prototype.uint32=function(e){return this.len+=(this.tail=this.tail.next=new VarintOp((e>>>=0)<128?1:e<16384?2:e<2097152?3:e<268435456?4:5,e)).len,this},Writer.prototype.int32=function(e){return e<0?this._push(writeVarint64,10,LongBits$1.fromNumber(e)):this.uint32(e)},Writer.prototype.sint32=function(e){return this.uint32((e<<1^e>>31)>>>0)},Writer.prototype.uint64=function(e){var t=LongBits$1.from(e);return this._push(writeVarint64,t.length(),t)},Writer.prototype.int64=Writer.prototype.uint64,Writer.prototype.sint64=function(e){var t=LongBits$1.from(e).zzEncode();return this._push(writeVarint64,t.length(),t)},Writer.prototype.bool=function(e){return this._push(writeByte,1,e?1:0)},Writer.prototype.fixed32=function(e){return this._push(writeFixed32,4,e>>>0)},Writer.prototype.sfixed32=Writer.prototype.fixed32,Writer.prototype.fixed64=function(e){var t=LongBits$1.from(e);return this._push(writeFixed32,4,t.lo)._push(writeFixed32,4,t.hi)},Writer.prototype.sfixed64=Writer.prototype.fixed64,Writer.prototype.float=function(e){return this._push(minimal.float.writeFloatLE,4,e)},Writer.prototype.double=function(e){return this._push(minimal.float.writeDoubleLE,8,e)};var writeBytes=minimal.Array.prototype.set?function(e,t,a){t.set(e,a)}:function(e,t,a){for(var r=0;r<e.length;++r)t[a+r]=e[r]};Writer.prototype.bytes=function(e){var t=e.length>>>0;if(!t)return this._push(writeByte,1,0);if(minimal.isString(e)){var a=Writer.alloc(t=base64.length(e));base64.decode(e,a,0),e=a}return this.uint32(t)._push(writeBytes,t,e)},Writer.prototype.string=function(e){var t=utf8.length(e);return t?this.uint32(t)._push(utf8.write,t,e):this._push(writeByte,1,0)},Writer.prototype.fork=function(){return this.states=new State(this),this.head=this.tail=new Op(noop,0,0),this.len=0,this},Writer.prototype.reset=function(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new Op(noop,0,0),this.len=0),this},Writer.prototype.ldelim=function(){var e=this.head,t=this.tail,a=this.len;return this.reset().uint32(a),a&&(this.tail.next=e.next,this.tail=t,this.len+=a),this},Writer.prototype.finish=function(){for(var e=this.head.next,t=this.constructor.alloc(this.len),a=0;e;)e.fn(e.val,t,a),a+=e.len,e=e.next;return t},Writer._configure=function(e){BufferWriter=e};var writer_buffer=BufferWriter$1;(BufferWriter$1.prototype=Object.create(writer.prototype)).constructor=BufferWriter$1;var Buffer=minimal.Buffer;function BufferWriter$1(){writer.call(this)}BufferWriter$1.alloc=function(e){return(BufferWriter$1.alloc=minimal._Buffer_allocUnsafe)(e)};var writeBytesBuffer=Buffer&&Buffer.prototype instanceof Uint8Array&&"set"===Buffer.prototype.set.name?function(e,t,a){t.set(e,a)}:function(e,t,a){if(e.copy)e.copy(t,a,0,e.length);else for(var r=0;r<e.length;)t[a++]=e[r++]};function writeStringBuffer(e,t,a){e.length<40?minimal.utf8.write(e,t,a):t.utf8Write(e,a)}BufferWriter$1.prototype.bytes=function(e){minimal.isString(e)&&(e=minimal._Buffer_from(e,"base64"));var t=e.length>>>0;return this.uint32(t),t&&this._push(writeBytesBuffer,t,e),this},BufferWriter$1.prototype.string=function(e){var t=Buffer.byteLength(e);return this.uint32(t),t&&this._push(writeStringBuffer,t,e),this};var reader=Reader,BufferReader,LongBits$2=minimal.LongBits,utf8$1=minimal.utf8;function indexOutOfRange(e,t){return RangeError("index out of range: "+e.pos+" + "+(t||1)+" > "+e.len)}function Reader(e){this.buf=e,this.pos=0,this.len=e.length}var create_array="undefined"!=typeof Uint8Array?function(e){if(e instanceof Uint8Array||Array.isArray(e))return new Reader(e);throw Error("illegal buffer")}:function(e){if(Array.isArray(e))return new Reader(e);throw Error("illegal buffer")};function readLongVarint(){var e=new LongBits$2(0,0),t=0;if(!(this.len-this.pos>4)){for(;t<3;++t){if(this.pos>=this.len)throw indexOutOfRange(this);if(e.lo=(e.lo|(127&this.buf[this.pos])<<7*t)>>>0,this.buf[this.pos++]<128)return e}return e.lo=(e.lo|(127&this.buf[this.pos++])<<7*t)>>>0,e}for(;t<4;++t)if(e.lo=(e.lo|(127&this.buf[this.pos])<<7*t)>>>0,this.buf[this.pos++]<128)return e;if(e.lo=(e.lo|(127&this.buf[this.pos])<<28)>>>0,e.hi=(e.hi|(127&this.buf[this.pos])>>4)>>>0,this.buf[this.pos++]<128)return e;if(t=0,this.len-this.pos>4){for(;t<5;++t)if(e.hi=(e.hi|(127&this.buf[this.pos])<<7*t+3)>>>0,this.buf[this.pos++]<128)return e}else for(;t<5;++t){if(this.pos>=this.len)throw indexOutOfRange(this);if(e.hi=(e.hi|(127&this.buf[this.pos])<<7*t+3)>>>0,this.buf[this.pos++]<128)return e}throw Error("invalid varint encoding")}function readFixed32_end(e,t){return(e[t-4]|e[t-3]<<8|e[t-2]<<16|e[t-1]<<24)>>>0}function readFixed64(){if(this.pos+8>this.len)throw indexOutOfRange(this,8);return new LongBits$2(readFixed32_end(this.buf,this.pos+=4),readFixed32_end(this.buf,this.pos+=4))}Reader.create=minimal.Buffer?function(e){return(Reader.create=function(e){return minimal.Buffer.isBuffer(e)?new BufferReader(e):create_array(e)})(e)}:create_array,Reader.prototype._slice=minimal.Array.prototype.subarray||minimal.Array.prototype.slice,Reader.prototype.uint32=function(){var e=4294967295;return function(){if(e=(127&this.buf[this.pos])>>>0,this.buf[this.pos++]<128)return e;if(e=(e|(127&this.buf[this.pos])<<7)>>>0,this.buf[this.pos++]<128)return e;if(e=(e|(127&this.buf[this.pos])<<14)>>>0,this.buf[this.pos++]<128)return e;if(e=(e|(127&this.buf[this.pos])<<21)>>>0,this.buf[this.pos++]<128)return e;if(e=(e|(15&this.buf[this.pos])<<28)>>>0,this.buf[this.pos++]<128)return e;if((this.pos+=5)>this.len)throw this.pos=this.len,indexOutOfRange(this,10);return e}}(),Reader.prototype.int32=function(){return 0|this.uint32()},Reader.prototype.sint32=function(){var e=this.uint32();return e>>>1^-(1&e)|0},Reader.prototype.bool=function(){return 0!==this.uint32()},Reader.prototype.fixed32=function(){if(this.pos+4>this.len)throw indexOutOfRange(this,4);return readFixed32_end(this.buf,this.pos+=4)},Reader.prototype.sfixed32=function(){if(this.pos+4>this.len)throw indexOutOfRange(this,4);return 0|readFixed32_end(this.buf,this.pos+=4)},Reader.prototype.float=function(){if(this.pos+4>this.len)throw indexOutOfRange(this,4);var e=minimal.float.readFloatLE(this.buf,this.pos);return this.pos+=4,e},Reader.prototype.double=function(){if(this.pos+8>this.len)throw indexOutOfRange(this,4);var e=minimal.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,e},Reader.prototype.bytes=function(){var e=this.uint32(),t=this.pos,a=this.pos+e;if(a>this.len)throw indexOutOfRange(this,e);return this.pos+=e,Array.isArray(this.buf)?this.buf.slice(t,a):t===a?new this.buf.constructor(0):this._slice.call(this.buf,t,a)},Reader.prototype.string=function(){var e=this.bytes();return utf8$1.read(e,0,e.length)},Reader.prototype.skip=function(e){if("number"==typeof e){if(this.pos+e>this.len)throw indexOutOfRange(this,e);this.pos+=e}else do{if(this.pos>=this.len)throw indexOutOfRange(this)}while(128&this.buf[this.pos++]);return this},Reader.prototype.skipType=function(e){switch(e){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;;){if(4==(e=7&this.uint32()))break;this.skipType(e)}break;case 5:this.skip(4);break;default:throw Error("invalid wire type "+e+" at offset "+this.pos)}return this},Reader._configure=function(e){BufferReader=e;var t=minimal.Long?"toLong":"toNumber";minimal.merge(Reader.prototype,{int64:function(){return readLongVarint.call(this)[t](!1)},uint64:function(){return readLongVarint.call(this)[t](!0)},sint64:function(){return readLongVarint.call(this).zzDecode()[t](!1)},fixed64:function(){return readFixed64.call(this)[t](!0)},sfixed64:function(){return readFixed64.call(this)[t](!1)}})};var reader_buffer=BufferReader$1;function BufferReader$1(e){reader.call(this,e)}(BufferReader$1.prototype=Object.create(reader.prototype)).constructor=BufferReader$1,minimal.Buffer&&(BufferReader$1.prototype._slice=minimal.Buffer.prototype.slice),BufferReader$1.prototype.string=function(){var e=this.uint32();return this.buf.utf8Slice(this.pos,this.pos=Math.min(this.pos+e,this.len))};var service=Service;function Service(e,t,a){if("function"!=typeof e)throw TypeError("rpcImpl must be a function");minimal.EventEmitter.call(this),this.rpcImpl=e,this.requestDelimited=Boolean(t),this.responseDelimited=Boolean(a)}(Service.prototype=Object.create(minimal.EventEmitter.prototype)).constructor=Service,Service.prototype.rpcCall=function e(t,a,r,n,o){if(!n)throw TypeError("request must be specified");var s=this;if(!o)return minimal.asPromise(e,s,t,a,r,n);if(s.rpcImpl)try{return s.rpcImpl(t,a[s.requestDelimited?"encodeDelimited":"encode"](n).finish(),function(e,a){if(e)return s.emit("error",e,t),o(e);if(null!==a){if(!(a instanceof r))try{a=r[s.responseDelimited?"decodeDelimited":"decode"](a)}catch(e){return s.emit("error",e,t),o(e)}return s.emit("data",a,t),o(null,a)}s.end(!0)})}catch(e){return s.emit("error",e,t),void setTimeout(function(){o(e)},0)}else setTimeout(function(){o(Error("already ended"))},0)},Service.prototype.end=function(e){return this.rpcImpl&&(e||this.rpcImpl(null,null,null),this.rpcImpl=null,this.emit("end").off()),this};var rpc_1=createCommonjsModule(function(e,t){t.Service=service}),roots={},indexMinimal=createCommonjsModule(function(e,t){var a=t;function r(){a.Reader._configure(a.BufferReader),a.util._configure()}a.build="minimal",a.Writer=writer,a.BufferWriter=writer_buffer,a.Reader=reader,a.BufferReader=reader_buffer,a.util=minimal,a.rpc=rpc_1,a.roots=roots,a.configure=r,a.Writer._configure(a.BufferWriter),r()}),minimal$1=indexMinimal,minimal_1=minimal$1.roots,minimal_2=minimal$1.Reader,minimal_3=minimal$1.util,$Reader=minimal$1.Reader,$util=minimal$1.util,$root=minimal$1.roots.default||(minimal$1.roots.default={});$root.tensorflow=function(){var e,t,a={};return a.Any=function(){function e(e){if(e)for(var t=Object.keys(e),a=0;a<t.length;++a)null!=e[t[a]]&&(this[t[a]]=e[t[a]])}return e.prototype.typeUrl="",e.prototype.value=$util.newBuffer([]),e.decode=function(e,t){e instanceof $Reader||(e=$Reader.create(e));for(var a=void 0===t?e.len:e.pos+t,r=new $root.tensorflow.Any;e.pos<a;){var n=e.uint32();switch(n>>>3){case 1:r.typeUrl=e.string();break;case 2:r.value=e.bytes();break;default:e.skipType(7&n)}}return r},e}(),a.DataType=(e={},(t=Object.create(e))[e[0]="DT_INVALID"]=0,t[e[1]="DT_FLOAT"]=1,t[e[2]="DT_DOUBLE"]=2,t[e[3]="DT_INT32"]=3,t[e[4]="DT_UINT8"]=4,t[e[5]="DT_INT16"]=5,t[e[6]="DT_INT8"]=6,t[e[7]="DT_STRING"]=7,t[e[8]="DT_COMPLEX64"]=8,t[e[9]="DT_INT64"]=9,t[e[10]="DT_BOOL"]=10,t[e[11]="DT_QINT8"]=11,t[e[12]="DT_QUINT8"]=12,t[e[13]="DT_QINT32"]=13,t[e[14]="DT_BFLOAT16"]=14,t[e[101]="DT_FLOAT_REF"]=101,t[e[102]="DT_DOUBLE_REF"]=102,t[e[103]="DT_INT32_REF"]=103,t[e[104]="DT_UINT8_REF"]=104,t[e[105]="DT_INT16_REF"]=105,t[e[106]="DT_INT8_REF"]=106,t[e[107]="DT_STRING_REF"]=107,t[e[108]="DT_COMPLEX64_REF"]=108,t[e[109]="DT_INT64_REF"]=109,t[e[110]="DT_BOOL_REF"]=110,t[e[111]="DT_QINT8_REF"]=111,t[e[112]="DT_QUINT8_REF"]=112,t[e[113]="DT_QINT32_REF"]=113,t[e[114]="DT_BFLOAT16_REF"]=114,t),a.TensorShape=function(){function e(e){if(this.dim=[],e)for(var t=Object.keys(e),a=0;a<t.length;++a)null!=e[t[a]]&&(this[t[a]]=e[t[a]])}return e.prototype.dim=$util.emptyArray,e.prototype.unknownRank=!1,e.decode=function(e,t){e instanceof $Reader||(e=$Reader.create(e));for(var a=void 0===t?e.len:e.pos+t,r=new $root.tensorflow.TensorShape;e.pos<a;){var n=e.uint32();switch(n>>>3){case 2:r.dim&&r.dim.length||(r.dim=[]),r.dim.push($root.tensorflow.TensorShape.Dim.decode(e,e.uint32()));break;case 3:r.unknownRank=e.bool();break;default:e.skipType(7&n)}}return r},e.Dim=function(){function e(e){if(e)for(var t=Object.keys(e),a=0;a<t.length;++a)null!=e[t[a]]&&(this[t[a]]=e[t[a]])}return e.prototype.size=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.name="",e.decode=function(e,t){e instanceof $Reader||(e=$Reader.create(e));for(var a=void 0===t?e.len:e.pos+t,r=new $root.tensorflow.TensorShape.Dim;e.pos<a;){var n=e.uint32();switch(n>>>3){case 1:r.size=e.int64();break;case 2:r.name=e.string();break;default:e.skipType(7&n)}}return r},e}(),e}(),a.Tensor=function(){function e(e){if(this.floatVal=[],this.doubleVal=[],this.intVal=[],this.stringVal=[],this.scomplexVal=[],this.int64Val=[],this.boolVal=[],this.uint32Val=[],this.uint64Val=[],e)for(var t=Object.keys(e),a=0;a<t.length;++a)null!=e[t[a]]&&(this[t[a]]=e[t[a]])}return e.prototype.dtype=0,e.prototype.tensorShape=null,e.prototype.versionNumber=0,e.prototype.tensorContent=$util.newBuffer([]),e.prototype.floatVal=$util.emptyArray,e.prototype.doubleVal=$util.emptyArray,e.prototype.intVal=$util.emptyArray,e.prototype.stringVal=$util.emptyArray,e.prototype.scomplexVal=$util.emptyArray,e.prototype.int64Val=$util.emptyArray,e.prototype.boolVal=$util.emptyArray,e.prototype.uint32Val=$util.emptyArray,e.prototype.uint64Val=$util.emptyArray,e.decode=function(e,t){e instanceof $Reader||(e=$Reader.create(e));for(var a=void 0===t?e.len:e.pos+t,r=new $root.tensorflow.Tensor;e.pos<a;){var n=e.uint32();switch(n>>>3){case 1:r.dtype=e.int32();break;case 2:r.tensorShape=$root.tensorflow.TensorShape.decode(e,e.uint32());break;case 3:r.versionNumber=e.int32();break;case 4:r.tensorContent=e.bytes();break;case 5:if(r.floatVal&&r.floatVal.length||(r.floatVal=[]),2==(7&n))for(var o=e.uint32()+e.pos;e.pos<o;)r.floatVal.push(e.float());else r.floatVal.push(e.float());break;case 6:if(r.doubleVal&&r.doubleVal.length||(r.doubleVal=[]),2==(7&n))for(o=e.uint32()+e.pos;e.pos<o;)r.doubleVal.push(e.double());else r.doubleVal.push(e.double());break;case 7:if(r.intVal&&r.intVal.length||(r.intVal=[]),2==(7&n))for(o=e.uint32()+e.pos;e.pos<o;)r.intVal.push(e.int32());else r.intVal.push(e.int32());break;case 8:r.stringVal&&r.stringVal.length||(r.stringVal=[]),r.stringVal.push(e.bytes());break;case 9:if(r.scomplexVal&&r.scomplexVal.length||(r.scomplexVal=[]),2==(7&n))for(o=e.uint32()+e.pos;e.pos<o;)r.scomplexVal.push(e.float());else r.scomplexVal.push(e.float());break;case 10:if(r.int64Val&&r.int64Val.length||(r.int64Val=[]),2==(7&n))for(o=e.uint32()+e.pos;e.pos<o;)r.int64Val.push(e.int64());else r.int64Val.push(e.int64());break;case 11:if(r.boolVal&&r.boolVal.length||(r.boolVal=[]),2==(7&n))for(o=e.uint32()+e.pos;e.pos<o;)r.boolVal.push(e.bool());else r.boolVal.push(e.bool());break;case 16:if(r.uint32Val&&r.uint32Val.length||(r.uint32Val=[]),2==(7&n))for(o=e.uint32()+e.pos;e.pos<o;)r.uint32Val.push(e.uint32());else r.uint32Val.push(e.uint32());break;case 17:if(r.uint64Val&&r.uint64Val.length||(r.uint64Val=[]),2==(7&n))for(o=e.uint32()+e.pos;e.pos<o;)r.uint64Val.push(e.uint64());else r.uint64Val.push(e.uint64());break;default:e.skipType(7&n)}}return r},e}(),a.AttrValue=function(){function e(e){if(e)for(var t=Object.keys(e),a=0;a<t.length;++a)null!=e[t[a]]&&(this[t[a]]=e[t[a]])}var t;return e.prototype.list=null,e.prototype.s=$util.newBuffer([]),e.prototype.i=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.f=0,e.prototype.b=!1,e.prototype.type=0,e.prototype.shape=null,e.prototype.tensor=null,e.prototype.placeholder="",e.prototype.func=null,Object.defineProperty(e.prototype,"value",{get:$util.oneOfGetter(t=["list","s","i","f","b","type","shape","tensor","placeholder","func"]),set:$util.oneOfSetter(t)}),e.decode=function(e,t){e instanceof $Reader||(e=$Reader.create(e));for(var a=void 0===t?e.len:e.pos+t,r=new $root.tensorflow.AttrValue;e.pos<a;){var n=e.uint32();switch(n>>>3){case 1:r.list=$root.tensorflow.AttrValue.ListValue.decode(e,e.uint32());break;case 2:r.s=e.bytes();break;case 3:r.i=e.int64();break;case 4:r.f=e.float();break;case 5:r.b=e.bool();break;case 6:r.type=e.int32();break;case 7:r.shape=$root.tensorflow.TensorShape.decode(e,e.uint32());break;case 8:r.tensor=$root.tensorflow.Tensor.decode(e,e.uint32());break;case 9:r.placeholder=e.string();break;case 10:r.func=$root.tensorflow.NameAttrList.decode(e,e.uint32());break;default:e.skipType(7&n)}}return r},e.ListValue=function(){function e(e){if(this.s=[],this.i=[],this.f=[],this.b=[],this.type=[],this.shape=[],this.tensor=[],this.func=[],e)for(var t=Object.keys(e),a=0;a<t.length;++a)null!=e[t[a]]&&(this[t[a]]=e[t[a]])}return e.prototype.s=$util.emptyArray,e.prototype.i=$util.emptyArray,e.prototype.f=$util.emptyArray,e.prototype.b=$util.emptyArray,e.prototype.type=$util.emptyArray,e.prototype.shape=$util.emptyArray,e.prototype.tensor=$util.emptyArray,e.prototype.func=$util.emptyArray,e.decode=function(e,t){e instanceof $Reader||(e=$Reader.create(e));for(var a=void 0===t?e.len:e.pos+t,r=new $root.tensorflow.AttrValue.ListValue;e.pos<a;){var n=e.uint32();switch(n>>>3){case 2:r.s&&r.s.length||(r.s=[]),r.s.push(e.bytes());break;case 3:if(r.i&&r.i.length||(r.i=[]),2==(7&n))for(var o=e.uint32()+e.pos;e.pos<o;)r.i.push(e.int64());else r.i.push(e.int64());break;case 4:if(r.f&&r.f.length||(r.f=[]),2==(7&n))for(o=e.uint32()+e.pos;e.pos<o;)r.f.push(e.float());else r.f.push(e.float());break;case 5:if(r.b&&r.b.length||(r.b=[]),2==(7&n))for(o=e.uint32()+e.pos;e.pos<o;)r.b.push(e.bool());else r.b.push(e.bool());break;case 6:if(r.type&&r.type.length||(r.type=[]),2==(7&n))for(o=e.uint32()+e.pos;e.pos<o;)r.type.push(e.int32());else r.type.push(e.int32());break;case 7:r.shape&&r.shape.length||(r.shape=[]),r.shape.push($root.tensorflow.TensorShape.decode(e,e.uint32()));break;case 8:r.tensor&&r.tensor.length||(r.tensor=[]),r.tensor.push($root.tensorflow.Tensor.decode(e,e.uint32()));break;case 9:r.func&&r.func.length||(r.func=[]),r.func.push($root.tensorflow.NameAttrList.decode(e,e.uint32()));break;default:e.skipType(7&n)}}return r},e}(),e}(),a.NameAttrList=function(){function e(e){if(this.attr={},e)for(var t=Object.keys(e),a=0;a<t.length;++a)null!=e[t[a]]&&(this[t[a]]=e[t[a]])}return e.prototype.name="",e.prototype.attr=$util.emptyObject,e.decode=function(e,t){e instanceof $Reader||(e=$Reader.create(e));for(var a,r=void 0===t?e.len:e.pos+t,n=new $root.tensorflow.NameAttrList;e.pos<r;){var o=e.uint32();switch(o>>>3){case 1:n.name=e.string();break;case 2:e.skip().pos++,n.attr===$util.emptyObject&&(n.attr={}),a=e.string(),e.pos++,n.attr[a]=$root.tensorflow.AttrValue.decode(e,e.uint32());break;default:e.skipType(7&o)}}return n},e}(),a.NodeDef=function(){function e(e){if(this.input=[],this.attr={},e)for(var t=Object.keys(e),a=0;a<t.length;++a)null!=e[t[a]]&&(this[t[a]]=e[t[a]])}return e.prototype.name="",e.prototype.op="",e.prototype.input=$util.emptyArray,e.prototype.device="",e.prototype.attr=$util.emptyObject,e.decode=function(e,t){e instanceof $Reader||(e=$Reader.create(e));for(var a,r=void 0===t?e.len:e.pos+t,n=new $root.tensorflow.NodeDef;e.pos<r;){var o=e.uint32();switch(o>>>3){case 1:n.name=e.string();break;case 2:n.op=e.string();break;case 3:n.input&&n.input.length||(n.input=[]),n.input.push(e.string());break;case 4:n.device=e.string();break;case 5:e.skip().pos++,n.attr===$util.emptyObject&&(n.attr={}),a=e.string(),e.pos++,n.attr[a]=$root.tensorflow.AttrValue.decode(e,e.uint32());break;default:e.skipType(7&o)}}return n},e}(),a.VersionDef=function(){function e(e){if(this.badConsumers=[],e)for(var t=Object.keys(e),a=0;a<t.length;++a)null!=e[t[a]]&&(this[t[a]]=e[t[a]])}return e.prototype.producer=0,e.prototype.minConsumer=0,e.prototype.badConsumers=$util.emptyArray,e.decode=function(e,t){e instanceof $Reader||(e=$Reader.create(e));for(var a=void 0===t?e.len:e.pos+t,r=new $root.tensorflow.VersionDef;e.pos<a;){var n=e.uint32();switch(n>>>3){case 1:r.producer=e.int32();break;case 2:r.minConsumer=e.int32();break;case 3:if(r.badConsumers&&r.badConsumers.length||(r.badConsumers=[]),2==(7&n))for(var o=e.uint32()+e.pos;e.pos<o;)r.badConsumers.push(e.int32());else r.badConsumers.push(e.int32());break;default:e.skipType(7&n)}}return r},e}(),a.GraphDef=function(){function e(e){if(this.node=[],e)for(var t=Object.keys(e),a=0;a<t.length;++a)null!=e[t[a]]&&(this[t[a]]=e[t[a]])}return e.prototype.node=$util.emptyArray,e.prototype.versions=null,e.prototype.library=null,e.decode=function(e,t){e instanceof $Reader||(e=$Reader.create(e));for(var a=void 0===t?e.len:e.pos+t,r=new $root.tensorflow.GraphDef;e.pos<a;){var n=e.uint32();switch(n>>>3){case 1:r.node&&r.node.length||(r.node=[]),r.node.push($root.tensorflow.NodeDef.decode(e,e.uint32()));break;case 4:r.versions=$root.tensorflow.VersionDef.decode(e,e.uint32());break;case 2:r.library=$root.tensorflow.FunctionDefLibrary.decode(e,e.uint32());break;default:e.skipType(7&n)}}return r},e}(),a.CollectionDef=function(){function e(e){if(e)for(var t=Object.keys(e),a=0;a<t.length;++a)null!=e[t[a]]&&(this[t[a]]=e[t[a]])}var t;return e.prototype.nodeList=null,e.prototype.bytesList=null,e.prototype.int64List=null,e.prototype.floatList=null,e.prototype.anyList=null,Object.defineProperty(e.prototype,"kind",{get:$util.oneOfGetter(t=["nodeList","bytesList","int64List","floatList","anyList"]),set:$util.oneOfSetter(t)}),e.decode=function(e,t){e instanceof $Reader||(e=$Reader.create(e));for(var a=void 0===t?e.len:e.pos+t,r=new $root.tensorflow.CollectionDef;e.pos<a;){var n=e.uint32();switch(n>>>3){case 1:r.nodeList=$root.tensorflow.CollectionDef.NodeList.decode(e,e.uint32());break;case 2:r.bytesList=$root.tensorflow.CollectionDef.BytesList.decode(e,e.uint32());break;case 3:r.int64List=$root.tensorflow.CollectionDef.Int64List.decode(e,e.uint32());break;case 4:r.floatList=$root.tensorflow.CollectionDef.FloatList.decode(e,e.uint32());break;case 5:r.anyList=$root.tensorflow.CollectionDef.AnyList.decode(e,e.uint32());break;default:e.skipType(7&n)}}return r},e.NodeList=function(){function e(e){if(this.value=[],e)for(var t=Object.keys(e),a=0;a<t.length;++a)null!=e[t[a]]&&(this[t[a]]=e[t[a]])}return e.prototype.value=$util.emptyArray,e.decode=function(e,t){e instanceof $Reader||(e=$Reader.create(e));for(var a=void 0===t?e.len:e.pos+t,r=new $root.tensorflow.CollectionDef.NodeList;e.pos<a;){var n=e.uint32();switch(n>>>3){case 1:r.value&&r.value.length||(r.value=[]),r.value.push(e.string());break;default:e.skipType(7&n)}}return r},e}(),e.BytesList=function(){function e(e){if(this.value=[],e)for(var t=Object.keys(e),a=0;a<t.length;++a)null!=e[t[a]]&&(this[t[a]]=e[t[a]])}return e.prototype.value=$util.emptyArray,e.decode=function(e,t){e instanceof $Reader||(e=$Reader.create(e));for(var a=void 0===t?e.len:e.pos+t,r=new $root.tensorflow.CollectionDef.BytesList;e.pos<a;){var n=e.uint32();switch(n>>>3){case 1:r.value&&r.value.length||(r.value=[]),r.value.push(e.bytes());break;default:e.skipType(7&n)}}return r},e}(),e.Int64List=function(){function e(e){if(this.value=[],e)for(var t=Object.keys(e),a=0;a<t.length;++a)null!=e[t[a]]&&(this[t[a]]=e[t[a]])}return e.prototype.value=$util.emptyArray,e.decode=function(e,t){e instanceof $Reader||(e=$Reader.create(e));for(var a=void 0===t?e.len:e.pos+t,r=new $root.tensorflow.CollectionDef.Int64List;e.pos<a;){var n=e.uint32();switch(n>>>3){case 1:if(r.value&&r.value.length||(r.value=[]),2==(7&n))for(var o=e.uint32()+e.pos;e.pos<o;)r.value.push(e.int64());else r.value.push(e.int64());break;default:e.skipType(7&n)}}return r},e}(),e.FloatList=function(){function e(e){if(this.value=[],e)for(var t=Object.keys(e),a=0;a<t.length;++a)null!=e[t[a]]&&(this[t[a]]=e[t[a]])}return e.prototype.value=$util.emptyArray,e.decode=function(e,t){e instanceof $Reader||(e=$Reader.create(e));for(var a=void 0===t?e.len:e.pos+t,r=new $root.tensorflow.CollectionDef.FloatList;e.pos<a;){var n=e.uint32();switch(n>>>3){case 1:if(r.value&&r.value.length||(r.value=[]),2==(7&n))for(var o=e.uint32()+e.pos;e.pos<o;)r.value.push(e.float());else r.value.push(e.float());break;default:e.skipType(7&n)}}return r},e}(),e.AnyList=function(){function e(e){if(this.value=[],e)for(var t=Object.keys(e),a=0;a<t.length;++a)null!=e[t[a]]&&(this[t[a]]=e[t[a]])}return e.prototype.value=$util.emptyArray,e.decode=function(e,t){e instanceof $Reader||(e=$Reader.create(e));for(var a=void 0===t?e.len:e.pos+t,r=new $root.tensorflow.CollectionDef.AnyList;e.pos<a;){var n=e.uint32();switch(n>>>3){case 1:r.value&&r.value.length||(r.value=[]),r.value.push($root.tensorflow.Any.decode(e,e.uint32()));break;default:e.skipType(7&n)}}return r},e}(),e}(),a.SaverDef=function(){function e(e){if(e)for(var t=Object.keys(e),a=0;a<t.length;++a)null!=e[t[a]]&&(this[t[a]]=e[t[a]])}var t,a;return e.prototype.filenameTensorName="",e.prototype.saveTensorName="",e.prototype.restoreOpName="",e.prototype.maxToKeep=0,e.prototype.sharded=!1,e.prototype.keepCheckpointEveryNHours=0,e.prototype.version=0,e.decode=function(e,t){e instanceof $Reader||(e=$Reader.create(e));for(var a=void 0===t?e.len:e.pos+t,r=new $root.tensorflow.SaverDef;e.pos<a;){var n=e.uint32();switch(n>>>3){case 1:r.filenameTensorName=e.string();break;case 2:r.saveTensorName=e.string();break;case 3:r.restoreOpName=e.string();break;case 4:r.maxToKeep=e.int32();break;case 5:r.sharded=e.bool();break;case 6:r.keepCheckpointEveryNHours=e.float();break;case 7:r.version=e.int32();break;default:e.skipType(7&n)}}return r},e.CheckpointFormatVersion=(t={},(a=Object.create(t))[t[0]="LEGACY"]=0,a[t[1]="V1"]=1,a[t[2]="V2"]=2,a),e}(),a.TensorInfo=function(){function e(e){if(e)for(var t=Object.keys(e),a=0;a<t.length;++a)null!=e[t[a]]&&(this[t[a]]=e[t[a]])}var t;return e.prototype.name="",e.prototype.cooSparse=null,e.prototype.dtype=0,e.prototype.tensorShape=null,Object.defineProperty(e.prototype,"encoding",{get:$util.oneOfGetter(t=["name","cooSparse"]),set:$util.oneOfSetter(t)}),e.decode=function(e,t){e instanceof $Reader||(e=$Reader.create(e));for(var a=void 0===t?e.len:e.pos+t,r=new $root.tensorflow.TensorInfo;e.pos<a;){var n=e.uint32();switch(n>>>3){case 1:r.name=e.string();break;case 4:r.cooSparse=$root.tensorflow.TensorInfo.CooSparse.decode(e,e.uint32());break;case 2:r.dtype=e.int32();break;case 3:r.tensorShape=$root.tensorflow.TensorShape.decode(e,e.uint32());break;default:e.skipType(7&n)}}return r},e.CooSparse=function(){function e(e){if(e)for(var t=Object.keys(e),a=0;a<t.length;++a)null!=e[t[a]]&&(this[t[a]]=e[t[a]])}return e.prototype.valuesTensorName="",e.prototype.indicesTensorName="",e.prototype.denseShapeTensorName="",e.decode=function(e,t){e instanceof $Reader||(e=$Reader.create(e));for(var a=void 0===t?e.len:e.pos+t,r=new $root.tensorflow.TensorInfo.CooSparse;e.pos<a;){var n=e.uint32();switch(n>>>3){case 1:r.valuesTensorName=e.string();break;case 2:r.indicesTensorName=e.string();break;case 3:r.denseShapeTensorName=e.string();break;default:e.skipType(7&n)}}return r},e}(),e}(),a.SignatureDef=function(){function e(e){if(this.inputs={},this.outputs={},e)for(var t=Object.keys(e),a=0;a<t.length;++a)null!=e[t[a]]&&(this[t[a]]=e[t[a]])}return e.prototype.inputs=$util.emptyObject,e.prototype.outputs=$util.emptyObject,e.prototype.methodName="",e.decode=function(e,t){e instanceof $Reader||(e=$Reader.create(e));for(var a,r=void 0===t?e.len:e.pos+t,n=new $root.tensorflow.SignatureDef;e.pos<r;){var o=e.uint32();switch(o>>>3){case 1:e.skip().pos++,n.inputs===$util.emptyObject&&(n.inputs={}),a=e.string(),e.pos++,n.inputs[a]=$root.tensorflow.TensorInfo.decode(e,e.uint32());break;case 2:e.skip().pos++,n.outputs===$util.emptyObject&&(n.outputs={}),a=e.string(),e.pos++,n.outputs[a]=$root.tensorflow.TensorInfo.decode(e,e.uint32());break;case 3:n.methodName=e.string();break;default:e.skipType(7&o)}}return n},e}(),a.AssetFileDef=function(){function e(e){if(e)for(var t=Object.keys(e),a=0;a<t.length;++a)null!=e[t[a]]&&(this[t[a]]=e[t[a]])}return e.prototype.tensorInfo=null,e.prototype.filename="",e.decode=function(e,t){e instanceof $Reader||(e=$Reader.create(e));for(var a=void 0===t?e.len:e.pos+t,r=new $root.tensorflow.AssetFileDef;e.pos<a;){var n=e.uint32();switch(n>>>3){case 1:r.tensorInfo=$root.tensorflow.TensorInfo.decode(e,e.uint32());break;case 2:r.filename=e.string();break;default:e.skipType(7&n)}}return r},e}(),a.OpDef=function(){function e(e){if(this.inputArg=[],this.outputArg=[],this.attr=[],e)for(var t=Object.keys(e),a=0;a<t.length;++a)null!=e[t[a]]&&(this[t[a]]=e[t[a]])}return e.prototype.name="",e.prototype.inputArg=$util.emptyArray,e.prototype.outputArg=$util.emptyArray,e.prototype.attr=$util.emptyArray,e.prototype.deprecation=null,e.prototype.summary="",e.prototype.description="",e.prototype.isCommutative=!1,e.prototype.isAggregate=!1,e.prototype.isStateful=!1,e.prototype.allowsUninitializedInput=!1,e.decode=function(e,t){e instanceof $Reader||(e=$Reader.create(e));for(var a=void 0===t?e.len:e.pos+t,r=new $root.tensorflow.OpDef;e.pos<a;){var n=e.uint32();switch(n>>>3){case 1:r.name=e.string();break;case 2:r.inputArg&&r.inputArg.length||(r.inputArg=[]),r.inputArg.push($root.tensorflow.OpDef.ArgDef.decode(e,e.uint32()));break;case 3:r.outputArg&&r.outputArg.length||(r.outputArg=[]),r.outputArg.push($root.tensorflow.OpDef.ArgDef.decode(e,e.uint32()));break;case 4:r.attr&&r.attr.length||(r.attr=[]),r.attr.push($root.tensorflow.OpDef.AttrDef.decode(e,e.uint32()));break;case 8:r.deprecation=$root.tensorflow.OpDef.OpDeprecation.decode(e,e.uint32());break;case 5:r.summary=e.string();break;case 6:r.description=e.string();break;case 18:r.isCommutative=e.bool();break;case 16:r.isAggregate=e.bool();break;case 17:r.isStateful=e.bool();break;case 19:r.allowsUninitializedInput=e.bool();break;default:e.skipType(7&n)}}return r},e.ArgDef=function(){function e(e){if(e)for(var t=Object.keys(e),a=0;a<t.length;++a)null!=e[t[a]]&&(this[t[a]]=e[t[a]])}return e.prototype.name="",e.prototype.description="",e.prototype.type=0,e.prototype.typeAttr="",e.prototype.numberAttr="",e.prototype.typeListAttr="",e.prototype.isRef=!1,e.decode=function(e,t){e instanceof $Reader||(e=$Reader.create(e));for(var a=void 0===t?e.len:e.pos+t,r=new $root.tensorflow.OpDef.ArgDef;e.pos<a;){var n=e.uint32();switch(n>>>3){case 1:r.name=e.string();break;case 2:r.description=e.string();break;case 3:r.type=e.int32();break;case 4:r.typeAttr=e.string();break;case 5:r.numberAttr=e.string();break;case 6:r.typeListAttr=e.string();break;case 16:r.isRef=e.bool();break;default:e.skipType(7&n)}}return r},e}(),e.AttrDef=function(){function e(e){if(e)for(var t=Object.keys(e),a=0;a<t.length;++a)null!=e[t[a]]&&(this[t[a]]=e[t[a]])}return e.prototype.name="",e.prototype.type="",e.prototype.defaultValue=null,e.prototype.description="",e.prototype.hasMinimum=!1,e.prototype.minimum=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.allowedValues=null,e.decode=function(e,t){e instanceof $Reader||(e=$Reader.create(e));for(var a=void 0===t?e.len:e.pos+t,r=new $root.tensorflow.OpDef.AttrDef;e.pos<a;){var n=e.uint32();switch(n>>>3){case 1:r.name=e.string();break;case 2:r.type=e.string();break;case 3:r.defaultValue=$root.tensorflow.AttrValue.decode(e,e.uint32());break;case 4:r.description=e.string();break;case 5:r.hasMinimum=e.bool();break;case 6:r.minimum=e.int64();break;case 7:r.allowedValues=$root.tensorflow.AttrValue.decode(e,e.uint32());break;default:e.skipType(7&n)}}return r},e}(),e.OpDeprecation=function(){function e(e){if(e)for(var t=Object.keys(e),a=0;a<t.length;++a)null!=e[t[a]]&&(this[t[a]]=e[t[a]])}return e.prototype.version=0,e.prototype.explanation="",e.decode=function(e,t){e instanceof $Reader||(e=$Reader.create(e));for(var a=void 0===t?e.len:e.pos+t,r=new $root.tensorflow.OpDef.OpDeprecation;e.pos<a;){var n=e.uint32();switch(n>>>3){case 1:r.version=e.int32();break;case 2:r.explanation=e.string();break;default:e.skipType(7&n)}}return r},e}(),e}(),a.OpList=function(){function e(e){if(this.op=[],e)for(var t=Object.keys(e),a=0;a<t.length;++a)null!=e[t[a]]&&(this[t[a]]=e[t[a]])}return e.prototype.op=$util.emptyArray,e.decode=function(e,t){e instanceof $Reader||(e=$Reader.create(e));for(var a=void 0===t?e.len:e.pos+t,r=new $root.tensorflow.OpList;e.pos<a;){var n=e.uint32();switch(n>>>3){case 1:r.op&&r.op.length||(r.op=[]),r.op.push($root.tensorflow.OpDef.decode(e,e.uint32()));break;default:e.skipType(7&n)}}return r},e}(),a.MetaGraphDef=function(){function e(e){if(this.collectionDef={},this.signatureDef={},this.assetFileDef=[],e)for(var t=Object.keys(e),a=0;a<t.length;++a)null!=e[t[a]]&&(this[t[a]]=e[t[a]])}return e.prototype.metaInfoDef=null,e.prototype.graphDef=null,e.prototype.saverDef=null,e.prototype.collectionDef=$util.emptyObject,e.prototype.signatureDef=$util.emptyObject,e.prototype.assetFileDef=$util.emptyArray,e.decode=function(e,t){e instanceof $Reader||(e=$Reader.create(e));for(var a,r=void 0===t?e.len:e.pos+t,n=new $root.tensorflow.MetaGraphDef;e.pos<r;){var o=e.uint32();switch(o>>>3){case 1:n.metaInfoDef=$root.tensorflow.MetaGraphDef.MetaInfoDef.decode(e,e.uint32());break;case 2:n.graphDef=$root.tensorflow.GraphDef.decode(e,e.uint32());break;case 3:n.saverDef=$root.tensorflow.SaverDef.decode(e,e.uint32());break;case 4:e.skip().pos++,n.collectionDef===$util.emptyObject&&(n.collectionDef={}),a=e.string(),e.pos++,n.collectionDef[a]=$root.tensorflow.CollectionDef.decode(e,e.uint32());break;case 5:e.skip().pos++,n.signatureDef===$util.emptyObject&&(n.signatureDef={}),a=e.string(),e.pos++,n.signatureDef[a]=$root.tensorflow.SignatureDef.decode(e,e.uint32());break;case 6:n.assetFileDef&&n.assetFileDef.length||(n.assetFileDef=[]),n.assetFileDef.push($root.tensorflow.AssetFileDef.decode(e,e.uint32()));break;default:e.skipType(7&o)}}return n},e.MetaInfoDef=function(){function e(e){if(this.tags=[],e)for(var t=Object.keys(e),a=0;a<t.length;++a)null!=e[t[a]]&&(this[t[a]]=e[t[a]])}return e.prototype.metaGraphVersion="",e.prototype.strippedOpList=null,e.prototype.anyInfo=null,e.prototype.tags=$util.emptyArray,e.prototype.tensorflowVersion="",e.prototype.tensorflowGitVersion="",e.decode=function(e,t){e instanceof $Reader||(e=$Reader.create(e));for(var a=void 0===t?e.len:e.pos+t,r=new $root.tensorflow.MetaGraphDef.MetaInfoDef;e.pos<a;){var n=e.uint32();switch(n>>>3){case 1:r.metaGraphVersion=e.string();break;case 2:r.strippedOpList=$root.tensorflow.OpList.decode(e,e.uint32());break;case 3:r.anyInfo=$root.tensorflow.Any.decode(e,e.uint32());break;case 4:r.tags&&r.tags.length||(r.tags=[]),r.tags.push(e.string());break;case 5:r.tensorflowVersion=e.string();break;case 6:r.tensorflowGitVersion=e.string();break;default:e.skipType(7&n)}}return r},e}(),e}(),a.SavedModel=function(){function e(e){if(this.metaGraphs=[],e)for(var t=Object.keys(e),a=0;a<t.length;++a)null!=e[t[a]]&&(this[t[a]]=e[t[a]])}return e.prototype.savedModelSchemaVersion=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.metaGraphs=$util.emptyArray,e.decode=function(e,t){e instanceof $Reader||(e=$Reader.create(e));for(var a=void 0===t?e.len:e.pos+t,r=new $root.tensorflow.SavedModel;e.pos<a;){var n=e.uint32();switch(n>>>3){case 1:r.savedModelSchemaVersion=e.int64();break;case 2:r.metaGraphs&&r.metaGraphs.length||(r.metaGraphs=[]),r.metaGraphs.push($root.tensorflow.MetaGraphDef.decode(e,e.uint32()));break;default:e.skipType(7&n)}}return r},e}(),a.FunctionDefLibrary=function(){function e(e){if(this.function=[],this.gradient=[],e)for(var t=Object.keys(e),a=0;a<t.length;++a)null!=e[t[a]]&&(this[t[a]]=e[t[a]])}return e.prototype.function=$util.emptyArray,e.prototype.gradient=$util.emptyArray,e.decode=function(e,t){e instanceof $Reader||(e=$Reader.create(e));for(var a=void 0===t?e.len:e.pos+t,r=new $root.tensorflow.FunctionDefLibrary;e.pos<a;){var n=e.uint32();switch(n>>>3){case 1:r.function&&r.function.length||(r.function=[]),r.function.push($root.tensorflow.FunctionDef.decode(e,e.uint32()));break;case 2:r.gradient&&r.gradient.length||(r.gradient=[]),r.gradient.push($root.tensorflow.GradientDef.decode(e,e.uint32()));break;default:e.skipType(7&n)}}return r},e}(),a.FunctionDef=function(){function e(e){if(this.attr={},this.nodeDef=[],this.ret={},e)for(var t=Object.keys(e),a=0;a<t.length;++a)null!=e[t[a]]&&(this[t[a]]=e[t[a]])}return e.prototype.signature=null,e.prototype.attr=$util.emptyObject,e.prototype.nodeDef=$util.emptyArray,e.prototype.ret=$util.emptyObject,e.decode=function(e,t){e instanceof $Reader||(e=$Reader.create(e));for(var a,r=void 0===t?e.len:e.pos+t,n=new $root.tensorflow.FunctionDef;e.pos<r;){var o=e.uint32();switch(o>>>3){case 1:n.signature=$root.tensorflow.OpDef.decode(e,e.uint32());break;case 5:e.skip().pos++,n.attr===$util.emptyObject&&(n.attr={}),a=e.string(),e.pos++,n.attr[a]=$root.tensorflow.AttrValue.decode(e,e.uint32());break;case 3:n.nodeDef&&n.nodeDef.length||(n.nodeDef=[]),n.nodeDef.push($root.tensorflow.NodeDef.decode(e,e.uint32()));break;case 4:e.skip().pos++,n.ret===$util.emptyObject&&(n.ret={}),a=e.string(),e.pos++,n.ret[a]=e.string();break;default:e.skipType(7&o)}}return n},e}(),a.GradientDef=function(){function e(e){if(e)for(var t=Object.keys(e),a=0;a<t.length;++a)null!=e[t[a]]&&(this[t[a]]=e[t[a]])}return e.prototype.functionName="",e.prototype.gradientFunc="",e.decode=function(e,t){e instanceof $Reader||(e=$Reader.create(e));for(var a=void 0===t?e.len:e.pos+t,r=new $root.tensorflow.GradientDef;e.pos<a;){var n=e.uint32();switch(n>>>3){case 1:r.functionName=e.string();break;case 2:r.gradientFunc=e.string();break;default:e.skipType(7&n)}}return r},e}(),a}();var compiled_api=$root,compiled_api_1=compiled_api.tensorflow;function getParamValue(e,t,a,r){var n=t.params[e];if(n&&void 0!==n.inputIndex){if("tensor"===n.type)return getTensor(t.inputNames[n.inputIndex],a,r);if("tensors"===n.type)return(0===n.inputIndex?0===n.inputParamLength?t.inputNames:t.inputNames.slice(n.inputIndex,-n.inputParamLength):t.inputNames.splice(n.inputIndex)).map(function(e){return getTensor(e,a,r)});var o=Array.prototype.slice.call(getTensor(t.inputNames.slice(n.inputIndex)[0],a,r).dataSync());return"number"===n.type?o[0]:o}return n&&n.value}function getTensor(e,t,a){var r=parseNodeName(e),n=r[0],o=r[1],s=a.currentContextIds.find(function(e){return!!t[getNodeNameWithContextId(n,e)]});return void 0!==s?t[getNodeNameWithContextId(n,s)][o]:void 0}function getTensorsForCurrentContenxt(e,t,a){return t[getNodeNameWithContextId(e,a.currentContextId)]}function getNodeNameAndIndex(e,t){var a=parseNodeName(e),r=a[0],n=a[1];return[getNodeNameWithContextId(r,t&&t.currentContextId),n]}function getNodeNameWithContextId(e,t){return t?e+"-"+t:e}function parseNodeName(e){var t=e.lastIndexOf(":");return-1===t?[e,0]:[e.substring(0,t),Number(e.substring(t+1))]}function split$1(e,t){for(var a=[],r=0;r<e.length;r+=t)a.push(e.slice(r,r+t));return a}var json=[{tfOpName:"Add",dlOpName:"add",category:"arithmetic",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",dlOpName:"addN",category:"arithmetic",params:[{tfInputIndex:0,tfInputParamLength:0,dlParamName:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",dlOpName:"add",category:"arithmetic",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sub",dlOpName:"sub",category:"arithmetic",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",dlOpName:"div",category:"arithmetic",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",dlOpName:"div",category:"arithmetic",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",dlOpName:"floorDiv",category:"arithmetic",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",dlOpName:"mul",category:"arithmetic",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",dlOpName:"maximum",category:"arithmetic",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"}]},{tfOpName:"Minimum",dlOpName:"minimum",category:"arithmetic",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"}]},{tfOpName:"Pow",dlOpName:"pow",category:"arithmetic",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",dlOpName:"squaredDifference",category:"arithmetic",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",dlOpName:"mod",category:"arithmetic",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",dlOpName:"mod",category:"arithmetic",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]}],arithmetic=Object.freeze({json:json}),json$1=[{tfOpName:"Abs",dlOpName:"abs",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",dlOpName:"acos",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",dlOpName:"asin",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",dlOpName:"atan",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",dlOpName:"atan2",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"y",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",dlOpName:"ceil",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",dlOpName:"clipByValue",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"clip_value_min",dlParamName:"clipValueMin",type:"number"},{tfParamName:"clip_value_max",dlParamName:"clipValueMax",type:"number"}]},{tfOpName:"Cos",dlOpName:"cos",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",dlOpName:"cosh",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",dlOpName:"elu",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",dlOpName:"exp",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",dlOpName:"floor",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",dlOpName:"log",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",dlOpName:"neg",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",dlOpName:"relu",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",dlOpName:"clipByValue",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0},{dlParamName:"clipValueMin",type:"number",defaultValue:0},{dlParamName:"clipValueMax",type:"number",defaultValue:6}]},{tfOpName:"Selu",dlOpName:"selu",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",dlOpName:"sigmoid",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",dlOpName:"sin",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",dlOpName:"sinh",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",dlOpName:"sqrt",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",dlOpName:"rsqrt",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",dlOpName:"square",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",dlOpName:"tan",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",dlOpName:"tanh",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",dlOpName:"sign",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",dlOpName:"round",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",dlOpName:"expm1",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",dlOpName:"log1p",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",dlOpName:"reciprocal",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",dlOpName:"reciprocal",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",dlOpName:"softplus",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",dlOpName:"asinh",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",dlOpName:"acosh",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",dlOpName:"atanh",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",dlOpName:"erf",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",dlOpName:"prod",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"axes",type:"number[]"},{tfParamName:"keep_dims",dlParamName:"keepDims",type:"bool",notSupported:!0},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",dlOpName:"leakyRelu",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"alpha",dlParamName:"alpha",type:"number",defaultValue:.2},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]}],basicMath=Object.freeze({json:json$1}),json$2=[{tfOpName:"LoopCond",dlOpName:"loopCond",category:"control",params:[{tfInputIndex:0,dlParamName:"pred",type:"tensor"}]},{tfOpName:"Switch",dlOpName:"switch",category:"control",params:[{tfInputIndex:0,dlParamName:"data",type:"tensor"},{tfInputIndex:1,dlParamName:"pred",type:"tensor"}]},{tfOpName:"Merge",dlOpName:"merge",category:"control",params:[{tfInputIndex:0,tfInputParamLength:0,dlParamName:"tensors",type:"tensors"}]},{tfOpName:"Enter",dlOpName:"enter",category:"control",params:[{tfInputIndex:0,dlParamName:"tensor",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0},{tfParamName:"frame_name",dlParamName:"frameName",type:"string"},{tfParamName:"is_constant",dlParamName:"isConstant",type:"bool"}]},{tfOpName:"Exit",dlOpName:"exit",category:"control",params:[{tfInputIndex:0,dlParamName:"tensor",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",dlOpName:"nextIteration",category:"control",params:[{tfInputIndex:0,dlParamName:"tensor",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",dlOpName:"tensorArray",category:"control",params:[{tfInputIndex:0,dlParamName:"size",type:"number"},{tfParamName:"dtype",dlParamName:"dtype",type:"dtype"},{tfParamName:"element_shape",dlParamName:"elementShape",type:"shape"},{tfParamName:"dynamic_size",dlParamName:"dynamicSize",type:"bool"},{tfParamName:"clear_after_read",dlParamName:"clearAfterRead",type:"bool"},{tfParamName:"identical_element_shapes",dlParamName:"identicalElementShapes",type:"bool"},{tfParamName:"tensor_array_name",dlParamName:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",dlOpName:"tensorArrayWrite",category:"control",params:[{tfInputIndex:0,dlParamName:"tensorArrayId",type:"number"},{tfInputIndex:1,dlParamName:"index",type:"number"},{tfInputIndex:2,dlParamName:"tensor",type:"tensor"},{tfInputIndex:3,dlParamName:"flowIn",type:"number"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",dlOpName:"tensorArrayRead",category:"control",params:[{tfInputIndex:0,dlParamName:"tensorArrayId",type:"number"},{tfInputIndex:1,dlParamName:"index",type:"number"},{tfInputIndex:2,dlParamName:"flowIn",type:"number"},{tfParamName:"dtype",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",dlOpName:"tensorArrayGather",category:"control",params:[{tfInputIndex:0,dlParamName:"tensorArrayId",type:"number"},{tfInputIndex:1,dlParamName:"indices",type:"number[]"},{tfInputIndex:2,dlParamName:"flowIn",type:"number"},{tfParamName:"dtype",dlParamName:"dtype",type:"dtype"},{tfParamName:"element_shape",dlParamName:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",dlOpName:"tensorArrayScatter",category:"control",params:[{tfInputIndex:0,dlParamName:"tensorArrayId",type:"number"},{tfInputIndex:1,dlParamName:"indices",type:"number[]"},{tfInputIndex:2,dlParamName:"tensor",type:"tensor"},{tfInputIndex:3,dlParamName:"flowIn",type:"number"},{tfParamName:"T",dlParamName:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",dlOpName:"tensorArrayConcat",category:"control",params:[{tfInputIndex:0,dlParamName:"tensorArrayId",type:"number"},{tfInputIndex:1,dlParamName:"flowIn",type:"number"},{tfParamName:"dtype",dlParamName:"dtype",type:"dtype"},{tfParamName:"element_shape_except0",dlParamName:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",dlOpName:"tensorArraySplit",category:"control",params:[{tfInputIndex:0,dlParamName:"tensorArrayId",type:"number"},{tfInputIndex:1,dlParamName:"tensor",type:"tensor"},{tfInputIndex:2,dlParamName:"lengths",type:"number[]"},{tfInputIndex:3,dlParamName:"flowIn",type:"number"},{tfParamName:"T",dlParamName:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",dlOpName:"tensorArraySize",category:"control",params:[{tfInputIndex:0,dlParamName:"tensorArrayId",type:"number"},{tfInputIndex:1,dlParamName:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",dlOpName:"tensorArrayClose",category:"control",params:[{tfInputIndex:0,dlParamName:"tensorArrayId",type:"number"}]}],control=Object.freeze({json:json$2}),json$3=[{tfOpName:"AvgPool",dlOpName:"avgPool",category:"convolution",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"strides",dlParamName:"strides",type:"number[]"},{tfParamName:"padding",dlParamName:"pad",type:"string"},{tfParamName:"data_format",dlParamName:"dataFormat",type:"string",notSupported:!0},{tfParamName:"ksize",dlParamName:"kernelSize",type:"number[]"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",dlOpName:"maxPool",category:"convolution",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"strides",dlParamName:"strides",type:"number[]"},{tfParamName:"padding",dlParamName:"pad",type:"string"},{tfParamName:"data_format",dlParamName:"dataFormat",type:"string",notSupported:!0},{tfParamName:"ksize",dlParamName:"kernelSize",type:"number[]"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",dlOpName:"conv1d",category:"convolution",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"filter",type:"tensor"},{tfParamName:"stride",dlParamName:"stride",type:"number"},{tfParamName:"padding",dlParamName:"pad",type:"string"},{tfParamName:"data_format",dlParamName:"dataFormat",type:"string",defaultValue:"NWC"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0},{tfParamName:"dilation",dlParamName:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",dlOpName:"conv2d",category:"convolution",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"filter",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0},{tfParamName:"strides",dlParamName:"strides",type:"number[]"},{tfParamName:"padding",dlParamName:"pad",type:"string"},{tfParamName:"useCudnnOnGpu",dlParamName:"useCudnnOnGpu",type:"bool"},{tfParamName:"data_format",dlParamName:"dataFormat",type:"string",defaultValue:"NHWC"},{tfParamName:"dilations",dlParamName:"dilations",type:"number[]"}]},{tfOpName:"Conv2DBackpropInput",dlOpName:"conv2dTranspose",category:"convolution",params:[{tfInputIndex:2,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"filter",type:"tensor"},{tfInputIndex:0,dlParamName:"outputShape",type:"number[]"},{tfParamName:"strides",dlParamName:"strides",type:"number[]"},{tfParamName:"padding",dlParamName:"pad",type:"string"},{tfParamName:"data_format",dlParamName:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",dlOpName:"depthwiseConv2d",category:"convolution",params:[{tfInputIndex:0,dlParamName:"input",type:"tensor"},{tfInputIndex:1,dlParamName:"filter",type:"tensor"},{tfParamName:"strides",dlParamName:"strides",type:"number[]"},{tfParamName:"padding",dlParamName:"pad",type:"string"},{tfParamName:"data_format",dlParamName:"dataFormat",type:"string",defaultValue:"NHWC"},{tfParamName:"dilations",dlParamName:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",dlOpName:"depthwiseConv2d",category:"convolution",params:[{tfInputIndex:0,dlParamName:"input",type:"tensor"},{tfInputIndex:1,dlParamName:"filter",type:"tensor"},{tfParamName:"strides",dlParamName:"strides",type:"number[]"},{tfParamName:"padding",dlParamName:"pad",type:"string"},{tfParamName:"data_format",dlParamName:"dataFormat",type:"string",defaultValue:"NHWC"},{tfParamName:"dilations",dlParamName:"dilations",type:"number[]"}]}],convolution=Object.freeze({json:json$3}),json$4=[{tfOpName:"Fill",dlOpName:"fill",category:"creation",params:[{tfInputIndex:0,dlParamName:"shape",type:"number[]"},{tfInputIndex:1,dlParamName:"value",type:"number"},{tfParamName:"T",dlParamName:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",dlOpName:"linspace",category:"creation",params:[{tfInputIndex:0,dlParamName:"start",type:"number"},{tfInputIndex:1,dlParamName:"stop",type:"number"},{tfInputIndex:2,dlParamName:"num",type:"number"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",dlOpName:"oneHot",category:"creation",params:[{tfInputIndex:0,dlParamName:"indices",type:"tensor"},{tfInputIndex:1,dlParamName:"depth",type:"number"},{tfInputIndex:2,dlParamName:"onValue",type:"number",defaultValue:1},{tfInputIndex:3,dlParamName:"offValue",type:"number",defaultValue:0},{tfParamName:"axis",dlParamName:"axis",type:"number",notSupported:!0},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",dlOpName:"ones",category:"creation",params:[{tfInputIndex:0,dlParamName:"shape",type:"number[]"},{tfParamName:"T",dlParamName:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",dlOpName:"onesLike",category:"creation",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"dtype",dlParamName:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",dlOpName:"randomUniform",category:"creation",params:[{tfInputIndex:0,dlParamName:"shape",type:"number[]"},{tfParamName:"minval",dlParamName:"minval",type:"number",defaultValue:0},{tfParamName:"maxval",dlParamName:"maxval",type:"number",defaultValue:1},{tfParamName:"dtype",dlParamName:"dtype",type:"dtype"},{tfParamName:"seed",dlParamName:"seed",type:"number",defaultValue:0},{tfParamName:"seed2",dlParamName:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfParamName:"T",dlParamName:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",dlOpName:"range",category:"creation",params:[{tfInputIndex:0,dlParamName:"start",type:"number"},{tfInputIndex:1,dlParamName:"stop",type:"number"},{tfInputIndex:2,dlParamName:"step",type:"number",defaultValue:0},{tfParamName:"Tidx",dlParamName:"dtype",type:"dtype"}]},{tfOpName:"truncatedNormal",dlOpName:"truncatedNormal",category:"creation",params:[{tfInputIndex:0,dlParamName:"shape",type:"number[]"},{tfParamName:"means",dlParamName:"mean",type:"number",defaultValue:0},{tfParamName:"stddev",dlParamName:"stdDev",type:"number",defaultValue:1},{tfParamName:"seed",dlParamName:"seed",type:"number"},{tfParamName:"seed2",dlParamName:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfParamName:"dtype",dlParamName:"dtype",type:"dtype"},{tfParamName:"T",dlParamName:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",dlOpName:"zeros",category:"creation",params:[{tfInputIndex:0,dlParamName:"shape",type:"number[]"},{tfParamName:"T",dlParamName:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",dlOpName:"zerosLike",category:"creation",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype"}]}],creation=Object.freeze({json:json$4}),json$5=[{tfOpName:"NonMaxSuppressionV2",dlOpName:"nonMaxSuppression",category:"dynamic",params:[{tfInputIndex:0,dlParamName:"boxes",type:"tensor"},{tfInputIndex:1,dlParamName:"scores",type:"tensor"},{tfInputIndex:2,dlParamName:"maxOutputSize",type:"number"},{tfInputIndex:3,dlParamName:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",dlOpName:"nonMaxSuppression",category:"dynamic",params:[{tfInputIndex:0,dlParamName:"boxes",type:"tensor"},{tfInputIndex:1,dlParamName:"scores",type:"tensor"},{tfInputIndex:2,dlParamName:"maxOutputSize",type:"number"},{tfInputIndex:3,dlParamName:"iouThreshold",type:"number"},{tfInputIndex:4,dlParamName:"scoreThreshold",type:"number"}]},{tfOpName:"Where",dlOpName:"whereAsync",category:"dynamic",params:[{tfInputIndex:0,dlParamName:"condition",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",dlOpName:"setdiff1dAsync",category:"dynamic",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"y",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]}],dynamic=Object.freeze({json:json$5}),json$6=[{tfOpName:"TopKV2",dlOpName:"topK",category:"evaluation",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"k",type:"number"},{tfParamName:"sorted",dlParamName:"sorted",type:"bool"}]}],evaluation=Object.freeze({json:json$6}),json$7=[{tfOpName:"PlaceholderWithDefault",dlOpName:"placeholder",category:"graph",params:[{tfInputIndex:0,dlParamName:"default",type:"tensor"},{tfParamName:"shape",dlParamName:"shape",type:"shape"},{tfParamName:"dtype",dlParamName:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",dlOpName:"placeholder",category:"graph",params:[{tfParamName:"shape",dlParamName:"shape",type:"shape"},{tfParamName:"dtype",dlParamName:"dtype",type:"dtype"}]},{tfOpName:"Const",dlOpName:"const",category:"graph"},{tfOpName:"Identity",dlOpName:"identity",category:"graph",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"}]},{tfOpName:"Snapshot",dlOpName:"snapshot",category:"graph",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"}]},{tfOpName:"Rank",dlOpName:"rank",category:"graph",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"}]},{tfOpName:"Size",dlOpName:"size",category:"graph",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"}]},{tfOpName:"Shape",dlOpName:"shape",category:"graph",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"}]},{tfOpName:"ShapeN",dlOpName:"shapeN",category:"graph",params:[{tfInputIndex:0,tfInputParamLength:0,dlParamName:"x",type:"tensors"}]},{tfOpName:"Print",dlOpName:"print",category:"graph",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,tfInputParamLength:1,dlParamName:"data",type:"tensors"},{tfParamName:"message",dlParamName:"message",type:"string"},{tfParamName:"first_n",dlParamName:"firstN",type:"number",notSupprted:!0},{tfParamName:"summarize",dlParamName:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",dlOpName:"noop",category:"graph",params:[]},{tfOpName:"StopGradient",dlOpName:"stopGradient",category:"graph",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",dlOpName:"fakeQuantWithMinMaxVars",category:"graph",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"min",dlParamName:"min",type:"number"},{tfParamName:"max",dlParamName:"max",type:"number"}]}],graph=Object.freeze({json:json$7}),json$8=[{tfOpName:"ResizeBilinear",dlOpName:"resizeBilinear",category:"image",params:[{tfInputIndex:0,dlParamName:"images",type:"tensor"},{tfInputIndex:1,dlParamName:"size",type:"number[]"},{tfParamName:"align_corners",dlParamName:"alignCorners",type:"bool"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",dlOpName:"resizeNearestNeighbor",category:"image",params:[{tfInputIndex:0,dlParamName:"images",type:"tensor"},{tfInputIndex:1,dlParamName:"size",type:"number[]"},{tfParamName:"align_corners",dlParamName:"alignCorners",type:"bool"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",dlOpName:"cropAndResize",category:"image",params:[{tfInputIndex:0,dlParamName:"image",type:"tensor"},{tfInputIndex:1,dlParamName:"boxes",type:"tensor"},{tfInputIndex:2,dlParamName:"boxInd",type:"tensor"},{tfInputIndex:3,dlParamName:"cropSize",type:"number[]"},{tfParamName:"method",dlParamName:"method",type:"string"},{tfParamName:"extrapolation_value",dlParamName:"extrapolationValue",type:"number"}]}],image$1=Object.freeze({json:json$8}),json$9=[{tfOpName:"Equal",dlOpName:"equal",category:"logical",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",dlOpName:"notEqual",category:"logical",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",dlOpName:"greater",category:"logical",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",dlOpName:"greaterEqual",category:"logical",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",dlOpName:"less",category:"logical",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",dlOpName:"lessEqual",category:"logical",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",dlOpName:"logicalAnd",category:"logical",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",dlOpName:"logicalNot",category:"logical",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",dlOpName:"logicalOr",category:"logical",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",dlOpName:"where",category:"logical",params:[{tfInputIndex:0,dlParamName:"condition",type:"tensor"},{tfInputIndex:1,dlParamName:"a",type:"tensor"},{tfInputIndex:2,dlParamName:"b",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]}],logical=Object.freeze({json:json$9}),json$10=[{tfOpName:"MatMul",dlOpName:"matMul",category:"matrices",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"transpose_a",dlParamName:"transposeA",type:"bool",defaultValue:!1},{tfParamName:"transpose_b",dlParamName:"transposeB",type:"bool",defaultValue:!1},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",dlOpName:"matMul",category:"matrices",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"adj_x",dlParamName:"transposeA",type:"bool",defaultValue:!1},{tfParamName:"adj_y",dlParamName:"transposeB",type:"bool",defaultValue:!1},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",dlOpName:"transpose",category:"matrices",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"perm",type:"number[]"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]}],matrices=Object.freeze({json:json$10}),json$11=[{tfOpName:"FusedBatchNorm",dlOpName:"batchNormalization",category:"normalization",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"scale",type:"tensor"},{tfInputIndex:2,dlParamName:"offset",type:"tensor"},{tfInputIndex:3,dlParamName:"mean",type:"tensor"},{tfInputIndex:4,dlParamName:"variance",type:"tensor"},{tfParamName:"epsilon",dlParamName:"epsilon",type:"number",defaultValue:.001},{tfParamName:"data_format",dlParamName:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",dlOpName:"batchNormalization",category:"normalization",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"scale",type:"tensor"},{tfInputIndex:2,dlParamName:"offset",type:"tensor"},{tfInputIndex:3,dlParamName:"mean",type:"tensor"},{tfInputIndex:4,dlParamName:"variance",type:"tensor"},{tfParamName:"epsilon",dlParamName:"epsilon",type:"number",defaultValue:.001},{tfParamName:"data_format",dlParamName:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",dlOpName:"localResponseNormalization",category:"normalization",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"depth_radius",dlParamName:"radius",type:"number",defaultValue:5},{tfParamName:"bias",dlParamName:"bias",type:"number",defaultValue:1},{tfParamName:"alpha",dlParamName:"alpha",type:"number",defaultValue:1},{tfParamName:"beta",dlParamName:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",dlOpName:"softmax",category:"normalization",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",dlOpName:"logSoftmax",category:"normalization",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"}]},{tfOpName:"SparseToDense",dlOpName:"sparseToDense",category:"normalization",params:[{tfInputIndex:0,dlParamName:"sparseIndices",type:"tensor"},{tfInputIndex:1,dlParamName:"outputShape",type:"number[]"},{tfInputIndex:2,dlParamName:"sparseValues",type:"tensor"},{tfInputIndex:3,dlParamName:"defaultValue",type:"tensor"},{tfParamName:"validate_indices",dlParamName:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}],normalization=Object.freeze({json:json$11}),json$12=[{tfOpName:"Max",dlOpName:"max",category:"reduction",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"axis",type:"number[]"},{tfParamName:"keep_dims",dlParamName:"keepDims",type:"bool"}]},{tfOpName:"Mean",dlOpName:"mean",category:"reduction",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"axis",type:"number[]"},{tfParamName:"keep_dims",dlParamName:"keepDims",type:"bool"}]},{tfOpName:"Min",dlOpName:"min",category:"reduction",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"axis",type:"number[]"},{tfParamName:"keep_dims",dlParamName:"keepDims",type:"bool"}]},{tfOpName:"Sum",dlOpName:"sum",category:"reduction",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"axis",type:"number[]"},{tfParamName:"keep_dims",dlParamName:"keepDims",type:"bool"}]},{tfOpName:"All",dlOpName:"all",category:"reduction",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"axis",type:"number[]"},{tfParamName:"keep_dims",dlParamName:"keepDims",type:"bool"}]},{tfOpName:"Any",dlOpName:"any",category:"reduction",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"axis",type:"number[]"},{tfParamName:"keep_dims",dlParamName:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",dlOpName:"argMax",category:"reduction",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"axis",type:"number"}]},{tfOpName:"ArgMin",dlOpName:"argMin",category:"reduction",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"axis",type:"number"}]},{tfOpName:"Prod",dlOpName:"prod",category:"reduction",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"axis",type:"number[]"},{tfParamName:"keep_dims",dlParamName:"keepDims",type:"bool"}]}],reduction=Object.freeze({json:json$12}),json$13=[{tfOpName:"ConcatV2",dlOpName:"concat",category:"slice_join",params:[{tfInputIndex:0,tfInputParamLength:1,dlParamName:"tensors",type:"tensors"},{tfInputIndex:-1,dlParamName:"axis",type:"number"}]},{tfOpName:"Concat",dlOpName:"concat",category:"slice_join",params:[{tfInputIndex:1,tfInputParamLength:1,dlParamName:"tensors",type:"tensors"},{tfInputIndex:0,dlParamName:"axis",type:"number"}]},{tfOpName:"GatherV2",dlOpName:"gather",category:"slice_join",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"indices",type:"tensor"},{tfInputIndex:2,dlParamName:"axis",type:"number",defaultValue:0}]},{tfOpName:"Gather",dlOpName:"gather",category:"slice_join",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"indices",type:"tensor"},{tfParamName:"axis",dlParamName:"axis",type:"number",defaultValue:0},{tfParamName:"validate_indices",dlParamName:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",dlOpName:"reverse",category:"slice_join",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"dims",type:"bool",notSupported:!0}]},{tfOpName:"ReverseV2",dlOpName:"reverse",category:"slice_join",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"axis",type:"number[]"}]},{tfOpName:"Slice",dlOpName:"slice",category:"slice_join",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"begin",type:"number[]"},{tfInputIndex:2,dlParamName:"size",type:"number[]"}]},{tfOpName:"StridedSlice",dlOpName:"stridedSlice",category:"slice_join",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"begin",type:"number[]"},{tfInputIndex:2,dlParamName:"end",type:"number[]"},{tfInputIndex:3,dlParamName:"strides",type:"number[]"},{tfParamName:"begin_mask",dlParamName:"beginMask",type:"number",defaultValue:0},{tfParamName:"end_mask",dlParamName:"endMask",type:"number",defaultValue:0},{tfParamName:"new_axis_mask",dlParamName:"newAxisMask",type:"number",defaultValue:0},{tfParamName:"ellipsis_mask",dlParamName:"ellipsisMask",type:"number",defaultValue:0},{tfParamName:"shrink_axis_mask",dlParamName:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",dlOpName:"stack",category:"slice_join",params:[{tfInputIndex:0,tfInputParamLength:0,dlParamName:"tensors",type:"tensors"},{tfParamName:"axis",dlParamName:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",dlOpName:"unstack",category:"slice_join",params:[{tfInputIndex:0,tfInputParamLength:0,dlParamName:"tensor",type:"tensor"},{tfParamName:"axis",dlParamName:"axis",type:"number",defaultValue:0},{tfParamName:"num",dlParamName:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",dlOpName:"tile",category:"slice_join",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"reps",type:"number[]"}]},{tfOpName:"Split",dlOpName:"split",category:"slice_join",params:[{tfInputIndex:0,dlParamName:"axis",type:"number",defaultValue:0},{tfInputIndex:1,dlParamName:"x",type:"tensor"},{tfParamName:"num_split",dlParamName:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",dlOpName:"split",category:"slice_join",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"numOrSizeSplits",type:"number[]"},{tfInputIndex:2,dlParamName:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",dlOpName:"scatterNd",category:"slice_join",params:[{tfInputIndex:0,dlParamName:"indices",type:"tensor"},{tfInputIndex:1,dlParamName:"values",type:"tensor"},{tfInputIndex:2,dlParamName:"shape",type:"number[]"}]},{tfOpName:"GatherNd",dlOpName:"gatherNd",category:"slice_join",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",dlOpName:"sparseToDense",category:"slice_join",params:[{tfInputIndex:0,dlParamName:"sparseIndices",type:"tensor"},{tfInputIndex:1,dlParamName:"outputShape",type:"number[]"},{tfInputIndex:2,dlParamName:"sparseValues",type:"tensor"},{tfInputIndex:3,dlParamName:"defaultValue",type:"tensor"},{tfParamName:"validate_indices",dlParamName:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}],sliceJoin=Object.freeze({json:json$13}),json$14=[{tfOpName:"Cast",dlOpName:"cast",category:"transformation",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"SrcT",dlParamName:"sdtype",type:"dtype",notSupported:!0},{tfParamName:"DstT",dlParamName:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",dlOpName:"expandDims",category:"transformation",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,tfParamNameDeprecated:"dim",dlParamName:"axis",type:"number"}]},{tfOpName:"Pad",dlOpName:"pad",category:"transformation",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"padding",type:"number[]"},{tfParamName:"constant_value",dlParamName:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",dlOpName:"pad",category:"transformation",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"padding",type:"number[]"},{tfInputIndex:2,dlParamName:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",dlOpName:"reshape",category:"transformation",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"shape",type:"number[]"}]},{tfOpName:"Squeeze",dlOpName:"squeeze",category:"transformation",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"axis",tfParamNameDeprecated:"squeeze_dims",dlParamName:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",dlOpName:"spaceToBatchND",category:"transformation",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"blockShape",type:"number[]"},{tfInputIndex:2,dlParamName:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",dlOpName:"batchToSpaceND",category:"transformation",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"blockShape",type:"number[]"},{tfInputIndex:2,dlParamName:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",dlOpName:"depthToSpace",category:"transformation",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"block_size",dlParamName:"blockSize",type:"number"},{tfParamName:"data_format",dlParamName:"dataFormat",type:"string"}]}],transformation=Object.freeze({json:json$14}),CONTROL_FLOW_OPS=["Switch","Merge","Enter","Exit","NextIteration"],DYNAMIC_SHAPE_OPS=["NonMaxSuppressionV2","NonMaxSuppressionV3","Where"],OperationMapper=function(){function e(){var e=[arithmetic,basicMath,control,convolution,creation,dynamic,evaluation,logical,image$1,graph,matrices,normalization,reduction,sliceJoin,transformation],t=[].concat.apply([],e.map(function(e){return e.json}));this.opMappers=t.reduce(function(e,t){return e[t.tfOpName]=t,e},{})}return Object.defineProperty(e,"Instance",{get:function(){return this._instance||(this._instance=new this)},enumerable:!0,configurable:!0}),e.prototype.isControlFlow=function(e){return CONTROL_FLOW_OPS.some(function(t){return t===e.op})},e.prototype.isDynamicShape=function(e){return DYNAMIC_SHAPE_OPS.some(function(t){return t===e.op})},e.prototype.transformGraph=function(e){var t=this,a=!1,r=!1,n=[],o=[],s=e.node.reduce(function(e,s){return e[s.name]=t.mapNode(s),t.isControlFlow(s)&&(a=!0),t.isDynamicShape(s)&&(r=!0),"Placeholder"===s.op&&n.push(e[s.name]),"Const"===s.op&&o.push(e[s.name]),e},{}),i=[],p=[];return Object.keys(s).forEach(function(e){var t=s[e];t.inputNames.forEach(function(e){var a=getNodeNameAndIndex(e)[0];t.inputs.push(s[a]),s[a].children.push(t)}),0===t.inputs.length&&i.push(t)}),Object.keys(s).forEach(function(e){var t=s[e];0===t.children.length&&p.push(t)}),{nodes:s,inputs:i,outputs:p,weights:o,placeholders:n,withControlFlow:a,withDynamicShape:r}},e.prototype.mapNode=function(e){var t=this,a=this.opMappers[e.op];if(void 0===a)throw new Error("Tensorflow Op is not supported: "+e.op);var r={name:e.name,op:a.dlOpName,category:a.category,inputNames:(e.input||[]).map(function(e){return e.startsWith("^")?e.substr(1):e}),inputs:[],children:[],params:{}};return a.params&&(r.params=a.params.reduce(function(a,r){var n=r.tfInputIndex,o=r.tfInputParamLength,s=r.type,i=void 0;if(void 0===n)switch(r.type){case"string":void 0===(i=t.getStringParam(e.attr,r.tfParamName,r.defaultValue))&&r.tfParamNameDeprecated&&(i=t.getStringParam(e.attr,r.tfParamNameDeprecated,r.defaultValue));break;case"number":void 0===(i=t.getNumberParam(e.attr,r.tfParamName,r.defaultValue))&&r.tfParamNameDeprecated&&(i=t.getNumberParam(e.attr,r.tfParamNameDeprecated,r.defaultValue));break;case"number[]":void 0===(i=t.getNumericArrayParam(e.attr,r.tfParamName,r.defaultValue))&&r.tfParamNameDeprecated&&(i=t.getNumericArrayParam(e.attr,r.tfParamNameDeprecated,r.defaultValue));break;case"bool":void 0===(i=t.getBoolParam(e.attr,r.tfParamName,r.defaultValue))&&r.tfParamNameDeprecated&&(i=t.getBoolParam(e.attr,r.tfParamNameDeprecated,r.defaultValue));break;case"shape":void 0===(i=t.getTensorShapeParam(e.attr,r.tfParamName,r.defaultValue))&&r.tfParamNameDeprecated&&(i=t.getTensorShapeParam(e.attr,r.tfParamNameDeprecated,r.defaultValue));break;case"dtype":void 0===(i=t.getDtypeParam(e.attr,r.tfParamName,r.defaultValue))&&r.tfParamNameDeprecated&&(i=t.getDtypeParam(e.attr,r.tfParamNameDeprecated,r.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error("Unsupported param type: "+r.type+" for op: "+e.op)}return a[r.dlParamName]={value:i,inputIndex:n,type:s,inputParamLength:o},a},{})),r},e.prototype.getStringParam=function(e,t,a,r){void 0===r&&(r=!1);var n=e[t];if(void 0!==n){var o=String.fromCharCode.apply(null,n.s);return r?o:o.toLowerCase()}return a},e.prototype.getBoolParam=function(e,t,a){var r=e[t];return r?r.b:a},e.prototype.getNumberParam=function(e,t,a){var r=e[t],n=r?r[r.value]:a;return"number"==typeof n?n:n.toInt()},e.prototype.getDtypeParam=function(e,t,a){var r=e[t];if(r&&r.type)switch(r.type){case compiled_api_1.DataType.DT_FLOAT:return"float32";case compiled_api_1.DataType.DT_INT32:return"int32";case compiled_api_1.DataType.DT_BOOL:return"bool";default:return a}return a},e.prototype.getTensorShapeParam=function(e,t,a){var r=e[t];return r&&r.shape?r.shape.dim.map(function(e){return"number"==typeof e.size?e.size:e.size.toInt()}):a},e.prototype.getNumericArrayParam=function(e,t,a){var r=e[t];return r?(r.list.f&&r.list.f.length?r.list.f:r.list.i).map(function(e){return"number"==typeof e?e:e.toInt()}):a},e}(),executeOp=function(e,t,a){switch(e.op){case"add":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"addN":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["addN"])(getParamValue("tensors",e,t,a))];case"mod":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mod"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"mul":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"div":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"floorDiv":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["floorDiv"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"sub":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"minimum":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["minimum"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"maximum":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["maximum"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"pow":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["pow"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"squaredDifference":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["squaredDifference"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];default:throw TypeError("Node type "+e.op+" is not implemented")}},executeOp$1=function(e,t,a){switch(e.op){case"abs":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["abs"])(getParamValue("x",e,t,a))];case"acos":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["acos"])(getParamValue("x",e,t,a))];case"acosh":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["acosh"])(getParamValue("x",e,t,a))];case"asin":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["asin"])(getParamValue("x",e,t,a))];case"asinh":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["asinh"])(getParamValue("x",e,t,a))];case"atan":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["atan"])(getParamValue("x",e,t,a))];case"atan2":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["atan2"])(getParamValue("x",e,t,a),getParamValue("y",e,t,a))];case"atanh":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["atanh"])(getParamValue("x",e,t,a))];case"ceil":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["ceil"])(getParamValue("x",e,t,a))];case"cos":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["cos"])(getParamValue("x",e,t,a))];case"cosh":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["cosh"])(getParamValue("x",e,t,a))];case"elu":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["elu"])(getParamValue("x",e,t,a))];case"erf":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["erf"])(getParamValue("x",e,t,a))];case"exp":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["exp"])(getParamValue("x",e,t,a))];case"expm1":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["expm1"])(getParamValue("x",e,t,a))];case"floor":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["floor"])(getParamValue("x",e,t,a))];case"log":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["log"])(getParamValue("x",e,t,a))];case"log1p":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["log1p"])(getParamValue("x",e,t,a))];case"neg":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["neg"])(getParamValue("x",e,t,a))];case"reciprocal":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reciprocal"])(getParamValue("x",e,t,a))];case"relu":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["relu"])(getParamValue("x",e,t,a))];case"round":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["round"])(getParamValue("x",e,t,a))];case"selu":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["selu"])(getParamValue("x",e,t,a))];case"sigmoid":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sigmoid"])(getParamValue("x",e,t,a))];case"sin":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sin"])(getParamValue("x",e,t,a))];case"sign":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sign"])(getParamValue("x",e,t,a))];case"sinh":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sinh"])(getParamValue("x",e,t,a))];case"softplus":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["softplus"])(getParamValue("x",e,t,a))];case"sqrt":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(getParamValue("x",e,t,a))];case"square":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["square"])(getParamValue("x",e,t,a))];case"tanh":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tanh"])(getParamValue("x",e,t,a))];case"tan":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tan"])(getParamValue("x",e,t,a))];case"clipByValue":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clipByValue"])(getParamValue("x",e,t,a),getParamValue("clipValueMin",e,t,a),getParamValue("clipValueMax",e,t,a))];case"rsqrt":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"])(1,"float32"),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(getTensor(e.inputNames[0],t,a)))];case"prod":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["prod"])(getParamValue("x",e,t,a),getParamValue("axes",e,t,a))];case"leakyRelu":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["leakyRelu"])(getParamValue("x",e,t,a),getParamValue("alpha",e,t,a))];default:throw TypeError("Node type "+e.op+" is not implemented")}},TensorArray=function(){function e(t,a,r,n,o,s,i){this.name=t,this.dtype=a,this.maxSize=r,this.elementShape=n,this.identicalElementShapes=o,this.dynamicSize=s,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.id=e.nextId++}return Object.defineProperty(e.prototype,"closed",{get:function(){return this.closed_},enumerable:!0,configurable:!0}),e.prototype.clearAndClose=function(){this.tensors.forEach(function(e){return e.tensor.dispose()}),this.tensors=[],this.closed_=!0},e.prototype.size=function(){return this.tensors.length},e.prototype.read=function(e){if(this.closed_)throw new Error("TensorArray "+this.name+" has already been closed.");if(e<0||e>=this.tensors.length)throw new Error("Tried to read from index "+e+", but array size is: "+this.tensors.length);var t=this.tensors[e];if(t.cleared)throw new Error("TensorArray "+this.name+": Could not read index "+e+" twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).");return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor},e.prototype.readMany=function(e){var t=this;return e.map(function(e){return t.read(e)})},e.prototype.write=function(e,t){if(this.closed_)throw new Error("TensorArray "+this.name+" has already been closed.");if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error("Tried to write to index "+e+", but array is not resizeable and size is: "+this.maxSize);var a=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error("TensorArray "+this.name+": Could not write to TensorArray index "+e+",\n          because the value dtype is "+t.dtype+", but TensorArray dtype is "+this.dtype+".");if(0===this.size()&&0===this.elementShape.length&&(this.elementShape=t.shape),this.assertShapesMatch(this.elementShape,t.shape,"TensorArray "+this.name+": Could not write to TensorArray index "+e+"."),a&&a.read)throw new Error("TensorArray "+this.name+": Could not write to TensorArray index "+e+", because it has already been read.");if(a&&a.written)throw new Error("TensorArray "+this.name+": Could not write to TensorArray index "+e+", because it has already been written.");a.tensor=t,a.written=!0,this.tensors[e]=a},e.prototype.writeMany=function(e,t){var a=this;if(e.length!==t.length)throw new Error("TensorArray "+this.name+": could not write multiple tensors,because the index size: "+e.length+" is not the same as tensors size: "+t.length+".");e.forEach(function(e,r){return a.write(e,t[r])})},e.prototype.gather=function(e,t){if(t&&t!==this.dtype)throw new Error("TensorArray dtype is "+this.dtype+" but gather requested dtype "+t);if(!e){e=[];for(var a=0;a<this.size();a++)e.push(a)}if(0===e.length)return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor"])([],[0].concat(this.elementShape));var r=this.readMany(e);return this.assertShapesMatch(this.elementShape,r[0].shape,"TensorArray shape mismatch: "),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["stack"])(r,0)},e.prototype.concat=function(e){if(e&&e!==this.dtype)throw new Error("TensorArray dtype is "+this.dtype+" but concat requested dtype "+e);if(0===this.size())return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor"])([],[0].concat(this.elementShape));for(var t=[],a=0;a<this.size();a++)t.push(a);var r=this.readMany(t);return this.assertShapesMatch(this.elementShape,r[0].shape,"TensorArray shape mismatch: tensor array shape ("+this.elementShape+") vs first tensor shape ("+r[0].shape+")"),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["concat"])(r,0)},e.prototype.scatter=function(e,t){if(t.dtype!==this.dtype)throw new Error("TensorArray dtype is "+this.dtype+" but tensor has dtype "+t.dtype);if(e.length!==t.shape[0])throw new Error("Expected len(indices) == tensor.shape[0], but saw: "+e.length+" vs. "+t.shape[0]);var a=Math.max.apply(Math,e);if(!this.dynamicSize&&a>=this.maxSize)throw new Error("Max index must be < array size ("+a+"  vs. "+this.maxSize+")");this.writeMany(e,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["unstack"])(t,0))},e.prototype.split=function(e,t){var a=this;if(t.dtype!==this.dtype)throw new Error("TensorArray dtype is "+this.dtype+" but tensor has dtype "+t.dtype);var r=0,n=e.map(function(e){return r+=e});if(r!==t.shape[0])throw new Error("Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        "+r+", and tensor's shape is: "+t.shape);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error("TensorArray's size is not equal to the size of lengths ("+this.maxSize+" vs. "+e.length+"), and the TensorArray is not marked as dynamically resizeable");var o=0===r?0:t.size/r,s=[];Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){t=t.reshape([1,r,o]);for(var i=0;i<e.length;++i){var p=[0,0===i?0:n[i-1],0],m=[1,e[i],o];s[i]=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice"])(t,p,m).reshape(a.elementShape)}return s});for(var i=[],p=0;p<e.length;p++)i[p]=p;this.writeMany(i,s)},e.prototype.assertShapesMatch=function(e,t,a){void 0===a&&(a=""),_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(this.arraysEqual(e,t),a+" Shapes "+e+" and "+t+" must match")},e.prototype.arraysEqual=function(e,t){if(e.length!==t.length)return!1;for(var a=0;a<e.length;a++)if(-1!==e[a]&&-1!==t[a]&&e[a]!==t[a])return!1;return!0},e.nextId=0,e}();function executeOp$2(e,t,a){return __awaiter(this,void 0,void 0,function(){var r,n,o,s,i,p,m,u,l,d,c,f,y,h,g,N,P,x,b,I,v,O,V,w,T,k,S,$,_,A,D,j,E,C,R;return __generator(this,function(L){switch(L.label){case 0:switch(e.op){case"loopCond":return[3,1];case"switch":return[3,2];case"merge":return[3,4];case"enter":return[3,5];case"exit":return[3,6];case"nextIteration":return[3,7];case"tensorArray":return[3,8];case"tensorArrayWrite":return[3,9];case"tensorArrayRead":return[3,10];case"tensorArrayGather":return[3,11];case"tensorArrayScatter":return[3,12];case"tensorArrayConcat":return[3,13];case"tensorArraySplit":return[3,14];case"tensorArraySize":return[3,15];case"tensorArrayClose":return[3,16]}return[3,17];case 1:return[2,[getParamValue("pred",e,t,a).clone()]];case 2:return r=getParamValue("pred",e,t,a),n=getParamValue("data",e,t,a),[4,r.data()];case 3:return[2,L.sent()[0]?[void 0,n.clone()]:[n.clone(),void 0]];case 4:return[2,(o=e.inputNames.find(function(e){return void 0!==getTensor(e,t,a)}))?[getTensor(o,t,a).clone()]:void 0];case 5:return s=getParamValue("frameName",e,t,a),i=getParamValue("tensor",e,t,a),a.enterFrame(s),[2,[i.clone()]];case 6:return p=getParamValue("tensor",e,t,a),a.exitFrame(),[2,[p.clone()]];case 7:return m=getParamValue("tensor",e,t,a),a.nextIteration(),[2,[m.clone()]];case 8:return u=getParamValue("size",e,t,a),l=getParamValue("dtype",e,t,a),d=getParamValue("elementShape",e,t,a),c=getParamValue("dynamicSize",e,t,a),f=getParamValue("clearAfterRead",e,t,a),y=getParamValue("identicalElementShapes",e,t,a),h=getParamValue("name",e,t,a),g=new TensorArray(h,l,u,d,y,c,f),a.addTensorArray(g),[2,[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"])(g.id),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"])(1)]];case 9:return N=getParamValue("tensorArrayId",e,t,a),P=getParamValue("index",e,t,a),x=getParamValue("tensor",e,t,a),a.getTensorArray(N).write(P,x),[2,[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"])(1)]];case 10:return b=getParamValue("tensorArrayId",e,t,a),I=getParamValue("index",e,t,a),[2,[a.getTensorArray(b).read(I)]];case 11:return v=getParamValue("tensorArrayId",e,t,a),O=getParamValue("indices",e,t,a),V=getParamValue("dtype",e,t,a),[2,[a.getTensorArray(v).gather(O,V)]];case 12:return w=getParamValue("tensorArrayId",e,t,a),T=getParamValue("indices",e,t,a),k=getParamValue("tensor",e,t,a),a.getTensorArray(w).scatter(T,k),[2,[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"])(1)]];case 13:return S=getParamValue("tensorArrayId",e,t,a),$=a.getTensorArray(S),_=getParamValue("dtype",e,t,a),[2,[$.concat(_)]];case 14:return A=getParamValue("tensorArrayId",e,t,a),D=getParamValue("tensor",e,t,a),j=getParamValue("lengths",e,t,a),a.getTensorArray(A).split(j,D),[2,[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"])(1)]];case 15:return E=getParamValue("tensorArrayId",e,t,a),C=a.getTensorArray(E),[2,[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"])(C.size(),"int32")]];case 16:return R=getParamValue("tensorArrayId",e,t,a),a.getTensorArray(R).clearAndClose(),[2,[]];case 17:throw TypeError("Node type "+e.op+" is not implemented")}})})}var executeOp$3=function(e,t,a){switch(e.op){case"conv1d":var r=getParamValue("stride",e,t,a),n=getParamValue("pad",e,t,a),o=getParamValue("dataFormat",e,t,a).toUpperCase(),s=getParamValue("dilation",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["conv1d"])(getParamValue("x",e,t,a),getParamValue("filter",e,t,a),r,n,o,s)];case"conv2d":r=getParamValue("strides",e,t,a),n=getParamValue("pad",e,t,a),o=getParamValue("dataFormat",e,t,a).toUpperCase();var i=getParamValue("dilations",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["conv2d"])(getParamValue("x",e,t,a),getParamValue("filter",e,t,a),[r[1],r[2]],n,o,[i[0],i[1]])];case"conv2dTranspose":var p=getParamValue("outputShape",e,t,a);r=getParamValue("strides",e,t,a),n=getParamValue("pad",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["conv2dTranspose"])(getParamValue("x",e,t,a),getParamValue("filter",e,t,a),p,[r[1],r[2]],n)];case"depthwiseConv2d":r=getParamValue("strides",e,t,a),n=getParamValue("pad",e,t,a),i=getParamValue("dilations",e,t,a),o=getParamValue("dataFormat",e,t,a).toUpperCase();return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["depthwiseConv2d"])(getParamValue("input",e,t,a),getParamValue("filter",e,t,a),[r[1],r[2]],n,o,[i[0],i[1]])];case"avgPool":r=getParamValue("strides",e,t,a),n=getParamValue("pad",e,t,a);var m=getParamValue("kernelSize",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["avgPool"])(getParamValue("x",e,t,a),[m[1],m[2]],[r[1],r[2]],n)];case"maxPool":r=getParamValue("strides",e,t,a),n=getParamValue("pad",e,t,a),m=getParamValue("kernelSize",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["maxPool"])(getParamValue("x",e,t,a),[m[1],m[2]],[r[1],r[2]],n)];default:throw TypeError("Node type "+e.op+" is not implemented")}},executeOp$4=function(e,t,a){switch(e.op){case"fill":var r=getParamValue("shape",e,t,a),n=getParamValue("dtype",e,t,a),o=getParamValue("value",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["fill"])(r,o,n)];case"linspace":var s=getParamValue("start",e,t,a),i=getParamValue("stop",e,t,a),p=getParamValue("num",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["linspace"])(s,i,p)];case"oneHot":var m=getParamValue("indices",e,t,a),u=getParamValue("depth",e,t,a),l=getParamValue("onValue",e,t,a),d=getParamValue("offValue",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["oneHot"])(m,u,l,d)];case"ones":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["ones"])(getParamValue("shape",e,t,a),getParamValue("dtype",e,t,a))];case"onesLike":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["onesLike"])(getParamValue("x",e,t,a))];case"randomUniform":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["randomUniform"])(getParamValue("shape",e,t,a),getParamValue("minval",e,t,a),getParamValue("maxval",e,t,a),getParamValue("dtype",e,t,a))];case"range":s=getParamValue("start",e,t,a);var c=getParamValue("stop",e,t,a),f=getParamValue("step",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["range"])(s,c,f,getParamValue("dtype",e,t,a))];case"truncatedNormal":r=getParamValue("shape",e,t,a);var y=getParamValue("mean",e,t,a),h=getParamValue("stdDev",e,t,a),g=getParamValue("seed",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["truncatedNormal"])(r,y,h,getParamValue("dtype",e,t,a),g)];case"zeros":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["zeros"])(getParamValue("shape",e,t,a),getParamValue("dtype",e,t,a))];case"zerosLike":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["zerosLike"])(getParamValue("x",e,t,a))];default:throw TypeError("Node type "+e.op+" is not implemented")}};function executeOp$5(e,t,a){return __awaiter(this,void 0,void 0,function(){var r,n,o,s,i;return __generator(this,function(p){switch(p.label){case 0:switch(e.op){case"nonMaxSuppression":return[3,1];case"whereAsync":return[3,3];case"setdiff1dAsync":return[3,5]}return[3,7];case 1:return r=getParamValue("boxes",e,t,a),n=getParamValue("scores",e,t,a),o=getParamValue("maxOutputSize",e,t,a),s=getParamValue("iouThreshold",e,t,a),i=getParamValue("scoreThreshold",e,t,a),[4,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["image"].nonMaxSuppressionAsync(r,n,o,s,i)];case 2:return[2,[p.sent()]];case 3:return[4,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["whereAsync"])(getParamValue("condition",e,t,a))];case 4:return[2,[p.sent()]];case 5:return[4,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["setdiff1dAsync"])(getParamValue("x",e,t,a),getParamValue("y",e,t,a))];case 6:return[2,p.sent()];case 7:throw TypeError("Node type "+e.op+" is not implemented")}})})}var executeOp$6=function(e,t,a){switch(e.op){case"topK":var r=getParamValue("x",e,t,a),n=getParamValue("k",e,t,a),o=getParamValue("sorted",e,t,a),s=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["topk"])(r,n,o);return[s.values,s.indices];default:throw TypeError("Node type "+e.op+" is not implemented")}},executeOp$7=function(e,t,a){switch(e.op){case"const":return t[e.name];case"placeholder":var r=getParamValue("default",e,t,a);return[getTensor(e.name,t,a)||r];case"identity":case"stopGradient":case"fakeQuantWithMinMaxVars":return[getParamValue("x",e,t,a).clone()];case"snapshot":return[getParamValue("x",e,t,a).clone()];case"shape":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor1d"])(getParamValue("x",e,t,a).shape,"int32")];case"shapeN":return getParamValue("x",e,t,a).map(function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor1d"])(e.shape)});case"size":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"])(getParamValue("x",e,t,a).size,"int32")];case"rank":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"])(getParamValue("x",e,t,a).rank,"int32")];case"noop":return[];case"print":var n=getParamValue("x",e,t,a),o=getParamValue("data",e,t,a),s=getParamValue("message",e,t,a),i=getParamValue("summarize",e,t,a);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(s);for(var p=0;p<o.length;p++)console.log(Array.prototype.slice.call(o[0].dataSync()).slice(0,i));return[n];default:throw TypeError("Node type "+e.op+" is not implemented")}},executeOp$8=function(e,t,a){switch(e.op){case"resizeBilinear":var r=getParamValue("images",e,t,a),n=getParamValue("size",e,t,a),o=getParamValue("alignCorners",e,t,a);return[_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["image"].resizeBilinear(r,[n[0],n[1]],o)];case"resizeNearestNeighbor":r=getParamValue("images",e,t,a),n=getParamValue("size",e,t,a),o=getParamValue("alignCorners",e,t,a);return[_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["image"].resizeNearestNeighbor(r,[n[0],n[1]],o)];case"cropAndResize":var s=getParamValue("image",e,t,a),i=getParamValue("boxes",e,t,a),p=getParamValue("boxInd",e,t,a),m=getParamValue("cropSize",e,t,a),u=getParamValue("method",e,t,a),l=getParamValue("extrapolationValue",e,t,a);return[_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["image"].cropAndResize(s,i,p,m,u,l)];default:throw TypeError("Node type "+e.op+" is not implemented")}},executeOp$9=function(e,t,a){switch(e.op){case"equal":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["equal"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"notEqual":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["notEqual"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"greater":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["greater"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"greaterEqual":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["greaterEqual"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"less":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["less"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"lessEqual":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["lessEqual"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"logicalAnd":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["logicalAnd"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"logicalNot":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["logicalNot"])(getParamValue("a",e,t,a))];case"logicalOr":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["logicalOr"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"where":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["where"])(getParamValue("condition",e,t,a),getParamValue("a",e,t,a),getParamValue("b",e,t,a))];default:throw TypeError("Node type "+e.op+" is not implemented")}},executeOp$10=function(e,t,a){switch(e.op){case"matMul":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["matMul"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a),getParamValue("transposeA",e,t,a),getParamValue("transposeB",e,t,a))];case"transpose":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(getParamValue("x",e,t,a),getParamValue("perm",e,t,a))];default:throw TypeError("Node type "+e.op+" is not implemented")}},executeOp$11=function(e,t,a){switch(e.op){case"batchNormalization":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["batchNormalization"])(getParamValue("x",e,t,a),getParamValue("mean",e,t,a),getParamValue("variance",e,t,a),getParamValue("epsilon",e,t,a),getParamValue("scale",e,t,a),getParamValue("offset",e,t,a))];case"localResponseNormalization":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["localResponseNormalization"])(getParamValue("x",e,t,a),getParamValue("radius",e,t,a),getParamValue("bias",e,t,a),getParamValue("alpha",e,t,a),getParamValue("beta",e,t,a))];case"softmax":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["softmax"])(getParamValue("x",e,t,a))];case"logSoftmax":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["logSoftmax"])(getParamValue("x",e,t,a))];case"sparseToDense":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sparseToDense"])(getParamValue("sparseIndices",e,t,a),getParamValue("outputShape",e,t,a),getParamValue("sparseValues",e,t,a),getParamValue("defaultValue",e,t,a))];default:throw TypeError("Node type "+e.op+" is not implemented")}},executeOp$12=function(e,t,a){switch(e.op){case"max":var r=getParamValue("axis",e,t,a),n=getParamValue("keepDims",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["max"])(getParamValue("x",e,t,a),r,n)];case"mean":r=getParamValue("axis",e,t,a),n=getParamValue("keepDims",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(getParamValue("x",e,t,a),r,n)];case"min":r=getParamValue("axis",e,t,a),n=getParamValue("keepDims",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["min"])(getParamValue("x",e,t,a),r,n)];case"sum":r=getParamValue("axis",e,t,a),n=getParamValue("keepDims",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sum"])(getParamValue("x",e,t,a),r,n)];case"all":r=getParamValue("axis",e,t,a),n=getParamValue("keepDims",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["all"])(getParamValue("x",e,t,a),r,n)];case"any":r=getParamValue("axis",e,t,a),n=getParamValue("keepDims",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["any"])(getParamValue("x",e,t,a),r,n)];case"argMax":r=getParamValue("axis",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["argMax"])(getParamValue("x",e,t,a),r)];case"argMin":r=getParamValue("axis",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["argMin"])(getParamValue("x",e,t,a),r)];case"prod":r=getParamValue("axis",e,t,a),n=getParamValue("keepDims",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["prod"])(getParamValue("x",e,t,a),r,n)];default:throw TypeError("Node type "+e.op+" is not implemented")}},executeOp$13=function(e,t,a){switch(e.op){case"concat":var r=getParamValue("axis",e,t,a),n=getParamValue("tensors",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["concat"])(n,r)];case"gather":r=getParamValue("axis",e,t,a);var o=getParamValue("x",e,t,a),s=getParamValue("indices",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["gather"])(o,s,r)];case"reverse":r=getParamValue("axis",e,t,a),o=getParamValue("x",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reverse"])(o,r)];case"slice":var i=getParamValue("begin",e,t,a),p=getParamValue("size",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice"])(getParamValue("x",e,t,a),i,p)];case"stridedSlice":i=getParamValue("begin",e,t,a);var m=getParamValue("end",e,t,a),u=getParamValue("strides",e,t,a),l=getParamValue("beginMask",e,t,a),d=getParamValue("endMask",e,t,a),c=getParamValue("ellipsisMask",e,t,a),f=getParamValue("newAxisMask",e,t,a),y=getParamValue("shrinkAxisMask",e,t,a),h=getParamValue("x",e,t,a);if(1===i.length&&h.shape.length>1)for(var g=1;g<h.shape.length;g++)i.push(0),m.push(h.shape[g]),u.push(u[0]);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["stridedSlice"])(h,i,m,u,l,d,c,f,y)];case"stack":return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var r=getParamValue("axis",e,t,a),n=getParamValue("tensors",e,t,a),o=n[0].shape,s=n[0].squeeze().shape,i=n.map(function(e){var t=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].arraysEqual(e.shape,o);if(!t&&!_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].arraysEqual(e.squeeze().shape,s))throw new Error("the input tensors shape does not match");return t?e:e.reshape(o)});return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["stack"])(i,r)]});case"unstack":return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var r=getParamValue("axis",e,t,a),n=getParamValue("tensor",e,t,a);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["unstack"])(n,r)});case"tile":var N=getParamValue("reps",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tile"])(getParamValue("x",e,t,a),N)];case"split":r=getParamValue("axis",e,t,a);var P=getParamValue("numOrSizeSplits",e,t,a);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["split"])(getParamValue("x",e,t,a),P,r);case"scatterNd":s=getParamValue("indices",e,t,a);var x=getParamValue("values",e,t,a),b=getParamValue("shape",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scatterND"])(s,x,b)];case"gatherNd":var I=getParamValue("x",e,t,a);s=getParamValue("indices",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["gatherND"])(I,s)];case"sparseToDense":s=getParamValue("sparseIndices",e,t,a),b=getParamValue("outputShape",e,t,a);var v=getParamValue("sparseValues",e,t,a),O=getParamValue("defaultValue",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sparseToDense"])(s,v,b,O)];default:throw TypeError("Node type "+e.op+" is not implemented")}},executeOp$14=function(e,t,a){switch(e.op){case"cast":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["cast"])(getParamValue("x",e,t,a),getParamValue("dtype",e,t,a))];case"expandDims":var r=getParamValue("axis",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["expandDims"])(getParamValue("x",e,t,a),r)];case"squeeze":r=getParamValue("axis",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["squeeze"])(getParamValue("x",e,t,a),r)];case"reshape":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reshape"])(getParamValue("x",e,t,a),getParamValue("shape",e,t,a))];case"pad":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["pad"])(getParamValue("x",e,t,a),split$1(getParamValue("padding",e,t,a),2),getParamValue("constantValue",e,t,a))];case"spaceToBatchND":var n=getParamValue("blockShape",e,t,a),o=split$1(getParamValue("paddings",e,t,a),2);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["spaceToBatchND"])(getParamValue("x",e,t,a),n,o)];case"batchToSpaceND":n=getParamValue("blockShape",e,t,a);var s=split$1(getParamValue("crops",e,t,a),2);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["batchToSpaceND"])(getParamValue("x",e,t,a),n,s)];case"depthToSpace":var i=getParamValue("blockSize",e,t,a),p=getParamValue("dataFormat",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["depthToSpace"])(getParamValue("x",e,t,a),i,p)];default:throw TypeError("Node type "+e.op+" is not implemented")}};function executeOp$15(e,t,a){switch(e.category){case"arithmetic":return executeOp(e,t,a);case"basic_math":return executeOp$1(e,t,a);case"control":return executeOp$2(e,t,a);case"convolution":return executeOp$3(e,t,a);case"creation":return executeOp$4(e,t,a);case"dynamic":return executeOp$5(e,t,a);case"evaluation":return executeOp$6(e,t,a);case"image":return executeOp$8(e,t,a);case"graph":return executeOp$7(e,t,a);case"logical":return executeOp$9(e,t,a);case"matrices":return executeOp$10(e,t,a);case"normalization":return executeOp$11(e,t,a);case"reduction":return executeOp$12(e,t,a);case"slice_join":return executeOp$13(e,t,a);case"transformation":return executeOp$14(e,t,a);default:throw TypeError("Node type "+e.op+" is not implemented")}}var ExecutionContext=function(){function e(e,t){this.weightMap=e,this.tensorArrayMap=t,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}return e.prototype.newFrame=function(e,t){return{id:e,frameName:t,iterationId:0}},Object.defineProperty(e.prototype,"currentContext",{get:function(){return this.contexts},set:function(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"currentContextId",{get:function(){return this._currentContextIds[0]},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"currentContextIds",{get:function(){return this._currentContextIds},enumerable:!0,configurable:!0}),e.prototype.generateCurrentContextIds=function(){for(var e=[],t=0;t<this.contexts.length-1;t++){var a=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(a))}e.push(""),this._currentContextIds=e},e.prototype.contextIdforContexts=function(e){return e?e.map(function(e){return 0===e.id&&0===e.iterationId?"":e.frameName+"-"+e.iterationId}).join("/"):""},e.prototype.enterFrame=function(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))},e.prototype.exitFrame=function(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()},e.prototype.nextIteration=function(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");this.contexts=this.contexts.slice(),this.lastId++;var e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))},e.prototype.getWeight=function(e){return this.weightMap[e]},e.prototype.addTensorArray=function(e){this.tensorArrayMap[e.id]=e},e.prototype.getTensorArray=function(e){return this.tensorArrayMap[e]},e}(),GraphExecutor=function(){function e(e){this.graph=e,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this.placeholders=e.placeholders,this._outputs=e.outputs,this.compile()}return Object.defineProperty(e.prototype,"weightMap",{get:function(){return this._weightMap},set:function(e){var t=Object.keys(e).map(function(t){return e[t].map(function(e){return e.id})});this.weightIds=[].concat.apply([],t),this._weightMap=e},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"inputs",{get:function(){return this.placeholders.map(function(e){return{name:e.name,shape:e.params.shape?e.params.shape.value:void 0,dtype:e.params.dtype?e.params.dtype.value:void 0}})},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"outputs",{get:function(){return this._outputs.map(function(e){return{name:e.name,shape:e.params.shape?e.params.shape.value:void 0,dtype:e.params.dtype?e.params.dtype.value:void 0}})},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"inputNodes",{get:function(){return this.placeholders.map(function(e){return e.name})},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"outputNodes",{get:function(){return this.outputs.map(function(e){return e.name})},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"isControlFlowModel",{get:function(){return this.graph.withControlFlow},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"isDynamicShapeModel",{get:function(){return this.graph.withDynamicShape},enumerable:!0,configurable:!0}),e.prototype.compile=function(e){if(!this.graph.withControlFlow&&!this.graph.withDynamicShape){var t=[],a=e||this.graph.placeholders,r=a.map(function(e){return e.name}).sort().join(this.SEPERATOR);if(!this.compiledMap.get(r)){for(var n=a.concat(this.graph.weights),o={};n.length>0;){var s=n.pop();o[s.name]=!0,t.push(s),s.children.forEach(function(e){!o[e.name]&&e.inputNames.every(function(e){var t=getNodeNameAndIndex(e)[0];return o[t]})&&n.push(e)})}this.compiledMap.set(r,t)}}},e.prototype.execute=function(e,t,a){var r=this;void 0===t&&(t=!0);var n=Object.keys(e).sort();this.checkInput(e,t),this.checkInputShapeAndType(e,t),this.compile(n.map(function(e){return r.graph.nodes[e]}));var o=this.calculateOutputs(a);this.checkOutput(this.compiledMap.get(n.join(this.SEPERATOR)),o);var s={};return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){for(var t=new ExecutionContext(r._weightMap,s),a=__assign({},r.weightMap,e),i=r.getFrozenTensorIds(a),p={},m=r.compiledMap.get(n.join(r.SEPERATOR)),u=0;u<m.length;u++){var l=m[u];if(a[l.name]||(a[l.name]=executeOp$15(l,a,t),r.checkTensorForDisposal(l.name,l,a,t,i,p)),o.every(function(e){return!!a[e]}))break}return r.findOutputs(a,t,o)})},e.prototype.getFrozenTensorIds=function(e){var t=[].concat.apply([],Object.keys(e).map(function(t){return e[t]}).map(function(e){return e.map(function(e){return e.id})}));return new Set(t)},e.prototype.checkTensorForDisposal=function(e,t,a,r,n,o){"control"!==t.category&&(a[e].forEach(function(e){null!=e&&(o[e.id]=(o[e.id]||0)+t.children.length)}),t.inputs.forEach(function(e){if("control"!==e.category){var t=getTensorsForCurrentContenxt(e.name,a,r);null!=t&&t.forEach(function(e){if(e&&!n.has(e.id)){var t=o[e.id];1===t?(e.dispose(),delete o[e.id]):null!=t&&o[e.id]--}})}}))},e.prototype.executeAsync=function(e,t){return __awaiter(this,void 0,void 0,function(){var a,r,n,o,s,i,p,m=this;return __generator(this,function(u){switch(u.label){case 0:return this.checkInput(e,!1),this.checkInputShapeAndType(e,!1),a={},r=new ExecutionContext(this._weightMap,a),[4,this.executeWithControlFlow(e,r)];case 1:return n=u.sent(),o=this.findOutputs(n,r,t),s=Object.keys(o).map(function(e){return o[e].id}),i=Object.keys(e).map(function(t){return e[t].map(function(e){return e.id})}),p=[].concat.apply([],i),Object.keys(n).forEach(function(e){n[e].forEach(function(e){e&&-1===s.indexOf(e.id)&&-1===p.indexOf(e.id)&&-1===m.weightIds.indexOf(e.id)&&e.dispose()})}),[2,o]}})})},e.prototype.executeWithControlFlow=function(e,t){return __awaiter(this,void 0,void 0,function(){var a,r,n,o,s,i,p,m,u=this;return __generator(this,function(l){switch(l.label){case 0:a=Object.keys(e),r=a.map(function(e){return u.graph.nodes[e]}),n=r.concat(this.graph.weights).map(function(e){return{node:e,contexts:t.currentContext}}),o=__assign({},this.weightMap,e),s={},i=this.getFrozenTensorIds(o),p={},l.label=1;case 1:return n.length>0?(m=this.processStack(r,n,t,o,p,i,s),[4,Promise.all(m)]):[3,3];case 2:return l.sent(),[3,1];case 3:return[2,o]}})})},e.prototype.processStack=function(e,t,a,r,n,o,s){for(var i=this,p=[],m=function(){var m=t.pop();a.currentContext=m.contexts;var l="";if("enter"===m.node.op&&getParamValue("isConstant",m.node,r,a)&&(l=getNodeNameAndIndex(m.node.name,a)[0]),-1===e.indexOf(m.node)){var d=executeOp$15(m.node,r,a);l||(l=getNodeNameAndIndex(m.node.name,a)[0]);var c=a.currentContext;d instanceof Promise?p.push(d.then(function(e){return r[l]=e,a.currentContext=c,i.checkTensorForDisposal(l,m.node,r,a,o,s),i.processChildNodes(m.node,t,a,r,n),e})):(r[l]=d,u.checkTensorForDisposal(l,m.node,r,a,o,s),u.processChildNodes(m.node,t,a,r,n))}else u.processChildNodes(m.node,t,a,r,n)},u=this;t.length>0;)m();return p},e.prototype.processChildNodes=function(e,t,a,r,n){e.children.forEach(function(e){var o=getNodeNameAndIndex(e.name,a)[0];n[o]||("merge"===e.op?e.inputNames.some(function(e){return!!getTensor(e,r,a)})&&(n[o]=!0,t.push({contexts:a.currentContext,node:e})):e.inputNames.every(function(e){return!!getTensor(e,r,a)})&&(n[o]=!0,t.push({contexts:a.currentContext,node:e})))})},e.prototype.calculateOutputs=function(e){return!e||e instanceof Array||(e=[e]),e||this.graph.outputs.map(function(e){return e.name})},e.prototype.findOutputs=function(e,t,a){return this.calculateOutputs(a).reduce(function(a,r){return a[r]=getTensor(r,e,t),a},{})},e.prototype.dispose=function(){var e=this;Object.keys(this.weightMap).forEach(function(t){return e.weightMap[t].forEach(function(e){return e.dispose()})})},e.prototype.checkInputShapeAndType=function(e,t){void 0===t&&(t=!0),this.placeholders.forEach(function(a){var r=e[a.name];if(t||r){var n=r[0];if(a.params.shape&&a.params.shape.value){var o=a.params.shape.value,s=o.length===n.shape.length&&n.shape.every(function(e,t){return-1===o[t]||o[t]===e});_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(s,"The shape of dict['"+a.name+"'] provided in model.execute(dict) must be ["+o+"], but was ["+n.shape+"]")}a.params.dtype&&a.params.dtype.value&&_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(n.dtype===a.params.dtype.value,"The dtype of dict['"+a.name+"'] provided in model.execute(dict) must be "+a.params.dtype.value+", but was "+n.dtype)}})},e.prototype.checkInput=function(e,t){var a=this;void 0===t&&(t=!0);var r=Object.keys(e),n=[],o=[];this.inputNodes.forEach(function(e){-1===r.indexOf(e)&&n.push(e)}),r.forEach(function(e){-1===a.inputNodes.indexOf(e)&&o.push(e)});var s=o.filter(function(e){return!a.graph.nodes[e]});if(n.length>0&&t)throw new Error("The dict provided in model.execute(dict) has the keys ["+r+"], but is missing the required keys: ["+n+"].");if(o.length>0&&t)throw new Error("The dict provided in model.execute(dict) has unused keys: ["+o+"]. Please provide only the following keys: ["+this.inputNodes+"].");if(s.length>0)throw new Error("The dict provided in model.execute(dict) has keys: ["+s+"] not part of model graph.")},e.prototype.checkOutput=function(e,t){var a=e.map(function(e){return e.name}),r=[];if(t.forEach(function(e){-1===a.indexOf(e)&&r.push(e)}),r.length>0)throw new Error("The following outputs are not be generated by the execution: ["+r+"].")},e}(),FrozenModel=function(){function e(e,t,a){this.modelUrl=e,this.weightManifestUrl=t,this.requestOption=a,this.version="n/a"}return Object.defineProperty(e.prototype,"modelVersion",{get:function(){return this.version},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"inputNodes",{get:function(){return this.executor.inputNodes},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"outputNodes",{get:function(){return this.executor.outputNodes},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"inputs",{get:function(){return this.executor.inputs},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"outputs",{get:function(){return this.executor.outputs},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"weights",{get:function(){return this.executor.weightMap},enumerable:!0,configurable:!0}),e.prototype.findIOHandler=function(){var e=[this.modelUrl,this.weightManifestUrl];if(this.requestOption)this.handler=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["io"].browserHTTPRequest(e,this.requestOption);else{var t=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["io"].getLoadHandlers(e);if(0===t.length)t.push(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["io"].browserHTTPRequest(e,this.requestOption));else if(t.length>1)throw new Error("Found more than one ("+t.length+") load handlers for URL '"+[e]+"'");this.handler=t[0]}},e.prototype.load=function(){return __awaiter(this,void 0,void 0,function(){var e,t,a;return __generator(this,function(r){switch(r.label){case 0:if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");return[4,this.handler.load()];case 1:return e=r.sent(),t=compiled_api_1.GraphDef.decode(new Uint8Array(e.modelTopology)),this.version=t.versions.producer+"."+t.versions.minConsumer,a=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["io"].decodeWeights(e.weightData,e.weightSpecs),this.executor=new GraphExecutor(OperationMapper.Instance.transformGraph(t)),this.executor.weightMap=this.convertTensorMapToTensorsMap(a),[2,!0]}})})},e.prototype.predict=function(e,t){return this.execute_(e,!0,this.outputNodes)},e.prototype.constructTensorMap=function(e){var t=e instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Tensor"]?[e]:e;if(t.length!==this.inputNodes.length)throw new Error("Input tensor count mismatch,the frozen model has "+this.inputNodes.length+" placeholders, while there are "+t.length+" input tensors.");return this.inputNodes.reduce(function(e,a,r){return e[a]=t[r],e},{})},e.prototype.execute=function(e,t){return this.execute_(e,!1,t)},e.prototype.execute_=function(e,t,a){if(void 0===t&&(t=!0),a=a||this.outputNodes,(e instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Tensor"]||Array.isArray(e))&&(e=this.constructTensorMap(e)),this.executor.isControlFlowModel||this.executor.isDynamicShapeModel)throw new Error("The model contains control flow or dynamic shape ops, please use executeAsync method");var r=this.executor.execute(this.convertTensorMapToTensorsMap(e),t,a),n=Object.keys(r);return Array.isArray(a)&&a.length>1?a.map(function(e){return r[e]}):r[n[0]]},e.prototype.executeAsync=function(e,t){return __awaiter(this,void 0,void 0,function(){var a,r;return __generator(this,function(n){switch(n.label){case 0:if(!this.executor.isControlFlowModel&&!this.executor.isDynamicShapeModel)throw new Error("The model does not contain control flow or dynamic shape ops, please use execute method for better performance.");return t=t||this.outputNodes,(e instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Tensor"]||Array.isArray(e))&&(e=this.constructTensorMap(e)),[4,this.executor.executeAsync(this.convertTensorMapToTensorsMap(e),t)];case 1:return a=n.sent(),r=Object.keys(a),[2,Array.isArray(t)&&t.length>1?t.map(function(e){return a[e]}):a[r[0]]]}})})},e.prototype.convertTensorMapToTensorsMap=function(e){return Object.keys(e).reduce(function(t,a){return t[a]=[e[a]],t},{})},e.prototype.dispose=function(){this.executor.dispose()},e}();function loadFrozenModel(e,t,a){return __awaiter(this,void 0,void 0,function(){var r;return __generator(this,function(n){switch(n.label){case 0:return[4,(r=new FrozenModel(e,t,a)).load()];case 1:return n.sent(),[2,r]}})})}var version="0.6.7";
//# sourceMappingURL=tf-converter.esm.js.map

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js":
/*!****************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js ***!
  \****************************************************************/
/*! exports provided: setBackend, getBackend, disposeVariables, memory, version_core, nextFrame, environment, io, math, serialization, test_util, util, webgl, AdadeltaOptimizer, AdagradOptimizer, AdamOptimizer, AdamaxOptimizer, MomentumOptimizer, Optimizer, RMSPropOptimizer, SGDOptimizer, Tensor, TensorBuffer, variable, Variable, Rank, Reduction, ENV, Environment, KernelBackend, DataStorage, image, linalg, losses, spectral, op, batchNormalization2d, batchNormalization3d, batchNormalization4d, batchNormalization, complex, real, imag, concat, concat1d, concat2d, concat3d, concat4d, split, conv1d, conv2d, conv2dDerFilter, depthwiseConv2d, separableConv2d, conv2dTranspose, matMul, dot, outerProduct, reverse, reverse1d, reverse2d, reverse3d, reverse4d, maxPool, avgPool, pool, slice, slice1d, slice2d, slice3d, slice4d, abs, acos, acosh, asin, asinh, atan, atanh, ceil, clipByValue, cos, cosh, erf, exp, expm1, floor, log, log1p, logSigmoid, neg, reciprocal, round, rsqrt, sigmoid, sign, sin, sinh, softplus, sqrt, square, step, tan, tanh, all, any, argMax, argMin, logSumExp, max, mean, min, moments, sum, prod, equal, equalStrict, greater, greaterEqual, greaterEqualStrict, greaterStrict, less, lessEqual, lessEqualStrict, lessStrict, notEqual, notEqualStrict, add, addN, addStrict, atan2, div, divStrict, floorDiv, maximum, maximumStrict, minimum, minimumStrict, mod, modStrict, mul, mulStrict, pow, powStrict, squaredDifference, squaredDifferenceStrict, sub, subStrict, elu, leakyRelu, prelu, relu, selu, logicalAnd, logicalNot, logicalOr, logicalXor, where, whereAsync, buffer, toPixels, print, batchToSpaceND, cast, clone, cumsum, depthToSpace, expandDims, eye, fromPixels, multinomial, oneHot, pad, pad1d, pad2d, pad3d, pad4d, rand, randomNormal, randomUniform, reshape, spaceToBatchND, squeeze, stack, tile, truncatedNormal, unstack, setdiff1dAsync, fill, linspace, ones, range, scalar, tensor, tensor1d, tensor2d, tensor3d, tensor4d, tensor5d, tensor6d, zeros, onesLike, zerosLike, transpose, softmax, logSoftmax, localResponseNormalization, norm, gather, unsortedSegmentSum, basicLSTMCell, multiRNNCell, movingAverage, stridedSlice, topk, scatterND, fft, ifft, rfft, sparseToDense, gatherND, train, tidy, keep, dispose, time, profile, customGrad, grad, grads, valueAndGrad, valueAndGrads, variableGrads */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(process, global, setImmediate, Buffer) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setBackend", function() { return setBackend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBackend", function() { return getBackend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "disposeVariables", function() { return disposeVariables; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "memory", function() { return memory; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version_core", function() { return version; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nextFrame", function() { return nextFrame; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "environment", function() { return environment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "io", function() { return io; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "math", function() { return math; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "serialization", function() { return serialization; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "test_util", function() { return test_util; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "util", function() { return util; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "webgl", function() { return webgl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AdadeltaOptimizer", function() { return AdadeltaOptimizer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AdagradOptimizer", function() { return AdagradOptimizer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AdamOptimizer", function() { return AdamOptimizer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AdamaxOptimizer", function() { return AdamaxOptimizer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MomentumOptimizer", function() { return MomentumOptimizer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Optimizer", function() { return Optimizer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RMSPropOptimizer", function() { return RMSPropOptimizer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SGDOptimizer", function() { return SGDOptimizer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Tensor", function() { return Tensor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TensorBuffer", function() { return TensorBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "variable", function() { return variable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Variable", function() { return Variable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Rank", function() { return Rank; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Reduction", function() { return Reduction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ENV", function() { return ENV; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Environment", function() { return Environment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KernelBackend", function() { return KernelBackend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataStorage", function() { return DataStorage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "image", function() { return image_ops; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linalg", function() { return linalg_ops; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "losses", function() { return loss_ops; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "spectral", function() { return spectral_ops; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "op", function() { return op; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "batchNormalization2d", function() { return batchNormalization2d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "batchNormalization3d", function() { return batchNormalization3d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "batchNormalization4d", function() { return batchNormalization4d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "batchNormalization", function() { return batchNormalization; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "complex", function() { return complex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "real", function() { return real; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "imag", function() { return imag; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concat", function() { return concat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concat1d", function() { return concat1d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concat2d", function() { return concat2d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concat3d", function() { return concat3d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concat4d", function() { return concat4d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "split", function() { return split$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conv1d", function() { return conv1d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conv2d", function() { return conv2d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conv2dDerFilter", function() { return conv2dDerFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "depthwiseConv2d", function() { return depthwiseConv2d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "separableConv2d", function() { return separableConv2d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conv2dTranspose", function() { return conv2dTranspose; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "matMul", function() { return matMul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "outerProduct", function() { return outerProduct; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reverse", function() { return reverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reverse1d", function() { return reverse1d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reverse2d", function() { return reverse2d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reverse3d", function() { return reverse3d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reverse4d", function() { return reverse4d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "maxPool", function() { return maxPool; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "avgPool", function() { return avgPool; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pool", function() { return pool; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slice", function() { return slice; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slice1d", function() { return slice1d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slice2d", function() { return slice2d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slice3d", function() { return slice3d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slice4d", function() { return slice4d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "abs", function() { return abs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "acos", function() { return acos; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "acosh", function() { return acosh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "asin", function() { return asin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "asinh", function() { return asinh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "atan", function() { return atan; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "atanh", function() { return atanh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ceil", function() { return ceil; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clipByValue", function() { return clipByValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cos", function() { return cos; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cosh", function() { return cosh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "erf", function() { return erf; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exp", function() { return exp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "expm1", function() { return expm1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floor", function() { return floor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "log", function() { return log$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "log1p", function() { return log1p; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "logSigmoid", function() { return logSigmoid; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "neg", function() { return neg; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reciprocal", function() { return reciprocal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round", function() { return round; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rsqrt", function() { return rsqrt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sigmoid", function() { return sigmoid; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sign", function() { return sign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sin", function() { return sin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sinh", function() { return sinh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "softplus", function() { return softplus; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrt", function() { return sqrt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "square", function() { return square; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "step", function() { return step; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tan", function() { return tan; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tanh", function() { return tanh$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "all", function() { return all; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "any", function() { return any; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "argMax", function() { return argMax; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "argMin", function() { return argMin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "logSumExp", function() { return logSumExp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "max", function() { return max; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mean", function() { return mean; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "min", function() { return min; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "moments", function() { return moments; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sum", function() { return sum$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "prod", function() { return prod; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equal", function() { return equal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equalStrict", function() { return equalStrict; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "greater", function() { return greater; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "greaterEqual", function() { return greaterEqual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "greaterEqualStrict", function() { return greaterEqualStrict; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "greaterStrict", function() { return greaterStrict; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "less", function() { return less; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lessEqual", function() { return lessEqual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lessEqualStrict", function() { return lessEqualStrict; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lessStrict", function() { return lessStrict; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "notEqual", function() { return notEqual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "notEqualStrict", function() { return notEqualStrict; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addN", function() { return addN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addStrict", function() { return addStrict; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "atan2", function() { return atan2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "div", function() { return div; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divStrict", function() { return divStrict; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floorDiv", function() { return floorDiv; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "maximum", function() { return maximum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "maximumStrict", function() { return maximumStrict; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "minimum", function() { return minimum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "minimumStrict", function() { return minimumStrict; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mod", function() { return mod; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "modStrict", function() { return modStrict; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mulStrict", function() { return mulStrict; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pow", function() { return pow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "powStrict", function() { return powStrict; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDifference", function() { return squaredDifference; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDifferenceStrict", function() { return squaredDifferenceStrict; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subStrict", function() { return subStrict; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "elu", function() { return elu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "leakyRelu", function() { return leakyRelu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "prelu", function() { return prelu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "relu", function() { return relu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "selu", function() { return selu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "logicalAnd", function() { return logicalAnd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "logicalNot", function() { return logicalNot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "logicalOr", function() { return logicalOr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "logicalXor", function() { return logicalXor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "where", function() { return where; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "whereAsync", function() { return whereAsync; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buffer", function() { return buffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toPixels", function() { return toPixels; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "print", function() { return print; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "batchToSpaceND", function() { return batchToSpaceND; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cast", function() { return cast; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cumsum", function() { return cumsum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "depthToSpace", function() { return depthToSpace; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "expandDims", function() { return expandDims; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "eye", function() { return eye; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromPixels", function() { return fromPixels; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multinomial", function() { return multinomial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "oneHot", function() { return oneHot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pad", function() { return pad; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pad1d", function() { return pad1d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pad2d", function() { return pad2d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pad3d", function() { return pad3d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pad4d", function() { return pad4d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rand", function() { return rand; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "randomNormal", function() { return randomNormal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "randomUniform", function() { return randomUniform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reshape", function() { return reshape; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "spaceToBatchND", function() { return spaceToBatchND; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squeeze", function() { return squeeze; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stack", function() { return stack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tile", function() { return tile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "truncatedNormal", function() { return truncatedNormal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unstack", function() { return unstack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setdiff1dAsync", function() { return setdiff1dAsync; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fill", function() { return fill; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linspace", function() { return linspace; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ones", function() { return ones$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "range", function() { return range; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scalar", function() { return scalar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tensor", function() { return tensor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tensor1d", function() { return tensor1d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tensor2d", function() { return tensor2d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tensor3d", function() { return tensor3d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tensor4d", function() { return tensor4d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tensor5d", function() { return tensor5d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tensor6d", function() { return tensor6d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zeros", function() { return zeros; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onesLike", function() { return onesLike; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zerosLike", function() { return zerosLike; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transpose", function() { return transpose; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "softmax", function() { return softmax; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "logSoftmax", function() { return logSoftmax; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "localResponseNormalization", function() { return localResponseNormalization; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "norm", function() { return norm; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gather", function() { return gather; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unsortedSegmentSum", function() { return unsortedSegmentSum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "basicLSTMCell", function() { return basicLSTMCell; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiRNNCell", function() { return multiRNNCell; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "movingAverage", function() { return movingAverage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stridedSlice", function() { return stridedSlice; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "topk", function() { return topk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scatterND", function() { return scatterND; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fft", function() { return fft; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ifft", function() { return ifft; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rfft", function() { return rfft; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sparseToDense", function() { return sparseToDense; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gatherND", function() { return gatherND; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "train", function() { return train; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tidy", function() { return tidy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "keep", function() { return keep; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dispose", function() { return dispose; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "time", function() { return time; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "profile", function() { return profile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "customGrad", function() { return customGrad; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "grad", function() { return grad; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "grads", function() { return grads; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "valueAndGrad", function() { return valueAndGrad; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "valueAndGrads", function() { return valueAndGrads; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "variableGrads", function() { return variableGrads; });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])};function __extends(e,t){function r(){this.constructor=e}extendStatics(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)}var __assign=Object.assign||function(e){for(var t,r=1,n=arguments.length;r<n;r++)for(var o in t=arguments[r])Object.prototype.hasOwnProperty.call(t,o)&&(e[o]=t[o]);return e};function __awaiter(e,t,r,n){return new(r||(r=Promise))(function(o,a){function i(e){try{u(n.next(e))}catch(e){a(e)}}function s(e){try{u(n.throw(e))}catch(e){a(e)}}function u(e){e.done?o(e.value):new r(function(t){t(e.value)}).then(i,s)}u((n=n.apply(e,t||[])).next())})}function __generator(e,t){var r,n,o,a,i={label:0,sent:function(){if(1&o[0])throw o[1];return o[1]},trys:[],ops:[]};return a={next:s(0),throw:s(1),return:s(2)},"function"==typeof Symbol&&(a[Symbol.iterator]=function(){return this}),a;function s(a){return function(s){return function(a){if(r)throw new TypeError("Generator is already executing.");for(;i;)try{if(r=1,n&&(o=2&a[0]?n.return:a[0]?n.throw||((o=n.return)&&o.call(n),0):n.next)&&!(o=o.call(n,a[1])).done)return o;switch(n=0,o&&(a=[2&a[0],o.value]),a[0]){case 0:case 1:o=a;break;case 4:return i.label++,{value:a[1],done:!1};case 5:i.label++,n=a[1],a=[0];continue;case 7:a=i.ops.pop(),i.trys.pop();continue;default:if(!(o=(o=i.trys).length>0&&o[o.length-1])&&(6===a[0]||2===a[0])){i=0;continue}if(3===a[0]&&(!o||a[1]>o[0]&&a[1]<o[3])){i.label=a[1];break}if(6===a[0]&&i.label<o[1]){i.label=o[1],o=a;break}if(o&&i.label<o[2]){i.label=o[2],i.ops.push(a);break}o[2]&&i.ops.pop(),i.trys.pop();continue}a=t.call(e,i)}catch(e){a=[6,e],n=0}finally{r=o=0}if(5&a[0])throw a[1];return{value:a[0]?a[1]:void 0,done:!0}}([a,s])}}}var contexts={},WEBGL_ATTRIBUTES={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function getWebGLContext(e){e in contexts||(document.createElement("canvas").addEventListener("webglcontextlost",function(t){t.preventDefault(),delete contexts[e]},!1),contexts[e]=getWebGLRenderingContext(e));var t=contexts[e];return t.isContextLost()?(delete contexts[e],getWebGLContext(e)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),contexts[e])}function getWebGLRenderingContext(e){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");var t=document.createElement("canvas");return 1===e?t.getContext("webgl",WEBGL_ATTRIBUTES)||t.getContext("experimental-webgl",WEBGL_ATTRIBUTES):t.getContext("webgl2",WEBGL_ATTRIBUTES)}function isMobile(){var e=navigator.userAgent||navigator.vendor||window.opera;return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}function shuffle(e){for(var t=e.length,r=0,n=0;t>0;)n=Math.random()*t|0,r=e[--t],e[t]=e[n],e[n]=r}function clamp(e,t,r){return Math.max(e,Math.min(t,r))}function nearestLargerEven(e){return e%2==0?e:e+1}function sum(e){for(var t=0,r=0;r<e.length;r++)t+=e[r];return t}function randUniform(e,t){var r=Math.random();return t*r+(1-r)*e}function distSquared(e,t){for(var r=0,n=0;n<e.length;n++){var o=Number(e[n])-Number(t[n]);r+=o*o}return r}function assert(e,t){if(!e)throw new Error("string"==typeof t?t:t())}function assertShapesMatch(e,t,r){void 0===r&&(r=""),assert(arraysEqual(e,t),r+" Shapes "+e+" and "+t+" must match")}function assertNonNull(e){assert(null!=e,"The input to the tensor constructor must be a non-null value.")}function flatten(e,t){if(void 0===t&&(t=[]),Array.isArray(e))for(var r=0;r<e.length;++r)flatten(e[r],t);else t.push(e);return t}function sizeFromShape(e){if(0===e.length)return 1;for(var t=e[0],r=1;r<e.length;r++)t*=e[r];return t}function isScalarShape(e){return 0===e.length}function arraysEqual(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(var r=0;r<e.length;r++)if(e[r]!==t[r])return!1;return!0}function isInt(e){return e%1==0}function tanh(e){if(null!=Math.tanh)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return-1;var t=Math.exp(2*e);return(t-1)/(t+1)}function sizeToSquarishShape(e){for(var t=Math.floor(Math.sqrt(e));t>1;--t)if(e%t==0)return[t,e/t];return[1,e]}function createShuffledIndices(e){for(var t=new Uint32Array(e),r=0;r<e;++r)t[r]=r;return shuffle(t),t}function rightPad(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function repeatedTry(e,t,r){return void 0===t&&(t=function(e){return 0}),new Promise(function(n,o){var a=0,i=function(){if(e())n();else{var s=t(++a);null!=r&&a>=r?o():setTimeout(i,s)}};i()})}function inferFromImplicitShape(e,t){for(var r=1,n=-1,o=0;o<e.length;++o)if(e[o]>=0)r*=e[o];else if(-1===e[o]){if(-1!==n)throw Error("Shapes can only have 1 implicit size. Found -1 at dim "+n+" and dim "+o);n=o}else if(e[o]<0)throw Error("Shapes can not be < 0. Found "+e[o]+" at dim "+o);if(-1===n){if(t>0&&t!==r)throw Error("Size("+t+") must match the product of shape "+e);return e}if(0===r)throw Error("Cannot infer the missing size in ["+e+"] when there are 0 elements");if(t%r!=0)throw Error("The implicit shape can't be a fractional number. Got "+t+" / "+r);var a=e.slice();return a[n]=t/r,a}function squeezeShape(e,t){for(var r=[],n=[],o=0,a=0;a<e.length;++a){if(null!=t){if(t[o]===a&&1!==e[a])throw new Error("Can't squeeze axis "+a+" since its dim '"+e[a]+"' is not 1");(null==t[o]||t[o]>a)&&1===e[a]&&(r.push(e[a]),n.push(a)),t[o]<=a&&o++}1!==e[a]&&(r.push(e[a]),n.push(a))}return{newShape:r,keptDims:n}}function getTypedArrayFromDType(e,t){var r=null;if(null==e||"float32"===e)r=new Float32Array(t);else if("int32"===e)r=new Int32Array(t);else{if("bool"!==e)throw new Error("Unknown data type "+e);r=new Uint8Array(t)}return r}function checkComputationForNaN(e,t,r){if("float32"===t)for(var n=0;n<e.length;n++)if(isNaN(e[n]))throw Error("The result of the '"+r+"' has NaNs.")}function checkConversionForNaN(e,t){if("float32"!==t)for(var r=0;r<e.length;r++)if(isNaN(e[r]))throw Error("NaN is not a valid value for dtype: '"+t+"'.")}function hasEncodingLoss(e,t){return"complex64"!==t&&(("float32"!==t||"complex64"===e)&&(("int32"!==t||"float32"===e||"complex64"===e)&&("bool"!==t||"bool"!==e)))}function copyTypedArray(e,t,r){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return r&&checkConversionForNaN(e,t),new Int32Array(e);if("bool"===t){for(var n=new Uint8Array(e.length),o=0;o<n.length;++o)0!==Math.round(e[o])&&(n[o]=1);return n}throw new Error("Unknown data type "+t)}function isTypedArray(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array}function bytesPerElement(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error("Unknown dtype "+e)}function isFunction(e){return!!(e&&e.constructor&&e.call&&e.apply)}function nearestDivisor(e,t){for(var r=t;r<e;++r)if(e%r==0)return r;return e}function computeStrides(e){var t=e.length;if(t<2)return[];var r=new Array(t-1);r[t-2]=e[t-1];for(var n=t-3;n>=0;--n)r[n]=r[n+1]*e[n+1];return r}function toTypedArray(e,t,r){return noConversionNeeded(e,t)?e:(Array.isArray(e)&&(e=flatten(e)),copyTypedArray(e,t,r))}function noConversionNeeded(e,t){return e instanceof Float32Array&&"float32"===t||e instanceof Int32Array&&"int32"===t||e instanceof Uint8Array&&"bool"===t}function makeOnesTypedArray(e,t){for(var r=makeZerosTypedArray(e,t),n=0;n<r.length;n++)r[n]=1;return r}function makeZerosTypedArray(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error("Unknown data type "+t)}function now(){if("undefined"!=typeof performance)return performance.now();if("undefined"!=typeof process){var e=process.hrtime();return 1e3*e[0]+e[1]/1e6}throw new Error("Cannot measure time in this environment. You should run tf.js in the browser or in Node.js")}var util=Object.freeze({shuffle:shuffle,clamp:clamp,nearestLargerEven:nearestLargerEven,sum:sum,randUniform:randUniform,distSquared:distSquared,assert:assert,assertShapesMatch:assertShapesMatch,assertNonNull:assertNonNull,flatten:flatten,sizeFromShape:sizeFromShape,isScalarShape:isScalarShape,arraysEqual:arraysEqual,isInt:isInt,tanh:tanh,sizeToSquarishShape:sizeToSquarishShape,createShuffledIndices:createShuffledIndices,rightPad:rightPad,repeatedTry:repeatedTry,inferFromImplicitShape:inferFromImplicitShape,squeezeShape:squeezeShape,getTypedArrayFromDType:getTypedArrayFromDType,checkComputationForNaN:checkComputationForNaN,checkConversionForNaN:checkConversionForNaN,hasEncodingLoss:hasEncodingLoss,isTypedArray:isTypedArray,bytesPerElement:bytesPerElement,isFunction:isFunction,nearestDivisor:nearestDivisor,computeStrides:computeStrides,toTypedArray:toTypedArray,makeOnesTypedArray:makeOnesTypedArray,makeZerosTypedArray:makeZerosTypedArray,now:now}),Profiler=function(){function e(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new Logger)}return e.prototype.profileKernel=function(e,t){var r,n=this,o=this.backendTimer.time(function(){r=t()});return(Array.isArray(r)?r:[r]).forEach(function(t){var r=t.dataSync();checkComputationForNaN(r,t.dtype,e),o.then(function(o){var a="";null!=o.getExtraProfileInfo&&(a=o.getExtraProfileInfo()),n.logger.logKernelProfile(e,t,r,o.kernelMs,a)})}),r},e}(),Logger=function(){function e(){}return e.prototype.logKernelProfile=function(e,t,r,n,o){var a=rightPad(n+"ms",9),i=rightPad(e,25),s=t.rank,u=t.size,l=rightPad(t.shape.toString(),14);console.log("%c"+i+"\t%c"+a+"\t%c"+s+"D "+l+"\t%c"+u+"\t%c"+o,"font-weight:bold","color:red","color:blue","color: orange","color: green")},e}(),FORMAT_LIMIT_NUM_VALS=20,FORMAT_NUM_FIRST_LAST_VALS=3,FORMAT_NUM_SIG_DIGITS=7;function tensorToString(e,t,r,n){var o=computeStrides(t),a=computeMaxSizePerColumn(e,t,r,o),i=t.length,s=subTensorToString(e,t,r,o,a),u=["Tensor"];return n&&(u.push("  dtype: "+r),u.push("  rank: "+i),u.push("  shape: ["+t+"]"),u.push("  values:")),u.push(s.map(function(e){return"    "+e}).join("\n")),u.join("\n")}function computeMaxSizePerColumn(e,t,r,n){var o=sizeFromShape(t),a=n[n.length-1],i=new Array(a).fill(0),s=t.length,u="complex64"===r?createComplexTuples(e):e;if(s>1)for(var l=0;l<o/a;l++)for(var c=l*a,p=0;p<a;p++)i[p]=Math.max(i[p],valToString(u[c+p],0).length);return i}function valToString(e,t){return rightPad(Array.isArray(e)?parseFloat(e[0].toFixed(FORMAT_NUM_SIG_DIGITS))+" + "+parseFloat(e[1].toFixed(FORMAT_NUM_SIG_DIGITS))+"j":parseFloat(e.toFixed(FORMAT_NUM_SIG_DIGITS)).toString(),t)}function subTensorToString(e,t,r,n,o,a){void 0===a&&(a=!0);var i="complex64"===r?2:1,s=t[0],u=t.length;if(0===u)return"complex64"===r?[valToString(createComplexTuples(e)[0],0)]:[e[0].toString()];if(1===u){if(s>FORMAT_LIMIT_NUM_VALS){var l=FORMAT_NUM_FIRST_LAST_VALS*i,c=Array.from(e.subarray(0,l)),p=Array.from(e.subarray(s-FORMAT_NUM_FIRST_LAST_VALS*i,s));return"complex64"===r&&(c=createComplexTuples(c),p=createComplexTuples(p)),["["+c.map(function(e,t){return valToString(e,o[t])}).join(", ")+", ..., "+p.map(function(e,t){return valToString(e,o[s-FORMAT_NUM_FIRST_LAST_VALS+t])}).join(", ")+"]"]}return["["+("complex64"===r?createComplexTuples(e):Array.from(e)).map(function(e,t){return valToString(e,o[t])}).join(", ")+"]"]}var d=t.slice(1),h=n.slice(1),f=n[0]*i,m=[];if(s>FORMAT_LIMIT_NUM_VALS){for(var g=0;g<FORMAT_NUM_FIRST_LAST_VALS;g++){var v=(y=g*f)+f;m.push.apply(m,subTensorToString(e.subarray(y,v),d,r,h,o,!1))}m.push("...");for(g=s-FORMAT_NUM_FIRST_LAST_VALS;g<s;g++){v=(y=g*f)+f;m.push.apply(m,subTensorToString(e.subarray(y,v),d,r,h,o,g===s-1))}}else for(g=0;g<s;g++){var y;v=(y=g*f)+f;m.push.apply(m,subTensorToString(e.subarray(y,v),d,r,h,o,g===s-1))}var x=2===u?",":"";m[0]="["+m[0]+x;for(g=1;g<m.length-1;g++)m[g]=" "+m[g]+x;var T=",\n";for(g=2;g<u;g++)T+="\n";return m[m.length-1]=" "+m[m.length-1]+"]"+(a?"":T),m}function createComplexTuples(e){for(var t=[],r=0;r<e.length;r+=2)t.push([e[r],e[r+1]]);return t}var TensorBuffer=function(){function e(e,t,r){if(this.dtype=t,this.shape=e.slice(),this.size=sizeFromShape(e),null!=r){var n=r.length;assert(n===this.size,"Length of values '"+n+"' does not match the size inferred by the shape '"+this.size+"'.")}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||getTypedArrayFromDType(t,sizeFromShape(this.shape)),this.strides=computeStrides(e)}return e.prototype.set=function(e){for(var t=[],r=1;r<arguments.length;r++)t[r-1]=arguments[r];0===t.length&&(t=[0]),assert(t.length===this.rank,"The number of provided coordinates ("+t.length+") must match the rank ("+this.rank+")");var n=this.locToIndex(t);this.values[n]=e},e.prototype.get=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];0===e.length&&(e=[0]);for(var r=e[e.length-1],n=0;n<e.length-1;++n)r+=this.strides[n]*e[n];return this.values[r]},e.prototype.locToIndex=function(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];for(var t=e[e.length-1],r=0;r<e.length-1;++r)t+=this.strides[r]*e[r];return t},e.prototype.indexToLoc=function(e){if(0===this.rank)return[];if(1===this.rank)return[e];for(var t=new Array(this.shape.length),r=0;r<t.length-1;++r)t[r]=Math.floor(e/this.strides[r]),e-=t[r]*this.strides[r];return t[t.length-1]=e,t},Object.defineProperty(e.prototype,"rank",{get:function(){return this.shape.length},enumerable:!0,configurable:!0}),e.prototype.toTensor=function(){return Tensor.make(this.shape,{values:this.values},this.dtype)},e}(),trackerFn=null,opHandler=null;function setTensorTracker(e){trackerFn=e}function setOpHandler(e){opHandler=e}var Tensor=function(){function e(e,t,r,n){this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=sizeFromShape(e),null!=r&&assert(this.size===r.length,"Based on the provided shape, ["+e+"], and dtype "+this.dtype+", the tensor should have "+this.size+" values but has "+r.length),this.strides=computeStrides(e),this.dataId=null!=n?n:{},this.id=trackerFn().nextTensorId(),this.rankType=this.rank<5?this.rank.toString():"higher",trackerFn().registerTensor(this),null!=r&&trackerFn().write(this.dataId,r)}return e.make=function(t,r,n){return new e(t,n,r.values,r.dataId)},e.prototype.flatten=function(){return this.throwIfDisposed(),this.as1D()},e.prototype.asScalar=function(){return this.throwIfDisposed(),assert(1===this.size,"The array must have only 1 element."),this.reshape([])},e.prototype.as1D=function(){return this.throwIfDisposed(),this.reshape([this.size])},e.prototype.as2D=function(e,t){return this.throwIfDisposed(),this.reshape([e,t])},e.prototype.as3D=function(e,t,r){return this.throwIfDisposed(),this.reshape([e,t,r])},e.prototype.as4D=function(e,t,r,n){return this.throwIfDisposed(),this.reshape([e,t,r,n])},e.prototype.asType=function(e){return this.throwIfDisposed(),opHandler.cast(this,e)},Object.defineProperty(e.prototype,"rank",{get:function(){return this.shape.length},enumerable:!0,configurable:!0}),e.prototype.get=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];assert(e.length===this.rank,"Number of coordinates in get() must match the rank of the tensor"),assert("complex64"!==this.dtype,"Tensor.get() is not supported for complex64 tensors yet."),this.throwIfDisposed(),0===e.length&&(e=[0]);for(var r=e[e.length-1],n=0;n<e.length-1;++n)r+=this.strides[n]*e[n];return this.dataSync()[r]},e.prototype.buffer=function(){return opHandler.buffer(this.shape,this.dtype,this.dataSync())},e.prototype.data=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(e){return this.throwIfDisposed(),[2,trackerFn().read(this.dataId)]})})},e.prototype.dataSync=function(){return this.throwIfDisposed(),trackerFn().readSync(this.dataId)},e.prototype.dispose=function(){this.isDisposed||(trackerFn().disposeTensor(this),this.isDisposedInternal=!0)},Object.defineProperty(e.prototype,"isDisposed",{get:function(){return this.isDisposedInternal},enumerable:!0,configurable:!0}),e.prototype.throwIfDisposed=function(){if(this.isDisposed)throw new Error("Tensor is disposed.")},e.prototype.toFloat=function(){return this.asType("float32")},e.prototype.toInt=function(){return this.asType("int32")},e.prototype.toBool=function(){return this.asType("bool")},e.prototype.print=function(e){return void 0===e&&(e=!1),opHandler.print(this,e)},e.prototype.reshape=function(e){return this.throwIfDisposed(),opHandler.reshape(this,e)},e.prototype.reshapeAs=function(e){return this.throwIfDisposed(),this.reshape(e.shape)},e.prototype.expandDims=function(e){return void 0===e&&(e=0),opHandler.expandDims(this,e)},e.prototype.cumsum=function(e,t,r){return void 0===e&&(e=0),void 0===t&&(t=!1),void 0===r&&(r=!1),opHandler.cumsum(this,e,t,r)},e.prototype.squeeze=function(e){return this.throwIfDisposed(),opHandler.squeeze(this,e)},e.prototype.clone=function(){return this.throwIfDisposed(),opHandler.clone(this)},e.prototype.toString=function(e){return void 0===e&&(e=!1),tensorToString(this.dataSync(),this.shape,this.dtype,e)},e.prototype.tile=function(e){return this.throwIfDisposed(),opHandler.tile(this,e)},e.prototype.gather=function(e,t){return void 0===t&&(t=0),this.throwIfDisposed(),opHandler.gather(this,e,t)},e.prototype.matMul=function(e,t,r){return void 0===t&&(t=!1),void 0===r&&(r=!1),this.throwIfDisposed(),opHandler.matMul(this,e,t,r)},e.prototype.dot=function(e){return this.throwIfDisposed(),opHandler.dot(this,e)},e.prototype.norm=function(e,t,r){return void 0===e&&(e="euclidean"),void 0===t&&(t=null),void 0===r&&(r=!1),this.throwIfDisposed(),opHandler.norm(this,e,t,r)},e.prototype.slice=function(e,t){return this.throwIfDisposed(),opHandler.slice(this,e,t)},e.prototype.reverse=function(e){return this.throwIfDisposed(),opHandler.reverse(this,e)},e.prototype.concat=function(e,t){return void 0===t&&(t=0),this.throwIfDisposed(),opHandler.concat([this,e],t)},e.prototype.split=function(e,t){return void 0===t&&(t=0),this.throwIfDisposed(),opHandler.split(this,e,t)},e.prototype.stack=function(e,t){return void 0===t&&(t=0),opHandler.stack([this,e],t)},e.prototype.unstack=function(e,t){return void 0===t&&(t=0),opHandler.unstack(this,t)},e.prototype.pad=function(e,t){return void 0===t&&(t=0),opHandler.pad(this,e,t)},e.prototype.batchNormalization=function(e,t,r,n,o){return void 0===r&&(r=.001),this.throwIfDisposed(),opHandler.batchNormalization(this,e,t,r,n,o)},e.prototype.all=function(e,t){return void 0===e&&(e=null),void 0===t&&(t=!1),this.throwIfDisposed(),opHandler.all(this,e,t)},e.prototype.any=function(e,t){return void 0===e&&(e=null),void 0===t&&(t=!1),this.throwIfDisposed(),opHandler.any(this,e,t)},e.prototype.logSumExp=function(e,t){return void 0===e&&(e=null),void 0===t&&(t=!1),this.throwIfDisposed(),opHandler.logSumExp(this,e,t)},e.prototype.sum=function(e,t){return void 0===e&&(e=null),void 0===t&&(t=!1),this.throwIfDisposed(),opHandler.sum(this,e,t)},e.prototype.prod=function(e,t){return void 0===e&&(e=null),void 0===t&&(t=!1),this.throwIfDisposed(),opHandler.prod(this,e,t)},e.prototype.mean=function(e,t){return void 0===e&&(e=null),void 0===t&&(t=!1),this.throwIfDisposed(),opHandler.mean(this,e,t)},e.prototype.min=function(e,t){return void 0===e&&(e=null),void 0===t&&(t=!1),this.throwIfDisposed(),opHandler.min(this,e,t)},e.prototype.max=function(e,t){return void 0===e&&(e=null),void 0===t&&(t=!1),this.throwIfDisposed(),opHandler.max(this,e,t)},e.prototype.argMin=function(e){return void 0===e&&(e=null),this.throwIfDisposed(),opHandler.argMin(this,e)},e.prototype.argMax=function(e){return void 0===e&&(e=null),this.throwIfDisposed(),opHandler.argMax(this,e)},e.prototype.cast=function(e){return this.throwIfDisposed(),opHandler.cast(this,e)},e.prototype.add=function(e){return this.throwIfDisposed(),opHandler.add(this,e)},e.prototype.addStrict=function(e){return this.throwIfDisposed(),opHandler.addStrict(this,e)},e.prototype.atan2=function(e){return this.throwIfDisposed(),opHandler.atan2(this,e)},e.prototype.sub=function(e){return this.throwIfDisposed(),opHandler.sub(this,e)},e.prototype.subStrict=function(e){return this.throwIfDisposed(),opHandler.subStrict(this,e)},e.prototype.pow=function(e){return this.throwIfDisposed(),opHandler.pow(this,e)},e.prototype.powStrict=function(e){return this.throwIfDisposed(),opHandler.powStrict(this,e)},e.prototype.mul=function(e){return this.throwIfDisposed(),opHandler.mul(this,e)},e.prototype.mulStrict=function(e){return this.throwIfDisposed(),opHandler.mulStrict(this,e)},e.prototype.div=function(e){return this.throwIfDisposed(),opHandler.div(this,e)},e.prototype.floorDiv=function(e){return this.throwIfDisposed(),opHandler.floorDiv(this,e)},e.prototype.divStrict=function(e){return this.throwIfDisposed(),opHandler.divStrict(this,e)},e.prototype.minimum=function(e){return this.throwIfDisposed(),opHandler.minimum(this,e)},e.prototype.minimumStrict=function(e){return this.throwIfDisposed(),opHandler.minimumStrict(this,e)},e.prototype.maximum=function(e){return this.throwIfDisposed(),opHandler.maximum(this,e)},e.prototype.maximumStrict=function(e){return this.throwIfDisposed(),opHandler.maximumStrict(this,e)},e.prototype.mod=function(e){return this.throwIfDisposed(),opHandler.mod(this,e)},e.prototype.modStrict=function(e){return this.throwIfDisposed(),opHandler.modStrict(this,e)},e.prototype.squaredDifference=function(e){return this.throwIfDisposed(),opHandler.squaredDifference(this,e)},e.prototype.squaredDifferenceStrict=function(e){return this.throwIfDisposed(),opHandler.squaredDifferenceStrict(this,e)},e.prototype.transpose=function(e){return this.throwIfDisposed(),opHandler.transpose(this,e)},e.prototype.notEqual=function(e){return this.throwIfDisposed(),opHandler.notEqual(this,e)},e.prototype.notEqualStrict=function(e){return this.throwIfDisposed(),opHandler.notEqualStrict(this,e)},e.prototype.less=function(e){return this.throwIfDisposed(),opHandler.less(this,e)},e.prototype.lessStrict=function(e){return this.throwIfDisposed(),opHandler.lessStrict(this,e)},e.prototype.equal=function(e){return this.throwIfDisposed(),opHandler.equal(this,e)},e.prototype.equalStrict=function(e){return this.throwIfDisposed(),opHandler.equalStrict(this,e)},e.prototype.lessEqual=function(e){return this.throwIfDisposed(),opHandler.lessEqual(this,e)},e.prototype.lessEqualStrict=function(e){return this.throwIfDisposed(),opHandler.lessEqualStrict(this,e)},e.prototype.greater=function(e){return this.throwIfDisposed(),opHandler.greater(this,e)},e.prototype.greaterStrict=function(e){return this.throwIfDisposed(),opHandler.greaterStrict(this,e)},e.prototype.greaterEqual=function(e){return this.throwIfDisposed(),opHandler.greaterEqual(this,e)},e.prototype.greaterEqualStrict=function(e){return this.throwIfDisposed(),opHandler.greaterEqualStrict(this,e)},e.prototype.logicalAnd=function(e){return this.throwIfDisposed(),opHandler.logicalAnd(this,e)},e.prototype.logicalOr=function(e){return this.throwIfDisposed(),opHandler.logicalOr(this,e)},e.prototype.logicalNot=function(){return this.throwIfDisposed(),opHandler.logicalNot(this)},e.prototype.logicalXor=function(e){return this.throwIfDisposed(),opHandler.logicalXor(this,e)},e.prototype.where=function(e,t){return this.throwIfDisposed(),opHandler.where(e,this,t)},e.prototype.neg=function(){return this.throwIfDisposed(),opHandler.neg(this)},e.prototype.ceil=function(){return this.throwIfDisposed(),opHandler.ceil(this)},e.prototype.floor=function(){return this.throwIfDisposed(),opHandler.floor(this)},e.prototype.sign=function(){return this.throwIfDisposed(),opHandler.sign(this)},e.prototype.exp=function(){return this.throwIfDisposed(),opHandler.exp(this)},e.prototype.expm1=function(){return this.throwIfDisposed(),opHandler.expm1(this)},e.prototype.log=function(){return this.throwIfDisposed(),opHandler.log(this)},e.prototype.log1p=function(){return this.throwIfDisposed(),opHandler.log1p(this)},e.prototype.sqrt=function(){return this.throwIfDisposed(),opHandler.sqrt(this)},e.prototype.rsqrt=function(){return this.throwIfDisposed(),opHandler.rsqrt(this)},e.prototype.square=function(){return this.throwIfDisposed(),opHandler.square(this)},e.prototype.reciprocal=function(){return this.throwIfDisposed(),opHandler.reciprocal(this)},e.prototype.abs=function(){return this.throwIfDisposed(),opHandler.abs(this)},e.prototype.clipByValue=function(e,t){return this.throwIfDisposed(),opHandler.clipByValue(this,e,t)},e.prototype.relu=function(){return this.throwIfDisposed(),opHandler.relu(this)},e.prototype.elu=function(){return this.throwIfDisposed(),opHandler.elu(this)},e.prototype.selu=function(){return this.throwIfDisposed(),opHandler.selu(this)},e.prototype.leakyRelu=function(e){return void 0===e&&(e=.2),this.throwIfDisposed(),opHandler.leakyRelu(this,e)},e.prototype.prelu=function(e){return this.throwIfDisposed(),opHandler.prelu(this,e)},e.prototype.sigmoid=function(){return this.throwIfDisposed(),opHandler.sigmoid(this)},e.prototype.logSigmoid=function(){return this.throwIfDisposed(),opHandler.logSigmoid(this)},e.prototype.softplus=function(){return this.throwIfDisposed(),opHandler.softplus(this)},e.prototype.zerosLike=function(){return this.throwIfDisposed(),opHandler.zerosLike(this)},e.prototype.onesLike=function(){return this.throwIfDisposed(),opHandler.onesLike(this)},e.prototype.sin=function(){return this.throwIfDisposed(),opHandler.sin(this)},e.prototype.cos=function(){return this.throwIfDisposed(),opHandler.cos(this)},e.prototype.tan=function(){return this.throwIfDisposed(),opHandler.tan(this)},e.prototype.asin=function(){return this.throwIfDisposed(),opHandler.asin(this)},e.prototype.acos=function(){return this.throwIfDisposed(),opHandler.acos(this)},e.prototype.atan=function(){return this.throwIfDisposed(),opHandler.atan(this)},e.prototype.sinh=function(){return this.throwIfDisposed(),opHandler.sinh(this)},e.prototype.cosh=function(){return this.throwIfDisposed(),opHandler.cosh(this)},e.prototype.tanh=function(){return this.throwIfDisposed(),opHandler.tanh(this)},e.prototype.asinh=function(){return this.throwIfDisposed(),opHandler.asinh(this)},e.prototype.acosh=function(){return this.throwIfDisposed(),opHandler.acosh(this)},e.prototype.atanh=function(){return this.throwIfDisposed(),opHandler.atanh(this)},e.prototype.erf=function(){return this.throwIfDisposed(),opHandler.erf(this)},e.prototype.round=function(){return this.throwIfDisposed(),opHandler.round(this)},e.prototype.step=function(e){return void 0===e&&(e=0),this.throwIfDisposed(),opHandler.step(this,e)},e.prototype.softmax=function(e){return void 0===e&&(e=-1),this.throwIfDisposed(),opHandler.softmax(this,e)},e.prototype.logSoftmax=function(e){return void 0===e&&(e=-1),this.throwIfDisposed(),opHandler.logSoftmax(this,e)},e.prototype.resizeBilinear=function(e,t){return void 0===t&&(t=!1),this.throwIfDisposed(),opHandler.image.resizeBilinear(this,e,t)},e.prototype.resizeNearestNeighbor=function(e,t){return void 0===t&&(t=!1),this.throwIfDisposed(),opHandler.image.resizeNearestNeighbor(this,e,t)},e.prototype.conv1d=function(e,t,r,n,o,a){return void 0===n&&(n="NWC"),void 0===o&&(o=1),this.throwIfDisposed(),opHandler.conv1d(this,e,t,r,n,o,a)},e.prototype.conv2d=function(e,t,r,n,o,a){return void 0===n&&(n="NHWC"),void 0===o&&(o=[1,1]),this.throwIfDisposed(),opHandler.conv2d(this,e,t,r,n,o,a)},e.prototype.conv2dTranspose=function(e,t,r,n,o){return this.throwIfDisposed(),opHandler.conv2dTranspose(this,e,t,r,n,o)},e.prototype.depthwiseConv2D=function(e,t,r,n,o,a){return void 0===n&&(n="NHWC"),void 0===o&&(o=[1,1]),this.throwIfDisposed(),opHandler.depthwiseConv2d(this,e,t,r,n,o,a)},e.prototype.separableConv2d=function(e,t,r,n,o,a){return void 0===o&&(o=[1,1]),void 0===a&&(a="NHWC"),this.throwIfDisposed(),opHandler.separableConv2d(this,e,t,r,n,o,a)},e.prototype.avgPool=function(e,t,r,n){return this.throwIfDisposed(),opHandler.avgPool(this,e,t,r,n)},e.prototype.maxPool=function(e,t,r,n){return this.throwIfDisposed(),opHandler.maxPool(this,e,t,r,n)},e.prototype.localResponseNormalization=function(e,t,r,n){return void 0===e&&(e=5),void 0===t&&(t=1),void 0===r&&(r=1),void 0===n&&(n=.5),opHandler.localResponseNormalization(this,e,t,r,n)},e.prototype.pool=function(e,t,r,n,o){return this.throwIfDisposed(),opHandler.pool(this,e,t,r,n,o)},e.prototype.variable=function(e,t,r){return void 0===e&&(e=!0),this.throwIfDisposed(),Variable.variable(this,e,t,r)},e.prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),opHandler.unsortedSegmentSum(this,e,t)},e.prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),opHandler.batchToSpaceND(this,e,t)},e.prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),opHandler.spaceToBatchND(this,e,t)},e.prototype.topk=function(e,t){return void 0===e&&(e=1),void 0===t&&(t=!0),this.throwIfDisposed(),opHandler.topk(this,e,t)},e.prototype.stridedSlice=function(e,t,r,n,o){return void 0===n&&(n=0),void 0===o&&(o=0),this.throwIfDisposed(),opHandler.stridedSlice(this,e,t,r,n,o)},e.prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),opHandler.depthToSpace(this,e,t)},e.prototype.fft=function(){return this.throwIfDisposed(),opHandler.spectral.fft(this)},e.prototype.ifft=function(){return this.throwIfDisposed(),opHandler.spectral.ifft(this)},e}();Object.defineProperty(Tensor,Symbol.hasInstance,{value:function(e){return!!e&&null!=e.shape&&null!=e.dtype}});var Variable=function(e){function t(t,r,n){void 0===r&&(r=!0);var o=e.call(this,t.shape,t.dtype,null,t.dataId)||this;o.trainable=r,o.name=n,null==o.name&&(o.name=trackerFn().nextVariableId().toString());try{trackerFn().registerVariable(o)}catch(e){throw trackerFn().disposeTensor(o),e}return o}return __extends(t,e),t.variable=function(e,r,n,o){return void 0===r&&(r=!0),null!=o&&o!==e.dtype&&(e=e.asType(o)),new t(e,r,n)},t.prototype.assign=function(e){if(e.dtype!==this.dtype)throw new Error("dtype of the new value ("+e.dtype+") and previous value ("+this.dtype+") must match");if(!arraysEqual(e.shape,this.shape))throw new Error("shape of the new value ("+e.shape+") and previous value ("+this.shape+") must match");trackerFn().disposeTensor(this),this.dataId=e.dataId,trackerFn().registerTensor(this)},t}(Tensor);Object.defineProperty(Variable,Symbol.hasInstance,{value:function(e){return e instanceof Tensor&&null!=e.assign&&e.assign instanceof Function}});var variable=Variable.variable;function getFilteredNodesXToY(e,t,r){for(var n={},o={},a=0;a<t.length;a++)n[t[a].id]=!0;for(a=0;a<e.length;a++){var i=(f=e[a]).inputs;for(var s in i){for(var u=i[s],l=!1,c=0;c<t.length;c++)if(n[u.id]){f.outputs.forEach(function(e){return n[e.id]=!0}),l=!0,o[f.id]=!0;break}if(l)break}}var p={};p[r.id]=!0;var d={};for(a=e.length-1;a>=0;a--)for(i=(f=e[a]).inputs,c=0;c<f.outputs.length;c++)if(p[f.outputs[c].id]){for(var s in i)p[i[s].id]=!0,d[f.id]=!0;break}var h=[];for(a=0;a<e.length;a++){var f;if(o[(f=e[a]).id]&&d[f.id]){var m={};for(var s in f.inputs){var g=f.inputs[s];n[g.id]&&(m[s]=g)}var v=Object.assign({},f);v.inputs=m,v.outputs=f.outputs,h.push(v)}}return h}function backpropagateGradients(e,t){for(var r=function(r){var n=t[r],o=[];if(n.outputs.forEach(function(t){var r=e[t.id];if(null!=r)o.push(r);else{var n=Tensor.make(t.shape,{values:makeZerosTypedArray(t.size,t.dtype)},t.dtype);o.push(n)}}),null==n.gradient)throw new Error("Cannot compute gradient: gradient function not found for "+n.name+".");var a=n.gradient(1===n.outputs.length?o[0]:o);for(var i in n.inputs){if(!(i in a))throw new Error("Cannot backprop through input "+i+". Available gradients found: "+Object.keys(a)+".");var s=a[i](),u=n.inputs[i];if(!arraysEqual(s.shape,u.shape))throw new Error("Error in gradient for op "+n.name+". The gradient of input '"+i+"' has shape '"+s.shape+"', which does not match the shape of the input '"+u.shape+"'");if(null==e[u.id])e[u.id]=s;else{var l=e[u.id];e[u.id]=l.add(s),l.dispose()}}},n=t.length-1;n>=0;n--)r(n)}function assertTypesMatch(e,t){assert(e.dtype===t.dtype,"The dtypes of the first("+e.dtype+") and second("+t.dtype+") input must match")}function isTensorInList(e,t){for(var r=0;r<t.length;r++)if(t[r].id===e.id)return!0;return!1}function getTensorsInContainer(e){var t=[];return walkTensorContainer(e,t,new Set),t}function walkTensorContainer(e,t,r){if(null!=e)if(e instanceof Tensor)t.push(e);else if(isIterable(e)){var n=e;for(var o in n){var a=n[o];r.has(a)||(r.add(a),walkTensorContainer(a,t,r))}}}function isIterable(e){return Array.isArray(e)||"object"==typeof e}var Type,Engine=function(){function e(e,t,r){this.backend=e,this.safeMode=t,this.debugMode=r,this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numDataBuffers=0,this.profiling=!1,this.gradientScopeCount=0,this.customGradientDepth=0,this.keepTensors=new Set,this.tensorInfo=new WeakMap,this.activeScope={track:[],name:"default scope"},this.scopeStack=[this.activeScope],this.profiler=new Profiler(e),this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null}}return e.prototype.moveData=function(e){this.write(e,this.readSync(e))},e.prototype.tidy=function(e,t,r){var n=this;void 0===r&&(r=!1);var o,a=null;if(null==t){if("function"!=typeof e)throw new Error("Please provide a function to tidy()");t=e}else{if("string"!=typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof t)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");a=e}return this.scopedRun(function(){return n.startScope(a,r)},function(){return n.endScope(o,r)},function(){return(o=t())instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),o})},e.prototype.scopedRun=function(e,t,r){e();try{var n=r();return t(),n}catch(e){throw t(),e}},e.prototype.nextTensorId=function(){return e.nextTensorId++},e.prototype.nextVariableId=function(){return e.nextVariableId++},e.prototype.runKernel=function(e,t,r){var n,o=this,a=[],i=function(e){return a.push(e),e},s=this.activeScope.name,u=this.numBytes,l=this.numTensors;if(this.scopedRun(function(){return o.customGradientDepth++},function(){return o.customGradientDepth--},function(){n=o.debugMode()?o.profiler.profileKernel(s,function(){return e(o.backend,i)}):e(o.backend,i)}),this.shouldRecord()){var c={id:this.nextTapeNodeId++,name:s,inputs:t,outputs:Array.isArray(n)?n:[n]};null!=r&&(c.gradient=function(e){return r(e,a)}),this.activeTape.push(c)}return this.profiling&&this.activeProfile.kernels.push({name:s,bytesAdded:this.numBytes-u,totalBytesSnapshot:this.numBytes,tensorsAdded:this.numTensors-l,totalTensorsSnapshot:this.numTensors,inputShapes:Object.keys(t).map(function(e){return t[e].shape}),outputShape:Array.isArray(n)?n.map(function(e){return e.shape}):n.shape}),n},e.prototype.registerTensor=function(e){var t=this.tensorInfo.has(e.dataId)?this.tensorInfo.get(e.dataId).refCount:0;this.numTensors++,0===t&&(this.numDataBuffers++,"complex64"!==e.dtype&&(this.numBytes+=sizeFromShape(e.shape)*bytesPerElement(e.dtype)),this.tensorInfo.set(e.dataId,{backend:this.backend,dtype:e.dtype,shape:e.shape,refCount:0}),this.backend.register(e.dataId,e.shape,e.dtype)),this.tensorInfo.get(e.dataId).refCount++,e instanceof Variable||this.track(e)},e.prototype.registerVariable=function(e){if(null!=this.registeredVariables[e.name])throw new Error("Variable with name "+e.name+" was already registered");this.registeredVariables[e.name]=e},e.prototype.disposeTensor=function(e){this.tensorInfo.has(e.dataId)&&(this.keepTensors.has(e.id)&&this.keepTensors.delete(e.id),this.numTensors--,this.tensorInfo.get(e.dataId).refCount<=1?(this.tensorInfo.get(e.dataId).backend.disposeData(e.dataId),this.numDataBuffers--,"complex64"!==e.dtype&&(this.numBytes-=sizeFromShape(e.shape)*bytesPerElement(e.dtype)),this.tensorInfo.delete(e.dataId)):this.tensorInfo.get(e.dataId).refCount--)},e.prototype.disposeVariables=function(){for(var e in this.registeredVariables){var t=this.registeredVariables[e];this.disposeTensor(t),delete this.registeredVariables[e]}},e.prototype.memory=function(){var e=this.backend.memory();return e.numTensors=this.numTensors,e.numDataBuffers=this.numDataBuffers,e.numBytes=this.numBytes,e},e.prototype.profile=function(e){return __awaiter(this,void 0,void 0,function(){var t,r;return __generator(this,function(n){return this.profiling=!0,t=this.numBytes,r=this.numTensors,this.activeProfile.kernels=[],this.activeProfile.result=e(),this.profiling=!1,this.activeProfile.peakBytes=Math.max.apply(Math,this.activeProfile.kernels.map(function(e){return e.totalBytesSnapshot})),this.activeProfile.newBytes=this.numBytes-t,this.activeProfile.newTensors=this.numTensors-r,[2,this.activeProfile]})})},e.prototype.shouldRecord=function(){return null!=this.activeTape&&0===this.customGradientDepth},e.prototype.addTapeNode=function(e,t,r){var n={};e.forEach(function(e,t){n[t]=e});var o={id:this.nextTapeNodeId++,name:this.activeScope.name,inputs:n,outputs:[t],gradient:function(e){var t={};return r(e).forEach(function(e,r){t[r]=function(){return e}}),t}};this.activeTape.push(o)},e.prototype.keep=function(e){if(1===this.scopeStack.length&&this.safeMode)throw new Error("Safe mode is ON. Enclose all tensor operations inside tf.tidy(): tf.tidy(() => {...}) to avoid memory leaks.");return this.keepTensors.add(e.id),e},e.prototype.startScope=function(e,t){void 0===t&&(t=!1),t&&0===this.gradientScopeCount&&(this.activeTape=[]),t&&this.gradientScopeCount++;var r={track:[],name:"unnamed scope"};e&&(r.name=e),this.scopeStack.push(r),this.activeScope=r},e.prototype.endScope=function(e,t){var r=this;void 0===t&&(t=!1),t&&(this.gradientScopeCount--,0===this.gradientScopeCount&&(this.activeTape=null));var n=new Set(this.keepTensors),o=getTensorsInContainer(e);o.forEach(function(e){return n.add(e.id)});for(var a=0;a<this.activeScope.track.length;a++){var i=this.activeScope.track[a];n.has(i.id)||(null!=this.activeTape?o.push(i):i.dispose())}var s=this.scopeStack.pop();this.activeScope=0===this.scopeStack.length?{track:[],name:"default scope"}:this.scopeStack[this.scopeStack.length-1],o.forEach(function(e){!r.keepTensors.has(e.id)&&isTensorInList(e,s.track)&&r.track(e)})},e.prototype.gradients=function(e,t,r,n){var o=this;return void 0===n&&(n=!1),assert(t.length>0,"gradients() received an empty list of xs."),this.tidy("gradients",function(){var a=e();assert(a instanceof Tensor,"The result y returned by f() must be a tensor.");var i=getFilteredNodesXToY(o.activeTape,t,a);if(!n&&0===i.length&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");var s={};return s[a.id]=null==r?ones(a.shape):r,backpropagateGradients(s,i),{value:a,grads:t.map(function(e){return s[e.id]})}},!0)},e.prototype.customGrad=function(e){var t=this;return assert(isFunction(e),"The f passed in customGrad(f) must be a function."),function(){for(var r,n,o=[],a=0;a<arguments.length;a++)o[a]=arguments[a];if(assert(o.every(function(e){return e instanceof Tensor}),"The args passed in customGrad(f)(x1, x2,...) must all be tensors"),t.scopedRun(function(){return t.customGradientDepth++},function(){return t.customGradientDepth--},function(){n=t.tidy(e.name,function(){var t=e.apply(void 0,o),n=t.value,a=t.gradFunc;return assert(n instanceof Tensor,"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),assert(isFunction(a),"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),r=a,n},!0)}),t.shouldRecord()){t.addTapeNode(o,n,function(e){var t=r(e),n=Array.isArray(t)?t:[t];return assert(n.length===o.length,"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),assert(n.every(function(e){return e instanceof Tensor}),"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."),n})}return n}},e.prototype.write=function(e,t){var r=this.tensorInfo.get(e);this.backend!==r.backend&&(r.backend.disposeData(e),r.backend=this.backend,this.backend.register(e,r.shape,r.dtype)),this.backend.write(e,t)},e.prototype.readSync=function(e){return this.tensorInfo.get(e).backend.readSync(e)},e.prototype.read=function(e){return this.tensorInfo.get(e).backend.read(e)},e.prototype.fromPixels=function(e,t){return this.backend.fromPixels(e,t)},e.prototype.time=function(e){return __awaiter(this,void 0,void 0,function(){var t,r;return __generator(this,function(n){switch(n.label){case 0:return t=now(),[4,this.backend.time(e)];case 1:return(r=n.sent()).wallMs=now()-t,[2,r]}})})},e.prototype.track=function(e){if(1===this.scopeStack.length&&this.safeMode)throw new Error("Safe mode is ON. Enclose all tensor operations inside tf.tidy(): tf.tidy(() => {op();...}); to avoid memory leaks.");return this.activeScope.track.push(e),e},e.nextTensorId=0,e.nextVariableId=0,e}();function ones(e){var t=makeOnesTypedArray(sizeFromShape(e),"float32");return Tensor.make(e,{values:t})}!function(e){e[e.NUMBER=0]="NUMBER",e[e.BOOLEAN=1]="BOOLEAN",e[e.STRING=2]="STRING"}(Type||(Type={}));var MAX_TEXTURE_SIZE,URL_PROPERTIES=[{name:"DEBUG",type:Type.BOOLEAN},{name:"IS_BROWSER",type:Type.BOOLEAN},{name:"WEBGL_LAZILY_UNPACK",type:Type.BOOLEAN},{name:"WEBGL_CPU_FORWARD",type:Type.BOOLEAN},{name:"WEBGL_PACK_BATCHNORMALIZATION",type:Type.BOOLEAN},{name:"WEBGL_CONV_IM2COL",type:Type.BOOLEAN},{name:"WEBGL_MAX_TEXTURE_SIZE",type:Type.NUMBER},{name:"WEBGL_PAGING_ENABLED",type:Type.BOOLEAN},{name:"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",type:Type.NUMBER},{name:"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",type:Type.BOOLEAN},{name:"WEBGL_VERSION",type:Type.NUMBER},{name:"WEBGL_RENDER_FLOAT32_ENABLED",type:Type.BOOLEAN},{name:"WEBGL_DOWNLOAD_FLOAT_ENABLED",type:Type.BOOLEAN},{name:"WEBGL_FENCE_API_ENABLED",type:Type.BOOLEAN},{name:"WEBGL_SIZE_UPLOAD_UNIFORM",type:Type.NUMBER},{name:"BACKEND",type:Type.STRING},{name:"EPSILON",type:Type.NUMBER},{name:"PROD",type:Type.BOOLEAN},{name:"TENSORLIKE_CHECK_SHAPE_CONSISTENCY",type:Type.BOOLEAN}];function isWebGLVersionEnabled(e){try{if(null!=getWebGLContext(e))return!0}catch(e){return!1}return!1}function getWebGLMaxTextureSize(e){if(null==MAX_TEXTURE_SIZE){var t=getWebGLContext(e);MAX_TEXTURE_SIZE=t.getParameter(t.MAX_TEXTURE_SIZE)}return MAX_TEXTURE_SIZE}function getWebGLDisjointQueryTimerVersion(e){if(0===e)return 0;var t=getWebGLContext(e);return hasExtension(t,"EXT_disjoint_timer_query_webgl2")&&2===e?2:hasExtension(t,"EXT_disjoint_timer_query")?1:0}function isRenderToFloatTextureEnabled(e){if(0===e)return!1;var t=getWebGLContext(e);if(1===e){if(!hasExtension(t,"OES_texture_float"))return!1}else if(!hasExtension(t,"EXT_color_buffer_float"))return!1;return createFloatTextureAndBindToFramebuffer(t,e)}function isDownloadFloatTextureEnabled(e){if(0===e)return!1;var t=getWebGLContext(e);if(1===e){if(!hasExtension(t,"OES_texture_float"))return!1;if(!hasExtension(t,"WEBGL_color_buffer_float"))return!1}else if(!hasExtension(t,"EXT_color_buffer_float"))return!1;return createFloatTextureAndBindToFramebuffer(t,e)}function isWebGLFenceEnabled(e){return 2===e&&null!=getWebGLContext(e).fenceSync}function isChrome(){return"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)}var TENSORFLOWJS_FLAGS_PREFIX="tfjsflags";function getFeaturesFromURL(){var e={};if("undefined"==typeof window||void 0===window.location||void 0===window.location.search)return e;var t=getQueryParams(window.location.search);if(TENSORFLOWJS_FLAGS_PREFIX in t){var r={};t[TENSORFLOWJS_FLAGS_PREFIX].split(",").forEach(function(e){var t=e.split(":"),n=t[0],o=t[1];r[n]=o}),URL_PROPERTIES.forEach(function(t){t.name in r&&(console.log("Setting feature override from URL "+t.name+": "+r[t.name]),t.type===Type.NUMBER?e[t.name]=+r[t.name]:t.type===Type.BOOLEAN?e[t.name]="true"===r[t.name]:t.type===Type.STRING?e[t.name]=r[t.name]:console.warn("Unknown URL param: "+t.name+"."))})}return e}function hasExtension(e,t){return null!=e.getExtension(t)}function createFloatTextureAndBindToFramebuffer(e,t){var r=e.createFramebuffer(),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n);var o=2===t?e.RGBA32F:e.RGBA;e.texImage2D(e.TEXTURE_2D,0,o,1,1,0,e.RGBA,e.FLOAT,null),e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);var a=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(r),a}function getQueryParams(e){var t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,function(e){for(var r=[],n=1;n<arguments.length;n++)r[n-1]=arguments[n];return decodeParam(t,r[0],r[1]),r.join("=")}),t}function decodeParam(e,t,r){e[decodeURIComponent(t)]=decodeURIComponent(r||"")}var EPSILON_FLOAT16=.001,TEST_EPSILON_FLOAT16=.1,EPSILON_FLOAT32=1e-7,TEST_EPSILON_FLOAT32=.001,Environment=function(){function e(e){this.features={},this.registry={},null!=e&&(this.features=e),this.get("DEBUG")&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}return e.setBackend=function(e,t){if(void 0===t&&(t=!1),!(e in ENV.registry))throw new Error("Backend name '"+e+"' not found in registry");ENV.engine.backend=ENV.findBackend(e),ENV.backendName=e},e.getBackend=function(){return ENV.initEngine(),ENV.backendName},e.disposeVariables=function(){ENV.engine.disposeVariables()},e.memory=function(){return ENV.engine.memory()},e.profile=function(e){return ENV.engine.profile(e)},e.tidy=function(e,t,r){return void 0===r&&(r=!1),ENV.engine.tidy(e,t,r)},e.dispose=function(e){getTensorsInContainer(e).forEach(function(e){return e.dispose()})},e.keep=function(e){return ENV.engine.keep(e)},e.time=function(e){return ENV.engine.time(e)},e.prototype.get=function(e){return e in this.features?this.features[e]:(this.features[e]=this.evaluateFeature(e),this.features[e])},e.prototype.getFeatures=function(){return this.features},e.prototype.set=function(e,t){this.features[e]=t},e.prototype.getBestBackendName=function(){var e=this;if(0===Object.keys(this.registry).length)throw new Error("No backend found in registry.");return Object.keys(this.registry).map(function(t){return{name:t,entry:e.registry[t]}}).sort(function(e,t){return t.entry.priority-e.entry.priority})[0].name},e.prototype.evaluateFeature=function(e){if("DEBUG"===e)return!1;if("IS_BROWSER"===e)return"undefined"!=typeof window;if("IS_NODE"===e)return"undefined"!=typeof process&&void 0!==process.versions.node;if("IS_CHROME"===e)return isChrome();if("WEBGL_CPU_FORWARD"===e)return!0;if("WEBGL_PACK_BATCHNORMALIZATION"===e)return!1;if("WEBGL_LAZILY_UNPACK"===e)return!1;if("WEBGL_CONV_IM2COL"===e)return!1;if("WEBGL_PAGING_ENABLED"===e)return this.get("IS_BROWSER")&&!this.get("PROD");if("WEBGL_MAX_TEXTURE_SIZE"===e)return getWebGLMaxTextureSize(this.get("WEBGL_VERSION"));if("IS_TEST"===e)return!1;if("BACKEND"===e)return this.getBestBackendName();if("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"===e){var t=this.get("WEBGL_VERSION");return 0===t?0:getWebGLDisjointQueryTimerVersion(t)}if("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE"===e)return this.get("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!isMobile();if("HAS_WEBGL"===e)return this.get("WEBGL_VERSION")>0;if("WEBGL_VERSION"===e)return isWebGLVersionEnabled(2)?2:isWebGLVersionEnabled(1)?1:0;if("WEBGL_RENDER_FLOAT32_ENABLED"===e)return isRenderToFloatTextureEnabled(this.get("WEBGL_VERSION"));if("WEBGL_DOWNLOAD_FLOAT_ENABLED"===e)return isDownloadFloatTextureEnabled(this.get("WEBGL_VERSION"));if("WEBGL_FENCE_API_ENABLED"===e)return isWebGLFenceEnabled(this.get("WEBGL_VERSION"));if("WEBGL_SIZE_UPLOAD_UNIFORM"===e)return this.get("WEBGL_RENDER_FLOAT32_ENABLED")?4:0;if("TEST_EPSILON"===e)return 32===this.backend.floatPrecision()?TEST_EPSILON_FLOAT32:TEST_EPSILON_FLOAT16;if("EPSILON"===e)return 32===this.backend.floatPrecision()?EPSILON_FLOAT32:EPSILON_FLOAT16;if("PROD"===e)return!1;if("TENSORLIKE_CHECK_SHAPE_CONSISTENCY"===e)return!this.get("PROD");throw new Error("Unknown feature "+e+".")},e.prototype.setFeatures=function(e){this.features=Object.assign({},e)},e.prototype.reset=function(){this.features=getFeaturesFromURL(),null!=this.globalEngine&&(this.globalEngine=null)},Object.defineProperty(e.prototype,"backend",{get:function(){return this.engine.backend},enumerable:!0,configurable:!0}),e.prototype.findBackend=function(e){return e in this.registry?this.registry[e].backend:null},e.prototype.registerBackend=function(e,t,r,n){var o=this;if(void 0===r&&(r=1),e in this.registry)return console.warn(e+" backend was already registered. Reusing existing backend"),null!=n&&n(function(){return o.engine}),!1;try{var a=t();return a.setDataMover({moveData:function(e){return o.engine.moveData(e)}}),this.registry[e]={backend:a,priority:r},!0}catch(t){return console.warn("Registration of backend "+e+" failed"),console.warn(t.stack||t.message),!1}},e.prototype.removeBackend=function(e){if(!(e in this.registry))throw new Error(e+" backend not found in registry");this.registry[e].backend.dispose(),delete this.registry[e]},Object.defineProperty(e.prototype,"engine",{get:function(){return this.initEngine(),this.globalEngine},enumerable:!0,configurable:!0}),e.prototype.initEngine=function(){var e=this;if(null==this.globalEngine){this.backendName=this.get("BACKEND");var t=this.findBackend(this.backendName);this.globalEngine=new Engine(t,!1,function(){return e.get("DEBUG")})}},e}();function getGlobalNamespace(){var e;if("undefined"!=typeof window)e=window;else{if("undefined"==typeof process)throw new Error("Could not find a global object");e=process}return e}function getOrMakeEnvironment(){var e=getGlobalNamespace();return null==e.ENV&&(e.ENV=new Environment(getFeaturesFromURL()),setTensorTracker(function(){return e.ENV.engine})),e.ENV}var ENV=getOrMakeEnvironment(),environment=Object.freeze({Environment:Environment,ENV:ENV});function grad(e){return assert(isFunction(e),"The f passed in grad(f) must be a function"),function(t,r){return assert(t instanceof Tensor,"The x passed in grad(f)(x) must be a tensor"),assert(null==r||r instanceof Tensor,"The dy passed in grad(f)(x, dy) must be a tensor"),ENV.engine.tidy(function(){var n=ENV.engine.gradients(function(){return e(t)},[t],r),o=n.value,a=n.grads;return null!=r&&assertShapesMatch(o.shape,r.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),checkGrads(a),a[0]})}}function grads(e){return assert(isFunction(e),"The f passed in grads(f) must be a function"),function(t,r){return assert(Array.isArray(t)&&t.every(function(e){return e instanceof Tensor}),"The args passed in grads(f)(args) must be an array of tensors"),assert(null==r||r instanceof Tensor,"The dy passed in grads(f)(args, dy) must be a tensor"),ENV.engine.tidy(function(){var n=ENV.engine.gradients(function(){return e.apply(void 0,t)},t,r),o=n.value,a=n.grads;return null!=r&&assertShapesMatch(o.shape,r.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),checkGrads(a),a})}}function valueAndGrad(e){return assert(isFunction(e),"The f passed in valueAndGrad(f) must be a function"),function(t,r){assert(t instanceof Tensor,"The x passed in valueAndGrad(f)(x) must be a tensor"),assert(null==r||r instanceof Tensor,"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");var n=ENV.engine.gradients(function(){return e(t)},[t],r),o=n.grads,a=n.value;return checkGrads(o),{grad:o[0],value:a}}}function valueAndGrads(e){return assert(isFunction(e),"The f passed in valueAndGrads(f) must be a function"),function(t,r){assert(Array.isArray(t)&&t.every(function(e){return e instanceof Tensor}),"The args passed in valueAndGrads(f)(args) must be array of tensors"),assert(null==r||r instanceof Tensor,"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");var n=ENV.engine.gradients(function(){return e.apply(void 0,t)},t,r);return null!=r&&assertShapesMatch(n.value.shape,r.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),checkGrads(n.grads),n}}function variableGrads(e,t){if(assert(isFunction(e),"The f passed in variableGrads(f) must be a function"),assert(null==t||Array.isArray(t)&&t.every(function(e){return e instanceof Variable}),"The varList passed in variableGrads(f, varList) must be an array of variables"),null==t)for(var r in t=[],ENV.engine.registeredVariables)t.push(ENV.engine.registeredVariables[r]);var n=t.length;assert((t=t.filter(function(e){return e.trainable})).length>0,"variableGrads() expects at least one of the input variables to be trainable, but none of the "+n+" variables is trainable.");var o=ENV.engine.gradients(e,t,null,!0),a=o.value,i=o.grads;assert(i.some(function(e){return null!=e}),"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),assert(0===a.rank,"The f passed in variableGrads(f) must return a scalar, but it returned a rank-"+a.rank+" tensor");var s={};return t.forEach(function(e,t){null!=i[t]&&(s[e.name]=i[t])}),{value:a,grads:s}}function customGrad(e){return ENV.engine.customGrad(e)}function checkGrads(e){if(e.filter(function(e){return null==e}).length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.")}var tidy=Environment.tidy,keep=Environment.keep,dispose=Environment.dispose,time=Environment.time,profile=Environment.profile;function warn(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];ENV.get("IS_TEST")||console.warn.apply(console,e)}function getReshaped(e,t,r,n){void 0===n&&(n=!0);var o=[];if(n)(o=o.concat(t.slice(0))).push(e[0]/r),o=o.concat(e.slice(1));else{o=o.concat(e[0]);for(var a=t.length,i=0;i<a;++i)o=o.concat([e[i+1]/t[i],t[i]]);o=o.concat(e.slice(a+1))}return o}function getPermuted(e,t,r){void 0===r&&(r=!0);var n=[];if(r){n.push(t);for(var o=t+1;o<e;++o)o<=2*t?(n.push(o),n.push(o-(t+1))):n.push(o)}else{var a=[],i=[];for(o=1;o<e;++o)o>=2*t+1||o%2==1?i.push(o):a.push(o);n.push.apply(n,a),n.push(0),n.push.apply(n,i)}return n}function getReshapedPermuted(e,t,r,n){void 0===n&&(n=!0);var o=[];n?o.push(e[0]/r):o.push(e[0]*r);for(var a=1;a<e.length;++a)a<=t.length?n?o.push(t[a-1]*e[a]):o.push(e[a]/t[a-1]):o.push(e[a]);return o}function getSliceBeginCoords(e,t){for(var r=[0],n=0;n<t;++n)r.push(e[n][0]);return r}function getSliceSize(e,t,r){for(var n=e.slice(0,1),o=0;o<r;++o)n.push(e[o+1]-t[o][0]-t[o][1]);return n}function axesAreInnerMostDims(e,t){for(var r=0;r<e.length;++r)if(e[e.length-r-1]!==t-1-r)return!1;return!0}function combineLocations(e,t,r){for(var n=e.length+t.length,o=[],a=0,i=0,s=0;s<n;s++)-1===r.indexOf(s)?o.push(e[a++]):o.push(t[i++]);return o}function computeOutAndReduceShapes(e,t){for(var r=[],n=e.length,o=0;o<n;o++)-1===t.indexOf(o)&&r.push(e[o]);return[r,t.map(function(t){return e[t]})]}function expandShapeToKeepDim(e,t){return combineLocations(e,t.map(function(e){return 1}),t)}function parseAxisParam(e,t){var r=t.length;return assert((e=null==e?t.map(function(e,t){return t}):[].concat(e)).every(function(e){return e>=-r&&e<r}),"All values in axis param must be in range [-"+r+", "+r+") but got axis "+e),assert(e.every(function(e){return isInt(e)}),"All values in axis param must be integers but got axis "+e),e.map(function(e){return e<0?r+e:e})}function assertAxesAreInnerMostDims(e,t,r){assert(axesAreInnerMostDims(t,r),e+" supports only inner-most axes for now. Got axes "+t+" and rank-"+r+" input.")}function getAxesPermutation(e,t){if(axesAreInnerMostDims(e,t))return null;for(var r=[],n=0;n<t;++n)-1===e.indexOf(n)&&r.push(n);return e.forEach(function(e){return r.push(e)}),r}function getUndoAxesPermutation(e){return e.map(function(e,t){return[t,e]}).sort(function(e,t){return e[1]-t[1]}).map(function(e){return e[0]})}function getInnerMostAxes(e,t){for(var r=[],n=t-e;n<t;++n)r.push(n);return r}function assertParamsConsistent(e,t){var r=e[0].length;e.forEach(function(e,t){assert(e.length===r,"Error in concat"+r+"D: rank of tensors["+t+"] must be the same as the rank of the rest ("+r+")")}),assert(t>=0&&t<r,"Error in concat"+r+"D: axis must be between 0 and "+(r-1)+".");var n=e[0];e.forEach(function(e,o){for(var a=0;a<r;a++)assert(a===t||e[a]===n[a],"Error in concat"+r+"D: Shape of tensors["+o+"] ("+e+") does not match the shape of the rest ("+n+") along the non-concatenated axis "+o+".")})}function computeOutShape(e,t){for(var r=e[0].slice(),n=1;n<e.length;n++)r[t]+=e[n][t];return r}function prepareAndValidate(e,t){if(e.rank<1)throw new Error("tf.gatherND() expects the input to be rank 1 or higher, but the rank was "+e.rank+".");if(t.rank<1)throw new Error("tf.gatherND() expects the indices to be rank 1 or higher, but the rank was "+t.rank+".");if("int32"!==t.dtype)throw new Error("tf.gatherND() expects the indices to be int32 type, but the dtype was "+t.dtype+".");if(t.shape[t.rank-1]>e.rank)throw new Error("index innermost dimension length must be <= tensor rank; saw: "+t.shape[t.rank-1]+" vs. "+e.rank);if(0===e.size)throw new Error("Requested more than 0 entries, but input is empty. Input shape: "+e.shape+".");for(var r=t.shape,n=r[r.length-1],o=1,a=0;a<r.length-1;++a)o*=r[a];var i=e.shape,s=r.slice();s.pop();var u=1;for(a=n;a<e.rank;++a)u*=i[a],s.push(i[a]);var l=computeStrides(e.shape).map(function(e){return e/u}).concat([1]).slice(0,n);return[s,o,u,l]}var PARALLELIZE_THRESHOLD=30;function computeOptimalWindowSize(e){return e<=PARALLELIZE_THRESHOLD?e:nearestDivisor(e,Math.floor(Math.sqrt(e)))}function validateUpdateShape(e,t,r){var n=t.rank>1?t.shape[t.rank-1]:1,o=t.rank>1?t.rank-1:1,a="Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: "+r.shape+", indices.shape: "+t.shape+", shape: "+e+", sliceDim: "+n+", and batchDim: "+o+".";if(r.rank<o)throw new Error(a+" update.rank < "+o+". ");if(e.length<n+(r.rank-o))throw new Error(a+" Output shape length < "+(n+(r.rank-o)));if(r.rank!==o+e.length-n)throw new Error(a+" update.rank != "+(o+e.length-n));for(var i=0;i<o;++i)if(r.shape[i]!==t.shape[i])throw new Error(a+" updates.shape["+i+"] ("+r.shape[i]+") != indices.shape["+i+"] ("+t.shape[i]+").");for(i=0;i<r.rank-o;++i)if(r.shape[i+o]!==e[i+n])throw new Error(a+" updates.shape["+(i+o)+"] ("+r.shape[i+o]+") != shape["+(i+o)+"] ("+e[i+o]+")")}function validateInput(e,t,r){if(t.rank<1)throw new Error("tf.scatterND() expects the indices to be rank 1 or higher, but the rank was "+t.rank+".");if(e.rank<1)throw new Error("tf.scatterND() expects the updates to be rank 1 or higher, but the rank was "+e.rank+".");if("int32"!==t.dtype)throw new Error("The dtype of 'indices' should be int32, but got dtype: "+t.dtype);if(r.length<1)throw new Error("Output rank must be greater or equal to 1, but got shape: "+r);if(0===r.length){if(0===t.size)throw new Error("Indices specified for empty output. indices shape: "+t.shape);if(0===e.size)throw new Error("Updates specified for empty output. updates shape: "+e.shape)}validateUpdateShape(r,t,e)}function calculateShapes(e,t,r){for(var n=t.rank>1?t.shape[t.rank-1]:1,o=r.length,a=1,i=n;i<o;++i)a*=r[i];var s=n<1?1:n,u=t.size/s,l=computeStrides(r).concat([1]);return{sliceRank:n,numUpdates:u,sliceSize:a,strides:l.slice(l.length-n,l.length),outputSize:sizeFromShape(r)}}function segOpComputeOptimalWindowSize(e,t){var r,n=!1;for(e<=PARALLELIZE_THRESHOLD?(r=e,n=!0):r=nearestDivisor(e,Math.floor(Math.sqrt(e)));!n;){if(r>t||r===e){n=!0;break}r=nearestDivisor(e,r+1)}return r}function computeOutShape$1(e,t,r){for(var n=[],o=e.length,a=0;a<o;a++)a!==t?n.push(e[a]):n.push(r);return n}function assertParamsValid(e,t,r){assert(e.rank===t.length,"Error in slice"+e.rank+"D: Length of begin "+t+" must match the rank of the array ("+e.rank+")."),assert(e.rank===r.length,"Error in slice"+e.rank+"D: Length of size "+r+" must match the rank of the array ("+e.rank+").");for(var n=0;n<e.rank;++n)assert(t[n]+r[n]<=e.shape[n],"Error in slice"+e.rank+"D: begin["+n+"] + size["+n+"] ("+(t[n]+r[n])+") would overflow input.shape["+n+"] ("+e.shape[n]+")")}function getStridedSlicedInfo(e,t,r,n,o,a,i,s,u){if(void 0===o&&(o=0),void 0===a&&(a=0),void 0===i&&(i=0),void 0===s&&(s=0),void 0===u&&(u=0),0!==i)throw new Error("ellipsis mask is not yet supported");if(0!==s)throw new Error("new axis mask is not yet supported");for(var l=[],c=[],p=[],d=0;d<e.length;d++)l[d]=startForAxis(o,t,n,e,d),c[d]=stopForAxis(a,r,n,e,d),u&1<<d&&(c[d]=l[d]+1,p.push(d));var h=new Array(e.length).fill(0);return h=h.map(function(e,t){for(var r=0,o=l[t];!(n[t]>0?o>=c[t]:o<=c[t]);o+=n[t])r+=1;return r}),[l,h,p]}function startForAxis(e,t,r,n,o){var a=t[o];e&1<<o&&(a=r[o]>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);var i=n[o];return a<0&&(a+=i),a=clamp(0,a,i-1)}function stopForAxis(e,t,r,n,o){var a=t[o];e&1<<o&&(a=r[o]>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);var i=n[o];return a<0&&(a+=i),a=r[o]>0?clamp(0,a,i):clamp(-1,a,i-1)}function inferShape(e){var t=e;if(isTypedArray(e))return[e.length];if(!Array.isArray(e))return[];for(var r=[];t instanceof Array;)r.push(t.length),t=t[0];return e instanceof Array&&ENV.get("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&deepAssertShapeConsistency(e,r,[]),r}function deepAssertShapeConsistency(e,t,r){if(r=r||[],e instanceof Array){assert(t.length>0,function(){return"Element arr["+r.join("][")+"] should be a primitive, but is an array of "+e.length+" elements"}),assert(e.length===t[0],function(){return"Element arr["+r.join("][")+"] should have "+t[0]+" elements, but has "+e.length+" elements"});for(var n=t.slice(1),o=0;o<e.length;++o)deepAssertShapeConsistency(e[o],n,r.concat(o))}else assert(0===t.length,function(){return"Element arr["+r.join("][")+"] is a primitive, but should be an array of "+t[0]+" elements"})}function convertToTensor(e,t,r,n){if(void 0===n&&(n="float32"),n=n||"float32",e instanceof Tensor)return e;if(!isTypedArray(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e)throw new Error("Argument '"+t+"' passed to '"+r+"' must be a Tensor or TensorLike, but got "+e.constructor.name);var o=inferShape(e);return isTypedArray(e)||Array.isArray(e)||(e=[e]),Tensor.make(o,{values:toTypedArray(e,n,ENV.get("DEBUG"))},n)}function convertToTensorArray(e,t,r){if(!Array.isArray(e))throw new Error("Argument "+t+" passed to "+r+" must be a `Tensor[]` or `TensorLike[]`");return e.map(function(e,n){return convertToTensor(e,t+"["+n+"]",r)})}function op(e){var t=Object.keys(e);if(1!==t.length)throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with "+t.length+" keys.");var r=t[0],n=e[r];r.endsWith("_")&&(r=r.substring(0,r.length-1));var o=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];ENV.engine.startScope(r);try{var o=n.apply(void 0,e);return o instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),ENV.engine.endScope(o),o}catch(e){throw ENV.engine.endScope(null),e}};return Object.defineProperty(o,"name",{value:r,configurable:!0}),o}function softmax_(e,t){void 0===t&&(t=-1);var r=convertToTensor(e,"logits","softmax");if(-1===t&&(t=r.rank-1),t!==r.rank-1)throw Error("Softmax along a non-last dimension is not yet supported. Logits was rank "+r.rank+" and dim was "+t);return customGrad(function(e){var r=e.logSumExp([t],!0),n=e.toFloat().sub(r).exp();return{value:n,gradFunc:function(e){var r=e.mul(n);return r.sub(r.sum([t],!0).mul(n))}}})(r)}function logSoftmax_(e,t){void 0===t&&(t=-1);var r=convertToTensor(e,"logits","logSoftmax");if(-1===t&&(t=r.rank-1),t!==r.rank-1)throw Error("Log Softmax along a non-last dimension is not yet supported. Logits was rank "+r.rank+" and axis was "+t);return customGrad(function(e){var r=e.max(t,!0),n=e.sub(r),o=n.toFloat().sub(n.exp().sum(t,!0).log());return{value:o,gradFunc:function(e){var r=o.exp();return e.sub(e.sum(t,!0).mul(r))}}})(r)}var softmax=op({softmax_:softmax_}),logSoftmax=op({logSoftmax_:logSoftmax_});function complex_(e,t){var r=convertToTensor(e,"real","complex"),n=convertToTensor(t,"imag","complex");return assertShapesMatch(r.shape,n.shape,"real and imag shapes, "+r.shape+" and "+n.shape+", must match in call to tf.complex()."),ENV.engine.runKernel(function(e){return e.complex(r,n)},{$real:r,$imag:n})}function real_(e){var t=convertToTensor(e,"input","real");return ENV.engine.runKernel(function(e){return e.real(t)},{$input:t})}function imag_(e){var t=convertToTensor(e,"input","imag");return ENV.engine.runKernel(function(e){return e.imag(t)},{$input:t})}var complex=op({complex_:complex_}),real=op({real_:real_}),imag=op({imag_:imag_});function tensor(e,t,r){if(void 0===r&&(r="float32"),"complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!isTypedArray(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e)throw new Error("values passed to tensor(values) must be an array of numbers or booleans, or a TypedArray");var n=inferShape(e);return null!=t&&1!==n.length&&assertShapesMatch(t,n,"Error creating a new Tensor. Inferred shape ("+n+") does not match the provided shape ("+t+"). "),isTypedArray(e)||Array.isArray(e)||(e=[e]),t=t||n,Tensor.make(t,{values:toTypedArray(e,r,ENV.get("DEBUG"))},r)}function scalar(e,t){if(void 0===t&&(t="float32"),(isTypedArray(e)||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean)");return tensor(e,[],t)}function tensor1d(e,t){void 0===t&&(t="float32"),assertNonNull(e);var r=inferShape(e);if(1!==r.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return tensor(e,r,t)}function tensor2d(e,t,r){if(void 0===r&&(r="float32"),assertNonNull(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");var n=inferShape(e);if(2!==n.length&&1!==n.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===n.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return tensor(e,t=t||n,r)}function tensor3d(e,t,r){if(void 0===r&&(r="float32"),assertNonNull(e),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");var n=inferShape(e);if(3!==n.length&&1!==n.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===n.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return tensor(e,t=t||n,r)}function tensor4d(e,t,r){if(void 0===r&&(r="float32"),assertNonNull(e),null!=t&&4!==t.length)throw new Error("tensor4d() requires shape to have four numbers");var n=inferShape(e);if(4!==n.length&&1!==n.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===n.length&&null==t)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return tensor(e,t=t||n,r)}function tensor5d(e,t,r){if(void 0===r&&(r="float32"),assertNonNull(e),null!=t&&5!==t.length)throw new Error("tensor5d() requires shape to have five numbers");var n=inferShape(e);if(5!==n.length&&1!==n.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===n.length&&null==t)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return tensor(e,t=t||n,r)}function tensor6d(e,t,r){if(void 0===r&&(r="float32"),assertNonNull(e),null!=t&&6!==t.length)throw new Error("tensor6d() requires shape to have six numbers");var n=inferShape(e);if(6!==n.length&&1!==n.length)throw new Error("tensor6d() requires values to be number[][][][] or flat/TypedArray");if(1===n.length&&null==t)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return tensor(e,t=t||n,r)}function ones$1(e,t){if(void 0===t&&(t="float32"),"complex64"===t){var r=ones$1(e,"float32"),n=ones$1(e,"float32");return complex(r,n)}var o=makeOnesTypedArray(sizeFromShape(e),t);return Tensor.make(e,{values:o},t)}function zeros(e,t){if(void 0===t&&(t="float32"),"complex64"===t){var r=zeros(e,"float32"),n=zeros(e,"float32");return complex(r,n)}var o=makeZerosTypedArray(sizeFromShape(e),t);return Tensor.make(e,{values:o},t)}function fill(e,t,r){void 0===r&&(r="float32");var n=getTypedArrayFromDType(r,sizeFromShape(e));return n.fill(t),Tensor.make(e,{values:n},r)}function onesLike_(e){var t=convertToTensor(e,"x","onesLike");return ones$1(t.shape,t.dtype)}function zerosLike_(e){var t=convertToTensor(e,"x","zerosLike");return zeros(t.shape,t.dtype)}function linspace(e,t,r){if(0===r)throw new Error("Cannot request zero samples");var n=(t-e)/(r-1),o=makeZerosTypedArray(r,"float32");o[0]=e;for(var a=1;a<o.length;a++)o[a]=o[a-1]+n;return tensor1d(o,"float32")}function range(e,t,r,n){if(void 0===r&&(r=1),void 0===n&&(n="float32"),0===r)throw new Error("Cannot have a step of zero");if(e===t||e<t&&r<0||t<e&&r>1)return zeros([0],n);var o=makeZerosTypedArray(Math.abs(Math.ceil((t-e)/r)),n);t<e&&1===r&&(r=-1),o[0]=e;for(var a=1;a<o.length;a++)o[a]=o[a-1]+r;return tensor1d(o,n)}var DType,Rank,UpcastInt32AndMap,UpcastBoolAndMap,UpcastFloat32AndMap,UpcastComplex64AndMap,onesLike=op({onesLike_:onesLike_}),zerosLike=op({zerosLike_:zerosLike_});!function(e){e.float32="float32",e.int32="int32",e.bool="bool"}(DType||(DType={})),function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"}(Rank||(Rank={})),function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"}(UpcastInt32AndMap||(UpcastInt32AndMap={})),function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"}(UpcastBoolAndMap||(UpcastBoolAndMap={})),function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"}(UpcastFloat32AndMap||(UpcastFloat32AndMap={})),function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"}(UpcastComplex64AndMap||(UpcastComplex64AndMap={}));var upcastTypeMap={float32:UpcastFloat32AndMap,int32:UpcastInt32AndMap,bool:UpcastBoolAndMap,complex64:UpcastComplex64AndMap};function upcastType(e,t){return upcastTypeMap[e][t]}function sumOutType(e){return upcastType(e,"int32")}var DataStorage=function(){function e(e){this.dataMover=e,this.data=new WeakMap}return e.prototype.get=function(e){return this.data.has(e)||this.dataMover.moveData(e),this.data.get(e)},e.prototype.set=function(e,t){this.data.set(e,t)},e.prototype.has=function(e){return this.data.has(e)},e.prototype.delete=function(e){return this.data.delete(e)},e}(),KernelBackend=function(){function e(){}return e.prototype.time=function(e){throw new Error("Not yet implemented.")},e.prototype.read=function(e){throw new Error("Not yet implemented.")},e.prototype.readSync=function(e){throw new Error("Not yet implemented.")},e.prototype.disposeData=function(e){throw new Error("Not yet implemented.")},e.prototype.write=function(e,t){throw new Error("Not yet implemented.")},e.prototype.fromPixels=function(e,t){throw new Error("Not yet implemented.")},e.prototype.register=function(e,t,r){throw new Error("Not yet implemented.")},e.prototype.memory=function(){throw new Error("Not yet implemented.")},e.prototype.floatPrecision=function(){throw new Error("Not yet implemented")},e.prototype.batchMatMul=function(e,t,r,n){throw new Error("Not yet implemented")},e.prototype.slice=function(e,t,r){throw new Error("Not yet implemented")},e.prototype.stridedSlice=function(e,t,r,n,o,a,i,s,u){throw new Error("Not yet implemented")},e.prototype.reverse=function(e,t){throw new Error("Not yet implemented")},e.prototype.concat=function(e,t){throw new Error("Not yet implemented")},e.prototype.neg=function(e){throw new Error("Not yet implemented")},e.prototype.add=function(e,t){throw new Error("Not yet implemented")},e.prototype.addN=function(e){throw new Error("Not yet implemented")},e.prototype.subtract=function(e,t){throw new Error("Not yet implemented")},e.prototype.multiply=function(e,t){throw new Error("Not yet implemented")},e.prototype.realDivide=function(e,t){throw new Error("Not yet implemented")},e.prototype.floorDiv=function(e,t){throw new Error("Not yet implemented")},e.prototype.sum=function(e,t){throw new Error("Not yet implemented")},e.prototype.prod=function(e,t){throw new Error("Not yet implemented")},e.prototype.unsortedSegmentSum=function(e,t,r){throw new Error("Not yet implemented")},e.prototype.argMin=function(e,t){throw new Error("Not yet implemented")},e.prototype.argMax=function(e,t){throw new Error("Not yet implemented")},e.prototype.equal=function(e,t){throw new Error("Not yet implemented")},e.prototype.notEqual=function(e,t){throw new Error("Not yet implemented")},e.prototype.less=function(e,t){throw new Error("Not yet implemented")},e.prototype.lessEqual=function(e,t){throw new Error("Not yet implemented")},e.prototype.greater=function(e,t){throw new Error("Not yet implemented")},e.prototype.greaterEqual=function(e,t){throw new Error("Not yet implemented")},e.prototype.logicalNot=function(e){throw new Error("Not yet implemented")},e.prototype.logicalAnd=function(e,t){throw new Error("Not yet implemented")},e.prototype.logicalOr=function(e,t){throw new Error("Not yet implemented")},e.prototype.where=function(e){throw new Error("Not yet implemented")},e.prototype.select=function(e,t,r){throw new Error("Not yet implemented")},e.prototype.topk=function(e,t,r){throw new Error("Not yet implemented")},e.prototype.min=function(e,t){throw new Error("Not yet implemented")},e.prototype.minimum=function(e,t){throw new Error("Not yet implemented")},e.prototype.mod=function(e,t){throw new Error("Not yet implemented")},e.prototype.max=function(e,t){throw new Error("Not yet implemented")},e.prototype.maximum=function(e,t){throw new Error("Not yet implemented")},e.prototype.all=function(e,t){throw new Error("Not yet implemented")},e.prototype.any=function(e,t){throw new Error("Not yet implemented")},e.prototype.squaredDifference=function(e,t){throw new Error("Not yet implemented")},e.prototype.ceil=function(e){throw new Error("Not yet implemented")},e.prototype.floor=function(e){throw new Error("Not yet implemented")},e.prototype.round=function(e){throw new Error("Not yet implemented")},e.prototype.sign=function(e){throw new Error("Not yet implemented")},e.prototype.pow=function(e,t){throw new Error("Not yet implemented")},e.prototype.exp=function(e){throw new Error("Not yet implemented")},e.prototype.expm1=function(e){throw new Error("Not yet implemented")},e.prototype.log=function(e){throw new Error("Not yet implemented")},e.prototype.log1p=function(e){throw new Error("Not yet implemented")},e.prototype.sqrt=function(e){throw new Error("Not yet implemented")},e.prototype.rsqrt=function(e){throw new Error("Not yet implemented")},e.prototype.square=function(e){throw new Error("Not yet implemented")},e.prototype.reciprocal=function(e){throw new Error("Not yet implemented")},e.prototype.relu=function(e){throw new Error("Not yet implemented")},e.prototype.elu=function(e){throw new Error("Not yet implemented")},e.prototype.eluDer=function(e,t){throw new Error("Not yet implemented")},e.prototype.selu=function(e){throw new Error("Not yet implemented")},e.prototype.int=function(e){throw new Error("Not yet implemented")},e.prototype.clip=function(e,t,r){throw new Error("Not yet implemented")},e.prototype.abs=function(e){throw new Error("Not yet implemented")},e.prototype.complexAbs=function(e){throw new Error("Not yet implemented")},e.prototype.sigmoid=function(e){throw new Error("Not yet implemented")},e.prototype.softplus=function(e){throw new Error("Not yet implemented")},e.prototype.sin=function(e){throw new Error("Not yet implemented")},e.prototype.cos=function(e){throw new Error("Not yet implemented")},e.prototype.tan=function(e){throw new Error("Not yet implemented")},e.prototype.asin=function(e){throw new Error("Not yet implemented")},e.prototype.acos=function(e){throw new Error("Not yet implemented")},e.prototype.atan=function(e){throw new Error("Not yet implemented")},e.prototype.atan2=function(e,t){throw new Error("Not yet implemented")},e.prototype.sinh=function(e){throw new Error("Not yet implemented")},e.prototype.cosh=function(e){throw new Error("Not yet implemented")},e.prototype.tanh=function(e){throw new Error("Not yet implemented")},e.prototype.asinh=function(e){throw new Error("Not yet implemented")},e.prototype.acosh=function(e){throw new Error("Not yet implemented")},e.prototype.atanh=function(e){throw new Error("Not yet implemented")},e.prototype.erf=function(e){throw new Error("Not yet implemented")},e.prototype.step=function(e,t){throw new Error("Not yet implemented")},e.prototype.conv2d=function(e,t,r){throw new Error("Not yet implemented")},e.prototype.conv2dDerInput=function(e,t,r){throw new Error("Not yet implemented")},e.prototype.conv2dDerFilter=function(e,t,r){throw new Error("Not yet implemented")},e.prototype.depthwiseConv2D=function(e,t,r){throw new Error("Not yet implemented")},e.prototype.depthwiseConv2DDerInput=function(e,t,r){throw new Error("Not yet implemented")},e.prototype.depthwiseConv2DDerFilter=function(e,t,r){throw new Error("Not yet implemented")},e.prototype.maxPool=function(e,t){throw new Error("Not yet implemented")},e.prototype.maxPoolBackprop=function(e,t,r,n){throw new Error("Not yet implemented")},e.prototype.avgPool=function(e,t){throw new Error("Not yet implemented")},e.prototype.avgPoolBackprop=function(e,t,r){throw new Error("Not yet implemented")},e.prototype.reshape=function(e,t){throw new Error("Not yet implemented")},e.prototype.cast=function(e,t){throw new Error("Not yet implemented")},e.prototype.tile=function(e,t){throw new Error("Not yet implemented")},e.prototype.pad=function(e,t,r){throw new Error("Not yet implemented")},e.prototype.transpose=function(e,t){throw new Error("Not yet implemented")},e.prototype.gather=function(e,t,r){throw new Error("Not yet implemented")},e.prototype.gatherND=function(e,t){throw new Error("Not yet implemented")},e.prototype.scatterND=function(e,t,r){throw new Error("Not yet implemented")},e.prototype.batchToSpaceND=function(e,t,r){throw new Error("Not yet implemented")},e.prototype.spaceToBatchND=function(e,t,r){throw new Error("Not yet implemented")},e.prototype.resizeBilinear=function(e,t,r,n){throw new Error("Not yet implemented")},e.prototype.resizeBilinearBackprop=function(e,t,r){throw new Error("Not yet implemented")},e.prototype.resizeNearestNeighbor=function(e,t,r,n){throw new Error("Not yet implemented")},e.prototype.resizeNearestNeighborBackprop=function(e,t,r){throw new Error("Not yet implemented")},e.prototype.batchNormalization=function(e,t,r,n,o,a){throw new Error("Not yet implemented")},e.prototype.localResponseNormalization4D=function(e,t,r,n,o){throw new Error("Not yet implemented")},e.prototype.LRNGrad=function(e,t,r,n,o,a,i){throw new Error("Not yet implemented")},e.prototype.multinomial=function(e,t,r,n){throw new Error("Not yet implemented")},e.prototype.oneHot=function(e,t,r,n){throw new Error("Not yet implemented")},e.prototype.cumsum=function(e,t,r,n){throw new Error("Not yet implemented")},e.prototype.nonMaxSuppression=function(e,t,r,n,o){throw new Error("Not yet implemented")},e.prototype.fft=function(e){throw new Error("Not yet implemented")},e.prototype.ifft=function(e){throw new Error("Not yet implemented")},e.prototype.complex=function(e,t){throw new Error("Not yet implemented")},e.prototype.real=function(e){throw new Error("Not yet implemented")},e.prototype.imag=function(e){throw new Error("Not yet implemented")},e.prototype.cropAndResize=function(e,t,r,n,o,a){throw new Error("Not yet implemented")},e.prototype.depthToSpace=function(e,t,r){throw new Error("Not yet implemented")},e.prototype.split=function(e,t,r){throw new Error("Not yet implemented")},e.prototype.sparseToDense=function(e,t,r,n){throw new Error("Not yet implemented")},e.prototype.setDataMover=function(e){throw new Error("Not yet implemented")},e.prototype.dispose=function(){throw new Error("Not yet implemented")},e}();function castTensor(e,t,r){if("complex64"===t){if("complex64"===e.dtype)return e.clone();var n=zeros(e.shape),o=e.toFloat(),a=r.complex(o,n);return n.dispose(),o.dispose(),a}if(!hasEncodingLoss(e.dtype,t))return Tensor.make(e.shape,{dataId:e.dataId},t);if("complex64"===e.dtype){var i=r.real(e);a=i.cast(t);return i.dispose(),a}if("int32"===t)return r.int(e);if("bool"===t){var s=scalar(0,e.dtype);a=r.notEqual(e,s);return s.dispose(),a}throw new Error("Error in Cast: unknown dtype argument ("+t+")")}function reshapeTensor(e,t){return Tensor.make(t,{dataId:e.dataId},e.dtype)}function mergeRealAndImagArrays(e,t){if(e.length!==t.length)throw new Error("Cannot merge real and imag arrays of different lengths. real:"+e.length+", imag: "+t.length+".");for(var r=new Float32Array(2*e.length),n=0;n<r.length;n+=2)r[n]=e[n/2],r[n+1]=t[n/2];return r}function splitRealAndImagArrays(e){for(var t=new Float32Array(e.length/2),r=new Float32Array(e.length/2),n=0;n<e.length;n+=2)t[n/2]=e[n],r[n/2]=e[n+1];return{real:t,imag:r}}function complexWithEvenIndex(e){for(var t=Math.ceil(e.length/4),r=new Float32Array(t),n=new Float32Array(t),o=0;o<e.length;o+=4)r[Math.floor(o/4)]=e[o],n[Math.floor(o/4)]=e[o+1];return{real:r,imag:n}}function complexWithOddIndex(e){for(var t=Math.floor(e.length/4),r=new Float32Array(t),n=new Float32Array(t),o=2;o<e.length;o+=4)r[Math.floor(o/4)]=e[o],n[Math.floor(o/4)]=e[o+1];return{real:r,imag:n}}function getComplexWithIndex(e,t){return{real:e[2*t],imag:e[2*t+1]}}function assignToTypedArray(e,t,r,n){e[2*n]=t,e[2*n+1]=r}function exponents(e,t){for(var r=new Float32Array(e/2),n=new Float32Array(e/2),o=0;o<Math.ceil(e/2);o++){var a=(t?2:-2)*Math.PI*(o/e);r[o]=Math.cos(a),n[o]=Math.sin(a)}return{real:r,imag:n}}function exponent(e,t,r){var n=(r?2:-2)*Math.PI*(e/t);return{real:Math.cos(n),imag:Math.sin(n)}}function nonMaxSuppressionImpl(e,t,r,n,o){for(var a=Array.from(t).map(function(e,t){return{score:e,boxIndex:t}}).filter(function(e){return e.score>o}).sort(function(e,t){return t.score-e.score}),i=[],s=0;s<a.length;s++){var u=a[s],l=u.score,c=u.boxIndex;if(l<o)break;for(var p=!1,d=i.length-1;d>=0;--d){if(intersectionOverUnion(e,c,i[d])>=n){p=!0;break}}if(!p&&(i.push(c),i.length>=r))break}return tensor1d(i,"int32")}function intersectionOverUnion(e,t,r){var n=e.subarray(4*t,4*t+4),o=e.subarray(4*r,4*r+4),a=Math.min(n[0],n[2]),i=Math.min(n[1],n[3]),s=Math.max(n[0],n[2]),u=Math.max(n[1],n[3]),l=Math.min(o[0],o[2]),c=Math.min(o[1],o[3]),p=Math.max(o[0],o[2]),d=Math.max(o[1],o[3]),h=(s-a)*(u-i),f=(p-l)*(d-c);if(h<=0||f<=0)return 0;var m=Math.max(a,l),g=Math.max(i,c),v=Math.min(s,p),y=Math.min(u,d),x=Math.max(v-m,0)*Math.max(y-g,0);return x/(h+f-x)}function split(e,t,r){var n=Array(e.rank).fill(0),o=e.shape.slice();return t.map(function(t){o[r]=t;var a=e.slice(n,o);return n[r]+=t,a})}function topkImpl(e,t,r,n,o){for(var a=t[t.length-1],i=[e.length/a,a],s=i[0],u=i[1],l=getTypedArrayFromDType(r,s*n),c=getTypedArrayFromDType("int32",s*n),p=0;p<s;p++){for(var d=p*u,h=e.subarray(d,d+u),f=[],m=0;m<h.length;m++)f.push({value:h[m],index:m});f.sort(function(e,t){return t.value-e.value});var g=p*n,v=l.subarray(g,g+n),y=c.subarray(g,g+n);for(m=0;m<n;m++)v[m]=f[m].value,y[m]=f[m].index}var x=t.slice();return x[x.length-1]=n,[tensor(l,x,r),tensor(c,x,"int32")]}var ArgMinMaxProgram=function(){return function(e,t,r){this.variableNames=["A"];var n=e.windowSize,o=e.batchSize,a=e.inSize,i=Math.ceil(a/n);r||this.variableNames.push("bestIndicesA"),this.outputShape=[o,i];var s="max"===t?">":"<",u=r?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * "+n+";\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < "+n+"; i++) {\n          int inIdx = "+u+";\n          float candidate = getA(batch, inIdx);\n          if (candidate "+s+" bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    "}}(),AvgPool2DBackpropProgram=function(){return function(e){this.variableNames=["dy"],this.outputShape=e.inShape;var t=e.filterHeight,r=e.filterWidth,n=e.strideHeight,o=e.strideWidth,a=e.dilationHeight,i=e.dilationWidth,s=e.effectiveFilterHeight,u=e.effectiveFilterWidth,l=s-1-e.padInfo.top,c=u-1-e.padInfo.left,p=1/(t*r);this.userCode="\n      const ivec2 pads = ivec2("+l+", "+c+");\n      const float avgMultiplier = float("+p+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < "+s+";\n            wR += "+a+") {\n          float dyR = float(dyRCorner + wR) / "+n+".0;\n\n          if (dyR < 0.0 || dyR >= "+e.outHeight+".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < "+u+";\n            wC+= "+i+") {\n            float dyC = float(dyCCorner + wC) / "+o+".0;\n\n            if (dyC < 0.0 || dyC >= "+e.outWidth+".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}}();function getBroadcastDims(e,t){for(var r=e.length,n=[],o=0;o<r;o++){var a=r-1-o,i=e[a]||1;(t[t.length-1-o]||1)>1&&1===i&&n.unshift(a)}return n}function getReductionAxes(e,t){for(var r=[],n=0;n<t.length;n++){var o=e[e.length-n-1],a=t.length-n-1,i=t[a];(null==o||1===o&&i>1)&&r.unshift(a)}return r}function broadcastDimsAreOuter(e){for(var t=0;t<e.length;t++)if(e[t]!==t)return!1;return!0}function assertAndGetBroadcastShape(e,t){for(var r=[],n=Math.max(e.length,t.length),o=0;o<n;o++){var a=e[e.length-o-1];null==a&&(a=1);var i=t[t.length-o-1];if(null==i&&(i=1),1===a)r.unshift(i);else if(1===i)r.unshift(a);else{if(a!==i)throw Error("Operands could not be broadcast together with shapes "+e+" and "+t+".");r.unshift(a)}}return r}var BatchNormProgram=function(){return function(e,t,r,n,o,a){this.outputShape=[],this.supportsBroadcasting=!0,this.variableNames=["x","mean","variance"],assertAndGetBroadcastShape(e,t),assertAndGetBroadcastShape(e,r);var i="0.0";null!=n&&(assertAndGetBroadcastShape(e,n),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");var s="1.0";null!=o&&(assertAndGetBroadcastShape(e,o),this.variableNames.push("scale"),s="getScaleAtOutCoords()"),this.outputShape=e,this.userCode="\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = "+i+";\n        float scale = "+s+";\n        float inv = scale * inversesqrt(variance + float("+a+"));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    "}}(),BatchNormPackedProgram=function(){return function(e,t,r,n,o,a){this.supportsBroadcasting=!0,this.usesPackedTextures=!0,this.variableNames=["x","mean","variance"],assertAndGetBroadcastShape(e,t),assertAndGetBroadcastShape(e,r);var i=broadcastSample("mean",t.length),s=broadcastSample("variance",r.length),u="vec4 offset = vec4(0.0)";null!=n&&(assertAndGetBroadcastShape(e,n),this.variableNames.push("offset"),u=broadcastSample("offset",n.length));var l="vec4 scale = vec4(1.0)";null!=o&&(assertAndGetBroadcastShape(e,o),this.variableNames.push("scale"),l=broadcastSample("scale",o.length)),this.outputShape=e,this.userCode="\n      void main() {\n        ivec4 rc = getOutputCoords();\n\n        "+u+";\n        "+l+";\n\n        vec4 x = getX(rc.x, rc.y, rc.z, rc.w);\n        "+i+";\n        "+s+";\n\n        vec4 inv = scale * inversesqrt(variance + vec4("+a+"));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    "}}();function broadcastSample(e,t){var r="get"+e.charAt(0).toUpperCase()+e.slice(1);return 1===t?"\n      vec4 "+e+"Sample = "+r+"(rc.w);\n      vec4 "+e+" = vec4("+e+"Sample.xy, "+e+"Sample.xy);\n    ":"vec4 "+e+" = "+r+"(rc.x, rc.y, rc.z, rc.w)"}var COMPLEX_MULTIPLY={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"},BinaryOpComplexProgram=function(){return function(e,t,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.supportsBroadcasting=!0,this.outputShape=assertAndGetBroadcastShape(t,r),this.userCode="\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        "+e+"\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    "}}(),CHECK_NAN_SNIPPET="\n  if (isNaN(a)) return a;\n  if (isNaN(b)) return b;\n",ADD="return a + b;",SUB="return a - b;",MUL="return a * b;",DIV="if (a == b) return 1.0;\n  return a / b;",INT_DIV="\n  float resultSign = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  int result = ia / ib;\n  int amodb = ia - ib * result;\n\n  if (resultSign < 0.0 && amodb != 0) {\n    result -= 1;\n  }\n  return float(result);\n",POW="\nif(a < 0.0 && floor(b) < b){\n  return NAN;\n}\nreturn (round(mod(b, 2.0)) == 0 || round(mod(b, 2.0)) == 2) ?\n    pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",SQUARED_DIFFERENCE="return (a - b) * (a - b);",EQUAL="return float(a == b);",NOT_EQUAL="return float(a != b);",LESS="return float(a < b);",LESS_EQUAL="return float(a <= b);",GREATER="return float(a > b);",GREATER_EQUAL="return float(a >= b);",LOGICAL_AND="return float(a >= 1.0 && b >= 1.0);",LOGICAL_OR="return float(a >= 1.0 || b >= 1.0);",MAX=CHECK_NAN_SNIPPET+"\n  return max(a, b);\n",MIN=CHECK_NAN_SNIPPET+"\n  return min(a, b);\n",MOD="if (b == 0.0) return NAN;\n  return mod(a, b);",ATAN2=CHECK_NAN_SNIPPET+"\n  return atan(a, b);\n",ELU_DER="return (b >= 1.0) ? a : a * (b + 1.0);",BinaryOpProgram=function(){function e(e,t,r){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.outputShape=assertAndGetBroadcastShape(t,r),this.userCode="\n      uniform float NAN;\n      float binaryOperation(float a, float b) {\n        "+e+"\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    "}return e.prototype.getCustomSetupFunc=function(){var e=this;return function(t,r){null==e.startLoc&&(e.startLoc=t.getUniformLocationNoThrow(r,"NAN"),null==e.startLoc)||t.gl.uniform1f(e.startLoc,NaN)}},e}(),ClipProgram=function(){return function(e,t,r){this.variableNames=["A"],this.outputShape=e,this.userCode="\n      void main() {\n        float value = getAAtOutCoords();\n        if (isNaN(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, float("+t+"), float("+r+")));\n      }\n    "}}(),ComplexAbsProgram=function(){return function(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float real = getRealAtOutCoords();\n        float imag = getImagAtOutCoords();\n        vec2 v = vec2(real, imag);\n\n        setOutput(sqrt(dot(v, v)));\n      }\n    "}}(),ConcatProgram=function(){return function(e,t){this.variableNames=["A","B"],this.outputShape=[],this.outputShape=computeOutShape([e,t],1),this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        float value = 0.0;\n        if (yC < "+e[1]+") {\n          value = getA(yR, yC);\n        } else {\n          yC -= "+e[1]+";\n          value = getB(yR, yC);\n        }\n\n        setOutput(value);\n      }\n    "}}(),Conv2DDerFilterProgram=function(){return function(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;var t=e.strideHeight,r=e.strideWidth,n=e.padInfo.top,o=e.padInfo.left;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < "+e.batchSize+"; b++) {\n          for (int yR = 0; yR < "+e.outHeight+"; yR++) {\n            int xR = wR + yR * "+t+" - "+n+";\n\n            if (xR < 0 || xR >= "+e.inHeight+") {\n              continue;\n            }\n\n            for (int yC = 0; yC < "+e.outWidth+"; yC++) {\n              int xC = wC + yC * "+r+" - "+o+";\n\n              if (xC < 0 || xC >= "+e.inWidth+") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}}(),Conv2DDerInputProgram=function(){return function(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;var t=e.filterHeight,r=e.filterWidth,n=e.strideHeight,o=e.strideWidth,a=t-1-e.padInfo.top,i=r-1-e.padInfo.left;this.userCode="\n      const ivec2 pads = ivec2("+a+", "+i+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < "+t+"; wR++) {\n          float dyR = float(dyRCorner + wR) / "+n+".0;\n\n          if (dyR < 0.0 || dyR >= "+e.outHeight+".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = "+t+" - 1 - wR;\n\n          for (int wC = 0; wC < "+r+"; wC++) {\n            float dyC = float(dyCCorner + wC) / "+o+".0;\n\n            if (dyC < 0.0 || dyC >= "+e.outWidth+".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = "+r+" - 1 - wC;\n\n            for (int d2 = 0; d2 < "+e.outChannels+"; d2++) {\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, d2);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}}(),DepthwiseConv2DDerFilterProgram=function(){return function(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;var t=e.strideHeight,r=e.strideWidth,n=e.padInfo.top,o=e.padInfo.left,a=e.outChannels/e.inChannels;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * "+a+" + dm;\n\n        float dotProd = 0.0;\n\n        // TODO: Vec4 over the batch size\n        for (int b = 0; b < "+e.batchSize+"; b++) {\n          for (int yR = 0; yR < "+e.outHeight+"; yR++) {\n            int xR = wR + yR * "+t+" - "+n+";\n\n            if (xR < 0 || xR >= "+e.inHeight+") {\n              continue;\n            }\n\n            for (int yC = 0; yC < "+e.outWidth+"; yC++) {\n              int xC = wC + yC * "+r+" - "+o+";\n\n              if (xC < 0 || xC >= "+e.inWidth+") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}}(),DepthwiseConv2DDerInputProgram=function(){return function(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;var t=e.filterHeight,r=e.filterWidth,n=e.strideHeight,o=e.strideWidth,a=t-1-e.padInfo.top,i=r-1-e.padInfo.left,s=e.outChannels/e.inChannels;this.userCode="\n      const ivec2 pads = ivec2("+a+", "+i+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < "+t+"; wR++) {\n          float dyR = float(dyRCorner + wR) / "+n+".0;\n\n          if (dyR < 0.0 || dyR >= "+e.outHeight+".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = "+t+" - 1 - wR;\n\n          for (int wC = 0; wC < "+r+"; wC++) {\n            float dyC = float(dyCCorner + wC) / "+o+".0;\n\n            if (dyC < 0.0 || dyC >= "+e.outWidth+".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = "+r+" - 1 - wC;\n\n            // TODO: Vec4 over the channelMul\n            for (int dm = 0; dm < "+s+"; dm++) {\n              int d2 = d1 * "+s+" + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}}(),Conv2DProgram=function(){return function(e){this.variableNames=["x","W"],this.outputShape=e.outShape;var t=e.padInfo.top,r=e.padInfo.left,n=e.strideHeight,o=e.strideWidth,a=e.dilationHeight,i=e.dilationWidth,s=e.filterHeight,u=e.filterWidth,l=4*Math.floor(e.inChannels/4),c=e.inChannels%4;this.userCode="\n      const ivec2 strides = ivec2("+n+", "+o+");\n      const ivec2 pads = ivec2("+t+", "+r+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < "+s+"; wR++) {\n          int xR = xRCorner + wR * "+a+";\n\n          if (xR < 0 || xR >= "+e.inHeight+") {\n            continue;\n          }\n\n          for (int wC = 0; wC < "+u+"; wC++) {\n            int xC = xCCorner + wC * "+i+";\n\n            if (xC < 0 || xC >= "+e.inWidth+") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < "+l+"; d1 += 4) {\n              vec4 xValues = vec4(\n                getX(batch, xR, xC, d1),\n                getX(batch, xR, xC, d1 + 1),\n                getX(batch, xR, xC, d1 + 2),\n                getX(batch, xR, xC, d1 + 3)\n              );\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              dotProd += dot(xValues, wValues);\n            }\n\n            if ("+(1===c)+") {\n              dotProd +=\n                getX(batch, xR, xC, "+l+") *\n                getW(wR, wC, "+l+", d2);\n            } else if ("+(2===c)+") {\n              vec2 xValues = vec2(\n                getX(batch, xR, xC, "+l+"),\n                getX(batch, xR, xC, "+l+" + 1)\n              );\n              vec2 wValues = vec2(\n                getW(wR, wC, "+l+", d2),\n                getW(wR, wC, "+l+" + 1, d2)\n              );\n              dotProd += dot(xValues, wValues);\n            } else if ("+(3===c)+") {\n              vec3 xValues = vec3(\n                getX(batch, xR, xC, "+l+"),\n                getX(batch, xR, xC, "+l+" + 1),\n                getX(batch, xR, xC, "+l+" + 2)\n              );\n              vec3 wValues = vec3(\n                getW(wR, wC, "+l+", d2),\n                getW(wR, wC, "+l+" + 1, d2),\n                getW(wR, wC, "+l+" + 2, d2)\n              );\n              dotProd += dot(xValues, wValues);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}}(),DepthwiseConv2DProgram=function(){return function(e){this.variableNames=["x","W"],this.outputShape=e.outShape;var t=e.inHeight,r=e.inWidth,n=e.padInfo.top,o=e.padInfo.left,a=e.strideHeight,i=e.strideWidth,s=e.dilationHeight,u=e.dilationWidth,l=e.filterHeight,c=e.filterWidth,p=e.outChannels/e.inChannels;this.userCode="\n      const ivec2 strides = ivec2("+a+", "+i+");\n      const ivec2 pads = ivec2("+n+", "+o+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / "+p+";\n        int q = d2 - d1 * "+p+";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TODO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < "+l+"; wR++) {\n          int xR = xRCorner + wR * "+s+";\n\n          if (xR < 0 || xR >= "+t+") {\n            continue;\n          }\n\n          for (int wC = 0; wC < "+c+"; wC++) {\n            int xC = xCCorner + wC * "+u+";\n\n            if (xC < 0 || xC >= "+r+") {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}}(),CropAndResizeProgram=function(){return function(e,t,r,n,o){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];var a=e[0],i=e[1],s=e[2],u=e[3],l=t[0],c=r[0],p=r[1];this.outputShape=[l,c,p,u];var d="bilinear"===n?1:0,h=[i-1+".0",s-1+".0"],f=h[0],m=h[1],g=c>1?[""+(i-1)/(c-1),"(y2-y1) * height_ratio","y1*"+f+" + float(y)*(height_scale)"]:["0.0","0.0","0.5 * (y1+y2) * "+f],v=g[0],y=g[1],x=g[2],T=p>1?[""+(s-1)/(p-1),"(x2-x1) * width_ratio","x1*"+m+" + float(x)*(width_scale)"]:["0.0","0.0","0.5 * (x1+x2) * "+m],E=T[0],w=T[1],S=T[2];this.userCode="\n      const float height_ratio = float("+v+");\n      const float width_ratio = float("+E+");\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= "+a+") {\n          return;\n        }\n\n        float height_scale = "+y+";\n        float width_scale = "+w+";\n\n        float in_y = "+x+";\n        if( in_y < 0.0 || in_y > "+f+" ) {\n          setOutput(float("+o+"));\n          return;\n        }\n        float in_x = "+S+";\n        if( in_x < 0.0 || in_x > "+m+" ) {\n          setOutput(float("+o+"));\n          return;\n        }\n\n        vec2 sourceFracIndexRC = vec2(in_y,in_x);\n        if("+d+" == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\n          ivec2 sourceCeilRC = ivec2(ceil(sourceFracIndexRC));\n\n          float topLeft = getImage(b, sourceFloorRC.x, sourceFloorRC.y, d);\n          float bottomLeft = getImage(b, sourceCeilRC.x, sourceFloorRC.y, d);\n          float topRight = getImage(b, sourceFloorRC.x, sourceCeilRC.y, d);\n          float bottomRight = getImage(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n          vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n          float top = topLeft + (topRight - topLeft) * fracRC.y;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n          float newValue = top + (bottom - top) * fracRC.x;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestRC = ivec2(floor(\n            sourceFracIndexRC + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestRC.x, sourceNearestRC.y, d);\n          setOutput(newValue);\n        }\n      }\n    "}}();function getLogicalCoordinatesFromFlatIndex(e,t,r){void 0===r&&(r="index");var n=computeStrides(t);return n.map(function(t,o){return"int "+e[o]+" = "+r+" / "+t+"; "+(o===n.length-1?"int "+e[o+1]+" = "+r+" - "+e[o]+" * "+t:"index -= "+e[o]+" * "+t)+";"}).join("")}function buildVec(e){return 1===e.length?""+e[0]:"vec"+e.length+"("+e.join(",")+")"}function dotify(e,t){if(e.length!==t.length)throw new Error("Vectors to be dotted must be of the same length -got "+e.length+" and "+t.length);for(var r=[],n=Math.floor(e.length/4),o=e.length%4,a=0;a<n;a++){var i=e.slice(4*a,4*a+4),s=t.slice(4*a,4*a+4);r.push(buildVec(i)+", "+buildVec(s))}if(0!==o){i=e.slice(4*n),s=t.slice(4*n);1===i.length&&(i=i.map(function(e){return"float("+e+")"}),s=s.map(function(e){return"float("+e+")"})),r.push(buildVec(i)+", "+buildVec(s))}return r.map(function(e,t){return"dot("+e+")"}).join("+")}function makeShader(e,t,r,n,o){var a=e.map(function(e){var t=sizeFromShape(e.shapeInfo.logicalShape);return e.shapeInfo.isUniform?"uniform float "+e.name+(t>1?"["+t+"]":"")+";":"uniform sampler2D "+e.name+";"});a=a.join("\n");var i,s,u=e.map(function(e){return getInputSamplingSnippet(e,t,n)}).join("\n"),l=t.texShape,c=SHADER_PREFIX;return t.isPacked?(i=getPackedOutputSamplingSnippet(t.logicalShape,l),s=FLOAT_TEXTURE_SET_RGBA_SNIPPET):(i=getOutputSamplingSnippet(t.logicalShape,l),s=FLOAT_TEXTURE_SET_R_SNIPPET),o&&(c+=SHADER_PACKED_PREFIX),[c,FLOAT_TEXTURE_SAMPLE_SNIPPET,s,a,i,u,r].join("\n")}function getSamplerFromInInfo(e){var t=e.shapeInfo.logicalShape;switch(t.length){case 0:return getSamplerScalar(e);case 1:return getSampler1D(e);case 2:return getSampler2D(e);case 3:return getSampler3D(e);case 4:return getSampler4D(e);case 5:return getSampler5D(e);case 6:return getSampler6D(e);default:throw new Error(t.length+"-D input sampling is not yet supported")}}function getPackedSamplerFromInInfo(e){var t=e.shapeInfo.logicalShape;switch(t.length){case 1:return getPackedSampler1D(e);case 2:return getPackedSampler2D(e);case 3:return getPackedSampler3D(e);case 4:return getPackedSampler4D(e);default:throw new Error("Packed "+t.length+"-D input sampling is not yet supported")}}function getInputSamplingSnippet(e,t,r){var n=getSamplerFlat(e);return e.shapeInfo.isPacked?n+=getPackedSamplerFromInInfo(e):n+=getSamplerFromInInfo(e),(r||arraysEqual(e.shapeInfo.logicalShape,t.logicalShape))&&(n+=getSamplerAtOutputCoords(e,t,r)),n}function getPackedOutputSamplingSnippet(e,t){switch(e.length){case 0:return getOutputScalarCoords();case 1:return getOutputPacked1DCoords(e,t);case 2:return getOutputPacked2DCoords(e,t);case 3:return getOutputPacked3DCoords(e,t);case 4:return getOutputPacked4DCoords(e,t);default:throw new Error(e.length+"-D packed output coordinate fetching is not yet supported")}}function getOutputSamplingSnippet(e,t){switch(e.length){case 0:return getOutputScalarCoords();case 1:return getOutput1DCoords(e,t);case 2:return getOutput2DCoords(e,t);case 3:return getOutput3DCoords(e,t);case 4:return getOutput4DCoords(e,t);case 5:return getOutput5DCoords(e,t);case 6:return getOutput6DCoords(e,t);default:throw new Error(e.length+"-D output sampling is not yet supported")}}var SAMPLE_1D_SNIPPET="\nvec2 UVfrom1D(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",SAMPLE_2D_SNIPPET="\nvec2 UVfrom2D(int texNumR, int texNumC, int numC, int row, int col) {\n  int index = row * numC + col;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",SAMPLE_3D_SNIPPET="\nvec2 UVfrom3D(int texNumR, int texNumC, int stride0,\n    int stride1, int row, int col, int depth) {\n  // Explicitly use integer operations as dot() only works on floats.\n  int index = row * stride0 + col * stride1 + depth;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",SAMPLE_4D_SNIPPET="\nvec2 UVfrom4D(int texNumR, int texNumC, int stride0,\n    int stride1, int stride2, int row, int col, int depth,\n    int depth2) {\n  // Explicitly use integer operations as dot() only works on floats.\n  int index = row * stride0 + col * stride1 + depth * stride2 + depth2;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom4D(int texNumR, int texNumC, int texelsInBatch2,\n    int texelsInBatch, int texelsInLogicalRow, int b2, int b,\n    int row, int col) {\n  int index = b2 * texelsInBatch2 + b * texelsInBatch +\n    (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",SAMPLE_5D_SNIPPET="\nvec2 UVfrom5D(int texNumR, int texNumC, int stride0,\n    int stride1, int stride2, int stride3, int row, int col, int depth,\n    int depth2, int depth3) {\n  // Explicitly use integer operations as dot() only works on floats.\n  int index = row * stride0 + col * stride1 +\n              depth * stride2 + depth2 * stride3 + depth3;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",SAMPLE_6D_SNIPPET="\nvec2 UVfrom6D(int texNumR, int texNumC, int stride0,\n    int stride1, int stride2, int stride3, int stride4,\n    int row, int col, int depth, int depth2, int depth3, int depth4) {\n  // Explicitly use integer operations as dot() only works on floats.\n  int index = row * stride0 + col * stride1 + depth * stride2 + depth2 *\n    stride3 + depth3 * stride4 + depth4;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",FLOAT_TEXTURE_SAMPLE_SNIPPET="\n  float sampleTexture(sampler2D textureSampler, vec2 uv) {\n    return texture2D(textureSampler, uv).r;\n  }\n",FLOAT_TEXTURE_SET_R_SNIPPET="\n  void setOutput(float val) {\n    gl_FragColor = vec4(val, 0, 0, 0);\n  }\n",FLOAT_TEXTURE_SET_RGBA_SNIPPET="\n  void setOutput(vec4 val) {\n    gl_FragColor = val;\n  }\n",SHADER_PREFIX="\n  precision highp float;\n  precision highp int;\n  varying vec2 resultUV;\n  const vec2 halfCR = vec2(0.5, 0.5);\n\n  struct ivec5\n  {\n    int x;\n    int y;\n    int z;\n    int w;\n    int u;\n  };\n\n  struct ivec6\n  {\n    int x;\n    int y;\n    int z;\n    int w;\n    int u;\n    int v;\n  };\n\n  bool isNaN(float val) {\n    return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;\n  }\n\n  bool hasNaN(vec4 values) {\n    vec4 v1 = values * values;\n    vec4 v2 = values * values;\n    return any(notEqual(v1, v2));\n  }\n\n  float getNaN(vec4 values) {\n    return dot(vec4(1), values);\n  }\n\n  int round(float value) {\n    return int(floor(value + 0.5));\n  }\n\n  int imod(int x, int y) {\n    return x - y * (x / y);\n  }\n\n  //Based on the work of Dave Hoskins\n  //https://www.shadertoy.com/view/4djSRW\n  #define HASHSCALE1 443.8975\n  float random(float seed){\n    vec2 p = resultUV * seed;\n    vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n  }\n\n  "+SAMPLE_1D_SNIPPET+"\n  "+SAMPLE_2D_SNIPPET+"\n  "+SAMPLE_3D_SNIPPET+"\n  "+SAMPLE_4D_SNIPPET+"\n  "+SAMPLE_5D_SNIPPET+"\n  "+SAMPLE_6D_SNIPPET+"\n",SHADER_PACKED_PREFIX="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function getOutputScalarCoords(){return"\n    int getOutputCoords() {\n      return 0;\n    }\n  "}function getOutputPacked1DCoords(e,t){var r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return 1===t[0]?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * "+r[1]+".0);\n      }\n    ":1===t[1]?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * "+r[0]+".0);\n      }\n    ":"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+r[0]+", "+r[1]+"));\n      return resTexRC.x * "+r[1]+" + resTexRC.y;\n    }\n  "}function getOutput1DCoords(e,t){return 1===t[0]?"\n      int getOutputCoords() {\n        return int(resultUV.x * "+t[1]+".0);\n      }\n    ":1===t[1]?"\n      int getOutputCoords() {\n        return int(resultUV.y * "+t[0]+".0);\n      }\n    ":"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+t[0]+", "+t[1]+"));\n      return resTexRC.x * "+t[1]+" + resTexRC.y;\n    }\n  "}function getOutputPacked3DCoords(e,t){var r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],n=Math.ceil(e[2]/2),o=n*Math.ceil(e[1]/2);return"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+r[0]+", "+r[1]+"));\n      int index = resTexRC.x * "+r[1]+" + resTexRC.y;\n\n      int b = index / "+o+";\n      index -= b * "+o+";\n\n      int r = 2 * (index / "+n+");\n      int c = imod(index, "+n+") * 2;\n\n      return ivec3(b, r, c);\n    }\n  "}function getOutput3DCoords(e,t){var r=getLogicalCoordinatesFromFlatIndex(["r","c","d"],e);return"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+t[0]+", "+t[1]+"));\n      int index = resTexRC.x * "+t[1]+" + resTexRC.y;\n      "+r+"\n      return ivec3(r, c, d);\n    }\n  "}function getOutputPacked4DCoords(e,t){var r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],n=Math.ceil(e[3]/2),o=n*Math.ceil(e[2]/2),a=o*e[1];return"\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+r[0]+", "+r[1]+"));\n      int index = resTexRC.x * "+r[1]+" + resTexRC.y;\n\n      int b2 = index / "+a+";\n      index -= b2 * "+a+";\n\n      int b = index / "+o+";\n      index -= b * "+o+";\n\n      int r = 2 * (index / "+n+");\n      int c = imod(index, "+n+") * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  "}function getOutput4DCoords(e,t){var r=getLogicalCoordinatesFromFlatIndex(["r","c","d","d2"],e);return"\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2("+t[0]+", "+t[1]+"));\n      int index = resTexRC.x * "+t[1]+" + resTexRC.y;\n      "+r+"\n      return ivec4(r, c, d, d2);\n    }\n  "}function getOutput5DCoords(e,t){var r=getLogicalCoordinatesFromFlatIndex(["r","c","d","d2","d3"],e);return"\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2("+t[0]+",\n                             "+t[1]+"));\n\n      int index = resTexRC.x * "+t[1]+" + resTexRC.y;\n\n      "+r+"\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  "}function getOutput6DCoords(e,t){var r=getLogicalCoordinatesFromFlatIndex(["r","c","d","d2","d3","d4"],e);return"\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2("+t[0]+", "+t[1]+"));\n      int index = resTexRC.x * "+t[1]+" + resTexRC.y;\n\n      "+r+"\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  "}function getOutputPacked2DCoords(e,t){var r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(arraysEqual(e,t))return"\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2("+r[0]+", "+r[1]+"));\n      }\n    ";var n=Math.ceil(e[1]/2);return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+r[0]+", "+r[1]+"));\n\n      int index = resTexRC.x * "+r[1]+" + resTexRC.y;\n      int r = 2 * (index / "+n+");\n      int c = imod(index, "+n+") * 2;\n\n      return ivec2(r, c);\n    }\n  "}function getOutput2DCoords(e,t){return arraysEqual(e,t)?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2("+t[0]+", "+t[1]+"));\n      }\n    ":1===e[1]?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2("+t[0]+", "+t[1]+"));\n        int index = resTexRC.x * "+t[1]+" + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":1===e[0]?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2("+t[0]+", "+t[1]+"));\n        int index = resTexRC.x * "+t[1]+" + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+t[0]+", "+t[1]+"));\n      int index = resTexRC.x * "+t[1]+" + resTexRC.y;\n      int r = index / "+e[1]+";\n      int c = index - r * "+e[1]+";\n      return ivec2(r, c);\n    }\n  "}function getSamplerScalar(e){var t=e.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1);return e.shapeInfo.isUniform?"float "+r+"() {return "+t+";}":"\n    float "+r+"() {\n      return sampleTexture("+t+", halfCR);\n    }\n  "}function getPackedSampler1D(e){var t=e.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),n=e.shapeInfo.texShape,o=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)];return"\n    vec4 "+r+"(int index) {\n      vec2 uv = packedUVfrom1D(\n        "+o[0]+", "+o[1]+", index);\n      return texture2D("+t+", uv);\n    }\n  "}function getSampler1D(e){var t=e.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1);return"\n    float "+r+"(int index) {\n      return "+r+"Flat(index);\n    }\n  "}function getPackedSampler2D(e){var t=e.shapeInfo.logicalShape,r=e.name,n="get"+r.charAt(0).toUpperCase()+r.slice(1),o=e.shapeInfo.texShape,a=o[0],i=o[1];if(null!=o&&arraysEqual(t,o))return"\n      vec4 "+n+"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2("+i+".0, "+a+".0);\n\n        return texture2D("+r+", uv);\n      }\n    ";var s=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];return"\n    vec4 "+n+"(int row, int col) {\n      vec2 uv = packedUVfrom2D("+Math.ceil(t[1]/2)+", "+s[0]+", "+s[1]+", row, col);\n      return texture2D("+r+", uv);\n    }\n  "}function getSampler2D(e){var t=e.shapeInfo.logicalShape,r=e.name,n="get"+r.charAt(0).toUpperCase()+r.slice(1),o=e.shapeInfo.texShape;if(null!=o&&arraysEqual(t,o)){var a=o[0];return"\n    float "+n+"(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2("+o[1]+".0, "+a+".0);\n      return sampleTexture("+r+", uv);\n    }\n  "}var i=squeezeShape(t),s=i.newShape,u=i.keptDims,l=s;if(l.length<t.length){return"\n      "+getSamplerFromInInfo(squeezeInputInfo(e,l))+"\n      float "+n+"(int row, int col) {\n        return "+n+"("+getSqueezedParams(["row","col"],u)+");\n      }\n    "}if(e.shapeInfo.isUniform)return"\n      float "+n+"(int row, int col) {\n        float index = dot(vec2(row, col), vec2("+t[1]+", 1));\n        return "+n+"Flat(round(index));\n      }\n    ";var c=o[0],p=o[1];return 1===p?"\n    float "+n+"(int row, int col) {\n      float index = dot(vec2(row, col), vec2("+t[1]+", 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / "+c+".0);\n      return sampleTexture("+r+", uv);\n    }\n  ":1===c?"\n    float "+n+"(int row, int col) {\n      float index = dot(vec2(row, col), vec2("+t[1]+", 1));\n      vec2 uv = vec2((index + 0.5) / "+p+".0, 0.5);\n      return sampleTexture("+r+", uv);\n    }\n  ":"\n  float "+n+"(int row, int col) {\n    vec2 uv = UVfrom2D("+c+", "+p+", "+t[1]+", row, col);\n    return sampleTexture("+r+", uv);\n  }\n"}function getPackedSampler3D(e){var t=e.shapeInfo.logicalShape,r=e.name,n="get"+r.charAt(0).toUpperCase()+r.slice(1),o=e.shapeInfo.texShape,a=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];if(1===t[0]){return"\n        "+getPackedSamplerFromInInfo(squeezeInputInfo(e,t.slice(1)))+"\n        vec4 "+n+"(int b, int row, int col) {\n          return "+n+"("+getSqueezedParams(["b","row","col"],[1,2])+");\n        }\n      "}var i=a[0],s=a[1],u=Math.ceil(t[2]/2);return"\n    vec4 "+n+"(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        "+i+", "+s+", "+u*Math.ceil(t[1]/2)+", "+u+", b, row, col);\n      return texture2D("+r+", uv);\n    }\n  "}function getSampler3D(e){var t=e.shapeInfo.logicalShape,r=e.name,n="get"+r.charAt(0).toUpperCase()+r.slice(1),o=t[1]*t[2],a=t[2],i=squeezeShape(t),s=i.newShape,u=i.keptDims,l=s;if(l.length<t.length){return"\n        "+getSamplerFromInInfo(squeezeInputInfo(e,l))+"\n        float "+n+"(int row, int col, int depth) {\n          return "+n+"("+getSqueezedParams(["row","col","depth"],u)+");\n        }\n      "}if(e.shapeInfo.isUniform)return"\n      float "+n+"(int row, int col, int depth) {\n        float index = dot(vec3(row, col, depth),\n                          vec3("+o+", "+a+", 1));\n        return "+n+"Flat(round(index));\n      }\n    ";var c=e.shapeInfo.texShape,p=c[0],d=c[1];return d===o?"\n        float "+n+"(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2("+a+", 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2("+d+".0, "+p+".0);\n          return sampleTexture("+r+", uv);\n        }\n      ":d===a?"\n    float "+n+"(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2("+t[1]+", 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2("+d+".0, "+p+".0);\n      return sampleTexture("+r+", uv);\n    }\n  ":"\n      float "+n+"(int row, int col, int depth) {\n        vec2 uv = UVfrom3D(\n            "+p+", "+d+", "+o+", "+a+", row, col, depth);\n        return sampleTexture("+r+", uv);\n      }\n  "}function getPackedSampler4D(e){var t=e.shapeInfo.logicalShape,r=e.name,n="get"+r.charAt(0).toUpperCase()+r.slice(1),o=e.shapeInfo.texShape,a=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],i=a[0],s=a[1],u=Math.ceil(t[3]/2),l=u*Math.ceil(t[2]/2);return"\n    vec4 "+n+"(int b2, int b, int row, int col) {\n      vec2 uv = packedUVfrom4D(\n        "+i+", "+s+", "+l*t[1]+",\n        "+l+", "+u+", b2, b, row, col);\n      return texture2D("+r+", uv);\n    }\n  "}function getSampler4D(e){var t=e.shapeInfo.logicalShape,r=e.name,n="get"+r.charAt(0).toUpperCase()+r.slice(1),o=t[3],a=t[2]*o,i=t[1]*a,s=squeezeShape(t),u=s.newShape,l=s.keptDims;if(u.length<t.length){return"\n      "+getSamplerFromInInfo(squeezeInputInfo(e,u))+"\n      float "+n+"(int row, int col, int depth, int depth2) {\n        return "+n+"("+getSqueezedParams(["row","col","depth","depth2"],l)+");\n      }\n    "}if(e.shapeInfo.isUniform)return"\n      float "+n+"(int row, int col, int depth, int depth2) {\n        float index = dot(vec4(row, col, depth, depth2),\n                          vec4("+i+", "+a+", "+o+", 1));\n        return "+n+"Flat(round(index));\n      }\n    ";var c=e.shapeInfo.texShape,p=c[0],d=c[1];return d===i?"\n      float "+n+"(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2), vec3("+a+", "+o+", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2("+d+".0, "+p+".0);\n        return sampleTexture("+r+", uv);\n      }\n    ":d===o?"\n      float "+n+"(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3("+t[1]*t[2]+", "+t[2]+", 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2("+d+".0, "+p+".0);\n        return sampleTexture("+r+", uv);\n      }\n    ":"\n    float "+n+"(int row, int col, int depth, int depth2) {\n      vec2 uv = UVfrom4D("+p+", "+d+", "+i+", "+a+",\n          "+o+", row, col, depth, depth2);\n      return sampleTexture("+r+", uv);\n    }\n  "}function getSampler5D(e){var t=e.shapeInfo.logicalShape,r=e.name,n="get"+r.charAt(0).toUpperCase()+r.slice(1),o=t[4],a=t[3]*o,i=t[2]*a,s=t[1]*i,u=squeezeShape(t),l=u.newShape,c=u.keptDims;if(l.length<t.length){return"\n      "+getSamplerFromInInfo(squeezeInputInfo(e,l))+"\n      float "+n+"(int row, int col, int depth, int depth2, int depth3) {\n        return "+n+"("+getSqueezedParams(["row","col","depth","depth2","depth3"],c)+");\n      }\n    "}if(e.shapeInfo.isUniform)return"\n      float "+n+"(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4("+s+", "+i+", "+a+", "+o+")) +\n          depth3;\n        return "+n+"Flat(index);\n      }\n    ";var p=e.shapeInfo.texShape,d=p[0],h=p[1];return h===s?"\n      float "+n+"(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(\n          vec4(col, depth, depth2, depth3),\n          vec4("+i+", "+a+", "+o+", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2("+h+".0, "+d+".0);\n        return sampleTexture("+r+", uv);\n      }\n    ":h===o?"\n      float "+n+"(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4("+t[1]*t[2]*t[3]+", "+t[2]*t[3]+",\n            "+t[3]+", 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2("+h+".0, "+d+".0);\n        return sampleTexture("+r+", uv);\n      }\n    ":"\n    float "+n+"(int row, int col, int depth, int depth2, int depth3) {\n      vec2 uv = UVfrom5D("+d+", "+h+", "+s+", "+i+",\n          "+a+", "+o+", row, col, depth, depth2, depth3);\n      return sampleTexture("+r+", uv);\n    }\n  "}function getSampler6D(e){var t=e.shapeInfo.logicalShape,r=e.name,n="get"+r.charAt(0).toUpperCase()+r.slice(1),o=t[5],a=t[4]*o,i=t[3]*a,s=t[2]*i,u=t[1]*s,l=squeezeShape(t),c=l.newShape,p=l.keptDims;if(c.length<t.length){return"\n      "+getSamplerFromInInfo(squeezeInputInfo(e,c))+"\n      float "+n+"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return "+n+"("+getSqueezedParams(["row","col","depth","depth2","depth3","depth4"],p)+");\n      }\n    "}if(e.shapeInfo.isUniform)return"\n      float "+n+"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4("+u+", "+s+", "+i+", "+a+")) +\n          dot(\n            vec2(depth3, depth4),\n            vec2("+o+", 1));\n        return "+n+"Flat(index);\n      }\n    ";var d=e.shapeInfo.texShape,h=d[0],f=d[1];return f===u?"\n      float "+n+"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(\n          vec4(col, depth, depth2, depth3),\n          vec4("+s+", "+i+", "+a+", "+o+")) + depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2("+f+".0, "+h+".0);\n        return sampleTexture("+r+", uv);\n      }\n    ":f===o?"\n      float "+n+"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4("+t[1]*t[2]*t[3]*t[4]+",\n               "+t[2]*t[3]*t[4]+",\n               "+t[3]*t[4]+",\n               "+t[4]+")) + depth3;\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2("+f+".0, "+h+".0);\n        return sampleTexture("+r+", uv);\n      }\n    ":"\n    float "+n+"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      vec2 uv = UVfrom6D("+h+", "+f+", "+u+", "+s+",\n          "+i+", "+a+", "+o+"\n          ,row, col, depth, depth2, depth3, depth4);\n      return sampleTexture("+r+", uv);\n    }\n  "}function getSamplerFlat(e){var t=e.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1)+"Flat",n=sizeFromShape(e.shapeInfo.logicalShape);if(e.shapeInfo.isUniform)return 1===n?"float "+r+"(int index) {return "+t+";}":"\n      float "+r+"(int index) {\n        for (int i = 0; i < "+n+"; i++) {\n          if (i == index) {\n            return "+t+"[i];\n          }\n        }\n      }\n    ";var o=e.shapeInfo.texShape,a=o[0],i=o[1];return 1===i&&1===a?"\n      float "+r+"(int index) {\n        return sampleTexture("+t+", halfCR);\n      }\n    ":1===i?"\n      float "+r+"(int index) {\n        vec2 uv = vec2(0.5, (float(index) + 0.5) / "+a+".0);\n        return sampleTexture("+t+", uv);\n      }\n    ":1===a?"\n      float "+r+"(int index) {\n        vec2 uv = vec2((float(index) + 0.5) / "+i+".0, 0.5);\n        return sampleTexture("+t+", uv);\n      }\n    ":"\n    float "+r+"(int index) {\n      vec2 uv = UVfrom1D("+a+", "+i+", index);\n      return sampleTexture("+t+", uv);\n    }\n  "}function getBroadcastOutputCoordsSampler(e,t,r,n){var o=e.shapeInfo.logicalShape.length,a=t.logicalShape.length,i="int";2===a?i="ivec2":3===a?i="ivec3":4===a&&(i="ivec4");var s=getBroadcastDims(e.shapeInfo.logicalShape,t.logicalShape),u=a-o;return"\n    float "+n+"() {\n      "+i+" coords = getOutputCoords();\n      "+(0===o?"":a<2&&s.length>=1?"coords = 0;":s.map(function(e){return"coords["+(e+u)+"] = 0;"}).join("\n"))+"\n      return get"+r+"("+(a<2&&o>0?"coords":e.shapeInfo.logicalShape.map(function(e,t){return"coords["+(t+u)+"]"}).join(", "))+");\n    }\n  "}function getSamplerAtOutputCoords(e,t,r){var n=e.name,o=n.charAt(0).toUpperCase()+n.slice(1),a="get"+o+"AtOutCoords",i=getBroadcastDims(e.shapeInfo.logicalShape,t.logicalShape),s=e.shapeInfo.logicalShape.length,u=t.logicalShape.length,l=r&&(u>s||i.length>0),c=broadcastDimsAreOuter(i),p=e.shapeInfo.isUniform;if(l&&!c)return getBroadcastOutputCoordsSampler(e,t,o,a);var d=sizeFromShape(e.shapeInfo.logicalShape),h="";l&&c&&(h="\n        int mainPart = index / "+d+";\n        index -= mainPart * "+d+";\n      ");var f=t.texShape;if(p)return 1===d?"float "+a+"() {return "+n+";}":"\n      float "+a+"() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                              vec2("+f[0]+", "+f[1]+"));\n        int index = resTexRC.x * "+f[1]+" + resTexRC.y;\n        "+h+"\n        return get"+o+"Flat(index);\n      }\n    ";var m=e.shapeInfo.texShape;return arraysEqual(m,f)?"\n      float "+a+"() {\n        return sampleTexture("+n+", resultUV);\n      }\n    ":"\n    float "+a+"() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+f[0]+", "+f[1]+"));\n      int index = resTexRC.x * "+f[1]+" + resTexRC.y;\n      "+h+"\n      int texR = index / "+m[1]+";\n      int texC = index - texR * "+m[1]+";\n      vec2 uv = (vec2(texC, texR) + halfCR) /\n                 vec2("+m[1]+".0, "+m[0]+".0);\n\n      return sampleTexture("+n+", uv);\n    }\n  "}function getCoordsDataType(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error("GPU for rank "+e+" is not yet supported")}function squeezeInputInfo(e,t){var r=JSON.parse(JSON.stringify(e));return r.shapeInfo.logicalShape=t,r}function getSqueezedParams(e,t){return t.map(function(t){return e[t]}).join(", ")}var CumSumProgram=function(){return function(e,t,r){this.variableNames=["x"],this.outputShape=e;var n=e.length,o=e[e.length-1],a=r?"<":">";this.userCode="\n      int getIndex(int i) {\n        "+(r?"return "+o+" -i - 1;":"return i;")+"\n      }\n\n      void main() {\n        "+getCoordsDataType(n)+" coords = getOutputCoords();\n        int end = "+getFinalCoord(n,"coords")+";\n        float val = 0.0;\n        for (int i = "+o+" - 1; i >= 0; i -= 1) {\n          int idx = getIndex(i);\n          if (idx "+a+" end) {\n            continue;\n          }\n          if (idx == end && "+t+") {\n            continue;\n          }\n          "+getFinalCoord(n,"coords")+" = idx;\n          val += getX("+getCoords(n,"coords")+");\n        }\n        setOutput(val);\n      }\n    "}}();function getCoords(e,t){if(1===e)return""+t;if(2===e)return t+".x, "+t+".y";if(3===e)return t+".x, "+t+".y, "+t+".z";if(4===e)return t+".x, "+t+".y, "+t+".z, "+t+".w";throw Error("Cumulative sum for rank "+e+" is not yet supported")}function getFinalCoord(e,t){if(1===e)return""+t;if(2===e)return t+".y";if(3===e)return t+".z";if(4===e)return t+".w";throw Error("Cumulative sum for rank "+e+" is not yet supported")}var DepthToSpaceProgram=function(){function e(e,t,r){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=r,this.userCode="\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = "+this.getHeightCoordString()+";\n      int w = "+this.getWidthCoordString()+";\n      int d = "+this.getDepthCoordString()+";\n\n      int in_h = h / "+t+";\n      int offset_h = imod(h, "+t+");\n      int in_w = w / "+t+";\n      int offset_w = imod(w, "+t+");\n      int offset_d = (offset_h * "+t+" + offset_w) *\n        "+this.getOutputDepthSize()+";\n      int in_d = d + offset_d;\n\n      float result = "+this.getInputSamplingString()+";\n      setOutput(result);\n    }\n  "}return e.prototype.getHeightCoordString=function(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"},e.prototype.getWidthCoordString=function(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"},e.prototype.getDepthCoordString=function(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"},e.prototype.getOutputDepthSize=function(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]},e.prototype.getInputSamplingString=function(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"},e}(),EncodeFloatProgram=function(){return function(e){this.variableNames=["A"],this.outputShape=e,this.userCode="\n      const float FLOAT_MAX = 1.70141184e38;\n      const float FLOAT_MIN = 1.17549435e-38;\n\n      lowp vec4 encode_float(highp float v) {\n        if (isNaN(v)) {\n          return vec4(255, 255, 255, 255);\n        }\n\n        highp float av = abs(v);\n\n        if(av < FLOAT_MIN) {\n          return vec4(0.0, 0.0, 0.0, 0.0);\n        } else if(v > FLOAT_MAX) {\n          return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n        } else if(v < -FLOAT_MAX) {\n          return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n        }\n\n        highp vec4 c = vec4(0,0,0,0);\n\n        highp float e = floor(log2(av));\n        highp float m = exp2(fract(log2(av))) - 1.0;\n\n        c[2] = floor(128.0 * m);\n        m -= c[2] / 128.0;\n        c[1] = floor(32768.0 * m);\n        m -= c[1] / 32768.0;\n        c[0] = floor(8388608.0 * m);\n\n        highp float ebias = e + 127.0;\n        c[3] = floor(ebias / 2.0);\n        ebias -= c[3] * 2.0;\n        c[2] += floor(ebias) * 128.0;\n\n        c[3] += 128.0 * step(0.0, -v);\n\n        return c / 255.0;\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        gl_FragColor = encode_float(x);\n      }\n    "}}(),COMPLEX_FFT={REAL:"return real * expR - imag * expI;",IMAG:"return real * expI + imag * expR;"},FFTProgram=function(){return function(e,t,r){this.variableNames=["real","imag"];var n=t[1];this.outputShape=t;var o=r?"2.0 * "+Math.PI:"-2.0 * "+Math.PI,a=r?n+".0":"1.0";this.userCode="\n      const float exponentMultiplier = "+o+";\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        "+e+"\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float("+n+");\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < "+n+"; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / "+a+";\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    "}}(),FromPixelsProgram=function(){return function(e){this.variableNames=["A"];var t=e[0],r=e[1];this.outputShape=e,this.userCode="\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2("+r+".0, "+t+".0);\n\n        vec4 values = texture2D(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    "}}(),GatherProgram=function(){return function(e,t,r){this.variableNames=["A","indices"];var n=e.slice();n[r]=t,this.outputShape=n,this.rank=n.length;var o=getCoordsDataType(this.rank),a=getSourceCoords(e,r);this.userCode="\n      void main() {\n        "+o+" resRC = getOutputCoords();\n        setOutput(getA("+a+"));\n      }\n    "}}();function getSourceCoords(e,t){var r=e.length;if(r>4)throw Error("Gather for rank "+r+" is not yet supported");if(1===r)return"int(getIndices(resRC))";for(var n=["resRC.x","resRC.y","resRC.z","resRC.w"],o=[],a=0;a<e.length;a++)a===t?o.push("int(getIndices("+n[a]+"))"):o.push(""+n[a]);return o.join()}var TextureUsage,PhysicalTextureType,GatherNDProgram=function(){return function(e,t,r){this.sliceDim=e,this.strides=t,this.variableNames=["x","indices"],this.outputShape=r;var n=getCoordsDataType(t.length),o=getCoordsDataType(r.length),a=this.sliceDim>1?"strides[j]":"strides";this.userCode="\n        "+n+" strides = "+n+"("+this.strides+");\n         void main() {\n          "+o+" coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < "+this.sliceDim+"; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * "+a+";\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      "}}();function getUnpackedMatrixTextureShapeWidthHeight(e,t){return[t,e]}function getUnpackedArraySizeFromMatrixSize(e,t){return e*t}function getMatrixSizeFromUnpackedArraySize(e,t){if(e%t!=0)throw new Error("unpackedSize ("+e+") must be a multiple of "+t);return e/t}function encodeMatrixToUnpackedArray(e,t,r){var n=getUnpackedArraySizeFromMatrixSize(e.length,r);if(t.length<n)throw new Error("unpackedArray length ("+t.length+") must be >= "+n);for(var o=0,a=0;a<e.length;++a)t[o]=e[a],o+=r}function decodeMatrixFromUnpackedArray(e,t,r){var n=getMatrixSizeFromUnpackedArraySize(e.length,r);if(t.length<n)throw new Error("matrix length ("+t.length+") must be >= "+n);for(var o=0,a=0;a<e.length;a+=r)t[o++]=e[a]}function getPackedMatrixTextureShapeWidthHeight(e,t){return[Math.ceil(t/2),Math.ceil(e/2)]}function getPackedRGBAArraySizeFromMatrixShape(e,t){var r=getPackedMatrixTextureShapeWidthHeight(e,t);return r[0]*r[1]*4}function encodeMatrixToPackedRGBA(e,t,r,n,o){var a=getPackedRGBAArraySizeFromMatrixShape(r,n);if(o.length<a)throw new Error("packedRGBA length ("+o.length+") must be >=\n        "+a);for(var i=n%2==1,s=r%2==1,u=Math.floor(n/2),l=Math.floor(r/2),c=Math.ceil(n/2),p=c*Math.ceil(r/2),d=nearestLargerEven(r)*nearestLargerEven(n),h=0;h<t;h++){for(var f=h*r*n,m=h*d,g=i?4:0,v=n,y=m,x=0;x<l;++x){for(var T=2*x*n,E=0;E<u;++E){var w=f+T+2*E;o[y]=e[w],o[y+1]=e[w+1],o[y+2]=e[w+v],o[y+3]=e[w+v+1],y+=4}y+=g}if(i){w=f+n-1,y=m+4*(c-1);var S=2*n;for(g=4*c,x=0;x<l;++x)o[y]=e[w],o[y+2]=e[w+n],w+=S,y+=g}if(s){for(w=f+(r-1)*n,y=m+4*(p-c),E=0;E<u;++E)o[y++]=e[w++],o[y++]=e[w++],y+=2;i&&s&&(o[m+d-4]=e[w])}}return o}function decodeMatrixFromPackedRGBA(e,t,r,n,o){var a=r*n;if(o.length<a)throw new Error("matrix length ("+o.length+") must be >= "+a);for(var i=n%2==1,s=r%2==1,u=Math.floor(n/2),l=Math.floor(r/2),c=Math.ceil(n/2),p=c*Math.ceil(r/2),d=nearestLargerEven(r)*nearestLargerEven(n),h=0;h<t;h++){for(var f=h*r*n,m=h*d,g=i?4:0,v=n+(i?1:0),y=m,x=f,T=f+n,E=0;E<l;++E){for(var w=0;w<u;++w)o[x++]=e[y++],o[x++]=e[y++],o[T++]=e[y++],o[T++]=e[y++];y+=g,x+=v,T+=v}if(i){y=m+4*(c-1);var S=f+n-1;for(g=4*c,v=2*n,E=0;E<l;++E)o[S]=e[y],o[S+n]=e[y+2],y+=g,S+=v}if(s){for(y=m+4*(p-c),S=f+(r-1)*n,w=0;w<u;++w)o[S++]=e[y++],o[S++]=e[y++],y+=2;i&&(o[f+r*n-1]=e[y])}}return o}function callAndCheck(e,t){var r=t();return checkWebGLError(e),r}!function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(TextureUsage||(TextureUsage={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(PhysicalTextureType||(PhysicalTextureType={}));var webGLDebugErrorCheckingEnabled=!1;function enableDebugWebGLErrorChecking(e){webGLDebugErrorCheckingEnabled=e}function checkWebGLError(e){if(webGLDebugErrorCheckingEnabled){var t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+getWebGLErrorMessage(e,t))}}function getWebGLErrorMessage(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return"Unknown error code "+t}}function getExtensionOrThrow(e,t){return throwIfNull(e,function(){return e.getExtension(t)},'Extension "'+t+'" not supported on this browser.')}function createVertexShader(e,t){var r=throwIfNull(e,function(){return e.createShader(e.VERTEX_SHADER)},"Unable to create vertex WebGLShader.");if(callAndCheck(e,function(){return e.shaderSource(r,t)}),callAndCheck(e,function(){return e.compileShader(r)}),!1===e.getShaderParameter(r,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(r)),new Error("Failed to compile vertex shader.");return r}function createFragmentShader(e,t){var r=throwIfNull(e,function(){return e.createShader(e.FRAGMENT_SHADER)},"Unable to create fragment WebGLShader.");if(callAndCheck(e,function(){return e.shaderSource(r,t)}),callAndCheck(e,function(){return e.compileShader(r)}),!1===e.getShaderParameter(r,e.COMPILE_STATUS))throw logShaderSourceAndInfoLog(t,e.getShaderInfoLog(r)),new Error("Failed to compile fragment shader.");return r}var lineNumberRegex=/ERROR: [0-9]+:([0-9]+):/g;function logShaderSourceAndInfoLog(e,t){var r=lineNumberRegex.exec(t);if(null==r)return console.log("Couldn't parse line number in error: "+t),void console.log(e);for(var n=+r[1],o=e.split("\n"),a=o.length.toString().length+2,i=o.map(function(e,t){return rightPad((t+1).toString(),a)+e}),s=0,u=0;u<i.length;u++)s=Math.max(i[u].length,s);var l=i.slice(0,n-1),c=i.slice(n-1,n),p=i.slice(n);console.log(l.join("\n")),console.log(t.split("\n")[0]),console.log("%c "+rightPad(c[0],s),"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(p.join("\n"))}function createProgram(e){return throwIfNull(e,function(){return e.createProgram()},"Unable to create WebGLProgram.")}function linkProgram(e,t){if(callAndCheck(e,function(){return e.linkProgram(t)}),!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function validateProgram(e,t){if(callAndCheck(e,function(){return e.validateProgram(t)}),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function createStaticVertexBuffer(e,t){var r=throwIfNull(e,function(){return e.createBuffer()},"Unable to create WebGLBuffer");return callAndCheck(e,function(){return e.bindBuffer(e.ARRAY_BUFFER,r)}),callAndCheck(e,function(){return e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW)}),r}function createStaticIndexBuffer(e,t){var r=throwIfNull(e,function(){return e.createBuffer()},"Unable to create WebGLBuffer");return callAndCheck(e,function(){return e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,r)}),callAndCheck(e,function(){return e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW)}),r}function getNumChannels(){return 2===ENV.get("WEBGL_VERSION")?1:4}function createTexture(e){return throwIfNull(e,function(){return e.createTexture()},"Unable to create WebGLTexture.")}function validateTextureSize(e,t){var r=ENV.get("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0){var n="["+e+"x"+t+"]";throw new Error("Requested texture size "+n+" is invalid.")}if(e>r||t>r){n="["+e+"x"+t+"]";throw new Error("Requested texture size "+n+" greater than WebGL maximum on this browser / GPU "+("["+r+"x"+r+"]")+".")}}function createFramebuffer(e){return throwIfNull(e,function(){return e.createFramebuffer()},"Unable to create WebGLFramebuffer.")}function bindVertexBufferToProgramAttribute(e,t,r,n,o,a,i){var s=e.getAttribLocation(t,r);return-1!==s&&(callAndCheck(e,function(){return e.bindBuffer(e.ARRAY_BUFFER,n)}),callAndCheck(e,function(){return e.vertexAttribPointer(s,o,e.FLOAT,!1,a,i)}),callAndCheck(e,function(){return e.enableVertexAttribArray(s)}),!0)}function bindTextureUnit(e,t,r){validateTextureUnit(e,r),callAndCheck(e,function(){return e.activeTexture(e.TEXTURE0+r)}),callAndCheck(e,function(){return e.bindTexture(e.TEXTURE_2D,t)})}function unbindTextureUnit(e,t){validateTextureUnit(e,t),callAndCheck(e,function(){return e.activeTexture(e.TEXTURE0+t)}),callAndCheck(e,function(){return e.bindTexture(e.TEXTURE_2D,null)})}function getProgramUniformLocationOrThrow(e,t,r){return throwIfNull(e,function(){return e.getUniformLocation(t,r)},'uniform "'+r+'" not present in program.')}function getProgramUniformLocation(e,t,r){return e.getUniformLocation(t,r)}function bindTextureToProgramUniformSampler(e,t,r,n,o){callAndCheck(e,function(){return bindTextureUnit(e,r,o)}),callAndCheck(e,function(){return e.uniform1i(n,o)})}function bindCanvasToFramebuffer(e){callAndCheck(e,function(){return e.bindFramebuffer(e.FRAMEBUFFER,null)}),callAndCheck(e,function(){return e.viewport(0,0,e.canvas.width,e.canvas.height)}),callAndCheck(e,function(){return e.scissor(0,0,e.canvas.width,e.canvas.height)})}function bindColorTextureToFramebuffer(e,t,r){callAndCheck(e,function(){return e.bindFramebuffer(e.FRAMEBUFFER,r)}),callAndCheck(e,function(){return e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0)})}function unbindColorTextureFromFramebuffer(e,t){callAndCheck(e,function(){return e.bindFramebuffer(e.FRAMEBUFFER,t)}),callAndCheck(e,function(){return e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0)})}function validateFramebuffer(e){var t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+getFramebufferErrorMessage(e,t))}function getFramebufferErrorMessage(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return"unknown error "+t}}function throwIfNull(e,t,r){var n=callAndCheck(e,function(){return t()});if(null==n)throw new Error(r);return n}function validateTextureUnit(e,t){var r=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,n=t+e.TEXTURE0;if(n<e.TEXTURE0||n>r)throw new Error("textureUnit must be in "+("[gl.TEXTURE0, gl.TEXTURE"+r+"]")+".")}function getTextureShapeFromLogicalShape(e,t){void 0===t&&(t=!1);var r=ENV.get("WEBGL_MAX_TEXTURE_SIZE");if(t&&(r*=2,e=e.map(function(t,r){return r>=e.length-2?nearestLargerEven(e[r]):e[r]})),2!==e.length){var n=squeezeShape(e);e=n.newShape}var o=sizeFromShape(e);return e.length<=1&&o<=r?[o,1]:2===e.length&&e[0]<=r&&e[1]<=r?e:3===e.length&&e[0]*e[1]<=r&&e[2]<=r?[e[0]*e[1],e[2]]:3===e.length&&e[0]<=r&&e[1]*e[2]<=r?[e[0],e[1]*e[2]]:4===e.length&&e[0]*e[1]*e[2]<=r&&e[3]<=r?[e[0]*e[1]*e[2],e[3]]:4===e.length&&e[0]<=r&&e[1]*e[2]*e[3]<=r?[e[0],e[1]*e[2]*e[3]]:sizeToSquarishShape(o)}function isEven(e){return e%2==0}function isReshapeFree(e,t){if(arraysEqual(e=e.slice(-2),t=t.slice(-2)))return!0;if(!e.length||!t.length)return!0;if(0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){if(arraysEqual(squeezeShape(e).newShape,squeezeShape(t).newShape))return!0}else if(isEven(e[0])&&isEven(t[0])){if(isEven(e[1])&&isEven(t[1]))return!0;if(e[1]===t[1])return!0}return!1}var webgl_util=Object.freeze({callAndCheck:callAndCheck,enableDebugWebGLErrorChecking:enableDebugWebGLErrorChecking,checkWebGLError:checkWebGLError,getWebGLErrorMessage:getWebGLErrorMessage,getExtensionOrThrow:getExtensionOrThrow,createVertexShader:createVertexShader,createFragmentShader:createFragmentShader,createProgram:createProgram,linkProgram:linkProgram,validateProgram:validateProgram,createStaticVertexBuffer:createStaticVertexBuffer,createStaticIndexBuffer:createStaticIndexBuffer,getNumChannels:getNumChannels,createTexture:createTexture,validateTextureSize:validateTextureSize,createFramebuffer:createFramebuffer,bindVertexBufferToProgramAttribute:bindVertexBufferToProgramAttribute,bindTextureUnit:bindTextureUnit,unbindTextureUnit:unbindTextureUnit,getProgramUniformLocationOrThrow:getProgramUniformLocationOrThrow,getProgramUniformLocation:getProgramUniformLocation,bindTextureToProgramUniformSampler:bindTextureToProgramUniformSampler,bindCanvasToFramebuffer:bindCanvasToFramebuffer,bindColorTextureToFramebuffer:bindColorTextureToFramebuffer,unbindColorTextureFromFramebuffer:unbindColorTextureFromFramebuffer,validateFramebuffer:validateFramebuffer,getFramebufferErrorMessage:getFramebufferErrorMessage,getTextureShapeFromLogicalShape:getTextureShapeFromLogicalShape,isReshapeFree:isReshapeFree});function createVertexShader$1(e){return createVertexShader(e,"\n    precision highp float;\n    attribute vec3 clipSpacePos;\n    attribute vec2 uv;\n    varying vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }")}function createVertexBuffer(e){return createStaticVertexBuffer(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function createIndexBuffer(e){return createStaticIndexBuffer(e,new Uint16Array([0,1,2,2,1,3]))}function getTextureConfig(e,t){var r,n,o,a,i,s,u,l=e;return 2===ENV.get("WEBGL_VERSION")?(r=l.R32F,n=l.R16F,o=l.RGBA32F,a=l.RED,i=4,s=1,u=l.HALF_FLOAT):(r=e.RGBA,n=e.RGBA,o=l.RGBA,a=e.RGBA,i=4,s=4,u=null!=t?t.HALF_FLOAT_OES:null),{internalFormatFloat:r,internalFormatHalfFloat:n,internalFormatPackedFloat:o,textureFormatFloat:a,downloadTextureFormat:e.RGBA,downloadUnpackNumChannels:i,defaultNumChannels:s,textureTypeHalfFloat:u}}function createAndConfigureTexture(e,t,r,n,o,a){validateTextureSize(t,r);var i=createTexture(e),s=e.TEXTURE_2D;return callAndCheck(e,function(){return e.bindTexture(s,i)}),callAndCheck(e,function(){return e.texParameteri(s,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE)}),callAndCheck(e,function(){return e.texParameteri(s,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE)}),callAndCheck(e,function(){return e.texParameteri(s,e.TEXTURE_MIN_FILTER,e.NEAREST)}),callAndCheck(e,function(){return e.texParameteri(s,e.TEXTURE_MAG_FILTER,e.NEAREST)}),callAndCheck(e,function(){return e.texImage2D(s,0,n,t,r,0,o,a,null)}),callAndCheck(e,function(){return e.bindTexture(e.TEXTURE_2D,null)}),i}function createFloat32MatrixTexture(e,t,r,n){var o=getUnpackedMatrixTextureShapeWidthHeight(t,r);return createAndConfigureTexture(e,o[0],o[1],n.internalFormatFloat,n.textureFormatFloat,e.FLOAT)}function createFloat16MatrixTexture(e,t,r,n){var o=getUnpackedMatrixTextureShapeWidthHeight(t,r);return createAndConfigureTexture(e,o[0],o[1],n.internalFormatFloat,n.textureFormatFloat,n.textureTypeHalfFloat)}function createUnsignedBytesMatrixTexture(e,t,r,n){var o=getUnpackedMatrixTextureShapeWidthHeight(t,r);return createAndConfigureTexture(e,o[0],o[1],e.RGBA,e.RGBA,e.UNSIGNED_BYTE)}function createPackedMatrixTexture(e,t,r,n){var o=getPackedMatrixTextureShapeWidthHeight(t,r);return createAndConfigureTexture(e,o[0],o[1],n.internalFormatPackedFloat,e.RGBA,e.FLOAT)}function createFloat16PackedMatrixTexture(e,t,r,n){var o=getPackedMatrixTextureShapeWidthHeight(t,r);return createAndConfigureTexture(e,o[0],o[1],n.internalFormatHalfFloat,e.RGBA,n.textureTypeHalfFloat)}function bindVertexProgramAttributeStreams(e,t,r){return callAndCheck(e,function(){return e.bindBuffer(e.ARRAY_BUFFER,r)}),bindVertexBufferToProgramAttribute(e,t,"clipSpacePos",r,3,20,0)&&bindVertexBufferToProgramAttribute(e,t,"uv",r,2,20,12)}function uploadPixelDataToTexture(e,t,r){callAndCheck(e,function(){return e.bindTexture(e.TEXTURE_2D,t)}),callAndCheck(e,function(){return e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,r)}),callAndCheck(e,function(){return e.bindTexture(e.TEXTURE_2D,null)})}function uploadDataToTexture(e,t,r,n,o,a){validateTextureSize(r,n),callAndCheck(e,function(){return e.bindTexture(e.TEXTURE_2D,t)}),callAndCheck(e,function(){return e.texSubImage2D(e.TEXTURE_2D,0,0,0,r,n,a,e.FLOAT,o)}),callAndCheck(e,function(){return e.bindTexture(e.TEXTURE_2D,null)})}function uploadMatrixToTexture(e,t,r,n,o,a,i){var s,u=getUnpackedMatrixTextureShapeWidthHeight(r,n),l=u[0],c=u[1];1===i.defaultNumChannels?s=o:encodeMatrixToUnpackedArray(o,s=new Float32Array(getUnpackedArraySizeFromMatrixSize(o.length,a)),a),uploadDataToTexture(e,t,l,c,s,i.textureFormatFloat)}function uploadMatrixToPackedTexture(e,t,r,n,o,a,i){var s=getPackedMatrixTextureShapeWidthHeight(n,o),u=s[0],l=s[1],c=new Float32Array(getPackedRGBAArraySizeFromMatrixShape(n,o));encodeMatrixToPackedRGBA(a,r,n,o,c),uploadDataToTexture(e,t,u,l,c,e.RGBA)}function maybeCreateBufferFromOutputTexture(e,t,r,n,o){var a=t;if(2===ENV.get("WEBGL_VERSION")){var i=e,s=i.createBuffer();callAndCheck(e,function(){return e.bindBuffer(i.PIXEL_PACK_BUFFER,s)});var u=4*getUnpackedArraySizeFromMatrixSize(r*n,o.downloadUnpackNumChannels);callAndCheck(e,function(){return e.bufferData(i.PIXEL_PACK_BUFFER,u,e.STATIC_DRAW)}),callAndCheck(e,function(){return i.readPixels(0,0,n,r,e.RGBA,e.FLOAT,0)}),callAndCheck(e,function(){return e.bindBuffer(i.PIXEL_PACK_BUFFER,null)}),a=s}return a}function downloadFloat32MatrixFromBuffer(e,t,r,n,o){var a=e,i=new Float32Array(getUnpackedArraySizeFromMatrixSize(r*n,o.downloadUnpackNumChannels));a.bindBuffer(e.ARRAY_BUFFER,t),a.getBufferSubData(e.ARRAY_BUFFER,0,i),a.bindBuffer(e.ARRAY_BUFFER,null);var s=new Float32Array(r*n);return decodeMatrixFromUnpackedArray(i,s,o.downloadUnpackNumChannels),s}function downloadFloat32MatrixFromOutputTexture(e,t,r,n){var o=getUnpackedMatrixTextureShapeWidthHeight(t,r),a=o[0],i=o[1],s=new Float32Array(getUnpackedArraySizeFromMatrixSize(t*r,n.downloadUnpackNumChannels));callAndCheck(e,function(){return e.readPixels(0,0,a,i,n.downloadTextureFormat,e.FLOAT,s)});var u=new Float32Array(t*r);return decodeMatrixFromUnpackedArray(s,u,n.downloadUnpackNumChannels),u}function downloadByteEncodedFloatMatrixFromOutputTexture(e,t,r,n){var o=getUnpackedMatrixTextureShapeWidthHeight(t,r),a=o[0],i=o[1],s=new Uint8Array(getUnpackedArraySizeFromMatrixSize(t*r,4));return callAndCheck(e,function(){return e.readPixels(0,0,a,i,n.downloadTextureFormat,e.UNSIGNED_BYTE,s)}),new Float32Array(s.buffer)}function downloadMatrixFromPackedOutputTexture(e,t,r,n,o,a,i){var s=getPackedMatrixTextureShapeWidthHeight(o,a),u=s[0],l=s[1],c=new Float32Array(getPackedRGBAArraySizeFromMatrixShape(o,a));callAndCheck(e,function(){return e.readPixels(0,0,u,l,e.RGBA,e.FLOAT,c)});var p=new Float32Array(sizeFromShape([t,r,n]));return decodeMatrixFromPackedRGBA(c,t,r,n,p)}var gpgpu_util=Object.freeze({createVertexShader:createVertexShader$1,createVertexBuffer:createVertexBuffer,createIndexBuffer:createIndexBuffer,getTextureConfig:getTextureConfig,createFloat32MatrixTexture:createFloat32MatrixTexture,createFloat16MatrixTexture:createFloat16MatrixTexture,createUnsignedBytesMatrixTexture:createUnsignedBytesMatrixTexture,createPackedMatrixTexture:createPackedMatrixTexture,createFloat16PackedMatrixTexture:createFloat16PackedMatrixTexture,bindVertexProgramAttributeStreams:bindVertexProgramAttributeStreams,uploadPixelDataToTexture:uploadPixelDataToTexture,uploadMatrixToTexture:uploadMatrixToTexture,uploadMatrixToPackedTexture:uploadMatrixToPackedTexture,maybeCreateBufferFromOutputTexture:maybeCreateBufferFromOutputTexture,downloadFloat32MatrixFromBuffer:downloadFloat32MatrixFromBuffer,downloadFloat32MatrixFromOutputTexture:downloadFloat32MatrixFromOutputTexture,downloadByteEncodedFloatMatrixFromOutputTexture:downloadByteEncodedFloatMatrixFromOutputTexture,downloadMatrixFromPackedOutputTexture:downloadMatrixFromPackedOutputTexture}),GPGPUContext=function(){function e(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.autoDebugValidate=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[],this.gl=null!=e?e:getWebGLContext(ENV.get("WEBGL_VERSION")),1===ENV.get("WEBGL_VERSION")?(this.textureFloatExtension=getExtensionOrThrow(this.gl,"OES_texture_float"),this.colorBufferFloatExtension=this.gl.getExtension("WEBGL_color_buffer_float"),ENV.get("WEBGL_RENDER_FLOAT32_ENABLED")||(this.textureHalfFloatExtension=getExtensionOrThrow(this.gl,"OES_texture_half_float"),this.colorBufferHalfFloatExtension=this.gl.getExtension("EXT_color_buffer_half_float"))):this.colorBufferFloatExtension=getExtensionOrThrow(this.gl,"EXT_color_buffer_float"),this.vertexBuffer=createVertexBuffer(this.gl),this.indexBuffer=createIndexBuffer(this.gl),this.framebuffer=createFramebuffer(this.gl),this.textureConfig=getTextureConfig(this.gl,this.textureHalfFloatExtension)}return e.prototype.dispose=function(){var e=this;if(!this.disposed){null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");var t=this.gl;callAndCheck(t,function(){return t.finish()}),callAndCheck(t,function(){return t.bindFramebuffer(t.FRAMEBUFFER,null)}),callAndCheck(t,function(){return t.deleteFramebuffer(e.framebuffer)}),callAndCheck(t,function(){return t.bindBuffer(t.ARRAY_BUFFER,null)}),callAndCheck(t,function(){return t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)}),callAndCheck(t,function(){return t.deleteBuffer(e.indexBuffer)}),this.disposed=!0}},e.prototype.enableAutomaticDebugValidation=function(e){this.autoDebugValidate=e,enableDebugWebGLErrorChecking(e)},e.prototype.createFloat32MatrixTexture=function(e,t){return this.throwIfDisposed(),createFloat32MatrixTexture(this.gl,e,t,this.textureConfig)},e.prototype.createFloat16MatrixTexture=function(e,t){return this.throwIfDisposed(),createFloat16MatrixTexture(this.gl,e,t,this.textureConfig)},e.prototype.createUnsignedBytesMatrixTexture=function(e,t){return this.throwIfDisposed(),createUnsignedBytesMatrixTexture(this.gl,e,t,this.textureConfig)},e.prototype.uploadPixelDataToTexture=function(e,t){this.throwIfDisposed(),uploadPixelDataToTexture(this.gl,e,t)},e.prototype.createFloat16PackedMatrixTexture=function(e,t){return this.throwIfDisposed(),createFloat16PackedMatrixTexture(this.gl,e,t,this.textureConfig)},e.prototype.createPackedMatrixTexture=function(e,t){return this.throwIfDisposed(),createPackedMatrixTexture(this.gl,e,t,this.textureConfig)},e.prototype.deleteMatrixTexture=function(e){var t=this;this.throwIfDisposed(),this.outputTexture===e&&(unbindColorTextureFromFramebuffer(this.gl,this.framebuffer),this.outputTexture=null),callAndCheck(this.gl,function(){return t.gl.deleteTexture(e)})},e.prototype.uploadMatrixToTexture=function(e,t,r,n){this.throwIfDisposed();var o=getNumChannels();return uploadMatrixToTexture(this.gl,e,t,r,n,o,this.textureConfig)},e.prototype.uploadMatrixToPackedTexture=function(e,t,r,n,o){return this.throwIfDisposed(),uploadMatrixToPackedTexture(this.gl,e,t,r,n,o,this.textureConfig)},e.prototype.downloadFloat32MatrixFromOutputTexture=function(e,t,r){var n=this;return this.downloadMatrixDriver(e,function(){return downloadFloat32MatrixFromOutputTexture(n.gl,t,r,n.textureConfig)})},e.prototype.downloadByteEncodedFloatMatrixFromOutputTexture=function(e,t,r){var n=this;return this.downloadMatrixDriver(e,function(){return downloadByteEncodedFloatMatrixFromOutputTexture(n.gl,t,r,n.textureConfig)})},e.prototype.downloadFloat32MatrixFromBuffer=function(e,t,r){return downloadFloat32MatrixFromBuffer(this.gl,e,t,r,this.textureConfig)},e.prototype.maybeCreateBufferFromTexture=function(e,t,r){this.bindTextureToFrameBuffer(e);var n=maybeCreateBufferFromOutputTexture(this.gl,e,t,r,this.textureConfig);return this.unbindTextureToFrameBuffer(),n},e.prototype.createAndWaitForFence=function(){var e=this.createFence(this.gl);return this.pollFence(e)},e.prototype.createFence=function(e){var t,r,n=this;if(ENV.get("WEBGL_FENCE_API_ENABLED")){var o=e,a=o.fenceSync(o.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),r=function(){var e=o.clientWaitSync(a,0,0);return e===o.ALREADY_SIGNALED||e===o.CONDITION_SATISFIED},t=a}else ENV.get("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),r=function(){return n.isQueryAvailable(t,ENV.get("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}):r=function(){return!0};return{query:t,isFencePassed:r}},e.prototype.downloadMatrixFromPackedTexture=function(e,t,r,n,o,a){var i=this;return this.downloadMatrixDriver(e,function(){return downloadMatrixFromPackedOutputTexture(i.gl,t,r,n,o,a,i.textureConfig)})},e.prototype.createProgram=function(e){this.throwIfDisposed();var t=this.gl,r=createFragmentShader(t,e),n=createVertexShader$1(t),o=createProgram(t);return callAndCheck(t,function(){return t.attachShader(o,n)}),callAndCheck(t,function(){return t.attachShader(o,r)}),linkProgram(t,o),this.autoDebugValidate&&validateProgram(t,o),this.vertexAttrsAreBound||(this.setProgram(o),this.vertexAttrsAreBound=bindVertexProgramAttributeStreams(t,this.program,this.vertexBuffer)),o},e.prototype.deleteProgram=function(e){var t=this;this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&callAndCheck(this.gl,function(){return t.gl.deleteProgram(e)})},e.prototype.setProgram=function(e){var t=this;this.throwIfDisposed(),this.program=e,null!=this.program&&this.autoDebugValidate&&validateProgram(this.gl,this.program),callAndCheck(this.gl,function(){return t.gl.useProgram(e)})},e.prototype.getUniformLocation=function(e,t,r){return void 0===r&&(r=!0),this.throwIfDisposed(),r?getProgramUniformLocationOrThrow(this.gl,e,t):getProgramUniformLocation(this.gl,e,t)},e.prototype.getAttributeLocation=function(e,t){var r=this;return this.throwIfDisposed(),callAndCheck(this.gl,function(){return r.gl.getAttribLocation(e,t)})},e.prototype.getUniformLocationNoThrow=function(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)},e.prototype.setInputMatrixTexture=function(e,t,r){this.throwIfDisposed(),this.throwIfNoProgram(),bindTextureToProgramUniformSampler(this.gl,this.program,e,t,r)},e.prototype.setOutputMatrixTexture=function(e,t,r){this.setOutputMatrixTextureDriver(e,r,t)},e.prototype.setOutputPackedMatrixTexture=function(e,t,r){this.throwIfDisposed();var n=getPackedMatrixTextureShapeWidthHeight(t,r),o=n[0],a=n[1];this.setOutputMatrixTextureDriver(e,o,a)},e.prototype.setOutputMatrixWriteRegion=function(e,t,r,n){this.setOutputMatrixWriteRegionDriver(r,e,n,t)},e.prototype.setOutputPackedMatrixWriteRegion=function(e,t,r,n){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")},e.prototype.debugValidate=function(){null!=this.program&&validateProgram(this.gl,this.program),validateFramebuffer(this.gl)},e.prototype.executeProgram=function(){this.throwIfDisposed(),this.throwIfNoProgram();var e=this.gl;this.autoDebugValidate&&this.debugValidate(),callAndCheck(e,function(){return e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0)})},e.prototype.blockUntilAllProgramsCompleted=function(){var e=this;this.throwIfDisposed(),callAndCheck(this.gl,function(){return e.gl.finish()})},e.prototype.getQueryTimerExtension=function(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=getExtensionOrThrow(this.gl,2===ENV.get("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension},e.prototype.getQueryTimerExtensionWebGL2=function(){return this.getQueryTimerExtension()},e.prototype.getQueryTimerExtensionWebGL1=function(){return this.getQueryTimerExtension()},e.prototype.beginQuery=function(){if(2===ENV.get("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){var e=this.gl,t=this.getQueryTimerExtensionWebGL2(),r=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,r),r}var n=this.getQueryTimerExtensionWebGL1(),o=n.createQueryEXT();return n.beginQueryEXT(n.TIME_ELAPSED_EXT,o),o},e.prototype.endQuery=function(){if(2!==ENV.get("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){var e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}else{var t=this.gl,r=this.getQueryTimerExtensionWebGL2();t.endQuery(r.TIME_ELAPSED_EXT)}},e.prototype.waitForQueryAndGetTime=function(e){return __awaiter(this,void 0,void 0,function(){var t=this;return __generator(this,function(r){switch(r.label){case 0:return[4,repeatedTry(function(){return t.disposed||t.isQueryAvailable(e,ENV.get("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))})];case 1:return r.sent(),[2,this.getQueryTime(e,ENV.get("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))]}})})},e.prototype.getQueryTime=function(e,t){if(0===t)return null;if(2===t){var r=this.gl;return r.getQueryParameter(e,r.QUERY_RESULT)/1e6}var n=this.getQueryTimerExtensionWebGL1();return n.getQueryObjectEXT(e,n.QUERY_RESULT_EXT)/1e6},e.prototype.isQueryAvailable=function(e,t){if(0===t)return!0;if(2===t){var r=this.gl,n=this.getQueryTimerExtensionWebGL2(),o=r.getQueryParameter(e,r.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),o&&!this.disjoint}o=(n=this.getQueryTimerExtensionWebGL1()).getQueryObjectEXT(e,n.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),o&&!this.disjoint},e.prototype.pollFence=function(e){var t=this;return new Promise(function(r){t.addItemToPoll(function(){return e.isFencePassed()},function(){return r()})})},e.prototype.pollItems=function(){for(var e=binSearchLastTrue(this.itemsToPoll.map(function(e){return e.isDoneFn})),t=0;t<=e;++t){(0,this.itemsToPoll[t].resolveFn)()}this.itemsToPoll=this.itemsToPoll.slice(e+1)},e.prototype.addItemToPoll=function(e,t){var r=this;this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1||repeatedTry(function(){return r.pollItems(),0===r.itemsToPoll.length})},e.prototype.bindTextureToFrameBuffer=function(e){this.throwIfDisposed(),bindColorTextureToFramebuffer(this.gl,e,this.framebuffer),this.autoDebugValidate&&validateFramebuffer(this.gl)},e.prototype.unbindTextureToFrameBuffer=function(){null!=this.outputTexture?(bindColorTextureToFramebuffer(this.gl,this.outputTexture,this.framebuffer),this.autoDebugValidate&&validateFramebuffer(this.gl)):unbindColorTextureFromFramebuffer(this.gl,this.framebuffer)},e.prototype.downloadMatrixDriver=function(e,t){this.bindTextureToFrameBuffer(e);var r=t();return this.unbindTextureToFrameBuffer(),r},e.prototype.setOutputMatrixTextureDriver=function(e,t,r){this.throwIfDisposed();var n=this.gl;bindColorTextureToFramebuffer(n,e,this.framebuffer),this.autoDebugValidate&&validateFramebuffer(n),this.outputTexture=e,callAndCheck(n,function(){return n.viewport(0,0,t,r)}),callAndCheck(n,function(){return n.scissor(0,0,t,r)})},e.prototype.setOutputMatrixWriteRegionDriver=function(e,t,r,n){var o=this;this.throwIfDisposed(),callAndCheck(this.gl,function(){return o.gl.scissor(e,t,r,n)})},e.prototype.throwIfDisposed=function(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")},e.prototype.throwIfNoProgram=function(){if(null==this.program)throw new Error("No GPU program is currently set.")},e}();function binSearchLastTrue(e){for(var t=0,r=e.length-1,n=-1;t<=r;){var o=t+r>>1;e[o]()?(n=o,t=o+1):r=o-1}return n}function compileProgram(e,t,r,n){for(var o=t.userCode,a=r.map(function(e,r){var n={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked};return{name:t.variableNames[r],shapeInfo:n}}),i=a.map(function(e){return e.shapeInfo}),s={logicalShape:n.shape,texShape:n.texData.texShape,isUniform:!1,isPacked:n.texData.isPacked},u=makeShader(a,s,o,!0===t.supportsBroadcasting,t.usesPackedTextures),l=e.createProgram(u),c={},p=0;p<t.variableNames.length;p++){var d=t.variableNames[p];c[d]=e.getUniformLocation(l,d,!1)}return{program:t,source:u,webGLProgram:l,uniformLocations:c,gpgpu:e,inShapeInfos:i,outShapeInfo:s}}function validateBinaryAndProgram(e,t){if(e.length!==t.length)throw Error("Binary was compiled with "+e.length+" inputs, but was executed with "+t.length+" inputs");e.forEach(function(e,r){var n=e.logicalShape,o=t[r],a=o.shape;if(!arraysEqual(n,a))throw Error("Binary was compiled with different shapes than the current args. Shapes "+n+" and "+a+" must match");if(!e.isUniform||!o.isUniform){var i=e.texShape,s=o.isUniform?null:o.texData.texShape;if(!arraysEqual(i,s))throw Error("Binary was compiled with different texture shapes than the current args. Shape "+i+" and "+s+" must match")}})}function runProgram(e,t,r,n){validateBinaryAndProgram(e.inShapeInfos,t),validateBinaryAndProgram([e.outShapeInfo],[r]);var o=r.texData.texture,a=r.texData.texShape,i=e.gpgpu;r.texData.isPacked?i.setOutputPackedMatrixTexture(o,a[0],a[1]):i.setOutputMatrixTexture(o,a[0],a[1]),i.setProgram(e.webGLProgram),t.forEach(function(t,r){var n=e.program.variableNames[r],o=e.uniformLocations[n];if(null!=o){if(t.isUniform){if(1===sizeFromShape(t.shape))i.gl.uniform1f(o,t.uniformValues[0]);else{var a=t.uniformValues;a instanceof Float32Array||(a=new Float32Array(a)),i.gl.uniform1fv(o,a)}return}var s=t.texData.texture;i.setInputMatrixTexture(s,o,r)}}),null!=n&&n(i,e.webGLProgram),i.executeProgram()}function makeShaderKey(e,t,r){var n="";t.concat(r).forEach(function(e){n+=e.shape+"_"+(e.isUniform?"uniform":e.texData.texShape)});var o=e.userCode,a=(!0===e.supportsBroadcasting).toString(),i=e.constructor.name;return i+="_"+a+"_"+n+"_"+o}var Im2ColProgram=function(){return function(e,t,r){this.variableNames=["A"],this.outputShape=e;var n=r.filterWidth,o=r.inChannels,a=r.strideWidth,i=r.strideHeight,s=r.padInfo,u=r.outWidth,l=r.dilationWidth,c=r.dilationHeight,p=s.left,d=s.top,h=o*n;this.userCode="\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            int blockIndex = rc.y + col;\n            int pos = rc.x + row;\n\n            if(blockIndex >= "+e[1]+" || pos >= "+e[0]+") continue;\n\n            int offsetY = int(blockIndex / ("+u+")) * "+i+" - "+d+";\n            int d0 = offsetY + "+c+" * (pos / "+h+");\n\n            if(d0 >= "+t[0]+" || d0 < 0) continue;\n\n            int offsetX = int(mod(float(blockIndex), "+u+".) * "+a+". - "+p+".);\n            int d1 = offsetX + "+l+" * (int(mod(float(pos), "+h+".) / "+o+".));\n\n            if(d1 >= "+t[1]+" || d1 < 0) continue;\n\n            result[row * 2 + col] = getA(d0, d1, int(mod(float(pos), "+o+".)));\n          }\n        }\n\n        gl_FragColor = result;\n      }\n    "}}(),LRNProgram=function(){return function(e,t,r,n,o){this.variableNames=["x"],this.outputShape=[];var a,i=t,s=e[3]-1;this.outputShape=e;var u="float("+r+") + float("+n+") * sum";a=.5===o?"inversesqrt("+u+")":1===o?"1.0/("+u+")":"exp(log("+u+") * float(-"+o+"));",this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -"+i+"; j <= "+i+"; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  "+s+") {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * "+a+";\n        setOutput(val);\n      }\n    "}}(),LRNGradProgram=function(){return function(e,t,r,n,o){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=r,this.alpha=n,this.beta=o,this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < "+this.depth+"; ++d) {\n          int depthBegin = int(max(0.0, float(d - "+t+")));\n          int depthEnd = int(min(float("+this.depth+"),\n              float(d + "+t+" + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = "+this.depth+";\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float("+n+") * norm + float("+r+");\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float("+n+")\n                * float("+o+")\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * "+o+");\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    "}}(),MaxPool2DBackpropProgram=function(){return function(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;var t=e.strideHeight,r=e.strideWidth,n=e.dilationHeight,o=e.effectiveFilterHeight,a=e.effectiveFilterWidth,i=o-1-e.padInfo.top,s=a-1-e.padInfo.left,u=o*a-1;this.userCode="\n      const ivec2 pads = ivec2("+i+", "+s+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < "+o+";\n          wR += "+n+") {\n          float dyR = float(dyRCorner + wR) / "+t+".0;\n\n          if (dyR < 0.0 || dyR >= "+e.outHeight+".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < "+a+"; wC++) {\n            float dyC = float(dyCCorner + wC) / "+r+".0;\n\n            if (dyC < 0.0 || dyC >= "+e.outWidth+".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = "+u+" - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * "+a+" + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}}(),MatMulProgram=function(){return function(e,t,r,n){void 0===r&&(r=!1),void 0===n&&(n=!1),this.variableNames=["matrixA","matrixB"];var o=e[0],a=r?e[2]:e[1],i=n?t[1]:t[2],s=r?e[1]:e[2];this.outputShape=[o,a,i];var u=function(e,t){return r?"batch, "+t+" + "+e+", aRow":"batch, aRow, "+t+" + "+e},l=function(e,t){return n?"batch, bCol, "+t+" + "+e:"batch, "+t+" + "+e+", bCol"},c=4*Math.floor(s/4),p=s%4;this.userCode=" float dotARowBCol(int batch, int aRow, int bCol) {\n      float result = 0.0;\n      for (int i = 0; i < "+c+"; i += 4) {\n        vec4 a = vec4(\n          getMatrixA("+u(0,"i")+"),\n          getMatrixA("+u(1,"i")+"),\n          getMatrixA("+u(2,"i")+"),\n          getMatrixA("+u(3,"i")+")\n        );\n        vec4 b = vec4(\n          getMatrixB("+l(0,"i")+"),\n          getMatrixB("+l(1,"i")+"),\n          getMatrixB("+l(2,"i")+"),\n          getMatrixB("+l(3,"i")+")\n        );\n\n        result += dot(a, b);\n      }\n\n      if ("+(1===p)+") {\n        result += getMatrixA("+u(0,c)+") *\n          getMatrixB("+l(0,c)+");\n      } else if ("+(2===p)+") {\n        vec2 a = vec2(\n          getMatrixA("+u(0,c)+"),\n          getMatrixA("+u(1,c)+")\n        );\n        vec2 b = vec2(\n          getMatrixB("+l(0,c)+"),\n          getMatrixB("+l(1,c)+")\n        );\n        result += dot(a, b);\n      } else if ("+(3===p)+") {\n        vec3 a = vec3(\n          getMatrixA("+u(0,c)+"),\n          getMatrixA("+u(1,c)+"),\n          getMatrixA("+u(2,c)+")\n        );\n        vec3 b = vec3(\n          getMatrixB("+l(0,c)+"),\n          getMatrixB("+l(1,c)+"),\n          getMatrixB("+l(2,c)+")\n        );\n        result += dot(a, b);\n      }\n\n      return result;\n    }\n\n    void main() {\n      ivec3 resBRC = getOutputCoords();\n      setOutput(dotARowBCol(resBRC.x, resBRC.y, resBRC.z));\n    }\n    "}}(),MatMulPackedProgram=function(){return function(e,t,r,n,o){void 0===n&&(n=!1),void 0===o&&(o=!1),this.variableNames=["matrixA","matrixB"],this.usesPackedTextures=!0,this.outputShape=r;var a=n?e[0]:e[1],i=Math.ceil(a/2),s=n?"i * 2, rc.x":"rc.x, i * 2",u=o?"rc.y, i * 2":"i * 2, rc.y",l=n?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],c=o?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];this.userCode="\n      const float sharedDimension = "+i+".0;\n\n      vec4 dot2x2ARowBCol(ivec2 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < "+i+"; i++) {\n          vec4 a = getMatrixA("+s+");\n          vec4 b = getMatrixB("+u+");\n\n          result += ("+l[0]+" * "+c[0]+") + ("+l[1]+" * "+c[1]+");\n        }\n        return result;\n      }\n\n      void main() {\n        ivec2 rc = getOutputCoords();\n        setOutput(dot2x2ARowBCol(rc));\n      }\n    "}}(),MultinomialProgram=function(){function e(e,t,r){this.variableNames=["probs"],this.outputShape=[e,r],this.userCode="\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < "+(t-1)+"; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float("+(t-1)+"));\n      }\n    "}return e.prototype.getCustomSetupFunc=function(e){var t=this;return function(r,n){null==t.seedLoc&&(t.seedLoc=r.getUniformLocation(n,"seed")),r.gl.uniform1f(t.seedLoc,e)}},e}(),OneHotProgram=function(){return function(e,t,r,n){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float("+n+"), float("+r+"),\n                      float(index == coords.y)));\n      }\n    "}}();function getVecChannels(e,t){return["x","y","z","w","u","v"].slice(0,t).map(function(t){return e+"."+t})}function getChannels(e,t){return 1===t?[e]:getVecChannels(e,t)}function getSourceCoords$1(e,t){if(1===e)return"rc";for(var r="",n=0;n<e;n++)r+=t[n],n<e-1&&(r+=",");return r}var PackProgram=function(){return function(e){this.variableNames=["A"],this.outputShape=e;var t=e.length,r=getChannels("rc",t),n=getCoordsDataType(t),o=getOutOfBoundsCondition(t,e,r),a=getSetup(t,e[e.length-1],e[e.length-2],r),i=getOutput(e,r);this.userCode="\n      void main() {\n        "+n+" rc = getOutputCoords();\n\n        if("+o+") {\n          gl_FragColor = vec4(0);\n        } else {\n          "+a+"\n\n          setOutput(vec4("+i+"));\n        }\n      }\n    "}}();function getSourceCoordsArr(e,t){for(var r=[],n=0;n<=1;n++)for(var o=0;o<=1;o++){for(var a=(0===n?"r":"rp1")+", "+(0===o?"c":"cp1"),i=2;i<e;i++)a=t[t.length-1-i]+","+a;r.push(a)}return r}function getOutOfBoundsCondition(e,t,r){if(1===e)return"rc > "+t[0];for(var n="",o=e-2;o<e;o++)n+=r[o]+" >= "+t[o],o<e-1&&(n+="||");return n}function getSetup(e,t,r,n){if(1===e)return"";var o=n.slice(-2);return"\n    int r = "+o[0]+";\n    int c = "+o[1]+";\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= "+t+";\n    bool rEdge = rp1 >= "+r+";\n  "}function getOutput(e,t){var r=e.length,n=getSourceCoordsArr(r,t);return 1===r?"getA(rc),\n            rc + 1 >= "+e[0]+" ? 0. : getA(rc + 1),\n            0, 0":"getA("+n[0]+"),\n          cEdge ? 0. : getA("+n[1]+"),\n          rEdge ? 0. : getA("+n[2]+"),\n          rEdge || cEdge ? 0. : getA("+n[3]+")"}var PadProgram=function(){return function(e,t,r){this.variableNames=["x"],this.outputShape=t.map(function(t,r){return t[0]+e[r]+t[1]});var n=e.length,o=getCoordsDataType(n),a=t.map(function(e){return e[0]}).join(","),i=t.map(function(t,r){return t[0]+e[r]}).join(","),s=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,n);this.userCode=1!==n?"\n      "+o+" start = "+o+"("+a+");\n      "+o+" end = "+o+"("+i+");\n\n      void main() {\n        "+o+" outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(float("+r+"));\n        } else {\n          "+o+" coords = outC - start;\n          setOutput(getX("+s+"));\n        }\n      }\n    ":"\n        int start = "+a+";\n        int end = "+i+";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(float("+r+"));\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      "}}(),Pool2DProgram=function(){return function(e,t,r){if(this.variableNames=["x"],"avg"===t&&r)throw new Error("Cannot compute positions for average pool.");var n=e.filterWidth,o=e.strideHeight,a=e.strideWidth,i=e.dilationHeight,s=e.dilationWidth,u=e.effectiveFilterHeight,l=e.effectiveFilterWidth,c=e.padInfo.top,p=e.padInfo.left;this.outputShape=e.outShape;var d="avg"===t,h="0.0";if(d||(h="-1.0 / 0.0"),r)this.userCode="\n        const ivec2 strides = ivec2("+o+", "+a+");\n        const ivec2 pads = ivec2("+c+", "+p+");\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < "+u+";\n              wR += "+i+") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= "+e.inHeight+") {\n              continue;\n            }\n\n            for (int wC = 0; wC < "+l+";\n                wC += "+s+") {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= "+e.inWidth+") {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = wR * "+l+" + wC;\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ";else{var f=t+"("+t+"("+t+"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"avg"===t&&(f="avgValue / count");var m=4*Math.floor(n/4),g=n%4,v="\n      if ("+d+") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    ";this.userCode="\n      const ivec2 strides = ivec2("+o+", "+a+");\n      const ivec2 pads = ivec2("+c+", "+p+");\n      const float initializationValue = "+h+";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= "+e.inWidth+") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4("+h+");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < "+u+";\n            wR += "+i+") {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= "+e.inHeight+") {\n            continue;\n          }\n\n          for (int wC = 0; wC < "+m+"; wC += 4) {\n            int xC = xCCorner + wC * "+s+";\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + "+s+", d),\n              getValue(batch, xR, xC + 2 * "+s+", d),\n              getValue(batch, xR, xC + 3 * "+s+", d)\n            );\n\n            "+v+"\n          }\n\n          int xC = xCCorner + "+m+";\n          if ("+(1===g)+") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            "+v+"\n          } else if ("+(2===g)+") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + "+s+", d),\n              initializationValue,\n              initializationValue\n            );\n\n            "+v+"\n          } else if ("+(3===g)+") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + "+s+", d),\n              getValue(batch, xR, xC + 2 * "+s+", d),\n              initializationValue\n            );\n\n            "+v+"\n          }\n        }\n        setOutput("+f+");\n      }\n    "}}}(),ReduceProgram=function(){return function(e,t){this.variableNames=["x"];var r=e.windowSize,n=e.batchSize,o=e.inSize,a=Math.ceil(o/r);this.outputShape=[n,a];var i="0.0",s="";"prod"===t?i="1.0":"min"===t?(i="1.0 / 0.0",s="min"):"max"===t&&(i="-1.0 / 0.0",s="max");var u=t+"("+t+"("+t+"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"sum"===t?u="sumValue":"prod"===t?u="prodValue":"all"===t?u="allValue":"any"===t&&(u="anyValue");var l=4*Math.floor(r/4),c=r%4,p="\n      if ("+("sum"===t)+") {\n        sumValue += dot(values, ones);\n      } else if ("+("prod"===t)+") {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = "+s+"(values, minMaxValue);\n      }\n    ",d="vec4";"all"===t?(i="1.0",p="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",d="bvec4"):"any"===t&&(i="0.0",p="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",d="bvec4");var h="";o%r>0&&(h="\n        if (inIdx < 0 || inIdx >= "+o+") {\n          return initializationValue;\n        }\n      "),this.userCode="\n      const float initializationValue = "+i+";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        "+h+"\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * "+r+";\n\n        vec4 minMaxValue = vec4("+i+");\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < "+l+"; i += 4) {\n          int inIdx = inOffset + i;\n          "+d+" values = "+d+"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          "+p+"\n        }\n\n        int inIdx = inOffset + "+l+";\n        if ("+(1===c)+") {\n          "+d+" values = "+d+"(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          "+p+"\n        } else if ("+(2===c)+") {\n          "+d+" values = "+d+"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          "+p+"\n        } else if ("+(3===c)+") {\n          "+d+" values = "+d+"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          "+p+"\n        }\n        setOutput("+u+");\n      }\n    "}}(),ReshapePackedProgram=function(){return function(e,t){this.variableNames=["A"],this.usesPackedTextures=!0,this.outputShape=e;for(var r="",n=0;n<4;n++){var o="thisRC = rc;";n%2==1&&(o+="thisRC.z += 1;"),n>1&&(o+="thisRC.y += 1;"),r+="\n        "+o+"\n        "+(n>0?"if(thisRC.y < rows && thisRC.z < cols){":"")+"\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result["+n+"] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        "+(n>0?"}":"")+"\n      "}this.userCode="\n      "+getReshapedInputCoords(t)+"\n      "+getFlatIndex(e)+"\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = "+e[1]+";\n        int cols = "+e[2]+";\n\n        "+r+"\n\n        setOutput(result);\n      }\n    "}}();function getFlatIndex(e){return"\n    int getFlatIndex(ivec3 coords) {\n      return round("+dotify(["coords.x","coords.y","coords.z"],computeStrides(e).map(function(e){return e.toString()}).concat(["1."]))+");\n    }\n  "}function getReshapedInputCoords(e){return"\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      "+getLogicalCoordinatesFromFlatIndex(["r","c","d"],e)+"\n      return ivec3(r, c, d);\n    }\n  "}var ResizeBilinearBackpropProgram=function(){return function(e,t,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t.shape;var n=t.shape,o=n[1],a=n[2],i=e.shape,s=i[1],u=i[2],l=[r&&s>1?o-1:o,r&&u>1?a-1:a],c=[r&&s>1?s-1:s,r&&u>1?u-1:u],p=l[0]/c[0],d=l[1]/c[1],h=1/p,f=1/d,m=2*Math.ceil(h)+2,g=2*Math.ceil(f)+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float("+p+");\n        const float widthScale = float("+d+");\n\n        const float invHeightScale = float("+h+");\n        const float invWidthScale = float("+f+");\n\n        const int winHeight = int("+m+");\n        const int winWidth = int("+g+");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= "+s+") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= "+u+") {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), "+(o-1)+".0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), "+(a-1)+".0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    "}}(),ResizeBilinearProgram=function(){return function(e,t,r,n){this.variableNames=["A"],this.outputShape=[];var o=e[0],a=e[1],i=e[2],s=e[3];this.outputShape=[o,t,r,s];var u=[n&&t>1?a-1:a,n&&r>1?i-1:i],l=[n&&t>1?t-1:t,n&&r>1?r-1:r];this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          "+u[0]/l[0]+",\n          "+u[1]/l[1]+");\n      const vec2 inputShapeRC = vec2("+a+".0, "+i+".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    "}}(),ResizeNearestNeigborBackpropProgram=function(){return function(e,t,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t.shape;var n=t.shape,o=n[1],a=n[2],i=e.shape,s=i[1],u=i[2],l=[r&&s>1?o-1:o,r&&u>1?a-1:a],c=[r&&s>1?s-1:s,r&&u>1?u-1:u],p=l[0]/c[0],d=l[1]/c[1],h=1/p,f=1/d,m=2*Math.ceil(h)+2,g=2*Math.ceil(f)+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float("+p+");\n        const float widthScale = float("+d+");\n\n        const float invHeightScale = float("+h+");\n        const float invWidthScale = float("+f+");\n\n        const int winHeight = int("+m+");\n        const int winWidth = int("+g+");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= "+s+") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= "+u+") {\n              continue;\n            }\n\n            float sourceFracRow =\n              float("+l[0]+") *\n                (float(dyR) / float("+c[0]+"));\n\n            float sourceFracCol =\n                float("+l[1]+") *\n                  (float(dyC) / float("+c[1]+"));\n\n            int sourceNearestRow = int(min(\n                float(int("+o+") - 1),\n                "+r+" ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int("+a+") - 1),\n                "+r+" ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    "}}(),ResizeNearestNeighborProgram=function(){return function(e,t,r,n){this.variableNames=["A"],this.outputShape=[];var o=e[0],a=e[1],i=e[2],s=e[3];this.outputShape=[o,t,r,s];var u=[n&&t>1?a-1:a,n&&r>1?i-1:i],l=[n&&t>1?t-1:t,n&&r>1?r-1:r],c=n?"0.5":"0.0";this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          "+u[0]/l[0]+",\n          "+u[1]/l[1]+");\n      const vec2 inputShapeRC = vec2("+a+".0, "+i+".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + "+c+")));\n\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    "}}(),ReverseProgram=function(){return function(e,t){this.variableNames=["x"];var r=e.length;if(r>4)throw new Error("WebGL backend: Reverse of rank-"+r+" tensor is not yet supported");if(this.outputShape=e,1!==r){var n=e.map(function(r,n){return function(r){return-1!==t.indexOf(r)&&1!==e[r]?e[r]+" - coords["+r+"] - 1":"coords["+r+"]"}(n)}).join(","),o=getCoordsDataType(r);this.userCode="\n      void main() {\n        "+o+" coords = getOutputCoords();\n        setOutput(getX("+n+"));\n      }\n    "}else this.userCode="\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX("+e[0]+" - coord - 1));\n        }\n      "}}(),ScatterProgram=function(){return function(e,t,r,n,o,a,i){void 0===i&&(i=!0),this.variableNames=["updates","indices","defaultValue"],this.outputShape=a;var s=getCoordsDataType(o.length),u=getCoordsDataType(a.length),l="";1===r?l="i":2===r&&(l="i, j");var c="getIndices("+l+")",p="";1===n?p="i":2===n&&(p="i, coords[1]");var d="getUpdates("+p+")",h=t>1?"strides[j]":"strides";this.userCode="\n        "+s+" strides = "+s+"("+o+");\n\n        void main() {\n          "+u+" coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < "+e+"; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < "+t+"; j++) {\n              int index = round("+c+");\n              flattenedIndex += index * "+h+";\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += "+d+";\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      "}}(),SegmentOpProgram=function(){return function(e,t){this.variableNames=["x","segmentIds"];var r=e.windowSize,n=e.batchSize,o=e.inSize,a=e.numSegments,i=a*Math.ceil(o/r);this.outputShape=[n,i];var s=4*Math.floor(r/4),u=r%4,l="\n        sumValue += dot(values, filter);\n    ",c="";o%r>0&&(c="\n        if (inIdx < 0 || inIdx >= "+o+") {\n          return initializationValue;\n        }\n      ");var p="";o%r>0&&(p="\n        if (inIdx < 0 || inIdx >= "+o+") {\n          return -1.0;\n        }\n      "),this.userCode="\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        "+c+"\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        "+p+"\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          "+a+")) * float("+r+"));\n        int currentSeg = int(mod(float(outIdx), float("+a+")));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < "+s+"; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 filter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          "+l+"\n        }\n\n        int inIdx = inOffset + "+s+";\n        if ("+(1===u)+") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 filter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          "+l+"\n        } else if ("+(2===u)+") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 filter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          "+l+"\n        } else if ("+(3===u)+") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 filter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          "+l+"\n        }\n        setOutput(sumValue);\n      }\n    "}}(),SelectProgram=function(){return function(e,t,r){var n,o;if(this.variableNames=["c","a","b"],this.outputShape=t,r>4)throw Error("Where for rank "+r+" is not yet supported");if(1===r)o="resRC",n="resRC";else{for(var a=["resRC.x","resRC.y","resRC.z","resRC.w"],i=[],s=[],u=0;u<t.length;u++)s.push(""+a[u]),u<e&&i.push(""+a[u]);n=i.join(),o=s.join()}var l=getCoordsDataType(r);this.userCode="\n      void main() {\n        "+l+" resRC = getOutputCoords();\n        float cVal = getC("+n+");\n        if (cVal >= 1.0) {\n          setOutput(getA("+o+"));\n        } else {\n          setOutput(getB("+o+"));\n        }\n      }\n    "}}(),SliceProgram=function(){function e(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;var t=getCoordsDataType(this.rank),r=getCoords$1(this.rank);this.userCode="\n      uniform "+t+" start;\n\n      void main() {\n        "+t+" sourceLoc = start + getOutputCoords();\n        setOutput(getSource("+r+"));\n      }\n    "}return e.prototype.getCustomSetupFunc=function(e){var t=this;if(e.length!==this.rank)throw Error("The rank ("+this.rank+") of the program must match the length of start ("+e.length+")");return function(r,n){if(null!=t.startLoc||(t.startLoc=r.getUniformLocationNoThrow(n,"start"),null!=t.startLoc))if(1===t.rank)r.gl.uniform1i(t.startLoc,e[0]);else if(2===t.rank)r.gl.uniform2i(t.startLoc,e[0],e[1]);else if(3===t.rank)r.gl.uniform3i(t.startLoc,e[0],e[1],e[2]);else{if(4!==t.rank)throw Error("Slicing for rank "+t.rank+" is not yet supported");r.gl.uniform4i(t.startLoc,e[0],e[1],e[2],e[3])}}},e}();function getCoords$1(e){if(1===e)return"sourceLoc";if(2===e)return"sourceLoc.x, sourceLoc.y";if(3===e)return"sourceLoc.x, sourceLoc.y, sourceLoc.z";if(4===e)return"sourceLoc.x, sourceLoc.y, sourceLoc.z, sourceLoc.w";throw Error("Slicing for rank "+e+" is not yet supported")}var StridedSliceProgram=function(){return function(e,t,r,n){this.variableNames=["x"];var o=r.filter(function(e,t){return-1===n.indexOf(t)});this.outputShape=o;var a=r.length,i=getCoordsDataType(r.length),s=getCoordsDataType(o.length),u="";if(1===a)u="coords * strides + begin";else{var l=0;u=r.map(function(e,t){return-1===n.indexOf(t)?(l++,1===o.length?"coords * strides["+t+"] + begin["+t+"]":"coords["+(l-1)+"] * strides["+t+"] + begin["+t+"]"):"begin["+t+"]"}).join(",")}this.userCode="\n      "+i+" begin = "+i+"("+e+");\n      "+i+" strides = "+i+"("+t+");\n\n      void main() {\n        "+s+" coords = getOutputCoords();\n        setOutput(getX("+u+"));\n      }\n    "}}(),TextureManager=function(){function e(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}return e.prototype.acquireTexture=function(e,t,r){var n,o=getPhysicalFromLogicalTextureType(t,r),a=getKeyFromTextureShape(e,o,r);if(a in this.freeTextures||(this.freeTextures[a]=[]),a in this.usedTextures||(this.usedTextures[a]=[]),this.freeTextures[a].length>0){this.numFreeTextures--,this.numUsedTextures++,this.log();var i=this.freeTextures[a].shift();return this.usedTextures[a].push(i),i}return this.numUsedTextures++,this.log(),o===PhysicalTextureType.PACKED_2X2_FLOAT32?n=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):o===PhysicalTextureType.PACKED_2X2_FLOAT16?n=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):o===PhysicalTextureType.UNPACKED_FLOAT32?n=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):o===PhysicalTextureType.UNPACKED_FLOAT16?n=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):o===PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE&&(n=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[a].push(n),n},e.prototype.releaseTexture=function(e,t,r,n){if(null!=this.freeTextures){var o=getKeyFromTextureShape(t,getPhysicalFromLogicalTextureType(r,n),n);o in this.freeTextures||(this.freeTextures[o]=[]),this.freeTextures[o].push(e),this.numFreeTextures++,this.numUsedTextures--;var a=this.usedTextures[o],i=a.indexOf(e);if(i<0)throw new Error("Cannot release a texture that was never provided by this texture manager");a.splice(i,1),this.log()}},e.prototype.log=function(){if(this.logEnabled){var e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",this.numFreeTextures+" / "+this.numUsedTextures,"("+e+")")}},e.prototype.getNumUsedTextures=function(){return this.numUsedTextures},e.prototype.getNumFreeTextures=function(){return this.numFreeTextures},e.prototype.dispose=function(){var e=this;if(null!=this.freeTextures){for(var t in this.freeTextures)this.freeTextures[t].forEach(function(t){e.gpgpu.deleteMatrixTexture(t)});for(var t in this.usedTextures)this.usedTextures[t].forEach(function(t){e.gpgpu.deleteMatrixTexture(t)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0}},e}();function getPhysicalFromLogicalTextureType(e,t){if(t)return ENV.get("WEBGL_RENDER_FLOAT32_ENABLED")?PhysicalTextureType.PACKED_2X2_FLOAT32:PhysicalTextureType.PACKED_2X2_FLOAT16;if(e===TextureUsage.DOWNLOAD||e===TextureUsage.PIXELS)return PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE;if(e===TextureUsage.UPLOAD)return PhysicalTextureType.UNPACKED_FLOAT32;if(e===TextureUsage.RENDER)return ENV.get("WEBGL_RENDER_FLOAT32_ENABLED")?PhysicalTextureType.UNPACKED_FLOAT32:PhysicalTextureType.UNPACKED_FLOAT16;throw new Error("Unknown logical texture type "+e)}function getKeyFromTextureShape(e,t,r){return e[0]+"_"+e[1]+"_"+t+"_"+r}var TileProgram=function(){return function(e,t){this.variableNames=["A"];for(var r=new Array(e.length),n=0;n<r.length;n++)r[n]=e[n]*t[n];this.outputShape=r,this.rank=r.length;var o=getCoordsDataType(this.rank),a=getSourceCoords$2(e);this.userCode="\n      void main() {\n        "+o+" resRC = getOutputCoords();\n        setOutput(getA("+a+"));\n      }\n    "}}();function getSourceCoords$2(e){var t=e.length;if(t>5)throw Error("Tile for rank "+t+" is not yet supported");if(1===t)return"imod(resRC, "+e[0]+")";for(var r=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],n=[],o=0;o<e.length;o++)n.push("imod("+r[o]+", "+e[o]+")");return n.join()}var TransposeProgram=function(){return function(e,t){this.variableNames=["A"];for(var r=new Array(e.length),n=0;n<r.length;n++)r[n]=e[t[n]];this.outputShape=r,this.rank=r.length;var o=getCoordsDataType(this.rank),a=getSwitchedCoords(t);this.userCode="\n    void main() {\n      "+o+" resRC = getOutputCoords();\n      setOutput(getA("+a+"));\n    }\n    "}}();function getSwitchedCoords(e){var t=e.length;if(t>6)throw Error("Transpose for rank "+t+" is not yet supported");for(var r=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],n=new Array(t),o=0;o<e.length;o++)n[e[o]]=r[o];return n.join()}var ERF_P=.3275911,ERF_A1=.254829592,ERF_A2=-.284496736,ERF_A3=1.421413741,ERF_A4=-1.453152027,ERF_A5=1.061405429,SELU_SCALEALPHA=1.7580993408473768,SELU_SCALE=1.0507009873554805,UnaryOpProgram=function(){function e(e,t){this.variableNames=["A"],this.outputShape=e,this.userCode="\n      uniform float NAN;\n      float unaryOperation(float x) {\n        "+t+"\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    "}return e.prototype.getCustomSetupFunc=function(){var e=this;return function(t,r){null==e.startLoc&&(e.startLoc=t.getUniformLocationNoThrow(r,"NAN"),null==e.startLoc)||t.gl.uniform1f(e.startLoc,NaN)}},e}(),CHECK_NAN_SNIPPET$1="if (isNaN(x)) return x;",ABS="return abs(x);",RELU=CHECK_NAN_SNIPPET$1+"\n  return (x < 0.0) ? 0.0 : x;\n",ELU="return (x >= 0.0) ? x : (exp(x) - 1.0);",SELU="\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = "+SELU_SCALEALPHA+";\n  float scale = "+SELU_SCALE+";\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n";function STEP(e){return void 0===e&&(e=0),CHECK_NAN_SNIPPET$1+"\n    return x > 0.0 ? 1.0 : float("+e+");\n  "}var NEG="return -x;",CEIL="return ceil(x);",FLOOR="return floor(x);",SIGN="\n  if (isNaN(x)) { return 0.0; }\n  return sign(x);\n",ROUND="\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n",EXP="return exp(x);",EXPM1="return exp(x) - 1.0;",LOG="if (x < 0.0) return NAN;\n  return log(x);",LOG1P="return log(1.0 + x);",SQRT="return sqrt(x);",RSQRT="return inversesqrt(x);",SIGMOID="return 1.0 / (1.0 + exp(-1.0 * x));",SOFTPLUS="\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n",SIN=CHECK_NAN_SNIPPET$1+"\n  return sin(x);\n",COS=CHECK_NAN_SNIPPET$1+"\n  return cos(x);\n",TAN="return tan(x);",ASIN="return asin(x);",ACOS="return acos(x);",ATAN=CHECK_NAN_SNIPPET$1+"\n  return atan(x);\n",SINH="\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n",COSH="\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n",TANH="\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n",ASINH="return log(x + sqrt(x * x + 1.0));",ACOSH=CHECK_NAN_SNIPPET$1+"\n  if (x < 1.0) return NAN;\n  return log(x + sqrt(x * x - 1.0));",ATANH=CHECK_NAN_SNIPPET$1+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\n  return (log(1.0 + x) - log(1.0 - x)) / 2.0;",ERF='\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = '+ERF_P+";\n  float a1 = "+ERF_A1+";\n  float a2 = "+ERF_A2+";\n  float a3 = "+ERF_A3+";\n  float a4 = "+ERF_A4+";\n  float a5 = "+ERF_A5+";\n\n  float t = 1.0 / (1.0 + p * x);\n  return 1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x);\n",SQUARE="return x * x;",RECIPROCAL="return 1.0 / x;",LOGICAL_NOT="return float(!(x >= 1.0));",TO_INT="return float(int(x));",UnpackProgram=function(){return function(e){this.variableNames=["A"],this.usesPackedTextures=!0,this.outputShape=e;var t=e.length,r=getChannels("rc",t),n=getCoordsDataType(t),o=getSourceCoords$1(t,r),a=r.slice(-2),i=1===t?"rc":"vec2("+a.join(",")+")";this.userCode="\n      void main() {\n        "+n+" rc = getOutputCoords();\n        vec4 packedInput = getA("+o+");\n\n        setOutput(getChannel(packedInput, "+i+"));\n      }\n    "}}();function concat1d_(e){return concat(e,0)}function concat2d_(e,t){return concat(e,t)}function concat3d_(e,t){return concat(e,t)}function concat4d_(e,t){return concat(e,t)}function concat_(e,t){void 0===t&&(t=0),assert(e.length>=1,"Pass at least one tensor to concat");var r=convertToTensorArray(e,"tensors","concat");t=parseAxisParam(t,r[0].shape)[0];var n=computeOutShape(r.map(function(e){return e.shape}),t);if(0===sizeFromShape(n))return tensor([],n);if(1===(r=r.filter(function(e){return e.size>0})).length)return r[0];var o=r.map(function(e){return e.shape});assertParamsConsistent(o,t);var a=r;return ENV.engine.runKernel(function(e){return e.concat(r,t)},a,function(e){var r=o.map(function(e){return e[t]});return split$1(e,r,t).map(function(e){return function(){return e}})})}function split_(e,t,r){void 0===r&&(r=0);var n,o=convertToTensor(e,"x","split");r=parseAxisParam(r,o.shape)[0],"number"==typeof t?(assert(o.shape[r]%t==0,"Number of splits must evenly divide the axis."),n=Array(t).fill(o.shape[r]/t)):(assert(o.shape[r]===t.reduce(function(e,t){return e+t}),"The sum of sizes must match the size of the axis dimension."),n=t);return ENV.engine.runKernel(function(e){return e.split(o,n,r)},{$x:o},function(e){return{$x:function(){return concat(e,r)}}})}var concat=op({concat_:concat_}),concat1d=op({concat1d_:concat1d_}),concat2d=op({concat2d_:concat2d_}),concat3d=op({concat3d_:concat3d_}),concat4d=op({concat4d_:concat4d_}),split$1=op({split_:split_}),commonjsGlobal="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};function createCommonjsModule(e,t){return e(t={exports:{}},t.exports),t.exports}var alea=createCommonjsModule(function(e){!function(e,t,r){function n(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function o(e,t){var r=new function(e){var t,r=this,n=(t=4022871197,function(e){e=e.toString();for(var r=0;r<e.length;r++){var n=.02519603282416938*(t+=e.charCodeAt(r));n-=t=n>>>0,t=(n*=t)>>>0,t+=4294967296*(n-=t)}return 2.3283064365386963e-10*(t>>>0)});r.next=function(){var e=2091639*r.s0+2.3283064365386963e-10*r.c;return r.s0=r.s1,r.s1=r.s2,r.s2=e-(r.c=0|e)},r.c=1,r.s0=n(" "),r.s1=n(" "),r.s2=n(" "),r.s0-=n(e),r.s0<0&&(r.s0+=1),r.s1-=n(e),r.s1<0&&(r.s1+=1),r.s2-=n(e),r.s2<0&&(r.s2+=1),n=null}(e),o=t&&t.state,a=r.next;return a.int32=function(){return 4294967296*r.next()|0},a.double=function(){return a()+1.1102230246251565e-16*(2097152*a()|0)},a.quick=a,o&&("object"==typeof o&&n(o,r),a.state=function(){return n(r,{})}),a}t&&t.exports?t.exports=o:r&&r.amd?r(function(){return o}):this.alea=o}(0,e,!1)}),xor128=createCommonjsModule(function(e){!function(e,t,r){function n(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function o(e,t){var r=new function(e){var t=this,r="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:r+=e;for(var n=0;n<r.length+64;n++)t.x^=0|r.charCodeAt(n),t.next()}(e),o=t&&t.state,a=function(){return(r.next()>>>0)/4294967296};return a.double=function(){do{var e=((r.next()>>>11)+(r.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},a.int32=r.next,a.quick=a,o&&("object"==typeof o&&n(o,r),a.state=function(){return n(r,{})}),a}t&&t.exports?t.exports=o:r&&r.amd?r(function(){return o}):this.xor128=o}(0,e,!1)}),xorwow=createCommonjsModule(function(e){!function(e,t,r){function n(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function o(e,t){var r=new function(e){var t=this,r="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:r+=e;for(var n=0;n<r.length+64;n++)t.x^=0|r.charCodeAt(n),n==r.length&&(t.d=t.x<<10^t.x>>>4),t.next()}(e),o=t&&t.state,a=function(){return(r.next()>>>0)/4294967296};return a.double=function(){do{var e=((r.next()>>>11)+(r.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},a.int32=r.next,a.quick=a,o&&("object"==typeof o&&n(o,r),a.state=function(){return n(r,{})}),a}t&&t.exports?t.exports=o:r&&r.amd?r(function(){return o}):this.xorwow=o}(0,e,!1)}),xorshift7=createCommonjsModule(function(e){!function(e,t,r){function n(e,t){return t.x=e.x.slice(),t.i=e.i,t}function o(e,t){null==e&&(e=+new Date);var r=new function(e){var t=this;t.next=function(){var e,r,n=t.x,o=t.i;return e=n[o],r=(e^=e>>>7)^e<<24,r^=(e=n[o+1&7])^e>>>10,r^=(e=n[o+3&7])^e>>>3,r^=(e=n[o+4&7])^e<<7,e=n[o+7&7],r^=(e^=e<<13)^e<<9,n[o]=r,t.i=o+1&7,r},function(e,t){var r,n=[];if(t===(0|t))n[0]=t;else for(t=""+t,r=0;r<t.length;++r)n[7&r]=n[7&r]<<15^t.charCodeAt(r)+n[r+1&7]<<13;for(;n.length<8;)n.push(0);for(r=0;r<8&&0===n[r];++r);for(8==r?n[7]=-1:n[r],e.x=n,e.i=0,r=256;r>0;--r)e.next()}(t,e)}(e),o=t&&t.state,a=function(){return(r.next()>>>0)/4294967296};return a.double=function(){do{var e=((r.next()>>>11)+(r.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},a.int32=r.next,a.quick=a,o&&(o.x&&n(o,r),a.state=function(){return n(r,{})}),a}t&&t.exports?t.exports=o:r&&r.amd?r(function(){return o}):this.xorshift7=o}(0,e,!1)}),xor4096=createCommonjsModule(function(e){!function(e,t,r){function n(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function o(e,t){null==e&&(e=+new Date);var r=new function(e){var t=this;t.next=function(){var e,r,n=t.w,o=t.X,a=t.i;return t.w=n=n+1640531527|0,r=o[a+34&127],e=o[a=a+1&127],r^=r<<13,e^=e<<17,r^=r>>>15,e^=e>>>12,r=o[a]=r^e,t.i=a,r+(n^n>>>16)|0},function(e,t){var r,n,o,a,i,s=[],u=128;for(t===(0|t)?(n=t,t=null):(t+="\0",n=0,u=Math.max(u,t.length)),o=0,a=-32;a<u;++a)t&&(n^=t.charCodeAt((a+32)%t.length)),0===a&&(i=n),n^=n<<10,n^=n>>>15,n^=n<<4,n^=n>>>13,a>=0&&(i=i+1640531527|0,o=0==(r=s[127&a]^=n+i)?o+1:0);for(o>=128&&(s[127&(t&&t.length||0)]=-1),o=127,a=512;a>0;--a)n=s[o+34&127],r=s[o=o+1&127],n^=n<<13,r^=r<<17,n^=n>>>15,r^=r>>>12,s[o]=n^r;e.w=i,e.X=s,e.i=o}(t,e)}(e),o=t&&t.state,a=function(){return(r.next()>>>0)/4294967296};return a.double=function(){do{var e=((r.next()>>>11)+(r.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},a.int32=r.next,a.quick=a,o&&(o.X&&n(o,r),a.state=function(){return n(r,{})}),a}t&&t.exports?t.exports=o:r&&r.amd?r(function(){return o}):this.xor4096=o}(0,e,!1)}),tychei=createCommonjsModule(function(e){!function(e,t,r){function n(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function o(e,t){var r=new function(e){var t=this,r="";t.next=function(){var e=t.b,r=t.c,n=t.d,o=t.a;return e=e<<25^e>>>7^r,r=r-n|0,n=n<<24^n>>>8^o,o=o-e|0,t.b=e=e<<20^e>>>12^r,t.c=r=r-n|0,t.d=n<<16^r>>>16^o,t.a=o-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):r+=e;for(var n=0;n<r.length+20;n++)t.b^=0|r.charCodeAt(n),t.next()}(e),o=t&&t.state,a=function(){return(r.next()>>>0)/4294967296};return a.double=function(){do{var e=((r.next()>>>11)+(r.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},a.int32=r.next,a.quick=a,o&&("object"==typeof o&&n(o,r),a.state=function(){return n(r,{})}),a}t&&t.exports?t.exports=o:r&&r.amd?r(function(){return o}):this.tychei=o}(0,e,!1)}),seedrandom=createCommonjsModule(function(e){!function(t,r){var n,o=this,a=256,i=6,s="random",u=r.pow(a,i),l=r.pow(2,52),c=2*l,p=a-1;function d(e,d,g){var v=[],y=f(function e(t,r){var n,o=[],a=typeof t;if(r&&"object"==a)for(n in t)try{o.push(e(t[n],r-1))}catch(e){}return o.length?o:"string"==a?t:t+"\0"}((d=1==d?{entropy:!0}:d||{}).entropy?[e,m(t)]:null==e?function(){try{var e;return n&&(e=n.randomBytes)?e=e(a):(e=new Uint8Array(a),(o.crypto||o.msCrypto).getRandomValues(e)),m(e)}catch(e){var r=o.navigator,i=r&&r.plugins;return[+new Date,o,i,o.screen,m(t)]}}():e,3),v),x=new function(e){var t,r=e.length,n=this,o=0,i=n.i=n.j=0,s=n.S=[];r||(e=[r++]);for(;o<a;)s[o]=o++;for(o=0;o<a;o++)s[o]=s[i=p&i+e[o%r]+(t=s[o])],s[i]=t;(n.g=function(e){for(var t,r=0,o=n.i,i=n.j,s=n.S;e--;)t=s[o=p&o+1],r=r*a+s[p&(s[o]=s[i=p&i+t])+(s[i]=t)];return n.i=o,n.j=i,r})(a)}(v),T=function(){for(var e=x.g(i),t=u,r=0;e<l;)e=(e+r)*a,t*=a,r=x.g(1);for(;e>=c;)e/=2,t/=2,r>>>=1;return(e+r)/t};return T.int32=function(){return 0|x.g(4)},T.quick=function(){return x.g(4)/4294967296},T.double=T,f(m(x.S),t),(d.pass||g||function(e,t,n,o){return o&&(o.S&&h(o,x),e.state=function(){return h(x,{})}),n?(r[s]=e,t):e})(T,y,"global"in d?d.global:this==r,d.state)}function h(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function f(e,t){for(var r,n=e+"",o=0;o<n.length;)t[p&o]=p&(r^=19*t[p&o])+n.charCodeAt(o++);return m(t)}function m(e){return String.fromCharCode.apply(0,e)}if(r["seed"+s]=d,f(r.random(),t),e.exports){e.exports=d;try{n=__webpack_require__(/*! crypto */ "./node_modules/crypto-browserify/index.js")}catch(e){}}else 0}([],Math)});seedrandom.alea=alea,seedrandom.xor128=xor128,seedrandom.xorwow=xorwow,seedrandom.xorshift7=xorshift7,seedrandom.xor4096=xor4096,seedrandom.tychei=tychei;var seedrandom$1=seedrandom,seedrandom_1=seedrandom$1.alea,MPRandGauss=function(){function e(e,t,r,n,o){this.mean=e,this.stdDev=t,this.dtype=r,this.nextVal=NaN,this.truncated=n,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);var a=o||Math.random();this.random=seedrandom_1(a.toString())}return e.prototype.nextValue=function(){if(!isNaN(this.nextVal)){var e=this.nextVal;return this.nextVal=NaN,e}for(var t,r,n=!1;!n;){var o=void 0,a=void 0,i=void 0;do{i=(o=2*this.random()-1)*o+(a=2*this.random()-1)*a}while(i>=1||0===i);var s=Math.sqrt(-2*Math.log(i)/i);t=this.mean+this.stdDev*o*s,r=this.mean+this.stdDev*a*s,this.truncated&&!this.isValidTruncated(t)||(n=!0)}return this.truncated&&!this.isValidTruncated(r)||(this.nextVal=this.convertValue(r)),this.convertValue(t)},e.prototype.convertValue=function(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)},e.prototype.isValidTruncated=function(e){return e<=this.upper&&e>=this.lower},e}();function clone_(e){var t=convertToTensor(e,"x","clone");return ENV.engine.runKernel(function(e){return Tensor.make(t.shape,{dataId:t.dataId},t.dtype)},{$x:t},function(e){return{$x:function(){return e.toFloat()}}})}function eye_(e,t,r,n){void 0===n&&(n="float32"),null==t&&(t=e);for(var o=buffer([e,t],n),a=e<=t?e:t,i=0;i<a;++i)o.set(1,i,i);var s=o.toTensor().as2D(e,t);if(null==r)return s;if(1===r.length)return tile(expandDims(s,0),[r[0],1,1]);if(2===r.length)return tile(expandDims(expandDims(s,0),0),[r[0],r[1],1,1]);if(3===r.length)return tile(expandDims(expandDims(expandDims(s,0),0),0),[r[0],r[1],r[2],1,1]);throw new Error("eye() currently supports only 1D and 2D batchShapes, but received "+r.length+"D.")}function randomNormal_(e,t,r,n,o){if(void 0===t&&(t=0),void 0===r&&(r=1),null!=n&&"bool"===n)throw new Error("Unsupported data type "+n);for(var a=new MPRandGauss(t,r,n,!1,o),i=buffer(e,n),s=0;s<i.values.length;s++)i.values[s]=a.nextValue();return i.toTensor()}function truncatedNormal_(e,t,r,n,o){if(void 0===t&&(t=0),void 0===r&&(r=1),null!=n&&"bool"===n)throw new Error("Unsupported data type "+n);for(var a=new MPRandGauss(t,r,n,!0,o),i=buffer(e,n),s=0;s<i.values.length;s++)i.values[s]=a.nextValue();return i.toTensor()}function randomUniform_(e,t,r,n){void 0===t&&(t=0),void 0===r&&(r=1),void 0===n&&(n="float32");for(var o=buffer(e,n),a=0;a<o.values.length;a++)o.values[a]=randUniform(t,r);return o.toTensor()}function rand_(e,t,r){var n=sizeFromShape(e),o=null;if(null==r||"float32"===r)o=new Float32Array(n);else if("int32"===r)o=new Int32Array(n);else{if("bool"!==r)throw new Error("Unknown data type "+r);o=new Uint8Array(n)}for(var a=0;a<n;a++)o[a]=t();return Tensor.make(e,{values:o},r)}function multinomial_(e,t,r,n){void 0===n&&(n=!1);var o=convertToTensor(e,"logits","multinomial"),a=o.size,i=o.rank;if(a<2)throw new Error("Error in multinomial: you need at least 2 outcomes, but got "+a+".");if(i>2)throw new Error("Rank of probabilities must be 1 or 2, but is "+i);r=r||Math.random();var s=1===i?o.as2D(1,-1):o,u=ENV.engine.runKernel(function(e){return e.multinomial(s,n,t,r)},{logits2D:s});return 1===i?u.as1D():u}function oneHot_(e,t,r,n){void 0===r&&(r=1),void 0===n&&(n=0);var o=convertToTensor(e,"indices","oneHot","int32");if(assert("int32"===o.dtype,"Indices must be of dtype `int32`"),t<2)throw new Error("Error in oneHot: depth must be >=2, but it is "+t);return ENV.engine.runKernel(function(e){return e.oneHot(o,t,r,n)},{$indices:o},function(e){return{$indices:function(){return zerosLike(o)}}})}function fromPixels_(e,t){if(void 0===t&&(t=3),t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");return ENV.engine.fromPixels(e,t)}function toPixels(e,t){return __awaiter(this,void 0,void 0,function(){var r,n,o,a,i,s,u,l,c,p,d,h,f,m,g,v,y,x,T,E;return __generator(this,function(w){switch(w.label){case 0:if(2!==(r=convertToTensor(e,"img","toPixels","int32")).rank&&3!==r.rank)throw new Error("toPixels only supports rank 2 or 3 tensors, got rank "+r.rank+".");if(n=r.shape.slice(0,2),o=n[0],a=n[1],(i=2===r.rank?1:r.shape[2])>4||2===i)throw new Error("toPixels only supports depth of size 1, 3 or 4 but got "+i);return s=r.min(),u=r.max(),[4,s.data()];case 1:return l=w.sent()[0],[4,u.data()];case 2:if(c=w.sent()[0],s.dispose(),u.dispose(),"float32"===r.dtype){if(l<0||c>1)throw new Error("Tensor values for a float32 Tensor must be in the range [0 - 1] but got range ["+l+" - "+c+"].")}else{if("int32"!==r.dtype)throw new Error("Unsupported type for toPixels: "+r.dtype+". Please use float32 or int32 tensors.");if(l<0||c>255)throw new Error("Tensor values for a int32 Tensor must be in the range [0 - 255] but got range ["+l+" - "+c+"].")}return[4,r.data()];case 3:for(p=w.sent(),d="float32"===r.dtype?255:1,h=new Uint8ClampedArray(a*o*4),f=0;f<o*a;++f)m=void 0,g=void 0,v=void 0,y=void 0,1===i?(m=p[f]*d,g=p[f]*d,v=p[f]*d,y=255):3===i?(m=p[3*f]*d,g=p[3*f+1]*d,v=p[3*f+2]*d,y=255):4===i&&(m=p[4*f]*d,g=p[4*f+1]*d,v=p[4*f+2]*d,y=p[4*f+3]*d),h[(x=4*f)+0]=Math.round(m),h[x+1]=Math.round(g),h[x+2]=Math.round(v),h[x+3]=Math.round(y);return null!=t&&(t.width=a,t.height=o,T=t.getContext("2d"),E=new ImageData(h,a,o),T.putImageData(E,0,0)),r!==e&&r.dispose(),[2,h]}})})}function reshape_(e,t){var r=convertToTensor(e,"x","reshape");t=inferFromImplicitShape(t,r.size),assert(r.size===sizeFromShape(t),"new shape and old shape must have the same number of elements.");return ENV.engine.runKernel(function(e){return e.reshape(r,t)},{$x:r},function(e){return{$x:function(){return e.reshape(r.shape)}}})}function squeeze_(e,t){var r=convertToTensor(e,"x","squeeze");return reshape(r,squeezeShape(r.shape,t).newShape)}function cast_(e,t){var r=convertToTensor(e,"x","cast");return ENV.engine.runKernel(function(e){return e.cast(r,t)},{$x:r},function(e){return{$x:function(){return e.clone()}}})}function tile_(e,t){var r=convertToTensor(e,"x","tile");assert(r.rank===t.length,"Error in transpose: rank of input "+r.rank+" must match length of reps "+t+".");return ENV.engine.runKernel(function(e){return e.tile(r,t)},{$x:r},function(e){return{$x:function(){var n=zerosLike(r);if(1===r.rank)for(var o=0;o<t[0];++o)n=n.add(e.slice([o*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(o=0;o<t[0];++o)for(var a=0;a<t[1];++a)n=n.add(e.slice([o*r.shape[0],a*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(o=0;o<t[0];++o)for(a=0;a<t[1];++a)for(var i=0;i<t[2];++i)n=n.add(e.slice([o*r.shape[0],a*r.shape[1],i*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error("Gradient for tile operation is not implemented for rank-"+r.rank+" tensors yet.");for(o=0;o<t[0];++o)for(a=0;a<t[1];++a)for(i=0;i<t[2];++i)for(var s=0;s<t[3];++s)n=n.add(e.slice([o*r.shape[0],a*r.shape[1],i*r.shape[2],s*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return n}}})}function pad1d_(e,t,r){return void 0===r&&(r=0),assert(2===t.length,"Invalid number of paddings. Must be length of 2."),pad(e,[t],r)}function pad2d_(e,t,r){return void 0===r&&(r=0),assert(2===t.length&&2===t[0].length&&2===t[1].length,"Invalid number of paddings. Must be length of 2 each."),pad(e,t,r)}function pad3d_(e,t,r){return void 0===r&&(r=0),assert(3===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length,"Invalid number of paddings. Must be length of 2 each."),pad(e,t,r)}function pad4d_(e,t,r){return void 0===r&&(r=0),assert(4===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length&&2===t[3].length,"Invalid number of paddings. Must be length of 2 each."),pad(e,t,r)}function pad_(e,t,r){void 0===r&&(r=0);var n=convertToTensor(e,"x","pad");if(0===n.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");var o=t.map(function(e){return e[0]});return ENV.engine.runKernel(function(e){return e.pad(n,t,r)},{$x:n},function(e){return{$x:function(){return e.slice(o,n.shape)}}})}function stack_(e,t){void 0===t&&(t=0);var r=convertToTensorArray(e,"tensors","stack");if(assert(r.length>=1,"Pass at least one tensor to tf.stack"),1===r.length)return r[0].expandDims(t);var n=r[0].rank,o=r[0].shape,a=r[0].dtype;assert(t<=n,"Axis must be <= rank of the tensor"),r.forEach(function(e){assertShapesMatch(o,e.shape,"All tensors passed to stack must have matching shapes")}),r.forEach(function(e){assert(a===e.dtype,"All tensors passed to stack must have matching dtypes")});var i=r.map(function(e){return e.expandDims(t)});return concat(i,t)}function batchToSpaceND_(e,t,r){var n=convertToTensor(e,"x","batchToSpaceND"),o=t.reduce(function(e,t){return e*t});assert(n.rank>=1+t.length,"input rank is "+n.rank+" but should be > than blockShape.length "+t.length),assert(r.length===t.length,"crops.length is "+r.length+" but should be equal to blockShape.length  "+t.length),assert(n.shape[0]%o==0,"input tensor batch is "+n.shape[0]+" but is not divisible by the product of the elements of blockShape "+t.join(" * ")+" === "+o);return ENV.engine.runKernel(function(e){return e.batchToSpaceND(n,t,r)},{$x:n},function(e){return{$x:function(){return e.spaceToBatchND(t,r)}}})}function spaceToBatchND_(e,t,r){var n=convertToTensor(e,"x","spaceToBatchND");assert(n.rank>=1+t.length,"input rank "+n.rank+" should be > than [blockShape] "+t.length),assert(r.length===t.length,"paddings.shape[0] "+r.length+" must be equal to [blockShape] "+t.length),assert(n.shape.reduce(function(e,n,o){return o>0&&o<=t.length?e&&(n+r[o-1][0]+r[o-1][1])%t[o-1]==0:e},!0),"input spatial dimensions "+n.shape.slice(1)+" with paddings "+r.toString()+" must be divisible by blockShapes "+t.toString());return ENV.engine.runKernel(function(e){return e.spaceToBatchND(n,t,r)},{$x:n},function(e){return{$x:function(){return e.batchToSpaceND(t,r)}}})}function unstack_(e,t){void 0===t&&(t=0);for(var r,n=convertToTensor(e,"x","unstack"),o=n.shape[t],a=Array(n.rank-1).fill(0),i=0,s=0;s<n.rank;s++)s!==t&&(a[i]=n.shape[s],i++);r=Array(o).fill(1);var u=Array(n.rank).fill(0),l=n.shape.slice();return r.map(function(e){l[t]=e;var r=n.slice(u,l);return u[t]+=e,r.reshape(a)})}function cumsum_(e,t,r,n){void 0===t&&(t=0),void 0===r&&(r=!1),void 0===n&&(n=!1);var o=convertToTensor(e,"x","cumsum"),a=getAxesPermutation([t|=0],o.rank),i=o;null!=a&&(i=o.transpose(a));var s=getInnerMostAxes(1,o.rank)[0],u=ENV.engine.runKernel(function(e){return e.cumsum(i,s,r,n)},{permutedX:i},function(e){return{permutedX:function(){return e.cumsum(t,r,!n)}}});return null!=a&&(u=u.transpose(a)),u}function expandDims_(e,t){void 0===t&&(t=0);var r=convertToTensor(e,"x","expandDims");assert(t<=r.rank,"Axis must be <= rank of the tensor");var n=r.shape.slice();return t<0&&(assert(-(r.rank+1)<=t,"Axis must be in the interval ["+-(r.rank+1)+", "+r.rank+"]"),t=r.rank+t+1),n.splice(t,0,1),reshape(r,n)}function depthToSpace_(e,t,r){void 0===r&&(r="NHWC");var n=convertToTensor(e,"x","depthToSpace"),o="NHWC"===r?n.shape[1]:n.shape[2],a="NHWC"===r?n.shape[2]:n.shape[3],i="NHWC"===r?n.shape[3]:n.shape[1];return assert(o*t>=0,"Negative dimension size caused by overflow when multiplying\n      "+o+" and "+t+"  for depthToSpace with input shape\n      "+n.shape),assert(a*t>=0,"Negative dimension size caused by overflow when multiplying\n      "+a+" and "+t+" for depthToSpace with input shape\n          "+n.shape),assert(i%(t*t)==0,"Dimension size must be evenly divisible by "+t*t+" but is "+i+" for depthToSpace with input shape "+n.shape),ENV.engine.runKernel(function(e){return e.depthToSpace(n,t,r)},{$x:n})}function setdiff1dAsync_(e,t){return __awaiter(this,void 0,void 0,function(){var r,n,o,a,i,s,u,l,c,p;return __generator(this,function(d){switch(d.label){case 0:return r=convertToTensor(e,"x","setdiff1d"),n=convertToTensor(t,"y","setdiff1d"),assert(r.dtype===n.dtype,"x and y should have the same dtype, but got x ("+r.dtype+") and y ("+n.dtype+")."),assert(1===r.rank,"x should be 1D tensor, but got x ("+r.shape+")."),assert(1===n.rank,"y should be 1D tensor, but got y ("+n.shape+")."),[4,r.data()];case 1:return o=d.sent(),[4,n.data()];case 2:for(a=d.sent(),i=new Set(a),s=0,c=0;c<o.length;c++)i.has(o[c])||s++;for(u=new TensorBuffer([s],r.dtype),l=new TensorBuffer([s],"int32"),c=0,p=0;c<o.length;c++)i.has(o[c])||(u.values[p]=o[c],l.values[p]=c,p++);return[2,[u.toTensor(),l.toTensor()]]}})})}function buffer(e,t,r){return void 0===t&&(t="float32"),new TensorBuffer(e,t,r)}function print(e,t){void 0===t&&(t=!1),console.log(e.toString(t))}var batchToSpaceND=op({batchToSpaceND_:batchToSpaceND_}),cast=op({cast_:cast_}),clone=op({clone_:clone_}),cumsum=op({cumsum_:cumsum_}),depthToSpace=op({depthToSpace_:depthToSpace_}),expandDims=op({expandDims_:expandDims_}),eye=op({eye_:eye_}),fromPixels=op({fromPixels_:fromPixels_}),multinomial=op({multinomial_:multinomial_}),oneHot=op({oneHot_:oneHot_}),pad=op({pad_:pad_}),pad1d=op({pad1d_:pad1d_}),pad2d=op({pad2d_:pad2d_}),pad3d=op({pad3d_:pad3d_}),pad4d=op({pad4d_:pad4d_}),rand=op({rand_:rand_}),randomNormal=op({randomNormal_:randomNormal_}),randomUniform=op({randomUniform_:randomUniform_}),reshape=op({reshape_:reshape_}),spaceToBatchND=op({spaceToBatchND_:spaceToBatchND_}),squeeze=op({squeeze_:squeeze_}),stack=op({stack_:stack_}),tile=op({tile_:tile_}),truncatedNormal=op({truncatedNormal_:truncatedNormal_}),unstack=op({unstack_:unstack_}),setdiff1dAsync=setdiff1dAsync_;function whereImpl(e,t){for(var r=[],n=0;n<t.length;n++)t[n]&&r.push(n);var o=buffer(e,"int32"),a=buffer([r.length,e.length],"int32");for(n=0;n<r.length;n++){var i=o.indexToLoc(r[n]),s=n*e.length;a.values.set(i,s)}return a.toTensor()}var CPU_HANDOFF_SIZE_THRESHOLD=10,BEFORE_PAGING_CONSTANT=300,MATMUL_SHARED_DIM_THRESHOLD=1e3,MathBackendWebGL=function(){function e(e,t){if(void 0===t&&(t=!0),this.gpgpu=e,this.delayedStorage=t,this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.lruDataGPU=[],this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.binaryCache={},this.disposed=!1,ENV.get("WEBGL_VERSION")<1)throw new Error("WebGL is not supported on this device");if(null==e){var r=getWebGLContext(ENV.get("WEBGL_VERSION"));this.gpgpu=new GPGPUContext(r),this.canvas=r.canvas,this.gpgpuCreatedLocally=!0}else this.gpgpuCreatedLocally=!1,this.canvas=e.gl.canvas;ENV.get("WEBGL_PAGING_ENABLED")&&(this.NUM_BYTES_BEFORE_PAGING=window.screen.height*window.screen.width*window.devicePixelRatio*BEFORE_PAGING_CONSTANT),this.textureManager=new TextureManager(this.gpgpu)}return e.prototype.register=function(e,t,r){if(this.texData.has(e))throw new Error("Data buffer is already registered");this.texData.set(e,{shape:t,dtype:r,values:null,texture:null,complexTensors:null,texShape:null,usage:TextureUsage.RENDER,isPacked:!1})},e.prototype.setDataMover=function(e){this.texData=new DataStorage(e)},e.prototype.fromPixels=function(e,t){if(null==e)throw new Error("pixels passed to tf.fromPixels() can not be null");var r=[e.height,e.width],n=[e.height,e.width,t];if(!(e instanceof HTMLVideoElement||e instanceof HTMLImageElement||e instanceof HTMLCanvasElement||e instanceof ImageData))throw new Error("pixels passed to tf.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement or ImageData, but was "+e.constructor.name);if(e instanceof HTMLVideoElement){if(null==this.fromPixels2DContext){if(!ENV.get("IS_BROWSER"))throw new Error("Can't read pixels from HTMLImageElement outside the browser.");if("complete"!==document.readyState)throw new Error("The DOM is not ready yet. Please call tf.fromPixels() once the DOM is ready. One way to do that is to add an event listener for `DOMContentLoaded` on the document object");this.fromPixels2DContext=document.createElement("canvas").getContext("2d")}this.fromPixels2DContext.canvas.width=e.width,this.fromPixels2DContext.canvas.height=e.height,this.fromPixels2DContext.drawImage(e,0,0,e.width,e.height),e=this.fromPixels2DContext.canvas}var o=this.makeTensorHandle(r,"int32");this.texData.get(o.dataId).usage=TextureUsage.PIXELS,this.gpgpu.uploadPixelDataToTexture(this.getTexture(o.dataId),e);var a=new FromPixelsProgram(n),i=this.compileAndRun(a,[o]);return this.disposeData(o.dataId),i},e.prototype.makeTensorHandle=function(e,t){var r={};return this.register(r,e,t),{dataId:r,shape:e,dtype:t}},e.prototype.write=function(e,t){if(null==t)throw new Error("MathBackendWebGL.write(): values can not be null");var r=this.texData.get(e),n=r.texture,o=r.texShape,a=r.usage,i=r.dtype,s=r.isPacked;if("complex64"===i)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");null!=n&&(this.releaseTexture(e,n,o,a,s),r.texture=null,r.texShape=null),r.usage=TextureUsage.UPLOAD,r.values=t,this.delayedStorage||this.uploadToGPU(e)},e.prototype.readSync=function(e){var t=this.texData.get(e),r=t.values,n=t.dtype,o=t.complexTensors;if(null!=r)return this.convertAndCacheOnCPU(e);var a,i,s=null!=this.activeTimers;(s&&(a=performance.now()),"complex64"===n)?i=mergeRealAndImagArrays(o.real.dataSync(),o.imag.dataSync()):i=this.getValuesFromTexture(e);return s&&(this.downloadWaitMs+=performance.now()-a),this.convertAndCacheOnCPU(e,i)},e.prototype.read=function(e){return __awaiter(this,void 0,void 0,function(){var t,r,n,o,a,i,s,u,l;return __generator(this,function(c){switch(c.label){case 0:if(this.pendingRead.has(e))return t=this.pendingRead.get(e),[2,new Promise(function(e){return t.push(e)})];if(r=this.texData.get(e),n=r.texture,o=r.values,a=r.texShape,null!=o)return[2,this.convertAndCacheOnCPU(e)];if(this.pendingRead.set(e,[]),!ENV.get("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===ENV.get("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");return i=this.gpgpu.maybeCreateBufferFromTexture(n,a[0],a[1]),[4,this.gpgpu.createAndWaitForFence()];case 1:return c.sent(),s=i instanceof WebGLTexture?this.getValuesFromTexture(e):this.gpgpu.downloadFloat32MatrixFromBuffer(i,a[0],a[1]),u=this.convertAndCacheOnCPU(e,s),l=this.pendingRead.get(e),this.pendingRead.delete(e),l.forEach(function(e){return e(u)}),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)),[2,u]}})})},e.prototype.getValuesFromTexture=function(e){var t=this.texData.get(e),r=t.shape,n=t.dtype,o=t.texture,a=t.texShape;if(ENV.get("WEBGL_DOWNLOAD_FLOAT_ENABLED")){if(this.texData.get(e).isPacked){var i=sizeFromShape(r.slice(0,r.length-2)),s=r.length>1?r[r.length-2]:1,u=r[r.length-1];return this.gpgpu.downloadMatrixFromPackedTexture(o,i,s,u,a[0],a[1])}return this.gpgpu.downloadFloat32MatrixFromOutputTexture(o,a[0],a[1])}var l=this.makeTensorHandle(r,"float32");l.size=sizeFromShape(r),this.texData.get(l.dataId).usage=TextureUsage.DOWNLOAD;var c=new EncodeFloatProgram(r);this.compileAndRun(c,[{shape:r,dtype:n,dataId:e}],l,null,!1);var p=this.texData.get(l.dataId),d=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(p.texture,p.texShape[0],p.texShape[1]);return this.disposeData(l.dataId),d},e.prototype.time=function(e){return __awaiter(this,void 0,void 0,function(){var t,r,n,o,a,i,s;return __generator(this,function(u){switch(u.label){case 0:return t=this.activeTimers,r=[],n=!1,null==this.programTimersStack?(this.programTimersStack=r,n=!0):this.activeTimers.push(r),this.activeTimers=r,e(),o=flatten(this.activeTimers.map(function(e){return e.query})).filter(function(e){return null!=e}),a=flatten(this.activeTimers.map(function(e){return e.name})).filter(function(e){return null!=e}),this.activeTimers=t,n&&(this.programTimersStack=null),[4,Promise.all(o)];case 1:return i=u.sent(),s={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:sum(i),getExtraProfileInfo:function(){return i.map(function(e,t){return{name:a[t],ms:e}}).map(function(e){return e.name+": "+e.ms}).join(", ")},wallMs:null},this.uploadWaitMs=0,this.downloadWaitMs=0,[2,s]}})})},e.prototype.memory=function(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU}},e.prototype.startTimer=function(){return ENV.get("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?this.gpgpu.beginQuery():{startMs:performance.now(),endMs:null}},e.prototype.endTimer=function(e){return ENV.get("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(this.gpgpu.endQuery(),e):(e.endMs=performance.now(),e)},e.prototype.getQueryTime=function(e){return __awaiter(this,void 0,void 0,function(){var t;return __generator(this,function(r){return ENV.get("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?[2,this.gpgpu.waitForQueryAndGetTime(e)]:[2,(t=e).endMs-t.startMs]})})},e.prototype.disposeData=function(e){if(!this.pendingDisposal.has(e))if(this.pendingRead.has(e))this.pendingDisposal.add(e);else if(this.texData.has(e)){var t=this.texData.get(e),r=t.texture,n=t.texShape,o=t.usage,a=t.complexTensors,i=t.isPacked;null!=r&&this.releaseTexture(e,r,n,o,i),null!=a&&(a.real.dispose(),a.imag.dispose()),this.texData.delete(e)}},e.prototype.getTexture=function(e){return this.uploadToGPU(e),this.texData.get(e).texture},e.prototype.getCPUBackend=function(){return ENV.get("WEBGL_CPU_FORWARD")?(null==this.cpuBackend&&(this.cpuBackend=ENV.findBackend("cpu")),this.cpuBackend):null},e.prototype.shouldExecuteOnCPU=function(e,t){var r=this;return void 0===t&&(t=CPU_HANDOFF_SIZE_THRESHOLD),null!=this.getCPUBackend()&&e.every(function(e){return null==r.texData.get(e.dataId).texture&&e.size<t})},e.prototype.getGPGPUContext=function(){return this.gpgpu},e.prototype.getCanvas=function(){return this.canvas},e.prototype.complex=function(e,t){var r=this.makeOutputArray(e.shape,"complex64");return this.texData.get(r.dataId).complexTensors={real:ENV.engine.keep(e.clone()),imag:ENV.engine.keep(t.clone())},r},e.prototype.real=function(e){return this.texData.get(e.dataId).complexTensors.real.clone()},e.prototype.imag=function(e){return this.texData.get(e.dataId).complexTensors.imag.clone()},e.prototype.slice=function(e,t,r){if(this.shouldExecuteOnCPU([e]))return this.cpuBackend.slice(e,t,r);var n=new SliceProgram(r),o=n.getCustomSetupFunc(t);return this.compileAndRun(n,[e],null,o)},e.prototype.stridedSlice=function(e,t,r,n,o,a,i,s,u){if(this.shouldExecuteOnCPU([e]))return this.cpuBackend.stridedSlice(e,t,r,n,o,a,i,s,u);var l=getStridedSlicedInfo(e.shape,t,r,n,o,a,i,s,u),c=l[0],p=l[1],d=l[2],h=p.filter(function(e,t){return-1===d.indexOf(t)});if(h.some(function(e){return 0===e}))return tensor([],h);var f=new StridedSliceProgram(c,n,p,d);return this.compileAndRun(f,[e])},e.prototype.reverse=function(e,t){var r=new ReverseProgram(e.shape,t);return this.compileAndRun(r,[e])},e.prototype.concat2Tensors=function(e,t,r){var n=computeOutShape([e.shape,t.shape],r),o=e.as2D(-1,sizeFromShape(e.shape.slice(r))),a=t.as2D(-1,sizeFromShape(t.shape.slice(r))),i=new ConcatProgram(o.shape,a.shape);return this.compileAndRun(i,[o,a]).reshape(n)},e.prototype.concat=function(e,t){if(this.shouldExecuteOnCPU(e))return this.cpuBackend.concat(e,t);if(1===e.length)return e[0];for(var r=e[0],n=1;n<e.length;++n)r=this.concat2Tensors(r,e[n],t);return r},e.prototype.neg=function(e){var t=new UnaryOpProgram(e.shape,NEG);return this.compileAndRun(t,[e])},e.prototype.batchMatMul=function(e,t,r,n){var o=r?e.shape[2]:e.shape[1],a=n?t.shape[1]:t.shape[2],i=r?e.shape[1]:e.shape[2],s=e.shape[0];if((1===o||1===a)&&i>MATMUL_SHARED_DIM_THRESHOLD){r&&(e=e.transpose([0,2,1])),n&&(t=t.transpose([0,2,1]));var u=1===a?e:e.as3D(s,i,1),l=1===a?2:1,c=1===a?t.as3D(s,1,i):t;return this.multiply(u,c).sum(l,!0)}if(1===s){var p=e.as2D(e.shape[1],e.shape[2]),d=t.as2D(t.shape[1],t.shape[2]),h=new MatMulPackedProgram(p.shape,d.shape,[o,a],r,n),f=this.compileAndRun(h,[p,d],this.makePackedTensor(h.outputShape));return!1===ENV.get("WEBGL_LAZILY_UNPACK")&&(f=this.unpackTensor(f)),f.reshape([1,f.shape[0],f.shape[1]])}return this.compileAndRun(new MatMulProgram(e.shape,t.shape,r,n),[e,t])},e.prototype.multiply=function(e,t){if("complex64"===e.dtype){var r=this.texData.get(e.dataId),n=this.texData.get(t.dataId),o=new BinaryOpComplexProgram(COMPLEX_MULTIPLY.REAL,e.shape,t.shape),a=new BinaryOpComplexProgram(COMPLEX_MULTIPLY.IMAG,e.shape,t.shape),i=[this.makeComplexComponentTensorHandle(e,r.complexTensors.real),this.makeComplexComponentTensorHandle(e,r.complexTensors.imag),this.makeComplexComponentTensorHandle(t,n.complexTensors.real),this.makeComplexComponentTensorHandle(t,n.complexTensors.imag)],s=this.compileAndRun(o,i),u=this.compileAndRun(a,i),l=this.complex(s,u);return s.dispose(),u.dispose(),l}if(this.shouldExecuteOnCPU([e,t]))return this.cpuBackend.multiply(e,t);var c=new BinaryOpProgram(MUL,e.shape,t.shape),p=this.makeOutputArray(c.outputShape,e.dtype);return this.compileAndRun(c,[e,t],p)},e.prototype.batchNormalization=function(e,t,r,n,o,a){var i=[e,t,r],s=null;null!=a&&(s=a.shape,i.push(a));var u=null;null!=o&&(u=o.shape,i.push(o));var l=null,c=BatchNormProgram;ENV.get("WEBGL_PACK_BATCHNORMALIZATION")&&(l=this.makePackedTensor(e.shape),c=BatchNormPackedProgram);var p=new c(e.shape,t.shape,r.shape,s,u,n);return this.compileAndRun(p,i,l)},e.prototype.localResponseNormalization4D=function(e,t,r,n,o){var a=new LRNProgram(e.shape,t,r,n,o);return this.compileAndRun(a,[e])},e.prototype.LRNGrad=function(e,t,r,n,o,a,i){var s=new LRNGradProgram(t.shape,n,o,a,i);return this.compileAndRun(s,[t,r,e])},e.prototype.tile=function(e,t){var r=new TileProgram(e.shape,t);return this.compileAndRun(r,[e])},e.prototype.pad=function(e,t,r){var n=new PadProgram(e.shape,t,r);return this.compileAndRun(n,[e])},e.prototype.transpose=function(e,t){var r=new TransposeProgram(e.shape,t);return this.compileAndRun(r,[e])},e.prototype.gather=function(e,t,r){var n=new GatherProgram(e.shape,t.size,r);return this.compileAndRun(n,[e,t])},e.prototype.batchToSpaceND=function(e,t,r){assert(e.rank<=4,"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");var n=t.reduce(function(e,t){return e*t}),o=getReshaped(e.shape,t,n),a=getPermuted(o.length,t.length),i=getReshapedPermuted(e.shape,t,n),s=getSliceBeginCoords(r,t.length),u=getSliceSize(i,r,t.length);return e.reshape(o).transpose(a).reshape(i).slice(s,u)},e.prototype.spaceToBatchND=function(e,t,r){assert(e.rank<=4,"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");var n=t.reduce(function(e,t){return e*t}),o=[[0,0]];o.push.apply(o,r);for(var a=1+t.length;a<e.shape.length;++a)o.push([0,0]);var i=e.pad(o),s=getReshaped(i.shape,t,n,!1),u=getPermuted(s.length,t.length,!1),l=getReshapedPermuted(i.shape,t,n,!1);return i.reshape(s).transpose(u).reshape(l)},e.prototype.reduce=function(e,t,r){var n=e.shape[0],o=e.shape[1],a=computeOptimalWindowSize(o),i=new ReduceProgram({windowSize:a,inSize:o,batchSize:n},t),s=i.outputShape,u=s[0],l=s[1],c=this.makeOutputArray([u,l],r);return this.compileAndRun(i,[e],c),1===c.shape[1]?c:this.reduce(c,t,r)},e.prototype.argReduce=function(e,t,r){void 0===r&&(r=null);var n=e.shape[0],o=e.shape[1];null!=r&&(n=r.shape[0],o=r.shape[1]);var a=computeOptimalWindowSize(o),i=new ArgMinMaxProgram({windowSize:a,inSize:o,batchSize:n},t,null==r),s=i.outputShape,u=s[0],l=s[1],c=this.makeOutputArray([u,l],"int32"),p=[e];return null!=r&&p.push(r),this.compileAndRun(i,p,c),1===c.shape[1]?c:this.argReduce(e,t,c)},e.prototype.sum=function(e,t){assertAxesAreInnerMostDims("sum",t,e.rank);var r=computeOutAndReduceShapes(e.shape,t),n=r[0],o=sizeFromShape(r[1]),a=e.as2D(-1,o),i=sumOutType(e.dtype);return this.reduce(a,"sum",i).reshape(n)},e.prototype.prod=function(e,t){var r=computeOutAndReduceShapes(e.shape,t),n=r[0],o=sizeFromShape(r[1]),a=e.as2D(-1,o),i=sumOutType(e.dtype);return this.reduce(a,"prod",i).reshape(n)},e.prototype.unsortedSegmentSum=function(e,t,r){var n=0,o=getAxesPermutation([n],e.rank),a=e;null!=o&&(a=e.transpose(o),n=getInnerMostAxes(1,e.rank)[0]);var i=computeOutShape$1(a.shape,n,r),s=sizeFromShape([a.shape[n]]),u=a.as2D(-1,s),l=sumOutType(e.dtype),c=this.segOpCompute(u,"unsortedSegmentSum",t,l,r).reshape(i);return null!=o&&(c=c.transpose(getUndoAxesPermutation(o))),c},e.prototype.segOpCompute=function(e,t,r,n,o){var a=e.shape[0],i=e.shape[1],s=segOpComputeOptimalWindowSize(i,o),u=new SegmentOpProgram({windowSize:s,inSize:i,batchSize:a,numSegments:o},t),l=u.outputShape,c=l[0],p=l[1],d=this.makeOutputArray([c,p],n);return this.compileAndRun(u,[e,r],d),d.shape[1]===o?d:(r=range(0,o).tile([i/s]),this.segOpCompute(d,t,r,n,o))},e.prototype.argMin=function(e,t){var r=[t];assertAxesAreInnerMostDims("argMin",r,e.rank);var n=computeOutAndReduceShapes(e.shape,r),o=n[0],a=sizeFromShape(n[1]),i=e.as2D(-1,a);return this.argReduce(i,"min").reshape(o)},e.prototype.argMax=function(e,t){var r=[t];assertAxesAreInnerMostDims("argMax",r,e.rank);var n=computeOutAndReduceShapes(e.shape,r),o=n[0],a=sizeFromShape(n[1]),i=e.as2D(-1,a);return this.argReduce(i,"max").reshape(o)},e.prototype.cumsum=function(e,t,r,n){if(t!==e.rank-1)throw new Error("WebGL cumsum shader expects an inner-most axis="+(e.rank-1)+" but got axis="+t);var o=new CumSumProgram(e.shape,r,n);return this.compileAndRun(o,[e])},e.prototype.equal=function(e,t){var r=new BinaryOpProgram(EQUAL,e.shape,t.shape),n=this.makeOutputArray(r.outputShape,"bool");return this.compileAndRun(r,[e,t],n)},e.prototype.notEqual=function(e,t){var r=new BinaryOpProgram(NOT_EQUAL,e.shape,t.shape),n=this.makeOutputArray(r.outputShape,"bool");return this.compileAndRun(r,[e,t],n)},e.prototype.less=function(e,t){if(this.shouldExecuteOnCPU([e,t]))return this.cpuBackend.less(e,t);var r=new BinaryOpProgram(LESS,e.shape,t.shape),n=this.makeOutputArray(r.outputShape,"bool");return this.compileAndRun(r,[e,t],n)},e.prototype.lessEqual=function(e,t){var r=new BinaryOpProgram(LESS_EQUAL,e.shape,t.shape),n=this.makeOutputArray(r.outputShape,"bool");return this.compileAndRun(r,[e,t],n)},e.prototype.greater=function(e,t){if(this.shouldExecuteOnCPU([e,t]))return this.cpuBackend.greater(e,t);var r=new BinaryOpProgram(GREATER,e.shape,t.shape),n=this.makeOutputArray(r.outputShape,"bool");return this.compileAndRun(r,[e,t],n)},e.prototype.greaterEqual=function(e,t){var r=new BinaryOpProgram(GREATER_EQUAL,e.shape,t.shape),n=this.makeOutputArray(r.outputShape,"bool");return this.compileAndRun(r,[e,t],n)},e.prototype.logicalNot=function(e){var t=new UnaryOpProgram(e.shape,LOGICAL_NOT);return this.compileAndRun(t,[e])},e.prototype.logicalAnd=function(e,t){var r=new BinaryOpProgram(LOGICAL_AND,e.shape,t.shape),n=this.makeOutputArray(r.outputShape,"bool");return this.compileAndRun(r,[e,t],n)},e.prototype.logicalOr=function(e,t){var r=new BinaryOpProgram(LOGICAL_OR,e.shape,t.shape),n=this.makeOutputArray(r.outputShape,"bool");return this.compileAndRun(r,[e,t],n)},e.prototype.select=function(e,t,r){var n=new SelectProgram(e.rank,t.shape,t.rank),o=this.makeOutputArray(n.outputShape,upcastType(t.dtype,r.dtype));return this.compileAndRun(n,[e,t,r],o)},e.prototype.where=function(e){warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");var t=e.dataSync();return whereImpl(e.shape,t)},e.prototype.topk=function(e,t,r){return topkImpl(e.dataSync(),e.shape,e.dtype,t,r)},e.prototype.min=function(e,t){assertAxesAreInnerMostDims("min",t,e.rank);var r=computeOutAndReduceShapes(e.shape,t),n=r[0],o=sizeFromShape(r[1]),a=e.as2D(-1,o);return this.reduce(a,"min",a.dtype).reshape(n)},e.prototype.minimum=function(e,t){if(this.shouldExecuteOnCPU([e,t]))return this.cpuBackend.minimum(e,t);var r=new BinaryOpProgram(MIN,e.shape,t.shape);return this.compileAndRun(r,[e,t])},e.prototype.mod=function(e,t){var r=new BinaryOpProgram(MOD,e.shape,t.shape),n=r.getCustomSetupFunc();return this.compileAndRun(r,[e,t],null,n)},e.prototype.max=function(e,t){assertAxesAreInnerMostDims("max",t,e.rank);var r=computeOutAndReduceShapes(e.shape,t),n=r[0],o=sizeFromShape(r[1]),a=e.as2D(-1,o);return this.reduce(a,"max",a.dtype).reshape(n)},e.prototype.maximum=function(e,t){if(this.shouldExecuteOnCPU([e,t]))return this.cpuBackend.maximum(e,t);var r=new BinaryOpProgram(MAX,e.shape,t.shape);return this.compileAndRun(r,[e,t])},e.prototype.all=function(e,t){assertAxesAreInnerMostDims("all",t,e.rank);var r=computeOutAndReduceShapes(e.shape,t),n=r[0],o=sizeFromShape(r[1]),a=e.as2D(-1,o);return this.reduce(a,"all",a.dtype).reshape(n)},e.prototype.any=function(e,t){assertAxesAreInnerMostDims("any",t,e.rank);var r=computeOutAndReduceShapes(e.shape,t),n=r[0],o=sizeFromShape(r[1]),a=e.as2D(-1,o);return this.reduce(a,"any",a.dtype).reshape(n)},e.prototype.squaredDifference=function(e,t){var r=new BinaryOpProgram(SQUARED_DIFFERENCE,e.shape,t.shape);return this.compileAndRun(r,[e,t])},e.prototype.realDivide=function(e,t){var r=new BinaryOpProgram(DIV,e.shape,t.shape),n=this.makeOutputArray(r.outputShape,"float32");return this.compileAndRun(r,[e,t],n)},e.prototype.floorDiv=function(e,t){var r=new BinaryOpProgram(INT_DIV,e.shape,t.shape),n=this.makeOutputArray(r.outputShape,"int32");return this.compileAndRun(r,[e,t],n)},e.prototype.add=function(e,t){if("complex64"===e.dtype&&"complex64"===t.dtype)return this.complexSeparableBinaryOp(e,t,ADD);var r=new BinaryOpProgram(ADD,e.shape,t.shape),n=this.makeOutputArray(r.outputShape,upcastType(e.dtype,t.dtype));return this.compileAndRun(r,[e,t],n)},e.prototype.complexSeparableBinaryOp=function(e,t,r){var n=this,o=this.texData.get(e.dataId),a=this.texData.get(t.dataId),i=[[o.complexTensors.real,a.complexTensors.real],[o.complexTensors.imag,a.complexTensors.imag]].map(function(o){var a=o[0],i=o[1],s=new BinaryOpProgram(r,e.shape,t.shape),u=n.makeOutputArray(s.outputShape,upcastType(a.dtype,i.dtype)),l=n.makeComplexComponentTensorHandle(e,a),c=n.makeComplexComponentTensorHandle(t,i);return n.compileAndRun(s,[l,c],u)}),s=i[0],u=i[1],l=this.complex(s,u);return s.dispose(),u.dispose(),l},e.prototype.makeComplexComponentTensorHandle=function(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}},e.prototype.addN=function(e){for(var t=e[0],r=1;r<e.length;r++)t=this.add(t,e[r]);return t},e.prototype.subtract=function(e,t){if("complex64"===e.dtype&&"complex64"===t.dtype)return this.complexSeparableBinaryOp(e,t,SUB);if(this.shouldExecuteOnCPU([e,t]))return this.cpuBackend.subtract(e,t);var r=new BinaryOpProgram(SUB,e.shape,t.shape),n=this.makeOutputArray(r.outputShape,upcastType(e.dtype,t.dtype));return this.compileAndRun(r,[e,t],n)},e.prototype.pow=function(e,t){var r=new BinaryOpProgram(POW,e.shape,t.shape),n=r.getCustomSetupFunc(),o=this.makeOutputArray(r.outputShape,upcastType(e.dtype,t.dtype));return this.compileAndRun(r,[e,t],o,n)},e.prototype.ceil=function(e){var t=new UnaryOpProgram(e.shape,CEIL);return this.compileAndRun(t,[e])},e.prototype.floor=function(e){var t=new UnaryOpProgram(e.shape,FLOOR);return this.compileAndRun(t,[e])},e.prototype.sign=function(e){var t=new UnaryOpProgram(e.shape,SIGN);return this.compileAndRun(t,[e])},e.prototype.round=function(e){var t=new UnaryOpProgram(e.shape,ROUND);return this.compileAndRun(t,[e])},e.prototype.exp=function(e){var t=new UnaryOpProgram(e.shape,EXP);return this.compileAndRun(t,[e])},e.prototype.expm1=function(e){var t=new UnaryOpProgram(e.shape,EXPM1);return this.compileAndRun(t,[e])},e.prototype.log=function(e){var t=new UnaryOpProgram(e.shape,LOG),r=t.getCustomSetupFunc();return this.compileAndRun(t,[e],null,r)},e.prototype.log1p=function(e){var t=new UnaryOpProgram(e.shape,LOG1P);return this.compileAndRun(t,[e])},e.prototype.sqrt=function(e){var t=new UnaryOpProgram(e.shape,SQRT);return this.compileAndRun(t,[e])},e.prototype.rsqrt=function(e){var t=new UnaryOpProgram(e.shape,RSQRT);return this.compileAndRun(t,[e])},e.prototype.square=function(e){var t=new UnaryOpProgram(e.shape,SQUARE);return this.compileAndRun(t,[e])},e.prototype.reciprocal=function(e){var t=new UnaryOpProgram(e.shape,RECIPROCAL);return this.compileAndRun(t,[e])},e.prototype.relu=function(e){var t=new UnaryOpProgram(e.shape,RELU);return this.compileAndRun(t,[e])},e.prototype.elu=function(e){var t=new UnaryOpProgram(e.shape,ELU);return this.compileAndRun(t,[e])},e.prototype.eluDer=function(e,t){var r=new BinaryOpProgram(ELU_DER,e.shape,t.shape);return this.compileAndRun(r,[e,t])},e.prototype.selu=function(e){var t=new UnaryOpProgram(e.shape,SELU);return this.compileAndRun(t,[e])},e.prototype.int=function(e){var t=new UnaryOpProgram(e.shape,TO_INT),r=this.makeOutputArray(t.outputShape,"int32");return this.compileAndRun(t,[e],r)},e.prototype.clip=function(e,t,r){var n=new ClipProgram(e.shape,t,r);return this.compileAndRun(n,[e])},e.prototype.abs=function(e){var t=new UnaryOpProgram(e.shape,ABS);return this.compileAndRun(t,[e])},e.prototype.complexAbs=function(e){var t=this.texData.get(e.dataId),r=new ComplexAbsProgram(e.shape),n=[this.makeComplexComponentTensorHandle(e,t.complexTensors.real),this.makeComplexComponentTensorHandle(e,t.complexTensors.imag)];return this.compileAndRun(r,n)},e.prototype.sigmoid=function(e){var t=new UnaryOpProgram(e.shape,SIGMOID);return this.compileAndRun(t,[e])},e.prototype.softplus=function(e){var t=new UnaryOpProgram(e.shape,SOFTPLUS);return this.compileAndRun(t,[e])},e.prototype.sin=function(e){var t=new UnaryOpProgram(e.shape,SIN);return this.compileAndRun(t,[e])},e.prototype.cos=function(e){var t=new UnaryOpProgram(e.shape,COS);return this.compileAndRun(t,[e])},e.prototype.tan=function(e){var t=new UnaryOpProgram(e.shape,TAN);return this.compileAndRun(t,[e])},e.prototype.asin=function(e){var t=new UnaryOpProgram(e.shape,ASIN);return this.compileAndRun(t,[e])},e.prototype.acos=function(e){var t=new UnaryOpProgram(e.shape,ACOS);return this.compileAndRun(t,[e])},e.prototype.atan=function(e){var t=new UnaryOpProgram(e.shape,ATAN);return this.compileAndRun(t,[e])},e.prototype.atan2=function(e,t){var r=new BinaryOpProgram(ATAN2,e.shape,t.shape);return this.compileAndRun(r,[e,t])},e.prototype.sinh=function(e){var t=new UnaryOpProgram(e.shape,SINH);return this.compileAndRun(t,[e])},e.prototype.cosh=function(e){var t=new UnaryOpProgram(e.shape,COSH);return this.compileAndRun(t,[e])},e.prototype.tanh=function(e){var t=new UnaryOpProgram(e.shape,TANH);return this.compileAndRun(t,[e])},e.prototype.asinh=function(e){var t=new UnaryOpProgram(e.shape,ASINH);return this.compileAndRun(t,[e])},e.prototype.acosh=function(e){var t=new UnaryOpProgram(e.shape,ACOSH),r=t.getCustomSetupFunc();return this.compileAndRun(t,[e],null,r)},e.prototype.atanh=function(e){var t=new UnaryOpProgram(e.shape,ATANH),r=t.getCustomSetupFunc();return this.compileAndRun(t,[e],null,r)},e.prototype.erf=function(e){var t=new UnaryOpProgram(e.shape,ERF);return this.compileAndRun(t,[e])},e.prototype.step=function(e,t){var r=new UnaryOpProgram(e.shape,STEP(t));return this.compileAndRun(r,[e])},e.prototype.conv2dWithIm2Row=function(e,t,r){var n=r.filterWidth,o=r.filterHeight,a=r.inChannels,i=r.outWidth,s=r.outHeight,u=n*o*a,l=s*i,c=[u,l],p=e.squeeze([0]),d=t.reshape([u,-1]),h=new Im2ColProgram(c,p.shape,r),f=this.compileAndRun(h,[p],this.makePackedTensor(c)),m=new MatMulPackedProgram(f.shape,d.shape,[l,r.outChannels],!0,!1),g=this.compileAndRun(m,[f,d],this.makePackedTensor(m.outputShape));return!1===ENV.get("WEBGL_LAZILY_UNPACK")&&(g=this.unpackTensor(g)),g.reshape([1,s,i,r.outChannels])},e.prototype.conv2d=function(e,t,r){if(ENV.get("WEBGL_CONV_IM2COL")&&1===e.shape[0])return this.conv2dWithIm2Row(e,t,r);var n=new Conv2DProgram(r);return this.compileAndRun(n,[e,t])},e.prototype.conv2dDerInput=function(e,t,r){var n=new Conv2DDerInputProgram(r);return this.compileAndRun(n,[e,t])},e.prototype.conv2dDerFilter=function(e,t,r){var n=new Conv2DDerFilterProgram(r);return this.compileAndRun(n,[e,t])},e.prototype.depthwiseConv2D=function(e,t,r){var n=new DepthwiseConv2DProgram(r);return this.compileAndRun(n,[e,t])},e.prototype.depthwiseConv2DDerInput=function(e,t,r){var n=new DepthwiseConv2DDerInputProgram(r);return this.compileAndRun(n,[e,t])},e.prototype.depthwiseConv2DDerFilter=function(e,t,r){var n=new DepthwiseConv2DDerFilterProgram(r);return this.compileAndRun(n,[e,t])},e.prototype.maxPool=function(e,t){var r=new Pool2DProgram(t,"max",!1),n=this.makeOutputArray(r.outputShape,e.dtype);return this.compileAndRun(r,[e],n)},e.prototype.avgPool=function(e,t){var r=new Pool2DProgram(t,"avg",!1),n=this.makeOutputArray(r.outputShape,"float32");return this.compileAndRun(r,[e],n)},e.prototype.maxPoolBackprop=function(e,t,r,n){var o=new Pool2DProgram(n,"max",!0),a=this.compileAndRun(o,[t]),i=new MaxPool2DBackpropProgram(n),s=this.makeOutputArray(i.outputShape,t.dtype),u=this.compileAndRun(i,[e,a],s);return a.dispose(),u},e.prototype.avgPoolBackprop=function(e,t,r){var n=new AvgPool2DBackpropProgram(r),o=this.makeOutputArray(n.outputShape,t.dtype);return this.compileAndRun(n,[e],o)},e.prototype.cast=function(e,t){return castTensor(e,t,this)},e.prototype.reshape=function(e,t){return this.texData.get(e.dataId).isPacked&&!isReshapeFree(e.shape,t)?this.packedReshape(e,t):reshapeTensor(e,t)},e.prototype.resizeBilinear=function(e,t,r,n){var o=new ResizeBilinearProgram(e.shape,t,r,n);return this.compileAndRun(o,[e])},e.prototype.resizeBilinearBackprop=function(e,t,r){var n=new ResizeBilinearBackpropProgram(e,t,r);return this.compileAndRun(n,[e])},e.prototype.resizeNearestNeighbor=function(e,t,r,n){var o=new ResizeNearestNeighborProgram(e.shape,t,r,n);return this.compileAndRun(o,[e])},e.prototype.resizeNearestNeighborBackprop=function(e,t,r){var n=new ResizeNearestNeigborBackpropProgram(e,t,r);return this.compileAndRun(n,[e])},e.prototype.multinomial=function(e,t,r,n){var o=t?e:softmax(e),a=o.shape[0],i=o.shape[1],s=new MultinomialProgram(a,i,r),u=this.makeOutputArray(s.outputShape,"int32"),l=s.getCustomSetupFunc(n);return this.compileAndRun(s,[o],u,l)},e.prototype.oneHot=function(e,t,r,n){var o=new OneHotProgram(e.size,t,r,n);return this.compileAndRun(o,[e])},e.prototype.nonMaxSuppression=function(e,t,r,n,o){return warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead"),nonMaxSuppressionImpl(e.dataSync(),t.dataSync(),r,n,o)},e.prototype.cropAndResize=function(e,t,r,n,o,a){var i=new CropAndResizeProgram(e.shape,t.shape,n,o,a);return this.compileAndRun(i,[e,t,r])},e.prototype.depthToSpace=function(e,t,r){assert(t>1,"blockSize should be > 1 for depthToSpace, but was: "+t);var n=e.shape[0],o=("NHWC"===r?e.shape[1]:e.shape[2])*t,a=("NHWC"===r?e.shape[2]:e.shape[3])*t,i=("NHWC"===r?e.shape[3]:e.shape[1])/(t*t),s=new DepthToSpaceProgram("NHWC"===r?[n,o,a,i]:[n,i,o,a],t,r);return this.compileAndRun(s,[e])},e.prototype.split=function(e,t,r){return split(e,t,r)},e.prototype.scatterND=function(e,t,r){var n=calculateShapes(t,e,r),o=n.sliceRank,a=n.numUpdates,i=n.sliceSize,s=n.strides,u=n.outputSize,l=[u/i,i],c=e.reshape([a,o]),p=t.reshape([a,i]);if(0===u)return reshapeTensor(tensor([]),r);var d=scalar(0),h=new ScatterProgram(a,o,c.rank,p.rank,s,l);return this.compileAndRun(h,[p,c,d]).reshape(r)},e.prototype.sparseToDense=function(e,t,r,n){var o=calculateShapes(t,e,r),a=o.sliceRank,i=o.numUpdates,s=o.strides,u=o.outputSize,l=new ScatterProgram(i,a,e.rank,t.rank,s,[u,1],!1);return this.compileAndRun(l,[t,e,n]).reshape(r)},e.prototype.fft=function(e){return this.fftImpl(e,!1)},e.prototype.ifft=function(e){return this.fftImpl(e,!0)},e.prototype.fftImpl=function(e,t){var r=this.texData.get(e.dataId),n=new FFTProgram(COMPLEX_FFT.REAL,e.shape,t),o=new FFTProgram(COMPLEX_FFT.IMAG,e.shape,t),a=[this.makeComplexComponentTensorHandle(e,r.complexTensors.real),this.makeComplexComponentTensorHandle(e,r.complexTensors.imag)],i=this.compileAndRun(n,a),s=this.compileAndRun(o,a),u=this.complex(i,s).as2D(e.shape[0],e.shape[1]);return i.dispose(),s.dispose(),u},e.prototype.gatherND=function(e,t){var r=t.shape,n=r[r.length-1],o=prepareAndValidate(e,t),a=o[0],i=o[1],s=o[2],u=o[3],l=t.reshape([i,n]),c=e.reshape([e.size/s,s]),p=new GatherNDProgram(n,u,[i,s]);return this.compileAndRun(p,[c,l]).reshape(a)},e.prototype.makeOutputArray=function(e,t){return Tensor.make(e,{},t)},e.prototype.makePackedTensor=function(e){var t=Tensor.make(e,{});return this.texData.get(t.dataId).isPacked=!0,t},e.prototype.unpackTensor=function(e){var t=new UnpackProgram(e.shape);return this.compileAndRun(t,[e])},e.prototype.getBatchDim=function(e,t){return void 0===t&&(t=2),sizeFromShape(e.slice(0,e.length-t))},e.prototype.getRowsCols=function(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]},e.prototype.packedReshape=function(e,t){var r=e.reshape([this.getBatchDim(e.shape)].concat(this.getRowsCols(e.shape))),n=[this.getBatchDim(t)].concat(this.getRowsCols(t)),o=new ReshapePackedProgram(n,r.shape);return this.compileAndRun(o,[r],this.makePackedTensor(n)).reshape(t)},e.prototype.compileAndRun=function(e,t,r,n,o){var a=this;if(void 0===o&&(o=!0),null==r&&(r=this.makeOutputArray(e.outputShape,t[0].dtype)),0===r.size)return this.texData.get(r.dataId).values=getTypedArrayFromDType(r.dtype,0),r;var i=t.map(function(t){if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");var r=a.texData.get(t.dataId);if(null==r.texture&&(r.isPacked||!e.usesPackedTextures)&&sizeFromShape(t.shape)<=ENV.get("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:a.readSync(t.dataId)};if(r.isPacked!==!!e.usesPackedTextures){var n=void 0,o=void 0;r.isPacked?(n=new UnpackProgram(t.shape),o=a.compileAndRun(n,[t])):(n=new PackProgram(t.shape),o=a.compileAndRun(n,[t],a.makePackedTensor(t.shape))),r=a.texData.get(o.dataId),t=o}return a.uploadToGPU(t.dataId),{shape:t.shape,texData:r,isUniform:!1}});this.uploadToGPU(r.dataId);var s,u={shape:r.shape,texData:this.texData.get(r.dataId),isUniform:!1},l=makeShaderKey(e,i,u),c=this.getAndSaveBinary(l,function(){return compileProgram(a.gpgpu,e,i,u)}),p=null!=this.activeTimers;if(p&&(s=this.startTimer()),runProgram(c,i,u,n),ENV.get("WEBGL_PAGING_ENABLED")&&o&&this.numBytesInGPU>this.NUM_BYTES_BEFORE_PAGING)for(var d=this.numBytesInGPU-this.NUM_BYTES_BEFORE_PAGING;d>0&&this.lruDataGPU.length>0;){var h=this.lruDataGPU.shift(),f=this.texData.get(h),m=f.shape,g=f.dtype;d-=this.computeBytes(m,g),this.read(h)}return p&&(s=this.endTimer(s),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(s)})),r},e.prototype.getAndSaveBinary=function(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]},e.prototype.getTextureManager=function(){return this.textureManager},e.prototype.dispose=function(){if(!this.disposed){for(var e in this.binaryCache)this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram);this.textureManager.dispose(),this.canvas.remove(),null!=this.fromPixels2DContext&&this.fromPixels2DContext.canvas.remove(),this.gpgpuCreatedLocally&&this.gpgpu.dispose(),this.disposed=!0}},e.prototype.floatPrecision=function(){var e=this;return tidy(function(){return e.abs(scalar(1e-8)).get()>0?32:16})},e.prototype.uploadToGPU=function(e){var t=this.texData.get(e),r=t.shape,n=t.values,o=t.texture,a=t.dtype,i=t.usage,s=t.isPacked;if(null==o){var u,l=null!=this.activeTimers;l&&(u=performance.now());var c=getTextureShapeFromLogicalShape(r,s);t.texShape=c;var p=this.acquireTexture(e,c,i,s);if(t.texture=p,null!=n){if(s){var d=sizeFromShape(r.slice(0,r.length-2)),h=r.length>1?r[r.length-2]:1,f=r[r.length-1];this.gpgpu.uploadMatrixToPackedTexture(p,d,h,f,typedArrayToFloat32(n,a))}else this.gpgpu.uploadMatrixToTexture(p,c[0],c[1],typedArrayToFloat32(n,a));t.values=null,l&&(this.uploadWaitMs+=performance.now()-u)}}else{ENV.get("WEBGL_PAGING_ENABLED")&&this.lruDataGPU.indexOf(e)>=0&&(this.lruDataGPU.splice(this.lruDataGPU.indexOf(e),1),this.lruDataGPU.push(e))}},e.prototype.convertAndCacheOnCPU=function(e,t){var r=this.delayedStorage,n=this.texData.get(e),o=n.texture,a=n.texShape,i=n.dtype,s=n.usage,u=n.isPacked;return r&&null!=o&&(this.releaseTexture(e,o,a,s,u),n.texture=null,n.texShape=null),n.usage=TextureUsage.UPLOAD,null!=t&&(n.values=float32ToTypedArray(t,i)),n.values},e.prototype.releaseTexture=function(e,t,r,n,o){var a=this.texData.get(e),i=a.shape,s=a.dtype;if(ENV.get("WEBGL_PAGING_ENABLED")){var u=this.lruDataGPU.indexOf(e);u>=0&&this.lruDataGPU.splice(u,1)}this.numBytesInGPU-=this.computeBytes(i,s),this.textureManager.releaseTexture(t,r,n,o)},e.prototype.acquireTexture=function(e,t,r,n){var o=this.texData.get(e),a=o.shape,i=o.dtype;return ENV.get("WEBGL_PAGING_ENABLED")&&this.lruDataGPU.push(e),this.numBytesInGPU+=this.computeBytes(a,i),this.textureManager.acquireTexture(t,r,n)},e.prototype.computeBytes=function(e,t){return sizeFromShape(e)*bytesPerElement(t)},e}();function float32ToTypedArray(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){for(var r="int32"===t?new Int32Array(e.length):new Uint8Array(e.length),n=0;n<r.length;++n)r[n]=Math.round(e[n]);return r}throw new Error("Unknown dtype "+t)}function typedArrayToFloat32(e,t){return e instanceof Float32Array?e:new Float32Array(e)}function neg_(e){var t=convertToTensor(e,"x","neg");return ENV.engine.runKernel(function(e){return e.neg(t)},{$x:t},function(e){return{$x:function(){return e.neg()}}})}function ceil_(e){var t=convertToTensor(e,"x","ceil");return ENV.engine.runKernel(function(e){return e.ceil(t)},{$x:t},function(e){return{$x:function(){return zerosLike(e)}}})}function floor_(e){var t=convertToTensor(e,"x","floor");return ENV.engine.runKernel(function(e){return e.floor(t)},{$x:t},function(e){return{$x:function(){return zerosLike(e)}}})}function sign_(e){var t=convertToTensor(e,"x","sign");return ENV.engine.runKernel(function(e){return e.sign(t)},{$x:t},function(e){return{$x:function(){return zerosLike(e)}}})}function round_(e){var t=convertToTensor(e,"x","round");return ENV.engine.runKernel(function(e){return e.round(t)},{$x:t},function(e){return{$x:function(){return zerosLike(e)}}})}function exp_(e){var t=convertToTensor(e,"x","exp");return ENV.engine.runKernel(function(e,r){return r(e.exp(t))},{$x:t},function(e,t){var r=t[0];return{$x:function(){return e.mulStrict(r)}}})}function expm1_(e){var t=convertToTensor(e,"x","expm1");return ENV.engine.runKernel(function(e){return e.expm1(t)},{$x:t},function(e){return{$x:function(){return e.mulStrict(t.exp())}}})}function log_(e){var t=convertToTensor(e,"x","log");return ENV.engine.runKernel(function(e){return e.log(t)},{$x:t},function(e){return{$x:function(){return e.divStrict(t.toFloat())}}})}function log1p_(e){var t=convertToTensor(e,"x","log1p");return ENV.engine.runKernel(function(e){return e.log1p(t)},{$x:t},function(e){return{$x:function(){return e.divStrict(t.add(scalar(1)))}}})}function sqrt_(e){var t=convertToTensor(e,"x","sqrt");return ENV.engine.runKernel(function(e){return e.sqrt(t)},{$x:t},function(e){return{$x:function(){return e.divStrict(t.toFloat().sqrt().mul(scalar(2)))}}})}function rsqrt_(e){var t=convertToTensor(e,"x","rsqrt");return ENV.engine.runKernel(function(e){return e.rsqrt(t)},{$x:t},function(e){return{$x:function(){return e.divStrict(t.pow(scalar(1.5)).mul(scalar(2))).neg()}}})}function square_(e){var t=convertToTensor(e,"x","square");return ENV.engine.runKernel(function(e){return e.square(t)},{$x:t},function(e){return{$x:function(){return e.mulStrict(t.toFloat().mul(scalar(2)))}}})}function reciprocal_(e){var t=convertToTensor(e,"x","reciprocal");return ENV.engine.runKernel(function(e){return e.reciprocal(t)},{$x:t},function(e){return{$x:function(){return e.divStrict(t.square().neg())}}})}function abs_(e){var t=convertToTensor(e,"x","abs");if("complex64"===t.dtype)return ENV.engine.runKernel(function(e){return e.complexAbs(t)},{$x:t});return ENV.engine.runKernel(function(e){return e.abs(t)},{$x:t},function(e){return{$x:function(){return e.mulStrict(t.toFloat().step(-1))}}})}function clipByValue_(e,t,r){var n=convertToTensor(e,"x","clipByValue");assert(t<=r,"Error in clip: min ("+t+") must be less than or equal to max ("+r+").");return ENV.engine.runKernel(function(e){return e.clip(n,t,r)},{$x:n},function(e){return{$x:function(){return e.where(n.greaterEqual(scalar(t)).logicalAnd(n.lessEqual(scalar(r))),zerosLike(e))}}})}function sigmoid_(e){var t=convertToTensor(e,"x","sigmoid");return ENV.engine.runKernel(function(e,r){return r(e.sigmoid(t))},{$x:t},function(e,t){var r=t[0];return{$x:function(){return e.mulStrict(r.mul(scalar(1).sub(r)))}}})}function logSigmoid_(e){var t=convertToTensor(e,"x","logSigmoid");return ENV.engine.runKernel(function(e){return e.softplus(t.neg()).neg()},{$x:t},function(e){return{$x:function(){return e.mulStrict(t.neg().sigmoid())}}})}function softplus_(e){var t=convertToTensor(e,"x","softplus");return ENV.engine.runKernel(function(e){return e.softplus(t)},{$x:t},function(e){return{$x:function(){return e.mulStrict(t.sigmoid())}}})}function sin_(e){var t=convertToTensor(e,"x","sin");return ENV.engine.runKernel(function(e){return e.sin(t)},{$x:t},function(e){return{$x:function(){return t.toFloat().cos().mulStrict(e)}}})}function cos_(e){var t=convertToTensor(e,"x","cos");return ENV.engine.runKernel(function(e){return e.cos(t)},{$x:t},function(e){return{$x:function(){return t.toFloat().sin().neg().mulStrict(e)}}})}function tan_(e){var t=convertToTensor(e,"x","tan");return ENV.engine.runKernel(function(e){return e.tan(t)},{$x:t},function(e){return{$x:function(){return e.divStrict(t.cos().square())}}})}function asin_(e){var t=convertToTensor(e,"x","asin");return ENV.engine.runKernel(function(e){return e.asin(t)},{$x:t},function(e){return{$x:function(){return e.divStrict(scalar(1).sub(t.toFloat().square()).sqrt())}}})}function acos_(e){var t=convertToTensor(e,"x","acos");return ENV.engine.runKernel(function(e){return e.acos(t)},{$x:t},function(e){return{$x:function(){return e.divStrict(scalar(1).sub(t.toFloat().square()).sqrt()).neg()}}})}function atan_(e){var t=convertToTensor(e,"x","atan");return ENV.engine.runKernel(function(e){return e.atan(t)},{$x:t},function(e){return{$x:function(){return e.divStrict(scalar(1).add(t.toFloat().square()))}}})}function sinh_(e){var t=convertToTensor(e,"x","sinh");return ENV.engine.runKernel(function(e){return e.sinh(t)},{$x:t},function(e){return{$x:function(){return t.toFloat().cosh().mulStrict(e)}}})}function cosh_(e){var t=convertToTensor(e,"x","cosh");return ENV.engine.runKernel(function(e){return e.cosh(t)},{$x:t},function(e){return{$x:function(){return t.toFloat().sinh().mulStrict(e)}}})}function tanh_(e){var t=convertToTensor(e,"x","tanh");return ENV.engine.runKernel(function(e,r){return r(e.tanh(t))},{$x:t},function(e,t){var r=t[0];return{$x:function(){return scalar(1).sub(r.square()).mulStrict(e)}}})}function asinh_(e){var t=convertToTensor(e,"x","asinh");return ENV.engine.runKernel(function(e){return e.asinh(t)},{$x:t},function(e){return{$x:function(){return e.divStrict(scalar(1).add(t.toFloat().square()).sqrt())}}})}function acosh_(e){var t=convertToTensor(e,"x","acosh");return ENV.engine.runKernel(function(e){return e.acosh(t)},{$x:t},function(e){return{$x:function(){return e.divStrict(t.toFloat().square().sub(scalar(1)).sqrt())}}})}function atanh_(e){var t=convertToTensor(e,"x","atanh");return ENV.engine.runKernel(function(e){return e.atanh(t)},{$x:t},function(e){return{$x:function(){return e.divStrict(scalar(1).sub(t.toFloat().square()))}}})}function erf_(e){var t=convertToTensor(e,"x","erf");assert("int32"===t.dtype||"float32"===t.dtype,"Input dtype must be `int32` or `float32`."),"int32"===t.dtype&&(t=t.toFloat());return ENV.engine.runKernel(function(e){return e.erf(t)},{$x:t},function(e){return{$x:function(){return e.mulStrict(scalar(2/Math.sqrt(Math.PI)).mul(t.square().neg().exp()))}}})}function step_(e,t){void 0===t&&(t=0);var r=convertToTensor(e,"x","step");return ENV.engine.runKernel(function(e){return e.step(r,t)},{$x:r},function(e){return{$x:function(){return zerosLike(e)}}})}ENV.get("IS_BROWSER")&&ENV.registerBackend("webgl",function(){return new MathBackendWebGL},2,setTensorTracker);var abs=op({abs_:abs_}),acos=op({acos_:acos_}),acosh=op({acosh_:acosh_}),asin=op({asin_:asin_}),asinh=op({asinh_:asinh_}),atan=op({atan_:atan_}),atanh=op({atanh_:atanh_}),ceil=op({ceil_:ceil_}),clipByValue=op({clipByValue_:clipByValue_}),cos=op({cos_:cos_}),cosh=op({cosh_:cosh_}),erf=op({erf_:erf_}),exp=op({exp_:exp_}),expm1=op({expm1_:expm1_}),floor=op({floor_:floor_}),log$1=op({log_:log_}),log1p=op({log1p_:log1p_}),logSigmoid=op({logSigmoid_:logSigmoid_}),neg=op({neg_:neg_}),reciprocal=op({reciprocal_:reciprocal_}),round=op({round_:round_}),rsqrt=op({rsqrt_:rsqrt_}),sigmoid=op({sigmoid_:sigmoid_}),sign=op({sign_:sign_}),sin=op({sin_:sin_}),sinh=op({sinh_:sinh_}),softplus=op({softplus_:softplus_}),sqrt=op({sqrt_:sqrt_}),square=op({square_:square_}),step=op({step_:step_}),tan=op({tan_:tan_}),tanh$1=op({tanh_:tanh_});function batchNormalization2d_(e,t,r,n,o,a){void 0===n&&(n=.001);var i,s,u=convertToTensor(e,"x","batchNormalization"),l=convertToTensor(t,"mean","batchNormalization"),c=convertToTensor(r,"variance","batchNormalization");return null!=o&&(i=convertToTensor(o,"scale","batchNormalization")),null!=a&&(s=convertToTensor(a,"offset","batchNormalization")),assert(2===u.rank,"Error in batchNormalization3D: x must be rank 3 but got rank "+u.rank+"."),assert(2===l.rank||1===l.rank,"Error in batchNormalization2D: mean must be rank 2 or rank 1 but got rank "+l.rank+"."),assert(2===c.rank||1===c.rank,"Error in batchNormalization2D: variance must be rank 2 or rank 1 but got rank "+c.rank+"."),null!=i&&assert(2===i.rank||1===i.rank,"Error in batchNormalization2D: scale must be rank 2 or rank 1 but got rank "+i.rank+"."),null!=s&&assert(2===s.rank||1===s.rank,"Error in batchNormalization2D: offset must be rank 2 or rank 1 but got rank "+s.rank+"."),batchNormalization(u,l,c,n,i,s)}function batchNormalization3d_(e,t,r,n,o,a){void 0===n&&(n=.001);var i,s,u=convertToTensor(e,"x","batchNormalization"),l=convertToTensor(t,"mean","batchNormalization"),c=convertToTensor(r,"variance","batchNormalization");return null!=o&&(i=convertToTensor(o,"scale","batchNormalization")),null!=a&&(s=convertToTensor(a,"offset","batchNormalization")),assert(3===u.rank,"Error in batchNormalization3D: x must be rank 3 but got rank "+u.rank+"."),assert(3===l.rank||1===l.rank,"Error in batchNormalization3D: mean must be rank 3 or rank 1 but got rank "+l.rank+"."),assert(3===c.rank||1===c.rank,"Error in batchNormalization3D: variance must be rank 3 or rank 1 but got rank "+c.rank+"."),null!=i&&assert(3===i.rank||1===i.rank,"Error in batchNormalization3D: scale must be rank 3 or rank 1 but got rank "+i.rank+"."),null!=s&&assert(3===s.rank||1===s.rank,"Error in batchNormalization3D: offset must be rank 3 or rank 1 but got rank "+s.rank+"."),batchNormalization(u,l,c,n,i,s)}function batchNormalization4d_(e,t,r,n,o,a){void 0===n&&(n=.001);var i,s,u=convertToTensor(e,"x","batchNormalization"),l=convertToTensor(t,"mean","batchNormalization"),c=convertToTensor(r,"variance","batchNormalization");return null!=o&&(i=convertToTensor(o,"scale","batchNormalization")),null!=a&&(s=convertToTensor(a,"offset","batchNormalization")),assert(4===u.rank,"Error in batchNormalization4D: x must be rank 4 but got rank "+u.rank+"."),assert(4===l.rank||1===l.rank,"Error in batchNormalization4D: mean must be rank 4 or rank 1 but got rank "+l.rank+"."),assert(4===c.rank||1===c.rank,"Error in batchNormalization4D: variance must be rank 4 or rank 1 but got rank "+c.rank+"."),null!=i&&assert(4===i.rank||1===i.rank,"Error in batchNormalization4D: scale must be rank 4 or rank 1 but got rank "+i.rank+"."),null!=s&&assert(4===s.rank||1===s.rank,"Error in batchNormalization4D: offset must be rank 4 or rank 1 but got rank "+s.rank+"."),batchNormalization(u,l,c,n,i,s)}function batchNormalization_(e,t,r,n,o,a){void 0===n&&(n=.001);var i,s,u,l=convertToTensor(e,"x","batchNormalization"),c=convertToTensor(t,"mean","batchNormalization"),p=convertToTensor(r,"variance","batchNormalization");null!=o&&(i=convertToTensor(o,"scale","batchNormalization")),null!=a&&(s=convertToTensor(a,"offset","batchNormalization")),assert(c.rank===p.rank,"Batch normalization gradient requires mean and variance to have equal ranks."),assert(null==s||c.rank===s.rank,"Batch normalization gradient requires mean and offset to have equal ranks."),assert(null==i||c.rank===i.rank,"Batch normalization gradient requires mean and scale to have equal ranks."),u=0===l.rank||1===l.rank?l.as4D(1,1,1,l.size):2===l.rank?l.as4D(1,1,l.shape[0],l.shape[1]):3===l.rank?l.as4D(1,l.shape[0],l.shape[1],l.shape[2]):l;return ENV.engine.runKernel(function(e){return e.batchNormalization(u,batchnormReshape4D(c),batchnormReshape4D(p),n,batchnormReshape4D(i),batchnormReshape4D(s))},{$x:l,$mean:c,$variance:p,$scale:i,$offset:s},function(e){var t=null==i?scalar(1):i,r=getReductionAxes(c.shape,u.shape),o=[];if(1===c.rank){for(var a=0;a<u.shape.length-1;++a)o.push(u.shape[a]);o.push(1)}var s=l.sub(c),d=e.mul(t),h=rsqrt(p.add(scalar(n))),f=h.mul(h).mul(h).mul(scalar(-.5));return{$x:function(){return 1===c.rank?e.mul(tile(h.as4D(1,1,1,c.shape[0]),o)).mul(t).reshape(l.shape):e.mul(h).mul(t).reshape(l.shape)},$mean:function(){var e=h.mul(scalar(-1)).mul(d);return 1===c.rank&&(e=e.sum(r)),e.reshape(c.shape)},$variance:function(){var e=f.mul(s).mul(d);return 1===c.rank&&(e=e.sum(r)),e.reshape(c.shape)},$scale:function(){var t=s.mul(h),n=e.mul(t);return 1===c.rank&&(n=n.sum(r)),n.reshape(c.shape)},$offset:function(){var t=e;return 1===c.rank&&(t=t.sum(r)),t.reshape(c.shape)}}}).reshape(l.shape)}function batchnormReshape4D(e){return null==e?null:0===e.rank?e.as1D():1===e.rank?e:2===e.rank?e.as4D(1,1,e.shape[0],e.shape[1]):3===e.rank?e.as4D(1,e.shape[0],e.shape[1],e.shape[2]):e}var batchNormalization2d=op({batchNormalization2d_:batchNormalization2d_}),batchNormalization3d=op({batchNormalization3d_:batchNormalization3d_}),batchNormalization4d=op({batchNormalization4d_:batchNormalization4d_}),batchNormalization=op({batchNormalization_:batchNormalization_});function computePool2DInfo(e,t,r,n,o,a,i){void 0===i&&(i="channelsLast");var s,u=parseTupleParam(t),l=u[0],c=u[1];if("channelsLast"===i)s=[l,c,e[3],e[3]];else{if("channelsFirst"!==i)throw new Error("Unknown dataFormat "+i);s=[l,c,e[1],e[1]]}return computeConv2DInfo(e,s,r,n,o,a,!1,i)}function computeConv2DInfo(e,t,r,n,o,a,i,s){void 0===i&&(i=!1),void 0===s&&(s="channelsLast");var u=[-1,-1,-1,-1],l=u[0],c=u[1],p=u[2],d=u[3];if("channelsLast"===s)l=e[0],c=e[1],p=e[2],d=e[3];else{if("channelsFirst"!==s)throw new Error("Unknown dataFormat "+s);l=e[0],d=e[1],c=e[2],p=e[3]}var h,f=t[0],m=t[1],g=t[3],v=parseTupleParam(r),y=v[0],x=v[1],T=parseTupleParam(n),E=T[0],w=T[1],S=getEffectiveFilterSize(f,E),b=getEffectiveFilterSize(m,w),C=getPadAndOutInfo(o,c,p,y,x,S,b,a),_=C.padInfo,A=C.outHeight,N=C.outWidth,R=i?g*d:g;return"channelsFirst"===s?h=[l,R,A,N]:"channelsLast"===s&&(h=[l,A,N,R]),{batchSize:l,dataFormat:s,inHeight:c,inWidth:p,inChannels:d,outHeight:A,outWidth:N,outChannels:R,padInfo:_,strideHeight:y,strideWidth:x,filterHeight:f,filterWidth:m,effectiveFilterHeight:S,effectiveFilterWidth:b,dilationHeight:E,dilationWidth:w,inShape:e,outShape:h,filterShape:t}}function computeOutputShape3D(e,t,r,n,o,a){null==o&&(o=computeDefaultPad(e,t,n));var i=e[0],s=e[1],u=conditionalRound((i-t+2*o)/n+1,a);assert(isInt(u),"The output # of rows ("+u+") must be an integer. Change the stride and/or zero pad parameters");var l=conditionalRound((s-t+2*o)/n+1,a);return assert(isInt(l),"The output # of columns ("+l+") must be an integer. Change the stride and/or zero pad parameters"),[u,l,r]}function computeDefaultPad(e,t,r,n){void 0===n&&(n=1);var o=getEffectiveFilterSize(t,n);return Math.floor((e[0]*(r-1)-r+o)/2)}function parseTupleParam(e){return"number"==typeof e?[e,e]:e}function getEffectiveFilterSize(e,t){return t<=1?e:e+(e-1)*(t-1)}function getPadAndOutInfo(e,t,r,n,o,a,i,s){var u,l,c;if("number"==typeof e){u={top:e,bottom:e,left:e,right:e,type:0===e?"VALID":"NUMBER"};var p=computeOutputShape3D([t,r,1],a,1,n,e,s);l=p[0],c=p[1]}else if("same"===e){var d=((l=Math.ceil(t/n))-1)*n+a-t,h=((c=Math.ceil(r/o))-1)*o+i-r,f=Math.floor(d/2),m=d-f,g=Math.floor(h/2);u={top:f,bottom:m,left:g,right:h-g,type:"SAME"}}else{if("valid"!==e)throw Error("Unknown padding parameter: "+e);u={top:0,bottom:0,left:0,right:0,type:"VALID"},l=Math.ceil((t-a+1)/n),c=Math.ceil((r-i+1)/o)}return{padInfo:u,outHeight:l,outWidth:c}}function conditionalRound(e,t){if(!t)return e;switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error("Unknown roundingMode "+t)}}function tupleValuesAreOne(e){var t=parseTupleParam(e),r=t[0],n=t[1];return 1===r&&1===n}function eitherStridesOrDilationsAreOne(e,t){return tupleValuesAreOne(e)||tupleValuesAreOne(t)}function matMul_(e,t,r,n){void 0===r&&(r=!1),void 0===n&&(n=!1);var o=convertToTensor(e,"a","matMul"),a=convertToTensor(t,"b","matMul"),i=r?o.shape[o.rank-2]:o.shape[o.rank-1],s=n?a.shape[a.rank-1]:a.shape[a.rank-2],u=r?o.shape[o.rank-1]:o.shape[o.rank-2],l=n?a.shape[a.rank-2]:a.shape[a.rank-1],c=o.shape.slice(0,-2),p=a.shape.slice(0,-2),d=sizeFromShape(c),h=sizeFromShape(p);assert(o.rank>=2&&a.rank>=2&&o.rank===a.rank,"Error in matMul: inputs must have the same rank of at least 2, got ranks "+o.rank+" and "+a.rank+"."),assert(arraysEqual(c,p),"Error in matMul: outer dimensions ("+c+") and ("+p+") of Tensors with shapes "+o.shape+" and "+a.shape+" must match."),assert(i===s,"Error in matMul: inner shapes ("+i+") and ("+s+") of Tensors with shapes "+o.shape+" and "+a.shape+" and transposeA="+r+" and transposeB="+n+" must match.");var f=o.shape.slice(0,-2).concat([u,l]),m=r?o.as3D(d,i,u):o.as3D(d,u,i),g=n?a.as3D(h,l,s):a.as3D(h,s,l);return ENV.engine.runKernel(function(e){return e.batchMatMul(m,g,r,n)},{$a:m,$b:g},function(e){return r||n?!r&&n?{$a:function(){return e.matMul(g.toFloat(),!1,!1)},$b:function(){return e.matMul(m.toFloat(),!0,!1)}}:r&&!n?{$a:function(){return g.toFloat().matMul(e,!1,!0)},$b:function(){return m.toFloat().matMul(e,!1,!1)}}:{$a:function(){return g.toFloat().matMul(e,!0,!0)},$b:function(){return e.matMul(m.toFloat(),!0,!0)}}:{$a:function(){return e.matMul(g.toFloat(),!1,!0)},$b:function(){return m.toFloat().matMul(e,!0,!1)}}}).reshape(f)}function outerProduct_(e,t){var r=convertToTensor(e,"v1","outerProduct"),n=convertToTensor(t,"v2","outerProduct");return assert(1===r.rank&&1===n.rank,"Error in outerProduct: inputs must be rank 1, but got ranks "+r.rank+" and "+n.rank+"."),r.as2D(-1,1).matMul(n.as2D(1,-1))}function dot_(e,t){var r=convertToTensor(e,"t1","dot"),n=convertToTensor(t,"t2","dot");assert(!(1!==r.rank&&2!==r.rank||1!==n.rank&&2!==n.rank),"Error in dot: inputs must all be rank 1 or 2, but got ranks "+r.rank+" and "+n.rank+".");var o=1===r.rank?r.size:r.shape[1],a=1===n.rank?n.size:n.shape[0];return assert(o===a,"Error in dot: inner dimensions of inputs must match, but got "+o+" and "+a+"."),1===r.rank&&1===n.rank?r.as2D(1,-1).matMul(n.as2D(-1,1)).asScalar():1===r.rank&&2===n.rank?r.as2D(1,-1).matMul(n.as2D(n.shape[0],n.shape[1])).as1D():2===r.rank&&1===n.rank?r.matMul(n.as2D(-1,1)).as1D():r.matMul(n.as2D(n.shape[0],n.shape[1]))}var matMul=op({matMul_:matMul_}),dot=op({dot_:dot_}),outerProduct=op({outerProduct_:outerProduct_});function conv1d_(e,t,r,n,o,a,i){void 0===o&&(o="NWC"),void 0===a&&(a=1);var s=convertToTensor(e,"x","conv1d"),u=convertToTensor(t,"filter","conv1d"),l=s,c=!1;2===s.rank&&(c=!0,l=s.as3D(1,s.shape[0],s.shape[1])),assert(3===l.rank,"Error in conv1d: input must be rank 3, but got rank "+l.rank+"."),assert(3===u.rank,"Error in conv1d: filter must be rank 3, but got rank "+u.rank+"."),null!=i&&assert(isInt(n),"Error in conv1d: pad must be an integer when using, dimRoundingMode "+i+" but got pad "+n+"."),assert(l.shape[2]===u.shape[1],"Error in conv1d: depth of input ("+l.shape[2]+") must match input depth for filter "+u.shape[1]+"."),assert(eitherStridesOrDilationsAreOne(r,a),"Error in conv1D: Either stride or dilation must be 1. Got stride "+r+" and dilation '"+a+"'"),assert("NWC"===o,"Error in conv1d: got dataFormat of "+o+" but only NWC is currently supported.");var p=u.as4D(1,u.shape[0],u.shape[1],u.shape[2]),d=l.as4D(l.shape[0],1,l.shape[1],l.shape[2]),h=conv2d(d,p,[1,r],n,"NHWC",[1,a],i);return c?h.as2D(h.shape[2],h.shape[3]):h.as3D(h.shape[0],h.shape[2],h.shape[3])}function conv2d_(e,t,r,n,o,a,i){void 0===o&&(o="NHWC"),void 0===a&&(a=[1,1]);var s=convertToTensor(e,"x","conv2d"),u=convertToTensor(t,"filter","conv2d"),l=s,c=!1;3===s.rank&&(c=!0,l=s.as4D(1,s.shape[0],s.shape[1],s.shape[2])),assert(4===l.rank,"Error in conv2d: input must be rank 4, but got rank "+l.rank+"."),assert(4===u.rank,"Error in conv2d: filter must be rank 4, but got rank "+u.rank+"."),null!=i&&assert(isInt(n),"Error in conv2d: pad must be an integer when using, dimRoundingMode "+i+" but got pad "+n+"."),assert(l.shape[3]===u.shape[2],"Error in conv2d: depth of input ("+l.shape[3]+") must match input depth for filter "+u.shape[2]+"."),assert(eitherStridesOrDilationsAreOne(r,a),"Error in conv2D: Either strides or dilations must be 1. Got strides "+r+" and dilations '"+a+"'"),assert("NHWC"===o,"Error in conv2d: got dataFormat of "+o+" but only NHWC is currently supported.");var p,d=computeConv2DInfo(l.shape,u.shape,r,a,n,i);if(1!==d.filterHeight||1!==d.filterWidth||1!==d.dilationHeight||1!==d.dilationWidth||1!==d.strideHeight||1!==d.strideWidth||"SAME"!==d.padInfo.type&&"VALID"!==d.padInfo.type){p=ENV.engine.runKernel(function(e){return e.conv2d(l,u,d)},{x:l,$filter:u},function(e){return assert(tupleValuesAreOne(a),"Error in gradient of conv2D: dilation rates greater than 1 are notyet supported in gradients. Got dilations '"+a+"'"),{x:function(){return conv2dDerInput_(l.shape,e,u,r,n)},$filter:function(){return conv2dDerFilter_(l,e,u.shape,r,n)}}})}else{var h=l.reshape([-1,d.inChannels]),f=u.reshape([d.inChannels,d.outChannels]);p=matMul(h,f).reshape(d.outShape)}return c?p.as3D(p.shape[1],p.shape[2],p.shape[3]):p}function conv2dDerInput_(e,t,r,n,o,a){assert(e.length===t.rank,"Length of inShape ("+e.length+") and rank of dy ("+t.rank+") must match");var i=e,s=t,u=!1;3===t.rank&&(u=!0,s=t.as4D(1,t.shape[0],t.shape[1],t.shape[2]),i=[1,e[0],e[1],e[2]]);var l=i[3],c=s.shape[3];assert(4===i.length,"Error in conv2dDerInput: inShape must be length 4, but got length "+i.length+"."),assert(4===s.rank,"Error in conv2dDerInput: dy must be rank 4, but got rank "+s.rank),assert(4===r.rank,"Error in conv2dDerInput: filter must be rank 4, but got rank "+r.rank),assert(l===r.shape[2],"Error in conv2dDerInput: depth of input ("+l+") must match input depth for filter "+r.shape[2]+"."),assert(c===r.shape[3],"Error in conv2dDerInput: depth of output ("+c+") must match output depth for filter "+r.shape[3]+"."),null!=a&&assert(isInt(o),"Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode "+a+" but got pad "+o+".");var p=computeConv2DInfo(i,r.shape,n,1,o,a),d=ENV.engine.runKernel(function(e){return e.conv2dDerInput(s,r,p)},{dy4D:s,filter:r},function(e){return{dy4D:function(){return conv2d(e,r,n,o,"NHWC",1,a)},filter:function(){return conv2dDerFilter(e,s,r.shape,n,o,a)}}});return u?d.as3D(d.shape[1],d.shape[2],d.shape[3]):d}function conv2dDerFilter_(e,t,r,n,o,a){var i=e;3===e.rank&&(i=e.as4D(1,e.shape[0],e.shape[1],e.shape[2]));var s=t;3===s.rank&&(s=t.as4D(1,t.shape[0],t.shape[1],t.shape[2])),assert(4===i.rank,"Error in conv2dDerFilter: input must be rank 4, but got shape "+i.shape+"."),assert(4===s.rank,"Error in conv2dDerFilter: dy must be rank 4, but got shape "+s.shape+"."),assert(4===r.length,"Error in conv2dDerFilter: filterShape must be length 4, but got "+r+"."),assert(i.shape[3]===r[2],"Error in conv2dDerFilter: depth of input "+i.shape[3]+") must match input depth in filter ("+r[2]+"."),assert(s.shape[3]===r[3],"Error in conv2dDerFilter: depth of dy ("+s.shape[3]+") must match output depth for filter ("+r[3]+")."),null!=a&&assert(isInt(o),"Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode "+a+" but got pad "+o+".");var u=computeConv2DInfo(i.shape,r,n,1,o,a);return ENV.engine.runKernel(function(e){return e.conv2dDerFilter(i,s,u)},{x4D:i,dy4D:s})}function conv2dTranspose_(e,t,r,n,o,a){return conv2dDerInput_(r,convertToTensor(e,"x","conv2dTranspose"),convertToTensor(t,"filter","conv2dTranspose"),n,o,a)}function depthwiseConv2d_(e,t,r,n,o,a,i){void 0===o&&(o="NHWC"),void 0===a&&(a=[1,1]);var s=convertToTensor(e,"x","depthwiseConv2d"),u=convertToTensor(t,"filter","depthwiseConv2d"),l=s,c=!1;3===s.rank&&(c=!0,l=s.as4D(1,s.shape[0],s.shape[1],s.shape[2])),assert(4===l.rank,"Error in depthwiseConv2d: input must be rank 4, but got rank "+l.rank+"."),assert(4===u.rank,"Error in depthwiseConv2d: filter must be rank 4, but got rank "+u.rank+"."),assert(l.shape[3]===u.shape[2],"Error in depthwiseConv2d: number of input channels ("+l.shape[3]+") must match the inChannels dimension in filter "+u.shape[2]+"."),null==a&&(a=[1,1]),assert(eitherStridesOrDilationsAreOne(r,a),"Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides "+r+" and dilations '"+a+"'"),null!=i&&assert(isInt(n),"Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode "+i+" but got pad "+n+".");var p=computeConv2DInfo(l.shape,u.shape,r,a,n,i,!0),d=ENV.engine.runKernel(function(e){return e.depthwiseConv2D(l,u,p)},{x:l,$filter:u},function(e){return assert(tupleValuesAreOne(a),"Error in gradient of depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '"+a+"'"),{x:function(){return depthwiseConv2dDerInput(l.shape,e,u,p)},$filter:function(){return depthwiseConv2dDerFilter(l,e,u.shape,p)}}});return c?d.as3D(d.shape[1],d.shape[2],d.shape[3]):d}function separableConv2d_(e,t,r,n,o,a,i){void 0===a&&(a=[1,1]),void 0===i&&(i="NHWC");var s=convertToTensor(e,"x","separableConv2d"),u=convertToTensor(t,"depthwiseFilter","separableConv2d"),l=convertToTensor(r,"pointwiseFilter","separableConv2d"),c=s,p=!1;if(3===s.rank&&(p=!0,c=s.as4D(1,s.shape[0],s.shape[1],s.shape[2])),"NCHW"===i)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");assert(4===c.rank,"Error in separableConv2d: input must be rank 4, but got rank "+c.rank+"."),assert(4===u.rank,"Error in separableConv2d: depthwise filter must be rank 4, but got rank "+u.rank+"."),assert(4===l.rank,"Error in separableConv2d: pointwise filter must be rank 4, but got rank "+u.rank+"."),assert(1===l.shape[0],"Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got "+l.shape[0]+"."),assert(1===l.shape[1],"Error in separableConv2d: the second dimension of pointwise filter  must be 1, but got "+l.shape[1]+".");var d=u.shape[2],h=u.shape[3];assert(l.shape[2]===d*h,"Error in separableConv2d: the third dimension of pointwise filter must be "+d*h+", but got "+l.shape[2]+".");var f=depthwiseConv2d(c,u,n,o,i,a),m=conv2d(f,l,1,"valid",i);return p?m.as3D(m.shape[1],m.shape[2],m.shape[3]):m}function depthwiseConv2dDerInput(e,t,r,n){var o=t,a=!1;3===t.rank&&(a=!0,o=t.as4D(1,t.shape[0],t.shape[1],t.shape[2]));var i=ENV.engine.runKernel(function(e){return e.depthwiseConv2DDerInput(o,r,n)},{dy4D:o});return a?i.as3D(i.shape[1],i.shape[2],i.shape[3]):i}function depthwiseConv2dDerFilter(e,t,r,n){var o=e;3===e.rank&&(o=e.as4D(1,e.shape[0],e.shape[1],e.shape[2]));var a=t;return 3===a.rank&&(a=t.as4D(1,t.shape[0],t.shape[1],t.shape[2])),ENV.engine.runKernel(function(e){return e.depthwiseConv2DDerFilter(o,a,n)},{x4D:o,dy4D:a})}var conv1d=op({conv1d_:conv1d_}),conv2d=op({conv2d_:conv2d_}),conv2dDerFilter=op({conv2dDerFilter_:conv2dDerFilter_}),depthwiseConv2d=op({depthwiseConv2d_:depthwiseConv2d_}),separableConv2d=op({separableConv2d_:separableConv2d_}),conv2dTranspose=op({conv2dTranspose_:conv2dTranspose_});function reverse1d_(e){var t=convertToTensor(e,"x","reverse");return assert(1===t.rank,"Error in reverse1D: x must be rank 1 but got\n             rank "+t.rank+"."),reverse(t,0)}function reverse2d_(e,t){var r=convertToTensor(e,"x","reverse");return assert(2===r.rank,"Error in reverse2D: x must be rank 2 but got\n             rank "+r.rank+"."),reverse(r,t)}function reverse3d_(e,t){var r=convertToTensor(e,"x","reverse");return assert(3===r.rank,"Error in reverse3D: x must be rank 3 but got\n             rank "+r.rank+"."),reverse(r,t)}function reverse4d_(e,t){var r=convertToTensor(e,"x","reverse");return assert(4===r.rank,"Error in reverse4D: x must be rank 4 but got\n             rank "+r.rank+"."),reverse(r,t)}function reverse_(e,t){var r=convertToTensor(e,"x","reverse");if(0===r.rank)return r.clone();var n=parseAxisParam(t,r.shape);return ENV.engine.runKernel(function(e){return e.reverse(r,n)},{$x:r},function(e){return{$x:function(){return e.reverse(n)}}}).reshapeAs(r)}var reverse=op({reverse_:reverse_}),reverse1d=op({reverse1d_:reverse1d_}),reverse2d=op({reverse2d_:reverse2d_}),reverse3d=op({reverse3d_:reverse3d_}),reverse4d=op({reverse4d_:reverse4d_});function maxPoolImpl_(e,t,r,n,o,a){var i=convertToTensor(e,"x","maxPool"),s=i,u=!1;3===i.rank&&(u=!0,s=i.as4D(1,i.shape[0],i.shape[1],i.shape[2])),null==n&&(n=[1,1]),assert(4===s.rank,"Error in maxPool: input must be rank 4 but got rank "+s.rank+"."),assert(eitherStridesOrDilationsAreOne(r,n),"Error in maxPool: Either strides or dilations must be 1. Got strides "+r+" and dilations '"+n+"'"),null!=a&&assert(isInt(o),"Error in maxPool: pad must be an integer when using, dimRoundingMode "+a+" but got pad "+o+".");var l=computePool2DInfo(s.shape,t,r,n,o,a),c=ENV.engine.runKernel(function(e,t){return t(e.maxPool(s,l))},{x:s},function(e,a){var i=a[0];return{x:function(){return maxPoolBackprop(e,s,i,t,r,n,o)}}});return u?c.as3D(c.shape[1],c.shape[2],c.shape[3]):c}function maxPool_(e,t,r,n,o){return maxPoolImpl_(e,t,r,1,n,o)}function avgPoolImpl_(e,t,r,n,o,a){var i=convertToTensor(e,"x","avgPool");assert("float32"===i.dtype,"The input dtype to avgPool must be float32"),null==n&&(n=[1,1]),assert(eitherStridesOrDilationsAreOne(r,n),"Error in avgPool: Either strides or dilations must be 1. Got strides "+r+" and dilations '"+n+"'");var s=i,u=!1;3===i.rank&&(u=!0,s=i.as4D(1,i.shape[0],i.shape[1],i.shape[2])),assert(4===s.rank,"Error in avgPool: x must be rank 4 but got rank "+s.rank+"."),null!=a&&assert(isInt(o),"Error in avgPool: pad must be an integer when using, dimRoundingMode "+a+" but got pad "+o+".");var l=computePool2DInfo(s.shape,t,r,n,o),c=ENV.engine.runKernel(function(e){return e.avgPool(s,l)},{x:s},function(e){return{x:function(){return avgPoolBackprop(e,s,t,r,n,o)}}});return c=c.cast(i.dtype),u?c.as3D(c.shape[1],c.shape[2],c.shape[3]):c}function avgPool_(e,t,r,n,o){return avgPoolImpl_(e,t,r,1,n,o)}function pool_(e,t,r,n,o,a){null==o&&(o=[1,1]),null==a&&(a=1),0===n&&(n="valid");var i=convertToTensor(e,"x","maxPool"),s=i,u=!1;3===i.rank&&(u=!0,s=i.as4D(1,i.shape[0],i.shape[1],i.shape[2])),assert(eitherStridesOrDilationsAreOne(a,o),"Error in pool: Either strides or dilations must be 1. Got strides "+a+" and dilations '"+o+"'");var l,c=computePool2DInfo(s.shape,t,a,o,n),p=[c.dilationHeight,c.dilationWidth];l="same"===n?withSpaceToBatchBasePaddings([c.filterHeight,c.filterWidth],p):[[0,0],[0,0]];var d=1===p[0]&&1===p[1],h=requiredSpaceToBatchPaddings([c.inHeight,c.inWidth],p,l),f=h[0],m=h[1],g=d?n:"valid",v=d?s:spaceToBatchND(s,p,f),y=("avg"===r?function(){return avgPoolImpl_(v,t,a,1,g)}:function(){return maxPoolImpl_(v,t,a,1,g)})(),x=d?y:batchToSpaceND(y,p,m);return u?x.as3D(x.shape[1],x.shape[2],x.shape[3]):x}function maxPoolBackprop(e,t,r,n,o,a,i,s){var u=convertToTensor(e,"dy","maxPoolBackprop"),l=convertToTensor(t,"input","maxPoolBackprop"),c=convertToTensor(r,"output","maxPoolBackprop");assert(l.rank===u.rank,"Rank of input ("+l.rank+") does not match rank of dy ("+u.rank+")"),null==a&&(a=[1,1]),assert(eitherStridesOrDilationsAreOne(o,a),"Error in maxPoolBackProp: Either strides or dilations must be 1. Got strides "+o+" and dilations '"+a+"'"),assert(4===u.rank,"Error in maxPoolBackprop: dy must be rank 4 but got rank "+u.rank+"."),assert(4===l.rank,"Error in maxPoolBackprop: input must be rank 4 but got rank "+l.rank+"."),null!=s&&assert(isInt(i),"Error in maxPoolBackprop: pad must be an integer when using, dimRoundingMode "+s+" but got pad "+i+".");var p=computePool2DInfo(l.shape,n,o,a,i,s);return ENV.engine.runKernel(function(e){return e.maxPoolBackprop(u,l,c,p)},{$dy:u,$input:l})}function avgPoolBackprop(e,t,r,n,o,a){var i=convertToTensor(e,"dy","avgPoolBackprop"),s=convertToTensor(t,"input","avgPoolBackprop");assert(s.rank===i.rank,"Rank of input ("+s.rank+") does not match rank of dy ("+i.rank+")"),null==o&&(o=[1,1]),assert(eitherStridesOrDilationsAreOne(n,o),"Error in avgPoolBackprop: Either strides or dilations must be 1. Got strides "+n+" and dilations '"+o+"'");var u=s,l=i,c=!1;3===s.rank&&(c=!0,u=s.as4D(1,s.shape[0],s.shape[1],s.shape[2]),l=i.as4D(1,i.shape[0],i.shape[1],i.shape[2])),assert(4===l.rank,"Error in avgPoolBackprop: dy must be rank 4 but got rank "+l.rank+"."),assert(4===u.rank,"Error in avgPoolBackprop: input must be rank 4 but got rank "+u.rank+".");var p=computePool2DInfo(u.shape,r,n,o,a),d=ENV.engine.runKernel(function(e){return e.avgPoolBackprop(l,u,p)},{dy4D:l,input4D:u});return c?d.as3D(d.shape[1],d.shape[2],d.shape[3]):d}function requiredSpaceToBatchPaddings(e,t,r){var n=r.map(function(e){return e[0]}),o=r.map(function(e){return e[1]}),a=e.concat(n,o),i=t.map(function(e,t){return(e-a[t]%e)%e}),s=o.map(function(e,t){return e+i[t]});return[t.map(function(e,t){return[n[t],s[t]]}),t.map(function(e,t){return[0,i[t]]})]}function withSpaceToBatchBasePaddings(e,t){var r=e.map(function(e,r){return e+(e-1)*(t[r]-1)}).map(function(e){return e-1}),n=r.map(function(e){return Math.floor(e/2)}),o=r.map(function(e,t){return e-n[t]});return r.map(function(e,t){return[n[t],o[t]]})}var maxPool=op({maxPool_:maxPool_}),avgPool=op({avgPool_:avgPool_}),pool=op({pool_:pool_});function slice1d_(e,t,r){var n=convertToTensor(e,"x","slice1d");return assert(1===n.rank,"slice1d expects a rank-1 tensor, but got a rank-"+n.rank+" tensor"),slice(n,[t],[r])}function slice2d_(e,t,r){var n=convertToTensor(e,"x","slice2d");return assert(2===n.rank,"slice2d expects a rank-2 tensor, but got a rank-"+n.rank+" tensor"),slice(n,t,r)}function slice3d_(e,t,r){var n=convertToTensor(e,"x","slice3d");return assert(3===n.rank,"slice3d expects a rank-3 tensor, but got a rank-"+n.rank+" tensor"),slice(n,t,r)}function slice4d_(e,t,r){var n=convertToTensor(e,"x","slice4d");return assert(4===n.rank,"slice4d expects a rank-4 tensor, but got a rank-"+n.rank+" tensor"),slice(n,t,r)}function slice_(e,t,r){var n,o,a=convertToTensor(e,"x","slice");if(0===a.rank)throw new Error("Slicing scalar is not possible");n="number"==typeof t?[t].concat(new Array(a.rank-1).fill(0)):t.length<a.rank?t.concat(new Array(a.rank-t.length).fill(0)):t.slice(),o=(o=null==r?new Array(a.rank).fill(-1):"number"==typeof r?[r].concat(new Array(a.rank-1).fill(-1)):r.length<a.rank?r.concat(new Array(a.rank-r.length).fill(-1)):r).map(function(e,t){return e>=0?e:(assert(-1===e,"Bad value in size"),a.shape[t]-n[t])}),assertParamsValid(a,n,o);var i=a.shape;return ENV.engine.runKernel(function(e){return e.slice(a,n,o)},{$x:a},function(e){for(var t=[],r=0;r<e.rank;r++)t.push([n[r],i[r]-n[r]-o[r]]);return{$x:function(){return e.pad(t)}}})}var slice=op({slice_:slice_}),slice1d=op({slice1d_:slice1d_}),slice2d=op({slice2d_:slice2d_}),slice3d=op({slice3d_:slice3d_}),slice4d=op({slice4d_:slice4d_});function logSumExp_(e,t,r){void 0===t&&(t=null),void 0===r&&(r=!1);var n=convertToTensor(e,"x","logSumExp"),o=parseAxisParam(t,n.shape),a=n.max(o,!0),i=n.sub(a).exp().sum(o).log(),s=a.reshape(i.shape).add(i);if(r){var u=expandShapeToKeepDim(s.shape,o);return s.reshape(u)}return s}function sum_(e,t,r){void 0===t&&(t=null),void 0===r&&(r=!1);var n=convertToTensor(e,"x","sum");"bool"===n.dtype&&(n=n.toInt());var o=parseAxisParam(t,n.shape);return customGrad(function(e){var t=getAxesPermutation(o,e.rank),n=o,a=e;null!=t&&(a=e.transpose(t),n=getInnerMostAxes(n.length,e.rank));var i=ENV.engine.runKernel(function(e){return e.sum(a,n)},{permutedX:a});if(r){var s=expandShapeToKeepDim(i.shape,o);i=i.reshape(s)}return{value:i,gradFunc:function(t){var r=e.shape.slice();return o.forEach(function(e){r[e]=1}),t.reshape(r).mul(ones$1(e.shape,"float32"))}}})(n)}function prod_(e,t,r){void 0===t&&(t=null),void 0===r&&(r=!1);var n=convertToTensor(e,"x","prod");"bool"===n.dtype&&(n=n.toInt());var o=parseAxisParam(t,n.shape),a=getAxesPermutation(o,n.rank),i=o,s=n;null!=a&&(s=n.transpose(a),i=getInnerMostAxes(i.length,n.rank));var u=ENV.engine.runKernel(function(e){return e.prod(s,i)},{permutedX:s});if(r){var l=expandShapeToKeepDim(u.shape,o);u=u.reshape(l)}return u}function mean_(e,t,r){void 0===t&&(t=null),void 0===r&&(r=!1);var n=convertToTensor(e,"x","mean"),o=parseAxisParam(t,n.shape),a=sizeFromShape(computeOutAndReduceShapes(n.shape,o)[1]);return customGrad(function(e){var n=scalar(a);return{value:(n.dtype===e.dtype?e:e.cast(n.dtype)).div(n).sum(t,r),gradFunc:function(t){var r=e.shape.slice();return o.forEach(function(e){r[e]=1}),t.reshape(r).mul(ones$1(e.shape,"float32")).div(n)}}})(n)}function gradForMinAndMax(e,t,r,n,o){var a=t[0];return a.rank<r.rank&&(a=a.reshape(expandShapeToKeepDim(a.shape,n))),e.rank<r.rank&&(e=e.reshape(expandShapeToKeepDim(e.shape,n))),{$x:function(){var t=e.mul(r.equal(a).cast(e.dtype));return null==o?t:t.transpose(o)}}}function min_(e,t,r){void 0===t&&(t=null),void 0===r&&(r=!1);var n=convertToTensor(e,"x","min"),o=n,a=parseAxisParam(t,n.shape),i=a,s=getAxesPermutation(i,n.rank);null!=s&&(n=n.transpose(s),i=getInnerMostAxes(i.length,n.rank));var u=ENV.engine.runKernel(function(e,t){return t(e.min(n,i))},{$x:n},function(e,t){return gradForMinAndMax(e,t,o,a,s)});if(r){var l=expandShapeToKeepDim(u.shape,a);u=u.reshape(l)}return u}function max_(e,t,r){void 0===t&&(t=null),void 0===r&&(r=!1);var n=convertToTensor(e,"x","max"),o=n,a=parseAxisParam(t,n.shape),i=a,s=getAxesPermutation(i,n.rank);null!=s&&(n=n.transpose(s),i=getInnerMostAxes(i.length,n.rank));var u=ENV.engine.runKernel(function(e,t){return t(e.max(n,i))},{$x:n},function(e,t){return gradForMinAndMax(e,t,o,a,s)});if(r){var l=expandShapeToKeepDim(u.shape,a);u=u.reshape(l)}return u}function argMin_(e,t){void 0===t&&(t=0);var r=convertToTensor(e,"x","argMin");null==t&&(t=0);var n=parseAxisParam(t,r.shape),o=getAxesPermutation(n,r.rank);null!=o&&(r=r.transpose(o),n=getInnerMostAxes(n.length,r.rank));return ENV.engine.runKernel(function(e){return e.argMin(r,n[0])},{$x:r},function(e){return{$x:function(){return zerosLike(r)}}})}function argMax_(e,t){void 0===t&&(t=0);var r=convertToTensor(e,"x","argMax");null==t&&(t=0);var n=parseAxisParam(t,r.shape),o=getAxesPermutation(n,r.rank);null!=o&&(r=r.transpose(o),n=getInnerMostAxes(n.length,r.rank));return ENV.engine.runKernel(function(e){return e.argMax(r,n[0])},{$x:r},function(e){return{$x:function(){return zerosLike(r)}}})}function all_(e,t,r){void 0===t&&(t=null),void 0===r&&(r=!1);var n=convertToTensor(e,"x","all","bool");assert("bool"===n.dtype,"Error Tensor must be of type bool. Got: "+n.dtype);var o=parseAxisParam(t,n.shape),a=o,i=getAxesPermutation(a,n.rank);null!=i&&(n=n.transpose(i),a=getInnerMostAxes(a.length,n.rank));var s=ENV.engine.runKernel(function(e){return e.all(n,a)},{$x:n});if(r){var u=expandShapeToKeepDim(s.shape,o);return s.reshape(u)}return s}function any_(e,t,r){void 0===t&&(t=null),void 0===r&&(r=!1);var n=convertToTensor(e,"x","any","bool");assert("bool"===n.dtype,"Error Tensor must be of type bool. Got: "+n.dtype);var o=parseAxisParam(t,n.shape),a=o,i=getAxesPermutation(a,n.rank);null!=i&&(n=n.transpose(i),a=getInnerMostAxes(a.length,n.rank));var s=ENV.engine.runKernel(function(e){return e.any(n,a)},{$x:n});if(r){var u=expandShapeToKeepDim(s.shape,o);return s.reshape(u)}return s}function moments_(e,t,r){void 0===t&&(t=null),void 0===r&&(r=!1);var n=parseAxisParam(t,(e=convertToTensor(e,"x","moments")).shape),o=e.mean(n,r),a=o.shape;return r||(a=expandShapeToKeepDim(o.shape,n)),{mean:o,variance:e.toFloat().sub(o.reshape(a)).square().mean(n,r)}}var all=op({all_:all_}),any=op({any_:any_}),argMax=op({argMax_:argMax_}),argMin=op({argMin_:argMin_}),logSumExp=op({logSumExp_:logSumExp_}),max=op({max_:max_}),mean=op({mean_:mean_}),min=op({min_:min_}),moments=op({moments_:moments_}),sum$1=op({sum_:sum_}),prod=op({prod_:prod_});function notEqual_(e,t){var r=convertToTensor(e,"a","notEqual"),n=convertToTensor(t,"b","notEqual");return assertTypesMatch(r,n),assertAndGetBroadcastShape(r.shape,n.shape),ENV.engine.runKernel(function(e){return e.notEqual(r,n)},{$a:r,$b:n})}function notEqualStrict_(e,t){var r=convertToTensor(e,"a","notEqualStrict"),n=convertToTensor(t,"b","notEqualStrict");return assertShapesMatch(r.shape,n.shape,"Error in notEqualStrict: "),r.notEqual(n)}function less_(e,t){var r=convertToTensor(e,"a","less"),n=convertToTensor(t,"b","less");return assertTypesMatch(r,n),assertAndGetBroadcastShape(r.shape,n.shape),ENV.engine.runKernel(function(e){return e.less(r,n)},{$a:r,$b:n})}function lessStrict_(e,t){var r=convertToTensor(e,"a","lessStrict"),n=convertToTensor(t,"b","lessStrict");return assertShapesMatch(r.shape,n.shape,"Error in lessStrict: "),r.less(n)}function equal_(e,t){var r=convertToTensor(e,"a","equal"),n=convertToTensor(t,"b","equal");return assertTypesMatch(r,n),assertAndGetBroadcastShape(r.shape,n.shape),ENV.engine.runKernel(function(e){return e.equal(r,n)},{$a:r,$b:n})}function equalStrict_(e,t){var r=convertToTensor(e,"a","equalStrict"),n=convertToTensor(t,"b","equalStrict");return assertShapesMatch(r.shape,n.shape,"Error in equalStrict: "),r.equal(n)}function lessEqual_(e,t){var r=convertToTensor(e,"a","lessEqual"),n=convertToTensor(t,"b","lessEqual");return assertTypesMatch(r,n),assertAndGetBroadcastShape(r.shape,n.shape),ENV.engine.runKernel(function(e){return e.lessEqual(r,n)},{$a:r,$b:n})}function lessEqualStrict_(e,t){var r=convertToTensor(e,"a","lessEqualStrict"),n=convertToTensor(t,"b","lessEqualStrict");return assertShapesMatch(r.shape,n.shape,"Error in lessEqualStrict: "),r.lessEqual(n)}function greater_(e,t){var r=convertToTensor(e,"a","greater"),n=convertToTensor(t,"b","greater");return assertTypesMatch(r,n),assertAndGetBroadcastShape(r.shape,n.shape),ENV.engine.runKernel(function(e){return e.greater(r,n)},{$a:r,$b:n})}function greaterStrict_(e,t){var r=convertToTensor(e,"a","greaterStrict"),n=convertToTensor(t,"b","greaterStrict");return assertShapesMatch(r.shape,n.shape,"Error in greaterStrict: "),r.greater(n)}function greaterEqual_(e,t){var r=convertToTensor(e,"a","greaterEqual"),n=convertToTensor(t,"b","greaterEqual");assertTypesMatch(r,n),assertAndGetBroadcastShape(r.shape,n.shape);return ENV.engine.runKernel(function(e){return e.greaterEqual(r,n)},{$a:r,$b:n},function(e){return{$a:function(){return zerosLike(r)},$b:function(){return zerosLike(n)}}})}function greaterEqualStrict_(e,t){var r=convertToTensor(e,"a","greaterEqualStrict"),n=convertToTensor(t,"b","greaterEqualStrict");return assertShapesMatch(r.shape,n.shape,"Error in greaterEqualStrict: "),r.greaterEqual(n)}var equal=op({equal_:equal_}),equalStrict=op({equalStrict_:equalStrict_}),greater=op({greater_:greater_}),greaterEqual=op({greaterEqual_:greaterEqual_}),greaterEqualStrict=op({greaterEqualStrict_:greaterEqualStrict_}),greaterStrict=op({greaterStrict_:greaterStrict_}),less=op({less_:less_}),lessEqual=op({lessEqual_:lessEqual_}),lessEqualStrict=op({lessEqualStrict_:lessEqualStrict_}),lessStrict=op({lessStrict_:lessStrict_}),notEqual=op({notEqual_:notEqual_}),notEqualStrict=op({notEqualStrict_:notEqualStrict_});function add_(e,t){var r=convertToTensor(e,"a","add"),n=convertToTensor(t,"b","add");assertTypesMatch(r,n);var o=assertAndGetBroadcastShape(r.shape,n.shape);return ENV.engine.runKernel(function(e){return e.add(r,n)},{$a:r,$b:n},function(e){return{$a:function(){var t=e,n=getReductionAxes(r.shape,o);return n.length>0&&(t=t.sum(n)),t.reshape(r.shape)},$b:function(){var t=e,r=getReductionAxes(n.shape,o);return r.length>0&&(t=t.sum(r)),t.reshape(n.shape)}}})}function addN_(e){assert(Array.isArray(e),function(){return"The argument passed to tf.addN() must be a list of tensors"}),assert(e.length>=1,function(){return"Must pass at least one tensor to tf.addN(), but got "+e.length});var t=e.map(function(e,t){return convertToTensor(e,"tensors"+t,"addN")}),r=t[0];t.forEach(function(e){if(e.dtype!==r.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(function(e){if(!arraysEqual(e.shape,r.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});var n=t;return ENV.engine.runKernel(function(e){return e.addN(t)},n,function(e){var r={};return t.forEach(function(t,n){r[n]=function(){return e.clone()}}),r})}function addStrict_(e,t){return assertShapesMatch(e.shape,t.shape,"Error in addStrict: "),e.add(t)}function sub_(e,t){var r=convertToTensor(e,"a","sub"),n=convertToTensor(t,"b","sub");assertTypesMatch(r,n);var o=assertAndGetBroadcastShape(r.shape,n.shape);return ENV.engine.runKernel(function(e){return e.subtract(r,n)},{$a:r,$b:n},function(e){return{$a:function(){var t=e,n=getReductionAxes(r.shape,o);return n.length>0&&(t=t.sum(n)),t.reshape(r.shape)},$b:function(){var t=e,r=getReductionAxes(n.shape,o);return r.length>0&&(t=t.sum(r)),t.neg().reshape(n.shape)}}})}function subStrict_(e,t){return assertShapesMatch(e.shape,t.shape,"Error in subStrict: "),e.sub(t)}function pow_(e,t){var r=convertToTensor(e,"base","pow"),n=convertToTensor(t,"exp","pow"),o=assertAndGetBroadcastShape(r.shape,n.shape);e=r.cast(upcastType(r.dtype,n.dtype)),t=n.cast(upcastType(r.dtype,n.dtype));return ENV.engine.runKernel(function(e,t){return t(e.pow(r,n))},{$base:r,$exp:n},function(e,t){var a=t[0];return{$base:function(){var t=n.toFloat(),a=e.mul(t.mul(r.pow(t.sub(scalar(1))))),i=getReductionAxes(r.shape,o);return i.length>0&&(a=a.sum(i)),a.reshape(r.shape)},$exp:function(){var t=e.mul(a.mul(r.log()).toFloat()),i=getReductionAxes(n.shape,o);return i.length>0&&(t=t.sum(i)),t.reshape(n.shape)}}})}function powStrict_(e,t){return assertShapesMatch(e.shape,t.shape,"Error in powStrict: "),e.pow(t)}function mul_(e,t){var r=convertToTensor(e,"a","mul"),n=convertToTensor(t,"b","mul");assertTypesMatch(r,n);var o=assertAndGetBroadcastShape(r.shape,n.shape);return ENV.engine.runKernel(function(e){return e.multiply(r,n)},{$a:r,$b:n},function(e){return{$a:function(){var t=e.mul(n.toFloat()),a=getReductionAxes(r.shape,o);return a.length>0?t.sum(a).reshape(r.shape):t},$b:function(){var t=e.mul(r.toFloat()),a=getReductionAxes(n.shape,o);return a.length>0?t.sum(a).reshape(n.shape):t}}})}function mulStrict_(e,t){return assertShapesMatch(e.shape,t.shape,"Error in multiplyStrict: "),e.mul(t)}function div_(e,t){var r,n=convertToTensor(e,"a","div"),o=convertToTensor(t,"b","div");if(assertTypesMatch(n,o),"int32"===n.dtype&&"int32"===o.dtype)return floorDiv(n,o);r=function(e){return e.realDivide(n,o)};var a=assertAndGetBroadcastShape(n.shape,o.shape);return ENV.engine.runKernel(r,{$a:n,$b:o},function(e){return{$a:function(){var t=e.div(o.toFloat()),r=getReductionAxes(n.shape,a);return r.length>0?t.sum(r).reshape(n.shape):t},$b:function(){var t=e.mul(n.toFloat()),r=getReductionAxes(o.shape,a);r.length>0&&(t=t.sum(r).reshape(o.shape));var i=o.square();return t.div(i.toFloat()).neg()}}})}function floorDiv_(e,t){var r=convertToTensor(e,"a","floorDiv"),n=convertToTensor(t,"b","floorDiv");assertTypesMatch(r,n);var o=assertAndGetBroadcastShape(r.shape,n.shape);return ENV.engine.runKernel(function(e){return e.floorDiv(r,n)},{$a:r,$b:n},function(e){return{$a:function(){var t=e.div(n.toFloat()),a=getReductionAxes(r.shape,o);return a.length>0?t.sum(a).reshape(r.shape):t},$b:function(){var t=e.mul(r.toFloat()),a=getReductionAxes(n.shape,o);a.length>0&&(t=t.sum(a).reshape(n.shape));var i=n.square();return t.div(i.toFloat()).neg()}}})}function divStrict_(e,t){return assertShapesMatch(e.shape,t.shape,"Error in divideStrict: "),e.div(t)}function mod_(e,t){var r=convertToTensor(e,"a","mod"),n=convertToTensor(t,"b","mod");assertTypesMatch(r,n);var o=assertAndGetBroadcastShape(r.shape,n.shape);return ENV.engine.runKernel(function(e){return e.mod(r,n)},{$a:r,$b:n},function(e){return{$a:function(){var t=getReductionAxes(r.shape,o);return t.length>0?e.sum(t).reshape(r.shape):e},$b:function(){var t=e.mul(r.div(n).floor().neg()),a=getReductionAxes(n.shape,o);return a.length>0?t.sum(a).reshape(n.shape):t}}})}function modStrict_(e,t){return assertShapesMatch(e.shape,t.shape,"Error in modStrict: "),e.mod(t)}function minimum_(e,t){var r=convertToTensor(e,"a","minimum"),n=convertToTensor(t,"b","minimum");assertTypesMatch(r,n),"bool"===r.dtype&&(r=r.toInt()),"bool"===n.dtype&&(n=n.toInt()),assertAndGetBroadcastShape(r.shape,n.shape);return ENV.engine.runKernel(function(e){return e.minimum(r,n)},{$a:r,$b:n},function(e){return{$a:function(){return e.mul(r.lessEqual(n).toFloat())},$b:function(){return e.mul(r.greater(n).toFloat())}}})}function minimumStrict_(e,t){return assertShapesMatch(e.shape,t.shape,"Error in minimumStrict: "),e.minimum(t)}function maximum_(e,t){var r=convertToTensor(e,"a","maximum"),n=convertToTensor(t,"b","maximum");assertTypesMatch(r,n),"bool"===r.dtype&&(r=r.toInt()),"bool"===n.dtype&&(n=n.toInt()),assertAndGetBroadcastShape(r.shape,n.shape);return ENV.engine.runKernel(function(e){return e.maximum(r,n)},{$a:r,$b:n},function(e){return{$a:function(){return e.mul(r.greaterEqual(n).toFloat())},$b:function(){return e.mul(r.less(n).toFloat())}}})}function maximumStrict_(e,t){return assertShapesMatch(e.shape,t.shape,"Error in maximumStrict: "),e.maximum(t)}function squaredDifference_(e,t){var r=convertToTensor(e,"a","squaredDifference"),n=convertToTensor(t,"b","squaredDifference");assertTypesMatch(r,n),assertAndGetBroadcastShape(r.shape,n.shape);return ENV.engine.runKernel(function(e){return e.squaredDifference(r,n)},{$a:r,$b:n},function(e){var t=scalar(2);return{$a:function(){return e.mul(r.sub(n).mul(t))},$b:function(){return e.mul(n.sub(r).mul(t))}}})}function squaredDifferenceStrict_(e,t){return assertShapesMatch(e.shape,t.shape,"Error in squaredDifferenceStrict: "),e.squaredDifference(t)}function atan2_(e,t){var r=convertToTensor(e,"a","atan2"),n=convertToTensor(t,"b","atan2");assertTypesMatch(r,n);var o=assertAndGetBroadcastShape(r.shape,n.shape);return ENV.engine.runKernel(function(e){return e.atan2(r,n)},{$a:r,$b:n},function(e){return{$a:function(){var t=add(r.square(),n.square()),a=e.mul(n.div(t)),i=getReductionAxes(r.shape,o);return i.length>0&&(a=a.sum(i)),a.reshape(r.shape)},$b:function(){var t=add(r.square(),n.square()),a=neg(e.mul(r.div(t))),i=getReductionAxes(n.shape,o);return i.length>0&&(a=a.sum(i)),a.reshape(n.shape)}}})}var add=op({add_:add_}),addN=op({addN_:addN_}),addStrict=op({addStrict_:addStrict_}),atan2=op({atan2_:atan2_}),div=op({div_:div_}),divStrict=op({divStrict_:divStrict_}),floorDiv=op({floorDiv_:floorDiv_}),maximum=op({maximum_:maximum_}),maximumStrict=op({maximumStrict_:maximumStrict_}),minimum=op({minimum_:minimum_}),minimumStrict=op({minimumStrict_:minimumStrict_}),mod=op({mod_:mod_}),modStrict=op({modStrict_:modStrict_}),mul=op({mul_:mul_}),mulStrict=op({mulStrict_:mulStrict_}),pow=op({pow_:pow_}),powStrict=op({powStrict_:powStrict_}),squaredDifference=op({squaredDifference_:squaredDifference_}),squaredDifferenceStrict=op({squaredDifferenceStrict_:squaredDifferenceStrict_}),sub=op({sub_:sub_}),subStrict=op({subStrict_:subStrict_});function logicalNot_(e){var t=convertToTensor(e,"x","logicalNot","bool");return assert("bool"===t.dtype,"Error Array must be of type bool."),ENV.engine.runKernel(function(e){return e.logicalNot(t)},{$x:t})}function logicalAnd_(e,t){var r=convertToTensor(e,"a","logicalAnd","bool"),n=convertToTensor(t,"b","logicalAnd","bool");return assert("bool"===r.dtype&&"bool"===n.dtype,"Error Array must be of type bool."),assertAndGetBroadcastShape(r.shape,n.shape),ENV.engine.runKernel(function(e){return e.logicalAnd(r,n)},{$a:r,$b:n})}function logicalOr_(e,t){var r=convertToTensor(e,"a","logicalOr","bool"),n=convertToTensor(t,"b","logicalOr","bool");return assert("bool"===r.dtype&&"bool"===n.dtype,"Error Array must be of type bool."),assertAndGetBroadcastShape(r.shape,n.shape),ENV.engine.runKernel(function(e){return e.logicalOr(r,n)},{$a:r,$b:n})}function logicalXor_(e,t){var r=convertToTensor(e,"a","logicalXor","bool"),n=convertToTensor(t,"b","logicalXor","bool");return assert("bool"===r.dtype&&"bool"===n.dtype,"Error Array must be of type bool."),assertAndGetBroadcastShape(r.shape,n.shape),logicalOr(e,t).logicalAnd(logicalAnd(e,t).logicalNot())}function where_(e,t,r){var n=convertToTensor(t,"a","where"),o=convertToTensor(r,"b","where"),a=convertToTensor(e,"condition","where","bool");assert("bool"===a.dtype,"Error Condition must be of type bool."),assertShapesMatch(n.shape,o.shape,"Error in where: "),1===a.rank?assert(a.shape[0]===n.shape[0],"The first dimension of `a` must match the size of `condition`."):assertShapesMatch(a.shape,o.shape,"Error in where: ");return ENV.engine.runKernel(function(e){return e.select(a,n,o)},{$condition:a,$a:n,$b:o},function(e){return{$condition:function(){return zerosLike(a)},$a:function(){return e.mul(a.cast(n.dtype))},$b:function(){return e.mul(a.logicalNot().cast(o.dtype))}}})}function whereAsync_(e){return __awaiter(this,void 0,void 0,function(){var t,r,n;return __generator(this,function(o){switch(o.label){case 0:return assert("bool"===(t=convertToTensor(e,"condition","where","bool")).dtype,"Condition must be of type bool."),[4,t.data()];case 1:return r=o.sent(),n=whereImpl(t.shape,r),e!==t&&t.dispose(),[2,n]}})})}var logicalAnd=op({logicalAnd_:logicalAnd_}),logicalNot=op({logicalNot_:logicalNot_}),logicalOr=op({logicalOr_:logicalOr_}),logicalXor=op({logicalXor_:logicalXor_}),where=op({where_:where_}),whereAsync=whereAsync_;function relu_(e){var t=convertToTensor(e,"x","relu");if("bool"===t.dtype)return t.toInt();return ENV.engine.runKernel(function(e){return e.relu(t)},{$x:t},function(e){var r=t.step();return{$x:function(){return e.mulStrict(r.toFloat())}}})}function elu_(e){var t=convertToTensor(e,"x","elu");return ENV.engine.runKernel(function(e,r){return r(e.elu(t))},{$x:t},function(e,t){var r=t[0];return{$x:function(){return ENV.engine.runKernel(function(t){return t.eluDer(e,r)},{dy:e,y:r})}}})}function selu_(e){var t=convertToTensor(e,"x","selu");return ENV.engine.runKernel(function(e){return e.selu(t)},{$x:t},function(e){return{$x:function(){var r=t.greater(scalar(0)),n=scalar(SELU_SCALEALPHA),o=scalar(SELU_SCALE),a=e.mul(o),i=e.mul(n).mul(t.toFloat().exp());return where(r,a,i)}}})}function leakyRelu_(e,t){void 0===t&&(t=.2);var r=convertToTensor(e,"x","leakyRelu");return maximum(scalar(t).mul(r),r)}function prelu_(e,t){var r=convertToTensor(e,"x","prelu"),n=convertToTensor(t,"alpha","prelu"),o=scalar(0);return maximum(o,r).add(n.mul(minimum(o,r)))}var elu=op({elu_:elu_}),leakyRelu=op({leakyRelu_:leakyRelu_}),prelu=op({prelu_:prelu_}),relu=op({relu_:relu_}),selu=op({selu_:selu_});function transpose_(e,t){var r=convertToTensor(e,"x","transpose");if(null==t&&(t=r.shape.map(function(e,t){return t}).reverse()),assert(r.rank===t.length,"Error in transpose: rank of input "+r.rank+" must match length of perm "+t+"."),t.forEach(function(e){assert(e>=0&&e<r.rank,"All entries in 'perm' must be between 0 and "+(r.rank-1)+" but got "+t)}),r.rank<=1)return r.clone();return ENV.engine.runKernel(function(e){return e.transpose(r,t)},{$x:r},function(e){var r=getUndoAxesPermutation(t);return{$x:function(){return e.transpose(r)}}})}var transpose=op({transpose_:transpose_});function localResponseNormalization_(e,t,r,n,o){void 0===t&&(t=5),void 0===r&&(r=1),void 0===n&&(n=1),void 0===o&&(o=.5);var a=convertToTensor(e,"x","localResponseNormalization");assert(4===a.rank||3===a.rank,"Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank "+a.rank+"."),assert(isInt(t),"Error in localResponseNormalization: depthRadius must be an integer\n                     but got depthRadius "+t+".");var i=a,s=!1;3===a.rank&&(s=!0,i=a.as4D(1,a.shape[0],a.shape[1],a.shape[2]));var u=ENV.engine.runKernel(function(e,a){return a(e.localResponseNormalization4D(i,t,r,n,o))},{x4D:i},function(e,a){var s=a[0];return{x4D:function(){return ENV.engine.runKernel(function(a){return a.LRNGrad(e,i,s,t,r,n,o)},{})}}});return s?u.as3D(u.shape[1],u.shape[2],u.shape[3]):u}var localResponseNormalization=op({localResponseNormalization_:localResponseNormalization_});function norm_(e,t,r,n){void 0===t&&(t="euclidean"),void 0===r&&(r=null),void 0===n&&(n=!1);var o=normImpl(e=convertToTensor(e,"x","norm"),t,r),a=o.shape;if(n){var i=parseAxisParam(r,e.shape);a=expandShapeToKeepDim(o.shape,i)}return o.reshape(a)}function normImpl(e,t,r){if(void 0===r&&(r=null),0===e.rank)return e.abs();if(1!==e.rank&&null===r)return normImpl(e.reshape([-1]),t,r);if(1===e.rank||"number"==typeof r||r instanceof Array&&1===r.length){if(1===t)return e.abs().sum(r);if(t===1/0)return e.abs().max(r);if(t===-1/0)return e.abs().min(r);if("euclidean"===t||2===t)return e.abs().pow(scalar(2,"int32")).sum(r).sqrt();throw new Error("Error in norm: invalid ord value: "+t)}if(r instanceof Array&&2===r.length){if(1===t)return e.abs().sum(r[0]).max(r[1]-1);if(t===1/0)return e.abs().sum(r[1]).max(r[0]);if(t===-1/0)return e.abs().sum(r[1]).min(r[0]);if("fro"===t||"euclidean"===t)return e.square().sum(r).sqrt();throw new Error("Error in norm: invalid ord value: "+t)}throw new Error("Error in norm: invalid axis: "+r)}var norm=op({norm_:norm_});function unsortedSegmentSum_(e,t,r){var n=convertToTensor(e,"x","unsortedSegmentSum"),o=convertToTensor(t,"segmentIds","unsortedSegmentSum","int32");assert("int32"===o.dtype,"segmentIds must be of dtype `int32`"),assert(isInt(r),"numSegments must be of dtype int");return ENV.engine.runKernel(function(e){return e.unsortedSegmentSum(n,o,r)},{$x:n},function(e){return{$x:function(){return gatherDropNegatives(e,o)}}})}function gather_(e,t,r){void 0===r&&(r=0);var n=convertToTensor(e,"x","gather"),o=convertToTensor(t,"indices","gather","int32");assert("int32"===o.dtype,"Indices must be of dtype `int32`"),r=parseAxisParam(r,n.shape)[0];return ENV.engine.runKernel(function(e){return e.gather(n,o,r)},{$x:n},function(e){return{$x:function(){if(0===r)return unsortedSegmentSum(e,o,n.shape[r]);var t=n.shape,a=o.size,i=t.slice(0,r),s=i.length,u=t.slice(r,t.length).slice(1),l=u.length,c=arrayRange(0,s),p=arrayRange(s+1,s+1+l),d=arrayConcat([i,[a],u]),h=e.reshape(d),f=o.reshape([a]),m=arrayConcat([[s],c,p]),g=h.transpose(m),v=unsortedSegmentSum(g,f,n.shape[r]),y=getUndoAxesPermutation(m);return v=v.transpose(y)}}})}function arrayRange(e,t){for(var r=[],n=e;n<t;++n)r.push(n);return r}function arrayConcat(e){for(var t=[],r=0;r<e.length;++r)for(var n=0;n<e[r].length;++n)t.push(e[r][n]);return t}function gatherDropNegatives(e,t){for(var r=maximum(t,zerosLike(t)),n=gather(e,r),o=greaterEqual(t,scalar(0,"int32")),a=n.rank-o.rank,i=0;i<a;++i)o=expandDims(o,i+1);o=logicalAnd(o,ones$1(n.shape,"bool"));var s=zerosLike(n);return where(o,n,s)}var gather=op({gather_:gather_}),unsortedSegmentSum=op({unsortedSegmentSum_:unsortedSegmentSum_});function multiRNNCell_(e,t,r,n){for(var o=convertToTensor(t,"data","multiRNNCell"),a=convertToTensorArray(r,"c","multiRNNCell"),i=convertToTensorArray(n,"h","multiRNNCell"),s=o,u=[],l=0;l<e.length;l++){var c=e[l](s,a[l],i[l]);u.push(c[0]),u.push(c[1]),s=c[1]}var p=[],d=[];for(l=0;l<u.length;l+=2)p.push(u[l]),d.push(u[l+1]);return[p,d]}function basicLSTMCell_(e,t,r,n,o,a){var i=convertToTensor(e,"forgetBias","basicLSTMCell"),s=convertToTensor(t,"lstmKernel","basicLSTMCell"),u=convertToTensor(r,"lstmBias","basicLSTMCell"),l=convertToTensor(n,"data","basicLSTMCell"),c=convertToTensor(o,"c","basicLSTMCell"),p=convertToTensor(a,"h","basicLSTMCell"),d=l.concat(p,1).matMul(s).add(u),h=d.shape[0],f=d.shape[1]/4,m=[h,f],g=d.slice([0,0],m),v=d.slice([0,f],m),y=d.slice([0,2*f],m),x=d.slice([0,3*f],m),T=g.sigmoid().mulStrict(v.tanh()).addStrict(c.mulStrict(i.add(y).sigmoid()));return[T,T.tanh().mulStrict(x.sigmoid())]}var basicLSTMCell=op({basicLSTMCell_:basicLSTMCell_}),multiRNNCell=op({multiRNNCell_:multiRNNCell_});function movingAverage_(e,t,r,n,o){void 0===o&&(o=!0);var a=convertToTensor(e,"v","movingAverage"),i=convertToTensor(t,"x","movingAverage"),s=convertToTensor(r,"decay","movingAverage");assertTypesMatch(a,i),assert(arraysEqual(a.shape,i.shape),"Shape mismatch in v and x");var u=scalar(1),l=u.sub(s),c=i.sub(a).mul(l);if(o){assert(null!=n,"When using zeroDebias: true, step is required.");var p=convertToTensor(n,"step","movingAverage");c=c.div(u.sub(pow(s,p)))}return a.add(c)}var movingAverage=op({movingAverage_:movingAverage_});function stridedSlice_(e,t,r,n,o,a,i,s,u){if(void 0===o&&(o=0),void 0===a&&(a=0),void 0===i&&(i=0),void 0===s&&(s=0),void 0===u&&(u=0),0!==i)throw new Error("ellipsis mask is not yet supported");if(0!==s)throw new Error("new axis mask is not yet supported");var l=convertToTensor(e,"x","stridedSlice");return ENV.engine.runKernel(function(e){return e.stridedSlice(l,t,r,n,o,a,i,s,u)},{$x:l})}var stridedSlice=op({stridedSlice_:stridedSlice_});function topk_(e,t,r){void 0===t&&(t=1),void 0===r&&(r=!0);var n=convertToTensor(e,"x","topk");if(0===n.rank)throw new Error("topk() expects the input to be of rank 1 or higher");var o=n.shape[n.shape.length-1];if(t>o)throw new Error("'k' passed to topk() must be <= the last dimension ("+o+") but got "+t);var a=ENV.engine.runKernel(function(e){return e.topk(n,t,r)},{$x:n});return{values:a[0],indices:a[1]}}var topk=op({topk_:topk_});function scatterND_(e,t,r){var n=convertToTensor(e,"indices","scatterND","int32"),o=convertToTensor(t,"updates","scatterND");return validateInput(o,n,r),ENV.engine.runKernel(function(e){return e.scatterND(n,o,r)},{$indices:n,$updates:o})}var scatterND=op({scatterND_:scatterND_});function fft_(e){assert("complex64"===e.dtype,"The dtype for tf.spectral.fft() must be complex64 but got "+e.dtype+".");var t=e.shape[e.shape.length-1],r=e.size/t,n=e.as2D(r,t);return ENV.engine.runKernel(function(e){return e.fft(n)},{input:e}).reshape(e.shape)}function ifft_(e){assert("complex64"===e.dtype,"The dtype for tf.spectral.ifft() must be complex64 but got "+e.dtype+".");var t=e.shape[e.shape.length-1],r=e.size/t,n=e.as2D(r,t);return ENV.engine.runKernel(function(e){return e.ifft(n)},{input:e}).reshape(e.shape)}function rfft_(e){assert("float32"===e.dtype,"The dtype for rfft() must be real value but\n    got "+e.dtype);var t=e.shape[e.shape.length-1],r=e.size/t,n=e.zerosLike(),o=complex(e,n).as2D(r,t),a=ENV.engine.runKernel(function(e){return e.fft(o)},{complexInput:o}),i=Math.floor(t/2)+1,s=real(a),u=imag(a),l=s.split([i,t-i],s.shape.length-1),c=u.split([i,t-i],u.shape.length-1),p=e.shape.slice();return p[e.shape.length-1]=i,complex(l[0],c[0]).reshape(p)}var fft=op({fft_:fft_}),ifft=op({ifft_:ifft_}),rfft=op({rfft_:rfft_}),spectral_ops=Object.freeze({fft:fft,ifft:ifft,rfft:rfft});function validateInput$1(e,t,r,n){if("int32"!==e.dtype)throw new Error("tf.sparseToDense() expects the indices to be int32 type, but the dtype was "+e.dtype+".");if(e.rank>2)throw new Error("sparseIndices should be a scalar, vector, or matrix, but got shape "+e.shape+".");var o=e.rank>0?e.shape[0]:1,a=e.rank>1?e.shape[1]:1;if(r.length!==a)throw new Error("outputShape has incorrect number of elements:, "+r.length+", should be: "+a+".");var i=t.size;if(0!==t.rank&&(1!==t.rank||i!==o))throw new Error("sparseValues has incorrect shape "+t.shape+", should be [] or ["+o+"]");if(t.dtype!==n.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function sparseToDense_(e,t,r,n){var o=convertToTensor(e,"sparseIndices","sparseToDense","int32"),a=convertToTensor(t,"sparseValues","sparseToDense"),i=convertToTensor(n,"defaultValue","sparseToDense",a.dtype);return validateInput$1(o,a,r,i),ENV.engine.runKernel(function(e){return e.sparseToDense(o,a,r,i)},{$sparseIndices:o,$sparseValues:a,$defaultValue:i})}var sparseToDense=op({sparseToDense_:sparseToDense_});function gatherND_(e,t){var r=convertToTensor(t,"indices","gatherND","int32"),n=convertToTensor(e,"x","gatherND");return ENV.engine.runKernel(function(e){return e.gatherND(n,r)},{$x:n,$indices:r})}var Reduction,gatherND=op({gatherND_:gatherND_});function computeWeightedLoss_(e,t,r){void 0===r&&(r=Reduction.SUM_BY_NONZERO_WEIGHTS);var n=convertToTensor(e,"losses","computeWeightedLoss"),o=null;null!=t&&(o=convertToTensor(t,"weights","computeWeightedLoss"));var a=null==o?n:n.mul(o);if(r===Reduction.NONE)return a;if(r===Reduction.SUM)return a.sum();if(r===Reduction.MEAN){if(null==o)return a.mean();var i=sizeFromShape(n.shape)/sizeFromShape(o.shape),s=a.sum().div(o.sum());return i>1?s.div(scalar(i)):s}if(r===Reduction.SUM_BY_NONZERO_WEIGHTS){if(null==o)return a.sum().div(scalar(n.size));var u=o.mul(ones$1(n.shape)).notEqual(scalar(0)).sum().toFloat();return a.sum().div(u)}throw Error("Unknown reduction: "+r)}function absoluteDifference_(e,t,r,n){void 0===n&&(n=Reduction.SUM_BY_NONZERO_WEIGHTS);var o=convertToTensor(e,"labels","absoluteDifference"),a=convertToTensor(t,"predictions","absoluteDifference"),i=null;null!=r&&(i=convertToTensor(r,"weights","absoluteDifference")),assertShapesMatch(o.shape,a.shape,"Error in absoluteDifference: ");var s=o.sub(a).abs();return computeWeightedLoss(s,i,n)}function meanSquaredError_(e,t,r,n){void 0===n&&(n=Reduction.SUM_BY_NONZERO_WEIGHTS);var o=convertToTensor(e,"labels","meanSquaredError"),a=convertToTensor(t,"predictions","meanSquaredError"),i=null;null!=r&&(i=convertToTensor(r,"weights","meanSquaredError")),assertShapesMatch(o.shape,a.shape,"Error in meanSquaredError: ");var s=o.squaredDifference(a);return computeWeightedLoss(s,i,n)}function cosineDistance_(e,t,r,n,o){void 0===o&&(o=Reduction.SUM_BY_NONZERO_WEIGHTS);var a=convertToTensor(e,"labels","cosineDistance"),i=convertToTensor(t,"predictions","cosineDistance"),s=null;null!=n&&(s=convertToTensor(n,"weights","cosineDistance")),assertShapesMatch(a.shape,i.shape,"Error in cosineDistance: ");var u=scalar(1).sub(a.mul(i).sum(r,!0));return computeWeightedLoss(u,s,o)}function hingeLoss_(e,t,r,n){void 0===n&&(n=Reduction.SUM_BY_NONZERO_WEIGHTS);var o=convertToTensor(e,"labels","hingeLoss"),a=convertToTensor(t,"predictions","hingeLoss"),i=null;null!=r&&(i=convertToTensor(r,"weights","hingeLoss")),assertShapesMatch(o.shape,a.shape,"Error in hingeLoss: ");var s=scalar(1);o=scalar(2).mul(o).sub(s);var u=s.sub(o.mul(a)).relu();return computeWeightedLoss(u,i,n)}function logLoss_(e,t,r,n,o){void 0===n&&(n=1e-7),void 0===o&&(o=Reduction.SUM_BY_NONZERO_WEIGHTS);var a=convertToTensor(e,"labels","logLoss"),i=convertToTensor(t,"predictions","logLoss"),s=null;null!=r&&(s=convertToTensor(r,"weights","logLoss")),assertShapesMatch(a.shape,i.shape,"Error in logLoss: ");var u=scalar(1),l=scalar(n),c=a.mul(i.add(l).log()).neg().sub(u.sub(a).mul(u.sub(i).add(l).log()));return computeWeightedLoss(c,s,o)}function sigmoidCrossEntropyWithLogits_(e,t){var r=convertToTensor(e,"labels","sigmoidCrossEntropyWithLogits"),n=convertToTensor(t,"logits","sigmoidCrossEntropyWithLogits");assertShapesMatch(r.shape,n.shape,"Error in sigmoidCrossEntropyWithLogits: ");var o=n.relu(),a=n.mul(r),i=n.abs().neg().exp().log1p();return o.sub(a).add(i)}function sigmoidCrossEntropy_(e,t,r,n,o){void 0===n&&(n=0),void 0===o&&(o=Reduction.SUM_BY_NONZERO_WEIGHTS);var a=convertToTensor(e,"multiClassLabels","sigmoidCrossEntropy"),i=convertToTensor(t,"logits","sigmoidCrossEntropy"),s=null;if(null!=r&&(s=convertToTensor(r,"weights","sigmoidCrossEntropy")),assertShapesMatch(a.shape,i.shape,"Error in sigmoidCrossEntropy: "),n>0){var u=scalar(n),l=scalar(1),c=scalar(.5);a=a.mul(l.sub(u)).add(c.mul(u))}var p=sigmoidCrossEntropyWithLogits_(a,i);return computeWeightedLoss(p,s,o)}function huberLoss_(e,t,r,n,o){void 0===n&&(n=1),void 0===o&&(o=Reduction.SUM_BY_NONZERO_WEIGHTS);var a=convertToTensor(e,"labels","huberLoss"),i=convertToTensor(t,"predictions","huberLoss"),s=null;null!=r&&(s=convertToTensor(r,"weights","huberLoss")),assertShapesMatch(a.shape,i.shape,"Error in huberLoss: ");var u=scalar(n),l=i.sub(a).abs(),c=minimum(l,u),p=l.sub(c),d=scalar(.5).mul(c.square()).add(u.mul(p));return computeWeightedLoss(d,s,o)}function softmaxCrossEntropyWithLogits_(e,t,r){if(void 0===r&&(r=-1),-1===r&&(r=t.rank-1),r!==t.rank-1)throw Error("Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank "+t.rank+" and dim was "+r);return customGrad(function(e,t){var n=t.logSumExp([r],!0),o=t.toFloat().sub(n);return{value:o.mul(e).neg().sum([r]),gradFunc:function(t){var n=expandShapeToKeepDim(t.shape,[r]);return[t.reshape(n).mul(e.toFloat().sub(o.exp())),t.reshape(n).mul(o.exp().sub(e.toFloat()))]}}})(e,t)}function softmaxCrossEntropy_(e,t,r,n,o){void 0===n&&(n=0),void 0===o&&(o=Reduction.SUM_BY_NONZERO_WEIGHTS);var a=convertToTensor(e,"onehotLabels","softmaxCrossEntropy"),i=convertToTensor(t,"logits","softmaxCrossEntropy"),s=null;if(null!=r&&(s=convertToTensor(r,"weights","softmaxCrossEntropy")),assertShapesMatch(a.shape,i.shape,"Error in softmaxCrossEntropy: "),n>0){var u=scalar(n),l=scalar(1),c=scalar(a.shape[1]);a=a.mul(l.sub(u)).add(u.div(c))}var p=softmaxCrossEntropyWithLogits_(a,i);return computeWeightedLoss(p,s,o)}!function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(Reduction||(Reduction={}));var absoluteDifference=op({absoluteDifference_:absoluteDifference_}),computeWeightedLoss=op({computeWeightedLoss_:computeWeightedLoss_}),cosineDistance=op({cosineDistance_:cosineDistance_}),hingeLoss=op({hingeLoss_:hingeLoss_}),huberLoss=op({huberLoss_:huberLoss_}),logLoss=op({logLoss_:logLoss_}),meanSquaredError=op({meanSquaredError_:meanSquaredError_}),sigmoidCrossEntropy=op({sigmoidCrossEntropy_:sigmoidCrossEntropy_}),softmaxCrossEntropy=op({softmaxCrossEntropy_:softmaxCrossEntropy_}),loss_ops=Object.freeze({get Reduction(){return Reduction},absoluteDifference:absoluteDifference,computeWeightedLoss:computeWeightedLoss,cosineDistance:cosineDistance,hingeLoss:hingeLoss,huberLoss:huberLoss,logLoss:logLoss,meanSquaredError:meanSquaredError,sigmoidCrossEntropy:sigmoidCrossEntropy,softmaxCrossEntropy:softmaxCrossEntropy});function gramSchmidt_(e){var t;if(Array.isArray(e)){t=!1,assert(null!=e&&e.length>0,"Gram-Schmidt process: input must not be null, undefined, or empty");for(var r=e[0].shape[0],n=1;n<e.length;++n)assert(e[n].shape[0]===r,"Gram-Schmidt: Non-unique lengths found in the input vectors: ("+e[n].shape[0]+" vs. "+r+")")}else t=!0,e=split$1(e,e.shape[0],0).map(function(e){return squeeze(e,[0])});assert(e.length<=e[0].shape[0],"Gram-Schmidt: Number of vectors ("+e.length+") exceeds number of dimensions ("+e[0].shape[0]+").");var o=[],a=e,i=function(e){o.push(ENV.engine.tidy(function(){var t=a[e];if(e>0)for(var r=0;r<e;++r){var n=sum$1(o[r].mulStrict(t)).mul(o[r]);t=t.sub(n)}return t.div(norm(t,"euclidean"))}))};for(n=0;n<e.length;++n)i(n);return t?stack(o,0):o}function qr_(e,t){if(void 0===t&&(t=!1),e.rank<2)throw new Error("qr() requires input tensor to have a rank >= 2, but got rank "+e.rank);if(2===e.rank)return qr2d(e,t);var r=e.shape.slice(0,e.shape.length-2).reduce(function(e,t){return e*t}),n=[],o=[];return unstack(e.reshape([r,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0).forEach(function(e){var r=qr2d(e,t),a=r[0],i=r[1];n.push(a),o.push(i)}),[stack(n,0).reshape(e.shape),stack(o,0).reshape(e.shape)]}function qr2d(e,t){return void 0===t&&(t=!1),ENV.engine.tidy(function(){if(2!==e.shape.length)throw new Error("qr2d() requires a 2D Tensor, but got a "+e.shape.length+"D Tensor.");for(var r=e.shape[0],n=e.shape[1],o=eye(r),a=e.clone(),i=tensor2d([[1]],[1,1]),s=i.clone(),u=r>=n?n:r,l=function(e){var t,u=a,l=s,c=o;t=ENV.engine.tidy(function(){var t=a.slice([e,e],[r-e,1]),u=t.norm(),l=a.slice([e,e],[1,1]),c=l.sign().neg(),p=l.sub(c.mul(u)),d=t.div(p);s=1===d.shape[0]?i.clone():i.concat(d.slice([1,0],[d.shape[0]-1,d.shape[1]]),0);var h=c.matMul(p).div(u).neg(),f=a.slice([e,0],[r-e,n]),m=h.mul(s);a=0===e?f.sub(m.matMul(s.transpose().matMul(f))):a.slice([0,0],[e,n]).concat(f.sub(m.matMul(s.transpose().matMul(f))),0);var g=o.slice([0,e],[r,o.shape[1]-e]);return o=0===e?g.sub(g.matMul(s).matMul(m.transpose())):o.slice([0,0],[r,e]).concat(g.sub(g.matMul(s).matMul(m.transpose())),1),[s,a,o]}),s=t[0],a=t[1],o=t[2],dispose([u,l,c])},c=0;c<u;++c)l(c);return!t&&r>n&&(o=o.slice([0,0],[r,n]),a=a.slice([0,0],[n,n])),[o,a]})}var gramSchmidt=op({gramSchmidt_:gramSchmidt_}),qr=op({qr_:qr_}),linalg_ops=Object.freeze({gramSchmidt:gramSchmidt,qr:qr});function resizeBilinear_(e,t,r){void 0===r&&(r=!1);var n=convertToTensor(e,"images","resizeBilinear");assert(3===n.rank||4===n.rank,"Error in resizeBilinear: x must be rank 3 or 4, but got rank "+n.rank+"."),assert(2===t.length,"Error in resizeBilinear: new shape must 2D, but got shape "+t+".");var o=n,a=!1;3===n.rank&&(a=!0,o=n.as4D(1,n.shape[0],n.shape[1],n.shape[2]));var i=t[0],s=t[1],u=ENV.engine.runKernel(function(e,t){return e.resizeBilinear(o,i,s,r)},{batchImages:o},function(e,t){return{batchImages:function(){return ENV.engine.runKernel(function(t){return t.resizeBilinearBackprop(e,o,r)},{})}}});return a?u.as3D(u.shape[1],u.shape[2],u.shape[3]):u}function resizeNearestNeighbor_(e,t,r){void 0===r&&(r=!1);var n=convertToTensor(e,"images","resizeNearestNeighbor");assert(3===n.rank||4===n.rank,"Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank "+n.rank+"."),assert(2===t.length,"Error in resizeNearestNeighbor: new shape must 2D, but got shape "+t+"."),assert("float32"===n.dtype||"int32"===n.dtype,"`images` must have `int32` or `float32` as dtype");var o=n,a=!1;3===n.rank&&(a=!0,o=n.as4D(1,n.shape[0],n.shape[1],n.shape[2]));var i=t[0],s=t[1],u=ENV.engine.runKernel(function(e,t){return e.resizeNearestNeighbor(o,i,s,r)},{batchImages:o},function(e,t){return{batchImages:function(){return ENV.engine.runKernel(function(t){return t.resizeNearestNeighborBackprop(e,o,r)},{})}}});return a?u.as3D(u.shape[1],u.shape[2],u.shape[3]):u}function nonMaxSuppression_(e,t,r,n,o){void 0===n&&(n=.5),void 0===o&&(o=Number.NEGATIVE_INFINITY);var a=convertToTensor(e,"boxes","nonMaxSuppression"),i=convertToTensor(t,"scores","nonMaxSuppression"),s=nonMaxSuppSanityCheck(a,i,r,n,o);return r=s.maxOutputSize,n=s.iouThreshold,o=s.scoreThreshold,ENV.engine.runKernel(function(e){return e.nonMaxSuppression(a,i,r,n,o)},{$boxes:a})}function nonMaxSuppressionAsync_(e,t,r,n,o){return void 0===n&&(n=.5),void 0===o&&(o=Number.NEGATIVE_INFINITY),__awaiter(this,void 0,void 0,function(){var a,i,s,u,l,c;return __generator(this,function(p){switch(p.label){case 0:return a=convertToTensor(e,"boxes","nonMaxSuppressionAsync"),i=convertToTensor(t,"scores","nonMaxSuppressionAsync"),s=nonMaxSuppSanityCheck(a,i,r,n,o),r=s.maxOutputSize,n=s.iouThreshold,o=s.scoreThreshold,[4,a.data()];case 1:return u=p.sent(),[4,i.data()];case 2:return l=p.sent(),c=nonMaxSuppressionImpl(u,l,r,n,o),a!==e&&a.dispose(),i!==t&&i.dispose(),[2,c]}})})}function nonMaxSuppSanityCheck(e,t,r,n,o){null==n&&(n=.5),null==o&&(o=Number.NEGATIVE_INFINITY);var a=e.shape[0];return r=Math.min(r,a),assert(0<=n&&n<=1,"iouThreshold must be in [0, 1], but was '"+n+"'"),assert(2===e.rank,"boxes must be a 2D tensor, but was of rank '"+e.rank+"'"),assert(4===e.shape[1],"boxes must have 4 columns, but 2nd dimension was "+e.shape[1]),assert(1===t.rank,"scores must be a 1D tensor"),assert(t.shape[0]===a,"scores has incompatible shape with boxes. Expected "+a+", but was "+t.shape[0]),{maxOutputSize:r,iouThreshold:n,scoreThreshold:o}}function cropAndResize_(e,t,r,n,o,a){var i=convertToTensor(e,"image","cropAndResize","float32"),s=convertToTensor(t,"boxes","cropAndResize","float32"),u=convertToTensor(r,"boxInd","cropAndResize","int32");o=o||"bilinear",a=a||0;var l=s.shape[0];assert(4===i.rank,"Error in cropAndResize: image must be rank 4,but got rank "+i.rank+"."),assert(2===s.rank&&4===s.shape[1],"Error in cropAndResize: boxes must be have size ["+l+",4] but had shape "+s.shape+"."),assert(1===u.rank&&u.shape[0]===l,"Error in cropAndResize: boxInd must be have size ["+l+"] but had shape "+s.shape+"."),assert("int32"===u.dtype,"Error in cropAndResize: boxInd must be of dtype int32, but got dtype "+u.dtype+"."),assert(2===n.length,"Error in cropAndResize: cropSize must be of length 2, but got length "+n.length+"."),assert(n[0]>=1&&n[1]>=1,"cropSize must be atleast [1,1], but was "+n),assert("bilinear"===o||"nearest"===o,"method must be bilinear or nearest, but was "+o);return ENV.engine.runKernel(function(e,t){return e.cropAndResize(i,s,u,n,o,a)},{$image:i,$boxes:s})}var resizeBilinear=op({resizeBilinear_:resizeBilinear_}),resizeNearestNeighbor=op({resizeNearestNeighbor_:resizeNearestNeighbor_}),nonMaxSuppression=op({nonMaxSuppression_:nonMaxSuppression_}),nonMaxSuppressionAsync=nonMaxSuppressionAsync_,cropAndResize=cropAndResize_,image_ops=Object.freeze({resizeBilinear:resizeBilinear,resizeNearestNeighbor:resizeNearestNeighbor,nonMaxSuppression:nonMaxSuppression,nonMaxSuppressionAsync:nonMaxSuppressionAsync,cropAndResize:cropAndResize}),ops=Object.freeze({image:image_ops,linalg:linalg_ops,losses:loss_ops,spectral:spectral_ops,op:op,batchNormalization2d:batchNormalization2d,batchNormalization3d:batchNormalization3d,batchNormalization4d:batchNormalization4d,batchNormalization:batchNormalization,complex:complex,real:real,imag:imag,concat:concat,concat1d:concat1d,concat2d:concat2d,concat3d:concat3d,concat4d:concat4d,split:split$1,conv1d:conv1d,conv2d:conv2d,conv2dDerFilter:conv2dDerFilter,depthwiseConv2d:depthwiseConv2d,separableConv2d:separableConv2d,conv2dTranspose:conv2dTranspose,matMul:matMul,dot:dot,outerProduct:outerProduct,reverse:reverse,reverse1d:reverse1d,reverse2d:reverse2d,reverse3d:reverse3d,reverse4d:reverse4d,maxPool:maxPool,avgPool:avgPool,pool:pool,slice:slice,slice1d:slice1d,slice2d:slice2d,slice3d:slice3d,slice4d:slice4d,abs:abs,acos:acos,acosh:acosh,asin:asin,asinh:asinh,atan:atan,atanh:atanh,ceil:ceil,clipByValue:clipByValue,cos:cos,cosh:cosh,erf:erf,exp:exp,expm1:expm1,floor:floor,log:log$1,log1p:log1p,logSigmoid:logSigmoid,neg:neg,reciprocal:reciprocal,round:round,rsqrt:rsqrt,sigmoid:sigmoid,sign:sign,sin:sin,sinh:sinh,softplus:softplus,sqrt:sqrt,square:square,step:step,tan:tan,tanh:tanh$1,all:all,any:any,argMax:argMax,argMin:argMin,logSumExp:logSumExp,max:max,mean:mean,min:min,moments:moments,sum:sum$1,prod:prod,equal:equal,equalStrict:equalStrict,greater:greater,greaterEqual:greaterEqual,greaterEqualStrict:greaterEqualStrict,greaterStrict:greaterStrict,less:less,lessEqual:lessEqual,lessEqualStrict:lessEqualStrict,lessStrict:lessStrict,notEqual:notEqual,notEqualStrict:notEqualStrict,add:add,addN:addN,addStrict:addStrict,atan2:atan2,div:div,divStrict:divStrict,floorDiv:floorDiv,maximum:maximum,maximumStrict:maximumStrict,minimum:minimum,minimumStrict:minimumStrict,mod:mod,modStrict:modStrict,mul:mul,mulStrict:mulStrict,pow:pow,powStrict:powStrict,squaredDifference:squaredDifference,squaredDifferenceStrict:squaredDifferenceStrict,sub:sub,subStrict:subStrict,elu:elu,leakyRelu:leakyRelu,prelu:prelu,relu:relu,selu:selu,logicalAnd:logicalAnd,logicalNot:logicalNot,logicalOr:logicalOr,logicalXor:logicalXor,where:where,whereAsync:whereAsync,buffer:buffer,toPixels:toPixels,print:print,batchToSpaceND:batchToSpaceND,cast:cast,clone:clone,cumsum:cumsum,depthToSpace:depthToSpace,expandDims:expandDims,eye:eye,fromPixels:fromPixels,multinomial:multinomial,oneHot:oneHot,pad:pad,pad1d:pad1d,pad2d:pad2d,pad3d:pad3d,pad4d:pad4d,rand:rand,randomNormal:randomNormal,randomUniform:randomUniform,reshape:reshape,spaceToBatchND:spaceToBatchND,squeeze:squeeze,stack:stack,tile:tile,truncatedNormal:truncatedNormal,unstack:unstack,setdiff1dAsync:setdiff1dAsync,fill:fill,linspace:linspace,ones:ones$1,range:range,scalar:scalar,tensor:tensor,tensor1d:tensor1d,tensor2d:tensor2d,tensor3d:tensor3d,tensor4d:tensor4d,tensor5d:tensor5d,tensor6d:tensor6d,zeros:zeros,onesLike:onesLike,zerosLike:zerosLike,transpose:transpose,softmax:softmax,logSoftmax:logSoftmax,localResponseNormalization:localResponseNormalization,norm:norm,gather:gather,unsortedSegmentSum:unsortedSegmentSum,basicLSTMCell:basicLSTMCell,multiRNNCell:multiRNNCell,movingAverage:movingAverage,stridedSlice:stridedSlice,topk:topk,scatterND:scatterND,fft:fft,ifft:ifft,rfft:rfft,sparseToDense:sparseToDense,gatherND:gatherND}),MathBackendCPU=function(){function e(){this.blockSize=48,this.firstUse=!0,ENV.get("IS_BROWSER")&&(this.fromPixels2DContext=document.createElement("canvas").getContext("2d"))}return e.prototype.setDataMover=function(e){this.data=new DataStorage(e)},e.prototype.register=function(e,t,r){if(this.firstUse&&(this.firstUse=!1,ENV.get("IS_NODE")&&warn("\n============================\nHi there . Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================\n")),this.data.has(e))throw new Error("Data buffer is already registered");this.data.set(e,{dtype:r})},e.prototype.write=function(e,t){if(null==t)throw new Error("MathBackendCPU.write(): values can not be null");this.data.get(e).values=t},e.prototype.fromPixels=function(e,t){if(null==e)throw new Error("pixels passed to tf.fromPixels() can not be null");var r,n;if(ENV.get("IS_NODE")&&null==e.getContext)throw new Error("When running in node, pixels must be an HTMLCanvasElement like the one returned by the `canvas` npm package");if(null!=e.getContext)r=e.getContext("2d").getImageData(0,0,e.width,e.height).data;else if(e instanceof ImageData)r=e.data;else{if(!(e instanceof HTMLImageElement||e instanceof HTMLVideoElement))throw new Error("pixels passed to tf.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement or ImageData, but was "+e.constructor.name);if(null==this.fromPixels2DContext)throw new Error("Can't read pixels from HTMLImageElement outside the browser.");this.fromPixels2DContext.canvas.width=e.width,this.fromPixels2DContext.canvas.height=e.height,this.fromPixels2DContext.drawImage(e,0,0,e.width,e.height),r=this.fromPixels2DContext.getImageData(0,0,e.width,e.height).data}if(4===t)n=new Int32Array(r);else{var o=e.width*e.height;n=new Int32Array(o*t);for(var a=0;a<o;a++)for(var i=0;i<t;++i)n[a*t+i]=r[4*a+i]}return tensor3d(n,[e.height,e.width,t],"int32")},e.prototype.read=function(e){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(t){return[2,this.readSync(e)]})})},e.prototype.readSync=function(e){var t=this.data.get(e),r=t.dtype,n=t.complexTensors;return"complex64"===r?mergeRealAndImagArrays(n.real.dataSync(),n.imag.dataSync()):this.data.get(e).values},e.prototype.disposeData=function(e){if(this.data.has(e)){var t=this.data.get(e).complexTensors;null!=t&&(t.real.dispose(),t.imag.dispose()),this.data.delete(e)}},e.prototype.time=function(e){return __awaiter(this,void 0,void 0,function(){var t;return __generator(this,function(r){return t=now(),e(),[2,{kernelMs:now()-t}]})})},e.prototype.memory=function(){return{unreliable:!0}},e.prototype.complex=function(e,t){var r=Tensor.make(e.shape,{},"complex64");return this.data.get(r.dataId).complexTensors={real:ENV.engine.keep(e.clone()),imag:ENV.engine.keep(t.clone())},r},e.prototype.real=function(e){return this.data.get(e.dataId).complexTensors.real.clone()},e.prototype.imag=function(e){return this.data.get(e.dataId).complexTensors.imag.clone()},e.prototype.assertNotComplex=function(e,t){Array.isArray(e)||(e=[e]),e.forEach(function(e){null!=e&&assert("complex64"!==e.dtype,t+" does not support complex64 tensors.")})},e.prototype.slice=function(e,t,r){this.assertNotComplex(e,"slice");for(var n=buffer(r,e.dtype),o=0;o<n.size;++o){var a=n.indexToLoc(o),i=a.map(function(e,r){return e+t[r]});n.set.apply(n,[e.get.apply(e,i)].concat(a))}return n.toTensor()},e.prototype.stridedSlice=function(e,t,r,n,o,a,i,s,u){this.assertNotComplex(e,"stridedSlice");var l=getStridedSlicedInfo(e.shape,t,r,n,o,a,i,s,u),c=l[0],p=l[1],d=l[2],h=p.filter(function(e,t){return-1===d.indexOf(t)});if(h.some(function(e){return 0===e}))return tensor([],h);for(var f=buffer(p,e.dtype),m=0;m<f.size;m++){for(var g=f.indexToLoc(m),v=new Array(g.length),y=0;y<v.length;y++)v[y]=g[y]*n[y]+c[y];f.set.apply(f,[e.get.apply(e,v)].concat(g))}return f.toTensor().reshape(h)},e.prototype.reverse=function(e,t){this.assertNotComplex(e,"reverse");for(var r=buffer(e.shape,e.dtype),n=e.buffer(),o=function(o){var a=r.indexToLoc(o),i=a.slice();t.forEach(function(t){return i[t]=e.shape[t]-1-i[t]}),r.set.apply(r,[n.get.apply(n,i)].concat(a))},a=0;a<r.size;a++)o(a);return r.toTensor()},e.prototype.concat=function(e,t){this.assertNotComplex(e,"concat");var r=e.map(function(e){var r=sizeFromShape(e.shape.slice(t));return e.as2D(-1,r)}),n=computeOutShape(r.map(function(e){return e.shape}),1),o=buffer(n,e[0].dtype).values;if(1===r[0].shape[0]){var a=0;r.forEach(function(e){o.set(e.dataSync(),a),a+=e.size})}else{var i=0;r.forEach(function(e){for(var t=e.dataSync(),r=0,a=0;a<e.shape[0];++a)for(var s=a*n[1]+i,u=0;u<e.shape[1];++u)o[s+u]=t[r++];i+=e.shape[1]})}var s=computeOutShape(e.map(function(e){return e.shape}),t);return tensor(o,s,e[0].dtype)},e.prototype.neg=function(e){return this.assertNotComplex(e,"neg"),this.multiply(scalar(-1),e)},e.prototype.add=function(e,t){return"complex64"===e.dtype||"complex64"===t.dtype?this.broadcastedBinaryComplexOp(e.cast("complex64"),t.cast("complex64"),function(e,t,r,n){return{real:e+r,imag:t+n}}):this.broadcastedBinaryOp(e,t,upcastType(e.dtype,t.dtype),function(e,t){return e+t})},e.prototype.addN=function(e){this.assertNotComplex(e,"addN");for(var t=e.map(function(e){return e.dataSync()}),r=buffer(e[0].shape,e[0].dtype),n=r.values,o=0;o<e.length;o++)for(var a=t[o],i=0;i<n.length;i++)n[i]+=a[i];return r.toTensor()},e.prototype.subtract=function(e,t){return"complex64"===e.dtype||"complex64"===t.dtype?this.broadcastedBinaryComplexOp(e.cast("complex64"),t.cast("complex64"),function(e,t,r,n){return{real:e-r,imag:t-n}}):this.broadcastedBinaryOp(e,t,upcastType(e.dtype,t.dtype),function(e,t){return e-t})},e.prototype.pow=function(e,t){return this.assertNotComplex([e,t],"pow"),this.broadcastedBinaryOp(e,t,e.dtype,function(e,t){return Math.pow(e,t)})},e.prototype.batchMatMul=function(e,t,r,n){this.assertNotComplex([e,t],"matMul");for(var o=r?e.shape[1]:e.shape[2],a=r?e.shape[2]:e.shape[1],i=n?t.shape[1]:t.shape[2],s=e.shape[0],u=e.dataSync(),l=t.dataSync(),c=r?[e.strides[0],1,e.strides[1]]:[e.strides[0],e.strides[1],1],p=c[0],d=c[1],h=c[2],f=n?[1,t.strides[1],t.strides[0]]:[t.strides[1],1,t.strides[0]],m=f[0],g=f[1],v=f[2],y=a*i,x=new Float32Array(s*y),T=this.blockSize,E=0;E<s;E++)for(var w=0;w<a;w+=T)for(var S=0;S<i;S+=T)for(var b=0;b<o;b+=T)for(var C=Math.min(w+T,a),_=Math.min(S+T,i),A=Math.min(b+T,o),N=w;N<C;N++)for(var R=S;R<_;R++){for(var I=0,k=b;k<A;k++)I+=u[E*p+N*d+k*h]*l[k*m+R*g+E*v];x[E*y+(N*i+R)]+=I}return tensor3d(x,[s,a,i])},e.prototype.multiply=function(e,t){return"complex64"===e.dtype||"complex64"===t.dtype?this.broadcastedBinaryComplexOp(e.cast("complex64"),t.cast("complex64"),function(e,t,r,n){return{real:e*r-t*n,imag:e*n+t*r}}):this.broadcastedBinaryOp(e,t,upcastType(e.dtype,t.dtype),function(e,t){return e*t})},e.prototype.realDivide=function(e,t){this.assertNotComplex([e,t],"realDivide");return this.broadcastedBinaryOp(e,t,"float32",function(e,t){return e/t})},e.prototype.floorDiv=function(e,t){this.assertNotComplex([e,t],"floorDiv");return this.broadcastedBinaryOp(e,t,"int32",function(e,t){return Math.floor(e/t)})},e.prototype.sum=function(e,t){this.assertNotComplex(e,"sum"),assertAxesAreInnerMostDims("sum",t,e.rank);for(var r=computeOutAndReduceShapes(e.shape,t),n=r[0],o=r[1],a=zeros(n,upcastType(e.dtype,"int32")),i=sizeFromShape(o),s=a.dataSync(),u=e.dataSync(),l=0;l<s.length;++l){for(var c=l*i,p=0,d=0;d<i;++d)p+=u[c+d];s[l]=p}return a},e.prototype.prod=function(e,t){this.assertNotComplex(e,"sum");for(var r=computeOutAndReduceShapes(e.shape,t),n=r[0],o=r[1],a=zeros(n,upcastType(e.dtype,"int32")),i=sizeFromShape(o),s=a.dataSync(),u=e.dataSync(),l=0;l<s.length;++l){for(var c=l*i,p=1,d=0;d<i;++d)p*=u[c+d];s[l]=p}return a},e.prototype.unsortedSegmentSum=function(e,t,r){this.assertNotComplex(e,"unsortedSegmentSum");for(var n=[],o=e.rank-t.rank,a=0;a<o;++a)t=t.expandDims(a+1);for(a=0;a<r;++a){var i=scalar(a,"int32"),s=equal(i,t).asType("float32").mul(e).sum(0);n.push(s)}return stack(n)},e.prototype.argMin=function(e,t){this.assertNotComplex(e,"argMin");var r=[t];assertAxesAreInnerMostDims("argMin",r,e.rank);for(var n=computeOutAndReduceShapes(e.shape,r),o=n[0],a=n[1],i=zeros(o,"int32"),s=sizeFromShape(a),u=i.dataSync(),l=e.dataSync(),c=0;c<u.length;++c){for(var p=c*s,d=l[p],h=0,f=0;f<s;++f){var m=l[p+f];m<d&&(d=m,h=f)}u[c]=h}return i},e.prototype.argMax=function(e,t){this.assertNotComplex(e,"argMax");var r=[t];assertAxesAreInnerMostDims("argMax",r,e.rank);for(var n=computeOutAndReduceShapes(e.shape,r),o=n[0],a=n[1],i=zeros(o,"int32"),s=sizeFromShape(a),u=i.dataSync(),l=e.dataSync(),c=0;c<u.length;++c){for(var p=c*s,d=l[p],h=0,f=0;f<s;++f){var m=l[p+f];m>d&&(d=m,h=f)}u[c]=h}return i},e.prototype.cumsum=function(e,t,r,n){if(this.assertNotComplex(e,"cumsum"),t!==e.rank-1)throw new Error("backend.cumsum in CPU expects an inner-most axis="+(e.rank-1)+" but got axis="+t);for(var o=upcastType(e.dtype,"int32"),a=zeros(e.shape,o),i=a.dataSync(),s=e.dataSync(),u=e.shape[e.rank-1],l=n?function(e,t){return e+u-t-1}:function(e,t){return e+t},c=0;c<s.length;c+=u)for(var p=0;p<u;p++){var d=l(c,p);if(0===p)i[d]=r?0:s[d];else{var h=l(c,p-1);i[d]=r?s[h]+i[h]:s[d]+i[h]}}return a},e.prototype.equal=function(e,t){return this.assertNotComplex([e,t],"equal"),this.broadcastedBinaryOp(e,t,"bool",function(e,t){return e===t?1:0})},e.prototype.notEqual=function(e,t){return this.assertNotComplex([e,t],"notEqual"),this.broadcastedBinaryOp(e,t,"bool",function(e,t){return e!==t?1:0})},e.prototype.less=function(e,t){return this.assertNotComplex([e,t],"less"),this.broadcastedBinaryOp(e,t,"bool",function(e,t){return e<t?1:0})},e.prototype.lessEqual=function(e,t){return this.assertNotComplex([e,t],"lessEqual"),this.broadcastedBinaryOp(e,t,"bool",function(e,t){return e<=t?1:0})},e.prototype.greater=function(e,t){return this.assertNotComplex([e,t],"greater"),this.broadcastedBinaryOp(e,t,"bool",function(e,t){return e>t?1:0})},e.prototype.greaterEqual=function(e,t){return this.assertNotComplex([e,t],"greaterEqual"),this.broadcastedBinaryOp(e,t,"bool",function(e,t){return e>=t?1:0})},e.prototype.logicalNot=function(e){this.assertNotComplex(e,"logicalNot");for(var t=e.dataSync(),r=new Int32Array(t.length),n=0;n<t.length;++n)r[n]=t[n]?0:1;return Tensor.make(e.shape,{values:r},"bool")},e.prototype.logicalAnd=function(e,t){return this.assertNotComplex([e,t],"logicalAnd"),this.broadcastedBinaryOp(e,t,"bool",function(e,t){return e&&t})},e.prototype.logicalOr=function(e,t){return this.assertNotComplex([e,t],"logicalOr"),this.broadcastedBinaryOp(e,t,"bool",function(e,t){return e||t})},e.prototype.select=function(e,t,r){this.assertNotComplex([e,t,r],"select");for(var n=e.dataSync(),o=t.dataSync(),a=r.dataSync(),i=zeros(t.shape,upcastType(t.dtype,r.dtype)),s=i.dataSync(),u=0,l=0===e.rank||e.rank>1||1===t.rank?1:t.shape[1],c=0;c<n.length;c++)for(var p=0;p<l;p++)1===n[c]?s[u++]=o[c]:s[u++]=a[c];return i},e.prototype.where=function(e){this.assertNotComplex([e],"where");var t=e.dataSync();return whereImpl(e.shape,t)},e.prototype.topk=function(e,t,r){return this.assertNotComplex(e,"topk"),topkImpl(e.dataSync(),e.shape,e.dtype,t,r)},e.prototype.min=function(e,t){this.assertNotComplex(e,"min"),assertAxesAreInnerMostDims("min",t,e.rank);for(var r=computeOutAndReduceShapes(e.shape,t),n=r[0],o=r[1],a=zeros(n,e.dtype),i=sizeFromShape(o),s=a.dataSync(),u=e.dataSync(),l=0;l<s.length;++l){for(var c=l*i,p=u[c],d=0;d<i;++d){var h=u[c+d];h<p&&(p=h)}s[l]=p}return a},e.prototype.minimum=function(e,t){return this.assertNotComplex([e,t],"minimum"),this.broadcastedBinaryOp(e,t,e.dtype,function(e,t){return Math.min(e,t)})},e.prototype.mod=function(e,t){return this.assertNotComplex([e,t],"mod"),this.broadcastedBinaryOp(e,t,e.dtype,function(e,t){var r=e%t;return e<0&&t<0||e>=0&&t>=0?r:(r+t)%t})},e.prototype.max=function(e,t){this.assertNotComplex(e,"max"),assertAxesAreInnerMostDims("max",t,e.rank);for(var r=computeOutAndReduceShapes(e.shape,t),n=r[0],o=r[1],a=zeros(n,e.dtype),i=sizeFromShape(o),s=a.dataSync(),u=e.dataSync(),l=0;l<s.length;++l){for(var c=l*i,p=u[c],d=0;d<i;++d){var h=u[c+d];h>p&&(p=h)}s[l]=p}return a},e.prototype.maximum=function(e,t){return this.assertNotComplex([e,t],"maximum"),this.broadcastedBinaryOp(e,t,e.dtype,function(e,t){return Math.max(e,t)})},e.prototype.all=function(e,t){this.assertNotComplex(e,"all"),assertAxesAreInnerMostDims("all",t,e.rank);for(var r=computeOutAndReduceShapes(e.shape,t),n=r[0],o=r[1],a=zeros(n,e.dtype),i=sizeFromShape(o),s=a.dataSync(),u=e.dataSync(),l=0;l<s.length;++l){for(var c=l*i,p=u[c],d=0;d<i;++d){var h=u[c+d];p=p&&h}s[l]=p}return a},e.prototype.any=function(e,t){this.assertNotComplex(e,"any"),assertAxesAreInnerMostDims("any",t,e.rank);for(var r=computeOutAndReduceShapes(e.shape,t),n=r[0],o=r[1],a=zeros(n,e.dtype),i=sizeFromShape(o),s=a.dataSync(),u=e.dataSync(),l=0;l<s.length;++l){for(var c=l*i,p=u[c],d=0;d<i;++d){var h=u[c+d];p=p||h}s[l]=p}return a},e.prototype.squaredDifference=function(e,t){return this.assertNotComplex([e,t],"squaredDifference"),this.broadcastedBinaryOp(e,t,e.dtype,function(e,t){var r=e-t;return r*r})},e.prototype.ceil=function(e){this.assertNotComplex(e,"ceil");for(var t=e.dataSync(),r=new Float32Array(t.length),n=0;n<t.length;++n)r[n]=Math.ceil(t[n]);return Tensor.make(e.shape,{values:r})},e.prototype.floor=function(e){this.assertNotComplex(e,"floor");for(var t=e.dataSync(),r=new Float32Array(t.length),n=0;n<t.length;++n)r[n]=Math.floor(t[n]);return Tensor.make(e.shape,{values:r})},e.prototype.sign=function(e){this.assertNotComplex(e,"x");for(var t=e.dataSync(),r=new Float32Array(t.length),n=0;n<t.length;++n)t[n]<0?r[n]=-1:t[n]>0?r[n]=1:r[n]=0;return Tensor.make(e.shape,{values:r})},e.prototype.round=function(e){this.assertNotComplex(e,"round");for(var t=e.dataSync(),r=new Float32Array(t.length),n=0;n<t.length;++n){var o=Math.floor(t[n]);t[n]-o<.5?r[n]=Math.floor(t[n]):t[n]-o>.5?r[n]=Math.ceil(t[n]):r[n]=o%2==0?o:o+1}return Tensor.make(e.shape,{values:r})},e.prototype.exp=function(e){this.assertNotComplex(e,"exp");for(var t=e.dataSync(),r=new Float32Array(t.length),n=0;n<t.length;++n)r[n]=Math.exp(t[n]);return Tensor.make(e.shape,{values:r})},e.prototype.expm1=function(e){this.assertNotComplex(e,"expm1");for(var t=e.dataSync(),r=new Float32Array(t.length),n=0;n<t.length;++n)r[n]=Math.expm1(t[n]);return Tensor.make(e.shape,{values:r})},e.prototype.log=function(e){this.assertNotComplex(e,"log");for(var t=e.dataSync(),r=new Float32Array(t.length),n=0;n<t.length;++n){var o=t[n];r[n]=Math.log(o)}return Tensor.make(e.shape,{values:r})},e.prototype.log1p=function(e){this.assertNotComplex(e,"log1p");for(var t=e.dataSync(),r=new Float32Array(t.length),n=0;n<t.length;++n){var o=t[n];r[n]=Math.log1p(o)}return Tensor.make(e.shape,{values:r})},e.prototype.sqrt=function(e){this.assertNotComplex(e,"sqrt");for(var t=e.dataSync(),r=new Float32Array(t.length),n=0;n<t.length;++n){var o=t[n];r[n]=Math.sqrt(o)}return Tensor.make(e.shape,{values:r})},e.prototype.rsqrt=function(e){this.assertNotComplex(e,"rsqrt");for(var t=e.dataSync(),r=new Float32Array(t.length),n=0;n<t.length;++n){var o=t[n];r[n]=1/Math.sqrt(o)}return Tensor.make(e.shape,{values:r})},e.prototype.square=function(e){this.assertNotComplex(e,"square");for(var t=e.dataSync(),r=new Float32Array(t.length),n=0;n<t.length;++n){var o=t[n];r[n]=o*o}return Tensor.make(e.shape,{values:r})},e.prototype.reciprocal=function(e){this.assertNotComplex(e,"reciprocal");for(var t=e.dataSync(),r=new Float32Array(t.length),n=0;n<t.length;++n)r[n]=1/t[n];return Tensor.make(e.shape,{values:r})},e.prototype.relu=function(e){this.assertNotComplex(e,"relu");for(var t=zeros(e.shape,e.dtype),r=t.dataSync(),n=e.dataSync(),o=0;o<n.length;++o)r[o]=Math.max(0,n[o]);return t},e.prototype.elu=function(e){this.assertNotComplex(e,"elu");for(var t=new Float32Array(e.size),r=e.dataSync(),n=0;n<r.length;++n){var o=r[n];t[n]=o>=0?o:Math.exp(o)-1}return Tensor.make(e.shape,{values:t})},e.prototype.eluDer=function(e,t){this.assertNotComplex([e,t],"eluDer");for(var r=new Float32Array(t.size),n=t.dataSync(),o=e.dataSync(),a=0;a<n.length;++a){var i=n[a];r[a]=i>=1?o[a]:o[a]*(i+1)}return Tensor.make(t.shape,{values:r})},e.prototype.selu=function(e){this.assertNotComplex(e,"selu");for(var t=SELU_SCALEALPHA,r=SELU_SCALE,n=new Float32Array(e.size),o=e.dataSync(),a=0;a<o.length;++a){var i=o[a];n[a]=i>=0?r*i:t*(Math.exp(i)-1)}return Tensor.make(e.shape,{values:n})},e.prototype.clip=function(e,t,r){this.assertNotComplex(e,"clip");for(var n=new Float32Array(e.size),o=e.dataSync(),a=0;a<o.length;++a){var i=o[a];n[a]=i>r?r:i<t?t:i}return Tensor.make(e.shape,{values:n})},e.prototype.abs=function(e){for(var t=new Float32Array(e.size),r=e.dataSync(),n=0;n<r.length;++n)t[n]=Math.abs(r[n]);return Tensor.make(e.shape,{values:t})},e.prototype.complexAbs=function(e){for(var t=new Float32Array(e.size),r=e.dataSync(),n=0;n<e.size;++n){var o=r[2*n],a=r[2*n+1];t[n]=Math.sqrt(o*o+a*a)}return Tensor.make(e.shape,{values:t})},e.prototype.int=function(e){this.assertNotComplex(e,"int");for(var t=new Int32Array(e.size),r=e.dataSync(),n=0;n<r.length;++n)t[n]=r[n];return Tensor.make(e.shape,{values:t},"int32")},e.prototype.sigmoid=function(e){this.assertNotComplex(e,"sigmoid");for(var t=new Float32Array(e.size),r=e.dataSync(),n=0;n<r.length;++n)t[n]=1/(1+Math.exp(-r[n]));return Tensor.make(e.shape,{values:t})},e.prototype.softplus=function(e){this.assertNotComplex(e,"softplus");for(var t=Math.log(1.1920928955078125e-7)+2,r=new Float32Array(e.size),n=e.dataSync(),o=0;o<n.length;++o){var a=n[o]>-t,i=n[o]<t,s=Math.exp(n[o]),u=void 0;u=i?s:a?n[o]:Math.log(1+s),r[o]=u}return Tensor.make(e.shape,{values:r})},e.prototype.sin=function(e){this.assertNotComplex(e,"sin");for(var t=new Float32Array(e.size),r=e.dataSync(),n=0;n<r.length;++n)t[n]=Math.sin(r[n]);return Tensor.make(e.shape,{values:t})},e.prototype.cos=function(e){this.assertNotComplex(e,"cos");for(var t=new Float32Array(e.size),r=e.dataSync(),n=0;n<r.length;++n)t[n]=Math.cos(r[n]);return Tensor.make(e.shape,{values:t})},e.prototype.tan=function(e){this.assertNotComplex(e,"tan");for(var t=new Float32Array(e.size),r=e.dataSync(),n=0;n<r.length;++n)t[n]=Math.tan(r[n]);return Tensor.make(e.shape,{values:t})},e.prototype.asin=function(e){this.assertNotComplex(e,"asin");for(var t=new Float32Array(e.size),r=e.dataSync(),n=0;n<r.length;++n)t[n]=Math.asin(r[n]);return Tensor.make(e.shape,{values:t})},e.prototype.acos=function(e){this.assertNotComplex(e,"acos");for(var t=new Float32Array(e.size),r=e.dataSync(),n=0;n<r.length;++n)t[n]=Math.acos(r[n]);return Tensor.make(e.shape,{values:t})},e.prototype.atan=function(e){this.assertNotComplex(e,"atan");for(var t=new Float32Array(e.size),r=e.dataSync(),n=0;n<r.length;++n)t[n]=Math.atan(r[n]);return Tensor.make(e.shape,{values:t})},e.prototype.atan2=function(e,t){return this.assertNotComplex([e,t],"atan2"),this.broadcastedBinaryOp(e,t,e.dtype,function(e,t){return Math.atan2(e,t)})},e.prototype.sinh=function(e){this.assertNotComplex(e,"sinh");for(var t=new Float32Array(e.size),r=e.dataSync(),n=0;n<r.length;++n)t[n]=Math.sinh(r[n]);return Tensor.make(e.shape,{values:t})},e.prototype.cosh=function(e){this.assertNotComplex(e,"cosh");for(var t=new Float32Array(e.size),r=e.dataSync(),n=0;n<r.length;++n)t[n]=Math.cosh(r[n]);return Tensor.make(e.shape,{values:t})},e.prototype.tanh=function(e){this.assertNotComplex(e,"tanh");for(var t=new Float32Array(e.size),r=e.dataSync(),n=0;n<r.length;++n)t[n]=tanh(r[n]);return Tensor.make(e.shape,{values:t})},e.prototype.asinh=function(e){this.assertNotComplex(e,"asinh");for(var t=new Float32Array(e.size),r=e.dataSync(),n=0;n<r.length;++n)t[n]=Math.asinh(r[n]);return Tensor.make(e.shape,{values:t})},e.prototype.acosh=function(e){this.assertNotComplex(e,"acosh");for(var t=new Float32Array(e.size),r=e.dataSync(),n=0;n<r.length;++n)t[n]=Math.acosh(r[n]);return Tensor.make(e.shape,{values:t})},e.prototype.atanh=function(e){this.assertNotComplex(e,"atanh");for(var t=new Float32Array(e.size),r=e.dataSync(),n=0;n<r.length;++n)t[n]=Math.atanh(r[n]);return Tensor.make(e.shape,{values:t})},e.prototype.erf=function(e){this.assertNotComplex(e,"erf");for(var t=new Float32Array(e.size),r=e.dataSync(),n=ERF_P,o=ERF_A1,a=ERF_A2,i=ERF_A3,s=ERF_A4,u=ERF_A5,l=0;l<r.length;++l){var c=r[l],p=1/(1+n*c);t[l]=1-((((u*p+s)*p+i)*p+a)*p+o)*p*Math.exp(-c*c)}return Tensor.make(e.shape,{values:t})},e.prototype.step=function(e,t){void 0===t&&(t=0),this.assertNotComplex(e,"step");for(var r=new Float32Array(e.size),n=e.dataSync(),o=0;o<n.length;++o){var a=n[o];isNaN(a)?r[o]=NaN:r[o]=a>0?1:t}return Tensor.make(e.shape,{values:r})},e.prototype.conv2d=function(e,t,r){this.assertNotComplex([e,t],"conv2d");for(var n=r.filterHeight,o=r.filterWidth,a=r.dilationHeight,i=r.dilationWidth,s=r.padInfo.left,u=r.padInfo.top,l=buffer(r.outShape,e.dtype),c=e.dataSync(),p=t.dataSync(),d=l.values,h=0;h<r.batchSize;++h)for(var f=h*e.strides[0],m=h*l.strides[0],g=0;g<r.outHeight;++g)for(var v=m+g*l.strides[1],y=g*r.strideHeight-s,x=0;x<n;x++){var T=y+x*a;if(!(T<0||T>=r.inHeight))for(var E=x*t.strides[0],w=f+T*e.strides[1],S=0;S<r.outWidth;++S)for(var b=v+S*r.outChannels,C=S*r.strideWidth-u,_=0;_<o;_++){var A=C+_*i;if(!(A<0||A>=r.inWidth))for(var N=E+_*t.strides[1],R=w+A*r.inChannels,I=N,k=0;k<r.inChannels;++k){for(var D=c[R+k],M=0;M<r.outChannels;++M)d[b+M]+=D*p[I+M];I+=r.outChannels}}}return l.toTensor()},e.prototype.conv2dDerInput=function(e,t,r){this.assertNotComplex([e,t],"conv2dDerInput");for(var n=buffer(r.inShape,"float32"),o=n.values,a=n.strides,i=a[0],s=a[1],u=a[2],l=e.dataSync(),c=e.strides,p=c[0],d=c[1],h=c[2],f=t.dataSync(),m=t.strides,g=m[0],v=m[1],y=m[2],x=r.batchSize,T=r.filterHeight,E=r.filterWidth,w=r.inChannels,S=r.inHeight,b=r.inWidth,C=r.outChannels,_=r.outHeight,A=r.outWidth,N=r.strideHeight,R=r.strideWidth,I=T-1-r.padInfo.top,k=E-1-r.padInfo.left,D=0;D<x;++D)for(var M=0;M<w;++M)for(var O=0;O<S;++O)for(var P=O-I,F=Math.max(0,Math.ceil(P/N)),L=Math.min(_,(T+P)/N),B=0;B<b;++B){for(var U=B-k,z=Math.max(0,Math.ceil(U/R)),V=Math.min(A,(E+U)/R),H=0,G=F;G<L;++G)for(var W=G*N-P,q=z;q<V;++q)for(var $=p*D+d*G+h*q,X=g*(T-1-W)+v*(E-1-(q*R-U))+y*M,K=0;K<C;++K){H+=l[$+K]*f[X+K]}o[i*D+s*O+u*B+M]=H}return n.toTensor()},e.prototype.conv2dDerFilter=function(e,t,r){this.assertNotComplex([e,t],"conv2dDerFilter");for(var n=r.strideHeight,o=r.strideWidth,a=r.filterHeight,i=r.filterWidth,s=buffer(r.filterShape,"float32"),u=r.padInfo.left,l=r.padInfo.top,c=0;c<a;++c)for(var p=Math.max(0,Math.ceil((l-c)/n)),d=Math.min(r.outHeight,(r.inHeight+l-c)/n),h=0;h<i;++h)for(var f=Math.max(0,Math.ceil((u-h)/o)),m=Math.min(r.outWidth,(r.inWidth+u-h)/o),g=0;g<r.inChannels;++g)for(var v=0;v<r.outChannels;++v){for(var y=0,x=0;x<r.batchSize;++x)for(var T=p;T<d;++T)for(var E=c+T*n-l,w=f;w<m;++w){var S=h+w*o-u;y+=e.get(x,E,S,g)*t.get(x,T,w,v)}s.set(y,c,h,g,v)}return s.toTensor()},e.prototype.depthwiseConv2D=function(e,t,r){this.assertNotComplex([e,t],"depthwiseConv2D");for(var n=r.filterHeight,o=r.filterWidth,a=r.dilationHeight,i=r.dilationWidth,s=r.padInfo.left,u=r.padInfo.top,l=r.outChannels/r.inChannels,c=buffer(r.outShape,e.dtype),p=e.dataSync(),d=t.dataSync(),h=c.values,f=0;f<r.batchSize;++f)for(var m=f*e.strides[0],g=f*c.strides[0],v=0;v<r.outHeight;++v)for(var y=g+v*c.strides[1],x=v*r.strideHeight-s,T=0;T<n;++T){var E=x+T*a;if(!(E<0||E>=r.inHeight))for(var w=T*t.strides[0],S=m+E*e.strides[1],b=0;b<r.outWidth;++b)for(var C=y+b*c.strides[2],_=b*r.strideWidth-u,A=0;A<o;++A){var N=_+A*i;if(!(N<0||N>=r.inWidth))for(var R=w+A*t.strides[1],I=S+N*r.inChannels,k=C,D=R,M=0;M<r.inChannels;++M){for(var O=p[I+M],P=0;P<l;++P)h[k+P]+=O*d[D+P];k+=l,D+=l}}}return c.toTensor()},e.prototype.depthwiseConv2DDerInput=function(e,t,r){this.assertNotComplex([e,t],"depthwiseConv2DDerInput");for(var n=buffer(r.inShape,"float32"),o=n.values,a=n.strides,i=a[0],s=a[1],u=a[2],l=e.dataSync(),c=e.strides,p=c[0],d=c[1],h=c[2],f=t.dataSync(),m=t.strides,g=m[0],v=m[1],y=m[2],x=r.batchSize,T=r.filterHeight,E=r.filterWidth,w=r.inChannels,S=r.inHeight,b=r.inWidth,C=r.outChannels,_=r.outHeight,A=r.outWidth,N=r.strideHeight,R=r.strideWidth,I=T-1-r.padInfo.top,k=E-1-r.padInfo.left,D=C/w,M=0;M<x;++M)for(var O=0;O<w;++O)for(var P=0;P<S;++P)for(var F=P-I,L=Math.max(0,Math.ceil(F/N)),B=Math.min(_,(T+F)/N),U=0;U<b;++U){for(var z=U-k,V=Math.max(0,Math.ceil(z/R)),H=Math.min(A,(E+z)/R),G=0,W=L;W<B;++W)for(var q=W*N-F,$=V;$<H;++$)for(var X=p*M+d*W+h*$,K=g*(T-1-q)+v*(E-1-($*R-z))+y*O,j=0;j<D;++j){G+=l[X+(O*D+j)]*f[K+j]}o[i*M+s*P+u*U+O]=G}return n.toTensor()},e.prototype.depthwiseConv2DDerFilter=function(e,t,r){this.assertNotComplex([e,t],"depthwiseConv2DDerFilter");for(var n=r.strideHeight,o=r.strideWidth,a=r.filterHeight,i=r.filterWidth,s=buffer(r.filterShape,"float32"),u=r.padInfo.left,l=r.padInfo.top,c=r.outChannels/r.inChannels,p=0;p<a;++p)for(var d=Math.max(0,Math.ceil((l-p)/n)),h=Math.min(r.outHeight,(r.inHeight+l-p)/n),f=0;f<i;++f)for(var m=Math.max(0,Math.ceil((u-f)/o)),g=Math.min(r.outWidth,(r.inWidth+u-f)/o),v=0;v<r.outChannels;++v){for(var y=Math.trunc(v/c),x=v%c,T=0,E=0;E<r.batchSize;++E)for(var w=d;w<h;++w)for(var S=p+w*n-l,b=m;b<g;++b){var C=f+b*o-u;T+=e.get(E,S,C,y)*t.get(E,w,b,v)}s.set(T,p,f,y,x)}return s.toTensor()},e.prototype.tile=function(e,t){this.assertNotComplex(e,"tile");for(var r=new Array(e.rank),n=0;n<r.length;n++)r[n]=e.shape[n]*t[n];var o=buffer(r,e.dtype),a=e.buffer();for(n=0;n<o.values.length;++n){for(var i=o.indexToLoc(n),s=new Array(e.rank),u=0;u<s.length;u++)s[u]=i[u]%e.shape[u];var l=a.locToIndex(s);o.values[n]=a.values[l]}return o.toTensor()},e.prototype.pad=function(e,t,r){this.assertNotComplex(e,"pad");var n=t.map(function(t,r){return t[0]+e.shape[r]+t[1]}),o=t.map(function(e){return e[0]}),a=e.buffer(),i=buffer(n,e.dtype);0!==r&&i.values.fill(r);for(var s=0;s<e.size;s++){var u=a.indexToLoc(s),l=u.map(function(e,t){return e+o[t]});i.set.apply(i,[e.get.apply(e,u)].concat(l))}return i.toTensor()},e.prototype.transpose=function(e,t){this.assertNotComplex(e,"transpose");for(var r=new Array(e.rank),n=0;n<r.length;n++)r[n]=e.shape[t[n]];var o=e.dataSync(),a=buffer(r,e.dtype),i=e.buffer();for(n=0;n<e.size;++n){for(var s=i.indexToLoc(n),u=new Array(s.length),l=0;l<u.length;l++)u[l]=s[t[l]];var c=a.locToIndex(u);a.values[c]=o[n]}return a.toTensor()},e.prototype.gather=function(e,t,r){this.assertNotComplex([e,t],"gather");var n=e.shape.slice(),o=t.dataSync();n[r]=o.length;for(var a=buffer(n,e.dtype),i=e.buffer(),s=0;s<a.size;++s){var u=a.indexToLoc(s),l=u.slice();l[r]=o[u[r]];var c=i.locToIndex(l);a.values[s]=i.values[c]}return a.toTensor()},e.prototype.batchToSpaceND=function(e,t,r){this.assertNotComplex([e],"batchToSpaceND");var n=t.reduce(function(e,t){return e*t}),o=getReshaped(e.shape,t,n),a=getPermuted(o.length,t.length),i=getReshapedPermuted(e.shape,t,n),s=getSliceBeginCoords(r,t.length),u=getSliceSize(i,r,t.length);return e.reshape(o).transpose(a).reshape(i).slice(s,u)},e.prototype.spaceToBatchND=function(e,t,r){this.assertNotComplex([e],"spaceToBatchND");var n=t.reduce(function(e,t){return e*t}),o=[[0,0]];o.push.apply(o,r);for(var a=1+t.length;a<e.shape.length;++a)o.push([0,0]);var i=e.pad(o),s=getReshaped(i.shape,t,n,!1),u=getPermuted(s.length,t.length,!1),l=getReshapedPermuted(i.shape,t,n,!1);return i.reshape(s).transpose(u).reshape(l)},e.prototype.pool=function(e,t,r){this.assertNotComplex(e,"pool");for(var n=t.strideHeight,o=t.strideWidth,a=t.dilationHeight,i=t.dilationWidth,s=t.effectiveFilterHeight,u=t.effectiveFilterWidth,l=t.padInfo.top,c=t.padInfo.left,p="max"===r?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,d=e.dataSync(),h=buffer(t.outShape,e.dtype),f=h.values,m=t.outShape[1]*t.outShape[2]*t.outShape[3],g=t.outShape[2]*t.outShape[3],v=t.outShape[3],y=0;y<t.batchSize;++y)for(var x=y*m,T=y*e.strides[0],E=0;E<t.inChannels;++E)for(var w=0;w<t.outHeight;++w)for(var S=w*n-l,b=Math.max(0,S),C=Math.min(t.inHeight,s+S),_=x+w*g,A=0;A<t.outWidth;++A){for(var N=A*o-c,R=Math.max(0,N),I=Math.min(t.inWidth,u+N),k=p,D=0,M=0,O=b;O<C;O+=a){for(var P=T+O*e.strides[1],F=R;F<I;F+=i){var L=d[P+F*e.strides[2]+E];"max"===r&&L>k?k=L:"avg"===r&&(D+=L,M++)}if(isNaN(k))break}f[_+A*v+E]="avg"===r?D/M:k}return h.toTensor()},e.prototype.maxPool=function(e,t){return this.pool(e,t,"max")},e.prototype.maxPoolPositions=function(e,t){for(var r=buffer(t.outShape,"int32"),n=t.strideHeight,o=t.strideWidth,a=t.dilationHeight,i=t.dilationWidth,s=t.effectiveFilterHeight,u=t.effectiveFilterWidth,l=t.padInfo.top,c=t.padInfo.left,p=0;p<t.batchSize;++p)for(var d=0;d<t.inChannels;++d)for(var h=0;h<t.outHeight;++h){for(var f=h*n-l,m=f;m<0;)m+=a;for(var g=Math.min(t.inHeight,s+f),v=0;v<t.outWidth;++v){for(var y=v*o-c,x=y;x<0;)x+=i;for(var T=Math.min(t.inWidth,u+y),E=Number.NEGATIVE_INFINITY,w=-1,S=m;S<g;S+=a)for(var b=S-f,C=x;C<T;C+=i){var _=C-y,A=e.get(p,S,C,d);A>E&&(E=A,w=b*u+_)}r.set(w,p,h,v,d)}}return r.toTensor()},e.prototype.maxPoolBackprop=function(e,t,r,n){this.assertNotComplex([t,r],"maxPoolBackprop");for(var o=this.maxPoolPositions(t,n),a=n.strideHeight,i=n.strideWidth,s=n.dilationHeight,u=n.dilationWidth,l=n.effectiveFilterHeight,c=n.effectiveFilterWidth,p=c-1-n.padInfo.left,d=l-1-n.padInfo.top,h=buffer(t.shape,"float32"),f=0;f<n.batchSize;++f)for(var m=0;m<n.inChannels;++m)for(var g=0;g<n.inHeight;++g)for(var v=0;v<n.inWidth;++v){for(var y=g-d,x=v-p,T=0,E=0;E<l;E+=s){var w=(y+E)/a;if(!(w<0||w>=n.outHeight||Math.floor(w)!==w))for(var S=0;S<c;S+=u){var b=(x+S)/i;if(!(b<0||b>=n.outWidth||Math.floor(b)!==b)){var C=l*c-1-o.get(f,w,b,m)===E*c+S?1:0;if(0!==C)T+=e.get(f,w,b,m)*C}}}h.set(T,f,g,v,m)}return h.toTensor()},e.prototype.avgPoolBackprop=function(e,t,r){this.assertNotComplex([e,t],"avgPoolBackprop");for(var n=r.strideHeight,o=r.strideWidth,a=r.filterHeight,i=r.filterWidth,s=r.dilationHeight,u=r.dilationWidth,l=r.effectiveFilterHeight,c=r.effectiveFilterWidth,p=c-1-r.padInfo.left,d=l-1-r.padInfo.top,h=buffer(t.shape,"float32"),f=1/(a*i),m=0;m<r.batchSize;++m)for(var g=0;g<r.inChannels;++g)for(var v=0;v<r.inHeight;++v)for(var y=0;y<r.inWidth;++y){for(var x=v-d,T=y-p,E=0,w=0;w<l;w+=s){var S=(x+w)/n;if(!(S<0||S>=r.outHeight||Math.floor(S)!==S))for(var b=0;b<c;b+=u){var C=(T+b)/o;if(!(C<0||C>=r.outWidth||Math.floor(C)!==C))E+=e.get(m,S,C,g)}}h.set(E*f,m,v,y,g)}return h.toTensor()},e.prototype.cast=function(e,t){return castTensor(e,t,this)},e.prototype.reshape=function(e,t){return reshapeTensor(e,t)},e.prototype.avgPool=function(e,t){return this.assertNotComplex(e,"avgPool"),this.pool(e,t,"avg").toFloat()},e.prototype.resizeBilinear=function(e,t,r,n){this.assertNotComplex(e,"resizeBilinear");for(var o=e.shape,a=o[0],i=o[1],s=o[2],u=o[3],l=e.dataSync(),c=new Float32Array(sizeFromShape([a,t,r,u])),p=[n&&t>1?i-1:i,n&&r>1?s-1:s],d=[n&&t>1?t-1:t,n&&r>1?r-1:r],h=0,f=p[0]/d[0],m=p[1]/d[1],g=0;g<a;g++)for(var v=0;v<t;v++)for(var y=f*v,x=Math.floor(y),T=y-x,E=Math.min(i-1,Math.ceil(y)),w=g*e.strides[0]+x*e.strides[1],S=g*e.strides[0]+E*e.strides[1],b=0;b<r;b++)for(var C=m*b,_=Math.floor(C),A=C-_,N=Math.min(s-1,Math.ceil(C)),R=w+_*e.strides[2],I=S+_*e.strides[2],k=w+ +N*e.strides[2],D=S+N*e.strides[2],M=0;M<u;M++){var O=l[R+M],P=l[I+M],F=O+(l[k+M]-O)*A,L=F+(P+(l[D+M]-P)*A-F)*T;c[h++]=L}return tensor(c,[a,t,r,u])},e.prototype.resizeBilinearBackprop=function(e,t,r){this.assertNotComplex([e,t],"resizeBilinearBackprop");for(var n=t.shape,o=n[0],a=n[1],i=n[2],s=n[3],u=e.shape,l=u[1],c=u[2],p=new Float32Array(o*a*i*s),d=[r&&l>1?a-1:a,r&&c>1?i-1:i],h=[r&&l>1?l-1:l,r&&c>1?c-1:c],f=d[0]/h[0],m=d[1]/h[1],g=e.dataSync(),v=0,y=0;y<o;y++)for(var x=y*t.strides[0],T=0;T<l;T++)for(var E=T*f,w=Math.floor(E),S=Math.min(Math.ceil(E),a-1),b=x+w*t.strides[1],C=x+S*t.strides[1],_=E-w,A=1-_,N=0;N<c;N++)for(var R=N*m,I=Math.floor(R),k=Math.min(Math.ceil(R),i-1),D=R-I,M=1-D,O=b+I*t.strides[2],P=b+k*t.strides[2],F=C+I*t.strides[2],L=C+k*t.strides[2],B=A*M,U=A*D,z=_*M,V=_*D,H=0;H<s;H++){var G=g[v++];p[O+H]+=G*B,p[P+H]+=G*U,p[F+H]+=G*z,p[L+H]+=G*V}return tensor4d(p,[o,i,a,s],t.dtype)},e.prototype.resizeNearestNeighbor=function(e,t,r,n){this.assertNotComplex(e,"resizeNearestNeighbor");for(var o=e.shape,a=o[0],i=o[1],s=o[2],u=o[3],l=e.dataSync(),c=new Float32Array(a*t*r*u),p=[n&&t>1?i-1:i,n&&r>1?s-1:s],d=[n&&t>1?t-1:t,n&&r>1?r-1:r],h=p[0]/d[0],f=p[1]/d[1],m=0,g=0;g<a;g++)for(var v=g*e.strides[0],y=0;y<t;y++)for(var x=h*y,T=v+Math.min(i-1,n?Math.round(x):Math.floor(x))*e.strides[1],E=0;E<r;E++)for(var w=f*E,S=T+Math.min(s-1,n?Math.round(w):Math.floor(w))*e.strides[2],b=0;b<u;b++){var C=l[S+b];c[m++]=C}return tensor(c,[a,t,r,u],e.dtype)},e.prototype.resizeNearestNeighborBackprop=function(e,t,r){this.assertNotComplex([e,t],"resizeNearestNeighborBackprop");for(var n=t.shape,o=n[0],a=n[1],i=n[2],s=n[3],u=e.shape,l=u[1],c=u[2],p=new Float32Array(o*a*i*s),d=e.dataSync(),h=[r&&l>1?a-1:a,r&&c>1?i-1:i],f=[r&&l>1?l-1:l,r&&c>1?c-1:c],m=h[0]/f[0],g=h[1]/f[1],v=1/m,y=1/g,x=2*Math.ceil(v)+2,T=2*Math.ceil(y)+2,E=0;E<o;E++)for(var w=E*t.strides[0],S=0;S<a;S++)for(var b=w+S*t.strides[1],C=Math.floor(S*v),_=Math.floor(C-x/2),A=0;A<i;A++)for(var N=b+A*t.strides[2],R=Math.floor(A*y),I=Math.floor(R-T/2),k=0;k<s;k++){for(var D=0,M=0;M<x;M++){var O=M+_;if(!(O<0||O>=l)){var P=w+O*e.strides[1],F=O*m;if(S===Math.min(a-1,r?Math.round(F):Math.floor(F)))for(var L=0;L<T;L++){var B=L+I;if(!(B<0||B>=c)){var U=P+B*e.strides[2],z=B*g;A===Math.min(i-1,r?Math.round(z):Math.floor(z))&&(D+=d[U+k])}}}}p[N+k]=D}return tensor4d(p,t.shape,t.dtype)},e.prototype.batchNormalization=function(e,t,r,n,o,a){this.assertNotComplex([e,t,r,o,a],"batchNormalization");for(var i=e.dataSync(),s=t.dataSync(),u=r.dataSync(),l=o?o.dataSync():new Float32Array([1]),c=a?a.dataSync():new Float32Array([0]),p=new Float32Array(i.length),d=c.length,h=l.length,f=u.length,m=s.length,g=0,v=0,y=0,x=0,T=0;T<i.length;++T)p[T]=c[g++]+(i[T]-s[v++])*l[y++]/Math.sqrt(u[x++]+n),g>=d&&(g=0),v>=m&&(v=0),y>=h&&(y=0),x>=f&&(x=0);return tensor4d(p,e.shape)},e.prototype.localResponseNormalization4D=function(e,t,r,n,o){this.assertNotComplex(e,"localResponseNormalization4D");var a=e.shape[3],i=a-1,s=e.dataSync(),u=sizeFromShape(e.shape),l=new Float32Array(u);function c(e){for(var r=e%a,n=e-r+Math.max(0,r-t),o=e-r+Math.min(r+t,i),u=0;n<=o;n++){var l=s[n];u+=l*l}return u}for(var p=0;p<u;p++){var d=c(p),h=s[p]*Math.pow(r+n*d,-o);l[p]=h}return tensor4d(l,e.shape)},e.prototype.LRNGrad=function(e,t,r,n,o,a,i){this.assertNotComplex(e,"LRNGrad");for(var s=e.shape[3],u=e.dataSync(),l=t.dataSync(),c=r.dataSync(),p=new Float32Array(sizeFromShape(e.shape)),d=sizeFromShape(e.shape),h=0;h<d;h++){for(var f=h%s,m=h-f+Math.max(0,f-n),g=h-f+Math.min(s,f+n+1),v=0,y=m;y<g;y++)v+=Math.pow(l[y],2);v=a*v+o;for(y=m;y<g;y++){var x=-2*a*i*l[y]*c[h]/v;h===y&&(x+=Math.pow(v,-i)),x*=u[h],p[y]+=x}}return tensor4d(p,e.shape)},e.prototype.multinomial=function(e,t,r,n){this.assertNotComplex(e,"multinomial");for(var o=t?e:softmax(e),a=o.shape[0],i=o.shape[1],s=zeros([a,r],"int32"),u=s.dataSync(),l=o.dataSync(),c=0;c<a;++c){var p=c*i,d=new Float32Array(i-1);d[0]=l[p];for(var h=1;h<d.length;++h)d[h]=d[h-1]+l[p+h];for(var f=seedrandom_1(n.toString()),m=c*r,g=0;g<r;++g){var v=f();u[m+g]=d.length;for(var y=0;y<d.length;y++)if(v<d[y]){u[m+g]=y;break}}}return s},e.prototype.oneHot=function(e,t,r,n){this.assertNotComplex(e,"oneHot");var o=new Float32Array(e.size*t);o.fill(n);for(var a=0;a<e.size;++a)e.get(a)>=0&&e.get(a)<t&&(o[a*t+e.get(a)]=r);return tensor2d(o,[e.size,t],"int32")},e.prototype.nonMaxSuppression=function(e,t,r,n,o){return this.assertNotComplex(e,"nonMaxSuppression"),nonMaxSuppressionImpl(e.dataSync(),t.dataSync(),r,n,o)},e.prototype.fft=function(e){if(1!==e.shape[0])throw new Error("tf.fft() on CPU only supports vectors.");return this.fftImpl(e,!1)},e.prototype.ifft=function(e){if(1!==e.shape[0])throw new Error("tf.ifft() on CPU only supports vectors.");return this.fftImpl(e,!0)},e.prototype.fftImpl=function(e,t){var r=e.as1D(),n=r.size;if(this.isExponentOf2(n)){var o=this.fftRadix2(r,n,t).as2D(e.shape[0],e.shape[1]);return t&&(o=complex(real(o).div(scalar(n)),imag(o).div(scalar(n)))),o}var a=e.dataSync(),i=splitRealAndImagArrays(this.fourierTransformByMatmul(a,n,t));return complex(i.real,i.imag).as2D(e.shape[0],e.shape[1])},e.prototype.isExponentOf2=function(e){return 0==(e&e-1)},e.prototype.fftRadix2=function(e,t,r){if(1===t)return e;var n=e.dataSync(),o=t/2,a=complexWithEvenIndex(n),i=complex(a.real,a.imag).as1D(),s=complexWithOddIndex(n),u=complex(s.real,s.imag).as1D();i=this.fftRadix2(i,o,r),u=this.fftRadix2(u,o,r);var l=exponents(t,r),c=complex(l.real,l.imag).mul(u),p=i.add(c),d=i.sub(c),h=real(p).concat(real(d)),f=imag(p).concat(imag(d));return complex(h,f).as1D()},e.prototype.fourierTransformByMatmul=function(e,t,r){for(var n=new Float32Array(2*t),o=0;o<t;o++){for(var a=0,i=0,s=0;s<t;s++){var u=exponent(o*s,t,r),l=getComplexWithIndex(e,s);a+=l.real*u.real-l.imag*u.imag,i+=l.real*u.imag+l.imag*u.real}r&&(a/=t,i/=t),assignToTypedArray(n,a,i,o)}return n},e.prototype.depthToSpace=function(e,t,r){assert("NHWC"===r,"Only NHWC dataFormat supported on CPU for depthToSpace. Got "+r),assert(t>1,"blockSize should be > 1 for depthToSpace, but was: "+t);for(var n=e.shape[0],o=e.shape[1],a=e.shape[2],i=e.shape[3],s=o*t,u=a*t,l=i/(t*t),c=e.dataSync(),p=new Float32Array(n*s*u*l),d=0,h=0;h<n;++h)for(var f=0;f<s;++f)for(var m=Math.floor(f/t),g=f%t,v=0;v<u;++v)for(var y=Math.floor(v/t),x=(g*t+v%t)*l,T=0;T<l;++T){var E=T+x+i*(y+a*(m+o*h));p[d++]=c[E]}return tensor4d(p,[n,s,u,l])},e.prototype.broadcastedBinaryOp=function(e,t,r,n){var o=assertAndGetBroadcastShape(e.shape,t.shape),a=buffer(o,r),i=e.dataSync(),s=t.dataSync(),u=getBroadcastDims(e.shape,o),l=getBroadcastDims(t.shape,o),c=a.values;if(u.length+l.length===0)for(var p=0;p<c.length;++p)c[p]=n(i[p%i.length],s[p%s.length]);else{var d=e.buffer(),h=t.buffer(),f=function(r){var o=a.indexToLoc(r),p=o.slice(-e.rank);u.forEach(function(e){return p[e]=0});var f=d.locToIndex(p),m=o.slice(-t.rank);l.forEach(function(e){return m[e]=0});var g=h.locToIndex(m);c[r]=n(i[f],s[g])};for(p=0;p<c.length;++p)f(p)}return a.toTensor()},e.prototype.broadcastedBinaryComplexOp=function(e,t,r){var n=assertAndGetBroadcastShape(e.shape,t.shape),o=buffer(n,"float32"),a=buffer(n,"float32"),i=e.dataSync(),s=t.dataSync(),u=getBroadcastDims(e.shape,n),l=getBroadcastDims(t.shape,n),c=o.values,p=a.values;if(u.length+l.length===0)for(var d=0;d<c.length;d++){var h=d%i.length,f=d%s.length,m=r(i[2*h],i[2*h+1],s[2*f],s[2*f+1]);c[d]=m.real,p[d]=m.imag}else{var g=this.data.get(e.dataId).complexTensors.real.buffer(),v=this.data.get(t.dataId).complexTensors.real.buffer(),y=function(n){var a=o.indexToLoc(n),d=a.slice(-e.rank);u.forEach(function(e){return d[e]=0});var h=g.locToIndex(d),f=a.slice(-t.rank);l.forEach(function(e){return f[e]=0});var m=v.locToIndex(f),y=r(i[2*h],i[2*h+1],s[2*m],s[2*m+1]);c[n]=y.real,p[n]=y.imag};for(d=0;d<c.length;d++)y(d)}return this.complex(o.toTensor(),a.toTensor())},e.prototype.split=function(e,t,r){return split(e,t,r)},e.prototype.dispose=function(){},e.prototype.floatPrecision=function(){return 32},e.prototype.cropAndResize=function(e,t,r,n,o,a){for(var i=e.shape,s=i[0],u=i[1],l=i[2],c=i[3],p=t.shape[0],d=n[0],h=n[1],f=buffer([p,d,h,c]),m=t.dataSync(),g=r.dataSync(),v=e.dataSync(),y=e.strides,x=f.strides,T=0;T<p;T++){var E=4*T,w=m[E],S=m[E+1],b=m[E+2],C=m[E+3],_=g[T];if(!(_>=s))for(var A=d>1?(b-w)*(u-1)/(d-1):0,N=h>1?(C-S)*(l-1)/(h-1):0,R=0;R<d;R++){var I=d>1?w*(u-1)+R*A:.5*(w+b)*(u-1);if(I<0||I>u-1)for(var k=0;k<h;k++)for(var D=0;D<c;D++){var M=D+k*x[2]+R*x[1]+T*x[0];f.values[M]=a}else if("bilinear"===o){var O=Math.floor(I),P=Math.ceil(I),F=I-O;for(k=0;k<h;k++){if((q=h>1?S*(l-1)+k*N:.5*(S+C)*(l-1))<0||q>l-1)for(D=0;D<c;D++){M=D+k*x[2]+R*x[1]+T*x[0];f.values[M]=a}else{var L=Math.floor(q),B=Math.ceil(q),U=q-L;for(D=0;D<c;D++){var z=v[M=D+L*y[2]+O*y[1]+_*y[0]],V=v[M=D+B*y[2]+O*y[1]+_*y[0]],H=v[M=D+L*y[2]+P*y[1]+_*y[0]],G=z+(V-z)*U,W=H+(v[M=D+B*y[2]+P*y[1]+_*y[0]]-H)*U;M=D+k*x[2]+R*x[1]+T*x[0],f.values[M]=G+(W-G)*F}}}}else for(k=0;k<h;++k){var q;if((q=h>1?S*(l-1)+k*N:.5*(S+C)*(l-1))<0||q>l-1)for(D=0;D<c;D++){M=D+k*x[2]+R*x[1]+T*x[0];f.values[M]=a}else{var $=Math.round(q),X=Math.round(I);for(D=0;D<c;D++){var K=D+$*y[2]+X*y[1]+_*y[0],j=D+k*x[2]+R*x[1]+T*x[0];f.values[j]=v[K]}}}}}return f.toTensor()},e.prototype.sparseToDense=function(e,t,r,n){var o=calculateShapes(t,e,r),a=o.sliceRank,i=o.numUpdates,s=o.sliceSize,u=o.strides,l=o.outputSize;return this.scatter(e,t,r,l,s,i,a,u,n,!1)},e.prototype.gatherND=function(e,t){var r=t.shape,n=r[r.length-1],o=prepareAndValidate(e,t),a=o[0],i=o[1],s=o[2],u=o[3];if(0===i)return tensor([],a,e.dtype);for(var l=new TensorBuffer([i,s],e.dtype),c=t.dataSync(),p=e.dataSync(),d=0;d<i;d++){for(var h=[],f=0,m=0;m<n;m++){var g=c[d*n+m];f+=g*u[m],h.push(g)}if(f<0||f>=e.size/s)throw new Error("Invalid indices: "+h+" does not index into "+e.shape);for(var v=0;v<s;v++)l.values[d*s+v]=p[f*s+v]}return l.toTensor().reshape(a)},e.prototype.scatterND=function(e,t,r){var n=calculateShapes(t,e,r),o=n.sliceRank,a=n.numUpdates,i=n.sliceSize,s=n.strides,u=n.outputSize,l=scalar(0);return this.scatter(e,t,r,u,i,a,o,s,l,!0)},e.prototype.scatter=function(e,t,r,n,o,a,i,s,u,l){var c=[n/o,o],p=e.dataSync(),d=t.dataSync();if(0===n)return tensor([],r,t.dtype);var h=new TensorBuffer(c,t.dtype);h.values.fill(u.dataSync()[0]);for(var f=0;f<a;f++){for(var m=[],g=0,v=0;v<i;v++){var y=p[f*i+v];m.push(y),g+=y*s[v]}if(g<0||g>=n/o)throw new Error("Invalid indices: "+m+" does not index into "+r);for(var x=0;x<o;x++)l?h.values[g*o+x]+=d[f*o+x]:h.values[g*o+x]=0===t.rank?d[0]:d[f*o+x]}return h.toTensor().reshape(r)},e}();ENV.registerBackend("cpu",function(){return new MathBackendCPU},1,setTensorTracker);var delayCallback="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:setImmediate;function nextFrame(){return new Promise(function(e){return delayCallback(function(){return e()})})}var DTYPE_VALUE_SIZE_MAP={float32:4,int32:4,uint16:2,uint8:1,bool:1};function encodeWeights(e){return __awaiter(this,void 0,void 0,function(){var t,r,n,o;return __generator(this,function(a){switch(a.label){case 0:for(n in t=[],r=[],e){if("float32"!==(o=e[n]).dtype&&"int32"!==o.dtype&&"bool"!==o.dtype)throw new Error("Unsupported dtype in weight '"+n+"': "+o.dtype);t.push({name:n,shape:o.shape,dtype:o.dtype}),r.push(o.data())}return[4,Promise.all(r)];case 1:return[2,{data:concatenateTypedArrays(a.sent()),specs:t}]}})})}function decodeWeights(e,t){for(var r={},n=0,o=function(t){var o=t.name,a=t.dtype,i=t.shape,s=sizeFromShape(i),u=void 0;if("quantization"in t){var l=t.quantization;if("uint8"!==l.dtype&&"uint16"!==l.dtype)throw new Error("Weight "+t.name+" has unknown quantization dtype "+l.dtype+". Supported quantization dtypes are: 'uint8' and 'uint16'.");var c=DTYPE_VALUE_SIZE_MAP[l.dtype],p=e.slice(n,n+s*c),d="uint8"===l.dtype?new Uint8Array(p):new Uint16Array(p);if("float32"===a)u=Float32Array.from(d,function(e){return e*l.scale+l.min});else{if("int32"!==a)throw new Error("Unsupported dtype in weight '"+o+"': "+a);u=Int32Array.from(d,function(e){return Math.round(e*l.scale+l.min)})}n+=s*c}else{var h=DTYPE_VALUE_SIZE_MAP[a];p=e.slice(n,n+s*h);if("float32"===a)u=new Float32Array(p);else if("int32"===a)u=new Int32Array(p);else{if("bool"!==a)throw new Error("Unsupported dtype in weight '"+o+"': "+a);u=new Uint8Array(p)}n+=s*h}var f=void 0;if("float32"===a)f=tensor(u,i,"float32");else if("int32"===a)f=tensor(u,i,"int32");else{if("bool"!==a)throw new Error("Unsupported dtype in weight '"+o+"': "+a);f=tensor(u,i,"bool")}r[o]=f},a=0,i=t;a<i.length;a++){o(i[a])}return r}function concatenateTypedArrays(e){if(null===e)throw new Error("Invalid input value: "+JSON.stringify(e));var t=0,r=[];e.forEach(function(e){if(t+=e.byteLength,r.push(e.byteLength===e.buffer.byteLength?e:new e.constructor(e)),!(e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array))throw new Error("Unsupported TypedArray subtype: "+e.constructor.name)});var n=new Uint8Array(t),o=0;return r.forEach(function(e){n.set(new Uint8Array(e.buffer),o),o+=e.byteLength}),n.buffer}var useNodeBuffer="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function stringByteLength(e){return useNodeBuffer?Buffer.byteLength(e):new Blob([e]).size}function arrayBufferToBase64String(e){return useNodeBuffer?Buffer.from(e).toString("base64"):btoa(String.fromCharCode.apply(null,new Uint8Array(e)))}function base64StringToArrayBuffer(e){if(useNodeBuffer){var t=Buffer.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}for(var r=atob(e),n=new Uint8Array(r.length),o=0;o<r.length;++o)n.set([r.charCodeAt(o)],o);return n.buffer}function concatenateArrayBuffers(e){var t=0;e.forEach(function(e){t+=e.byteLength});var r=new Uint8Array(t),n=0;return e.forEach(function(e){r.set(new Uint8Array(e),n),n+=e.byteLength}),r.buffer}function basename(e){for(e=e.trim();e.endsWith("/");)e=e.slice(0,e.length-1);var t=e.split("/");return t[t.length-1]}function getModelArtifactsInfoForJSON(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:stringByteLength(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:stringByteLength(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:e.weightData.byteLength}}var IORouterRegistry=function(){function e(){this.saveRouters=[],this.loadRouters=[]}return e.getInstance=function(){return null==e.instance&&(e.instance=new e),e.instance},e.registerSaveRouter=function(t){e.getInstance().saveRouters.push(t)},e.registerLoadRouter=function(t){e.getInstance().loadRouters.push(t)},e.getSaveHandlers=function(t){return e.getHandlers(t,"save")},e.getLoadHandlers=function(t){return e.getHandlers(t,"load")},e.getHandlers=function(e,t){var r=[];return("load"===t?this.getInstance().loadRouters:this.getInstance().saveRouters).forEach(function(t){var n=t(e);null!==n&&r.push(n)}),r},e}(),URL_SCHEME_SUFFIX="://",ModelStoreManagerRegistry=function(){function e(){this.managers={}}return e.getInstance=function(){return null==e.instance&&(e.instance=new e),e.instance},e.registerManager=function(t,r){assert(null!=t,"scheme must not be undefined or null."),t.endsWith(URL_SCHEME_SUFFIX)&&(t=t.slice(0,t.indexOf(URL_SCHEME_SUFFIX))),assert(t.length>0,"scheme must not be an empty string.");var n=e.getInstance();assert(null==n.managers[t],"A model store manager is already registered for scheme '"+t+"'."),n.managers[t]=r},e.getManager=function(e){var t=this.getInstance().managers[e];if(null==t)throw new Error("Cannot find model manager for scheme '"+e+"'");return t},e.getSchemes=function(){return Object.keys(this.getInstance().managers)},e}();function parseURL(e){if(-1===e.indexOf(URL_SCHEME_SUFFIX))throw new Error("The url string provided does not contain a scheme. Supported schemes are: "+ModelStoreManagerRegistry.getSchemes().join(","));return{scheme:e.split(URL_SCHEME_SUFFIX)[0],path:e.split(URL_SCHEME_SUFFIX)[1]}}function cloneModelInternal(e,t,r){return void 0===r&&(r=!1),__awaiter(this,void 0,void 0,function(){var n,o,a,i,s,u,l,c,p;return __generator(this,function(d){switch(d.label){case 0:return assert(e!==t,"Old path and new path are the same: '"+e+"'"),assert((n=IORouterRegistry.getLoadHandlers(e)).length>0,"Copying failed because no load handler is found for source URL "+e+"."),assert(n.length<2,"Copying failed because more than one ("+n.length+") load handlers for source URL "+e+"."),o=n[0],assert((a=IORouterRegistry.getSaveHandlers(t)).length>0,"Copying failed because no save handler is found for destination URL "+t+"."),assert(a.length<2,"Copying failed because more than one ("+n.length+") save handlers for destination URL "+t+"."),i=a[0],s=parseURL(e).scheme,u=parseURL(e).path,l=s===parseURL(e).scheme,[4,o.load()];case 1:return c=d.sent(),r&&l?[4,ModelStoreManagerRegistry.getManager(s).removeModel(u)]:[3,3];case 2:d.sent(),d.label=3;case 3:return[4,i.save(c)];case 4:return p=d.sent(),!r||l?[3,6]:[4,ModelStoreManagerRegistry.getManager(s).removeModel(u)];case 5:d.sent(),d.label=6;case 6:return[2,p.modelArtifactsInfo]}})})}function listModels(){return __awaiter(this,void 0,void 0,function(){var e,t,r,n,o,a,i;return __generator(this,function(s){switch(s.label){case 0:e=ModelStoreManagerRegistry.getSchemes(),t={},r=0,n=e,s.label=1;case 1:return r<n.length?(o=n[r],[4,ModelStoreManagerRegistry.getManager(o).listModels()]):[3,4];case 2:for(i in a=s.sent())t[o+URL_SCHEME_SUFFIX+i]=a[i];s.label=3;case 3:return r++,[3,1];case 4:return[2,t]}})})}function removeModel(e){return __awaiter(this,void 0,void 0,function(){var t;return __generator(this,function(r){switch(r.label){case 0:return t=parseURL(e),[4,ModelStoreManagerRegistry.getManager(t.scheme).removeModel(t.path)];case 1:return[2,r.sent()]}})})}function copyModel(e,t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(r){switch(r.label){case 0:return[4,cloneModelInternal(e,t,!1)];case 1:return[2,r.sent()]}})})}function moveModel(e,t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(r){switch(r.label){case 0:return[4,cloneModelInternal(e,t,!0)];case 1:return[2,r.sent()]}})})}var DATABASE_NAME="tensorflowjs",DATABASE_VERSION=1,MODEL_STORE_NAME="models_store",INFO_STORE_NAME="model_info_store";function getIndexedDBFactory(){if(!ENV.get("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");var e=window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function setUpDatabase(e){var t=e.result;t.createObjectStore(MODEL_STORE_NAME,{keyPath:"modelPath"}),t.createObjectStore(INFO_STORE_NAME,{keyPath:"modelPath"})}var BrowserIndexedDB=function(){function e(e){if(this.indexedDB=getIndexedDBFactory(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}return e.prototype.save=function(e){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(t){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return[2,this.databaseAction(this.modelPath,e)]})})},e.prototype.load=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(e){return[2,this.databaseAction(this.modelPath)]})})},e.prototype.databaseAction=function(e,t){var r=this;return new Promise(function(e,n){var o=r.indexedDB.open(DATABASE_NAME,DATABASE_VERSION);o.onupgradeneeded=function(){return setUpDatabase(o)},o.onsuccess=function(){var a=o.result;if(null==t){var i=a.transaction(MODEL_STORE_NAME,"readonly"),s=i.objectStore(MODEL_STORE_NAME).get(r.modelPath);s.onsuccess=function(){if(null==s.result)return a.close(),n(new Error("Cannot find model with path '"+r.modelPath+"' in IndexedDB."));e(s.result.modelArtifacts)},s.onerror=function(e){return a.close(),n(s.error)},i.oncomplete=function(){return a.close()}}else{var u,l=getModelArtifactsInfoForJSON(t),c=a.transaction(INFO_STORE_NAME,"readwrite"),p=c.objectStore(INFO_STORE_NAME),d=p.put({modelPath:r.modelPath,modelArtifactsInfo:l});d.onsuccess=function(){var o=(u=a.transaction(MODEL_STORE_NAME,"readwrite")).objectStore(MODEL_STORE_NAME).put({modelPath:r.modelPath,modelArtifacts:t,modelArtifactsInfo:l});o.onsuccess=function(){return e({modelArtifactsInfo:l})},o.onerror=function(e){var t=(p=c.objectStore(INFO_STORE_NAME)).delete(r.modelPath);t.onsuccess=function(){return a.close(),n(o.error)},t.onerror=function(e){return a.close(),n(o.error)}}},d.onerror=function(e){return a.close(),n(d.error)},c.oncomplete=function(){null==u?a.close():u.oncomplete=function(){return a.close()}}}},o.onerror=function(e){return n(o.error)}})},e.URL_SCHEME="indexeddb://",e}(),indexedDBRouter=function(e){return ENV.get("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(BrowserIndexedDB.URL_SCHEME)?browserIndexedDB(e.slice(BrowserIndexedDB.URL_SCHEME.length)):null};function browserIndexedDB(e){return new BrowserIndexedDB(e)}function maybeStripScheme(e){return e.startsWith(BrowserIndexedDB.URL_SCHEME)?e.slice(BrowserIndexedDB.URL_SCHEME.length):e}IORouterRegistry.registerSaveRouter(indexedDBRouter),IORouterRegistry.registerLoadRouter(indexedDBRouter);var BrowserIndexedDBManager=function(){function e(){this.indexedDB=getIndexedDBFactory()}return e.prototype.listModels=function(){return __awaiter(this,void 0,void 0,function(){var e=this;return __generator(this,function(t){return[2,new Promise(function(t,r){var n=e.indexedDB.open(DATABASE_NAME,DATABASE_VERSION);n.onupgradeneeded=function(){return setUpDatabase(n)},n.onsuccess=function(){var e=n.result,o=e.transaction(INFO_STORE_NAME,"readonly"),a=o.objectStore(INFO_STORE_NAME).getAll();a.onsuccess=function(){for(var e={},r=0,n=a.result;r<n.length;r++){var o=n[r];e[o.modelPath]=o.modelArtifactsInfo}t(e)},a.onerror=function(t){return e.close(),r(a.error)},o.oncomplete=function(){return e.close()}},n.onerror=function(e){return r(n.error)}})]})})},e.prototype.removeModel=function(e){return __awaiter(this,void 0,void 0,function(){var t=this;return __generator(this,function(r){return e=maybeStripScheme(e),[2,new Promise(function(r,n){var o=t.indexedDB.open(DATABASE_NAME,DATABASE_VERSION);o.onupgradeneeded=function(){return setUpDatabase(o)},o.onsuccess=function(){var t,a=o.result,i=a.transaction(INFO_STORE_NAME,"readwrite"),s=i.objectStore(INFO_STORE_NAME),u=s.get(e);u.onsuccess=function(){if(null==u.result)return a.close(),n(new Error("Cannot find model with path '"+e+"' in IndexedDB."));var o=s.delete(e),i=function(){var o=(t=a.transaction(MODEL_STORE_NAME,"readwrite")).objectStore(MODEL_STORE_NAME).delete(e);o.onsuccess=function(){return r(u.result.modelArtifactsInfo)},o.onerror=function(e){return n(u.error)}};o.onsuccess=i,o.onerror=function(e){return i(),a.close(),n(u.error)}},u.onerror=function(e){return a.close(),n(u.error)},i.oncomplete=function(){null==t?a.close():t.oncomplete=function(){return a.close()}}},o.onerror=function(e){return n(o.error)}})]})})},e}();if(ENV.get("IS_BROWSER"))try{ModelStoreManagerRegistry.registerManager(BrowserIndexedDB.URL_SCHEME,new BrowserIndexedDBManager)}catch(e){}var PATH_SEPARATOR="/",PATH_PREFIX="tensorflowjs_models",INFO_SUFFIX="info",MODEL_TOPOLOGY_SUFFIX="model_topology",WEIGHT_SPECS_SUFFIX="weight_specs",WEIGHT_DATA_SUFFIX="weight_data";function getModelKeys(e){return{info:[PATH_PREFIX,e,INFO_SUFFIX].join(PATH_SEPARATOR),topology:[PATH_PREFIX,e,MODEL_TOPOLOGY_SUFFIX].join(PATH_SEPARATOR),weightSpecs:[PATH_PREFIX,e,WEIGHT_SPECS_SUFFIX].join(PATH_SEPARATOR),weightData:[PATH_PREFIX,e,WEIGHT_DATA_SUFFIX].join(PATH_SEPARATOR)}}function getModelPathFromKey(e){var t=e.split(PATH_SEPARATOR);if(t.length<3)throw new Error("Invalid key format: "+e);return t.slice(1,t.length-1).join(PATH_SEPARATOR)}function maybeStripScheme$1(e){return e.startsWith(BrowserLocalStorage.URL_SCHEME)?e.slice(BrowserLocalStorage.URL_SCHEME.length):e}var BrowserLocalStorage=function(){function e(e){if(!ENV.get("IS_BROWSER")||void 0===window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=getModelKeys(this.modelPath)}return e.prototype.save=function(e){return __awaiter(this,void 0,void 0,function(){var t,r,n,o;return __generator(this,function(a){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");t=JSON.stringify(e.modelTopology),r=JSON.stringify(e.weightSpecs),n=getModelArtifactsInfoForJSON(e);try{return this.LS.setItem(this.keys.info,JSON.stringify(n)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,arrayBufferToBase64String(e.weightData)),[2,{modelArtifactsInfo:n}]}catch(e){for(o in this.keys)this.LS.removeItem(this.keys[o]);throw new Error("Failed to save model '"+this.modelPath+"' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes="+n.modelTopologyBytes+", weightSpecsBytes="+n.weightSpecsBytes+", weightDataBytes="+n.weightDataBytes+".")}return[2]})})},e.prototype.load=function(){return __awaiter(this,void 0,void 0,function(){var e,t,r,n,o;return __generator(this,function(a){if(null==(e=JSON.parse(this.LS.getItem(this.keys.info))))throw new Error("In local storage, there is no model with name '"+this.modelPath+"'");if("JSON"!==e.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");if(t={},null==(r=JSON.parse(this.LS.getItem(this.keys.topology))))throw new Error("In local storage, the topology of model '"+this.modelPath+"' is missing.");if(t.modelTopology=r,null==(n=JSON.parse(this.LS.getItem(this.keys.weightSpecs))))throw new Error("In local storage, the weight specs of model '"+this.modelPath+"' are missing.");if(t.weightSpecs=n,null==(o=this.LS.getItem(this.keys.weightData)))throw new Error("In local storage, the binary weight values of model '"+this.modelPath+"' are missing.");return t.weightData=base64StringToArrayBuffer(o),[2,t]})})},e.URL_SCHEME="localstorage://",e}(),localStorageRouter=function(e){return ENV.get("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(BrowserLocalStorage.URL_SCHEME)?browserLocalStorage(e.slice(BrowserLocalStorage.URL_SCHEME.length)):null};function browserLocalStorage(e){return new BrowserLocalStorage(e)}IORouterRegistry.registerSaveRouter(localStorageRouter),IORouterRegistry.registerLoadRouter(localStorageRouter);var BrowserLocalStorageManager=function(){function e(){assert(ENV.get("IS_BROWSER"),"Current environment is not a web browser"),assert(void 0!==window.localStorage,"Current browser does not appear to support localStorage"),this.LS=window.localStorage}return e.prototype.listModels=function(){return __awaiter(this,void 0,void 0,function(){var e,t,r,n,o,a;return __generator(this,function(i){for(e={},t=PATH_PREFIX+PATH_SEPARATOR,r=PATH_SEPARATOR+INFO_SUFFIX,n=0;n<this.LS.length;++n)(o=this.LS.key(n)).startsWith(t)&&o.endsWith(r)&&(a=getModelPathFromKey(o),e[a]=JSON.parse(this.LS.getItem(o)));return[2,e]})})},e.prototype.removeModel=function(e){return __awaiter(this,void 0,void 0,function(){var t,r;return __generator(this,function(n){if(e=maybeStripScheme$1(e),t=getModelKeys(e),null==this.LS.getItem(t.info))throw new Error("Cannot find model at path '"+e+"'");return r=JSON.parse(this.LS.getItem(t.info)),this.LS.removeItem(t.info),this.LS.removeItem(t.topology),this.LS.removeItem(t.weightSpecs),this.LS.removeItem(t.weightData),[2,r]})})},e}();if(ENV.get("IS_BROWSER"))try{ModelStoreManagerRegistry.registerManager(BrowserLocalStorage.URL_SCHEME,new BrowserLocalStorageManager)}catch(e){}var DEFAULT_FILE_NAME_PREFIX="model",DEFAULT_JSON_EXTENSION_NAME=".json",DEFAULT_WEIGHT_DATA_EXTENSION_NAME=".weights.bin",BrowserDownloads=function(){function e(t){if(!ENV.get("IS_BROWSER"))throw new Error("triggerDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(e.URL_SCHEME)&&(t=t.slice(e.URL_SCHEME.length)),null!=t&&0!==t.length||(t=DEFAULT_FILE_NAME_PREFIX),this.modelTopologyFileName=t+DEFAULT_JSON_EXTENSION_NAME,this.weightDataFileName=t+DEFAULT_WEIGHT_DATA_EXTENSION_NAME}return e.prototype.save=function(e){return __awaiter(this,void 0,void 0,function(){var t,r,n,o,a,i;return __generator(this,function(s){if(t=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"})),e.modelTopology instanceof ArrayBuffer)throw new Error("DownloadTrigger.save() does not support saving model topology in binary formats yet.");return r=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],n={modelTopology:e.modelTopology,weightsManifest:r},o=window.URL.createObjectURL(new Blob([JSON.stringify(n)],{type:"application/json"})),(a=null==this.jsonAnchor?document.createElement("a"):this.jsonAnchor).download=this.modelTopologyFileName,a.href=o,a.click(),null!=e.weightData&&((i=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor).download=this.weightDataFileName,i.href=t,i.click()),[2,{modelArtifactsInfo:getModelArtifactsInfoForJSON(e)}]})})},e.URL_SCHEME="downloads://",e}(),BrowserFiles=function(){function e(e){if(null==e||e.length<1)throw new Error("When calling browserFiles, at least 1 file is required, but received "+e);this.files=e}return e.prototype.load=function(){return __awaiter(this,void 0,void 0,function(){var e,t,r=this;return __generator(this,function(n){return e=this.files[0],t=this.files.slice(1),[2,new Promise(function(n,o){var a=new FileReader;a.onload=function(a){var i=JSON.parse(a.target.result),s=i.modelTopology;if(null!=s){0===t.length&&n({modelTopology:s});var u=i.weightsManifest;if(null!=u){var l;try{l=r.checkManifestAndWeightFiles(u,t)}catch(e){return void o(e)}var c=[],p=[],d=[];u.forEach(function(e){e.paths.forEach(function(e){p.push(e),d.push(null)}),c.push.apply(c,e.weights)}),u.forEach(function(e){e.paths.forEach(function(e){var t=new FileReader;t.onload=function(t){var r=t.target.result,o=p.indexOf(e);d[o]=r,-1===d.indexOf(null)&&n({modelTopology:s,weightSpecs:c,weightData:concatenateArrayBuffers(d)})},t.onerror=function(t){o("Failed to weights data from file of path '"+e+"'.")},t.readAsArrayBuffer(l[e])})})}else o(new Error("weightManifest field is missing from file "+e.name))}else o(new Error("modelTopology field is missing from file "+e.name))},a.onerror=function(t){o("Failed to read model topology and weights manifest JSON from file '"+e.name+"'. BrowserFiles supports loading Keras-style tf.Model artifacts only.")},a.readAsText(e)})]})})},e.prototype.checkManifestAndWeightFiles=function(e,t){for(var r=[],n=t.map(function(e){return basename(e.name)}),o={},a=0,i=e;a<i.length;a++){i[a].paths.forEach(function(e){var a=basename(e);if(-1!==r.indexOf(a))throw new Error("Duplicate file basename found in weights manifest: '"+a+"'");if(r.push(a),-1===n.indexOf(a))throw new Error("Weight file with basename '"+a+"' is not provided.");o[e]=t[n.indexOf(a)]})}if(r.length!==t.length)throw new Error("Mismatch in the number of files in weights manifest ("+r.length+") and the number of weight files provided ("+t.length+").");return o},e}(),browserDownloadsRouter=function(e){return ENV.get("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(BrowserDownloads.URL_SCHEME)?browserDownloads(e.slice(BrowserDownloads.URL_SCHEME.length)):null};function browserDownloads(e){return void 0===e&&(e="model"),new BrowserDownloads(e)}function browserFiles(e){return new BrowserFiles(e)}function loadWeightsAsArrayBuffer(e,t){return __awaiter(this,void 0,void 0,function(){var r,n;return __generator(this,function(o){switch(o.label){case 0:return r=e.map(function(e){return fetch(e,t)}),[4,Promise.all(r)];case 1:return n=o.sent(),[4,Promise.all(n.map(function(e){return e.arrayBuffer()}))];case 2:return[2,o.sent()]}})})}function loadWeights(e,t,r,n){return void 0===t&&(t=""),__awaiter(this,void 0,void 0,function(){var o,a,i,s,u,l,c,p,d,h;return __generator(this,function(f){switch(f.label){case 0:if(o=e.map(function(){return!1}),a={},i=null!=r?r.map(function(){return!1}):[],s=[],e.forEach(function(e,t){var n=0;e.weights.forEach(function(e){var u="quantization"in e?e.quantization.dtype:e.dtype,l=DTYPE_VALUE_SIZE_MAP[u]*sizeFromShape(e.shape),c=function(){o[t]=!0,null==a[t]&&(a[t]=[]),a[t].push({manifestEntry:e,groupOffset:n,sizeBytes:l})};null!=r?r.forEach(function(t,r){t===e.name&&(c(),i[r]=!0)}):c(),s.push(e.name),n+=l})}),!i.every(function(e){return e}))throw u=r.filter(function(e,t){return!i[t]}),new Error("Could not find weights in manifest with names: "+u.join(", ")+". \nManifest JSON has weights with names: "+s.join(", ")+".");return l=o.reduce(function(e,t,r){return t&&e.push(r),e},[]),c=[],l.forEach(function(r){e[r].paths.forEach(function(e){var r=t+(t.endsWith("/")?"":"/")+e;c.push(r)})}),[4,loadWeightsAsArrayBuffer(c,n)];case 1:return p=f.sent(),d={},h=0,l.forEach(function(t){for(var r=e[t].paths.length,n=0,o=0;o<r;o++)n+=p[h+o].byteLength;for(var i=new ArrayBuffer(n),s=new Uint8Array(i),u=0,l=0;l<r;l++){var c=new Uint8Array(p[h+l]);s.set(c,u),u+=c.byteLength}a[t].forEach(function(e){var t=decodeWeights(i.slice(e.groupOffset,e.groupOffset+e.sizeBytes),[e.manifestEntry]);for(var r in t)d[r]=t[r]}),h+=r}),[2,d]}})})}IORouterRegistry.registerSaveRouter(browserDownloadsRouter);var BrowserHTTPRequest=function(){function e(e,t,r){if(this.weightPathPrefix=r,this.DEFAULT_METHOD="POST","undefined"==typeof fetch)throw new Error("browserHTTPRequest is not supported outside the web browser without a fetch polyfill.");if(assert(null!=e&&e.length>0,"URL path for browserHTTPRequest must not be null, undefined or empty."),Array.isArray(e)&&assert(2===e.length,"URL paths for browserHTTPRequest must have a length of 2, (actual length is "+e.length+")."),this.path=e,null!=t&&null!=t.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t||{}}return e.prototype.save=function(e){return __awaiter(this,void 0,void 0,function(){var t,r,n,o;return __generator(this,function(a){switch(a.label){case 0:if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");return(t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit)).body=new FormData,r=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],n={modelTopology:e.modelTopology,weightsManifest:r},t.body.append("model.json",new Blob([JSON.stringify(n)],{type:"application/json"}),"model.json"),null!=e.weightData&&t.body.append("model.weights.bin",new Blob([e.weightData],{type:"application/octet-stream"}),"model.weights.bin"),[4,fetch(this.path,t)];case 1:if((o=a.sent()).ok)return[2,{modelArtifactsInfo:getModelArtifactsInfoForJSON(e),responses:[o]}];throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status "+o.status+".")}})})},e.prototype.load=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(e){return[2,Array.isArray(this.path)?this.loadBinaryModel():this.loadJSONModel()]})})},e.prototype.loadBinaryTopology=function(){return __awaiter(this,void 0,void 0,function(){var e,t;return __generator(this,function(r){switch(r.label){case 0:return r.trys.push([0,3,,4]),[4,fetch(this.path[0],this.requestInit)];case 1:if(!(e=r.sent()).ok)throw new Error("BrowserHTTPRequest.load() failed due to HTTP response: "+e.statusText);return[4,e.arrayBuffer()];case 2:return[2,r.sent()];case 3:throw t=r.sent(),new Error(this.path[0]+" not found. "+t);case 4:return[2]}})})},e.prototype.loadBinaryModel=function(){return __awaiter(this,void 0,void 0,function(){var e,t,r,n,o,a,i,s;return __generator(this,function(u){switch(u.label){case 0:return e=this.loadBinaryTopology(),[4,fetch(this.path[1],this.requestInit)];case 1:if(!(t=u.sent()).ok)throw new Error("BrowserHTTPRequest.load() failed due to HTTP response: "+t.statusText);return[4,Promise.all([e,t])];case 2:return r=u.sent(),n=r[0],[4,r[1].json()];case 3:return null==(o=u.sent())?[3,5]:[4,this.loadWeights(o)];case 4:s=u.sent(),a=s[0],i=s[1],u.label=5;case 5:return[2,{modelTopology:n,weightSpecs:a,weightData:i}]}})})},e.prototype.loadJSONModel=function(){return __awaiter(this,void 0,void 0,function(){var e,t,r,n,o,a,i,s;return __generator(this,function(u){switch(u.label){case 0:return[4,fetch(this.path,this.requestInit)];case 1:if(!(e=u.sent()).ok)throw new Error("BrowserHTTPRequest.load() failed due to HTTP response: "+e.statusText);return[4,e.json()];case 2:if(t=u.sent(),r=t.modelTopology,n=t.weightsManifest,null==r&&null==n)throw new Error("The JSON from HTTP path "+this.path+" contains neither model topology or manifest for weights.");return null==n?[3,4]:(i=t.weightsManifest,[4,this.loadWeights(i)]);case 3:s=u.sent(),o=s[0],a=s[1],u.label=4;case 4:return[2,{modelTopology:r,weightSpecs:o,weightData:a}]}})})},e.prototype.loadWeights=function(e){return __awaiter(this,void 0,void 0,function(){var t,r,n,o,a,i,s,u,l,c,p,d;return __generator(this,function(h){switch(h.label){case 0:for(t=Array.isArray(this.path)?this.path[1]:this.path,r=parseUrl(t),n=r[0],o=r[1],a=this.weightPathPrefix||n,i=[],s=0,u=e;s<u.length;s++)l=u[s],i.push.apply(i,l.weights);return c=[],e.forEach(function(e){e.paths.forEach(function(e){c.push(a+e+o)})}),p=[i],d=concatenateArrayBuffers,[4,loadWeightsAsArrayBuffer(c,this.requestInit)];case 1:return[2,p.concat([d.apply(void 0,[h.sent()])])]}})})},e.URL_SCHEME_REGEX=/^https?:\/\//,e}();function parseUrl(e){var t=e.lastIndexOf("/"),r=e.lastIndexOf("?");return[e.substring(0,t)+"/",r>t?e.substring(r):""]}function isHTTPScheme(e){return null!=e.match(BrowserHTTPRequest.URL_SCHEME_REGEX)}var httpRequestRouter=function(e){if("undefined"==typeof fetch)return null;return(Array.isArray(e)?e.every(function(e){return isHTTPScheme(e)}):isHTTPScheme(e))?browserHTTPRequest(e):null};function browserHTTPRequest(e,t,r){return new BrowserHTTPRequest(e,t,r)}IORouterRegistry.registerSaveRouter(httpRequestRouter),IORouterRegistry.registerLoadRouter(httpRequestRouter);var PassthroughLoader=function(){function e(e,t,r){this.modelTopology=e,this.weightSpecs=t,this.weightData=r}return e.prototype.load=function(){return __awaiter(this,void 0,void 0,function(){var e;return __generator(this,function(t){return e={},null!=this.modelTopology&&(e=__assign({modelTopology:this.modelTopology},e)),null!=this.weightSpecs&&this.weightSpecs.length>0&&(e=__assign({weightSpecs:this.weightSpecs},e)),null!=this.weightData&&this.weightData.byteLength>0&&(e=__assign({weightData:this.weightData},e)),[2,e]})})},e}(),PassthroughSaver=function(){function e(e){this.saveHandler=e}return e.prototype.save=function(e){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(t){return[2,this.saveHandler(e)]})})},e}();function fromMemory(e,t,r){return new PassthroughLoader(e,t,r)}function withSaveHandler(e){return new PassthroughSaver(e)}var registerSaveRouter=IORouterRegistry.registerSaveRouter,registerLoadRouter=IORouterRegistry.registerLoadRouter,getSaveHandlers=IORouterRegistry.getSaveHandlers,getLoadHandlers=IORouterRegistry.getLoadHandlers,io=Object.freeze({browserFiles:browserFiles,browserHTTPRequest:browserHTTPRequest,concatenateArrayBuffers:concatenateArrayBuffers,decodeWeights:decodeWeights,encodeWeights:encodeWeights,fromMemory:fromMemory,getLoadHandlers:getLoadHandlers,getModelArtifactsInfoForJSON:getModelArtifactsInfoForJSON,getSaveHandlers:getSaveHandlers,loadWeights:loadWeights,registerLoadRouter:registerLoadRouter,registerSaveRouter:registerSaveRouter,withSaveHandler:withSaveHandler,copyModel:copyModel,listModels:listModels,moveModel:moveModel,removeModel:removeModel});function confusionMatrix_(e,t,r){var n=convertToTensor(e,"label","confusionMatrix","int32"),o=convertToTensor(t,"label","confusionMatrix","int32");assert(null==r||r>0&&Number.isInteger(r),"If provided, numClasses must be a positive integer, but got "+r),assert(1===n.rank,"Expected the rank of labels to be 1, but got "+n.rank),assert(1===o.rank,"Expected the rank of predictions to be 1, but got "+o.rank),assert(n.shape[0]===o.shape[0],"Mismatch in the number of examples: "+n.shape[0]+" vs. "+o.shape[0]+". Labels and predictions should have the same number of elements."),assert(r>0&&Number.isInteger(r),"numClasses is required to be a positive integer, but got "+r);var a=oneHot(n.asType("int32"),r),i=oneHot(o.asType("int32"),r);return a.transpose().matMul(i).asType("int32")}var confusionMatrix=op({confusionMatrix_:confusionMatrix_}),math=Object.freeze({confusionMatrix:confusionMatrix}),Serializable=function(){function e(){}return e.prototype.getClassName=function(){return this.constructor.className},e.fromConfig=function(e,t){return new e(t)},e}(),SerializationMap=function(){function e(){this.classNameMap={}}return e.getMap=function(){return null==e.instance&&(e.instance=new e),e.instance},e.register=function(t){e.getMap().classNameMap[t.className]=[t,t.fromConfig]},e}();function registerClass(e){assert(null!=e.className,"Class being registered does not have the static className property defined."),assert("string"==typeof e.className,"className is required to be a string, but got type "+typeof e.className),assert(e.className.length>0,"Class being registered has an empty-string as its className, which is disallowed."),SerializationMap.register(e)}var serialization=Object.freeze({Serializable:Serializable,SerializationMap:SerializationMap,registerClass:registerClass}),WEBGL_ENVS={HAS_WEBGL:!0},NODE_ENVS={IS_NODE:!0},CHROME_ENVS={IS_CHROME:!0},BROWSER_ENVS={IS_BROWSER:!0},CPU_ENVS={HAS_WEBGL:!1},BROWSER_CPU_ENVS={BACKEND:"test-cpu"},ALL_ENVS={};function expectArraysClose(e,t,r){if(null==r&&(r=ENV.get("TEST_EPSILON")),e instanceof Tensor||t instanceof Tensor){if(e instanceof Tensor&&t instanceof Tensor){if(e.dtype!==t.dtype)throw new Error("Arrays are of different type actual: "+e.dtype+" vs expected: "+t.dtype+".");if(!arraysEqual(e.shape,t.shape))throw new Error("Arrays are of different shape actual: "+e.shape+" vs expected: "+t.shape+".")}}else{var n=e.constructor.name,o=t.constructor.name;if(n!==o)throw new Error("Arrays are of different type actual: "+n+" vs expected: "+o)}var a,i;if(a=e instanceof Tensor?e.dataSync():e,i=t instanceof Tensor?t.dataSync():t,a.length!==i.length)throw new Error("Arrays have different lengths actual: "+a.length+" vs expected: "+i.length+".\nActual:   "+a+".\nExpected: "+i+".");for(var s=0;s<i.length;++s){var u=a[s],l=i[s];if(!areClose(u,Number(l),r))throw new Error("Arrays differ: actual["+s+"] = "+u+", expected["+s+"] = "+l+".\nActual:   "+a+".\nExpected: "+i+".")}}function expectPromiseToFail(e,t){e().then(function(){return t.fail()},function(){return t()})}function expectArraysEqual(e,t){return expectArraysClose(e,t,0)}function expectNumbersClose(e,t,r){if(null==r&&(r=ENV.get("TEST_EPSILON")),!areClose(e,t,r))throw new Error("Numbers differ: actual === "+e+", expected === "+t)}function areClose(e,t,r){return!(!isNaN(e)||!isNaN(t))||!(isNaN(e)||isNaN(t)||Math.abs(e-t)>r)}function expectValuesInRange(e,t,r){var n;n=e instanceof Tensor?e.dataSync():e;for(var o=0;o<n.length;o++)if(n[o]<t||n[o]>r)throw new Error("Value out of range:"+n[o]+" low: "+t+", high: "+r)}function expectArrayBuffersEqual(e,t){expect(new Float32Array(e)).toEqual(new Float32Array(t))}var test_util=Object.freeze({WEBGL_ENVS:WEBGL_ENVS,NODE_ENVS:NODE_ENVS,CHROME_ENVS:CHROME_ENVS,BROWSER_ENVS:BROWSER_ENVS,CPU_ENVS:CPU_ENVS,BROWSER_CPU_ENVS:BROWSER_CPU_ENVS,ALL_ENVS:ALL_ENVS,expectArraysClose:expectArraysClose,expectPromiseToFail:expectPromiseToFail,expectArraysEqual:expectArraysEqual,expectNumbersClose:expectNumbersClose,expectValuesInRange:expectValuesInRange,expectArrayBuffersEqual:expectArrayBuffersEqual}),version="0.13.11",webgl=Object.freeze({gpgpu_util:gpgpu_util,webgl_util:webgl_util,MathBackendWebGL:MathBackendWebGL,GPGPUContext:GPGPUContext}),Optimizer=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.minimize=function(e,t,r){void 0===t&&(t=!1);var n=this.computeGradients(e,r),o=n.value,a=n.grads;return this.applyGradients(a),Object.keys(a).forEach(function(e){return a[e].dispose()}),t?o:(o.dispose(),null)},t.prototype.computeGradients=function(e,t){return variableGrads(e,t)},t}(Serializable),AdadeltaOptimizer=function(e){function t(t,r,n){void 0===n&&(n=null);var o=e.call(this)||this;return o.learningRate=t,o.rho=r,o.epsilon=n,o.accumulatedGrads={},o.accumulatedUpdates={},o.c=keep(scalar(-t)),o.rhoScalar=keep(scalar(r)),o.oneMinusRho=keep(scalar(1-r)),null===n&&(n=ENV.get("EPSILON")),o.epsilonScalar=keep(scalar(n)),o}return __extends(t,e),t.prototype.applyGradients=function(e){var t=this,r=function(r){var o=ENV.engine.registeredVariables[r];if(null==n.accumulatedGrads[r]){tidy(function(){t.accumulatedGrads[r]=zerosLike(o).variable(!1)})}if(null==n.accumulatedUpdates[r]){tidy(function(){t.accumulatedUpdates[r]=zerosLike(o).variable(!1)})}var a=e[r],i=n.accumulatedGrads[r],s=n.accumulatedUpdates[r];tidy(function(){var e=t.rhoScalar.mul(i).add(t.oneMinusRho.mul(a.square())),n=s.add(t.epsilonScalar).sqrt().div(i.add(t.epsilonScalar).sqrt()).mul(a),u=t.rhoScalar.mul(s).add(t.oneMinusRho.mul(n.square()));t.accumulatedGrads[r].assign(e),t.accumulatedUpdates[r].assign(u);var l=t.c.mul(n).add(o);o.assign(l)})},n=this;for(var o in e)r(o)},t.prototype.dispose=function(){var e=this;this.c.dispose(),this.epsilonScalar.dispose(),this.rhoScalar.dispose(),this.oneMinusRho.dispose(),null!=this.accumulatedUpdates&&(Object.keys(this.accumulatedUpdates).forEach(function(t){return e.accumulatedUpdates[t].dispose()}),Object.keys(this.accumulatedGrads).forEach(function(t){return e.accumulatedGrads[t].dispose()}))},t.prototype.getConfig=function(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}},t.fromConfig=function(e,t){return new e(t.learningRate,t.rho,t.epsilon)},t.className="AdadeltaOptimizer",t}(Optimizer);registerClass(AdadeltaOptimizer);var AdagradOptimizer=function(e){function t(t,r){void 0===r&&(r=.1);var n=e.call(this)||this;return n.learningRate=t,n.initialAccumulatorValue=r,n.accumulatedGrads={},n.c=keep(scalar(-t)),n.epsilon=keep(scalar(ENV.get("EPSILON"))),n}return __extends(t,e),t.prototype.applyGradients=function(e){var t=this,r=function(r){var o=ENV.engine.registeredVariables[r];if(null==n.accumulatedGrads[r]){tidy(function(){t.accumulatedGrads[r]=fill(o.shape,t.initialAccumulatorValue).variable(!1)})}var a=e[r],i=n.accumulatedGrads[r];tidy(function(){var e=i.add(a.square());t.accumulatedGrads[r].assign(e);var n=t.c.mul(a.div(e.add(t.epsilon).sqrt())).add(o);o.assign(n)})},n=this;for(var o in e)r(o)},t.prototype.dispose=function(){var e=this;this.epsilon.dispose(),this.c.dispose(),null!=this.accumulatedGrads&&Object.keys(this.accumulatedGrads).forEach(function(t){return e.accumulatedGrads[t].dispose()})},t.prototype.getConfig=function(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}},t.fromConfig=function(e,t){return new e(t.learningRate,t.initialAccumulatorValue)},t.className="AdagradOptimizer",t}(Optimizer);registerClass(AdagradOptimizer);var AdamOptimizer=function(e){function t(t,r,n,o){void 0===o&&(o=null);var a=e.call(this)||this;return a.learningRate=t,a.beta1=r,a.beta2=n,a.epsilon=o,a.accumulatedFirstMoment={},a.accumulatedSecondMoment={},a.c=keep(scalar(-t)),a.beta1Scalar=keep(scalar(r)),a.beta2Scalar=keep(scalar(n)),tidy(function(){a.accBeta1=scalar(r).variable(),a.accBeta2=scalar(n).variable()}),a.oneMinusBeta1=keep(scalar(1-r)),a.oneMinusBeta2=keep(scalar(1-n)),a.one=keep(scalar(1)),null===o&&(o=ENV.get("EPSILON")),a.epsScalar=keep(scalar(o)),a}return __extends(t,e),t.prototype.applyGradients=function(e){var t=this;tidy(function(){var r=t.one.sub(t.accBeta1),n=t.one.sub(t.accBeta2);for(var o in e){var a=ENV.engine.registeredVariables[o];if(null==t.accumulatedFirstMoment[o]){var i=!1;t.accumulatedFirstMoment[o]=zerosLike(a).variable(i)}if(null==t.accumulatedSecondMoment[o]){i=!1;t.accumulatedSecondMoment[o]=zerosLike(a).variable(i)}var s=e[o],u=t.accumulatedFirstMoment[o],l=t.accumulatedSecondMoment[o],c=t.beta1Scalar.mul(u).add(t.oneMinusBeta1.mul(s)),p=t.beta2Scalar.mul(l).add(t.oneMinusBeta2.mul(s.square())),d=c.div(r),h=p.div(n);t.accumulatedFirstMoment[o].assign(c),t.accumulatedSecondMoment[o].assign(p);var f=t.c.mul(d.div(t.epsScalar.add(h.sqrt()))).add(a);a.assign(f)}t.accBeta1.assign(t.accBeta1.mul(t.beta1Scalar)),t.accBeta2.assign(t.accBeta2.mul(t.beta2Scalar))})},t.prototype.dispose=function(){var e=this;this.c.dispose(),this.epsScalar.dispose(),this.beta1Scalar.dispose(),this.beta2Scalar.dispose(),this.accBeta1.dispose(),this.accBeta2.dispose(),this.oneMinusBeta1.dispose(),this.oneMinusBeta2.dispose(),this.one.dispose(),null!=this.accumulatedFirstMoment&&Object.keys(this.accumulatedFirstMoment).forEach(function(t){return e.accumulatedFirstMoment[t].dispose()}),null!=this.accumulatedSecondMoment&&Object.keys(this.accumulatedSecondMoment).forEach(function(t){return e.accumulatedSecondMoment[t].dispose()})},t.prototype.getConfig=function(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}},t.fromConfig=function(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)},t.className="AdamOptimizer",t}(Optimizer);registerClass(AdamOptimizer);var AdamaxOptimizer=function(e){function t(t,r,n,o,a){void 0===o&&(o=null),void 0===a&&(a=0);var i=e.call(this)||this;return i.learningRate=t,i.beta1=r,i.beta2=n,i.epsilon=o,i.decay=a,i.accumulatedFirstMoment={},i.accumulatedWeightedInfNorm={},i.c=keep(scalar(-t)),i.beta1Scalar=keep(scalar(r)),i.beta2Scalar=keep(scalar(n)),i.decayScalar=keep(scalar(a)),tidy(function(){i.iteration=scalar(0).variable(),i.accBeta1=scalar(r).variable()}),i.oneMinusBeta1=keep(scalar(1-r)),i.one=keep(scalar(1)),null===o&&(o=ENV.get("EPSILON")),i.epsScalar=keep(scalar(o)),i}return __extends(t,e),t.prototype.applyGradients=function(e){var t=this;tidy(function(){var r=t.one.sub(t.accBeta1),n=t.c.div(t.one.add(t.decayScalar.mul(t.iteration)));for(var o in e){var a=ENV.engine.registeredVariables[o];if(null==t.accumulatedFirstMoment[o]){var i=!1;t.accumulatedFirstMoment[o]=zerosLike(a).variable(i)}if(null==t.accumulatedWeightedInfNorm[o]){i=!1;t.accumulatedWeightedInfNorm[o]=zerosLike(a).variable(i)}var s=e[o],u=t.accumulatedFirstMoment[o],l=t.accumulatedWeightedInfNorm[o],c=t.beta1Scalar.mul(u).add(t.oneMinusBeta1.mul(s)),p=t.beta2Scalar.mul(l),d=s.abs(),h=p.maximum(d);t.accumulatedFirstMoment[o].assign(c),t.accumulatedWeightedInfNorm[o].assign(h);var f=n.div(r).mul(c.div(t.epsScalar.add(h))).add(a);a.assign(f)}t.iteration.assign(t.iteration.add(t.one)),t.accBeta1.assign(t.accBeta1.mul(t.beta1Scalar))})},t.prototype.dispose=function(){var e=this;this.c.dispose(),this.epsScalar.dispose(),this.accBeta1.dispose(),this.beta1Scalar.dispose(),this.beta2Scalar.dispose(),this.oneMinusBeta1.dispose(),this.decayScalar.dispose(),this.iteration.dispose(),this.one.dispose(),null!=this.accumulatedFirstMoment&&Object.keys(this.accumulatedFirstMoment).forEach(function(t){return e.accumulatedFirstMoment[t].dispose()}),null!=this.accumulatedWeightedInfNorm&&Object.keys(this.accumulatedWeightedInfNorm).forEach(function(t){return e.accumulatedWeightedInfNorm[t].dispose()})},t.prototype.getConfig=function(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}},t.fromConfig=function(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)},t.className="AdamaxOptimizer",t}(Optimizer);registerClass(AdamaxOptimizer);var SGDOptimizer=function(e){function t(t){var r=e.call(this)||this;return r.learningRate=t,r.setLearningRate(t),r}return __extends(t,e),t.prototype.applyGradients=function(e){var t=this;Object.keys(e).forEach(function(r){var n=e[r],o=ENV.engine.registeredVariables[r];tidy(function(){var e=t.c.mul(n).add(o);o.assign(e)})})},t.prototype.setLearningRate=function(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=keep(scalar(-e))},t.prototype.dispose=function(){this.c.dispose()},t.prototype.getConfig=function(){return{learningRate:this.learningRate}},t.fromConfig=function(e,t){return new e(t.learningRate)},t.className="SGDOptimizer",t}(Optimizer);registerClass(SGDOptimizer);var MomentumOptimizer=function(e){function t(t,r,n){void 0===n&&(n=!1);var o=e.call(this,t)||this;return o.learningRate=t,o.momentum=r,o.useNesterov=n,o.m=scalar(o.momentum),o.accumulations={},o}return __extends(t,e),t.prototype.applyGradients=function(e){var t=this,r=function(r){var o=ENV.engine.registeredVariables[r];if(null==n.accumulations[r]){tidy(function(){t.accumulations[r]=zerosLike(o).variable(!1)})}var a=n.accumulations[r],i=e[r];tidy(function(){var e,n=t.m.mul(a).add(i);e=t.useNesterov?t.c.mul(i.add(n.mul(t.m))).add(o):t.c.mul(n).add(o),t.accumulations[r].assign(n),o.assign(e)})},n=this;for(var o in e)r(o)},t.prototype.dispose=function(){if(e.prototype.dispose.call(this),this.m.dispose(),null!=this.accumulations)for(var t in this.accumulations)this.accumulations[t].dispose()},t.prototype.setMomentum=function(e){this.momentum=e},t.prototype.getConfig=function(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}},t.fromConfig=function(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)},t.className="MomentumOptimizer",t}(SGDOptimizer);registerClass(MomentumOptimizer);var RMSPropOptimizer=function(e){function t(t,r,n,o,a){void 0===r&&(r=.9),void 0===n&&(n=0),void 0===o&&(o=null),void 0===a&&(a=!1);var i=e.call(this)||this;return i.learningRate=t,i.decay=r,i.momentum=n,i.epsilon=o,i.accumulatedMeanSquares={},i.accumulatedMeanGrads={},i.accumulatedMoments={},i.c=keep(scalar(t)),i.decayScalar=keep(scalar(r)),i.momentumScalar=keep(scalar(n)),i.oneMinusDecay=keep(scalar(1-r)),i.centered=a,null===o&&(o=ENV.get("EPSILON")),i.epsilonScalar=keep(scalar(o)),i}return __extends(t,e),t.prototype.applyGradients=function(e){var t=this,r=function(r){var o=ENV.engine.registeredVariables[r];if(null==n.accumulatedMeanSquares[r]){tidy(function(){t.accumulatedMeanSquares[r]=zerosLike(o).variable(!1)})}if(null==n.accumulatedMeanGrads[r]&&n.centered){tidy(function(){t.accumulatedMeanGrads[r]=zerosLike(o).variable(!1)})}if(null==n.accumulatedMoments[r]){tidy(function(){t.accumulatedMoments[r]=zerosLike(o).variable(!1)})}var a=n.accumulatedMeanSquares[r],i=n.accumulatedMeanGrads[r],s=n.accumulatedMoments[r],u=e[r];tidy(function(){var e=t.decayScalar.mul(a).add(t.oneMinusDecay.mul(u.square()));if(t.centered){var n=t.decayScalar.mul(i).add(t.oneMinusDecay.mul(u)),l=t.momentumScalar.mul(s).add(t.c.mul(u).div(e.sub(n.square().add(t.epsilonScalar)).sqrt()));t.accumulatedMeanSquares[r].assign(e),t.accumulatedMeanGrads[r].assign(n),t.accumulatedMoments[r].assign(l);var c=o.sub(l);o.assign(c)}else{var p=t.decayScalar.mul(a).add(t.oneMinusDecay.mul(u.square()));l=t.momentumScalar.mul(s).add(t.c.mul(u).div(p.add(t.epsilonScalar).sqrt()));t.accumulatedMeanSquares[r].assign(p),t.accumulatedMoments[r].assign(l);c=o.sub(l);o.assign(c)}})},n=this;for(var o in e)r(o)},t.prototype.dispose=function(){var e=this;this.c.dispose(),this.epsilonScalar.dispose(),this.decayScalar.dispose(),this.momentumScalar.dispose(),this.oneMinusDecay.dispose(),null!=this.accumulatedMeanSquares&&Object.keys(this.accumulatedMeanSquares).forEach(function(t){return e.accumulatedMeanSquares[t].dispose()}),null!=this.accumulatedMeanGrads&&this.centered&&Object.keys(this.accumulatedMeanGrads).forEach(function(t){return e.accumulatedMeanGrads[t].dispose()}),null!=this.accumulatedMoments&&Object.keys(this.accumulatedMoments).forEach(function(t){return e.accumulatedMoments[t].dispose()})},t.prototype.getConfig=function(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}},t.fromConfig=function(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)},t.className="RMSPropOptimizer",t}(Optimizer);registerClass(RMSPropOptimizer);var OptimizerConstructors=function(){function e(){}return e.sgd=function(e){return new SGDOptimizer(e)},e.momentum=function(e,t,r){return void 0===r&&(r=!1),new MomentumOptimizer(e,t,r)},e.rmsprop=function(e,t,r,n,o){return void 0===t&&(t=.9),void 0===r&&(r=0),void 0===n&&(n=null),void 0===o&&(o=!1),new RMSPropOptimizer(e,t,r,n,o)},e.adam=function(e,t,r,n){return void 0===e&&(e=.001),void 0===t&&(t=.9),void 0===r&&(r=.999),void 0===n&&(n=null),new AdamOptimizer(e,t,r,n)},e.adadelta=function(e,t,r){return void 0===e&&(e=.001),void 0===t&&(t=.95),void 0===r&&(r=null),new AdadeltaOptimizer(e,t,r)},e.adamax=function(e,t,r,n,o){return void 0===e&&(e=.002),void 0===t&&(t=.9),void 0===r&&(r=.999),void 0===n&&(n=null),void 0===o&&(o=0),new AdamaxOptimizer(e,t,r,n,o)},e.adagrad=function(e,t){return void 0===t&&(t=.1),new AdagradOptimizer(e,t)},e}(),train={sgd:OptimizerConstructors.sgd,momentum:OptimizerConstructors.momentum,adadelta:OptimizerConstructors.adadelta,adagrad:OptimizerConstructors.adagrad,rmsprop:OptimizerConstructors.rmsprop,adamax:OptimizerConstructors.adamax,adam:OptimizerConstructors.adam},setBackend=Environment.setBackend,getBackend=Environment.getBackend,disposeVariables=Environment.disposeVariables,memory=Environment.memory;setOpHandler(ops);
//# sourceMappingURL=tf-core.esm.js.map

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../process/browser.js */ "./node_modules/process/browser.js"), __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../../timers-browserify/main.js */ "./node_modules/timers-browserify/main.js").setImmediate, __webpack_require__(/*! ./../../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-layers/dist/tf-layers.esm.js":
/*!********************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-layers/dist/tf-layers.esm.js ***!
  \********************************************************************/
/*! exports provided: constraints, initializers, layers, models, metrics, regularizers, CallbackList, CustomCallback, History, Callback, InputSpec, SymbolicTensor, Model, input, loadModel, model, registerCallbackConstructor, sequential, RNN, Sequential, LayerVariable, version_layers */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "constraints", function() { return exports_constraints; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "initializers", function() { return exports_initializers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "layers", function() { return exports_layers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "models", function() { return exports_models; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "metrics", function() { return exports_metrics; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "regularizers", function() { return exports_regularizers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CallbackList", function() { return CallbackList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CustomCallback", function() { return CustomCallback; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "History", function() { return History; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Callback", function() { return Callback; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InputSpec", function() { return InputSpec; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SymbolicTensor", function() { return SymbolicTensor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Model", function() { return Model; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "input", function() { return input; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadModel", function() { return loadModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "model", function() { return model; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "registerCallbackConstructor", function() { return registerCallbackConstructor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sequential", function() { return sequential; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RNN", function() { return RNN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sequential", function() { return Sequential; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LayerVariable", function() { return LayerVariable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version_layers", function() { return version; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var extendStatics=function(e,t){return(extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)t.hasOwnProperty(n)&&(e[n]=t[n])})(e,t)};function __extends(e,t){function n(){this.constructor=e}extendStatics(e,t),e.prototype=null===t?Object.create(t):(n.prototype=t.prototype,new n)}var __assign=function(){return(__assign=Object.assign||function(e){for(var t,n=1,r=arguments.length;n<r;n++)for(var i in t=arguments[n])Object.prototype.hasOwnProperty.call(t,i)&&(e[i]=t[i]);return e}).apply(this,arguments)};function __awaiter(e,t,n,r){return new(n||(n=Promise))(function(i,a){function o(e){try{l(r.next(e))}catch(e){a(e)}}function s(e){try{l(r.throw(e))}catch(e){a(e)}}function l(e){e.done?i(e.value):new n(function(t){t(e.value)}).then(o,s)}l((r=r.apply(e,t||[])).next())})}function __generator(e,t){var n,r,i,a,o={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return a={next:s(0),throw:s(1),return:s(2)},"function"==typeof Symbol&&(a[Symbol.iterator]=function(){return this}),a;function s(a){return function(s){return function(a){if(n)throw new TypeError("Generator is already executing.");for(;o;)try{if(n=1,r&&(i=2&a[0]?r.return:a[0]?r.throw||((i=r.return)&&i.call(r),0):r.next)&&!(i=i.call(r,a[1])).done)return i;switch(r=0,i&&(a=[2&a[0],i.value]),a[0]){case 0:case 1:i=a;break;case 4:return o.label++,{value:a[1],done:!1};case 5:o.label++,r=a[1],a=[0];continue;case 7:a=o.ops.pop(),o.trys.pop();continue;default:if(!(i=(i=o.trys).length>0&&i[i.length-1])&&(6===a[0]||2===a[0])){o=0;continue}if(3===a[0]&&(!i||a[1]>i[0]&&a[1]<i[3])){o.label=a[1];break}if(6===a[0]&&o.label<i[1]){o.label=i[1],i=a;break}if(i&&o.label<i[2]){o.label=i[2],o.ops.push(a);break}i[2]&&o.ops.pop(),o.trys.pop();continue}a=t.call(e,o)}catch(e){a=[6,e],r=0}finally{n=i=0}if(5&a[0])throw a[1];return{value:a[0]?a[1]:void 0,done:!0}}([a,s])}}}var _epsilon=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["ENV"].get("EPSILON");function epsilon(){return _epsilon}function imageDataFormat(){return"channelsLast"}var _nextUniqueTensorId=0;function getNextUniqueTensorId(){return _nextUniqueTensorId++}var _uidPrefixes={};function getUid(e){return void 0===e&&(e=""),e in _uidPrefixes||(_uidPrefixes[e]=0),_uidPrefixes[e]+=1,e+_uidPrefixes[e].toString()}var scalarCache={float32:{},int32:{}},DEFAULT_DTYPE="float32";function getScalar(e,t){return void 0===t&&(t=DEFAULT_DTYPE),null==scalarCache[t][e]&&(scalarCache[t][e]=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"])(e,t),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["keep"])(scalarCache[t][e])),scalarCache[t][e]}var AttributeError=function(e){function t(n){var r=e.call(this,n)||this;return Object.setPrototypeOf(r,t.prototype),r}return __extends(t,e),t}(Error),RuntimeError=function(e){function t(n){var r=e.call(this,n)||this;return Object.setPrototypeOf(r,t.prototype),r}return __extends(t,e),t}(Error),ValueError=function(e){function t(n){var r=e.call(this,n)||this;return Object.setPrototypeOf(r,t.prototype),r}return __extends(t,e),t}(Error),NotImplementedError=function(e){function t(n){var r=e.call(this,n)||this;return Object.setPrototypeOf(r,t.prototype),r}return __extends(t,e),t}(Error),AssertionError=function(e){function t(n){var r=e.call(this,n)||this;return Object.setPrototypeOf(r,t.prototype),r}return __extends(t,e),t}(Error),IndexError=function(e){function t(n){var r=e.call(this,n)||this;return Object.setPrototypeOf(r,t.prototype),r}return __extends(t,e),t}(Error);function pyListRepeat(e,t){if(Array.isArray(e)){for(var n=[],r=0;r<t;r++)n=n.concat(e);return n}return(n=new Array(t)).fill(e),n}function assert(e,t){if(!e)throw new AssertionError(t)}function count(e,t){for(var n=0,r=0,i=e;r<i.length;r++){i[r]===t&&n++}return n}function singletonOrArray(e){return 1===e.length?e[0]:e}function toList(e){return Array.isArray(e)?e:[e]}function toSnakeCase(e){var t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==t[0]?t:"private"+t}function toCamelCase(e){return e.length<=1?e:-1===e.indexOf("_")?e:e.replace(/[_]+(\w|$)/g,function(e,t){return t.toUpperCase()})}var _GLOBAL_CUSTOM_OBJECTS={};function serializeKerasObject(e){return null===e||void 0===e?null:{className:e.getClassName(),config:e.getConfig()}}function deserializeKerasObject(e,t,n,r){if(void 0===t&&(t={}),void 0===n&&(n={}),void 0===r&&(r="object"),"string"==typeof e){var i=e,a=void 0;if(i in n)a=n[i];else if(i in _GLOBAL_CUSTOM_OBJECTS)a=_GLOBAL_CUSTOM_OBJECTS[i];else if(null==(a=t[i]))throw new ValueError("Unknown "+r+": "+e+". This may be due to one of the following reasons:\n1. The "+r+" is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom "+r+" is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().");return a}var o=e;if(null==o.className||null==o.config)throw new ValueError(r+": Improper config format: "+JSON.stringify(o)+".\n'className' and 'config' must set.");var s=o.className,l=void 0,u=void 0;if(s in n?(l=(S=n.get(s))[0],u=S[1]):s in _GLOBAL_CUSTOM_OBJECTS?(l=(I=_GLOBAL_CUSTOM_OBJECTS.className)[0],u=I[1]):s in t&&(l=(N=t[s])[0],u=N[1]),null==l)throw new ValueError("Unknown "+r+": "+s+". This may be due to one of the following reasons:\n1. The "+r+" is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom "+r+" is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().");if(null!=u){for(var c={},p=0,h=Object.keys(_GLOBAL_CUSTOM_OBJECTS);p<h.length;p++){c[v=h[p]]=_GLOBAL_CUSTOM_OBJECTS[v]}for(var d=0,f=Object.keys(n);d<f.length;d++){c[v=f[d]]=n[v]}o.config.customObjects=c;for(var g=__assign({},_GLOBAL_CUSTOM_OBJECTS),m=0,y=Object.keys(n);m<y.length;m++){var v=y[m];_GLOBAL_CUSTOM_OBJECTS[v]=n[v]}var b=u(l,o.config);return _GLOBAL_CUSTOM_OBJECTS=__assign({},g),b}g=__assign({},_GLOBAL_CUSTOM_OBJECTS);for(var w=0,z=Object.keys(n);w<z.length;w++){v=z[w];_GLOBAL_CUSTOM_OBJECTS[v]=n[v]}var S,I,N;b=new l(o.config);return _GLOBAL_CUSTOM_OBJECTS=__assign({},g),b}function numberCompare(e,t){return e<t?-1:e>t?1:0}function reverseNumberCompare(e,t){return-1*numberCompare(e,t)}function stringToDType(e){switch(e){case"float32":return"float32";default:throw new ValueError("Invalid dtype: "+e)}}function unique(e){if(null==e)return e;for(var t=[],n=0,r=e;n<r.length;n++){var i=r[n];-1===t.indexOf(i)&&t.push(i)}return t}function isObjectEmpty(e){if(null==e)throw new ValueError("Invalid value in obj: "+JSON.stringify(e));for(var t in e)if(e.hasOwnProperty(t))return!1;return!0}function checkStringTypeUnionValue(e,t,n){if(null!=n&&e.indexOf(n)<0)throw new ValueError(n+" is not a valid "+t+".  Valid values are "+e+" or null/undefined.")}function checkArrayTypeAndLength(e,t,n,r){return void 0===n&&(n=0),void 0===r&&(r=1/0),assert(n>=0),assert(r>=n),Array.isArray(e)&&e.length>=n&&e.length<=r&&e.every(function(e){return typeof e===t})}function calcL2Norms(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sum"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mulStrict"])(e,e),t,!0))})}var Constraint=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.getConfig=function(){return{}},t}(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].Serializable),MaxNorm=function(e){function t(t){var n=e.call(this)||this;return n.defaultMaxValue=2,n.defaultAxis=0,n.maxValue=null!=t.maxValue?t.maxValue:n.defaultMaxValue,n.axis=null!=t.axis?t.axis:n.defaultAxis,n}return __extends(t,e),t.prototype.apply=function(e){var t=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=calcL2Norms(e,t.axis),r=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clipByValue"])(n,0,t.maxValue);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(e,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"])(r,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(getScalar(epsilon()),n)))})},t.prototype.getConfig=function(){return{maxValue:this.maxValue,axis:this.axis}},t.className="MaxNorm",t}(Constraint);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(MaxNorm);var UnitNorm=function(e){function t(t){var n=e.call(this)||this;return n.defaultAxis=0,n.axis=null!=t.axis?t.axis:n.defaultAxis,n}return __extends(t,e),t.prototype.apply=function(e){var t=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"])(e,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(getScalar(epsilon()),calcL2Norms(e,t.axis)))})},t.prototype.getConfig=function(){return{axis:this.axis}},t.className="UnitNorm",t}(Constraint);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(UnitNorm);var NonNeg=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.apply=function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["relu"])(e)},t.className="NonNeg",t}(Constraint);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(NonNeg);var MinMaxNorm=function(e){function t(t){var n=e.call(this)||this;return n.defaultMinValue=0,n.defaultMaxValue=1,n.defaultRate=1,n.defaultAxis=0,n.minValue=null!=t.minValue?t.minValue:n.defaultMinValue,n.maxValue=null!=t.maxValue?t.maxValue:n.defaultMaxValue,n.rate=null!=t.rate?t.rate:n.defaultRate,n.axis=null!=t.axis?t.axis:n.defaultAxis,n}return __extends(t,e),t.prototype.apply=function(e){var t=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=calcL2Norms(e,t.axis),r=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(getScalar(t.rate),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clipByValue"])(n,t.minValue,t.maxValue)),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(getScalar(1-t.rate),n));return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(e,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"])(r,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(getScalar(epsilon()),n)))})},t.prototype.getConfig=function(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}},t.className="MinMaxNorm",t}(Constraint);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(MinMaxNorm);var CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function serializeConstraint(e){return serializeKerasObject(e)}function deserializeConstraint(e,t){return void 0===t&&(t={}),deserializeKerasObject(e,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].SerializationMap.getMap().classNameMap,t,"constraint")}function getConstraint(e){return null==e?null:"string"==typeof e?deserializeConstraint({className:e in CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP?CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP[e]:e,config:{}}):e instanceof Constraint?e:deserializeConstraint(e)}function maxNorm(e){return new MaxNorm(e)}function unitNorm(e){return new UnitNorm(e)}function nonNeg(){return new NonNeg}function minMaxNorm(e){return new MinMaxNorm(e)}var exports_constraints=Object.freeze({maxNorm:maxNorm,unitNorm:unitNorm,nonNeg:nonNeg,minMaxNorm:minMaxNorm}),nameMap=new Map,VALID_DATA_FORMAT_VALUES=["channelsFirst","channelsLast"];function checkDataFormat(e){checkStringTypeUnionValue(VALID_DATA_FORMAT_VALUES,"DataFormat",e)}var VALID_PADDING_MODE_VALUES=["valid","same","causal"];function checkPaddingMode(e){checkStringTypeUnionValue(VALID_PADDING_MODE_VALUES,"PaddingMode",e)}var VALID_POOL_MODE_VALUES=["max","avg"];function checkPoolMode(e){checkStringTypeUnionValue(VALID_POOL_MODE_VALUES,"PoolMode",e)}var _nameScopeStack=[],_nameScopeDivider="/";function nameScope(e,t){_nameScopeStack.push(e);try{var n=t();return _nameScopeStack.pop(),n}catch(e){throw _nameScopeStack.pop(),e}}function currentNameScopePrefix(){return 0===_nameScopeStack.length?"":_nameScopeStack.join(_nameScopeDivider)+_nameScopeDivider}function getScopedTensorName(e){if(!isValidTensorName(e))throw new Error("Not a valid tensor name: '"+e+"'");return currentNameScopePrefix()+e}function getUniqueTensorName(e){if(!isValidTensorName(e))throw new Error("Not a valid tensor name: '"+e+"'");nameMap.has(e)||nameMap.set(e,0);var t=nameMap.get(e);if(nameMap.set(e,nameMap.get(e)+1),t>0){var n=e+"_"+t;return nameMap.set(n,1),n}return e}var tensorNameRegex=new RegExp(/^[A-Za-z][-A-Za-z0-9\._\/]*$/);function isValidTensorName(e){return!!e.match(tensorNameRegex)}function isInteger(e){return e===parseInt(e.toString(),10)}function arrayProd(e,t,n){null==t&&(t=0),null==n&&(n=e.length);for(var r=1,i=t;i<n;++i)r*=e[i];return r}function toArray1D(e){return e=Array.isArray(e)?new Float32Array(e):e,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor1d"])(e)}function min$1(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["min"])(toArray1D(e)).dataSync()[0]}function max$1(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["max"])(toArray1D(e)).dataSync()[0]}function range(e,t){if(t<e)throw new ValueError("end ("+t+") < begin ("+e+") is forbidden.");for(var n=[],r=e;r<t;++r)n.push(r);return n}function cast$1(e,t){return e.asType(t)}function expandDims(e,t){void 0===t&&(t=-1);var n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),e.reshape(n)}function repeat(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(2!==e.shape.length)throw new ValueError("repeat() expects a rank-2 tensor, but received a rank-"+e.shape.length+" tensor.");return tile$1(expandDims(e,1),[1,t,1])})}function flatten(e){var t=[arrayProd(e.shape)];return e.reshape(t)}function batchFlatten(e){if(e.rank<=1)throw new ValueError("batchFlatten requires a minimum rank of 2. Got rank: "+e.rank+".");var t=[e.shape[0],arrayProd(e.shape,1)];return e.reshape(t)}function sliceAlongFirstAxis(e,t,n){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){switch(e.rank){case 1:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice1d"])(e,t,n);case 2:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice2d"])(e,[t,0],[n,e.shape[1]]);case 3:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice3d"])(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice4d"])(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);default:throw new ValueError("sliceAlongFirstAxis() received an unsupported tensor rank: "+e.rank)}})}function sliceAlongLastAxis(e,t,n){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){switch(e.rank){case 1:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice1d"])(e,t,n);case 2:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice2d"])(e,[0,t],[e.shape[0],n]);case 3:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice3d"])(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice4d"])(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new ValueError("sliceAlongLastAxis() received an unsupported tensor rank: "+e.rank)}})}function sliceAlongAxis(e,t,n,r){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){switch(e.rank){case 1:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice1d"])(e,t,n);case 2:switch(r){case 1:return sliceAlongFirstAxis(e,t,n);case 2:return sliceAlongLastAxis(e,t,n);default:throw new ValueError("The axis is not within the rank of the tensor "+r)}case 3:switch(r){case 1:return sliceAlongFirstAxis(e,t,n);case 2:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice3d"])(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return sliceAlongLastAxis(e,t,n);default:throw new ValueError("The axis is not within the rank of the tensor "+r)}case 4:switch(r){case 1:return sliceAlongFirstAxis(e,t,n);case 2:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice4d"])(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice4d"])(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return sliceAlongLastAxis(e,t,n);default:throw new ValueError("The axis is not within the rank of the tensor "+r)}default:throw new ValueError("sliceAlongLastAxis() received an unsupported tensor rank: "+e.rank)}})}function concatenate(e,t){var n;return void 0===t&&(t=-1),t<0&&(t=0!==(n=e[0].rank)?n:0),t===e[0].rank&&(t=-1),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["concat"])(e,t)}function concatAlongFirstAxis(e,t){switch(e.rank){case 1:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["concat1d"])([e,t]);case 2:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["concat2d"])([e,t],0);case 3:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["concat3d"])([e,t],0);case 4:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["concat4d"])([e,t],0);default:throw new ValueError("concatAlongFirstAxis() received an unsupported tensor rank: "+e.rank)}}function tile$1(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new ValueError("The length of input n ("+t.length+") does not match the number of dimensions in input x ("+e.rank+")");return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tile"])(e,t)}function randomNormal$1(e,t,n,r,i){return void 0===t&&(t=0),void 0===n&&(n=1),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["randomNormal"])(e,t,n,r,i)}function dot(e,t){if(e.rank<2||t.rank<2)throw new NotImplementedError("dot requires both inputs to be rank >= 2 but got x shape = "+e.shape+" and y shape = "+t.shape);if(t.rank>=3&&(r=e.shape.slice(-1)[0])!==(o=t.shape.slice(-2)[0]))throw new NotImplementedError("If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = "+e.shape+" and  y shape = "+t.shape);if(2===e.rank&&2===t.rank)return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["matMul"])(e,t);var n=e.shape.slice(),r=n.pop();e=e.reshape([-1,r]);var i=t.shape.slice(),a=i.pop(),o=i.pop(),s=i.concat([a]),l=Array.from({length:t.rank},function(e,n){return 0===n?t.rank-2:n<=t.rank-2?n-1:n});t=t.transpose(l).reshape([o,-1]);var u=n.concat(s);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["matMul"])(e,t).reshape(u)}function gather$1(e,t,n){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return t=Array.isArray(t)?Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor1d"])(t,"int32"):t.toInt(),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["gather"])(e,t,n)})}function square(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mulStrict"])(e,e)}function biasAdd(e,t,n){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(null==n&&(n=imageDataFormat()),checkDataFormat(n),1!==t.rank&&t.rank!==e.rank)throw new ValueError("Unexpected bias dimensions: "+t.rank+"; expected it to be 1 or "+e.rank);var r,i=t.shape;if(5===e.rank)"channelsFirst"===n?r=1===i.length?e.add(t.reshape([1,i[0],1,1,1])):e.add(t.reshape([1,i[3],i[0],i[1],i[2]])):"channelsLast"===n&&(r=1===i.length?e.add(t.reshape([1,1,1,1,i[0]])):e.add(t.reshape([1].concat(i))));else if(4===e.rank)"channelsFirst"===n?r=1===i.length?e.add(t.reshape([1,i[0],1,1])):e.add(t.reshape([1,i[2],i[0],i[1]])):"channelsLast"===n&&(r=1===i.length?e.add(t.reshape([1,1,1,i[0]])):e.add(t.reshape([1].concat(i))));else if(3===e.rank)"channelsFirst"===n?r=1===i.length?e.add(t.reshape([1,i[0],1])):e.add(t.reshape([1,i[1],i[0]])):"channelsLast"===n&&(r=1===i.length?e.add(t.reshape([1,1,i[0]])):e.add(t.reshape([1].concat(i))));else{if(!(e.rank<3))throw new ValueError("Unsupported input rank by biasAdd: "+e.rank);r=e.add(t)}return r})}function elu$1(e,t){if(void 0===t&&(t=1),1!==t)throw new NotImplementedError("Support for alpha values other than 1 ("+t+") is not implemented yet.");return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["elu"])(e)}function softsign(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"])(e,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(getScalar(1),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["abs"])(e)))})}function dropout(e,t,n,r){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(null!=n&&!_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].arraysEqual(e.shape,n))throw new NotImplementedError("Non-default noise shape is not implemented yet: "+JSON.stringify(n));if(null!=r)throw new NotImplementedError("seed is not implemented for dropout yet.");var i=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["step"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["neg"])(t),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["randomUniform"])(e.shape,0,1,"float32")));return i=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"])(getScalar(1),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"])(getScalar(1),t)),i),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(e,i)})}function hardSigmoid(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(getScalar(.5),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(getScalar(.2),e));return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clipByValue"])(t,0,1)})}function inTrainPhase(e,t,n){return void 0===n&&(n=!1),n?e():t()}var VALID_FAN_MODE_VALUES=["fanIn","fanOut","fanAvg"];function checkFanMode(e){checkStringTypeUnionValue(VALID_FAN_MODE_VALUES,"FanMode",e)}var VALID_DISTRIBUTION_VALUES=["normal","uniform"];function checkDistribution(e){checkStringTypeUnionValue(VALID_DISTRIBUTION_VALUES,"Distribution",e)}var Initializer=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.fromConfigUsesCustomObjects=function(){return!1},t.prototype.getConfig=function(){return{}},t}(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].Serializable),Zeros=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.apply=function(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["zeros"])(e,t)},t.className="Zeros",t}(Initializer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Zeros);var Ones=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.apply=function(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["ones"])(e,t)},t.className="Ones",t}(Initializer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Ones);var Constant=function(e){function t(t){var n=e.call(this)||this;if("object"!=typeof t)throw new ValueError("Expected argument of type ConstantConfig but got "+t);if(void 0===t.value)throw new ValueError("config must have value set but got "+t);return n.value=t.value,n}return __extends(t,e),t.prototype.apply=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"])(n.value),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["ones"])(e,t))})},t.prototype.getConfig=function(){return{value:this.value}},t.className="Constant",t}(Initializer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Constant);var RandomUniform=function(e){function t(t){var n=e.call(this)||this;return n.DEFAULT_MINVAL=-.05,n.DEFAULT_MAXVAL=.05,n.minval=t.minval||n.DEFAULT_MINVAL,n.maxval=t.maxval||n.DEFAULT_MAXVAL,n.seed=t.seed,n}return __extends(t,e),t.prototype.apply=function(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["randomUniform"])(e,this.minval,this.maxval,t)},t.prototype.getConfig=function(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}},t.className="RandomUniform",t}(Initializer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(RandomUniform);var RandomNormal=function(e){function t(t){var n=e.call(this)||this;return n.DEFAULT_MEAN=0,n.DEFAULT_STDDEV=.05,n.mean=t.mean||n.DEFAULT_MEAN,n.stddev=t.stddev||n.DEFAULT_STDDEV,n.seed=t.seed,n}return __extends(t,e),t.prototype.apply=function(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new NotImplementedError("randomNormal does not support dType "+t+".");return randomNormal$1(e,this.mean,this.stddev,t,this.seed)},t.prototype.getConfig=function(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}},t.className="RandomNormal",t}(Initializer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(RandomNormal);var TruncatedNormal=function(e){function t(t){var n=e.call(this)||this;return n.DEFAULT_MEAN=0,n.DEFAULT_STDDEV=.05,n.mean=t.mean||n.DEFAULT_MEAN,n.stddev=t.stddev||n.DEFAULT_STDDEV,n.seed=t.seed,n}return __extends(t,e),t.prototype.apply=function(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new NotImplementedError("truncatedNormal does not support dType "+t+".");return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["truncatedNormal"])(e,this.mean,this.stddev,t,this.seed)},t.prototype.getConfig=function(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}},t.className="TruncatedNormal",t}(Initializer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(TruncatedNormal);var Identity=function(e){function t(t){var n=e.call(this)||this;return n.gain=null!=t.gain?Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"])(t.gain):getScalar(1),n}return __extends(t,e),t.prototype.apply=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(2!==e.length||e[0]!==e[1])throw new ValueError("Identity matrix initializer can only be used for 2D square matrices.");return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(n.gain,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["eye"])(e[0]))})},t.prototype.getConfig=function(){return{gain:this.gain.get()}},t.className="Identity",t}(Initializer);function computeFans(e,t){var n,r;if(void 0===t&&(t="channelsLast"),checkDataFormat(t),2===e.length)n=e[0],r=e[1];else if(-1!==[3,4,5].indexOf(e.length)){if("channelsFirst"===t){var i=arrayProd(e,2);n=e[1]*i,r=e[0]*i}else if("channelsLast"===t){i=arrayProd(e,0,e.length-2);n=e[e.length-2]*i,r=e[e.length-1]*i}}else{var a=arrayProd(e);n=Math.sqrt(a),r=Math.sqrt(a)}return[n,r]}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Identity);var VarianceScaling=function(e){function t(t){var n=e.call(this)||this;if(t.scale<0)throw new ValueError("scale must be a positive float. Got: "+t.scale);return n.scale=null==t.scale?1:t.scale,n.mode=t.mode,checkFanMode(n.mode),n.distribution=t.distribution,checkDistribution(n.distribution),n.seed=t.seed,n}return __extends(t,e),t.prototype.apply=function(e,t){var n=computeFans(e),r=n[0],i=n[1],a=this.scale;if("fanIn"===this.mode?a/=Math.max(1,r):"fanOut"===this.mode?a/=Math.max(1,i):a/=Math.max(1,(r+i)/2),"normal"===this.distribution){var o=Math.sqrt(a);if("float32"!==(t=t||"float32")&&"int32"!==t)throw new NotImplementedError(this.getClassName()+" does not support dType "+t+".");return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["truncatedNormal"])(e,0,o,t,this.seed)}var s=Math.sqrt(3*a);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["randomUniform"])(e,-s,s,t)},t.prototype.getConfig=function(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}},t.className="VarianceScaling",t}(Initializer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(VarianceScaling);var GlorotUniform=function(e){function t(t){return e.call(this,{scale:1,mode:"fanAvg",distribution:"uniform",seed:null==t?null:t.seed})||this}return __extends(t,e),t.prototype.getClassName=function(){return VarianceScaling.className},t.className="GlorotUniform",t}(VarianceScaling);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(GlorotUniform);var GlorotNormal=function(e){function t(t){return e.call(this,{scale:1,mode:"fanAvg",distribution:"normal",seed:null==t?null:t.seed})||this}return __extends(t,e),t.prototype.getClassName=function(){return VarianceScaling.className},t.className="GlorotNormal",t}(VarianceScaling);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(GlorotNormal);var HeNormal=function(e){function t(t){return e.call(this,{scale:2,mode:"fanIn",distribution:"normal",seed:null==t?null:t.seed})||this}return __extends(t,e),t.prototype.getClassName=function(){return VarianceScaling.className},t.className="HeNormal",t}(VarianceScaling);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(HeNormal);var LeCunNormal=function(e){function t(t){return e.call(this,{scale:1,mode:"fanIn",distribution:"normal",seed:null==t?null:t.seed})||this}return __extends(t,e),t.prototype.getClassName=function(){return VarianceScaling.className},t.className="LeCunNormal",t}(VarianceScaling);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(LeCunNormal);var Orthogonal=function(e){function t(t){var n=e.call(this)||this;if(n.DEFAULT_GAIN=1,n.gain=null==t.gain?n.DEFAULT_GAIN:t.gain,n.seed=t.seed,null!=n.seed)throw new NotImplementedError("Random seed is not implemented for Orthogonal Initializer yet.");return n}return __extends(t,e),t.prototype.apply=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(2!==e.length)throw new NotImplementedError("The Orthogonal Initializer does not support non-2D shapes yet.");e[0]*e[1]>2e3&&console.warn("Orthogonal initializer is being called on a matrix with more than 2000 ("+e[0]*e[1]+") elements: Slowness may result.");var t=randomNormal$1(e[0]>e[1]?[e[1],e[0]]:e,0,1,"float32"),r=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["linalg"].gramSchmidt(t);return e[0]>e[1]&&(r=r.transpose()),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(getScalar(n.gain),r)})},t.prototype.getConfig=function(){return{gain:this.gain,seed:this.seed}},t.className="Orthogonal",t}(Initializer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Orthogonal);var INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",identity:"Identity",leCunNormal:"LeCunNormal",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function deserializeInitializer(e,t){return void 0===t&&(t={}),deserializeKerasObject(e,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].SerializationMap.getMap().classNameMap,t,"initializer")}function serializeInitializer(e){return serializeKerasObject(e)}function getInitializer(e){if("string"==typeof e){var t=e in INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP?INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP[e]:e;return"GlorotUniform"===t?new GlorotUniform:"GlorotNormal"===t?new GlorotNormal:"HeNormal"===t?new HeNormal:"LeCunNormal"===t?new LeCunNormal:deserializeInitializer({className:t,config:{}})}return e instanceof Initializer?e:deserializeInitializer(e)}function zeros$1(){return new Zeros}function ones$1(){return new Ones}function constant(e){return new Constant(e)}function randomUniform$1(e){return new RandomUniform(e)}function randomNormal$2(e){return new RandomNormal(e)}function truncatedNormal$1(e){return new TruncatedNormal(e)}function identity(e){return new Identity(e)}function varianceScaling(e){return new VarianceScaling(e)}function glorotUniform(e){return new GlorotUniform(e)}function glorotNormal(e){return new GlorotNormal(e)}function heNormal(e){return new HeNormal(e)}function leCunNormal(e){return new LeCunNormal(e)}function orthogonal(e){return new Orthogonal(e)}var exports_initializers=Object.freeze({zeros:zeros$1,ones:ones$1,constant:constant,randomUniform:randomUniform$1,randomNormal:randomNormal$2,truncatedNormal:truncatedNormal$1,identity:identity,varianceScaling:varianceScaling,glorotUniform:glorotUniform,glorotNormal:glorotNormal,heNormal:heNormal,leCunNormal:leCunNormal,orthogonal:orthogonal});function isArrayOfShapes(e){return Array.isArray(e)&&Array.isArray(e[0])}function normalizeShapeList(e){return 0===e.length?[]:Array.isArray(e[0])?e:[e]}function getExactlyOneTensor(e){var t;if(Array.isArray(e)){if(1!==e.length)throw new ValueError("Expected Tensor length to be 1; got "+e.length);t=e[0]}else t=e;return t}function getExactlyOneShape(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(1===e.length)return(e=e)[0];throw new ValueError("Expected exactly 1 Shape; got "+e.length)}return e}function countParamsInWeights(e){for(var t=0,n=0,r=e;n<r.length;n++){var i=r[n];0===i.shape.length?t+=1:t+=i.shape.reduce(function(e,t){return e*t})}return t}var DEFAULT_VARIABLE_NAME_PREFIX="Variable",LayerVariable=function(){function e(e,t,n,r,i){void 0===t&&(t="float32"),void 0===n&&(n=DEFAULT_VARIABLE_NAME_PREFIX),void 0===r&&(r=!0),void 0===i&&(i=null),this.dtype=null==t?"float32":t,this.shape=e.shape,this.id=getNextUniqueTensorId(),n=null==n?DEFAULT_VARIABLE_NAME_PREFIX:n,this.originalName=getScopedTensorName(n),this.name=getUniqueTensorName(this.originalName),this.trainable=r,this.constraint=i,this.val=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["variable"])(e,this.trainable,this.name,this.dtype)}return e.prototype.read=function(){return this.assertNotDisposed(),this.val},e.prototype.write=function(e){return this.assertNotDisposed(),checkShapesMatch(this.val,e),this.val.id!==e.id&&(this.val.assign(e),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this},e.prototype.dispose=function(){this.assertNotDisposed(),this.val.dispose()},e.prototype.assertNotDisposed=function(){if(this.val.isDisposed)throw new Error("LayersVariable "+this.name+" is already disposed.")},e}();function checkShapesMatch(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}function batchGetValue(e){return e.map(function(e){return e.read()})}function batchSetValue(e){e.map(function(e){e[0].write(e[1])})}var InputSpec=function(){return function(e){this.dtype=e.dtype,this.shape=e.shape,null!=e.shape?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}(),SymbolicTensor=function(){return function(e,t,n,r,i,a,o){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=r,this.callArgs=i,this.outputTensorIndex=o,this.id=getNextUniqueTensorId(),null!=a&&(this.originalName=getScopedTensorName(a),this.name=getUniqueTensorName(this.originalName)),this.rank=t.length}}(),_nextNodeID=0,Node=function(){function e(e,t){this.callArgs=t,this.id=_nextNodeID++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(var n=0,r=e.inboundLayers;n<r.length;n++){var i=r[n];null!=i&&i.outboundNodes.push(this)}e.outboundLayer.inboundNodes.push(this)}return e.prototype.getConfig=function(){for(var e=[],t=0,n=this.inboundLayers;t<n.length;t++){var r=n[t];null!=r?e.push(r.name):e.push(null)}return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}},e}(),_nextLayerID=0,Layer=function(e){function t(t){var n=e.call(this)||this;n._callHook=null,n._addedWeightNames=[],n._stateful=!1,n.id=_nextLayerID++,n.activityRegularizer=null,n.inputSpec=null,n.supportsMasking=!1,n._trainableWeights=[],n._nonTrainableWeights=[],n._losses=[],n._updates=[],n._built=!1,n.inboundNodes=[],n.outboundNodes=[];var r=t.name;if(!r){var i=n.getClassName();r=toSnakeCase(i)+"_"+getUid(i)}if(n.name=r,n.trainable=null==t.trainable||t.trainable,n.updatable=null==t.updatable||t.updatable,null!=t.inputShape||null!=t.batchInputShape){var a=void 0;if(null!=t.batchInputShape)a=t.batchInputShape;else if(null!=t.inputShape){var o=null;null!=t.batchSize&&(o=t.batchSize),a=[o].concat(t.inputShape)}n.batchInputShape=a;var s=t.dtype;null==s&&(s=t.inputDType),null==s&&(s="float32"),n.dtype=s}return null!=t.weights?n.initialWeights=t.weights:n.initialWeights=null,n._refCount=null,n}return __extends(t,e),t.nodeKey=function(e,t){return e.name+"_ib-"+t.toString()},t.prototype.getNodeAtIndex=function(e,t){if(0===this.inboundNodes.length)throw new RuntimeError("The layer has never been called and thus has no defined "+t+".");if(this.inboundNodes.length<=e)throw new ValueError("Asked to get "+t+" at node "+e+", but the layer has only "+this.inboundNodes.length+" inbound nodes.");return this.inboundNodes[e]},t.prototype.getInputAt=function(e){return singletonOrArray(this.getNodeAtIndex(e,"input").inputTensors)},t.prototype.getOutputAt=function(e){return singletonOrArray(this.getNodeAtIndex(e,"output").outputTensors)},Object.defineProperty(t.prototype,"input",{get:function(){if(this.inboundNodes.length>1)throw new AttributeError("Layer "+this.name+' has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use `getInputAt(nodeIndex)` instead.');if(0===this.inboundNodes.length)throw new AttributeError("Layer "+this.name+" is not connected, no input to return.");return singletonOrArray(this.getNodeAtIndex(0,"input").inputTensors)},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"output",{get:function(){if(0===this.inboundNodes.length)throw new AttributeError("Layer "+this.name+" has no inbound nodes.");if(this.inboundNodes.length>1)throw new AttributeError("Layer "+this.name+' has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use `getOutputAt(nodeIndex)` instead.');return singletonOrArray(this.getNodeAtIndex(0,"output").outputTensors)},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"losses",{get:function(){return this._losses},enumerable:!0,configurable:!0}),t.prototype.calculateLosses=function(){return this.losses.map(function(e){return e()})},Object.defineProperty(t.prototype,"updates",{get:function(){return this._updates},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"built",{get:function(){return this._built},set:function(e){this._built=e},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"trainableWeights",{get:function(){return this.trainable?this._trainableWeights:[]},set:function(e){this._trainableWeights=e},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"nonTrainableWeights",{get:function(){return this.trainable?this._nonTrainableWeights:this._trainableWeights.concat(this._nonTrainableWeights)},set:function(e){this._nonTrainableWeights=e},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"weights",{get:function(){return this.trainableWeights.concat(this.nonTrainableWeights)},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"stateful",{get:function(){return this._stateful},enumerable:!0,configurable:!0}),t.prototype.resetStates=function(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")},t.prototype.assertInputCompatibility=function(e){if(e=toList(e),null!=this.inputSpec&&0!==this.inputSpec.length){var t=toList(this.inputSpec);if(e.length!==t.length)throw new ValueError("Layer "+this.name+" expects "+t.length+" inputs, but it received "+e.length+" input tensors. Input received: "+e);for(var n=0;n<e.length;n++){var r=e[n],i=t[n];if(null!=i){var a=r.rank;if(null!=i.ndim&&a!==i.ndim)throw new ValueError("Input "+n+" is incompatible with layer "+this.name+": expected ndim="+i.ndim+", found ndim="+a);if(null!=i.maxNDim&&a>i.maxNDim)throw new ValueError("Input "+n+" is incompatible with layer "+this.name+": expected max_ndim="+i.maxNDim+", found ndim="+a);if(null!=i.minNDim&&a<i.minNDim)throw new ValueError("Input "+n+" is incompatible with layer "+this.name+": expected min_ndim="+i.minNDim+", found ndim="+a+".");if(null!=i.dtype&&r.dtype!==i.dtype)throw new ValueError("Input "+n+" is incompatible with layer "+this.name+" : expected dtype="+i.dtype+", found dtype="+r.dtype+".");if(i.axes){var o=r.shape;for(var s in i.axes){var l=Number(s),u=i.axes[s],c=l>=0?o[l]:o[o.length+l];if(null!=u&&-1===[u,null].indexOf(c))throw new ValueError("Input "+n+" is incompatible with layer "+this.name+": expected axis "+l+" of input shape to have value "+u+" but got shape "+o+".")}}if(null!=i.shape)for(var p=0;p<i.shape.length;++p){var h=i.shape[p],d=r.shape[p];if(null!=h&&null!=d&&h!==d)throw new ValueError("Input "+n+" is incompatible with layer "+this.name+": expected shape="+i.shape+", found shape=${xShape}.")}}}}},t.prototype.call=function(e,t){return e},t.prototype.invokeCallHook=function(e,t){null!=this._callHook&&this._callHook(e,t)},t.prototype.setCallHook=function(e){this._callHook=e},t.prototype.clearCallHook=function(){this._callHook=null},t.prototype.apply=function(e,t){var n=this;t=t||{},this.assertNotDisposed();for(var r=toList(e),i=!0,a=0,o=r;a<o.length;a++){if(!(o[a]instanceof SymbolicTensor)){i=!1;break}}for(var s=!0,l=0,u=r;l<u.length;l++){if(u[l]instanceof SymbolicTensor){s=!1;break}}if(i===s)throw new ValueError("Arguments to apply() must be all SymbolicTensors or all Tensors");return nameScope(this.name,function(){if(!n.built){n.assertInputCompatibility(e);for(var i=[],a=0,o=toList(e);a<o.length;a++){var l=o[a];i.push(l.shape)}n.build(singletonOrArray(i)),n.built=!0,n.initialWeights&&n.setWeights(n.initialWeights),null===n._refCount&&s&&(n._refCount=1)}if(n.assertInputCompatibility(e),s){for(var u=[],c=0,p=toList(g=n.call(e,t));c<p.length;c++){var h=p[c];-1!==r.indexOf(h)&&(h=h.clone()),u.push(h)}if(g=singletonOrArray(u),null!=n.activityRegularizer)throw new NotImplementedError("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return g}var d=collectInputShape(e),f=n.computeOutputShape(d),g=void 0,m=guessOutputDType(e);if(n.warnOnIncompatibleInputShape(Array.isArray(e)?d[0]:d),g=null!=f&&f.length>0&&Array.isArray(f[0])?f.map(function(r,i){return new SymbolicTensor(m,r,n,toList(e),t,n.name,i)}):new SymbolicTensor(m,f,n,toList(e),t,n.name),n.addInboundNode(e,g,null,null,d,f,t),n._refCount++,null!=n.activityRegularizer)throw new NotImplementedError("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return g})},t.prototype.warnOnIncompatibleInputShape=function(e){if(null!=this.batchInputShape)if(e.length!==this.batchInputShape.length)console.warn("The rank of the input tensor provided (shape: "+JSON.stringify(e)+") does not match that of the batchInputShape ("+JSON.stringify(this.batchInputShape)+") of the layer "+this.name);else{var t=!1;this.batchInputShape.forEach(function(n,r){null!=n&&null!=e[r]&&e[r]!==n&&(t=!0)}),t&&console.warn("The shape of the input tensor ("+JSON.stringify(e)+") does not match the expectation of layer "+this.name+": "+JSON.stringify(this.batchInputShape))}},Object.defineProperty(t.prototype,"outputShape",{get:function(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new AttributeError("The layer "+this.name+" has never been called and thus has no defined output shape.");for(var e=[],t=0,n=this.inboundNodes;t<n.length;t++){var r=n[t],i=JSON.stringify(r.outputShapes);-1===e.indexOf(i)&&e.push(i)}if(1===e.length){var a=this.inboundNodes[0].outputShapes;return Array.isArray(a)&&Array.isArray(a[0])&&1===a.length?a[0]:a}throw new AttributeError("The layer "+this.name+' has multiple inbound nodes with different output shapes. Hence the notion of "outut shape" is ill-defined for the layer.')},enumerable:!0,configurable:!0}),t.prototype.countParams=function(){if(!this.built)throw new RuntimeError("You tried to call countParams() on "+this.name+", but the layer is not built yet. Build it first by calling build(batchInputShape).");return countParamsInWeights(this.weights)},t.prototype.build=function(e){this.built=!0},t.prototype.getWeights=function(e){return void 0===e&&(e=!1),batchGetValue(e?this.trainableWeights:this.weights)},t.prototype.setWeights=function(e){var t=this;Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=t.weights;if(n.length!==e.length)throw new ValueError('You called setWeights(weights) on layer "'+t.name+'" with a weight list of length '+e.length+", but the layer was expecting "+n.length+" weights. Provided weights: "+e+"...");if(0!==n.length){for(var r=[],i=batchGetValue(n),a=0;a<i.length;++a){var o=i[a],s=n[a],l=e[a];if(!_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].arraysEqual(o.shape,l.shape))throw new ValueError("Layer weight shape "+o.shape+" not compatible with provided weight shape "+l.shape);r.push([s,l])}batchSetValue(r)}})},t.prototype.addWeight=function(e,t,n,r,i,a,o){if(-1!==this._addedWeightNames.indexOf(e))throw new ValueError("Duplicate weight name "+e+" for layer "+this.name);this._addedWeightNames.push(e),null==n&&(n="float32");var s=new LayerVariable(r.apply(t,n),n,e,a,o);return null!=i&&this.addLoss(function(){return i.apply(s.read())}),null==a&&(a=!0),a?this._trainableWeights.push(s):this._nonTrainableWeights.push(s),s},t.prototype.addLoss=function(e){var t;null==e||Array.isArray(e)&&0===e.length||(e=toList(e),void 0!==this._losses&&null!==this._losses&&(t=this.losses).push.apply(t,e))},t.prototype.computeOutputShape=function(e){return e},t.prototype.computeMask=function(e,t){var n=this;if(!this.supportsMasking){if(null!=t){if(!Array.isArray(t))throw new TypeError("Layer "+this.name+" does not support masking,but was passed an inputMask.");t.forEach(function(e){if(null!=e)throw new TypeError("Layer "+n.name+" does not support masking,but was passed an inputMask.")})}return null}return t},t.prototype.addInboundNode=function(e,t,n,r,i,a,o){void 0===o&&(o=null);var s=toList(e);t=toList(t),n=toList(n),r=toList(r),i=normalizeShapeList(i),a=normalizeShapeList(a);for(var l=[],u=[],c=[],p=0,h=s;p<h.length;p++){var d=h[p];l.push(d.sourceLayer),u.push(d.nodeIndex),c.push(d.tensorIndex)}new Node({outboundLayer:this,inboundLayers:l,nodeIndices:u,tensorIndices:c,inputTensors:s,outputTensors:t,inputMasks:n,outputMasks:r,inputShapes:i,outputShapes:a},o);for(var f=0;f<t.length;f++)t[f].sourceLayer=this,t[f].nodeIndex=this.inboundNodes.length-1,t[f].tensorIndex=f},t.prototype.getConfig=function(){var e={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(e.batchInputShape=this.batchInputShape),null!=this.dtype&&(e.dtype=this.dtype),e},t.prototype.disposeWeights=function(){return this.weights.forEach(function(e){return e.dispose()}),this.weights.length},t.prototype.assertNotDisposed=function(){if(0===this._refCount)throw new Error("Layer '"+this.name+"' is already disposed.")},t.prototype.dispose=function(){if(!this.built)throw new Error("Cannot dispose Layer "+this.name+" because it has not been built yet.");if(null===this._refCount)throw new Error("Cannot dispose Layer "+this.name+" because it has not been used yet.");this.assertNotDisposed();var e=0;return 0==--this._refCount&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}},t}(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].Serializable);function collectInputShape(e){for(var t=[],n=0,r=e=toList(e);n<r.length;n++){var i=r[n];t.push(i.shape)}return singletonOrArray(t)}function guessOutputDType(e){return"float32"}function getSourceInputs(e,t,n){if((null==t||null!=n&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),0===t.inboundNodes.length)return[e];var r=t.inboundNodes[n];if(0===r.inboundLayers.length)return r.inputTensors;for(var i=[],a=0;a<r.inboundLayers.length;a++)for(var o=0,s=getSourceInputs(r.inputTensors[a],r.inboundLayers[a],r.nodeIndices[a]);o<s.length;o++){var l=s[o];-1===i.indexOf(l)&&i.push(l)}return i}var ModelLoggingVerbosity,InputLayer=function(e){function t(t){var n=e.call(this,{dtype:t.dtype,name:null!=t.name?t.name:getUid("input").toString()})||this;if(null==t.batchSize&&(t.batchSize=null),null==t.sparse&&(t.sparse=!1),n.trainable=!1,n.built=!0,n.sparse=t.sparse,null!=t.inputShape&&null!=t.batchInputShape)throw new ValueError("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");var r=t.batchInputShape;if(null==r){if(null==t.inputShape)throw new ValueError("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");r=[t.batchSize].concat(t.inputShape)}else if(null!=t.batchSize)throw new ValueError("Cannot specify batchSize if batchInputShape isspecified when creating an InputLayer.");var i=t.dtype||"float32";n.batchInputShape=r,n.dtype=i,n.inputSpec=[{shape:r}];var a=new SymbolicTensor(n.dtype,n.batchInputShape,n,[],{},n.name);return a.nodeIndex=0,a.tensorIndex=0,new Node({outboundLayer:n,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[a],outputTensors:[a],inputMasks:[null],outputMasks:[null],inputShapes:[r],outputShapes:[r]}),n}return __extends(t,e),t.prototype.apply=function(e,t){throw new ValueError("Cannot pass any input to an InputLayer's apply() method. InputLayer name: "+this.name)},t.prototype.dispose=function(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}},t.prototype.getConfig=function(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}},t.className="InputLayer",t}(Layer);function Input(e){if(null==e.batchShape&&null==e.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=e.batchShape&&null!=e.shape)throw new ValueError("Please provide either a `shape` or `batchShape` argument to Input, but not both.");var t=e.batchShape;null!=e.shape&&null==t&&(t=[null].concat(e.shape));var n=e.dtype;return null==n&&(n="float32"),new InputLayer({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}function resolveScalarsInLogs(e){return __awaiter(this,void 0,void 0,function(){var t,n,r,i,a,o,s,l;return __generator(this,function(u){switch(u.label){case 0:if(null==e)return[2];for(i in t=[],n=[],r=[],e)"number"!=typeof(a=e[i])&&(o=a,t.push(o.data()),n.push(i),r.push(o));return[4,Promise.all(t)];case 1:for(s=u.sent(),l=0;l<s.length;++l)e[n[l]]=s[l][0];return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(r),[2]}})})}function disposeTensorsInLogs(e){if(null!=e)for(var t in e){var n=e[t];"number"!=typeof n&&n.dispose()}}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(InputLayer),function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"}(ModelLoggingVerbosity||(ModelLoggingVerbosity={}));var BaseCallback=function(){function e(){this.validationData=null}return e.prototype.setParams=function(e){this.params=e},e.prototype.onEpochBegin=function(e,t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(e){return[2]})})},e.prototype.onEpochEnd=function(e,t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(e){return[2]})})},e.prototype.onBatchBegin=function(e,t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(e){return[2]})})},e.prototype.onBatchEnd=function(e,t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(e){return[2]})})},e.prototype.onTrainBegin=function(e){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(e){return[2]})})},e.prototype.onTrainEnd=function(e){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(e){return[2]})})},e.prototype.setModel=function(e){},e}(),CallbackList=function(){function e(e,t){void 0===t&&(t=10),null==e&&(e=[]),this.callbacks=e,this.queueLength=t}return e.prototype.append=function(e){this.callbacks.push(e)},e.prototype.setParams=function(e){for(var t=0,n=this.callbacks;t<n.length;t++){n[t].setParams(e)}},e.prototype.setModel=function(e){for(var t=0,n=this.callbacks;t<n.length;t++){n[t].setModel(e)}},e.prototype.onEpochBegin=function(e,t){return __awaiter(this,void 0,void 0,function(){var n,r;return __generator(this,function(i){switch(i.label){case 0:null==t&&(t={}),n=0,r=this.callbacks,i.label=1;case 1:return n<r.length?[4,r[n].onEpochBegin(e,t)]:[3,4];case 2:i.sent(),i.label=3;case 3:return n++,[3,1];case 4:return[2]}})})},e.prototype.onEpochEnd=function(e,t){return __awaiter(this,void 0,void 0,function(){var n,r;return __generator(this,function(i){switch(i.label){case 0:null==t&&(t={}),n=0,r=this.callbacks,i.label=1;case 1:return n<r.length?[4,r[n].onEpochEnd(e,t)]:[3,4];case 2:i.sent(),i.label=3;case 3:return n++,[3,1];case 4:return[2]}})})},e.prototype.onBatchBegin=function(e,t){return __awaiter(this,void 0,void 0,function(){var n,r;return __generator(this,function(i){switch(i.label){case 0:null==t&&(t={}),n=0,r=this.callbacks,i.label=1;case 1:return n<r.length?[4,r[n].onBatchBegin(e,t)]:[3,4];case 2:i.sent(),i.label=3;case 3:return n++,[3,1];case 4:return[2]}})})},e.prototype.onBatchEnd=function(e,t){return __awaiter(this,void 0,void 0,function(){var n,r;return __generator(this,function(i){switch(i.label){case 0:return null==t&&(t={}),[4,resolveScalarsInLogs(t)];case 1:i.sent(),n=0,r=this.callbacks,i.label=2;case 2:return n<r.length?[4,r[n].onBatchEnd(e,t)]:[3,5];case 3:i.sent(),i.label=4;case 4:return n++,[3,2];case 5:return[2]}})})},e.prototype.onTrainBegin=function(e){return __awaiter(this,void 0,void 0,function(){var t,n;return __generator(this,function(r){switch(r.label){case 0:null==e&&(e={}),t=0,n=this.callbacks,r.label=1;case 1:return t<n.length?[4,n[t].onTrainBegin(e)]:[3,4];case 2:r.sent(),r.label=3;case 3:return t++,[3,1];case 4:return[2]}})})},e.prototype.onTrainEnd=function(e){return __awaiter(this,void 0,void 0,function(){var t,n;return __generator(this,function(r){switch(r.label){case 0:null==e&&(e={}),t=0,n=this.callbacks,r.label=1;case 1:return t<n.length?[4,n[t].onTrainEnd(e)]:[3,4];case 2:r.sent(),r.label=3;case 3:return t++,[3,1];case 4:return[2]}})})},e}(),ModelTrainingYielder=function(){function e(e){this.yieldEvery=e,this.batchCount=0,this.batchDurationsMillis=[],this.autoYieldEveryBatches=null,this.batchStartMillis=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].now()}return e.prototype.resolveOneTensorInLogs=function(e){return __awaiter(this,void 0,void 0,function(){var t,n,r,i,a;return __generator(this,function(o){switch(o.label){case 0:for(n in t=[],e)t.push(n);r=0,o.label=1;case 1:return r<t.length?(i=t[r],"number"==typeof(a=e[i])?[3,3]:[4,a.data()]):[3,4];case 2:return o.sent(),[3,4];case 3:return r++,[3,1];case 4:return[2]}})})},e.prototype.maybeYieldOnBatch=function(t){return __awaiter(this,void 0,void 0,function(){var n,r;return __generator(this,function(i){switch(i.label){case 0:return"auto"!==this.yieldEvery?[3,7]:(this.batchCount++,null!=this.autoYieldEveryBatches?[3,3]:[4,this.resolveOneTensorInLogs(t)]);case 1:return i.sent(),n=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].now(),[4,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["nextFrame"])()];case 2:return i.sent(),this.batchCount>e.SKIP_FIRST_BATCHES&&(this.batchDurationsMillis.push(n-this.batchStartMillis),this.batchDurationsMillis.length>=e.DECISION_BATCH_COUNT&&(r=this.batchDurationsMillis.reduce(function(e,t){return e+t})/this.batchDurationsMillis.length,this.autoYieldEveryBatches=Math.round(e.THRESHOLD_MILLIS/r),this.autoYieldEveryBatches<1&&(this.autoYieldEveryBatches=1))),this.batchStartMillis=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].now(),this.lastYieldBatchCount=this.batchCount,[3,6];case 3:return this.batchCount-this.lastYieldBatchCount>=this.autoYieldEveryBatches?[4,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["nextFrame"])()]:[3,6];case 4:return i.sent(),[4,this.resolveOneTensorInLogs(t)];case 5:i.sent(),this.lastYieldBatchCount=this.batchCount,i.label=6;case 6:return[3,9];case 7:return"batch"!==this.yieldEvery?[3,9]:[4,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["nextFrame"])()];case 8:i.sent(),i.label=9;case 9:return[2]}})})},e.prototype.maybeYieldOnEpoch=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(e){switch(e.label){case 0:return"epoch"!==this.yieldEvery?[3,2]:[4,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["nextFrame"])()];case 1:e.sent(),e.label=2;case 2:return[2]}})})},e.SKIP_FIRST_BATCHES=1,e.DECISION_BATCH_COUNT=2,e.THRESHOLD_MILLIS=16,e}(),BaseLogger=function(e){function t(t){var n=e.call(this)||this;return n.yieldEvery=t||"auto",n}return __extends(t,e),t.prototype.onTrainBegin=function(e){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(e){return this.autoYielder=new ModelTrainingYielder(this.yieldEvery),[2]})})},t.prototype.onEpochBegin=function(e){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(e){return this.seen=0,this.totals={},[2]})})},t.prototype.onBatchEnd=function(e,t){return __awaiter(this,void 0,void 0,function(){var e,n,r,i,a=this;return __generator(this,function(o){switch(o.label){case 0:return[4,this.autoYielder.maybeYieldOnBatch(t)];case 1:for(i in o.sent(),null==t&&(t={}),e=null==t.size?0:t.size,this.seen+=e,n=function(n){var i=t[n];if("number"==typeof i)r.totals.hasOwnProperty(n)||(r.totals[n]=0),r.totals[n]=r.totals[n]+i*e;else{var o=void 0;n in r.totals?o=r.totals[n]:r.totals[n]=getScalar(0),r.totals[n]=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(a.totals[n],Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(i,getScalar(e)))}),null!=o&&o.dispose()}},r=this,t)n(i);return[2]}})})},t.prototype.onEpochEnd=function(e,t){return __awaiter(this,void 0,void 0,function(){var e,n,r,i,a,o=this;return __generator(this,function(s){switch(s.label){case 0:return[4,this.autoYielder.maybeYieldOnEpoch()];case 1:if(s.sent(),null!=t)for(e=function(e){if(null==n.totals[e])return"continue";"number"==typeof n.totals[e]?t[e]=n.totals[e]/n.seen:Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){t[e]=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"])(getScalar(1),getScalar(o.seen)),o.totals[e]),o.totals[e].dispose(),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["keep"])(t[e])})},n=this,r=0,i=this.params.metrics;r<i.length;r++)a=i[r],e(a);return[2]}})})},t}(BaseCallback),History=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.onTrainBegin=function(e){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(e){return this.epoch=[],this.history={},[2]})})},t.prototype.onEpochEnd=function(e,t){return __awaiter(this,void 0,void 0,function(){var n;return __generator(this,function(r){for(n in null==t&&(t={}),this.epoch.push(e),t)null==this.history[n]&&(this.history[n]=[]),this.history[n].push(t[n]);return[2]})})},t.prototype.syncData=function(){return __awaiter(this,void 0,void 0,function(){var e,t,n,r,i,a,o,s,l;return __generator(this,function(u){switch(u.label){case 0:for(r in e=[],t=[],n=[],this.history)for(i=this.history[r],a=0;a<i.length;++a)"number"!=typeof i[a]&&(o=i[a],e.push(o.data()),t.push(r),n.push(a));return[4,Promise.all(e)];case 1:for(s=u.sent(),l=0;l<s.length;++l)this.history[t[l]][n[l]].dispose(),this.history[t[l]][n[l]]=s[l][0];return[2]}})})},t}(BaseCallback),CustomCallback=function(e){function t(t){var n=e.call(this)||this;return n.trainBegin=t.onTrainBegin,n.trainEnd=t.onTrainEnd,n.epochBegin=t.onEpochBegin,n.epochEnd=t.onEpochEnd,n.batchBegin=t.onBatchBegin,n.batchEnd=t.onBatchEnd,n}return __extends(t,e),t.prototype.onEpochBegin=function(e,t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(n){switch(n.label){case 0:return null==this.epochBegin?[3,3]:[4,resolveScalarsInLogs(t)];case 1:return n.sent(),[4,this.epochBegin(e,t)];case 2:n.sent(),n.label=3;case 3:return[2]}})})},t.prototype.onEpochEnd=function(e,t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(n){switch(n.label){case 0:return null==this.epochEnd?[3,3]:[4,resolveScalarsInLogs(t)];case 1:return n.sent(),[4,this.epochEnd(e,t)];case 2:n.sent(),n.label=3;case 3:return[2]}})})},t.prototype.onBatchBegin=function(e,t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(n){switch(n.label){case 0:return null==this.batchBegin?[3,3]:[4,resolveScalarsInLogs(t)];case 1:return n.sent(),[4,this.batchBegin(e,t)];case 2:n.sent(),n.label=3;case 3:return[2]}})})},t.prototype.onBatchEnd=function(e,t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(n){switch(n.label){case 0:return null==this.batchEnd?[3,3]:[4,resolveScalarsInLogs(t)];case 1:return n.sent(),[4,this.batchEnd(e,t)];case 2:n.sent(),n.label=3;case 3:return[2]}})})},t.prototype.onTrainBegin=function(e){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(t){switch(t.label){case 0:return null==this.trainBegin?[3,3]:[4,resolveScalarsInLogs(e)];case 1:return t.sent(),[4,this.trainBegin(e)];case 2:t.sent(),t.label=3;case 3:return[2]}})})},t.prototype.onTrainEnd=function(e){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(t){switch(t.label){case 0:return null==this.trainEnd?[3,3]:[4,resolveScalarsInLogs(e)];case 1:return t.sent(),[4,this.trainEnd(e)];case 2:t.sent(),t.label=3;case 3:return[2]}})})},t}(BaseCallback);function standardizeCallbacks(e){return null==e?null:e instanceof BaseCallback?[e]:Array.isArray(e)&&e[0]instanceof BaseCallback?e:toList(e).map(function(e){return new CustomCallback(e)})}var CallbackConstructorRegistry=function(){function e(){}return e.registerCallbackConstructor=function(t,n){_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(t>=0&&Number.isInteger(t),"Verbosity level is expected to be an integer >= 0, but got "+t),e.checkForDuplicate(n),null==e.constructors[t]&&(e.constructors[t]=[]),e.constructors[t].push(n)},e.checkForDuplicate=function(t){for(var n in e.constructors){e.constructors[+n].forEach(function(e){if(e===t)throw new ValueError("Duplicate callback constructor.")})}},e.clear=function(){e.constructors={}},e.createCallbacks=function(t){var n=[];for(var r in e.constructors){var i=+r;t>=i&&n.push.apply(n,e.constructors[i])}return n.map(function(e){return new e})},e.constructors={},e}();function configureCallbacks(e,t,n,r,i,a,o,s,l,u){var c=new History,p=[new BaseLogger(t)].concat(CallbackConstructorRegistry.createCallbacks(n));null!=e&&p.push.apply(p,e),p.push(c);var h=new CallbackList(p);return h.setParams({epochs:r,initialEpoch:i,samples:a,steps:o,batchSize:s,verbose:n,doValidation:l,metrics:u}),{callbackList:h,history:c}}function l2Normalize(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sum"])(square(e),t,!0),r=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"])(epsilon()),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["onesLike"])(e)),i=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["maximum"])(n,r));return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"])(e,i)})}function meanSquaredError(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(square(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"])(t,e)),-1)})}function meanAbsoluteError(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["abs"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"])(t,e)),-1)})}function meanAbsolutePercentageError(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"])(e,t),r=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clipByValue"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["abs"])(e),epsilon(),Number.MAX_VALUE),i=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["abs"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"])(n,r));return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(getScalar(100),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(i,-1))})}function meanSquaredLogarithmicError(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=getScalar(1),r=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clipByValue"])(t,epsilon(),Number.MAX_VALUE),i=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["log"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(n,r)),a=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clipByValue"])(e,epsilon(),Number.MAX_VALUE),o=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["log"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(n,a));return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(square(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"])(i,o)),-1)})}function squaredHinge(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=getScalar(0),r=getScalar(1),i=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["maximum"])(n,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"])(r,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(e,t)));return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(square(i),-1)})}function hinge(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=getScalar(0),r=getScalar(1),i=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["maximum"])(n,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"])(r,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(e,t)));return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(i,-1)})}function categoricalHinge(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=getScalar(0),r=getScalar(1),i=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sum"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(e,t),-1),a=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["max"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"])(r,e),t),-1);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["maximum"])(n,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(r,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"])(a,i)))})}function logcosh(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=getScalar(Math.log(2)),r=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"])(t,e),i=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(r,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["softplus"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(getScalar(-2),r))),n);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(i,-1)})}function categoricalCrossentropy(e,t,n){return void 0===n&&(n=!1),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(n)t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["softmax"])(t);else{var r=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sum"])(t,t.shape.length-1,!0);t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"])(t,r)}return t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clipByValue"])(t,epsilon(),1-epsilon()),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["neg"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sum"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(e.toFloat(),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["log"])(t)),t.shape.length-1))})}function sparseCategoricalCrossentropy(e,t,n){return void 0===n&&(n=!1),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var r=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["floor"])(flatten(e)).toInt(),i=t.shape;return categoricalCrossentropy(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["oneHot"])(r,i[i.length-1]).reshape(i),t,n)})}function sigmoidCrossEntropyWithLogits(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["maximum"])(t,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["zerosLike"])(t)),r=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(t,e),i=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["log"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(getScalar(1),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["exp"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["neg"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["abs"])(t)))));return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"])(n,r),i)})}function binaryCrossentropy(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n;return n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clipByValue"])(t,epsilon(),1-epsilon()),n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["log"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"])(n,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["onesLike"])(n),n))),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(sigmoidCrossEntropyWithLogits(e,n),-1)})}function kullbackLeiblerDivergence(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clipByValue"])(e,epsilon(),1),r=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clipByValue"])(t,epsilon(),1);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sum"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(e,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["log"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"])(n,r))),-1)})}function poisson(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["log"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(getScalar(epsilon()),t));return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"])(t,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(e,n)),-1)})}function cosineProximity(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=l2Normalize(e,-1),r=l2Normalize(t,-1),i=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(n,r);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["neg"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sum"])(i,-1))})}function get(e){var t={meanSquaredError:meanSquaredError,meanAbsoluteError:meanAbsoluteError,meanAbsolutePercentageError:meanAbsolutePercentageError,meanSquaredLogarithmicError:meanSquaredLogarithmicError,squaredHinge:squaredHinge,hinge:hinge,categoricalHinge:categoricalHinge,logcosh:logcosh,categoricalCrossentropy:categoricalCrossentropy,sparseCategoricalCrossentropy:sparseCategoricalCrossentropy,binaryCrossentropy:binaryCrossentropy,kullbackLeiblerDivergence:kullbackLeiblerDivergence,poisson:poisson,cosineProximity:cosineProximity};if("string"==typeof e){if(e in t)return t[e];var n="Unknown loss "+e;throw e.toLowerCase().includes("softmaxcrossentropy")&&(n="Unknown loss "+e+'. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy'),new ValueError(n)}return e}function binaryAccuracy(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(getScalar(.5),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["onesLike"])(t)),r=cast$1(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["greater"])(t,n),e.dtype);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["equal"])(e,r),-1)})}function categoricalAccuracy(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return cast$1(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["equal"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["argMax"])(e,-1),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["argMax"])(t,-1)),"float32")})}function truePositives(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=getScalar(1);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["logicalAnd"])(e.equal(n),t.equal(n)).sum().cast("float32")})}function falseNegatives(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=getScalar(1),r=getScalar(0);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["logicalAnd"])(e.equal(n),t.equal(r)).sum().cast("float32")})}function falsePositives(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=getScalar(1),r=getScalar(0);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["logicalAnd"])(e.equal(r),t.equal(n)).sum().cast("float32")})}function precision(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=getScalar(0),r=truePositives(e,t),i=falsePositives(e,t),a=r.add(i);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["where"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["greater"])(a,n),r.div(a),n).cast("float32")})}function recall(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=getScalar(0),r=truePositives(e,t),i=falseNegatives(e,t),a=r.add(i);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["where"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["greater"])(a,n),r.div(a),n).cast("float32")})}function binaryCrossentropy$1(e,t){return binaryCrossentropy(e,t)}function sparseCategoricalAccuracy(e,t){throw new NotImplementedError}var mse$1=meanSquaredError,MSE$1=meanSquaredError,mae$1=meanAbsoluteError,MAE$1=meanAbsoluteError,mape$1=meanAbsolutePercentageError,MAPE$1=meanAbsolutePercentageError,categoricalCrossentropy$1=categoricalCrossentropy,cosine$1=cosineProximity,sparseCategoricalCrossentropy$1=sparseCategoricalCrossentropy;function get$1(e){var t={binaryAccuracy:binaryAccuracy,categoricalAccuracy:categoricalAccuracy,precision:precision,categoricalCrossentropy:categoricalCrossentropy$1,sparseCategoricalCrossentropy:sparseCategoricalCrossentropy$1,mse:mse$1,MSE:MSE$1,mae:mae$1,MAE:MAE$1,mape:mape$1,MAPE:MAPE$1,cosine:cosine$1};if("string"==typeof e&&e in t)return t[e];if("string"!=typeof e&&null!=e)return e;throw new ValueError("Unknown metric "+e)}function getOptimizer(e){var t={Adagrad:function(){return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["train"].adagrad(.01)},Adadelta:function(){return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["train"].adadelta(1,.95,epsilon())},Adam:function(){return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["train"].adam(.001,.9,.999,epsilon())},Adamax:function(){return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["train"].adamax(.002,.9,.999,epsilon(),0)},RMSProp:function(){return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["train"].rmsprop(.001,.9,0,epsilon())},SGD:function(){return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["train"].sgd(.01)}};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new ValueError("Unknown Optimizer "+e)}function printSummary(e,t,n,r){void 0===r&&(r=console.log);var i,a=isModelSequentialLike(e),o=["Layer (type)","Output shape","Param #"];if(a?(t=t||65,n=n||[.45,.85,1]):(t=t||98,n=n||[.33,.55,.67,1]),n[n.length-1]<=1&&(n=n.map(function(e){return Math.floor(t*e)})),!a)for(var s in o.push("Receives inputs"),i=[],e.nodesByDepth)i.push.apply(i,e.nodesByDepth[s]);r("_".repeat(t)),printRow(o,n,r),r("=".repeat(t));for(var l=e.layers,u=0;u<l.length;++u)a?printLayerSummary(l[u],n,r):printLayerSummaryWithConnections(l[u],n,i,r),r((u===l.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();var c=countTrainableParams(e),p=countParamsInWeights(e.nonTrainableWeights);r("Total params: "+(c+p)),r("Trainable params: "+c),r("Non-trainable params: "+p),r("_".repeat(t))}function countTrainableParams(e){return null!=e.collectedTrainableWeights?countParamsInWeights(e.collectedTrainableWeights):countParamsInWeights(e.trainableWeights)}function isModelSequentialLike(e){var t=!0,n=[],r=[];for(var i in e.nodesByDepth)n.push(e.nodesByDepth[i]);for(var a=0,o=n;a<o.length;a++){var s=o[a];if(s.length>1||1===s.length&&s[0].inboundLayers.length>1){t=!1;break}r.push.apply(r,s)}if(t)for(var l=0,u=e.layers;l<u.length;l++){for(var c=!1,p=0,h=u[l].inboundNodes;p<h.length;p++){var d=h[p];if(-1!==r.indexOf(d)){if(c){t=!1;break}c=!0}}if(!t)break}return t}function printRow(e,t,n){void 0===n&&(n=console.log);for(var r="",i=0;i<e.length;++i)i>0&&(r=r.slice(0,r.length-1)+" "),r=(r+=e[i]).slice(0,t[i]),r+=" ".repeat(t[i]-r.length);n(r)}function printLayerSummary(e,t,n){var r;try{r=JSON.stringify(e.outputShape)}catch(e){r="multiple"}printRow([e.name+" ("+e.getClassName()+")",r,e.countParams().toString()],t,n)}function printLayerSummaryWithConnections(e,t,n,r){var i;try{i=JSON.stringify(e.outputShape)}catch(e){i="multiple"}for(var a=[],o=0,s=e.inboundNodes;o<s.length;o++){var l=s[o];if(!(null!=n&&n.length>0&&-1===n.indexOf(l)))for(var u=0;u<l.inboundLayers.length;++u){var c=l.inboundLayers[u].name,p=l.nodeIndices[u],h=l.tensorIndices[u];a.push(c+"["+p+"]["+h+"]")}}var d=e.name,f=e.getClassName(),g=0===a.length?"":a[0];printRow([d+" ("+f+")",i,e.countParams().toString(),g],t,r);for(u=1;u<a.length;++u)printRow(["","","",a[u]],t,r)}function deserialize(e,t){return void 0===t&&(t={}),deserializeKerasObject(e,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].SerializationMap.getMap().classNameMap,t,"layer")}function isArrayItemInputOrOutputName(e,t,n){return("inboundNodes"===e||"outputLayers"===e||"inputLayers"===e)&&0===t&&"string"==typeof n}function convertPythonicToTs(e,t){if(null===e)return null;if("string"==typeof e)return toCamelCase(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){for(var n=[],r=e.length,i=0;i<r;++i){var a=e[i];isArrayItemInputOrOutputName(t,i,a)?n.push(a):n.push(convertPythonicToTs(a,t))}return n}for(var o={},s=0,l=Object.keys(e);s<l.length;s++){var u=l[s],c=e[u];if("name"===u&&"string"==typeof c)o[u]=c;else{var p=toCamelCase(u);o[p]=convertPythonicToTs(c,p)}}return o}function convertTsToPythonic(e,t){if(null===e||void 0===e)return null;if("string"==typeof e)return toSnakeCase(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){for(var n=[],r=e.length,i=0;i<r;++i){var a=e[i];isArrayItemInputOrOutputName(t,i,a)?n.push(a):n.push(convertTsToPythonic(a,t))}return n}for(var o={},s=0,l=Object.keys(e);s<l.length;s++){var u=l[s],c=e[u],p=toSnakeCase(u);o[p]="name"!==u&&"className"!==u||"string"!=typeof c?convertTsToPythonic(c,u):c}return o}var version="0.8.5";function preprocessWeightsForLoading(e,t,n,r){if(!n.startsWith("2."))throw new ValueError("Unsupported Keras version in weights being loaded: "+n);return t}function loadTensor(e,t,n){var r=stringToDType(e);return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Tensor"].make(t,{values:0===t.length?n:_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].flatten(n)},r)}function loadWeightsFromJson(e,t,n){void 0===n&&(n=!1);for(var r=e.keras_version,i=e.backend,a=t.map(function(e){return e.name}),o={},s=0,l=t;s<l.length;s++){null!=(b=l[s]).name&&(null==o[b.name]&&(o[b.name]=[]),o[b.name].push(b))}for(var u=e.weights,c=[],p=0;p<a.length;++p){var h=a[p],d=u[h];null==d&&(d=[]);for(var f=[],g=0;g<d.length;++g){var m=d[g];f.push(new LayerVariable(loadTensor(m.dtype,m.shape,m.value)))}for(var y=0,v=o[h];y<v.length;y++){var b,w=(b=v[y]).weights;if((f=preprocessWeightsForLoading(b,f,r,i)).length!==w.length){if(!n)throw new ValueError("Layer #"+p+' (named "'+b.name+'") expects '+w.length+" weight(s), but the saved weights have "+f.length+" element(s).");console.warn("Skipping loading of weights of layer "+b.name+" due to mismatch in number of weights: ("+f.length+" vs "+w.length+").")}for(var z=0;z<f.length;++z)!n||_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].arraysEqual(w[z].shape,f[z].shape)?c.push([w[z],f[z].read()]):console.warn("Skipping loading of weights for layer "+b.name+" due to mismatch in shape ("+w[z].shape+" vs "+f[z].shape+")")}}batchSetValue(c)}function loadWeightsFromNamedTensorMap(e,t,n){void 0===n&&(n=!0);for(var r={},i=0,a=0,o=t;a<o.length;a++)for(var s=0,l=o[a].weights;s<l.length;s++){var u=l[s];if(null!=r[u.originalName])throw new ValueError("Duplicate weight name: "+u.originalName);r[u.originalName]=u,i++}var c=[];for(var p in e){if(null!=r[p])c.push([r[p],e[p]]);else if(n)throw new ValueError("Provided weight data has no target variable: "+p);delete r[p]}if(n){var h=[];for(var d in r)h.push(d);if(h.length>0)throw new ValueError(h.length+" of "+i+" weights are not set: "+h)}batchSetValue(c)}var Container=function(e){function t(n){var r=e.call(this,{})||this;if(r.containerNodes=new Set,r.name=n.name,null==r.name){var i=r.getClassName().toLowerCase();r.name=getUid(i)}if(r.supportsMasking=!1,r.trainable=!0,r.updatable=!0,Array.isArray(n.inputs)?r.inputs=n.inputs.slice():r.inputs=[n.inputs],Array.isArray(n.outputs)?r.outputs=n.outputs.slice():r.outputs=[n.outputs],unique(r.inputs).length!==r.inputs.length)throw new ValueError("The list of inputs passed to the model is redundant. All inputs should only appear once. Found: "+r.inputs.map(function(e){return e.name}));unique(r.outputs).length!==r.outputs.length&&console.warn("The list of outputs passed to the model is redundant. All outputs should only appear once. Found: "+r.outputs.map(function(e){return e.name})),r.inputLayers=[],r.inputLayersNodeIndices=[],r.inputLayersTensorIndices=[],r.outputLayers=[],r.outputLayersNodeIndices=[],r.outputLayersTensorIndices=[],r.layers=[];for(var a=0,o=r.outputs;a<o.length;a++){var s=(A=o[a]).sourceLayer,l=A.nodeIndex,u=A.tensorIndex;r.outputLayers.push(s),r.outputLayersNodeIndices.push(l),r.outputLayersTensorIndices.push(u)}for(var c=0,p=r.inputs;c<p.length;c++){s=(A=p[c]).sourceLayer,l=A.nodeIndex,u=A.tensorIndex;assert(0===l,"input layer has >1 nodes"),assert(0===u,"input layer has >1 tensors"),r.inputLayers.push(s),r.inputLayersNodeIndices.push(l),r.inputLayersTensorIndices.push(u)}r.inputNames=[],r.outputNames=[],r.feedInputShapes=[],r.feedInputNames=[],r.feedOutputNames=[];for(var h=0;h<r.inputLayers.length;h++){if(!((s=r.inputLayers[h])instanceof InputLayer))throw new TypeError("Input layers to a Model must be InputLayer objects. Received inputs: "+n.inputs+". Input "+h+" (0-based) originates from layer type "+s.getClassName()+".");r.inputNames.push(s.name),r.feedInputShapes.push(s.batchInputShape),r.feedInputNames.push(s.name)}for(var d=0,f=r.outputLayers;d<f.length;d++){s=f[d];r.outputNames.push(s.name)}r.internalInputShapes=r.inputs.map(function(e){return e.shape}),r.internalOutputShapes=r.outputs.map(function(e){return e.shape});for(var g={},m={},y={},v={},b={},w=[],z=function(e,n,i,a,o,s){null!=a&&null!=o&&null!=s||(a=e.sourceLayer,o=e.nodeIndex,s=e.tensorIndex);var l=a.inboundNodes[o];if(-1!==i.indexOf(l))throw new RuntimeError("The tensor "+e.name+' at layer "'+a.name+'" is part of a cycle.');if(-1===n.indexOf(l)){r.containerNodes.add(t.nodeKey(a,o)),a.id in b||(b[a.id]=Object.keys(b).length),-1===i.indexOf(l)&&i.push(l);for(var u=l.inboundLayers.length,c=0;c<u;c++){var p=l.inputTensors[c],h=l.inboundLayers[c],d=l.nodeIndices[c],f=l.tensorIndices[c];z(p,n,i,h,d,f)}for(n.push(l);i.indexOf(l)>=0;)i.splice(i.indexOf(l),1);w.push(l)}},S=[],I=[],N=0,C=r.outputs;N<C.length;N++){var A=C[N];z(A,S,I)}for(var _=0,E=w.slice().reverse();_<E.length;_++){m[(K=E[_]).id]=K,K.id in g||(g[K.id]=0);var k=g[K.id],L=null==y[K.outboundLayer.id]?0:y[K.outboundLayer.id];k=Math.max(k,L),y[K.outboundLayer.id]=k,v[K.outboundLayer.id]=K.outboundLayer,g[K.id]=k;for(h=0;h<K.inboundLayers.length;h++){var x=K.inboundLayers[h],T=(l=K.nodeIndices[h],x.inboundNodes[l]),D=null==g[T.id]?0:g[T.id];g[T.id]=Math.max(k+1,D),m[T.id]=T}}var O={};for(var R in g){(k=g[R])in O||(O[k]=[]),O[k].push(m[R])}var M={};for(var P in y){(k=y[P])in M||(M[k]=[]),M[k].push(v[P])}var V=Object.keys(M).map(function(e){return parseInt(e,10)}).sort(reverseNumberCompare);r.layers=[];for(var F=0,B=V;F<B.length;F++){var U=M[k=B[F]];U.sort(function(e,t){var n=b[e.id],r=b[t.id];return n<r?-1:n>r?1:0});for(var j=0,W=U;j<W.length;j++){s=W[j];r.layers.push(s)}}r.layersByDepth=M,V=Object.keys(O).map(function(e){return parseInt(e,10)}).sort(reverseNumberCompare);for(var $=r.inputs.slice(),q=[],G=0,J=V;G<J.length;G++)for(var H=0,Z=O[k=J[G]];H<Z.length;H++){var K;if(null!=(s=(K=Z[H]).outboundLayer)){for(var Y=0,X=K.inputTensors;Y<X.length;Y++){A=X[Y];if(-1===$.indexOf(A))throw new RuntimeError("Graph disconnected: cannot obtain value for tensor "+A+' at layer "'+s.name+'". The following previous layers were accessed without issue: '+q)}for(var Q=0,ee=K.outputTensors;Q<ee.length;Q++){A=ee[Q];$.push(A)}q.push(s.name)}}r.nodesByDepth=O;for(var te=r.layers.map(function(e){return e.name}),ne=function(e){var t=te.filter(function(t){return t===e}).length;if(1!==t)throw new RuntimeError('The name "'+e+'" is used '+t+" times in the model. All layer names should be unique. Layer names: "+JSON.stringify(te))},re=0,ie=te;re<ie.length;re++){ne(ie[re])}return r.outboundNodes=[],r.inboundNodes=[],new Node({outboundLayer:r,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:r.inputs,outputTensors:r.outputs,inputMasks:r.inputs.map(function(e){return null}),outputMasks:r.outputs.map(function(e){return null}),inputShapes:r.inputs.map(function(e){return e.shape}),outputShapes:r.outputs.map(function(e){return e.shape})}),r.built=!0,r._refCount=1,r}return __extends(t,e),t.prototype.assertNotDisposed=function(){if(0===this._refCount)throw new Error("Container '"+this.name+"' is already disposed.")},t.prototype.dispose=function(){this.assertNotDisposed();var e={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount)for(var t=0,n=this.layers;t<n.length;t++){var r=n[t];e.numDisposedVariables+=r.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e},Object.defineProperty(t.prototype,"trainableWeights",{get:function(){if(this._trainableWeights.length>0)throw new ValueError("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];for(var e=[],t=0,n=this.layers;t<n.length;t++){var r=n[t];e=e.concat(r.trainableWeights)}return e},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"nonTrainableWeights",{get:function(){for(var e=[],t=0,n=this.layers;t<n.length;t++){var r=n[t];e.push.apply(e,r.nonTrainableWeights)}if(!this.trainable){for(var i=[],a=0,o=this.layers;a<o.length;a++){r=o[a];i.push.apply(i,r.trainableWeights)}return i.concat(e)}return e},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"weights",{get:function(){return this.trainableWeights.concat(this.nonTrainableWeights)},enumerable:!0,configurable:!0}),t.prototype.loadWeights=function(e,t,n,r){void 0===t&&(t=!1),void 0===n&&(n=!1),void 0===r&&(r=!0),n?loadWeightsFromNamedTensorMap(e,this.layers,r):loadWeightsFromJson(e,this.layers,t)},t.prototype.updatedConfig=function(){var e=this.getConfig();return{className:this.getClassName(),config:e,kerasVersion:"tfjs-layers "+version,backend:"TensorFlow.js"}},t.prototype.toJSON=function(e,t){void 0===t&&(t=!0);var n=convertTsToPythonic(this.updatedConfig());return t?JSON.stringify(n):n},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var r;return e=toList(e),r="mask"in t?toList(t.mask):pyListRepeat(null,e.length),n.runInternalGraph(e,r)[0]})},t.prototype.computeMask=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var r;return e=toList(e),r=null==t?pyListRepeat(null,e.length):toList(t),n.runInternalGraph(e,r)[1]})},t.prototype.computeOutputShape=function(e){var t=normalizeShapeList(e);if(t.length!==this.inputLayers.length)throw new ValueError("Invalid inputShape argument "+e+": model has "+this.inputLayers.length+" tensor inputs.");for(var n={},r=0;r<t.length;r++){var i=this.inputLayers[r],a=t[r];n[I=i.name+"_0_0"]=a}var o=Object.keys(this.nodesByDepth).map(function(e){return parseInt(e,10)}).sort(reverseNumberCompare);if(o.length>1)for(var s=0,l=o;s<l.length;s++)for(var u=l[s],c=0,p=this.nodesByDepth[u];c<p.length;c++){var h=p[c];i=h.outboundLayer;if(-1===this.inputLayers.map(function(e){return e.id}).indexOf(i.id)){for(var d=[],f=0;f<h.inboundLayers.length;f++){var g=h.inboundLayers[f],m=h.nodeIndices[f],y=h.tensorIndices[f],v=n[I=g.name+"_"+m+"_"+y];d.push(v)}var b=normalizeShapeList(i.computeOutputShape(singletonOrArray(d))),w=i.inboundNodes.indexOf(h);for(f=0;f<b.length;f++){n[I=i.name+"_"+w+"_"+f]=b[f]}}}var z=[],S=[];for(r=0;r<this.outputLayers.length;r++){i=this.outputLayers[r],w=this.outputLayersNodeIndices[r],y=this.outputLayersTensorIndices[r];var I=i.name+"_"+w+"_"+y;S.push(I)}for(r=0;r<S.length;r++){var N=S[r];assert(N in n),z.push(n[N])}return singletonOrArray(z)},t.prototype.runInternalGraph=function(e,t){null==t&&(t=pyListRepeat(null,e.length));for(var n={},r=0;r<this.inputs.length;++r){var i=this.inputs[r],a=e[r],o=t[r];n[i.id]=[a,o]}for(var s=0,l=Object.keys(this.nodesByDepth).map(function(e){return parseInt(e,10)}).sort(reverseNumberCompare);s<l.length;s++)for(var u=l[s],c=0,p=this.nodesByDepth[u];c<p.length;c++){for(var h=p[c],d=h.outboundLayer,f=h.inputTensors,g=h.outputTensors,m=new Array,y=0,v=f;y<v.length;y++){(i=v[y]).id in n&&m.push(n[i.id])}if(m.length===f.length){var b={},w=void 0,z=void 0,S=void 0,I=void 0;if(null!=h.callArgs&&(b=h.callArgs),1===m.length){var N=m[0],C=N[0],A=N[1];null==b.mask&&(b.mask=A),S=toList(d.call(C,b)),I=toList(d.computeMask(C,A)),w=[C],z=[A]}else w=m.map(function(e){return e[0]}),z=m.map(function(e){return e[1]}),null==b.mask&&(b.mask=z),S=toList(d.call(w,b)),I=toList(d.computeMask(w,z));if(d.activityRegularizer)throw new NotImplementedError("Model invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(r=0;r<g.length;++r){i=g[r],a=S[r],o=I[r];n[i.id]=[a,o]}}}for(var _=[],E=[],k=[],L=0,x=this.outputs;L<x.length;L++){assert((i=x[L]).id in n,"Could not compute output "+i.name+" : "+i.id);var T=n[i.id],D=T[0];o=T[1];k.push(D.shape),_.push(D),E.push(o)}return[_,E,k]},t.prototype.buildNodeConversionMap=function(e){for(var n,r={},i=0,a=this.layers;i<a.length;i++){var o=a[i];n=o instanceof t?1:0;for(var s=0;s<o.inboundNodes.length;s++){var l=t.nodeKey(o,s);this.containerNodes.has(l)&&(r[l]=n,n+=1)}}return r},t.prototype.getLayer=function(e,t){if(null!=t){if(this.layers.length<=t)throw new ValueError("Was asked to retrieve layer at index "+t+", but model only has "+this.layers.length+" layer(s).");return this.layers[t]}if(null==e)throw new ValueError("Provide either a layer name or layer index");for(var n=0,r=this.layers;n<r.length;n++){var i=r[n];if(i.name===e)return i}throw new ValueError("No such layer: "+e)},t.prototype.calculateLosses=function(){var e=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){for(var n=[],r=0,i=e.layers;r<i.length;r++)for(var a=i[r],o=0;o<a.inboundNodes.length;++o){var s=t.nodeKey(a,o);e.containerNodes.has(s)&&n.push.apply(n,a.calculateLosses())}return n})},t.prototype.getConfig=function(){for(var e={name:this.name},n=this.buildNodeConversionMap(this.layers),r=[],i=0,a=this.layers;i<a.length;i++){for(var o=(b=a[i]).getClassName(),s=b.getConfig(),l=[],u=0;u<b.inboundNodes.length;u++){var c=b.inboundNodes[u],p=t.nodeKey(b,u),h={};if(this.containerNodes.has(p)){if(c.callArgs)try{JSON.stringify(c.callArgs),h=c.callArgs}catch(e){console.warn("Layer "+b.name+" was passed non-serializable keyword arguments: "+c.callArgs+". They will not be included in the serialized model (and thus will be missing at deserialization time)."),h={}}if(c.inboundLayers.length>0){for(var d=[],f=0;f<c.inboundLayers.length;f++){var g=c.inboundLayers[f],m=c.nodeIndices[f],y=c.tensorIndices[f];null==(z=n[t.nodeKey(g,m)])&&(z=0),d.push([g.name,z,y,h])}l.push(d)}}}r.push({name:b.name,className:o,config:s,inboundNodes:l})}e.layers=r;var v=[];for(f=0;f<this.inputLayers.length;f++){var b=this.inputLayers[f];m=this.inputLayersNodeIndices[f],p=t.nodeKey(b,m);if(this.containerNodes.has(p)){null!==(z=n[p])&&void 0!==z||(z=0);y=this.inputLayersTensorIndices[f];v.push([b.name,z,y])}}e.inputLayers=v;var w=[];for(f=0;f<this.outputLayers.length;f++){b=this.outputLayers[f],m=this.outputLayersNodeIndices[f],p=t.nodeKey(b,m);if(this.containerNodes.has(p)){var z;null!==(z=n[p])&&void 0!==z||(z=0);y=this.outputLayersTensorIndices[f];w.push([b.name,z,y])}}return e.outputLayers=w,e},t.fromConfig=function(e,t){var n={},r={};function i(e,t){e.name in r?r[e.name].push(t):r[e.name]=[t]}function a(e,t){for(var r,a=[],o=0,s=t;o<s.length;o++){var l=s[o],u=l[0],c=l[1],p=l[2];if(3===l.length)r={};else{if(4!==l.length)throw new ValueError("Improperly formatted model config for layer "+JSON.stringify(e)+": "+JSON.stringify(l));r=l[3]}if(!(u in n))return void i(e,t);var h=n[u];if(h.inboundNodes.length<=c)return void i(e,t);var d=h.inboundNodes[c];a.push(d.outputTensors[p])}a.length>0&&e.apply(singletonOrArray(a),r)}function o(e){var r=e.name,a=deserialize(e,null!=t.customObjects?t.customObjects:{});n[r]=a;for(var o=0,s=e.inboundNodes;o<s.length;o++){var l=s[o];if(!(l instanceof Array))throw new ValueError("Corrupted configuration, expected array for nodeData: "+l);i(a,l)}}for(var s=t.name,l=t.layers,u=0,c=l;u<c.length;u++){o(d=c[u])}for(;!isObjectEmpty(r);)for(var p=0,h=l;p<h.length;p++){var d=h[p];if((_=n[d.name]).name in r){var f=r[_.name];delete r[_.name];for(var g=0,m=f;g<m.length;g++){a(_,m[g])}}}for(var y=[],v=[],b=0,w=t.inputLayers;b<w.length;b++){var z=(d=w[b])[0],S=d[1],I=d[2];assert(z in n);var N=(_=n[z]).inboundNodes[S].outputTensors;y.push(N[I])}for(var C=0,A=t.outputLayers;C<A.length;C++){z=(d=A[C])[0],S=d[1],I=d[2];assert(z in n);var _;N=(_=n[z]).inboundNodes[S].outputTensors;v.push(N[I])}return new e({inputs:y,outputs:v,name:s})},Object.defineProperty(t.prototype,"stateful",{get:function(){if(this._stateful)throw new ValueError("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(var e=0,t=this.layers;e<t.length;e++){if(t[e].stateful)return!0}return!1},enumerable:!0,configurable:!0}),t.prototype.resetStates=function(){var e=this;Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){e.layers.forEach(function(e){e.stateful&&e.resetStates()})})},t}(Layer);function assertFeedCompatibility(e,t){if(null!=e.shape){if(e.shape.length!==t.shape.length)throw new ValueError("The rank of feed ("+t.shape.length+") does not match the rank of the key ("+e.shape.length+").");for(var n=0;n<e.shape.length;++n)if(null!=e.shape[n]&&e.shape[n]!==t.shape[n])throw new ValueError("The "+n+"-th dimension of the feed ("+t.shape[n]+") is incompatible with that of the key ("+e.shape[n]+").")}if(null==e.dtype||e.dtype===t.dtype)return t;try{return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["cast"])(t,e.dtype)}catch(n){throw new ValueError("The dtype of the feed ("+t.dtype+") can not be cast to the dtype of the key '"+e.name+"' ("+e.dtype+").")}}var FeedDict=function(){function e(t){if(this.id2Value={},t instanceof e)for(var n in t.id2Value)this.id2Value[n]=t.id2Value[n];else{if(null==t)return;for(var r=0,i=t;r<i.length;r++){var a=i[r];this.add(a.key,a.value)}}}return e.prototype.add=function(e,t){if(null!=this.id2Value[e.id])throw new ValueError("Duplicate key: name="+e.name+", id="+e.id);return this.id2Value[e.id]=assertFeedCompatibility(e,t),this},e.prototype.addFeed=function(e){this.add(e.key,e.value)},e.prototype.hasKey=function(e){return null!=this.id2Value[e.id]},e.prototype.getValue=function(e){if(null==this.id2Value[e.id])throw new ValueError("Nonexistent key: "+JSON.stringify(e));return this.id2Value[e.id]},e}();function execute(e,t,n){for(var r=Array.isArray(e),i=r?e:[e],a=[],o=new FeedDict(t),s=0,l=i;s<l.length;s++){var u=l[s];a.push(executeInternal(u,o,n))}return r?a:a[0]}function executeInternal(e,t,n){if(t.hasKey(e))return t.getValue(e);if(e.sourceLayer instanceof InputLayer)throw new ValueError("Missing a feed value for SymbolicTensor from InputLayer '"+InputLayer.name+"'");for(var r=[],i=0,a=e.inputs;i<a.length;i++){var o=executeInternal(a[i],t,n);r.push(o)}var s=e.sourceLayer.apply(r,n);Array.isArray(s)||(s=[s]);for(var l=getNodeOutputs(e),u=Array.isArray(l)?l:[l],c=0;c<u.length;++c)t.add(u[c],s[c]);return 1===s.length?s[0]:s[e.outputTensorIndex]}function getNodeOutputs(e){var t;if(1===e.sourceLayer.inboundNodes.length)t=e.sourceLayer.output;else{for(var n=null,r=0;r<e.sourceLayer.inboundNodes.length;++r)for(var i=0,a=e.sourceLayer.inboundNodes[r].outputTensors;i<a.length;i++){if(a[i].id===e.id){n=r;break}}t=e.sourceLayer.getOutputAt(n)}return t}var DEFAULT_VALIDATION_BATCH_SIZE=32;function standardizeDataIteratorOutput(e,t){if(e.outputs.length>1)throw new NotImplementedError("Support for training a model with multiple output tensors with a dataset object is not implemented yet.");_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(Array.isArray(t)&&2===t.length,"Dataset iterator for fitDataset() is expected to generate an Array of length 2: `[xs, ys]`, but instead generates "+t);var n=(t=t)[1],r=t[0];if(r instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Tensor"])return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(1===e.inputs.length,"Model has multiple "+e.inputs.length+" inputs, hence it expects the input dataset to generate a dictionary of tensors  (with keys "+JSON.stringify(e.inputNames)+", but received a single tensor."),_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(r.shape[0]===n.shape[0],"Mismatch in batch size between x and y tensors ("+r.shape[0]+" vs. "+n.shape[0]+")"),[r,n];var i=void 0;r=r;for(var a=[],o=0,s=e.inputNames;o<s.length;o++){var l=s[o];if(null==r[l])throw new ValueError("The feature data generated by the dataset lacks the required input key '"+l+"'.");a.push(r[l]),null==i?i=r[l].shape[0]:_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(r[l].shape[0]===i,"Mismatch in batch size between x and y tensors ("+r[l].shape[0]+" vs. "+n.shape[0]+")")}return a.concat(n)}function standardizeTensorValidationData(e){if(3===e.length)throw new NotImplementedError("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}function fitDataset(e,t,n){return __awaiter(this,void 0,void 0,function(){var r,i,a,o,s,l,u,c,p,h,d,f,g,m,y,v,b,w,z,S,I,N,C,A,_,E;return __generator(this,function(k){switch(k.label){case 0:if(r=null!=n.batchesPerEpoch,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(null!=e.optimizer,"You must compile a model before training/testing. Use Model.compile(modelCompileConfig)."),_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(null!=n,"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),"For fitDataset(), config.epochs is expected to be a positive integer, but got "+n.epochs),_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),"For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got "+n.batchesPerEpoch),_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(null==n.validationSplit,"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0,k.label=1;case 1:return k.trys.push([1,,21,22]),i=null!=n.validationData,a=void 0,o=void 0,i&&(isDatasetObject(n.validationData)?_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),"For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got "+n.validationBatches):(s=standardizeTensorValidationData(n.validationData),a=s.xs,o=s.ys)),l=e.makeTrainFunction(),u=e.getDedupedMetricsNames(),c=void 0,c=i?u.slice().concat(u.map(function(e){return"val_"+e})):u.slice(),p=standardizeCallbacks(n.callbacks),h=configureCallbacks(p,n.yieldEvery,n.verbose,n.epochs,null,null,n.batchesPerEpoch,null,i,c),d=h.callbackList,f=h.history,e.history=f,[4,d.onTrainBegin()];case 2:return k.sent(),g=null==n.initialEpoch?0:n.initialEpoch,m={},[4,t.iterator()];case 3:y=k.sent(),k.label=4;case 4:return g<n.epochs?[4,d.onEpochBegin(g)]:[3,18];case 5:return k.sent(),v=0,b=0,r?[3,7]:[4,t.iterator()];case 6:y=k.sent(),k.label=7;case 7:return!r||v<n.batchesPerEpoch?[4,y.next()]:[3,16];case 8:if(w=k.sent(),r&&w.done)return console.warn("You provided `batchesPerEpoch` as "+n.batchesPerEpoch+", but your dataset iterator ran out of data after "+v+" batches; interrupting training. Make sure that your dataset can generate at least `batchesPerEpoch * epochs` batches (in this case, "+n.batchesPerEpoch*n.epochs+" batches). You may need to use the repeat() function when building your dataset."),[3,16];if(null==w.value)return[3,10];for(z=standardizeDataIteratorOutput(e,w.value),(S={}).batch=b,S.size=z[0].shape[0],d.onBatchBegin(b,S),I=l(z),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(z),E=0;E<u.length;++E)N=u[E],C=I[E],S[N]=C,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["keep"])(C);return[4,d.onBatchEnd(b,S)];case 9:k.sent(),disposeTensorsInLogs(S),b++,v++,k.label=10;case 10:return(r?v>=n.batchesPerEpoch:w.done)?i?(A=void 0,isDatasetObject(n.validationData)?(_=toList,[4,e.evaluateDataset(n.validationData,{batches:n.validationBatches})]):[3,12]):[3,14]:[3,15];case 11:return A=_.apply(void 0,[k.sent()]),[3,13];case 12:A=toList(e.evaluate(a,o,{batchSize:null==n.validationBatchSize?DEFAULT_VALIDATION_BATCH_SIZE:n.validationBatchSize,verbose:0})),k.label=13;case 13:for(E=0;E<e.metricsNames.length;++E)m["val_"+e.metricsNames[E]]=A[E];k.label=14;case 14:return[3,16];case 15:return e.stopTraining_?[3,16]:[3,7];case 16:return[4,d.onEpochEnd(g,m)];case 17:return k.sent(),g++,e.stopTraining_?[3,18]:[3,4];case 18:return[4,d.onTrainEnd()];case 19:return k.sent(),[4,e.history.syncData()];case 20:return k.sent(),[2,e.history];case 21:return e.isTraining=!1,[7];case 22:return[2]}})})}function isDatasetObject(e){return"function"==typeof e.iterator}function isLazyIteratorObject(e){return"function"==typeof e.next}function evaluateDataset(e,t,n){return __awaiter(this,void 0,void 0,function(){var r,i,a,o,s,l,u,c,p,h;return __generator(this,function(d){switch(d.label){case 0:if(r=null!=n.batches,i=e.testFunction,a=[],n.verbose>0)throw new NotImplementedError("Verbose mode is not implemented yet.");return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(!r||n.batches>0&&Number.isInteger(n.batches),"Test loop expects `batches` to be a positive integer, but received "+JSON.stringify(n.batches)),isLazyIteratorObject(t)?(s=t,[3,3]):[3,1];case 1:return[4,t.iterator()];case 2:s=d.sent(),d.label=3;case 3:o=s,l=0,u=0,c=function(){var t,s,c,p,h,d;return __generator(this,function(f){switch(f.label){case 0:return[4,o.next()];case 1:if((t=f.sent()).value){if(s=standardizeDataIteratorOutput(e,t.value),c=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return i(s)}),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(s),0===u)for(d=0;d<c.length;++d)a.push(getScalar(0));for(p=s[0].shape[0],h=function(e){var t=c[e],n=a[e];a[e]=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(a[e],Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(getScalar(p),t))}),u>0&&Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(n)},d=0;d<c.length;++d)h(d);Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(c),l+=p,++u}return t.done?(r&&console.warn("Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least `batches` batches (in this case, "+n.batches+" batches). You may need to use the repeat() function when building your dataset."),[2,"break"]):[2]}})},d.label=4;case 4:return!r||u<n.batches?[5,c()]:[3,6];case 5:return"break"===d.sent()?[3,6]:[3,4];case 6:for(p=function(e){var t=a[e];a[e]=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"])(a[e],getScalar(l))}),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(t)},h=0;h<a.length;++h)p(h);return[2,singletonOrArray(a)]}})})}function checkBatchSize(e){_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(e>0&&Number.isInteger(e),"batchSize is required to be a positive integer, but got "+e)}function sliceArrays(e,t,n){return null==e?[null]:Array.isArray(e)?e.map(function(e){return sliceAlongFirstAxis(e,t,n-t)}):sliceAlongFirstAxis(e,t,n-t)}function sliceArraysByIndices(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return null==e?null:Array.isArray(e)?e.map(function(e){return sliceArraysByIndices(e,t)}):gather$1(e,"int32"===t.dtype?t:t.toInt())})}function makeBatches(e,t){for(var n=[],r=0,i=null;r<e;)(i=r+t)>=e&&(i=e),n.push([r,i]),r=i;return n}function fitLoop(e,t,n,r,i,a,o,s,l,u,c,p,h,d,f,g){return __awaiter(this,void 0,void 0,function(){var m,y,v,b,w,z,S,I;return __generator(this,function(N){switch(N.label){case 0:if(null==i&&(i=32),null==a&&(a=1),null==c&&(c=!0),null==h&&(h=0),m=!1,null!=l&&null!=u&&(m=!0),null!=f&&(m=!0,null==d))throw new ValueError("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");return null!=(y=e.checkNumSamples(n,i,d,"steps_per_epoch"))&&(v=range(0,y)),null==o&&(o=1),b=configureCallbacks(s,g,o,a,h,y,d,i,m,p),w=b.callbackList,z=b.history,w.setModel(e),e.history=z,[4,w.onTrainBegin()];case 1:N.sent(),e.stopTraining_=!1,S=function(a){var o,s,p,h,f;return __generator(this,function(g){switch(g.label){case 0:return[4,w.onEpochBegin(a)];case 1:if(g.sent(),o={},null==d)return[3,2];throw new NotImplementedError("stepsPerEpoch mode is not implemented yet.");case 2:if("batch"===c)throw new NotImplementedError("batch shuffling is not implemneted yet");c&&_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].shuffle(v),s=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor1d"])(v),p=makeBatches(y,i),h=function(a){var c;return __generator(this,function(h){switch(h.label){case 0:return c={},[4,w.onBatchBegin(a,c)];case 1:return h.sent(),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var h=p[a][0],d=p[a][1],f=sliceAlongFirstAxis(s,h,d-h);c.batch=a,c.size=d-h;for(var g=sliceArraysByIndices(n,f),y=t(g),v=0;v<r.length;++v){var b=r[v],w=y[v];c[b]=w,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["keep"])(w)}if(a===p.length-1&&m){var z=e.testLoop(l,u,i);for(v=0;v<r.length;++v){b=r[v],w=z[v];Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["keep"])(w),o["val_"+b]=w}}}),[4,w.onBatchEnd(a,c)];case 2:return h.sent(),disposeTensorsInLogs(c),e.stopTraining_?[2,"break"]:[2]}})},f=0,g.label=3;case 3:return f<p.length?[5,h(f)]:[3,6];case 4:if("break"===g.sent())return[3,6];g.label=5;case 5:return++f,[3,3];case 6:s.dispose(),g.label=7;case 7:return[4,w.onEpochEnd(a,o)];case 8:return g.sent(),e.stopTraining_?[2,"break"]:[2]}})},I=h,N.label=2;case 2:return I<a?[5,S(I)]:[3,5];case 3:if("break"===N.sent())return[3,5];N.label=4;case 4:return++I,[3,2];case 5:return[4,w.onTrainEnd()];case 6:return N.sent(),[4,e.history.syncData()];case 7:return N.sent(),[2,e.history]}})})}function fitTensors(e,t,n,r){return void 0===r&&(r={}),__awaiter(this,void 0,void 0,function(){var i,a,o,s,l,u,c,p,h,d,f,g,m,y,v,b,w,z,S,I;return __generator(this,function(N){switch(N.label){case 0:if(e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0,N.label=1;case 1:if(N.trys.push([1,,3,4]),checkBatchSize(c=null==r.batchSize?32:r.batchSize),p=e.standardizeUserData(t,n,!1,c),i=p[0],a=p[1],h=!1,d=void 0,null!=r.validationData&&r.validationData.length>0){if(h=!0,2!==r.validationData.length)throw 3===r.validationData.length?new NotImplementedError("validationData including sample weights is not supported yet."):new ValueError("When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; "+r.validationData+" is invalid.");o=r.validationData[0],s=r.validationData[1],f=e.standardizeUserData(o,s,!0,c),l=f[0],u=f[1],d=l.concat(u)}else null!=r.validationSplit&&r.validationSplit>0&&r.validationSplit<1?(h=!0,g=Math.floor(i[0].shape[0]*(1-r.validationSplit)),m=i[0].shape[0],l=sliceArrays(i,g,m),i=sliceArrays(i,0,g),u=sliceArrays(a,g,m),a=sliceArrays(a,0,g),d=l.concat(u)):null!=r.validationSteps&&(h=!0);return y=i.concat(a),e.checkTrainableWeightsConsistency(),v=e.makeTrainFunction(),b=e.getDedupedMetricsNames(),w=void 0,z=void 0,h?(e.makeTestFunction(),w=e.testFunction,z=b.slice().concat(b.map(function(e){return"val_"+e}))):(w=null,d=[],z=b.slice()),S=standardizeCallbacks(r.callbacks),[4,fitLoop(e,v,y,b,c,r.epochs,r.verbose,S,w,d,r.shuffle,z,r.initialEpoch,null,null,r.yieldEvery)];case 2:return I=N.sent(),e.isTraining=!1,[2,I];case 3:return e.isTraining=!1,disposeNewTensors(i,t),disposeNewTensors(a,n),disposeNewTensors(l,o),disposeNewTensors(u,s),[7];case 4:return[2]}})})}function ensureTensorsRank2OrHigher(e){var t=[];e instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Tensor"]&&(e=[e]);for(var n=0;n<e.length;++n){var r=e[n];if(1===r.rank)t.push(expandDims(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function disposeNewTensors(e,t){if(null!=e){var n=[];if(t instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Tensor"])n.push(t.id);else if(Array.isArray(t))t.forEach(function(e){return n.push(e.id)});else if(null!=t)for(var r in t){var i=t[r];n.push(i.id)}var a=[];if(e instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Tensor"])-1===n.indexOf(e.id)&&a.push(e);else if(Array.isArray(e))e.forEach(function(e){-1===n.indexOf(e.id)&&a.push(e)});else if(null!=e)for(var o in e){var s=e[o];-1===n.indexOf(s.id)&&a.push(s)}a.forEach(function(e){e.isDisposed||e.dispose()})}}function isDataTensor(e){return e instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Tensor"]}function isDataArray(e){return Array.isArray(e)}function isDataDict(e){return!isDataTensor(e)&&!isDataArray(e)}function standardizeInputData(e,t,n,r,i){if(void 0===r&&(r=!0),void 0===i&&(i=""),null==t||0===t.length){if(null!=e){var a=!1;if(isDataArray(e)&&e.length>0)a=!0;else if(isDataDict(e)){for(var o in e)if(e.hasOwnProperty(o)){a=!0;break}}else a=!0;if(a)throw new ValueError("Error when checking model "+i+" expected no data, but got "+e)}return[]}if(null==e)return t.map(function(e){return null});var s;if(isDataDict(e)){e=e,s=[];for(var l=0,u=t;l<u.length;l++){var c=u[l];if(null==e[c])throw new ValueError('No data provided for "'+c+'". Need data for each key in: '+t);s.push(e[c])}}else if(isDataArray(e)){if((e=e).length!==t.length)throw new ValueError("Error when checking model "+i+": the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see "+t.length+" Tensor(s), but instead got the following list of Tensor(s): "+e);s=e}else{if(e=e,t.length>1)throw new ValueError("The model "+i+" expects "+t.length+" Tensor(s), but only received one Tensor. Found: Tensor with shape "+e.shape);s=[e]}if(s=ensureTensorsRank2OrHigher(s),null!=n)for(var p=0;p<t.length;++p)if(null!=n[p]){var h=s[p];if(h.shape.length!==n[p].length)throw new ValueError("Error when checking "+i+": expected "+t[p]+" to have "+n[p].length+" dimension(s). but got array with shape "+h.shape);for(var d=0;d<n[p].length;++d)if(0!==d||r){var f=h.shape[d],g=n[p][d];if(null!=g&&g>=0&&f!==g)throw new ValueError("Error when checking "+i+": expected "+t[p]+" to have shape ["+n[p]+"], but got array with shape ["+h.shape+"].")}}return s}function checkArrayLengths(e,t,n){var r=unique(e.map(function(e){return e.shape[0]}));r.sort();var i=unique(t.map(function(e){return e.shape[0]}));if(i.sort(),r.length>1)throw new ValueError("All input Tensors (x) should have the same number of samples. Got array shapes: "+JSON.stringify(e.map(function(e){return e.shape})));if(i.length>1)throw new ValueError("All target Tensors (y) should have the same number of samples. Got array shapes: "+JSON.stringify(t.map(function(e){return e.shape})));if(r.length>0&&i.length>0&&!_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].arraysEqual(r,i))throw new ValueError("Input Tensors should have the same number of samples as target Tensors. Found "+r[0]+" input sample(s) and "+i[0]+" target sample(s).")}function checkLossAndTargetCompatibility(e,t,n){for(var r=[meanSquaredError,binaryCrossentropy,categoricalCrossentropy],i=0;i<e.length;++i){var a=e[i],o=t[i],s=n[i];if(null!=o){if(o===categoricalCrossentropy&&1===a.shape[a.shape.length-1])throw new ValueError("You are passing a target array of shape "+a.shape+" while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].");if(-1!==r.indexOf(o))for(var l=a.shape.slice(1),u=s.slice(1),c=0;c<l.length;++c){var p=l[c],h=u[c];if(null!=h&&p!==h)throw new ValueError("A target Tensor with shape "+a.shape+" was passed for an output of shape "+s+", while using a loss function that expects targets to have the same shape as the output.")}}}}function checkInputData(e,t,n,r,i){var a;if(void 0===r&&(r=!0),void 0===i&&(i=""),Array.isArray(e)){if(e.length!==t.length)throw new ValueError("Error when checking model "+i+": the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see "+t.length+" Tensor(s), but instead got "+e.length+" Tensors(s).");a=e}else{if(t.length>1)throw new ValueError("The model expects "+t.length+" "+i+" Tensors, but only received one Tensor. Found: array with shape "+JSON.stringify(e.shape)+".");a=[e]}if(null!=n)for(var o=0;o<t.length;++o)if(null!=n[o]){var s=a[o];if(s.shape.length!==n[o].length)throw new ValueError("Error when checking "+i+": expected "+t[o]+" to have "+n[o].length+" dimension(s), but got array with shape "+JSON.stringify(s.shape));for(var l=0;l<n[o].length;++l)if(0!==l||r){var u=s.shape[l],c=n[o][l];if(null!=c&&c!==u)throw new ValueError("Error when checking "+i+": expected "+t[o]+" to have shape "+JSON.stringify(n[o])+" but got array with shape "+JSON.stringify(s.shape)+".")}}}function collectMetrics(e,t){if(null==e||Array.isArray(e)&&0===e.length)return t.map(function(e){return[]});if(Array.isArray(e))return t.map(function(t){return e});if(null!=e){for(var n=[],r=0,i=t;r<i.length;r++){var a=i[r],o=e.hasOwnProperty(a)?e[a]:[];Array.isArray(o)||(o=[o]),n.push(o)}return n}throw new TypeError("Type of metrics argument not understood. Expected an Array or Object, found: "+e)}var Model=function(e){function t(t){var n=e.call(this,t)||this;return n.isTraining=!1,n}return __extends(t,e),t.prototype.summary=function(e,t,n){if(void 0===n&&(n=console.log),!this.built)throw new ValueError("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");printSummary(this,e,t,n)},t.prototype.compile=function(e){var t=this;if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"==typeof e.optimizer)this.optimizer=getOptimizer(e.optimizer);else{if(!(e.optimizer instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Optimizer"]))throw new ValueError("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer=e.optimizer}var n=[];if(Array.isArray(e.loss)||"string"==typeof e.loss||"function"==typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new ValueError("When passing an Array as loss, it should have one entry per model output. The model has "+this.outputs.length+" output(s), but you passed loss="+e.loss+".");var r=e.loss;n=r.map(function(e){return get(e)})}else{var i=get(e.loss);this.outputs.map(function(e){n.push(i)})}else{for(var a in e.loss=e.loss,e.loss)if(-1===this.outputNames.indexOf(a))throw new ValueError('Unknown entry in loss dictionary: "'+a+'". Only expect the following keys: '+this.outputNames);for(var o in this.outputNames)null==e.loss[o]&&console.warn('Output "'+o+'" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to '+o+" during training"),n.push(get(e.loss[o]))}this.lossFunctions=n,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(var s=0;s<this.outputs.length;++s){var l=this.internalOutputShapes[s],u=this.outputNames[s];this.feedOutputNames.push(u),this.feedOutputShapes.push(l),this.feedLossFns.push(this.lossFunctions[s])}var c=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],nameScope("loss",function(){for(var e=0;e<t.outputs.length;++e)if(-1===c.indexOf(e)){var n=t.lossFunctions[e];t.outputs.length>1&&(t.metricsTensors.push([n,e]),t.metricsNames.push(t.outputNames[e]+"_loss"))}});var p=collectMetrics(e.metrics,this.outputNames);nameScope("metric",function(){for(var e=function(e){if(-1!==c.indexOf(e))return"continue";!function(n){for(var r,i,a,o=function(n){if(-1!==["accuracy","acc","crossentropy","ce"].indexOf(n)){var o=t.internalOutputShapes[e];1===o[o.length-1]||t.lossFunctions[e]===binaryCrossentropy?-1!==["accuracy","acc"].indexOf(n)?i=binaryAccuracy:-1!==["crossentropy","ce"].indexOf(n)&&(i=binaryCrossentropy$1):t.lossFunctions[e]===sparseCategoricalCrossentropy?-1!==["accuracy","acc"].indexOf(n)?i=sparseCategoricalAccuracy:-1!==["crossentropy","ce"].indexOf(n)&&(i=sparseCategoricalCrossentropy$1):-1!==["accuracy","acc"].indexOf(n)?i=categoricalAccuracy:-1!==["crossentropy","ce"].indexOf(n)&&(i=categoricalCrossentropy$1);var s=void 0;-1!==["accuracy","acc"].indexOf(n)?s="acc":-1!==["crossentropy","ce"].indexOf(n)&&(s="ce"),a=i,r=""+s}else{var l=get$1(n);a=l,r=""+n}var u;nameScope(r,function(){u=a}),function(e,n,r){t.outputNames.length>1&&(n=t.outputNames[e]+"_"+n),t.metricsNames.push(n),t.metricsTensors.push([r,e])}(e,r,u)},s=0,l=n;s<l.length;s++)o(l[s])}(p[e])},n=0;n<t.outputs.length;++n)e(n)}),this.collectedTrainableWeights=this.trainableWeights},t.prototype.checkTrainableWeightsConsistency=function(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")},t.prototype.evaluate=function(e,t,n){void 0===n&&(n={});var r=null==n.batchSize?32:n.batchSize;checkBatchSize(r);var i=this.standardizeUserData(e,t,!0,r);try{var a=i[0].concat(i[1]);this.makeTestFunction();var o=this.testFunction;return singletonOrArray(this.testLoop(o,a,r,n.verbose,n.steps))}finally{disposeNewTensors(i[0],e),disposeNewTensors(i[1],t)}},t.prototype.evaluateDataset=function(e,t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(n){return this.makeTestFunction(),[2,evaluateDataset(this,e,t)]})})},t.prototype.checkNumSamples=function(e,t,n,r){var i;if(void 0===r&&(r="steps"),null!=n){if(i=null,null!=t)throw new ValueError("If "+r+" is set, batchSize must be null or undefined.Got batchSize = "+t)}else{if(null==e)throw new ValueError("Either the input data should have a defined shape, or "+r+" shoud be specified.");i=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return i},t.prototype.execute=function(e,t){if(Array.isArray(t)&&0===t.length)throw new ValueError("`outputs` is an empty Array, which is not allowed.");var n=Array.isArray(t),r=n?t:[t],i=this.retrieveSymbolicTensors(r),a=new FeedDict;if(e instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Tensor"]&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new ValueError("The number of inputs provided ("+e.length+") does not match the number of inputs of this model ("+this.inputs.length+").");for(var o=0;o<this.inputs.length;++o)a.add(this.inputs[o],e[o])}else for(var s=0,l=this.inputs;s<l.length;s++){var u=l[s],c=e[u.name];if(null==c)throw new ValueError("No value is provided for the model's input "+u.name);a.add(u,c)}var p=execute(i,a);return n?p:p[0]},t.prototype.retrieveSymbolicTensors=function(e){for(var t=pyListRepeat(null,e.length),n=e.length,r=0,i=this.layers;r<i.length;r++){for(var a=i[r],o=Array.isArray(a.output)?a.output:[a.output],s=o.map(function(e){return e.name}),l=0;l<e.length;++l){var u=s.indexOf(e[l]);if(-1!==u&&(t[l]=o[u],n--),0===n)break}if(0===n)break}if(n>0){var c=[];throw t.forEach(function(t,n){null==t&&c.push(e[n])}),new ValueError("Cannot find SymbolicTensors for output name(s): "+JSON.stringify(c))}return t},t.prototype.predictLoop=function(e,t,n){var r=this;return void 0===t&&(t=32),void 0===n&&(n=!1),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var i=r.checkNumSamples(e);if(n)throw new NotImplementedError("Verbose predictLoop() is not implemented yet.");for(var a=makeBatches(i,t),o=[],s=function(t){var n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=a[t][0],i=a[t][1],o=sliceArrays(e,n,i),s=[];if(Array.isArray(o))for(var l=0;l<o.length;++l)s.push({key:r.inputs[l],value:o[l]});else s.push({key:r.inputs[0],value:o});var u=new FeedDict(s);return execute(r.outputs,u)});if(0===t)for(var i=0,s=n;i<s.length;i++){var l=s[i];o.push(l)}else for(var u=0;u<n.length;++u)o[u]=concatAlongFirstAxis(o[u],n[u])},l=0;l<a.length;++l)s(l);return singletonOrArray(o)})},t.prototype.predict=function(e,t){void 0===t&&(t={});var n=ensureTensorsRank2OrHigher(e);checkInputData(n,this.inputNames,this.feedInputShapes,!1);try{var r=null==t.batchSize?32:t.batchSize;return checkBatchSize(r),this.predictLoop(n,r)}finally{disposeNewTensors(n,e)}},t.prototype.predictOnBatch=function(e){return checkInputData(e,this.inputNames,this.feedInputShapes,!0),this.predictLoop(e,e.shape[0])},t.prototype.standardizeUserData=function(e,t,n,r){if(void 0===n&&(n=!0),null==this.optimizer)throw new RuntimeError("You must compile a model before training/testing. Use Model.compile(modelCompileConfig).");for(var i=[],a=0;a<this.feedOutputShapes.length;++a){var o=this.feedOutputShapes[a];this.feedLossFns[a]===sparseCategoricalCrossentropy?i.push(o.slice(0,o.length-1).concat([1])):i.push(o)}if(checkArrayLengths(e=standardizeInputData(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=standardizeInputData(t,this.feedOutputNames,i,!1,"target"),null),checkLossAndTargetCompatibility(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=r&&r>0&&e[0].shape[0]%r!=0)throw new ValueError("In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size "+r+". Found: "+e[0].shape[0]+" sample(s).");return[e,t,null]},t.prototype.testLoop=function(e,t,n,r,i){var a=this;return void 0===r&&(r=0),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var o=a.checkNumSamples(t,n,i,"steps"),s=[];if(r>0)throw new NotImplementedError("Verbose mode is not implemented yet.");if(null!=i)throw new NotImplementedError("steps mode in testLoop() is not implemented yet");for(var l=makeBatches(o,n),u=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor1d"])(range(0,o)),c=0;c<l.length;++c){var p=l[c][0],h=l[c][1],d=sliceAlongFirstAxis(u,p,h-p),f=sliceArraysByIndices(t,d),g=e(f);if(0===c)for(var m=0;m<g.length;++m)s.push(getScalar(0));for(m=0;m<g.length;++m){var y=g[m];s[m]=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(s[m],Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(getScalar(h-p),y))}}for(m=0;m<s.length;++m)s[m]=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"])(s[m],getScalar(o));return s})},t.prototype.getDedupedMetricsNames=function(){for(var e=this.metricsNames,t=[],n=0;n<e.length;++n){var r=e[n],i=r;if(count(e,r)>1)i+="_"+count(e.slice(0,n),r);t.push(i)}return t},t.prototype.makeTrainFunction=function(){var e=this;return function(t){var n=t.slice(0,e.inputs.length),r=t.slice(e.inputs.length,e.inputs.length+e.outputs.length),i=[],a=e.collectedTrainableWeights.map(function(e){return e.read()});return[e.optimizer.minimize(function(){for(var t=[],a=0;a<e.inputs.length;++a)t.push({key:e.inputs[a],value:n[a]});var o,s=new FeedDict(t),l=execute(e.outputs,s,{training:!0});for(a=0;a<e.lossFunctions.length;++a){var u=(0,e.lossFunctions[a])(r[a],l[a]);Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(u),o=0===a?u:Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(o,u)}for(a=0;a<e.metricsTensors.length;++a){var c=e.metricsTensors[a][0],p=e.metricsTensors[a][1],h=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(c(r[p],l[p]));Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["keep"])(h),i.push(h)}return o=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(o),e.calculateLosses().forEach(function(e){o=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(o,e)}),o},!0,a)].concat(i)}},t.prototype.makeTestFunction=function(){var e=this;this.testFunction=function(t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){for(var n,r=[],i=t.slice(0,e.inputs.length),a=t.slice(e.inputs.length,e.inputs.length+e.outputs.length),o=[],s=0;s<e.inputs.length;++s)o.push({key:e.inputs[s],value:i[s]});var l=new FeedDict(o),u=execute(e.outputs,l);for(s=0;s<e.lossFunctions.length;++s){var c=e.lossFunctions[s],p=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(c(a[s],u[s]));n=0===s?p:Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(n,p),r.push(n)}for(s=0;s<e.metricsTensors.length;++s){var h=e.metricsTensors[s][0],d=e.metricsTensors[s][1],f=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(h(a[d],u[d]));r.push(f)}return r})}},t.prototype.fit=function(e,t,n){return void 0===n&&(n={}),__awaiter(this,void 0,void 0,function(){return __generator(this,function(r){return[2,fitTensors(this,e,t,n)]})})},t.prototype.fitDataset=function(e,t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(n){return[2,fitDataset(this,e,t)]})})},t.prototype.getNamedWeights=function(e){for(var t={},n=null!=e&&e.trainableOnly,r=n?this.trainableWeights:this.weights,i=this.getWeights(n),a=0;a<r.length;++a)n&&!r[a].trainable||(t[r[a].originalName]=i[a]);return t},Object.defineProperty(t.prototype,"stopTraining",{set:function(e){this.stopTraining_=e},enumerable:!0,configurable:!0}),t.prototype.save=function(e,t){return __awaiter(this,void 0,void 0,function(){var n,r,i,a,o;return __generator(this,function(s){switch(s.label){case 0:if("string"==typeof e){if(0===(n=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["io"].getSaveHandlers(e)).length)throw new ValueError("Cannot find any save handlers for URL '"+e+"'");if(n.length>1)throw new ValueError("Found more than one ("+n.length+") save handlers for URL '"+e+"'");e=n[0]}if(null==e.save)throw new ValueError("Model.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return[4,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["io"].encodeWeights(this.getNamedWeights(t))];case 1:return r=s.sent(),i=!1,a=null,o=this.toJSON(a,i),[2,e.save({modelTopology:o,weightData:r.data,weightSpecs:r.specs})]}})})},t.className="Model",t}(Container);function modelFromJSON(e,t){return __awaiter(this,void 0,void 0,function(){var n,r,i,a,o,s,l,u,c,p;return __generator(this,function(h){switch(h.label){case 0:return"modelTopology"in e||(e={modelTopology:e}),null!=(n=(e=e).modelTopology).model_config&&(n=n.model_config),r=convertPythonicToTs(n),i=deserialize(r,t),null==e.weightsManifest?[3,2]:[4,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["io"].loadWeights(e.weightsManifest,e.pathPrefix,i.weights.map(function(e){return e.originalName}))];case 1:for(a=h.sent(),o={},s=0,l=i.weights;s<l.length;s++)u=l[s],o[u.originalName]=a[u.originalName];c=null,p=!0,i.loadWeights(o,c,p),h.label=2;case 2:return[2,i]}})})}function loadModelInternal(e,t){return void 0===t&&(t=!0),__awaiter(this,void 0,void 0,function(){var n;return __generator(this,function(r){if("string"==typeof e){if(0===(n=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["io"].getLoadHandlers(e)).length)n.push(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["io"].browserHTTPRequest(e));else if(n.length>1)throw new ValueError("Found more than one ("+n.length+") load handlers for URL '"+e+"'");e=n[0]}return[2,loadModelFromIOHandler(e,void 0,t)]})})}function loadModelFromIOHandler(e,t,n){return void 0===n&&(n=!0),__awaiter(this,void 0,void 0,function(){var r,i,a,o,s;return __generator(this,function(l){switch(l.label){case 0:if(null==e.load)throw new ValueError("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");return[4,e.load()];case 1:if(r=l.sent(),null!=(i=r.modelTopology).model_config&&(i=i.model_config),a=deserialize(convertPythonicToTs(i),t),null!=r.weightData){if(null==r.weightSpecs)throw new ValueError("Model artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");o=!1,s=!0,a.loadWeights(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["io"].decodeWeights(r.weightData,r.weightSpecs),o,s,n)}return[2,a]}})})}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Model);var Sequential=function(e){function t(t){var n=e.call(this,{inputs:[],outputs:[]})||this;if(t=t||{},n.trainable=!0,n._updatable=!0,n.built=!1,n.name=null!=t.name?t.name:getUid("sequential_"),null!=t.layers)for(var r=0,i=t.layers;r<i.length;r++){var a=i[r];n.add(a)}return n}return __extends(t,e),t.prototype.checkShape=function(e){if(e.inboundNodes[0].outputTensors[0].shape.some(function(e){return e<0}))throw new ValueError("Negative dimension size caused by adding layer "+e.name+" with input shape ["+e.inboundNodes[0].inputTensors[0].shape+"]")},t.prototype.add=function(e){var n,r=e instanceof t||e instanceof Model;if(r){if(1!==(n=e).outputs.length)throw new ValueError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==n.inputs.length)throw new ValueError("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new ValueError("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");var i=Input({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(i)}if(r)this.outputs=n.outputs,this.inputs=n.inputs;else{if(1!==e.inboundNodes.length)throw new ValueError("A layer added to a Sequential model must not already be connected somewhere else. Model received layer "+e.name+" which has "+e.inboundNodes.length+" pre-existing inbound connections.");if(1!==e.inboundNodes[0].outputTensors.length)throw new ValueError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=getSourceInputs(this.outputs[0])}this.inboundNodes=[],new Node({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:pyListRepeat(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(function(e){return e.shape}),outputShapes:this.outputs[0].shape})}else{var a=e.apply(this.outputs[0]);if(Array.isArray(a))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[a],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1},t.prototype.pop=function(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{var e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}},t.prototype.call=function(e,t){return null==this.model&&this.build(),this.model.call(e,t)},t.prototype.build=function(e){if(getExactlyOneShape(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Model({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.model.updatable=this.updatable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0},t.prototype.countParams=function(){return this.built||this.build(),e.prototype.countParams.call(this)},t.prototype.summary=function(t,n,r){void 0===r&&(r=console.log),this.built||this.build(),e.prototype.summary.call(this,t,n,r)},t.prototype.setWeights=function(e){null==this.model&&this.build(),this.model.setWeights(e)},Object.defineProperty(t.prototype,"updatable",{get:function(){return this._updatable},set:function(e){this.built&&(this.model.updatable=e),this._updatable=e},enumerable:!0,configurable:!0}),t.prototype.evaluate=function(e,t,n){if(void 0===n&&(n={}),!this.built)throw new RuntimeError("The model needs to be compiled before being used.");return this.model.evaluate(e,t,n)},t.prototype.evaluateDataset=function(e,t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(n){if(!this.built)throw new RuntimeError("The model needs to be compiled before being used.");return[2,this.model.evaluateDataset(e,t)]})})},t.prototype.predict=function(e,t){return void 0===t&&(t={}),null==this.model&&this.build(),this.model.predict(e,t)},t.prototype.predictOnBatch=function(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)},t.prototype.compile=function(e){this.build(),this.model.compile(e),this.optimizer=this.model.optimizer,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames},t.prototype.fit=function(e,t,n){return void 0===n&&(n={}),__awaiter(this,void 0,void 0,function(){return __generator(this,function(r){if(!this.built)throw new RuntimeError("The model needs to be compiled before being used.");return[2,this.model.fit(e,t,n)]})})},t.prototype.fitDataset=function(e,t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(n){if(!this.built)throw new RuntimeError("The model needs to be compiled before being used.");return[2,this.model.fitDataset(e,t)]})})},t.fromConfig=function(e,n){var r,i={};if(n instanceof Array){if(null==n[0].className||"Merge"===n[0].className)throw new ValueError("Legacy serialization format not supported yet.");r=n}else _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(null!=n.layers,"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),r=n.layers,delete n.layers,i=n;var a=new e(i);if(!(a instanceof t))throw new NotImplementedError("Sequential.fromConfig called on non-Sequential input: "+a);for(var o=0,s=r;o<s.length;o++){var l=deserialize(s[o]);a.add(l)}return a},Object.defineProperty(t.prototype,"stopTraining",{set:function(e){this.model.stopTraining=e},enumerable:!0,configurable:!0}),t.prototype.getConfig=function(){for(var e=[],t=0,n=this.layers;t<n.length;t++){var r=n[t];e.push({className:r.getClassName(),config:r.getConfig()})}return e},t.className="Sequential",t}(Model);function model(e){return new Model(e)}function sequential(e){return new Sequential(e)}function loadModel(e,t){return void 0===t&&(t=!0),loadModelInternal(e,t)}function input(e){return Input(e)}function registerCallbackConstructor(e,t){CallbackConstructorRegistry.registerCallbackConstructor(e,t)}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Sequential);var Activation=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.getConfig=function(){return{}},t}(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].Serializable),Elu=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.apply=function(e,t){return void 0===t&&(t=1),elu$1(e,t)},t.className="elu",t}(Activation);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Elu);var Selu=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.apply=function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["selu"])(e)},t.className="selu",t}(Activation);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Selu);var Relu=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.apply=function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["relu"])(e)},t.className="relu",t}(Activation);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Relu);var Relu6=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.apply=function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["minimum"])(getScalar(6),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["relu"])(e))})},t.className="relu6",t}(Activation);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Relu6);var Linear=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.apply=function(e){return e},t.className="linear",t}(Activation);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Linear);var Sigmoid=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.apply=function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sigmoid"])(e)},t.className="sigmoid",t}(Activation);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Sigmoid);var HardSigmoid=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.apply=function(e){return hardSigmoid(e)},t.className="hardSigmoid",t}(Activation);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(HardSigmoid);var Softplus=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.apply=function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["softplus"])(e)},t.className="softplus",t}(Activation);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Softplus);var Softsign=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.apply=function(e){return softsign(e)},t.className="softsign",t}(Activation);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Softsign);var Tanh=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.apply=function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tanh"])(e)},t.className="tanh",t}(Activation);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Tanh);var Softmax=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.apply=function(e,t){return void 0===t&&(t=-1),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["softmax"])(e,t)},t.className="softmax",t}(Activation);function serializeActivation(e){return e.getClassName()}function deserializeActivation(e,t){return void 0===t&&(t={}),deserializeKerasObject(e,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].SerializationMap.getMap().classNameMap,t,"activation")}function getActivation(e){return null==e?deserializeActivation({className:"linear",config:{}}):"string"==typeof e?deserializeActivation({className:e,config:{}}):e instanceof Activation?e:deserializeActivation(e)}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Softmax);var ReLU=function(e){function t(t){var n=e.call(this,null==t?{}:t)||this;return n.supportsMasking=!0,null!=t&&(n.maxValue=t.maxValue),n}return __extends(t,e),t.prototype.call=function(e,t){e=getExactlyOneTensor(e);var n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["relu"])(e);return null!=this.maxValue&&(n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clipByValue"])(n,0,this.maxValue)),n},t.prototype.computeOutputShape=function(e){return e},t.prototype.getConfig=function(){var t={maxValue:this.maxValue},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="ReLU",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(ReLU);var LeakyReLU=function(e){function t(t){var n=e.call(this,null==t?{}:t)||this;return n.DEFAULT_ALPHA=.3,null==t&&(t={}),n.alpha=null==t.alpha?n.DEFAULT_ALPHA:t.alpha,n}return __extends(t,e),t.prototype.call=function(e,t){var n=getExactlyOneTensor(e);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["leakyRelu"])(n,this.alpha)},t.prototype.computeOutputShape=function(e){return e},t.prototype.getConfig=function(){var t={alpha:this.alpha},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="LeakyReLU",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(LeakyReLU);var ELU=function(e){function t(t){var n=e.call(this,null==t?{}:t)||this;if(n.DEFAULT_ALPHA=1,null==t&&(t={}),null!=t.alpha&&t.alpha!==n.DEFAULT_ALPHA)throw new NotImplementedError("Non-default alpha value ("+t.alpha+") is not supported by the ELU layer yet.");return n.alpha=null==t.alpha?n.DEFAULT_ALPHA:t.alpha,n}return __extends(t,e),t.prototype.call=function(e,t){var n=getExactlyOneTensor(e);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["elu"])(n)},t.prototype.computeOutputShape=function(e){return e},t.prototype.getConfig=function(){var t={alpha:this.alpha},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="ELU",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(ELU);var ThresholdedReLU=function(e){function t(t){var n=e.call(this,null==t?{}:t)||this;return n.DEFAULT_THETA=1,null==t&&(t={}),n.theta=null==t.theta?n.DEFAULT_THETA:t.theta,n.thetaTensor=getScalar(n.theta),n}return __extends(t,e),t.prototype.call=function(e,t){var n=getExactlyOneTensor(e);return n.mul(cast$1(n.greater(this.thetaTensor),"float32"))},t.prototype.computeOutputShape=function(e){return e},t.prototype.getConfig=function(){var t={theta:this.theta},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="ThresholdedReLU",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(ThresholdedReLU);var Softmax$1=function(e){function t(t){var n=e.call(this,null==t?{}:t)||this;return n.DEFAULT_AXIS=1,null==t&&(t={}),n.softmax=(new Softmax).apply,n.axis=null==t.axis?n.DEFAULT_AXIS:t.axis,n}return __extends(t,e),t.prototype.call=function(e,t){var n=getExactlyOneTensor(e);return this.softmax(n,this.axis)},t.prototype.computeOutputShape=function(e){return e},t.prototype.getConfig=function(){var t={axis:this.axis},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="Softmax",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Softmax$1);var Regularizer=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t}(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].Serializable),L1L2=function(e){function t(t){var n=e.call(this)||this,r=null==t||null==t.l1?.01:t.l1,i=null==t||null==t.l2?.01:t.l2;return n.hasL1=0!==r,n.hasL2=0!==i,n.l1=getScalar(r),n.l2=getScalar(i),n}return __extends(t,e),t.prototype.apply=function(e){var t=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["zeros"])([1]);return t.hasL1&&(n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(n,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sum"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(t.l1,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["abs"])(e))))),t.hasL2&&(n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(n,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sum"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(t.l2,square(e))))),n.asScalar()})},t.prototype.getConfig=function(){return{l1:this.l1.dataSync()[0],l2:this.l2.dataSync()[0]}},t.fromConfig=function(e,t){return new e({l1:t.l1,l2:t.l2})},t.className="L1L2",t}(Regularizer);function l1(e){return new L1L2({l1:null!=e?e.l1:null,l2:0})}function l2(e){return new L1L2({l2:null!=e?e.l2:null,l1:0})}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(L1L2);var REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP={l1l2:"L1L2"};function serializeRegularizer(e){return serializeKerasObject(e)}function deserializeRegularizer(e,t){return void 0===t&&(t={}),deserializeKerasObject(e,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].SerializationMap.getMap().classNameMap,t,"regularizer")}function getRegularizer(e){return null==e?null:"string"==typeof e?deserializeRegularizer({className:e in REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP?REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP[e]:e,config:{}}):e instanceof Regularizer?e:deserializeRegularizer(e)}function normalizeArray(e,t,n){if("number"==typeof e)return pyListRepeat(e,t);if(e.length!==t)throw new ValueError("The "+n+" argument must be a tuple of "+t+" integers. Received: "+e.length+" elements.");for(var r=0;r<t;++r){var i=e[r];if(!isInteger(i))throw new ValueError("The "+n+" argument must be a tuple of "+t+" integers. Received: "+JSON.stringify(e)+" including a non-integer number "+i)}return e}function convOutputLength(e,t,n,r,i){return void 0===i&&(i=1),null==e?e:(a="same"===n?e:e-(t+(t-1)*(i-1))+1,Math.floor((a+r-1)/r));var a}function deconvLength(e,t,n,r){if(null==e)return null;if("valid"===r)e=e*t+max$1([n-t,0]);else{if("same"!==r)throw new ValueError("Unsupport padding mode: "+r+".");e*=t}return e}function preprocessConv2DInput(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return checkDataFormat(t),"channelsFirst"===t?Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(e,[0,2,3,1]):e})}function conv1dWithBias(e,t,n,r,i,a,o){return void 0===r&&(r=1),void 0===i&&(i="valid"),void 0===o&&(o=1),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(null==a&&(a=imageDataFormat()),checkDataFormat(a),3!==e.shape.length)throw new ValueError("The input of a conv1dWithBias operation should be 3, but is "+e.shape.length+" instead.");if(3!==t.shape.length)throw new ValueError("The kernel for a conv1dWithBias operation should be 3, but is "+t.shape.length+" instead");if(null!=n&&1!==n.shape.length)throw new ValueError("The bias for a conv1dWithBias operation should be 1, but is "+t.shape.length+" instead");if("channelsFirst"===a&&(e=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(e,[0,2,1])),"causal"===i)throw new NotImplementedError("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");var s=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["conv1d"])(e,t,r,"same"===i?"same":"valid","NWC",o);return null!=n&&(s=biasAdd(s,n)),s})}function conv2dWithBias(e,t,n,r,i,a,o){return void 0===r&&(r=[1,1]),void 0===i&&(i="valid"),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(null==a&&(a=imageDataFormat()),checkDataFormat(a),3!==e.rank&&4!==e.rank)throw new ValueError("conv2dWithBias expects input to be of rank 3 or 4, but received "+e.rank+".");if(3!==t.rank&&4!==t.rank)throw new ValueError("conv2dWithBias expects kernel to be of rank 3 or 4, but received "+e.rank+".");var s=preprocessConv2DInput(e,a);if("causal"===i)throw new NotImplementedError("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return s=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["conv2d"])(s,t,r,"same"===i?"same":"valid","NHWC",o),null!=n&&(s=biasAdd(s,n)),"channelsFirst"===a&&(s=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(s,[0,3,1,2])),s})}var BaseConv=function(e){function t(n,r){var i=e.call(this,r)||this;if(i.bias=null,i.DEFAULT_KERNEL_INITIALIZER="glorotNormal",i.DEFAULT_BIAS_INITIALIZER="zeros",t.verifyConfig(r),i.rank=n,1!==i.rank&&2!==i.rank)throw new NotImplementedError("Convolution layer for rank other than 1 or 2 ("+i.rank+") is not implemented yet.");if(i.kernelSize=normalizeArray(r.kernelSize,n,"kernelSize"),i.strides=normalizeArray(null==r.strides?1:r.strides,n,"strides"),i.padding=null==r.padding?"valid":r.padding,checkPaddingMode(i.padding),i.dataFormat=null==r.dataFormat?"channelsLast":r.dataFormat,checkDataFormat(i.dataFormat),i.activation=getActivation(r.activation),i.useBias=null==r.useBias||r.useBias,i.biasInitializer=getInitializer(r.biasInitializer||i.DEFAULT_BIAS_INITIALIZER),i.biasConstraint=getConstraint(r.biasConstraint),i.biasRegularizer=getRegularizer(r.biasRegularizer),i.activityRegularizer=getRegularizer(r.activityRegularizer),i.dilationRate=normalizeArray(null==r.dilationRate?1:r.dilationRate,n,"dilationRate"),1===i.rank&&Array.isArray(i.dilationRate)&&1!==i.dilationRate.length)throw new ValueError("dilationRate must be a number or an array of a single number for 1D convolution, but received "+JSON.stringify(i.dilationRate));if(2===i.rank)if("number"==typeof i.dilationRate)i.dilationRate=[i.dilationRate,i.dilationRate];else if(2!==i.dilationRate.length)throw new ValueError("dilationRate must be a number or array of two numbers for 2D convolution, but received "+JSON.stringify(i.dilationRate));return i}return __extends(t,e),t.verifyConfig=function(e){if(assert("kernelSize"in e,"required key 'kernelSize' not in config"),"number"!=typeof e.kernelSize&&!checkArrayTypeAndLength(e.kernelSize,"number",1,2))throw new ValueError("BaseConv expects config.kernelSize to be number or number[] with length 1 or 2, but received "+JSON.stringify(e.kernelSize)+".")},t.prototype.getConfig=function(){var t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:serializeActivation(this.activation),useBias:this.useBias,biasInitializer:serializeInitializer(this.biasInitializer),biasRegularizer:serializeRegularizer(this.biasRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),biasConstraint:serializeConstraint(this.biasConstraint)},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t}(Layer),Conv=function(e){function t(n,r){var i=e.call(this,n,r)||this;return i.kernel=null,t.verifyConfig(r),i.filters=r.filters,i.kernelInitializer=getInitializer(r.kernelInitializer||i.DEFAULT_KERNEL_INITIALIZER),i.kernelConstraint=getConstraint(r.kernelConstraint),i.kernelRegularizer=getRegularizer(r.kernelRegularizer),i}return __extends(t,e),t.prototype.build=function(e){e=getExactlyOneShape(e);var t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new ValueError("The channel dimension of the input should be defined. Found "+e[t]);var n,r=e[t],i=this.kernelSize.concat([r,this.filters]);this.kernel=this.addWeight("kernel",i,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:(n={},n[t]=r,n)}],this.built=!0},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var t;e=getExactlyOneTensor(e);var r=null==n.bias?null:n.bias.read();if(1===n.rank)t=conv1dWithBias(e,n.kernel.read(),r,n.strides[0],n.padding,n.dataFormat,n.dilationRate[0]);else if(2===n.rank)t=conv2dWithBias(e,n.kernel.read(),r,n.strides,n.padding,n.dataFormat,n.dilationRate);else if(3===n.rank)throw new NotImplementedError("3D convolution is not implemented yet.");return null!=n.activation&&(t=n.activation.apply(t)),t})},t.prototype.computeOutputShape=function(e){e=getExactlyOneShape(e);for(var t=[],n="channelsLast"===this.dataFormat?e.slice(1,e.length-1):e.slice(2),r=0;r<n.length;++r){var i=convOutputLength(n[r],this.kernelSize[r],this.padding,this.strides[r],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[r]);t.push(i)}var a=[e[0]];return"channelsLast"===this.dataFormat?(a=a.concat(t)).push(this.filters):(a.push(this.filters),a=a.concat(t)),a},t.prototype.getConfig=function(){var t={filters:this.filters,kernelInitializer:serializeInitializer(this.kernelInitializer),kernelRegularizer:serializeRegularizer(this.kernelRegularizer),kernelConstraint:serializeConstraint(this.kernelConstraint)},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.verifyConfig=function(e){if(!("filters"in e)||"number"!=typeof e.filters||e.filters<1)throw new ValueError("Convolution layer expected config.filters to be a 'number' > 0 but got "+JSON.stringify(e.filters))},t}(BaseConv),Conv2D=function(e){function t(n){var r=e.call(this,2,n)||this;return t.verifyConfig(n),r}return __extends(t,e),t.prototype.getConfig=function(){var t=e.prototype.getConfig.call(this);return delete t.rank,t},t.verifyConfig=function(e){if("number"!=typeof e.kernelSize&&!checkArrayTypeAndLength(e.kernelSize,"number",1,2))throw new ValueError("Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received "+JSON.stringify(e.kernelSize)+".")},t.className="Conv2D",t}(Conv);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Conv2D);var Conv2DTranspose=function(e){function t(t){var n=e.call(this,t)||this;if(n.inputSpec=[new InputSpec({ndim:4})],"same"!==n.padding&&"valid"!==n.padding)throw new ValueError("Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode "+n.padding);return n}return __extends(t,e),t.prototype.build=function(e){if(4!==(e=getExactlyOneShape(e)).length)throw new ValueError("Input should have rank 4; Received input shape: "+JSON.stringify(e));var t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new ValueError("The channel dimension of the inputs should be defined. Found `None`.");var n,r=e[t],i=this.kernelSize.concat([this.filters,r]);this.kernel=this.addWeight("kernel",i,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new InputSpec({ndim:4,axes:(n={},n[t]=r,n)})],this.built=!0},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var t=getExactlyOneTensor(e);if(4!==t.shape.length)throw new ValueError("Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-"+t.shape.length);var r,i,a=t.shape,o=a[0];"channelsFirst"===n.dataFormat?(r=2,i=3):(r=1,i=2);var s=a[r],l=a[i],u=n.kernelSize[0],c=n.kernelSize[1],p=n.strides[0],h=n.strides[1],d=[o,deconvLength(s,p,u,n.padding),deconvLength(l,h,c,n.padding),n.filters];"channelsLast"!==n.dataFormat&&(t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(t,[0,2,3,1]));var f=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["conv2dTranspose"])(t,n.kernel.read(),d,n.strides,n.padding);return"channelsLast"!==n.dataFormat&&(f=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(f,[0,3,1,2])),null!=n.bias&&(f=biasAdd(f,n.bias.read(),n.dataFormat)),null!=n.activation&&(f=n.activation.apply(f)),f})},t.prototype.computeOutputShape=function(e){var t,n,r,i=(e=getExactlyOneShape(e)).slice();"channelsFirst"===this.dataFormat?(t=1,n=2,r=3):(t=3,n=1,r=2);var a=this.kernelSize[0],o=this.kernelSize[1],s=this.strides[0],l=this.strides[1];return i[t]=this.filters,i[n]=deconvLength(i[n],s,a,this.padding),i[r]=deconvLength(i[r],l,o,this.padding),i},t.prototype.getConfig=function(){var t=e.prototype.getConfig.call(this);return delete t.dilationRate,t},t.className="Conv2DTranspose",t}(Conv2D);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Conv2DTranspose);var SeparableConv=function(e){function t(t,n){var r=e.call(this,t,n)||this;if(r.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",r.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",r.depthwiseKernel=null,r.pointwiseKernel=null,null==n.filters)throw new ValueError("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=n.kernelInitializer||null!=n.kernelRegularizer||null!=n.kernelConstraint)throw new ValueError("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=n.padding&&"same"!==n.padding&&"valid"!==n.padding)throw new ValueError("SeparableConv"+r.rank+"D supports only padding modes: 'same' and 'valid', but received "+JSON.stringify(n.padding));return r.depthMultiplier=null==n.depthMultiplier?1:n.depthMultiplier,r.depthwiseInitializer=getInitializer(n.depthwiseInitializer||r.DEFAULT_DEPTHWISE_INITIALIZER),r.depthwiseRegularizer=getRegularizer(n.depthwiseRegularizer),r.depthwiseConstraint=getConstraint(n.depthwiseConstraint),r.pointwiseInitializer=getInitializer(n.depthwiseInitializer||r.DEFAULT_POINTWISE_INITIALIZER),r.pointwiseRegularizer=getRegularizer(n.pointwiseRegularizer),r.pointwiseConstraint=getConstraint(n.pointwiseConstraint),r}return __extends(t,e),t.prototype.build=function(e){if((e=getExactlyOneShape(e)).length<this.rank+2)throw new ValueError("Inputs to SeparableConv"+this.rank+"D should have rank "+(this.rank+2)+", but received input shape: "+JSON.stringify(e));var t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t]||e[t]<0)throw new ValueError("The channel dimension of the inputs should be defined, but found "+JSON.stringify(e[t]));for(var n=e[t],r=this.kernelSize.concat([n,this.depthMultiplier]),i=[],a=0;a<this.rank;++a)i.push(1);i.push(n*this.depthMultiplier,this.filters);var o;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",i,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,!0,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.inputSpec=[new InputSpec({ndim:this.rank+2,axes:(o={},o[t]=n,o)})],this.built=!0},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var t;if(e=getExactlyOneTensor(e),1===n.rank)throw new NotImplementedError("1D separable convolution is not implemented yet.");return 2===n.rank&&("channelsFirst"===n.dataFormat&&(e=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(e,[0,2,3,1])),t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["separableConv2d"])(e,n.depthwiseKernel.read(),n.pointwiseKernel.read(),n.strides,n.padding,n.dilationRate,"NHWC")),n.useBias&&(t=biasAdd(t,n.bias.read(),n.dataFormat)),null!=n.activation&&(t=n.activation.apply(t)),"channelsFirst"===n.dataFormat&&(t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(t,[0,3,1,2])),t})},t.prototype.getConfig=function(){var t=e.prototype.getConfig.call(this);return delete t.rank,delete t.kernelInitializer,delete t.kernelRegularizer,delete t.kernelConstraint,t.depthwiseInitializer=serializeInitializer(this.depthwiseInitializer),t.pointwiseInitializer=serializeInitializer(this.pointwiseInitializer),t.depthwiseRegularizer=serializeRegularizer(this.depthwiseRegularizer),t.pointwiseRegularizer=serializeRegularizer(this.pointwiseRegularizer),t.depthwiseConstraint=serializeConstraint(this.depthwiseConstraint),t.pointwiseConstraint=serializeConstraint(this.pointwiseConstraint),t},t.className="SeparableConv",t}(Conv),SeparableConv2D=function(e){function t(t){return e.call(this,2,t)||this}return __extends(t,e),t.className="SeparableConv2D",t}(SeparableConv);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(SeparableConv2D);var Conv1D=function(e){function t(n){var r=e.call(this,1,n)||this;return t.verifyConfig(n),r.inputSpec=[{ndim:3}],r}return __extends(t,e),t.prototype.getConfig=function(){var t=e.prototype.getConfig.call(this);return delete t.rank,delete t.dataFormat,t},t.verifyConfig=function(e){if("number"!=typeof e.kernelSize&&!checkArrayTypeAndLength(e.kernelSize,"number",1,1))throw new ValueError("Conv1D expects config.kernelSize to be number or number[] with length 1, but received "+JSON.stringify(e.kernelSize)+".")},t.className="Conv1D",t}(Conv);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Conv1D);var Cropping2D=function(e){function t(t){var n=e.call(this,t)||this;return"number"==typeof t.cropping?n.cropping=[[t.cropping,t.cropping],[t.cropping,t.cropping]]:"number"==typeof t.cropping[0]?n.cropping=[[t.cropping[0],t.cropping[0]],[t.cropping[1],t.cropping[1]]]:n.cropping=t.cropping,n.dataFormat=void 0===t.dataFormat?"channelsLast":t.dataFormat,n.inputSpec=[{ndim:4}],n}return __extends(t,e),t.prototype.computeOutputShape=function(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return e=getExactlyOneTensor(e),"channelsLast"===n.dataFormat?sliceAlongAxis(sliceAlongAxis(e,n.cropping[0][0],e.shape[1]-n.cropping[0][0]-n.cropping[0][1],2),n.cropping[1][0],e.shape[2]-n.cropping[1][1]-n.cropping[1][0],3):sliceAlongAxis(sliceAlongAxis(e,n.cropping[0][0],e.shape[2]-n.cropping[0][0]-n.cropping[0][1],3),n.cropping[1][0],e.shape[3]-n.cropping[1][1]-n.cropping[1][0],4)})},t.prototype.getConfig=function(){var t={cropping:this.cropping,dataFormat:this.dataFormat},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="Cropping2D",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Cropping2D);var UpSampling2D=function(e){function t(t){var n=e.call(this,t)||this;return n.DEFAULT_SIZE=[2,2],n.inputSpec=[{ndim:4}],n.size=null==t.size?n.DEFAULT_SIZE:t.size,n.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,n}return __extends(t,e),t.prototype.computeOutputShape=function(e){if("channelsFirst"===this.dataFormat){var t=null==e[2]?null:this.size[0]*e[2],n=null==e[3]?null:this.size[1]*e[3];return[e[0],e[1],t,n]}t=null==e[1]?null:this.size[0]*e[1],n=null==e[2]?null:this.size[1]*e[2];return[e[0],t,n,e[3]]},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var t=getExactlyOneTensor(e),r=t.shape;if("channelsFirst"===n.dataFormat){t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(t,[0,2,3,1]);var i=n.size[0]*r[2],a=n.size[1]*r[3],o=t.resizeNearestNeighbor([i,a]);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(o,[0,3,1,2])}i=n.size[0]*r[1],a=n.size[1]*r[2];return t.resizeNearestNeighbor([i,a])})},t.prototype.getConfig=function(){var t={size:this.size,dataFormat:this.dataFormat},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="UpSampling2D",t}(Layer);function depthwiseConv2d$1(e,t,n,r,i,a){return void 0===n&&(n=[1,1]),void 0===r&&(r="valid"),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){null==i&&(i=imageDataFormat()),checkDataFormat(i);var o=preprocessConv2DInput(e,i);if(4!==e.rank)throw new ValueError("Input for depthwiseConv2d is required to be 4-D, but is instead "+e.rank+"-D");if(4!==t.rank)throw new ValueError("depthwiseKernel is required to be 4-D, but is instead "+t.rank+"-D");return o=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["depthwiseConv2d"])(o,t,n,"same"===r?"same":"valid","NHWC",a),"channelsFirst"===i&&(o=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(o,[0,3,1,2])),o})}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(UpSampling2D);var DepthwiseConv2D=function(e){function t(t){var n=e.call(this,2,t)||this;return n.depthwiseKernel=null,n.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,n.depthwiseInitializer=getInitializer(t.depthwiseInitializer||n.DEFAULT_KERNEL_INITIALIZER),n.depthwiseConstraint=getConstraint(t.depthwiseConstraint),n.depthwiseRegularizer=getRegularizer(t.depthwiseRegularizer),n}return __extends(t,e),t.prototype.build=function(e){if((e=getExactlyOneShape(e)).length<4)throw new ValueError("Inputs to DepthwiseConv2D should have rank 4. Received input shape: "+JSON.stringify(e)+".");var t="channelsFirst"===this.dataFormat?1:3;if(null==e[t]||e[t]<0)throw new ValueError("The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not ("+e[t]+").");var n=e[t],r=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var t=depthwiseConv2d$1(e=getExactlyOneTensor(e),n.depthwiseKernel.read(),n.strides,n.padding,n.dataFormat,null);return n.useBias&&(t=biasAdd(t,n.bias.read(),n.dataFormat)),null!=n.activation&&(t=n.activation.apply(t)),t})},t.prototype.computeOutputShape=function(e){e=getExactlyOneShape(e);var t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,i=convOutputLength(t,this.kernelSize[0],this.padding,this.strides[0]),a=convOutputLength(n,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],r,i,a]:[e[0],i,a,r]},t.prototype.getConfig=function(){var t=e.prototype.getConfig.call(this);return t.depthMultiplier=this.depthMultiplier,t.depthwiseInitializer=serializeInitializer(this.depthwiseInitializer),t.depthwiseRegularizer=serializeRegularizer(this.depthwiseRegularizer),t.depthwiseConstraint=serializeConstraint(this.depthwiseRegularizer),t},t.className="DepthwiseConv2D",t}(BaseConv);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(DepthwiseConv2D);var Dropout=function(e){function t(t){var n=e.call(this,t)||this;if(n.rate=Math.max(Math.min(t.rate,1),0),n.rateScalar=getScalar(n.rate),n.noiseShape=t.noiseShape,n.seed=t.seed,null!=n.seed)throw new NotImplementedError("Non-default seed is not implemented in Dropout layer yet: "+n.seed);return n.supportsMasking=!0,n}return __extends(t,e),t.prototype.getNoiseShape=function(e){if(null==this.noiseShape)return this.noiseShape;for(var t=e.shape,n=[],r=0;r<this.noiseShape.length;++r)n.push(null==this.noiseShape[r]?t[r]:this.noiseShape[r]);return n},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){n.invokeCallHook(e,t);var r=getExactlyOneTensor(e);if(null!=n.noiseShape&&!_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].arraysEqual(r.shape,n.noiseShape))throw new NotImplementedError("Non-default noise shape is not implemented in Dropout layer yet: "+JSON.stringify(n.noiseShape));if(0<n.rate&&n.rate<1){var i=null!=t.training&&t.training,a=n.getNoiseShape(r);return inTrainPhase(function(){return dropout(r,n.rateScalar,a,n.seed)},function(){return r},i)}return e})},t.prototype.getConfig=function(){var t={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="Dropout",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Dropout);var Dense=function(e){function t(t){var n=e.call(this,t)||this;if(n.activation=null,n.useBias=!0,n.kernel=null,n.bias=null,n.DEFAULT_KERNEL_INITIALIZER="glorotNormal",n.DEFAULT_BIAS_INITIALIZER="zeros",null==t.batchInputShape&&null==t.inputShape&&null!=t.inputDim){var r=null;null!=t.batchSize&&(r=t.batchSize),n.batchInputShape=[r,t.inputDim]}return n.units=t.units,n.activation=getActivation(t.activation),null!=t.useBias&&(n.useBias=t.useBias),n.kernelInitializer=getInitializer(t.kernelInitializer||n.DEFAULT_KERNEL_INITIALIZER),n.biasInitializer=getInitializer(t.biasInitializer||n.DEFAULT_BIAS_INITIALIZER),n.kernelConstraint=getConstraint(t.kernelConstraint),n.biasConstraint=getConstraint(t.biasConstraint),n.kernelRegularizer=getRegularizer(t.kernelRegularizer),n.biasRegularizer=getRegularizer(t.biasRegularizer),n.activityRegularizer=getRegularizer(t.activityRegularizer),n.inputSpec=[{minNDim:2}],n}return __extends(t,e),t.prototype.build=function(e){var t,n=(e=getExactlyOneShape(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[n,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:(t={},t[-1]=n,t)}],this.built=!0},t.prototype.computeOutputShape=function(e){var t=(e=getExactlyOneShape(e)).slice();return t[t.length-1]=this.units,t},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){n.invokeCallHook(e,t);var r=dot(getExactlyOneTensor(e),n.kernel.read());return null!=n.bias&&(r=biasAdd(r,n.bias.read())),null!=n.activation&&(r=n.activation.apply(r)),r})},t.prototype.getConfig=function(){var t={units:this.units,activation:serializeActivation(this.activation),useBias:this.useBias,kernelInitializer:serializeInitializer(this.kernelInitializer),biasInitializer:serializeInitializer(this.biasInitializer),kernelRegularizer:serializeRegularizer(this.kernelRegularizer),biasRegularizer:serializeRegularizer(this.biasRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),kernelConstraint:serializeConstraint(this.kernelConstraint),biasConstraint:serializeConstraint(this.biasConstraint)},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="Dense",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Dense);var Flatten=function(e){function t(t){var n=e.call(this,t||{})||this;return n.inputSpec=[{minNDim:3}],n}return __extends(t,e),t.prototype.computeOutputShape=function(e){for(var t=0,n=(e=getExactlyOneShape(e)).slice(1);t<n.length;t++){if(null==n[t])throw new ValueError('The shape of the input to "Flatten" is not fully defined (got '+e.slice(1)+'). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.')}return[e[0],arrayProd(e,1)]},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return n.invokeCallHook(e,t),batchFlatten(getExactlyOneTensor(e))})},t.className="Flatten",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Flatten);var Activation$1=function(e){function t(t){var n=e.call(this,t)||this;return n.supportsMasking=!0,n.activation=getActivation(t.activation),n}return __extends(t,e),t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){n.invokeCallHook(e,t);var r=getExactlyOneTensor(e);return n.activation.apply(r)})},t.prototype.getConfig=function(){var t={activation:serializeActivation(this.activation)},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="Activation",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Activation$1);var RepeatVector=function(e){function t(t){var n=e.call(this,t)||this;return n.n=t.n,n.inputSpec=[{ndim:2}],n}return __extends(t,e),t.prototype.computeOutputShape=function(e){return[e[0],this.n,e[1]]},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return repeat(e=getExactlyOneTensor(e),n.n)})},t.prototype.getConfig=function(){var t={n:this.n},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="RepeatVector",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(RepeatVector);var Reshape=function(e){function t(t){var n=e.call(this,t)||this;n.targetShape=t.targetShape;for(var r=0;r<n.targetShape.length;++r)n.isUnknown(n.targetShape[r])&&(n.targetShape[r]=null);return n}return __extends(t,e),t.prototype.isUnknown=function(e){return e<0||null==e},t.prototype.fixUnknownDimension=function(e,t){for(var n="Total size of new array must be unchanged.",r=t.slice(),i=1,a=null,o=0;o<r.length;++o){var s=r[o];if(this.isUnknown(s)){if(null!==a)throw new ValueError("Can only specifiy one unknown dimension.");a=o}else i*=s}var l=arrayProd(e);if(null!==a){if(0===i||l%i!=0)throw new ValueError(n);r[a]=l/i}else if(l!==i)throw new ValueError(n);return r},t.prototype.computeOutputShape=function(e){for(var t=!1,n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){n.invokeCallHook(e,t);var r=getExactlyOneTensor(e),i=r.shape,a=i.slice(0,1).concat(n.fixUnknownDimension(i.slice(1),n.targetShape));return r.reshape(a)})},t.prototype.getConfig=function(){var t={targetShape:this.targetShape},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="Reshape",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Reshape);var Permute=function(e){function t(t){var n=e.call(this,t)||this;if(null==t.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(t.dims))throw new Error("Permute constructor requires `dims` to be an Array, but received "+t.dims+" instead.");var r=range(1,t.dims.length+1);if(!_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].arraysEqual(t.dims.slice().sort(),r))throw new Error("Invalid permutation `dims`: "+JSON.stringify(t.dims)+" `dims` must contain consecutive integers starting from 1.");return n.dims=t.dims,n.dimsIncludingBatch=[0].concat(n.dims),n.inputSpec=[new InputSpec({ndim:n.dims.length+1})],n}return __extends(t,e),t.prototype.computeOutputShape=function(e){var t=(e=getExactlyOneShape(e)).slice();return this.dims.forEach(function(n,r){t[r+1]=e[n]}),t},t.prototype.call=function(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(getExactlyOneTensor(e),this.dimsIncludingBatch)},t.prototype.getConfig=function(){var t={dims:this.dims},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="Permute",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Permute);var Embedding=function(e){function t(t){var n=e.call(this,t)||this;if(n.embeddings=null,n.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==t.batchInputShape&&null==t.inputShape){var r=null;null!=t.batchSize&&(r=t.batchSize),null==t.inputLength?n.batchInputShape=[r,null]:n.batchInputShape=[r].concat(toList(t.inputLength))}return n.inputDim=t.inputDim,n.outputDim=t.outputDim,n.embeddingsInitializer=getInitializer(t.embeddingsInitializer||n.DEFAULT_EMBEDDINGS_INITIALIZER),n.embeddingsRegularizer=getRegularizer(t.embeddingsRegularizer),n.activityRegularizer=getRegularizer(t.activityRegularizer),n.embeddingsConstraint=getConstraint(t.embeddingsConstraint),n.maskZero=t.maskZero,n.inputLength=t.inputLength,n}return __extends(t,e),t.prototype.build=function(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0},t.prototype.warnOnIncompatibleInputShape=function(e){},t.prototype.computeMask=function(e,t){throw new NotImplementedError("computeMask has not been implemented for Embedding yet")},t.prototype.computeOutputShape=function(e){if(e=getExactlyOneShape(e),null==this.inputLength)return e.concat([this.outputDim]);var t=toList(this.inputLength);if(t.length!==e.length-1)throw new ValueError('"inputLength" is '+this.inputLength+", but received input shape has shape "+e);for(var n=0,r=0;r<t.length;++r){var i=t[r],a=e[r+1];if(null!=i&&null!=a&&i!==a)throw new ValueError('"inputLength" is '+this.inputLength+", but received input shape has shape "+e);null==i&&(t[n]=a),n++}return[e[0]].concat(t,[this.outputDim])},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){n.invokeCallHook(e,t);var r=getExactlyOneTensor(e);return"int32"!==r.dtype&&(r=cast$1(r,"int32")),gather$1(n.embeddings.read(),r.as1D()).reshape(getExactlyOneShape(n.computeOutputShape(r.shape)))})},t.prototype.getConfig=function(){var t={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:serializeInitializer(this.embeddingsInitializer),embeddingsRegularizer:serializeRegularizer(this.embeddingsRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),embeddingsConstraint:serializeConstraint(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="Embedding",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Embedding);var Merge=function(e){function t(t){var n=e.call(this,t||{})||this;return n.supportsMasking=!0,n}return __extends(t,e),t.prototype.mergeFunction=function(e){throw new NotImplementedError},t.prototype.computeElementwiseOpOutputShape=function(e,t){if(null==e||null==t)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(0===t.length)return e;for(var n=e.slice(0,e.length-t.length),r=0;r<t.length;++r){var i=e[e.length-t.length+r],a=t[r];if(null==i||null==a||i<0||a<0)n.push(null);else if(1===i)n.push(a);else if(1===a)n.push(i);else{if(i!==a)throw new ValueError("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(i)}}return n},t.prototype.build=function(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[getExactlyOneShape(e)]),(e=e).length<2)throw new ValueError("A merge layer should be called on an Array of at least 2 inputs. Got "+e.length+" input(s).");for(var t=[],n=0,r=e;n<r.length;n++){null!=(o=r[n])&&null!==o[0]&&t.push(o[0])}if((t=unique(t)).length>1)throw new ValueError("Can not merge tensors with different batch sizes. Got tensors with shapes: "+JSON.stringify(e)+".");for(var i=null==e[0]?null:e[0].slice(1),a=1;a<e.length;++a){var o=null==e[a]?null:e[a].slice(1);i=this.computeElementwiseOpOutputShape(i,o)}var s=e.map(function(e){return e.length});-1===e.indexOf(null)&&1===unique(s).length?this.reshapeRequired=!1:this.reshapeRequired=!0},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(e=e,n.reshapeRequired){var t=[],r=e.map(function(e){return e.rank});if(-1===r.indexOf(null)){for(var i=max$1(r),a=0,o=e;a<o.length;a++){for(var s=(h=o[a]).rank,l=0;l<i-s;++l)h=expandDims(h,1);t.push(h)}return n.mergeFunction(t)}for(var u=!1,c=0,p=e;c<p.length;c++){var h;if(null==(s=(h=p[c]).rank)){var d=h.shape,f=d[0],g=d.slice(1).concat([f]),m=h.reshape([f].concat(arrayProd(d.slice(1))));m=(m=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(m,[1,0])).reshape(g),t.push(m),u=!0}else if(s>1){var y=range(1,s).concat([0]);t.push(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(h,y)),u=!0}else t.push(h)}var v=n.mergeFunction(t),b=v.rank;if(u)if(null==b){var w=v.shape;g=[f=w[w.length-1]].concat(w.slice(0,w.length-1));v=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(v.reshape([-1,f]),[1,0]).reshape(g)}else if(b>1){y=[b-1].concat(range(0,b-1));v=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(v,y)}return v}return n.mergeFunction(e)})},t.prototype.computeOutputShape=function(e){var t;t=null==(e=e)[0]?null:e[0].slice(1);for(var n=1;n<e.length;++n){var r=null==e[n]?null:e[n].slice(1);t=this.computeElementwiseOpOutputShape(t,r)}for(var i=[],a=0,o=e;a<o.length;a++){null!=(r=o[a])&&null!==r[0]&&i.push(r[0])}return t=1===(i=unique(i)).length?i.concat(t):[null].concat(t)},t.prototype.computeMask=function(e,t){throw new NotImplementedError("computeMask has not been implemented for Merge yet")},t}(Layer),Add=function(e){function t(t){return e.call(this,t)||this}return __extends(t,e),t.prototype.mergeFunction=function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){for(var t=e[0].clone(),n=1;n<e.length;++n)t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(t,e[n]);return t})},t.className="Add",t}(Merge);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Add);var Multiply=function(e){function t(t){return e.call(this,t)||this}return __extends(t,e),t.prototype.mergeFunction=function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){for(var t=e[0].clone(),n=1;n<e.length;++n)t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(t,e[n]);return t})},t.className="Multiply",t}(Merge);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Multiply);var Average=function(e){function t(t){return e.call(this,t)||this}return __extends(t,e),t.prototype.mergeFunction=function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){for(var t=e[0].clone(),n=1;n<e.length;++n)t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(t,e[n]);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(getScalar(1/e.length),t)})},t.className="Average",t}(Merge);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Average);var Maximum=function(e){function t(t){return e.call(this,t)||this}return __extends(t,e),t.prototype.mergeFunction=function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){for(var t=e[0],n=1;n<e.length;++n)t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["maximum"])(t,e[n]);return t})},t.className="Maximum",t}(Merge);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Maximum);var Minimum=function(e){function t(t){return e.call(this,t)||this}return __extends(t,e),t.prototype.mergeFunction=function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){for(var t=e[0],n=1;n<e.length;++n)t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["minimum"])(t,e[n]);return t})},t.className="Minimum",t}(Merge);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Minimum);var Concatenate=function(e){function t(t){var n=e.call(this,t)||this;return n.DEFAULT_AXIS=-1,null==t&&(t={}),n.axis=null==t.axis?n.DEFAULT_AXIS:t.axis,n.supportsMasking=!0,n.reshapeRequired=!1,n}return __extends(t,e),t.prototype.build=function(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new ValueError("A `Concatenate` layer should be called on a list of at least 2 inputs");for(var t=!0,n=0,r=e=e;n<r.length;n++){if(null!=(c=r[n])){t=!1;break}}if(!t){for(var i=[],a=0;a<e.length;++a){var o=e[a].slice();o.splice(this.axis,1);for(var s=!1,l=0,u=i;l<u.length;l++){var c=u[l];if(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].arraysEqual(c,o)){s=!0;break}}s||i.push(o)}if(i.length>1)throw new ValueError("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}},t.prototype.mergeFunction=function(e){var t=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return concatenate(e,t.axis)})},t.prototype.computeOutputShape=function(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new ValueError("A `Concatenate` layer should be called on a list of inputs.");for(var t=e,n=t[0].slice(),r=this.axis<0?n.length+this.axis:this.axis,i=0,a=t.slice(1);i<a.length;i++){var o=a[i];if(null==n[r]||null==o[r]){n[r]=null;break}n[r]+=o[r]}return n},t.prototype.computeMask=function(e,t){throw new NotImplementedError("computeMask has not been implemented for Concatenate yet")},t.prototype.getConfig=function(){var t={axis:this.axis},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="Concatenate",t}(Merge);function interpretAxis(e,t){for(;e<0;)e+=t;return e}function batchDot(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new NotImplementedError("batchDot is not implemented for tensors of 4D or higher rank yet");if(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(e.shape.length>=2,"batchDot requires the rank of x to be >= 2, but got "+e.shape.length),_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(e.shape.length>=2,"batchDot requires the rank of y to be >= 2, but got "+t.shape.length),"number"==typeof n&&(n=[n,n]),"complex64"===e.dtype||"complex64"===t.dtype)throw new NotImplementedError("batchDot is not implemented for complex64-type Tensors yet.");var r=e.shape.length,i=t.shape.length;null==n&&(n=[r-1,i-2]);var a=n;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n,o;if(r>i){n=r-i;for(var s=[],l=0;l<n;++l)s.push(1);t=t.reshape(t.shape.concat(s))}else if(i>r){n=i-r;for(s=[],l=0;l<n;++l)s.push(1);e=e.reshape(e.shape.concat(s))}else n=0;if(2===e.shape.length&&2===t.shape.length)o=a[0]===a[1]?e.mulStrict(t).sum(a[0]):e.transpose([1,0]).mulStrict(t).sum(a[1]);else{var u=a[0]!==e.shape.length-1||null,c=a[1]===t.shape.length-1||null;o=e.matMul(t,u,c)}if(n>0){var p=void 0,h=[];for(l=p=r>i?r+i-3:r-1;l<p+n;++l)h.push(l);o=o.squeeze(h)}return 1===o.shape.length&&(o=o.expandDims(1)),o})}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Concatenate);var Dot=function(e){function t(t){var n=e.call(this,t)||this;return n.axes=t.axes,n.normalize=null!=t.normalize&&t.normalize,n.supportsMasking=!0,n.reshapeRequired=!1,n}return __extends(t,e),t.prototype.build=function(e){_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),"A `Dot` layer should be called on a list of exactly 2 inputs.");var t=e[0],n=e[1];if(t.length>3||n.length>3)throw new NotImplementedError("Dot layer does not support tensors of 4D or higher rank yet.");var r=this.interpretAxes(t,n);if(t[r[0]]!==n[r[1]])throw new ValueError("Dimension incompatibility: "+t[r[0]]+" !== "+n[r[1]])},t.prototype.mergeFunction=function(e){if(2!==e.length)throw new ValueError("A `Dot` layer must be called on exactly 2 inputs, but received "+e.length+" input(s).");var t,n=e[0],r=e[1];return t=Array.isArray(this.axes)?this.axes.map(function(t,n){return interpretAxis(t,e[n].shape.length)}):[interpretAxis(this.axes,n.shape.length),interpretAxis(this.axes,r.shape.length)],this.normalize&&(n=l2Normalize(n,t[0]),r=l2Normalize(r,t[1])),batchDot(n,r,t)},t.prototype.interpretAxes=function(e,t){return Array.isArray(this.axes)?this.axes:[interpretAxis(this.axes,e.length),interpretAxis(this.axes,t.length)]},t.prototype.computeOutputShape=function(e){_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),"A `Dot` layer should be called on a list of exactly 2 inputs.");var t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new NotImplementedError("Dot layer does not support tensors of 4D or higher rank yet.");var r=this.interpretAxes(t,n);t.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);var i=t.concat(n);return 1===i.length&&i.push(1),i},t.prototype.computeMask=function(e,t){throw new NotImplementedError("computeMask has not been implemented for Dot yet")},t.prototype.getConfig=function(){var t={axes:this.axes,normalize:this.normalize},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="Dot",t}(Merge);function batchNormalization(e,t,n,r,i,a){var o;if(void 0===a&&(a=.001),2===e.rank)o=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["batchNormalization2d"])(e,t,n,a,i,r);else if(3===e.rank)o=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["batchNormalization3d"])(e,t,n,a,i,r);else{if(4!==e.rank)throw new NotImplementedError("batchNormalization is not implemented for array of rank "+e.rank+" yet");o=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["batchNormalization4d"])(e,t,n,a,i,r)}return o}function regularNormalizeBatchInTraining(e,t,n,r,i){return void 0===i&&(i=.001),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var a=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["moments"])(e,r),o=a.mean,s=a.variance;return[batchNormalization(e,o,s,n,t,i),o,s]})}function broadcastNormalizeBatchInTraining(e,t,n,r,i){return void 0===i&&(i=.001),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){for(var a=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["moments"])(e,r),o=a.mean,s=a.variance,l=[],u=0,c=range(0,e.rank);u<c.length;u++){var p=c[u];-1!==r.indexOf(p)?l.push(1):l.push(e.shape[p])}var h=o.reshape(l),d=s.reshape(l),f=null==t?null:t.reshape(l),g=null==n?null:n.reshape(l);return[batchNormalization(e,h,d,g,f,i),o,s]})}function normalizeBatchInTraining(e,t,n,r,i){return void 0===i&&(i=.001),_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].arraysEqual(r.slice().sort(),range(0,e.rank-1))?regularNormalizeBatchInTraining(e,t,n,r,i):broadcastNormalizeBatchInTraining(e,t,n,r,i)}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Dot);var BatchNormalization=function(e){function t(t){var n=this;return null==t&&(t={}),(n=e.call(this,t)||this).supportsMasking=!0,n.axis=null==t.axis?-1:t.axis,n.momentum=null==t.momentum?.99:t.momentum,n.epsilon=null==t.epsilon?.001:t.epsilon,n.center=null==t.center||t.center,n.scale=null==t.scale||t.scale,n.betaInitializer=getInitializer(t.betaInitializer||"zeros"),n.gammaInitializer=getInitializer(t.gammaInitializer||"ones"),n.movingMeanInitializer=getInitializer(t.movingMeanInitializer||"zeros"),n.movingVarianceInitializer=getInitializer(t.movingVarianceInitializer||"ones"),n.betaConstraint=getConstraint(t.betaConstraint),n.gammaConstraint=getConstraint(t.gammaConstraint),n.betaRegularizer=getRegularizer(t.betaRegularizer),n.gammaRegularizer=getRegularizer(t.gammaRegularizer),n.stepCount=0,n}return __extends(t,e),t.prototype.build=function(e){e=getExactlyOneShape(e);var t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(null==n)throw new ValueError("Axis "+t+" of input tensor should have a defined dimension but the layer received an input with shape "+JSON.stringify(e)+".");this.inputSpec=[new InputSpec({ndim:e.length,axes:(r={},r[t]=n,r)})];var r,i=[n];this.scale&&(this.gamma=this.addWeight("gamma",i,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",i,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",i,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",i,null,this.movingVarianceInitializer,null,!1),this.built=!0},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var r=null!=t.training&&t.training,i=getExactlyOneTensor(e),a=i.shape,o=a.length,s=range(0,o),l=n.axis>=0?n.axis:n.axis+o;s.splice(l,1);var u=pyListRepeat(1,o);u[l]=a[l];var c=s.slice();c.sort();var p=!_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].arraysEqual(c,range(0,o).slice(0,o-1));if(!r)return function(){if(p){var e=n.movingMean.read().reshape(u),t=n.movingVariance.read().reshape(u),r=n.center?n.beta.read().reshape(u):null,a=n.scale?n.gamma.read().reshape(u):null;return batchNormalization(i,e,t,r,a,n.epsilon)}return batchNormalization(i,n.movingMean.read(),n.movingVariance.read(),null==n.beta?null:n.beta.read(),null==n.gamma?null:n.gamma.read(),n.epsilon)}();var h=normalizeBatchInTraining(i,n.gamma.read(),n.beta.read(),s,n.epsilon),d=h[0],f=h[1],g=h[2],m=arrayProd(s.map(function(e){return i.shape[e]})),y=g.mul(getScalar(m/(m-(1+n.epsilon))));return function(){n.stepCount++;var e=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["movingAverage"])(n.movingMean.read(),f,n.momentum,n.stepCount);n.movingMean.write(e);var t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["movingAverage"])(n.movingVariance.read(),y,n.momentum,n.stepCount);n.movingVariance.write(t)}(),d})},t.prototype.getConfig=function(){var t={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:serializeInitializer(this.betaInitializer),gammaInitializer:serializeInitializer(this.gammaInitializer),movingMeanInitializer:serializeInitializer(this.movingMeanInitializer),movingVarianceInitializer:serializeInitializer(this.movingVarianceInitializer),betaRegularizer:serializeRegularizer(this.betaRegularizer),gammaRegularizer:serializeRegularizer(this.gammaRegularizer),betaConstraint:serializeConstraint(this.betaConstraint),gammaConstraint:serializeConstraint(this.gammaConstraint)},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="BatchNormalization",t}(Layer);function spatial2dPadding(e,t,n){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(4!==e.rank)throw new ValueError("temporalPadding expects input tensor to be 4-D, but received a "+e.rank+"-D tensor.");if(null==t&&(t=[[1,1],[1,1]]),2!==t.length||2!==t[0].length||2!==t[1].length)throw new ValueError("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==n&&(n=imageDataFormat()),"channelsLast"!==n&&"channelsFirst"!==n)throw new ValueError("Unknown data format: "+n+". Supported data formats are 'channelsLast' and 'channelsFirst.");var r;return r="channelsFirst"===n?[[0,0],[0,0],t[0],t[1]]:[[0,0],t[0],t[1],[0,0]],Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["pad"])(e,r)})}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(BatchNormalization);var ZeroPadding2D=function(e){function t(t){var n=this;if(null==t&&(t={}),(n=e.call(this,t)||this).dataFormat=null==t.dataFormat?imageDataFormat():t.dataFormat,null==t.padding)n.padding=[[1,1],[1,1]];else if("number"==typeof t.padding)n.padding=[[t.padding,t.padding],[t.padding,t.padding]];else{if(t.padding=t.padding,2!==t.padding.length)throw new ValueError("ZeroPadding2D expects padding to be a length-2 array, but received a length-"+t.padding.length+" array.");var r=void 0,i=void 0;if("number"==typeof t.padding[0])r=[t.padding[0],t.padding[0]],i=[t.padding[1],t.padding[1]];else{if(t.padding=t.padding,2!==t.padding[0].length)throw new ValueError("ZeroPadding2D expects height padding to be a length-2 array, but received a length-"+t.padding[0].length+" array.");if(r=t.padding[0],2!==t.padding[1].length)throw new ValueError("ZeroPadding2D expects width padding to be a length-2 array, but received a length-"+t.padding[1].length+" array.");i=t.padding[1]}n.padding=[r,i]}return n.inputSpec=[new InputSpec({ndim:4})],n}return __extends(t,e),t.prototype.computeOutputShape=function(e){var t,n;return e=getExactlyOneShape(e),"channelsFirst"===this.dataFormat?(t=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],t,n]):(t=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],t,n,e[3]])},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return spatial2dPadding(getExactlyOneTensor(e),n.padding,n.dataFormat)})},t.prototype.getConfig=function(){var t={padding:this.padding,dataFormat:this.dataFormat},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="ZeroPadding2D",t}(Layer);function pool2d(e,t,n,r,i,a){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var o;checkDataFormat(i),checkPoolMode(a),checkPaddingMode(r),null==n&&(n=[1,1]),null==r&&(r="valid"),null==i&&(i=imageDataFormat()),null==a&&(a="max"),e=preprocessConv2DInput(e,i);var s="same"===r?"same":"valid";return o="max"===a?Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["maxPool"])(e,t,n,s):Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["avgPool"])(e,t,n,s),"channelsFirst"===i&&(o=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(o,[0,3,1,2])),o})}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(ZeroPadding2D);var Pooling1D=function(e){function t(t){var n=this;if(null==t.poolSize&&(t.poolSize=2),n=e.call(this,t)||this,"number"==typeof t.poolSize)n.poolSize=[t.poolSize];else{if(!Array.isArray(t.poolSize)||1!==t.poolSize.length||"number"!=typeof t.poolSize[0])throw new ValueError("poolSize for 1D convolutional layer must be a number or an Array of a single number, but received "+JSON.stringify(t.poolSize));n.poolSize=t.poolSize}if(null==t.strides)n.strides=n.poolSize;else if("number"==typeof t.strides)n.strides=[t.strides];else{if(!Array.isArray(t.strides)||1!==t.strides.length||"number"!=typeof t.strides[0])throw new ValueError("strides for 1D convolutional layer must be a number or an Array of a single number, but received "+JSON.stringify(t.strides));n.strides=t.strides}return n.padding=null==t.padding?"valid":t.padding,checkPaddingMode(n.padding),n.inputSpec=[new InputSpec({ndim:3})],n}return __extends(t,e),t.prototype.computeOutputShape=function(e){var t=convOutputLength((e=getExactlyOneShape(e))[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){n.invokeCallHook(e,t),e=expandDims(getExactlyOneTensor(e),2);var r=n.poolingFunction(getExactlyOneTensor(e),[n.poolSize[0],1],[n.strides[0],1],n.padding,"channelsLast");return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["squeeze"])(r,[2])})},t.prototype.getConfig=function(){var t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t}(Layer),MaxPooling1D=function(e){function t(t){return e.call(this,t)||this}return __extends(t,e),t.prototype.poolingFunction=function(e,t,n,r,i){return checkDataFormat(i),checkPaddingMode(r),pool2d(e,t,n,r,i,"max")},t.className="MaxPooling1D",t}(Pooling1D);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(MaxPooling1D);var AveragePooling1D=function(e){function t(t){return e.call(this,t)||this}return __extends(t,e),t.prototype.poolingFunction=function(e,t,n,r,i){return checkDataFormat(i),checkPaddingMode(r),pool2d(e,t,n,r,i,"avg")},t.className="AveragePooling1D",t}(Pooling1D);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(AveragePooling1D);var Pooling2D=function(e){function t(t){var n=this;if(null==t.poolSize&&(t.poolSize=[2,2]),(n=e.call(this,t)||this).poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],null==t.strides)n.strides=n.poolSize;else if(Array.isArray(t.strides)){if(2!==t.strides.length)throw new ValueError("If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length "+t.strides.length+".");n.strides=t.strides}else n.strides=[t.strides,t.strides];return n.padding=null==t.padding?"valid":t.padding,n.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,checkDataFormat(n.dataFormat),checkPaddingMode(n.padding),n.inputSpec=[new InputSpec({ndim:4})],n}return __extends(t,e),t.prototype.computeOutputShape=function(e){e=getExactlyOneShape(e);var t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2];return t=convOutputLength(t,this.poolSize[0],this.padding,this.strides[0]),n=convOutputLength(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n]:[e[0],t,n,e[3]]},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return n.invokeCallHook(e,t),n.poolingFunction(getExactlyOneTensor(e),n.poolSize,n.strides,n.padding,n.dataFormat)})},t.prototype.getConfig=function(){var t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t}(Layer),MaxPooling2D=function(e){function t(t){return e.call(this,t)||this}return __extends(t,e),t.prototype.poolingFunction=function(e,t,n,r,i){return checkDataFormat(i),checkPaddingMode(r),pool2d(e,t,n,r,i,"max")},t.className="MaxPooling2D",t}(Pooling2D);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(MaxPooling2D);var AveragePooling2D=function(e){function t(t){return e.call(this,t)||this}return __extends(t,e),t.prototype.poolingFunction=function(e,t,n,r,i){return checkDataFormat(i),checkPaddingMode(r),pool2d(e,t,n,r,i,"avg")},t.className="AveragePooling2D",t}(Pooling2D);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(AveragePooling2D);var GlobalPooling1D=function(e){function t(t){var n=e.call(this,t)||this;return n.inputSpec=[new InputSpec({ndim:3})],n}return __extends(t,e),t.prototype.computeOutputShape=function(e){return[e[0],e[2]]},t.prototype.call=function(e,t){throw new NotImplementedError},t}(Layer),GlobalAveragePooling1D=function(e){function t(t){return e.call(this,t)||this}return __extends(t,e),t.prototype.call=function(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var t=getExactlyOneTensor(e);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(t,1)})},t.className="GlobalAveragePooling1D",t}(GlobalPooling1D);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(GlobalAveragePooling1D);var GlobalMaxPooling1D=function(e){function t(t){return e.call(this,t)||this}return __extends(t,e),t.prototype.call=function(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var t=getExactlyOneTensor(e);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["max"])(t,1)})},t.className="GlobalMaxPooling1D",t}(GlobalPooling1D);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(GlobalMaxPooling1D);var GlobalPooling2D=function(e){function t(t){var n=e.call(this,t)||this;return n.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,checkDataFormat(n.dataFormat),n.inputSpec=[new InputSpec({ndim:4})],n}return __extends(t,e),t.prototype.computeOutputShape=function(e){return e=e,"channelsLast"===this.dataFormat?[e[0],e[3]]:[e[0],e[1]]},t.prototype.call=function(e,t){throw new NotImplementedError},t.prototype.getConfig=function(){var t={dataFormat:this.dataFormat},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t}(Layer),GlobalAveragePooling2D=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var t=getExactlyOneTensor(e);return"channelsLast"===n.dataFormat?Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(t,[1,2]):Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(t,[2,3])})},t.className="GlobalAveragePooling2D",t}(GlobalPooling2D);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(GlobalAveragePooling2D);var GlobalMaxPooling2D=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var t=getExactlyOneTensor(e);return"channelsLast"===n.dataFormat?Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["max"])(t,[1,2]):Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["max"])(t,[2,3])})},t.className="GlobalMaxPooling2D",t}(GlobalPooling2D);function standardizeArgs(e,t,n,r){if(Array.isArray(e)){if(null!=t||null!=n)throw new ValueError("When inputs is an array, neither initialState or constants should be provided");null!=r&&(n=e.slice(e.length-r,e.length),e=e.slice(0,e.length-r)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function i(e){return null==e||Array.isArray(e)?e:[e]}return{inputs:e,initialState:t=i(t),constants:n=i(n)}}function rnn(e,t,n,r,i,a,o,s){void 0===r&&(r=!1),void 0===o&&(o=!1),void 0===s&&(s=!1);var l=t.shape.length;if(l<3)throw new ValueError("Input should be at least 3D, but is "+l+"D.");var u,c,p=[1,0].concat(range(2,l));if(t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(t,p),null!=i)throw new NotImplementedError("The rnn() function of the deeplearn.js backend does not support masking yet.");if(null!=a)throw new NotImplementedError("The rnn() functoin of the deeplearn.js backend does not support constants yet.");o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),r&&(t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reverse"])(t,0));for(var h=n,d=t.shape[0],f=function(n){var r=sliceAlongFirstAxis(t,n,1);r=r.reshape(r.shape.slice(1));var i=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return e(r,h)});if(c=i[0],s)if(0===n)u=c.expandDims(1);else{var a=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["concat"])([u,c.expandDims(1)],1);u.dispose(),u=a}h=i[1]},g=0;g<d;++g)f(g);return[c,u,h]}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(GlobalMaxPooling2D);var RNN=function(e){function t(t){var n,r=e.call(this,t)||this;if(null==t.cell)throw new ValueError("cell property is missing for the constructor of RNN.");if(null==(n=Array.isArray(t.cell)?new StackedRNNCells({cells:t.cell}):t.cell).stateSize)throw new ValueError("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");return r.cell=n,r.returnSequences=null!=t.returnSequences&&t.returnSequences,r.returnState=null!=t.returnState&&t.returnState,r.goBackwards=null!=t.goBackwards&&t.goBackwards,r._stateful=null!=t.stateful&&t.stateful,r.unroll=null!=t.unroll&&t.unroll,r.supportsMasking=!0,r.inputSpec=[new InputSpec({ndim:3})],r.stateSpec=null,r.states=null,r.numConstants=null,r.keptStates=[],r}return __extends(t,e),t.prototype.getStates=function(){return null==this.states?range(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map(function(e){return null}):this.states},t.prototype.setStates=function(e){this.states=e},t.prototype.computeOutputShape=function(e){isArrayOfShapes(e)&&(e=e[0]),e=e;var t=this.cell.stateSize;Array.isArray(t)||(t=[t]);var n,r=t[0];if(n=this.returnSequences?[e[0],e[1],r]:[e[0],r],this.returnState){for(var i=[],a=0,o=t;a<o.length;a++){var s=o[a];i.push([e[0],s])}return[n].concat(i)}return n},t.prototype.computeMask=function(e,t){throw new NotImplementedError("computeMask has not been implemented for RNN yet")},t.prototype.build=function(e){if(null!=this.numConstants)throw new NotImplementedError("Constants support is not implemented in RNN yet.");isArrayOfShapes(e)&&(e=e[0]),e=e;var t=this.stateful?e[0]:null,n=e[e.length-1];this.inputSpec[0]=new InputSpec({shape:[t,null,n]});var r,i=[e[0]].concat(e.slice(2));if(this.cell.build(i),r=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].arraysEqual(this.stateSpec.map(function(e){return e.shape[e.shape.length-1]}),r))throw new ValueError("An initialState was passed that is not compatible with cell.stateSize. Received stateSpec="+this.stateSpec+"; However cell.stateSize is "+this.cell.stateSize)}else this.stateSpec=r.map(function(e){return new InputSpec({shape:[null,e]})});this.stateful&&this.resetStates()},t.prototype.resetStates=function(e,t){var n=this;void 0===t&&(t=!1),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(!n.stateful)throw new AttributeError("Cannot call resetStates() on an RNN Layer that is not stateful.");var r=n.inputSpec[0].shape[0];if(null==r)throw new ValueError("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==n.states)Array.isArray(n.cell.stateSize)?n.states=n.cell.stateSize.map(function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["zeros"])([r,e])}):n.states=[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["zeros"])([r,n.cell.stateSize])];else if(null==e)Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(n.states),null!=n.keptStates&&(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(n.keptStates),n.keptStates=[]),Array.isArray(n.cell.stateSize)?n.states=n.cell.stateSize.map(function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["zeros"])([r,e])}):n.states[0]=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["zeros"])([r,n.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==n.states.length)throw new ValueError("Layer "+n.name+" expects "+n.states.length+" state(s), but it received "+e.length+" state value(s). Input received: "+e);!0===t?n.keptStates.push(n.states.slice()):Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(n.states);for(var i=0;i<n.states.length;++i){var a=e[i],o=Array.isArray(n.cell.stateSize)?n.cell.stateSize[i]:n.cell.stateSize,s=[r,o];if(!_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].arraysEqual(a.shape,s))throw new ValueError("State "+i+" is incompatible with layer "+n.name+": expected shape="+s+", received shape="+a.shape);n.states[i]=a}}n.states.forEach(function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["keep"])(e)})})},t.prototype.apply=function(t,n){var r=null==n?null:n.initialState,i=null==n?null:n.constants;null==n&&(n={});var a=standardizeArgs(t,r,i,this.numConstants);t=a.inputs,r=a.initialState,i=a.constants;var o=[],s=[];if(null!=r){n.initialState=r,o=o.concat(r),this.stateSpec=[];for(var l=0,u=r;l<u.length;l++){var c=u[l];this.stateSpec.push(new InputSpec({shape:c.shape}))}s=s.concat(this.stateSpec)}if(null!=i&&(n.constants=i,o=o.concat(i),this.numConstants=i.length),o[0]instanceof SymbolicTensor){var p=[t].concat(o),h=this.inputSpec.concat(s),d=this.inputSpec;this.inputSpec=h;var f=e.prototype.apply.call(this,p,n);return this.inputSpec=d,f}return e.prototype.apply.call(this,t,n)},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var r=null==t?null:t.mask,i=null==t?null:t.training,a=null==t?null:t.initialState;if(e=getExactlyOneTensor(e),null==a&&(a=n.stateful?n.states:n.getInitialState(e)),null!=r)throw new NotImplementedError("Masking is not implemented for RNN yet");var o=Array.isArray(n.cell.stateSize)?n.cell.stateSize.length:1;if(a.length!==o)throw new ValueError("RNN Layer has "+o+" state(s) but was passed "+a.length+" initial state(s).");n.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");var s={training:i},l=rnn(function(e,t){var r=n.cell.call([e].concat(t),s);return[r[0],r.slice(1)]},e,a,n.goBackwards,null,null,n.unroll,n.returnSequences),u=l[0],c=l[1],p=l[2];n.stateful&&n.resetStates(p,i);var h=n.returnSequences?c:u;return n.returnState?[h].concat(p):h})},t.prototype.getInitialState=function(e){var t=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["zeros"])(e.shape);return n=expandDims(n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sum"])(n,[1,2])),Array.isArray(t.cell.stateSize)?t.cell.stateSize.map(function(e){return e>1?tile$1(n,[1,e]):n}):t.cell.stateSize>1?[tile$1(n,[1,t.cell.stateSize])]:[n]})},Object.defineProperty(t.prototype,"trainableWeights",{get:function(){return this.trainable?this.cell.trainableWeights:[]},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"nonTrainableWeights",{get:function(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights},enumerable:!0,configurable:!0}),t.prototype.getConfig=function(){var t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(t.numConstants=this.numConstants);var n=this.cell.getConfig();t.cell={className:this.cell.getClassName(),config:n};var r=e.prototype.getConfig.call(this);return Object.assign(t,r),t},t.className="RNN",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(RNN);var RNNCell=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t}(Layer),SimpleRNNCell=function(e){function t(t){var n=e.call(this,t)||this;return n.DEFAULT_ACTIVATION="tanh",n.DEFAULT_KERNEL_INITIALIZER="glorotNormal",n.DEFAULT_RECURRENT_INITIALIZER="orthogonal",n.DEFAULT_BIAS_INITIALIZER="zeros",n.units=t.units,n.activation=getActivation(null==t.activation?n.DEFAULT_ACTIVATION:t.activation),n.useBias=null==t.useBias||t.useBias,n.kernelInitializer=getInitializer(t.kernelInitializer||n.DEFAULT_KERNEL_INITIALIZER),n.recurrentInitializer=getInitializer(t.recurrentInitializer||n.DEFAULT_RECURRENT_INITIALIZER),n.biasInitializer=getInitializer(t.biasInitializer||n.DEFAULT_BIAS_INITIALIZER),n.kernelRegularizer=getRegularizer(t.kernelRegularizer),n.recurrentRegularizer=getRegularizer(t.recurrentRegularizer),n.biasRegularizer=getRegularizer(t.biasRegularizer),n.kernelConstraint=getConstraint(t.kernelConstraint),n.recurrentConstraint=getConstraint(t.recurrentConstraint),n.biasConstraint=getConstraint(t.biasConstraint),n.dropout=min$1([1,max$1([0,null==t.dropout?0:t.dropout])]),n.recurrentDropout=min$1([1,max$1([0,null==t.recurrentDropout?0:t.recurrentDropout])]),n.stateSize=n.units,n.dropoutMask=null,n.recurrentDropoutMask=null,n}return __extends(t,e),t.prototype.build=function(e){e=getExactlyOneShape(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(2!==(e=e).length)throw new ValueError("SimpleRNNCell expects 2 input Tensors, got "+e.length+".");var r=e[1];e=e[0];var i,a=null!=t.training&&t.training;0<n.dropout&&n.dropout<1&&null==n.dropoutMask&&(n.dropoutMask=generateDropoutMask(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["onesLike"])(e)},n.dropout,a)),0<n.recurrentDropout&&n.recurrentDropout<1&&null==n.recurrentDropoutMask&&(n.recurrentDropoutMask=generateDropoutMask(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["onesLike"])(r)},n.recurrentDropout,a));var o=n.dropoutMask,s=n.recurrentDropoutMask;i=dot(null!=o?Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(e,o):e,n.kernel.read()),null!=n.bias&&(i=biasAdd(i,n.bias.read())),null!=s&&(r=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(r,s));var l=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(i,dot(r,n.recurrentKernel.read()));return null!=n.activation&&(l=n.activation.apply(l)),[l,l]})},t.prototype.getConfig=function(){var t={units:this.units,activation:serializeActivation(this.activation),useBias:this.useBias,kernelInitializer:serializeInitializer(this.kernelInitializer),recurrentInitializer:serializeInitializer(this.recurrentInitializer),biasInitializer:serializeInitializer(this.biasInitializer),kernelRegularizer:serializeRegularizer(this.kernelRegularizer),recurrentRegularizer:serializeRegularizer(this.recurrentRegularizer),biasRegularizer:serializeRegularizer(this.biasRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),kernelConstraint:serializeConstraint(this.kernelConstraint),recurrentConstraint:serializeConstraint(this.recurrentConstraint),biasConstraint:serializeConstraint(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="SimpleRNNCell",t}(RNNCell);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(SimpleRNNCell);var SimpleRNN=function(e){function t(t){return t.cell=new SimpleRNNCell(t),e.call(this,t)||this}return __extends(t,e),t.prototype.call=function(t,n){var r=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){null!=r.cell.dropoutMask&&(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(r.cell.dropoutMask),r.cell.dropoutMask=null),null!=r.cell.recurrentDropoutMask&&(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(r.cell.recurrentDropoutMask),r.cell.recurrentDropoutMask=null);var i=null==n?null:n.mask,a=null==n?null:n.training,o=null==n?null:n.initialState;return e.prototype.call.call(r,t,{mask:i,training:a,initialState:o})})},Object.defineProperty(t.prototype,"units",{get:function(){return this.cell.units},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"activation",{get:function(){return this.cell.activation},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"useBias",{get:function(){return this.cell.useBias},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"kernelInitializer",{get:function(){return this.cell.kernelInitializer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"recurrentInitializer",{get:function(){return this.cell.recurrentInitializer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"biasInitializer",{get:function(){return this.cell.biasInitializer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"kernelRegularizer",{get:function(){return this.cell.kernelRegularizer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"recurrentRegularizer",{get:function(){return this.cell.recurrentRegularizer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"biasRegularizer",{get:function(){return this.cell.biasRegularizer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"kernelConstraint",{get:function(){return this.cell.kernelConstraint},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"recurrentConstraint",{get:function(){return this.cell.recurrentConstraint},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"biasConstraint",{get:function(){return this.cell.biasConstraint},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"dropout",{get:function(){return this.cell.dropout},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"recurrentDropout",{get:function(){return this.cell.recurrentDropout},enumerable:!0,configurable:!0}),t.prototype.getConfig=function(){var t={units:this.units,activation:serializeActivation(this.activation),useBias:this.useBias,kernelInitializer:serializeInitializer(this.kernelInitializer),recurrentInitializer:serializeInitializer(this.recurrentInitializer),biasInitializer:serializeInitializer(this.biasInitializer),kernelRegularizer:serializeRegularizer(this.kernelRegularizer),recurrentRegularizer:serializeRegularizer(this.recurrentRegularizer),biasRegularizer:serializeRegularizer(this.biasRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),kernelConstraint:serializeConstraint(this.kernelConstraint),recurrentConstraint:serializeConstraint(this.recurrentConstraint),biasConstraint:serializeConstraint(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout},n=e.prototype.getConfig.call(this);return delete n.cell,Object.assign(t,n),t},t.className="SimpleRNN",t}(RNN);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(SimpleRNN);var GRUCell=function(e){function t(t){var n=e.call(this,t)||this;return n.DEFAULT_ACTIVATION="tanh",n.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",n.DEFAULT_KERNEL_INITIALIZER="glorotNormal",n.DEFAULT_RECURRENT_INITIALIZER="orthogonal",n.DEFAULT_BIAS_INITIALIZER="zeros",n.units=t.units,n.activation=getActivation(void 0===t.activation?n.DEFAULT_ACTIVATION:t.activation),n.recurrentActivation=getActivation(void 0===t.recurrentActivation?n.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),n.useBias=null==t.useBias||t.useBias,n.kernelInitializer=getInitializer(t.kernelInitializer||n.DEFAULT_KERNEL_INITIALIZER),n.recurrentInitializer=getInitializer(t.recurrentInitializer||n.DEFAULT_RECURRENT_INITIALIZER),n.biasInitializer=getInitializer(t.biasInitializer||n.DEFAULT_BIAS_INITIALIZER),n.kernelRegularizer=getRegularizer(t.kernelRegularizer),n.recurrentRegularizer=getRegularizer(t.recurrentRegularizer),n.biasRegularizer=getRegularizer(t.biasRegularizer),n.kernelConstraint=getConstraint(t.kernelConstraint),n.recurrentConstraint=getConstraint(t.recurrentConstraint),n.biasConstraint=getConstraint(t.biasConstraint),n.dropout=min$1([1,max$1([0,null==t.dropout?0:t.dropout])]),n.recurrentDropout=min$1([1,max$1([0,null==t.recurrentDropout?0:t.recurrentDropout])]),n.implementation=t.implementation,n.stateSize=n.units,n.dropoutMask=null,n.recurrentDropoutMask=null,n}return __extends(t,e),t.prototype.build=function(e){var t=(e=getExactlyOneShape(e))[e.length-1];this.kernel=this.addWeight("kernel",[t,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(2!==(e=e).length)throw new ValueError("GRUCell expects 2 input Tensors (inputs, h, c), got "+e.length+".");var r=null!=t.training&&t.training,i=e[1];e=e[0],0<n.dropout&&n.dropout<1&&null==n.dropoutMask&&(n.dropoutMask=generateDropoutMask(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["onesLike"])(e)},n.dropout,r,3)),0<n.recurrentDropout&&n.recurrentDropout<1&&null==n.recurrentDropoutMask&&(n.recurrentDropoutMask=generateDropoutMask(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["onesLike"])(i)},n.recurrentDropout,r,3));var a,o,s,l=n.dropoutMask,u=n.recurrentDropoutMask;0<n.dropout&&n.dropout<1&&(e=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(e,l[0]));var c=dot(e,n.kernel.read());n.useBias&&(c=biasAdd(c,n.bias.read())),0<n.recurrentDropout&&n.recurrentDropout<1&&(i=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(i,u[0]));var p=n.recurrentKernel.read(),h=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["split"])(p,[2*n.units,n.units],p.rank-1),d=h[0],f=h[1],g=dot(i,d),m=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["split"])(c,3,c.rank-1),y=m[0],v=m[1],b=m[2],w=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["split"])(g,2,g.rank-1),z=w[0],S=w[1];a=n.recurrentActivation.apply(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(y,z)),o=n.recurrentActivation.apply(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(v,S));var I=dot(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(o,i),f);s=n.activation.apply(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(b,I));var N=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(a,i),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(getScalar(1),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["neg"])(a)),s));return[N,N]})},t.prototype.getConfig=function(){var t={units:this.units,activation:serializeActivation(this.activation),recurrentActivation:serializeActivation(this.recurrentActivation),useBias:this.useBias,kernelInitializer:serializeInitializer(this.kernelInitializer),recurrentInitializer:serializeInitializer(this.recurrentInitializer),biasInitializer:serializeInitializer(this.biasInitializer),kernelRegularizer:serializeRegularizer(this.kernelRegularizer),recurrentRegularizer:serializeRegularizer(this.recurrentRegularizer),biasRegularizer:serializeRegularizer(this.biasRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),kernelConstraint:serializeConstraint(this.kernelConstraint),recurrentConstraint:serializeConstraint(this.recurrentConstraint),biasConstraint:serializeConstraint(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="GRUCell",t}(RNNCell);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(GRUCell);var GRU=function(e){function t(t){return 0===t.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new GRUCell(t),e.call(this,t)||this}return __extends(t,e),t.prototype.call=function(t,n){var r=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){null!=r.cell.dropoutMask&&(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(r.cell.dropoutMask),r.cell.dropoutMask=null),null!=r.cell.recurrentDropoutMask&&(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(r.cell.recurrentDropoutMask),r.cell.recurrentDropoutMask=null);var i=null==n?null:n.mask,a=null==n?null:n.training,o=null==n?null:n.initialState;return e.prototype.call.call(r,t,{mask:i,training:a,initialState:o})})},Object.defineProperty(t.prototype,"units",{get:function(){return this.cell.units},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"activation",{get:function(){return this.cell.activation},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"recurrentActivation",{get:function(){return this.cell.recurrentActivation},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"useBias",{get:function(){return this.cell.useBias},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"kernelInitializer",{get:function(){return this.cell.kernelInitializer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"recurrentInitializer",{get:function(){return this.cell.recurrentInitializer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"biasInitializer",{get:function(){return this.cell.biasInitializer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"kernelRegularizer",{get:function(){return this.cell.kernelRegularizer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"recurrentRegularizer",{get:function(){return this.cell.recurrentRegularizer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"biasRegularizer",{get:function(){return this.cell.biasRegularizer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"kernelConstraint",{get:function(){return this.cell.kernelConstraint},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"recurrentConstraint",{get:function(){return this.cell.recurrentConstraint},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"biasConstraint",{get:function(){return this.cell.biasConstraint},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"dropout",{get:function(){return this.cell.dropout},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"recurrentDropout",{get:function(){return this.cell.recurrentDropout},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"implementation",{get:function(){return this.cell.implementation},enumerable:!0,configurable:!0}),t.prototype.getConfig=function(){var t={units:this.units,activation:serializeActivation(this.activation),recurrentActivation:serializeActivation(this.recurrentActivation),useBias:this.useBias,kernelInitializer:serializeInitializer(this.kernelInitializer),recurrentInitializer:serializeInitializer(this.recurrentInitializer),biasInitializer:serializeInitializer(this.biasInitializer),kernelRegularizer:serializeRegularizer(this.kernelRegularizer),recurrentRegularizer:serializeRegularizer(this.recurrentRegularizer),biasRegularizer:serializeRegularizer(this.biasRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),kernelConstraint:serializeConstraint(this.kernelConstraint),recurrentConstraint:serializeConstraint(this.recurrentConstraint),biasConstraint:serializeConstraint(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation},n=e.prototype.getConfig.call(this);return delete n.cell,Object.assign(t,n),t},t.fromConfig=function(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)},t.className="GRU",t}(RNN);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(GRU);var LSTMCell=function(e){function t(t){var n=e.call(this,t)||this;return n.DEFAULT_ACTIVATION="tanh",n.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",n.DEFAULT_KERNEL_INITIALIZER="glorotNormal",n.DEFAULT_RECURRENT_INITIALIZER="orthogonal",n.DEFAULT_BIAS_INITIALIZER="zeros",n.units=t.units,n.activation=getActivation(void 0===t.activation?n.DEFAULT_ACTIVATION:t.activation),n.recurrentActivation=getActivation(void 0===t.recurrentActivation?n.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),n.useBias=null==t.useBias||t.useBias,n.kernelInitializer=getInitializer(t.kernelInitializer||n.DEFAULT_KERNEL_INITIALIZER),n.recurrentInitializer=getInitializer(t.recurrentInitializer||n.DEFAULT_RECURRENT_INITIALIZER),n.biasInitializer=getInitializer(t.biasInitializer||n.DEFAULT_BIAS_INITIALIZER),n.unitForgetBias=t.unitForgetBias,n.kernelRegularizer=getRegularizer(t.kernelRegularizer),n.recurrentRegularizer=getRegularizer(t.recurrentRegularizer),n.biasRegularizer=getRegularizer(t.biasRegularizer),n.kernelConstraint=getConstraint(t.kernelConstraint),n.recurrentConstraint=getConstraint(t.recurrentConstraint),n.biasConstraint=getConstraint(t.biasConstraint),n.dropout=min$1([1,max$1([0,null==t.dropout?0:t.dropout])]),n.recurrentDropout=min$1([1,max$1([0,null==t.recurrentDropout?0:t.recurrentDropout])]),n.implementation=t.implementation,n.stateSize=[n.units,n.units],n.dropoutMask=null,n.recurrentDropoutMask=null,n}return __extends(t,e),t.prototype.build=function(e){var t,n,r=(e=getExactlyOneShape(e))[e.length-1];if(this.kernel=this.addWeight("kernel",[r,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){var i=this.biasInitializer,a=this.units;t=new((n=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.apply=function(e,t){var n=i.apply([a]),r=(new Ones).apply([a]),o=i.apply([2*a]);return concatAlongFirstAxis(concatAlongFirstAxis(n,r),o)},t}(Initializer)).className="CustomInit",n)}else t=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,t,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var r=null!=t.training&&t.training;if(3!==(e=e).length)throw new ValueError("LSTMCell expects 3 input Tensors (inputs, h, c), got "+e.length+".");var i=e[1],a=e[2];e=e[0],0<n.dropout&&n.dropout<1&&null==n.dropoutMask&&(n.dropoutMask=generateDropoutMask(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["onesLike"])(e)},n.dropout,r,4)),0<n.recurrentDropout&&n.recurrentDropout<1&&null==n.recurrentDropoutMask&&(n.recurrentDropoutMask=generateDropoutMask(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["onesLike"])(i)},n.recurrentDropout,r,4));var o,s,l,u,c=n.dropoutMask,p=n.recurrentDropoutMask;0<n.dropout&&n.dropout<1&&(e=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(e,c[0]));var h=dot(e,n.kernel.read());0<n.recurrentDropout&&n.recurrentDropout<1&&(i=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(i,p[0])),h=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(h,dot(i,n.recurrentKernel.read())),n.useBias&&(h=biasAdd(h,n.bias.read()));var d=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["split"])(h,4,h.rank-1),f=d[0],g=d[1],m=d[2],y=d[3];o=n.recurrentActivation.apply(f),s=n.recurrentActivation.apply(g),l=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(s,a),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(o,n.activation.apply(m))),u=n.recurrentActivation.apply(y);var v=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(u,n.activation.apply(l));return[v,v,l]})},t.prototype.getConfig=function(){var t={units:this.units,activation:serializeActivation(this.activation),recurrentActivation:serializeActivation(this.recurrentActivation),useBias:this.useBias,kernelInitializer:serializeInitializer(this.kernelInitializer),recurrentInitializer:serializeInitializer(this.recurrentInitializer),biasInitializer:serializeInitializer(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:serializeRegularizer(this.kernelRegularizer),recurrentRegularizer:serializeRegularizer(this.recurrentRegularizer),biasRegularizer:serializeRegularizer(this.biasRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),kernelConstraint:serializeConstraint(this.kernelConstraint),recurrentConstraint:serializeConstraint(this.recurrentConstraint),biasConstraint:serializeConstraint(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="LSTMCell",t}(RNNCell);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(LSTMCell);var LSTM=function(e){function t(t){return 0===t.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new LSTMCell(t),e.call(this,t)||this}return __extends(t,e),t.prototype.call=function(t,n){var r=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){null!=r.cell.dropoutMask&&(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(r.cell.dropoutMask),r.cell.dropoutMask=null),null!=r.cell.recurrentDropoutMask&&(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(r.cell.recurrentDropoutMask),r.cell.recurrentDropoutMask=null);var i=null==n?null:n.mask,a=null==n?null:n.training,o=null==n?null:n.initialState;return e.prototype.call.call(r,t,{mask:i,training:a,initialState:o})})},Object.defineProperty(t.prototype,"units",{get:function(){return this.cell.units},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"activation",{get:function(){return this.cell.activation},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"recurrentActivation",{get:function(){return this.cell.recurrentActivation},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"useBias",{get:function(){return this.cell.useBias},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"kernelInitializer",{get:function(){return this.cell.kernelInitializer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"recurrentInitializer",{get:function(){return this.cell.recurrentInitializer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"biasInitializer",{get:function(){return this.cell.biasInitializer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"unitForgetBias",{get:function(){return this.cell.unitForgetBias},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"kernelRegularizer",{get:function(){return this.cell.kernelRegularizer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"recurrentRegularizer",{get:function(){return this.cell.recurrentRegularizer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"biasRegularizer",{get:function(){return this.cell.biasRegularizer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"kernelConstraint",{get:function(){return this.cell.kernelConstraint},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"recurrentConstraint",{get:function(){return this.cell.recurrentConstraint},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"biasConstraint",{get:function(){return this.cell.biasConstraint},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"dropout",{get:function(){return this.cell.dropout},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"recurrentDropout",{get:function(){return this.cell.recurrentDropout},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"implementation",{get:function(){return this.cell.implementation},enumerable:!0,configurable:!0}),t.prototype.getConfig=function(){var t={units:this.units,activation:serializeActivation(this.activation),recurrentActivation:serializeActivation(this.recurrentActivation),useBias:this.useBias,kernelInitializer:serializeInitializer(this.kernelInitializer),recurrentInitializer:serializeInitializer(this.recurrentInitializer),biasInitializer:serializeInitializer(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:serializeRegularizer(this.kernelRegularizer),recurrentRegularizer:serializeRegularizer(this.recurrentRegularizer),biasRegularizer:serializeRegularizer(this.biasRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),kernelConstraint:serializeConstraint(this.kernelConstraint),recurrentConstraint:serializeConstraint(this.recurrentConstraint),biasConstraint:serializeConstraint(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation},n=e.prototype.getConfig.call(this);return delete n.cell,Object.assign(t,n),t},t.fromConfig=function(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)},t.className="LSTM",t}(RNN);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(LSTM);var StackedRNNCells=function(e){function t(t){var n=e.call(this,t)||this;return n.cells=t.cells,n}return __extends(t,e),Object.defineProperty(t.prototype,"stateSize",{get:function(){for(var e=[],t=0,n=this.cells.slice().reverse();t<n.length;t++){var r=n[t];Array.isArray(r.stateSize)?e.push.apply(e,r.stateSize):e.push(r.stateSize)}return e},enumerable:!0,configurable:!0}),t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){for(var r=(e=e).slice(1),i=[],a=0,o=n.cells.slice().reverse();a<o.length;a++){var s=o[a];Array.isArray(s.stateSize)?i.push(r.splice(0,s.stateSize.length)):i.push(r.splice(0,1))}i.reverse();for(var l,u=[],c=0;c<n.cells.length;++c){s=n.cells[c];r=i[c],l=0===c?[e[0]].concat(r):[l[0]].concat(r),l=s.call(l,t),u.push(l.slice(1))}r=[];for(var p=0,h=u.slice().reverse();p<h.length;p++){var d=h[p];r.push.apply(r,d)}return[l[0]].concat(r)})},t.prototype.build=function(e){var t;isArrayOfShapes(e)&&(e=e[0]),e=e;for(var n=0,r=this.cells;n<r.length;n++){var i=r[n];i.build(e),t=Array.isArray(i.stateSize)?i.stateSize[0]:i.stateSize,e=[e[0],t]}this.built=!0},t.prototype.getConfig=function(){for(var t=[],n=0,r=this.cells;n<r.length;n++){var i=r[n];t.push({className:this.getClassName(),config:i.getConfig()})}var a={cells:t},o=e.prototype.getConfig.call(this);return Object.assign(a,o),a},t.fromConfig=function(e,t,n){void 0===n&&(n={});for(var r=[],i=0,a=t.cells;i<a.length;i++){var o=a[i];r.push(deserialize(o,n))}return new e({cells:r})},Object.defineProperty(t.prototype,"trainableWeights",{get:function(){if(!this.trainable)return[];for(var e=[],t=0,n=this.cells;t<n.length;t++){var r=n[t];e.push.apply(e,r.trainableWeights)}return e},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"nonTrainableWeights",{get:function(){for(var e=[],t=0,n=this.cells;t<n.length;t++){var r=n[t];e.push.apply(e,r.nonTrainableWeights)}if(!this.trainable){for(var i=[],a=0,o=this.cells;a<o.length;a++){r=o[a];i.push.apply(i,r.trainableWeights)}return i.concat(e)}return e},enumerable:!0,configurable:!0}),t.prototype.getWeights=function(){for(var e=[],t=0,n=this.cells;t<n.length;t++){var r=n[t];e.push.apply(e,r.weights)}return batchGetValue(e)},t.prototype.setWeights=function(e){for(var t=[],n=0,r=this.cells;n<r.length;n++)for(var i=r[n],a=i.weights.length,o=e.splice(a),s=0;s<i.weights.length;++s)t.push([i.weights[s],o[s]]);batchSetValue(t)},t.className="StackedRNNCells",t}(RNNCell);function generateDropoutMask(e,t,n,r){function i(){return dropout(e(),getScalar(t))}if(void 0===n&&(n=null),void 0===r&&(r=1),r>1){for(var a=[],o=0;o<r;o++)a.push(inTrainPhase(i,e,n));return a.forEach(function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["keep"])(e)}),a}return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["keep"])(inTrainPhase(i,e,n))}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(StackedRNNCells);var Wrapper=function(e){function t(t){var n=e.call(this,t)||this;return n.layer=t.layer,n}return __extends(t,e),t.prototype.build=function(e){this.built=!0},Object.defineProperty(t.prototype,"trainable",{get:function(){return null!=this.layer&&this.layer.trainable},set:function(e){null!=this.layer&&(this.layer.trainable=e)},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"trainableWeights",{get:function(){return this.layer.trainableWeights},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"nonTrainableWeights",{get:function(){return this.layer.nonTrainableWeights},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"updates",{get:function(){return this.layer._updates},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"losses",{get:function(){return this.layer.losses},enumerable:!0,configurable:!0}),t.prototype.getWeights=function(){return this.layer.getWeights()},t.prototype.setWeights=function(e){this.layer.setWeights(e)},t.prototype.getConfig=function(){var t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.fromConfig=function(e,t,n){void 0===n&&(n={});var r=deserialize(t.layer,n);delete t.layer;var i={layer:r};return Object.assign(i,t),new e(i)},t}(Layer),TimeDistributed=function(e){function t(t){var n=e.call(this,t)||this;return n.supportsMasking=!0,n}return __extends(t,e),t.prototype.build=function(t){if((t=getExactlyOneShape(t)).length<3)throw new ValueError("TimeDistributed layer expects an input shape >= 3D, but received input shape "+JSON.stringify(t));this.inputSpec=[{shape:t}];var n=[t[0]].concat(t.slice(2));this.layer.built||(this.layer.build(n),this.layer.built=!0),e.prototype.build.call(this,t)},t.prototype.computeOutputShape=function(e){var t=[(e=getExactlyOneShape(e))[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),r=e[1];return[n[0],r].concat(n.slice(1))},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return rnn(function(e,r){return[getExactlyOneTensor(n.layer.call(e,t)),[]]},e=getExactlyOneTensor(e),[],!1,null,null,!1,!0)[1]})},t.className="TimeDistributed",t}(Wrapper);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(TimeDistributed);var VALID_BIDIRECTIONAL_MERGE_MODES=["sum","mul","concat","ave"];function checkBidirectionalMergeMode(e){checkStringTypeUnionValue(VALID_BIDIRECTIONAL_MERGE_MODES,"BidirectionalMergeMode",e)}var Bidirectional=function(e){function t(t){var n=e.call(this,t)||this,r=t.layer.getConfig();if(n.forwardLayer=deserialize({className:t.layer.getClassName(),config:r}),r.goBackwards=!0!==r.goBackwards,n.backwardLayer=deserialize({className:t.layer.getClassName(),config:r}),n.forwardLayer.name="forward_"+n.forwardLayer.name,n.backwardLayer.name="backward_"+n.backwardLayer.name,checkBidirectionalMergeMode(t.mergeMode),n.mergeMode=t.mergeMode,t.weights)throw new NotImplementedError("weights support is not implemented for Bidirectional layer yet.");return n._stateful=t.layer.stateful,n.returnSequences=t.layer.returnSequences,n.returnState=t.layer.returnState,n.supportsMasking=!0,n._trainable=!0,n.inputSpec=t.layer.inputSpec,n.numConstants=null,n}return __extends(t,e),Object.defineProperty(t.prototype,"trainable",{get:function(){return this._trainable},set:function(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)},enumerable:!0,configurable:!0}),t.prototype.getWeights=function(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())},t.prototype.setWeights=function(e){var t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))},t.prototype.computeOutputShape=function(e){var t,n,r,i=this.forwardLayer.computeOutputShape(e);return Array.isArray(i)&&Array.isArray(i[0])||(i=[i]),i=i,this.returnState?(r=i.slice(1),t=i[0]):t=i[0],t=t,"concat"===this.mergeMode?(t[t.length-1]*=2,n=[t]):n=null==this.mergeMode?[t,t.slice()]:[t],this.returnState?null==this.mergeMode?n.concat(r).concat(r.slice()):[t].concat(r).concat(r.slice()):singletonOrArray(n)},t.prototype.apply=function(t,n){var r=null==n?null:n.initialState,i=null==n?null:n.constants;null==n&&(n={});var a=standardizeArgs(t,r,i,this.numConstants);if(t=a.inputs,r=a.initialState,i=a.constants,Array.isArray(t)&&(r=t.slice(1),t=t[0]),(null==r||0===r.length)&&null==i)return e.prototype.apply.call(this,t,n);var o=[],s=[];if(null!=r){var l=r.length;if(l%2>0)throw new ValueError("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");n.initialState=r,o.push.apply(o,r);var u=r.map(function(e){return new InputSpec({shape:e.shape})});this.forwardLayer.stateSpec=u.slice(0,l/2),this.backwardLayer.stateSpec=u.slice(l/2),s.push.apply(s,u)}if(null!=i)throw new NotImplementedError("Support for constants in Bidirectional layers is not implemented yet.");for(var c=o[0]instanceof SymbolicTensor,p=0,h=o;p<h.length;p++){if(h[p]instanceof SymbolicTensor!==c)throw new ValueError("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors")}if(c){var d=[t].concat(o),f=this.inputSpec.concat(s),g=this.inputSpec;this.inputSpec=f;var m=e.prototype.apply.call(this,d,n);return this.inputSpec=g,m}return e.prototype.apply.call(this,t,n)},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(null!=t.mask)throw new NotImplementedError("The support for masking is not implemented for Bidirectional layers yet.");var r,i,a,o,s=t.initialState;if(null==s)r=n.forwardLayer.call(e,t),i=n.backwardLayer.call(e,t);else{var l=s.slice(0,s.length/2),u=s.slice(s.length/2);r=n.forwardLayer.call(e,Object.assign(t,{initialState:l})),i=n.backwardLayer.call(e,Object.assign(t,{initialState:u}))}return n.returnState&&(Array.isArray(r)&&(a=r.slice(1).concat(i.slice(1))),r=r[0],i=i[0]),n.returnSequences&&(i=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reverse"])(i,1)),"concat"===n.mergeMode?o=concatenate([r,i]):"sum"===n.mergeMode?o=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(r,i):"ave"===n.mergeMode?o=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(getScalar(.5),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(r,i)):"mul"===n.mergeMode?o=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(r,i):null==n.mergeMode&&(o=[r,i]),n.returnState?null==n.mergeMode?o.concat(a):[o].concat(a):o})},t.prototype.resetStates=function(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()},t.prototype.build=function(e){var t=this;nameScope(this.forwardLayer.name,function(){t.forwardLayer.build(e)}),nameScope(this.backwardLayer.name,function(){t.backwardLayer.build(e)}),this.built=!0},Object.defineProperty(t.prototype,"trainableWeights",{get:function(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"nonTrainableWeights",{get:function(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)},enumerable:!0,configurable:!0}),t.prototype.getConfig=function(){var t={mergeMode:this.mergeMode},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.fromConfig=function(e,t){var n=deserialize(t.layer);if(delete t.layer,null!=t.numConstants)throw new NotImplementedError("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");var r=t;return r.layer=n,new e(r)},t.className="Bidirectional",t}(Wrapper);function inputLayer(e){return new InputLayer(e)}function elu$2(e){return new ELU(e)}function reLU(e){return new ReLU(e)}function leakyReLU(e){return new LeakyReLU(e)}function softmax$1(e){return new Softmax$1(e)}function thresholdedReLU(e){return new ThresholdedReLU(e)}function conv1d$2(e){return new Conv1D(e)}function conv2d$2(e){return new Conv2D(e)}function conv2dTranspose$1(e){return new Conv2DTranspose(e)}function separableConv2d$1(e){return new SeparableConv2D(e)}function cropping2D(e){return new Cropping2D(e)}function upSampling2d(e){return new UpSampling2D(e)}function depthwiseConv2d$2(e){return new DepthwiseConv2D(e)}function activation(e){return new Activation$1(e)}function dense(e){return new Dense(e)}function dropout$1(e){return new Dropout(e)}function flatten$1(e){return new Flatten(e)}function repeatVector(e){return new RepeatVector(e)}function reshape(e){return new Reshape(e)}function permute(e){return new Permute(e)}function embedding(e){return new Embedding(e)}function add$2(e){return new Add(e)}function average$1(e){return new Average(e)}function concatenate$2(e){return new Concatenate(e)}function maximum$2(e){return new Maximum(e)}function minimum$2(e){return new Minimum(e)}function multiply$1(e){return new Multiply(e)}function dot$1(e){return new Dot(e)}function batchNormalization$1(e){return new BatchNormalization(e)}function zeroPadding2d(e){return new ZeroPadding2D(e)}function averagePooling1d(e){return new AveragePooling1D(e)}function avgPool1d(e){return averagePooling1d(e)}function avgPooling1d(e){return averagePooling1d(e)}function averagePooling2d(e){return new AveragePooling2D(e)}function avgPool2d(e){return averagePooling2d(e)}function avgPooling2d(e){return averagePooling2d(e)}function globalAveragePooling1d(e){return new GlobalAveragePooling1D(e)}function globalAveragePooling2d(e){return new GlobalAveragePooling2D(e)}function globalMaxPooling1d(e){return new GlobalMaxPooling1D(e)}function globalMaxPooling2d(e){return new GlobalMaxPooling2D(e)}function maxPooling1d(e){return new MaxPooling1D(e)}function maxPooling2d(e){return new MaxPooling2D(e)}function gru(e){return new GRU(e)}function gruCell(e){return new GRUCell(e)}function lstm(e){return new LSTM(e)}function lstmCell(e){return new LSTMCell(e)}function simpleRNN(e){return new SimpleRNN(e)}function simpleRNNCell(e){return new SimpleRNNCell(e)}function rnn$1(e){return new RNN(e)}function stackedRNNCells(e){return new StackedRNNCells(e)}function bidirectional(e){return new Bidirectional(e)}function timeDistributed(e){return new TimeDistributed(e)}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Bidirectional);var globalMaxPool1d=globalMaxPooling1d,globalMaxPool2d=globalMaxPooling2d,maxPool1d=maxPooling1d,maxPool2d=maxPooling2d,exports_layers=Object.freeze({inputLayer:inputLayer,elu:elu$2,reLU:reLU,leakyReLU:leakyReLU,softmax:softmax$1,thresholdedReLU:thresholdedReLU,conv1d:conv1d$2,conv2d:conv2d$2,conv2dTranspose:conv2dTranspose$1,separableConv2d:separableConv2d$1,cropping2D:cropping2D,upSampling2d:upSampling2d,depthwiseConv2d:depthwiseConv2d$2,activation:activation,dense:dense,dropout:dropout$1,flatten:flatten$1,repeatVector:repeatVector,reshape:reshape,permute:permute,embedding:embedding,add:add$2,average:average$1,concatenate:concatenate$2,maximum:maximum$2,minimum:minimum$2,multiply:multiply$1,dot:dot$1,batchNormalization:batchNormalization$1,zeroPadding2d:zeroPadding2d,averagePooling1d:averagePooling1d,avgPool1d:avgPool1d,avgPooling1d:avgPooling1d,averagePooling2d:averagePooling2d,avgPool2d:avgPool2d,avgPooling2d:avgPooling2d,globalAveragePooling1d:globalAveragePooling1d,globalAveragePooling2d:globalAveragePooling2d,globalMaxPooling1d:globalMaxPooling1d,globalMaxPooling2d:globalMaxPooling2d,maxPooling1d:maxPooling1d,maxPooling2d:maxPooling2d,gru:gru,gruCell:gruCell,lstm:lstm,lstmCell:lstmCell,simpleRNN:simpleRNN,simpleRNNCell:simpleRNNCell,rnn:rnn$1,stackedRNNCells:stackedRNNCells,bidirectional:bidirectional,timeDistributed:timeDistributed,globalMaxPool1d:globalMaxPool1d,globalMaxPool2d:globalMaxPool2d,maxPool1d:maxPool1d,maxPool2d:maxPool2d,Layer:Layer,RNN:RNN,RNNCell:RNNCell,input:input}),exports_models=Object.freeze({modelFromJSON:modelFromJSON});function binaryAccuracy$1(e,t){return binaryAccuracy(e,t)}function binaryCrossentropy$2(e,t){return binaryCrossentropy$1(e,t)}function categoricalAccuracy$1(e,t){return categoricalAccuracy(e,t)}function categoricalCrossentropy$2(e,t){return categoricalCrossentropy$1(e,t)}function precision$1(e,t){return precision(e,t)}function recall$1(e,t){return recall(e,t)}function cosineProximity$1(e,t){return cosineProximity(e,t)}function meanAbsoluteError$1(e,t){return meanAbsoluteError(e,t)}function meanAbsolutePercentageError$1(e,t){return meanAbsolutePercentageError(e,t)}function MAPE$2(e,t){return meanAbsolutePercentageError(e,t)}function mape$2(e,t){return meanAbsolutePercentageError(e,t)}function meanSquaredError$1(e,t){return meanSquaredError(e,t)}function MSE$2(e,t){return meanSquaredError(e,t)}function mse$2(e,t){return meanSquaredError(e,t)}var exports_metrics=Object.freeze({binaryAccuracy:binaryAccuracy$1,binaryCrossentropy:binaryCrossentropy$2,categoricalAccuracy:categoricalAccuracy$1,categoricalCrossentropy:categoricalCrossentropy$2,precision:precision$1,recall:recall$1,cosineProximity:cosineProximity$1,meanAbsoluteError:meanAbsoluteError$1,meanAbsolutePercentageError:meanAbsolutePercentageError$1,MAPE:MAPE$2,mape:mape$2,meanSquaredError:meanSquaredError$1,MSE:MSE$2,mse:mse$2});function l1l2(e){return new L1L2(e)}function l1$1(e){return l1(e)}function l2$1(e){return l2(e)}var exports_regularizers=Object.freeze({l1l2:l1l2,l1:l1$1,l2:l2$1}),Callback=function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t.model=null,t}return __extends(t,e),t.prototype.setModel=function(e){if(!(e instanceof Model))throw new Error("model must be a Model, not some other Container");this.model=e},t}(BaseCallback);
//# sourceMappingURL=tf-layers.esm.js.map


/***/ }),

/***/ "./node_modules/@tensorflow/tfjs/dist/tf.esm.js":
/*!******************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs/dist/tf.esm.js ***!
  \******************************************************/
/*! exports provided: version, setBackend, getBackend, disposeVariables, memory, version_core, nextFrame, environment, io, math, serialization, test_util, util, webgl, AdadeltaOptimizer, AdagradOptimizer, AdamOptimizer, AdamaxOptimizer, MomentumOptimizer, Optimizer, RMSPropOptimizer, SGDOptimizer, Tensor, TensorBuffer, variable, Variable, Rank, Reduction, ENV, Environment, KernelBackend, DataStorage, image, linalg, losses, spectral, op, batchNormalization2d, batchNormalization3d, batchNormalization4d, batchNormalization, complex, real, imag, concat, concat1d, concat2d, concat3d, concat4d, split, conv1d, conv2d, conv2dDerFilter, depthwiseConv2d, separableConv2d, conv2dTranspose, matMul, dot, outerProduct, reverse, reverse1d, reverse2d, reverse3d, reverse4d, maxPool, avgPool, pool, slice, slice1d, slice2d, slice3d, slice4d, abs, acos, acosh, asin, asinh, atan, atanh, ceil, clipByValue, cos, cosh, erf, exp, expm1, floor, log, log1p, logSigmoid, neg, reciprocal, round, rsqrt, sigmoid, sign, sin, sinh, softplus, sqrt, square, step, tan, tanh, all, any, argMax, argMin, logSumExp, max, mean, min, moments, sum, prod, equal, equalStrict, greater, greaterEqual, greaterEqualStrict, greaterStrict, less, lessEqual, lessEqualStrict, lessStrict, notEqual, notEqualStrict, add, addN, addStrict, atan2, div, divStrict, floorDiv, maximum, maximumStrict, minimum, minimumStrict, mod, modStrict, mul, mulStrict, pow, powStrict, squaredDifference, squaredDifferenceStrict, sub, subStrict, elu, leakyRelu, prelu, relu, selu, logicalAnd, logicalNot, logicalOr, logicalXor, where, whereAsync, buffer, toPixels, print, batchToSpaceND, cast, clone, cumsum, depthToSpace, expandDims, eye, fromPixels, multinomial, oneHot, pad, pad1d, pad2d, pad3d, pad4d, rand, randomNormal, randomUniform, reshape, spaceToBatchND, squeeze, stack, tile, truncatedNormal, unstack, setdiff1dAsync, fill, linspace, ones, range, scalar, tensor, tensor1d, tensor2d, tensor3d, tensor4d, tensor5d, tensor6d, zeros, onesLike, zerosLike, transpose, softmax, logSoftmax, localResponseNormalization, norm, gather, unsortedSegmentSum, basicLSTMCell, multiRNNCell, movingAverage, stridedSlice, topk, scatterND, fft, ifft, rfft, sparseToDense, gatherND, train, tidy, keep, dispose, time, profile, customGrad, grad, grads, valueAndGrad, valueAndGrads, variableGrads, constraints, initializers, layers, models, metrics, regularizers, CallbackList, CustomCallback, History, Callback, InputSpec, SymbolicTensor, Model, input, loadModel, model, registerCallbackConstructor, sequential, RNN, Sequential, LayerVariable, version_layers, FrozenModel, loadFrozenModel, version_converter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version", function() { return version$1; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setBackend", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["setBackend"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getBackend", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["getBackend"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "disposeVariables", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["disposeVariables"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "memory", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["memory"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "version_core", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["version_core"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "nextFrame", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["nextFrame"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "environment", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["environment"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "io", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["io"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "math", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["math"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "serialization", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "test_util", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["test_util"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "util", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "webgl", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["webgl"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AdadeltaOptimizer", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["AdadeltaOptimizer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AdagradOptimizer", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["AdagradOptimizer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AdamOptimizer", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["AdamOptimizer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AdamaxOptimizer", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["AdamaxOptimizer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MomentumOptimizer", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["MomentumOptimizer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Optimizer", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Optimizer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RMSPropOptimizer", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["RMSPropOptimizer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SGDOptimizer", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["SGDOptimizer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tensor", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Tensor"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TensorBuffer", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["TensorBuffer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "variable", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["variable"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Variable", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Variable"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Rank", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Rank"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Reduction", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Reduction"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ENV", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["ENV"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Environment", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Environment"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "KernelBackend", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["KernelBackend"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DataStorage", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["DataStorage"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "image", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["image"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "linalg", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["linalg"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "losses", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["losses"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "spectral", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["spectral"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "op", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["op"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "batchNormalization2d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["batchNormalization2d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "batchNormalization3d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["batchNormalization3d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "batchNormalization4d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["batchNormalization4d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "batchNormalization", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["batchNormalization"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "complex", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["complex"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "real", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["real"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "imag", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["imag"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "concat", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["concat"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "concat1d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["concat1d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "concat2d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["concat2d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "concat3d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["concat3d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "concat4d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["concat4d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "split", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["split"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "conv1d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["conv1d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "conv2d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["conv2d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "conv2dDerFilter", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["conv2dDerFilter"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "depthwiseConv2d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["depthwiseConv2d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "separableConv2d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["separableConv2d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "conv2dTranspose", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["conv2dTranspose"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "matMul", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["matMul"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dot"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "outerProduct", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["outerProduct"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reverse", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reverse"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reverse1d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reverse1d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reverse2d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reverse2d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reverse3d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reverse3d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reverse4d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reverse4d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "maxPool", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["maxPool"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "avgPool", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["avgPool"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pool", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["pool"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "slice", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "slice1d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice1d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "slice2d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice2d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "slice3d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice3d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "slice4d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice4d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "abs", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["abs"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "acos", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["acos"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "acosh", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["acosh"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "asin", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["asin"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "asinh", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["asinh"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "atan", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["atan"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "atanh", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["atanh"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ceil", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["ceil"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "clipByValue", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clipByValue"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cos", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["cos"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cosh", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["cosh"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "erf", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["erf"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "exp", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["exp"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "expm1", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["expm1"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "floor", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["floor"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "log", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["log"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "log1p", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["log1p"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "logSigmoid", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["logSigmoid"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "neg", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["neg"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reciprocal", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reciprocal"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "round", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["round"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "rsqrt", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["rsqrt"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sigmoid", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sigmoid"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sign", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sign"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sin", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sin"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sinh", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sinh"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "softplus", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["softplus"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sqrt", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sqrt"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "square", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["square"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "step", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["step"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tan", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tan"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tanh", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tanh"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "all", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["all"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "any", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["any"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "argMax", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["argMax"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "argMin", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["argMin"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "logSumExp", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["logSumExp"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "max", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["max"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mean", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "min", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["min"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "moments", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["moments"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sum", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sum"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "prod", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["prod"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "equal", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["equal"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "equalStrict", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["equalStrict"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "greater", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["greater"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "greaterEqual", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["greaterEqual"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "greaterEqualStrict", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["greaterEqualStrict"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "greaterStrict", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["greaterStrict"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "less", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["less"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lessEqual", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["lessEqual"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lessEqualStrict", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["lessEqualStrict"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lessStrict", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["lessStrict"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "notEqual", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["notEqual"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "notEqualStrict", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["notEqualStrict"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "add", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "addN", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["addN"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "addStrict", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["addStrict"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "atan2", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["atan2"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "div", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "divStrict", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["divStrict"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "floorDiv", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["floorDiv"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "maximum", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["maximum"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "maximumStrict", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["maximumStrict"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "minimum", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["minimum"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "minimumStrict", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["minimumStrict"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mod", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mod"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "modStrict", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["modStrict"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mulStrict", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mulStrict"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pow", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["pow"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "powStrict", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["powStrict"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "squaredDifference", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["squaredDifference"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "squaredDifferenceStrict", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["squaredDifferenceStrict"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "subStrict", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["subStrict"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "elu", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["elu"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "leakyRelu", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["leakyRelu"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "prelu", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["prelu"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "relu", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["relu"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "selu", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["selu"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "logicalAnd", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["logicalAnd"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "logicalNot", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["logicalNot"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "logicalOr", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["logicalOr"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "logicalXor", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["logicalXor"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "where", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["where"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "whereAsync", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["whereAsync"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "buffer", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["buffer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toPixels", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["toPixels"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "print", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["print"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "batchToSpaceND", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["batchToSpaceND"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cast", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["cast"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clone"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cumsum", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["cumsum"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "depthToSpace", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["depthToSpace"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "expandDims", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["expandDims"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "eye", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["eye"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fromPixels", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["fromPixels"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "multinomial", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["multinomial"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "oneHot", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["oneHot"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pad", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["pad"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pad1d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["pad1d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pad2d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["pad2d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pad3d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["pad3d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pad4d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["pad4d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "rand", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["rand"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "randomNormal", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["randomNormal"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "randomUniform", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["randomUniform"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reshape", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reshape"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "spaceToBatchND", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["spaceToBatchND"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "squeeze", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["squeeze"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stack", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["stack"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tile", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tile"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "truncatedNormal", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["truncatedNormal"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unstack", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["unstack"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setdiff1dAsync", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["setdiff1dAsync"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fill", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["fill"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "linspace", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["linspace"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ones", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["ones"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "range", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["range"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scalar", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tensor", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tensor1d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor1d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tensor2d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor2d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tensor3d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor3d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tensor4d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor4d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tensor5d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor5d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tensor6d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor6d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zeros", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["zeros"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "onesLike", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["onesLike"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zerosLike", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["zerosLike"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "transpose", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "softmax", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["softmax"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "logSoftmax", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["logSoftmax"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "localResponseNormalization", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["localResponseNormalization"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "norm", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["norm"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "gather", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["gather"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unsortedSegmentSum", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["unsortedSegmentSum"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "basicLSTMCell", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["basicLSTMCell"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "multiRNNCell", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["multiRNNCell"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "movingAverage", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["movingAverage"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stridedSlice", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["stridedSlice"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "topk", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["topk"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scatterND", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scatterND"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fft", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["fft"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ifft", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["ifft"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "rfft", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["rfft"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sparseToDense", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sparseToDense"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "gatherND", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["gatherND"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "train", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["train"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tidy", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "keep", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["keep"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dispose", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "time", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["time"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "profile", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["profile"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "customGrad", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["customGrad"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "grad", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["grad"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "grads", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["grads"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "valueAndGrad", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["valueAndGrad"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "valueAndGrads", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["valueAndGrads"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "variableGrads", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["variableGrads"]; });

/* harmony import */ var _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tensorflow/tfjs-layers */ "./node_modules/@tensorflow/tfjs-layers/dist/tf-layers.esm.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "constraints", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["constraints"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "initializers", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["initializers"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "layers", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["layers"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "models", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["models"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "metrics", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["metrics"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "regularizers", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["regularizers"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CallbackList", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["CallbackList"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CustomCallback", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["CustomCallback"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "History", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["History"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Callback", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["Callback"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "InputSpec", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["InputSpec"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SymbolicTensor", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["SymbolicTensor"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Model", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["Model"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "input", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["input"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadModel", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["loadModel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "model", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["model"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "registerCallbackConstructor", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["registerCallbackConstructor"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sequential", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["sequential"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RNN", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["RNN"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Sequential", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["Sequential"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LayerVariable", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["LayerVariable"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "version_layers", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["version_layers"]; });

/* harmony import */ var _tensorflow_tfjs_converter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tensorflow/tfjs-converter */ "./node_modules/@tensorflow/tfjs-converter/dist/tf-converter.esm.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FrozenModel", function() { return _tensorflow_tfjs_converter__WEBPACK_IMPORTED_MODULE_2__["FrozenModel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadFrozenModel", function() { return _tensorflow_tfjs_converter__WEBPACK_IMPORTED_MODULE_2__["loadFrozenModel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "version_converter", function() { return _tensorflow_tfjs_converter__WEBPACK_IMPORTED_MODULE_2__["version_converter"]; });

// @tensorflow/tfjs Copyright 2018 Google
var version="0.13.5",version$1={"tfjs-core":_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["version_core"],"tfjs-layers":_tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["version_layers"],"tfjs-converter":_tensorflow_tfjs_converter__WEBPACK_IMPORTED_MODULE_2__["version_converter"],tfjs:version};
//# sourceMappingURL=tf.esm.js.map


/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1.js":
/*!******************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var asn1 = exports;

asn1.bignum = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");

asn1.define = __webpack_require__(/*! ./asn1/api */ "./node_modules/asn1.js/lib/asn1/api.js").define;
asn1.base = __webpack_require__(/*! ./asn1/base */ "./node_modules/asn1.js/lib/asn1/base/index.js");
asn1.constants = __webpack_require__(/*! ./asn1/constants */ "./node_modules/asn1.js/lib/asn1/constants/index.js");
asn1.decoders = __webpack_require__(/*! ./asn1/decoders */ "./node_modules/asn1.js/lib/asn1/decoders/index.js");
asn1.encoders = __webpack_require__(/*! ./asn1/encoders */ "./node_modules/asn1.js/lib/asn1/encoders/index.js");


/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/api.js":
/*!**********************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/api.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var asn1 = __webpack_require__(/*! ../asn1 */ "./node_modules/asn1.js/lib/asn1.js");
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

var api = exports;

api.define = function define(name, body) {
  return new Entity(name, body);
};

function Entity(name, body) {
  this.name = name;
  this.body = body;

  this.decoders = {};
  this.encoders = {};
};

Entity.prototype._createNamed = function createNamed(base) {
  var named;
  try {
    named = __webpack_require__(/*! vm */ "./node_modules/vm-browserify/index.js").runInThisContext(
      '(function ' + this.name + '(entity) {\n' +
      '  this._initNamed(entity);\n' +
      '})'
    );
  } catch (e) {
    named = function (entity) {
      this._initNamed(entity);
    };
  }
  inherits(named, base);
  named.prototype._initNamed = function initnamed(entity) {
    base.call(this, entity);
  };

  return new named(this);
};

Entity.prototype._getDecoder = function _getDecoder(enc) {
  enc = enc || 'der';
  // Lazily create decoder
  if (!this.decoders.hasOwnProperty(enc))
    this.decoders[enc] = this._createNamed(asn1.decoders[enc]);
  return this.decoders[enc];
};

Entity.prototype.decode = function decode(data, enc, options) {
  return this._getDecoder(enc).decode(data, options);
};

Entity.prototype._getEncoder = function _getEncoder(enc) {
  enc = enc || 'der';
  // Lazily create encoder
  if (!this.encoders.hasOwnProperty(enc))
    this.encoders[enc] = this._createNamed(asn1.encoders[enc]);
  return this.encoders[enc];
};

Entity.prototype.encode = function encode(data, enc, /* internal */ reporter) {
  return this._getEncoder(enc).encode(data, reporter);
};


/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/base/buffer.js":
/*!******************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/base/buffer.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
var Reporter = __webpack_require__(/*! ../base */ "./node_modules/asn1.js/lib/asn1/base/index.js").Reporter;
var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js").Buffer;

function DecoderBuffer(base, options) {
  Reporter.call(this, options);
  if (!Buffer.isBuffer(base)) {
    this.error('Input not Buffer');
    return;
  }

  this.base = base;
  this.offset = 0;
  this.length = base.length;
}
inherits(DecoderBuffer, Reporter);
exports.DecoderBuffer = DecoderBuffer;

DecoderBuffer.prototype.save = function save() {
  return { offset: this.offset, reporter: Reporter.prototype.save.call(this) };
};

DecoderBuffer.prototype.restore = function restore(save) {
  // Return skipped data
  var res = new DecoderBuffer(this.base);
  res.offset = save.offset;
  res.length = this.offset;

  this.offset = save.offset;
  Reporter.prototype.restore.call(this, save.reporter);

  return res;
};

DecoderBuffer.prototype.isEmpty = function isEmpty() {
  return this.offset === this.length;
};

DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
  if (this.offset + 1 <= this.length)
    return this.base.readUInt8(this.offset++, true);
  else
    return this.error(fail || 'DecoderBuffer overrun');
}

DecoderBuffer.prototype.skip = function skip(bytes, fail) {
  if (!(this.offset + bytes <= this.length))
    return this.error(fail || 'DecoderBuffer overrun');

  var res = new DecoderBuffer(this.base);

  // Share reporter state
  res._reporterState = this._reporterState;

  res.offset = this.offset;
  res.length = this.offset + bytes;
  this.offset += bytes;
  return res;
}

DecoderBuffer.prototype.raw = function raw(save) {
  return this.base.slice(save ? save.offset : this.offset, this.length);
}

function EncoderBuffer(value, reporter) {
  if (Array.isArray(value)) {
    this.length = 0;
    this.value = value.map(function(item) {
      if (!(item instanceof EncoderBuffer))
        item = new EncoderBuffer(item, reporter);
      this.length += item.length;
      return item;
    }, this);
  } else if (typeof value === 'number') {
    if (!(0 <= value && value <= 0xff))
      return reporter.error('non-byte EncoderBuffer value');
    this.value = value;
    this.length = 1;
  } else if (typeof value === 'string') {
    this.value = value;
    this.length = Buffer.byteLength(value);
  } else if (Buffer.isBuffer(value)) {
    this.value = value;
    this.length = value.length;
  } else {
    return reporter.error('Unsupported type: ' + typeof value);
  }
}
exports.EncoderBuffer = EncoderBuffer;

EncoderBuffer.prototype.join = function join(out, offset) {
  if (!out)
    out = new Buffer(this.length);
  if (!offset)
    offset = 0;

  if (this.length === 0)
    return out;

  if (Array.isArray(this.value)) {
    this.value.forEach(function(item) {
      item.join(out, offset);
      offset += item.length;
    });
  } else {
    if (typeof this.value === 'number')
      out[offset] = this.value;
    else if (typeof this.value === 'string')
      out.write(this.value, offset);
    else if (Buffer.isBuffer(this.value))
      this.value.copy(out, offset);
    offset += this.length;
  }

  return out;
};


/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/base/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/base/index.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var base = exports;

base.Reporter = __webpack_require__(/*! ./reporter */ "./node_modules/asn1.js/lib/asn1/base/reporter.js").Reporter;
base.DecoderBuffer = __webpack_require__(/*! ./buffer */ "./node_modules/asn1.js/lib/asn1/base/buffer.js").DecoderBuffer;
base.EncoderBuffer = __webpack_require__(/*! ./buffer */ "./node_modules/asn1.js/lib/asn1/base/buffer.js").EncoderBuffer;
base.Node = __webpack_require__(/*! ./node */ "./node_modules/asn1.js/lib/asn1/base/node.js");


/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/base/node.js":
/*!****************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/base/node.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Reporter = __webpack_require__(/*! ../base */ "./node_modules/asn1.js/lib/asn1/base/index.js").Reporter;
var EncoderBuffer = __webpack_require__(/*! ../base */ "./node_modules/asn1.js/lib/asn1/base/index.js").EncoderBuffer;
var DecoderBuffer = __webpack_require__(/*! ../base */ "./node_modules/asn1.js/lib/asn1/base/index.js").DecoderBuffer;
var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/minimalistic-assert/index.js");

// Supported tags
var tags = [
  'seq', 'seqof', 'set', 'setof', 'objid', 'bool',
  'gentime', 'utctime', 'null_', 'enum', 'int', 'objDesc',
  'bitstr', 'bmpstr', 'charstr', 'genstr', 'graphstr', 'ia5str', 'iso646str',
  'numstr', 'octstr', 'printstr', 't61str', 'unistr', 'utf8str', 'videostr'
];

// Public methods list
var methods = [
  'key', 'obj', 'use', 'optional', 'explicit', 'implicit', 'def', 'choice',
  'any', 'contains'
].concat(tags);

// Overrided methods list
var overrided = [
  '_peekTag', '_decodeTag', '_use',
  '_decodeStr', '_decodeObjid', '_decodeTime',
  '_decodeNull', '_decodeInt', '_decodeBool', '_decodeList',

  '_encodeComposite', '_encodeStr', '_encodeObjid', '_encodeTime',
  '_encodeNull', '_encodeInt', '_encodeBool'
];

function Node(enc, parent) {
  var state = {};
  this._baseState = state;

  state.enc = enc;

  state.parent = parent || null;
  state.children = null;

  // State
  state.tag = null;
  state.args = null;
  state.reverseArgs = null;
  state.choice = null;
  state.optional = false;
  state.any = false;
  state.obj = false;
  state.use = null;
  state.useDecoder = null;
  state.key = null;
  state['default'] = null;
  state.explicit = null;
  state.implicit = null;
  state.contains = null;

  // Should create new instance on each method
  if (!state.parent) {
    state.children = [];
    this._wrap();
  }
}
module.exports = Node;

var stateProps = [
  'enc', 'parent', 'children', 'tag', 'args', 'reverseArgs', 'choice',
  'optional', 'any', 'obj', 'use', 'alteredUse', 'key', 'default', 'explicit',
  'implicit', 'contains'
];

Node.prototype.clone = function clone() {
  var state = this._baseState;
  var cstate = {};
  stateProps.forEach(function(prop) {
    cstate[prop] = state[prop];
  });
  var res = new this.constructor(cstate.parent);
  res._baseState = cstate;
  return res;
};

Node.prototype._wrap = function wrap() {
  var state = this._baseState;
  methods.forEach(function(method) {
    this[method] = function _wrappedMethod() {
      var clone = new this.constructor(this);
      state.children.push(clone);
      return clone[method].apply(clone, arguments);
    };
  }, this);
};

Node.prototype._init = function init(body) {
  var state = this._baseState;

  assert(state.parent === null);
  body.call(this);

  // Filter children
  state.children = state.children.filter(function(child) {
    return child._baseState.parent === this;
  }, this);
  assert.equal(state.children.length, 1, 'Root node can have only one child');
};

Node.prototype._useArgs = function useArgs(args) {
  var state = this._baseState;

  // Filter children and args
  var children = args.filter(function(arg) {
    return arg instanceof this.constructor;
  }, this);
  args = args.filter(function(arg) {
    return !(arg instanceof this.constructor);
  }, this);

  if (children.length !== 0) {
    assert(state.children === null);
    state.children = children;

    // Replace parent to maintain backward link
    children.forEach(function(child) {
      child._baseState.parent = this;
    }, this);
  }
  if (args.length !== 0) {
    assert(state.args === null);
    state.args = args;
    state.reverseArgs = args.map(function(arg) {
      if (typeof arg !== 'object' || arg.constructor !== Object)
        return arg;

      var res = {};
      Object.keys(arg).forEach(function(key) {
        if (key == (key | 0))
          key |= 0;
        var value = arg[key];
        res[value] = key;
      });
      return res;
    });
  }
};

//
// Overrided methods
//

overrided.forEach(function(method) {
  Node.prototype[method] = function _overrided() {
    var state = this._baseState;
    throw new Error(method + ' not implemented for encoding: ' + state.enc);
  };
});

//
// Public methods
//

tags.forEach(function(tag) {
  Node.prototype[tag] = function _tagMethod() {
    var state = this._baseState;
    var args = Array.prototype.slice.call(arguments);

    assert(state.tag === null);
    state.tag = tag;

    this._useArgs(args);

    return this;
  };
});

Node.prototype.use = function use(item) {
  assert(item);
  var state = this._baseState;

  assert(state.use === null);
  state.use = item;

  return this;
};

Node.prototype.optional = function optional() {
  var state = this._baseState;

  state.optional = true;

  return this;
};

Node.prototype.def = function def(val) {
  var state = this._baseState;

  assert(state['default'] === null);
  state['default'] = val;
  state.optional = true;

  return this;
};

Node.prototype.explicit = function explicit(num) {
  var state = this._baseState;

  assert(state.explicit === null && state.implicit === null);
  state.explicit = num;

  return this;
};

Node.prototype.implicit = function implicit(num) {
  var state = this._baseState;

  assert(state.explicit === null && state.implicit === null);
  state.implicit = num;

  return this;
};

Node.prototype.obj = function obj() {
  var state = this._baseState;
  var args = Array.prototype.slice.call(arguments);

  state.obj = true;

  if (args.length !== 0)
    this._useArgs(args);

  return this;
};

Node.prototype.key = function key(newKey) {
  var state = this._baseState;

  assert(state.key === null);
  state.key = newKey;

  return this;
};

Node.prototype.any = function any() {
  var state = this._baseState;

  state.any = true;

  return this;
};

Node.prototype.choice = function choice(obj) {
  var state = this._baseState;

  assert(state.choice === null);
  state.choice = obj;
  this._useArgs(Object.keys(obj).map(function(key) {
    return obj[key];
  }));

  return this;
};

Node.prototype.contains = function contains(item) {
  var state = this._baseState;

  assert(state.use === null);
  state.contains = item;

  return this;
};

//
// Decoding
//

Node.prototype._decode = function decode(input, options) {
  var state = this._baseState;

  // Decode root node
  if (state.parent === null)
    return input.wrapResult(state.children[0]._decode(input, options));

  var result = state['default'];
  var present = true;

  var prevKey = null;
  if (state.key !== null)
    prevKey = input.enterKey(state.key);

  // Check if tag is there
  if (state.optional) {
    var tag = null;
    if (state.explicit !== null)
      tag = state.explicit;
    else if (state.implicit !== null)
      tag = state.implicit;
    else if (state.tag !== null)
      tag = state.tag;

    if (tag === null && !state.any) {
      // Trial and Error
      var save = input.save();
      try {
        if (state.choice === null)
          this._decodeGeneric(state.tag, input, options);
        else
          this._decodeChoice(input, options);
        present = true;
      } catch (e) {
        present = false;
      }
      input.restore(save);
    } else {
      present = this._peekTag(input, tag, state.any);

      if (input.isError(present))
        return present;
    }
  }

  // Push object on stack
  var prevObj;
  if (state.obj && present)
    prevObj = input.enterObject();

  if (present) {
    // Unwrap explicit values
    if (state.explicit !== null) {
      var explicit = this._decodeTag(input, state.explicit);
      if (input.isError(explicit))
        return explicit;
      input = explicit;
    }

    var start = input.offset;

    // Unwrap implicit and normal values
    if (state.use === null && state.choice === null) {
      if (state.any)
        var save = input.save();
      var body = this._decodeTag(
        input,
        state.implicit !== null ? state.implicit : state.tag,
        state.any
      );
      if (input.isError(body))
        return body;

      if (state.any)
        result = input.raw(save);
      else
        input = body;
    }

    if (options && options.track && state.tag !== null)
      options.track(input.path(), start, input.length, 'tagged');

    if (options && options.track && state.tag !== null)
      options.track(input.path(), input.offset, input.length, 'content');

    // Select proper method for tag
    if (state.any)
      result = result;
    else if (state.choice === null)
      result = this._decodeGeneric(state.tag, input, options);
    else
      result = this._decodeChoice(input, options);

    if (input.isError(result))
      return result;

    // Decode children
    if (!state.any && state.choice === null && state.children !== null) {
      state.children.forEach(function decodeChildren(child) {
        // NOTE: We are ignoring errors here, to let parser continue with other
        // parts of encoded data
        child._decode(input, options);
      });
    }

    // Decode contained/encoded by schema, only in bit or octet strings
    if (state.contains && (state.tag === 'octstr' || state.tag === 'bitstr')) {
      var data = new DecoderBuffer(result);
      result = this._getUse(state.contains, input._reporterState.obj)
          ._decode(data, options);
    }
  }

  // Pop object
  if (state.obj && present)
    result = input.leaveObject(prevObj);

  // Set key
  if (state.key !== null && (result !== null || present === true))
    input.leaveKey(prevKey, state.key, result);
  else if (prevKey !== null)
    input.exitKey(prevKey);

  return result;
};

Node.prototype._decodeGeneric = function decodeGeneric(tag, input, options) {
  var state = this._baseState;

  if (tag === 'seq' || tag === 'set')
    return null;
  if (tag === 'seqof' || tag === 'setof')
    return this._decodeList(input, tag, state.args[0], options);
  else if (/str$/.test(tag))
    return this._decodeStr(input, tag, options);
  else if (tag === 'objid' && state.args)
    return this._decodeObjid(input, state.args[0], state.args[1], options);
  else if (tag === 'objid')
    return this._decodeObjid(input, null, null, options);
  else if (tag === 'gentime' || tag === 'utctime')
    return this._decodeTime(input, tag, options);
  else if (tag === 'null_')
    return this._decodeNull(input, options);
  else if (tag === 'bool')
    return this._decodeBool(input, options);
  else if (tag === 'objDesc')
    return this._decodeStr(input, tag, options);
  else if (tag === 'int' || tag === 'enum')
    return this._decodeInt(input, state.args && state.args[0], options);

  if (state.use !== null) {
    return this._getUse(state.use, input._reporterState.obj)
        ._decode(input, options);
  } else {
    return input.error('unknown tag: ' + tag);
  }
};

Node.prototype._getUse = function _getUse(entity, obj) {

  var state = this._baseState;
  // Create altered use decoder if implicit is set
  state.useDecoder = this._use(entity, obj);
  assert(state.useDecoder._baseState.parent === null);
  state.useDecoder = state.useDecoder._baseState.children[0];
  if (state.implicit !== state.useDecoder._baseState.implicit) {
    state.useDecoder = state.useDecoder.clone();
    state.useDecoder._baseState.implicit = state.implicit;
  }
  return state.useDecoder;
};

Node.prototype._decodeChoice = function decodeChoice(input, options) {
  var state = this._baseState;
  var result = null;
  var match = false;

  Object.keys(state.choice).some(function(key) {
    var save = input.save();
    var node = state.choice[key];
    try {
      var value = node._decode(input, options);
      if (input.isError(value))
        return false;

      result = { type: key, value: value };
      match = true;
    } catch (e) {
      input.restore(save);
      return false;
    }
    return true;
  }, this);

  if (!match)
    return input.error('Choice not matched');

  return result;
};

//
// Encoding
//

Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
  return new EncoderBuffer(data, this.reporter);
};

Node.prototype._encode = function encode(data, reporter, parent) {
  var state = this._baseState;
  if (state['default'] !== null && state['default'] === data)
    return;

  var result = this._encodeValue(data, reporter, parent);
  if (result === undefined)
    return;

  if (this._skipDefault(result, reporter, parent))
    return;

  return result;
};

Node.prototype._encodeValue = function encode(data, reporter, parent) {
  var state = this._baseState;

  // Decode root node
  if (state.parent === null)
    return state.children[0]._encode(data, reporter || new Reporter());

  var result = null;

  // Set reporter to share it with a child class
  this.reporter = reporter;

  // Check if data is there
  if (state.optional && data === undefined) {
    if (state['default'] !== null)
      data = state['default']
    else
      return;
  }

  // Encode children first
  var content = null;
  var primitive = false;
  if (state.any) {
    // Anything that was given is translated to buffer
    result = this._createEncoderBuffer(data);
  } else if (state.choice) {
    result = this._encodeChoice(data, reporter);
  } else if (state.contains) {
    content = this._getUse(state.contains, parent)._encode(data, reporter);
    primitive = true;
  } else if (state.children) {
    content = state.children.map(function(child) {
      if (child._baseState.tag === 'null_')
        return child._encode(null, reporter, data);

      if (child._baseState.key === null)
        return reporter.error('Child should have a key');
      var prevKey = reporter.enterKey(child._baseState.key);

      if (typeof data !== 'object')
        return reporter.error('Child expected, but input is not object');

      var res = child._encode(data[child._baseState.key], reporter, data);
      reporter.leaveKey(prevKey);

      return res;
    }, this).filter(function(child) {
      return child;
    });
    content = this._createEncoderBuffer(content);
  } else {
    if (state.tag === 'seqof' || state.tag === 'setof') {
      // TODO(indutny): this should be thrown on DSL level
      if (!(state.args && state.args.length === 1))
        return reporter.error('Too many args for : ' + state.tag);

      if (!Array.isArray(data))
        return reporter.error('seqof/setof, but data is not Array');

      var child = this.clone();
      child._baseState.implicit = null;
      content = this._createEncoderBuffer(data.map(function(item) {
        var state = this._baseState;

        return this._getUse(state.args[0], data)._encode(item, reporter);
      }, child));
    } else if (state.use !== null) {
      result = this._getUse(state.use, parent)._encode(data, reporter);
    } else {
      content = this._encodePrimitive(state.tag, data);
      primitive = true;
    }
  }

  // Encode data itself
  var result;
  if (!state.any && state.choice === null) {
    var tag = state.implicit !== null ? state.implicit : state.tag;
    var cls = state.implicit === null ? 'universal' : 'context';

    if (tag === null) {
      if (state.use === null)
        reporter.error('Tag could be omitted only for .use()');
    } else {
      if (state.use === null)
        result = this._encodeComposite(tag, primitive, cls, content);
    }
  }

  // Wrap in explicit
  if (state.explicit !== null)
    result = this._encodeComposite(state.explicit, false, 'context', result);

  return result;
};

Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
  var state = this._baseState;

  var node = state.choice[data.type];
  if (!node) {
    assert(
        false,
        data.type + ' not found in ' +
            JSON.stringify(Object.keys(state.choice)));
  }
  return node._encode(data.value, reporter);
};

Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
  var state = this._baseState;

  if (/str$/.test(tag))
    return this._encodeStr(data, tag);
  else if (tag === 'objid' && state.args)
    return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
  else if (tag === 'objid')
    return this._encodeObjid(data, null, null);
  else if (tag === 'gentime' || tag === 'utctime')
    return this._encodeTime(data, tag);
  else if (tag === 'null_')
    return this._encodeNull();
  else if (tag === 'int' || tag === 'enum')
    return this._encodeInt(data, state.args && state.reverseArgs[0]);
  else if (tag === 'bool')
    return this._encodeBool(data);
  else if (tag === 'objDesc')
    return this._encodeStr(data, tag);
  else
    throw new Error('Unsupported tag: ' + tag);
};

Node.prototype._isNumstr = function isNumstr(str) {
  return /^[0-9 ]*$/.test(str);
};

Node.prototype._isPrintstr = function isPrintstr(str) {
  return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(str);
};


/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/base/reporter.js":
/*!********************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/base/reporter.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

function Reporter(options) {
  this._reporterState = {
    obj: null,
    path: [],
    options: options || {},
    errors: []
  };
}
exports.Reporter = Reporter;

Reporter.prototype.isError = function isError(obj) {
  return obj instanceof ReporterError;
};

Reporter.prototype.save = function save() {
  var state = this._reporterState;

  return { obj: state.obj, pathLen: state.path.length };
};

Reporter.prototype.restore = function restore(data) {
  var state = this._reporterState;

  state.obj = data.obj;
  state.path = state.path.slice(0, data.pathLen);
};

Reporter.prototype.enterKey = function enterKey(key) {
  return this._reporterState.path.push(key);
};

Reporter.prototype.exitKey = function exitKey(index) {
  var state = this._reporterState;

  state.path = state.path.slice(0, index - 1);
};

Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
  var state = this._reporterState;

  this.exitKey(index);
  if (state.obj !== null)
    state.obj[key] = value;
};

Reporter.prototype.path = function path() {
  return this._reporterState.path.join('/');
};

Reporter.prototype.enterObject = function enterObject() {
  var state = this._reporterState;

  var prev = state.obj;
  state.obj = {};
  return prev;
};

Reporter.prototype.leaveObject = function leaveObject(prev) {
  var state = this._reporterState;

  var now = state.obj;
  state.obj = prev;
  return now;
};

Reporter.prototype.error = function error(msg) {
  var err;
  var state = this._reporterState;

  var inherited = msg instanceof ReporterError;
  if (inherited) {
    err = msg;
  } else {
    err = new ReporterError(state.path.map(function(elem) {
      return '[' + JSON.stringify(elem) + ']';
    }).join(''), msg.message || msg, msg.stack);
  }

  if (!state.options.partial)
    throw err;

  if (!inherited)
    state.errors.push(err);

  return err;
};

Reporter.prototype.wrapResult = function wrapResult(result) {
  var state = this._reporterState;
  if (!state.options.partial)
    return result;

  return {
    result: this.isError(result) ? null : result,
    errors: state.errors
  };
};

function ReporterError(path, msg) {
  this.path = path;
  this.rethrow(msg);
};
inherits(ReporterError, Error);

ReporterError.prototype.rethrow = function rethrow(msg) {
  this.message = msg + ' at: ' + (this.path || '(shallow)');
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, ReporterError);

  if (!this.stack) {
    try {
      // IE only adds stack when thrown
      throw new Error(this.message);
    } catch (e) {
      this.stack = e.stack;
    }
  }
  return this;
};


/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/constants/der.js":
/*!********************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/constants/der.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var constants = __webpack_require__(/*! ../constants */ "./node_modules/asn1.js/lib/asn1/constants/index.js");

exports.tagClass = {
  0: 'universal',
  1: 'application',
  2: 'context',
  3: 'private'
};
exports.tagClassByName = constants._reverse(exports.tagClass);

exports.tag = {
  0x00: 'end',
  0x01: 'bool',
  0x02: 'int',
  0x03: 'bitstr',
  0x04: 'octstr',
  0x05: 'null_',
  0x06: 'objid',
  0x07: 'objDesc',
  0x08: 'external',
  0x09: 'real',
  0x0a: 'enum',
  0x0b: 'embed',
  0x0c: 'utf8str',
  0x0d: 'relativeOid',
  0x10: 'seq',
  0x11: 'set',
  0x12: 'numstr',
  0x13: 'printstr',
  0x14: 't61str',
  0x15: 'videostr',
  0x16: 'ia5str',
  0x17: 'utctime',
  0x18: 'gentime',
  0x19: 'graphstr',
  0x1a: 'iso646str',
  0x1b: 'genstr',
  0x1c: 'unistr',
  0x1d: 'charstr',
  0x1e: 'bmpstr'
};
exports.tagByName = constants._reverse(exports.tag);


/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/constants/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/constants/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var constants = exports;

// Helper
constants._reverse = function reverse(map) {
  var res = {};

  Object.keys(map).forEach(function(key) {
    // Convert key to integer if it is stringified
    if ((key | 0) == key)
      key = key | 0;

    var value = map[key];
    res[value] = key;
  });

  return res;
};

constants.der = __webpack_require__(/*! ./der */ "./node_modules/asn1.js/lib/asn1/constants/der.js");


/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/decoders/der.js":
/*!*******************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/decoders/der.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

var asn1 = __webpack_require__(/*! ../../asn1 */ "./node_modules/asn1.js/lib/asn1.js");
var base = asn1.base;
var bignum = asn1.bignum;

// Import DER constants
var der = asn1.constants.der;

function DERDecoder(entity) {
  this.enc = 'der';
  this.name = entity.name;
  this.entity = entity;

  // Construct base tree
  this.tree = new DERNode();
  this.tree._init(entity.body);
};
module.exports = DERDecoder;

DERDecoder.prototype.decode = function decode(data, options) {
  if (!(data instanceof base.DecoderBuffer))
    data = new base.DecoderBuffer(data, options);

  return this.tree._decode(data, options);
};

// Tree methods

function DERNode(parent) {
  base.Node.call(this, 'der', parent);
}
inherits(DERNode, base.Node);

DERNode.prototype._peekTag = function peekTag(buffer, tag, any) {
  if (buffer.isEmpty())
    return false;

  var state = buffer.save();
  var decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"');
  if (buffer.isError(decodedTag))
    return decodedTag;

  buffer.restore(state);

  return decodedTag.tag === tag || decodedTag.tagStr === tag ||
    (decodedTag.tagStr + 'of') === tag || any;
};

DERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {
  var decodedTag = derDecodeTag(buffer,
                                'Failed to decode tag of "' + tag + '"');
  if (buffer.isError(decodedTag))
    return decodedTag;

  var len = derDecodeLen(buffer,
                         decodedTag.primitive,
                         'Failed to get length of "' + tag + '"');

  // Failure
  if (buffer.isError(len))
    return len;

  if (!any &&
      decodedTag.tag !== tag &&
      decodedTag.tagStr !== tag &&
      decodedTag.tagStr + 'of' !== tag) {
    return buffer.error('Failed to match tag: "' + tag + '"');
  }

  if (decodedTag.primitive || len !== null)
    return buffer.skip(len, 'Failed to match body of: "' + tag + '"');

  // Indefinite length... find END tag
  var state = buffer.save();
  var res = this._skipUntilEnd(
      buffer,
      'Failed to skip indefinite length body: "' + this.tag + '"');
  if (buffer.isError(res))
    return res;

  len = buffer.offset - state.offset;
  buffer.restore(state);
  return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
};

DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {
  while (true) {
    var tag = derDecodeTag(buffer, fail);
    if (buffer.isError(tag))
      return tag;
    var len = derDecodeLen(buffer, tag.primitive, fail);
    if (buffer.isError(len))
      return len;

    var res;
    if (tag.primitive || len !== null)
      res = buffer.skip(len)
    else
      res = this._skipUntilEnd(buffer, fail);

    // Failure
    if (buffer.isError(res))
      return res;

    if (tag.tagStr === 'end')
      break;
  }
};

DERNode.prototype._decodeList = function decodeList(buffer, tag, decoder,
                                                    options) {
  var result = [];
  while (!buffer.isEmpty()) {
    var possibleEnd = this._peekTag(buffer, 'end');
    if (buffer.isError(possibleEnd))
      return possibleEnd;

    var res = decoder.decode(buffer, 'der', options);
    if (buffer.isError(res) && possibleEnd)
      break;
    result.push(res);
  }
  return result;
};

DERNode.prototype._decodeStr = function decodeStr(buffer, tag) {
  if (tag === 'bitstr') {
    var unused = buffer.readUInt8();
    if (buffer.isError(unused))
      return unused;
    return { unused: unused, data: buffer.raw() };
  } else if (tag === 'bmpstr') {
    var raw = buffer.raw();
    if (raw.length % 2 === 1)
      return buffer.error('Decoding of string type: bmpstr length mismatch');

    var str = '';
    for (var i = 0; i < raw.length / 2; i++) {
      str += String.fromCharCode(raw.readUInt16BE(i * 2));
    }
    return str;
  } else if (tag === 'numstr') {
    var numstr = buffer.raw().toString('ascii');
    if (!this._isNumstr(numstr)) {
      return buffer.error('Decoding of string type: ' +
                          'numstr unsupported characters');
    }
    return numstr;
  } else if (tag === 'octstr') {
    return buffer.raw();
  } else if (tag === 'objDesc') {
    return buffer.raw();
  } else if (tag === 'printstr') {
    var printstr = buffer.raw().toString('ascii');
    if (!this._isPrintstr(printstr)) {
      return buffer.error('Decoding of string type: ' +
                          'printstr unsupported characters');
    }
    return printstr;
  } else if (/str$/.test(tag)) {
    return buffer.raw().toString();
  } else {
    return buffer.error('Decoding of string type: ' + tag + ' unsupported');
  }
};

DERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {
  var result;
  var identifiers = [];
  var ident = 0;
  while (!buffer.isEmpty()) {
    var subident = buffer.readUInt8();
    ident <<= 7;
    ident |= subident & 0x7f;
    if ((subident & 0x80) === 0) {
      identifiers.push(ident);
      ident = 0;
    }
  }
  if (subident & 0x80)
    identifiers.push(ident);

  var first = (identifiers[0] / 40) | 0;
  var second = identifiers[0] % 40;

  if (relative)
    result = identifiers;
  else
    result = [first, second].concat(identifiers.slice(1));

  if (values) {
    var tmp = values[result.join(' ')];
    if (tmp === undefined)
      tmp = values[result.join('.')];
    if (tmp !== undefined)
      result = tmp;
  }

  return result;
};

DERNode.prototype._decodeTime = function decodeTime(buffer, tag) {
  var str = buffer.raw().toString();
  if (tag === 'gentime') {
    var year = str.slice(0, 4) | 0;
    var mon = str.slice(4, 6) | 0;
    var day = str.slice(6, 8) | 0;
    var hour = str.slice(8, 10) | 0;
    var min = str.slice(10, 12) | 0;
    var sec = str.slice(12, 14) | 0;
  } else if (tag === 'utctime') {
    var year = str.slice(0, 2) | 0;
    var mon = str.slice(2, 4) | 0;
    var day = str.slice(4, 6) | 0;
    var hour = str.slice(6, 8) | 0;
    var min = str.slice(8, 10) | 0;
    var sec = str.slice(10, 12) | 0;
    if (year < 70)
      year = 2000 + year;
    else
      year = 1900 + year;
  } else {
    return buffer.error('Decoding ' + tag + ' time is not supported yet');
  }

  return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
};

DERNode.prototype._decodeNull = function decodeNull(buffer) {
  return null;
};

DERNode.prototype._decodeBool = function decodeBool(buffer) {
  var res = buffer.readUInt8();
  if (buffer.isError(res))
    return res;
  else
    return res !== 0;
};

DERNode.prototype._decodeInt = function decodeInt(buffer, values) {
  // Bigint, return as it is (assume big endian)
  var raw = buffer.raw();
  var res = new bignum(raw);

  if (values)
    res = values[res.toString(10)] || res;

  return res;
};

DERNode.prototype._use = function use(entity, obj) {
  if (typeof entity === 'function')
    entity = entity(obj);
  return entity._getDecoder('der').tree;
};

// Utility methods

function derDecodeTag(buf, fail) {
  var tag = buf.readUInt8(fail);
  if (buf.isError(tag))
    return tag;

  var cls = der.tagClass[tag >> 6];
  var primitive = (tag & 0x20) === 0;

  // Multi-octet tag - load
  if ((tag & 0x1f) === 0x1f) {
    var oct = tag;
    tag = 0;
    while ((oct & 0x80) === 0x80) {
      oct = buf.readUInt8(fail);
      if (buf.isError(oct))
        return oct;

      tag <<= 7;
      tag |= oct & 0x7f;
    }
  } else {
    tag &= 0x1f;
  }
  var tagStr = der.tag[tag];

  return {
    cls: cls,
    primitive: primitive,
    tag: tag,
    tagStr: tagStr
  };
}

function derDecodeLen(buf, primitive, fail) {
  var len = buf.readUInt8(fail);
  if (buf.isError(len))
    return len;

  // Indefinite form
  if (!primitive && len === 0x80)
    return null;

  // Definite form
  if ((len & 0x80) === 0) {
    // Short form
    return len;
  }

  // Long form
  var num = len & 0x7f;
  if (num > 4)
    return buf.error('length octect is too long');

  len = 0;
  for (var i = 0; i < num; i++) {
    len <<= 8;
    var j = buf.readUInt8(fail);
    if (buf.isError(j))
      return j;
    len |= j;
  }

  return len;
}


/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/decoders/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/decoders/index.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var decoders = exports;

decoders.der = __webpack_require__(/*! ./der */ "./node_modules/asn1.js/lib/asn1/decoders/der.js");
decoders.pem = __webpack_require__(/*! ./pem */ "./node_modules/asn1.js/lib/asn1/decoders/pem.js");


/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/decoders/pem.js":
/*!*******************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/decoders/pem.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js").Buffer;

var DERDecoder = __webpack_require__(/*! ./der */ "./node_modules/asn1.js/lib/asn1/decoders/der.js");

function PEMDecoder(entity) {
  DERDecoder.call(this, entity);
  this.enc = 'pem';
};
inherits(PEMDecoder, DERDecoder);
module.exports = PEMDecoder;

PEMDecoder.prototype.decode = function decode(data, options) {
  var lines = data.toString().split(/[\r\n]+/g);

  var label = options.label.toUpperCase();

  var re = /^-----(BEGIN|END) ([^-]+)-----$/;
  var start = -1;
  var end = -1;
  for (var i = 0; i < lines.length; i++) {
    var match = lines[i].match(re);
    if (match === null)
      continue;

    if (match[2] !== label)
      continue;

    if (start === -1) {
      if (match[1] !== 'BEGIN')
        break;
      start = i;
    } else {
      if (match[1] !== 'END')
        break;
      end = i;
      break;
    }
  }
  if (start === -1 || end === -1)
    throw new Error('PEM section not found for: ' + label);

  var base64 = lines.slice(start + 1, end).join('');
  // Remove excessive symbols
  base64.replace(/[^a-z0-9\+\/=]+/gi, '');

  var input = new Buffer(base64, 'base64');
  return DERDecoder.prototype.decode.call(this, input, options);
};


/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/encoders/der.js":
/*!*******************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/encoders/der.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js").Buffer;

var asn1 = __webpack_require__(/*! ../../asn1 */ "./node_modules/asn1.js/lib/asn1.js");
var base = asn1.base;

// Import DER constants
var der = asn1.constants.der;

function DEREncoder(entity) {
  this.enc = 'der';
  this.name = entity.name;
  this.entity = entity;

  // Construct base tree
  this.tree = new DERNode();
  this.tree._init(entity.body);
};
module.exports = DEREncoder;

DEREncoder.prototype.encode = function encode(data, reporter) {
  return this.tree._encode(data, reporter).join();
};

// Tree methods

function DERNode(parent) {
  base.Node.call(this, 'der', parent);
}
inherits(DERNode, base.Node);

DERNode.prototype._encodeComposite = function encodeComposite(tag,
                                                              primitive,
                                                              cls,
                                                              content) {
  var encodedTag = encodeTag(tag, primitive, cls, this.reporter);

  // Short form
  if (content.length < 0x80) {
    var header = new Buffer(2);
    header[0] = encodedTag;
    header[1] = content.length;
    return this._createEncoderBuffer([ header, content ]);
  }

  // Long form
  // Count octets required to store length
  var lenOctets = 1;
  for (var i = content.length; i >= 0x100; i >>= 8)
    lenOctets++;

  var header = new Buffer(1 + 1 + lenOctets);
  header[0] = encodedTag;
  header[1] = 0x80 | lenOctets;

  for (var i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8)
    header[i] = j & 0xff;

  return this._createEncoderBuffer([ header, content ]);
};

DERNode.prototype._encodeStr = function encodeStr(str, tag) {
  if (tag === 'bitstr') {
    return this._createEncoderBuffer([ str.unused | 0, str.data ]);
  } else if (tag === 'bmpstr') {
    var buf = new Buffer(str.length * 2);
    for (var i = 0; i < str.length; i++) {
      buf.writeUInt16BE(str.charCodeAt(i), i * 2);
    }
    return this._createEncoderBuffer(buf);
  } else if (tag === 'numstr') {
    if (!this._isNumstr(str)) {
      return this.reporter.error('Encoding of string type: numstr supports ' +
                                 'only digits and space');
    }
    return this._createEncoderBuffer(str);
  } else if (tag === 'printstr') {
    if (!this._isPrintstr(str)) {
      return this.reporter.error('Encoding of string type: printstr supports ' +
                                 'only latin upper and lower case letters, ' +
                                 'digits, space, apostrophe, left and rigth ' +
                                 'parenthesis, plus sign, comma, hyphen, ' +
                                 'dot, slash, colon, equal sign, ' +
                                 'question mark');
    }
    return this._createEncoderBuffer(str);
  } else if (/str$/.test(tag)) {
    return this._createEncoderBuffer(str);
  } else if (tag === 'objDesc') {
    return this._createEncoderBuffer(str);
  } else {
    return this.reporter.error('Encoding of string type: ' + tag +
                               ' unsupported');
  }
};

DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {
  if (typeof id === 'string') {
    if (!values)
      return this.reporter.error('string objid given, but no values map found');
    if (!values.hasOwnProperty(id))
      return this.reporter.error('objid not found in values map');
    id = values[id].split(/[\s\.]+/g);
    for (var i = 0; i < id.length; i++)
      id[i] |= 0;
  } else if (Array.isArray(id)) {
    id = id.slice();
    for (var i = 0; i < id.length; i++)
      id[i] |= 0;
  }

  if (!Array.isArray(id)) {
    return this.reporter.error('objid() should be either array or string, ' +
                               'got: ' + JSON.stringify(id));
  }

  if (!relative) {
    if (id[1] >= 40)
      return this.reporter.error('Second objid identifier OOB');
    id.splice(0, 2, id[0] * 40 + id[1]);
  }

  // Count number of octets
  var size = 0;
  for (var i = 0; i < id.length; i++) {
    var ident = id[i];
    for (size++; ident >= 0x80; ident >>= 7)
      size++;
  }

  var objid = new Buffer(size);
  var offset = objid.length - 1;
  for (var i = id.length - 1; i >= 0; i--) {
    var ident = id[i];
    objid[offset--] = ident & 0x7f;
    while ((ident >>= 7) > 0)
      objid[offset--] = 0x80 | (ident & 0x7f);
  }

  return this._createEncoderBuffer(objid);
};

function two(num) {
  if (num < 10)
    return '0' + num;
  else
    return num;
}

DERNode.prototype._encodeTime = function encodeTime(time, tag) {
  var str;
  var date = new Date(time);

  if (tag === 'gentime') {
    str = [
      two(date.getFullYear()),
      two(date.getUTCMonth() + 1),
      two(date.getUTCDate()),
      two(date.getUTCHours()),
      two(date.getUTCMinutes()),
      two(date.getUTCSeconds()),
      'Z'
    ].join('');
  } else if (tag === 'utctime') {
    str = [
      two(date.getFullYear() % 100),
      two(date.getUTCMonth() + 1),
      two(date.getUTCDate()),
      two(date.getUTCHours()),
      two(date.getUTCMinutes()),
      two(date.getUTCSeconds()),
      'Z'
    ].join('');
  } else {
    this.reporter.error('Encoding ' + tag + ' time is not supported yet');
  }

  return this._encodeStr(str, 'octstr');
};

DERNode.prototype._encodeNull = function encodeNull() {
  return this._createEncoderBuffer('');
};

DERNode.prototype._encodeInt = function encodeInt(num, values) {
  if (typeof num === 'string') {
    if (!values)
      return this.reporter.error('String int or enum given, but no values map');
    if (!values.hasOwnProperty(num)) {
      return this.reporter.error('Values map doesn\'t contain: ' +
                                 JSON.stringify(num));
    }
    num = values[num];
  }

  // Bignum, assume big endian
  if (typeof num !== 'number' && !Buffer.isBuffer(num)) {
    var numArray = num.toArray();
    if (!num.sign && numArray[0] & 0x80) {
      numArray.unshift(0);
    }
    num = new Buffer(numArray);
  }

  if (Buffer.isBuffer(num)) {
    var size = num.length;
    if (num.length === 0)
      size++;

    var out = new Buffer(size);
    num.copy(out);
    if (num.length === 0)
      out[0] = 0
    return this._createEncoderBuffer(out);
  }

  if (num < 0x80)
    return this._createEncoderBuffer(num);

  if (num < 0x100)
    return this._createEncoderBuffer([0, num]);

  var size = 1;
  for (var i = num; i >= 0x100; i >>= 8)
    size++;

  var out = new Array(size);
  for (var i = out.length - 1; i >= 0; i--) {
    out[i] = num & 0xff;
    num >>= 8;
  }
  if(out[0] & 0x80) {
    out.unshift(0);
  }

  return this._createEncoderBuffer(new Buffer(out));
};

DERNode.prototype._encodeBool = function encodeBool(value) {
  return this._createEncoderBuffer(value ? 0xff : 0);
};

DERNode.prototype._use = function use(entity, obj) {
  if (typeof entity === 'function')
    entity = entity(obj);
  return entity._getEncoder('der').tree;
};

DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
  var state = this._baseState;
  var i;
  if (state['default'] === null)
    return false;

  var data = dataBuffer.join();
  if (state.defaultBuffer === undefined)
    state.defaultBuffer = this._encodeValue(state['default'], reporter, parent).join();

  if (data.length !== state.defaultBuffer.length)
    return false;

  for (i=0; i < data.length; i++)
    if (data[i] !== state.defaultBuffer[i])
      return false;

  return true;
};

// Utility methods

function encodeTag(tag, primitive, cls, reporter) {
  var res;

  if (tag === 'seqof')
    tag = 'seq';
  else if (tag === 'setof')
    tag = 'set';

  if (der.tagByName.hasOwnProperty(tag))
    res = der.tagByName[tag];
  else if (typeof tag === 'number' && (tag | 0) === tag)
    res = tag;
  else
    return reporter.error('Unknown tag: ' + tag);

  if (res >= 0x1f)
    return reporter.error('Multi-octet tag encoding unsupported');

  if (!primitive)
    res |= 0x20;

  res |= (der.tagClassByName[cls || 'universal'] << 6);

  return res;
}


/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/encoders/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/encoders/index.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var encoders = exports;

encoders.der = __webpack_require__(/*! ./der */ "./node_modules/asn1.js/lib/asn1/encoders/der.js");
encoders.pem = __webpack_require__(/*! ./pem */ "./node_modules/asn1.js/lib/asn1/encoders/pem.js");


/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/encoders/pem.js":
/*!*******************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/encoders/pem.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

var DEREncoder = __webpack_require__(/*! ./der */ "./node_modules/asn1.js/lib/asn1/encoders/der.js");

function PEMEncoder(entity) {
  DEREncoder.call(this, entity);
  this.enc = 'pem';
};
inherits(PEMEncoder, DEREncoder);
module.exports = PEMEncoder;

PEMEncoder.prototype.encode = function encode(data, options) {
  var buf = DEREncoder.prototype.encode.call(this, data);

  var p = buf.toString('base64');
  var out = [ '-----BEGIN ' + options.label + '-----' ];
  for (var i = 0; i < p.length; i += 64)
    out.push(p.slice(i, i + 64));
  out.push('-----END ' + options.label + '-----');
  return out.join('\n');
};


/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "./node_modules/bn.js/lib/bn.js":
/*!**************************************!*\
  !*** ./node_modules/bn.js/lib/bn.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    Buffer = __webpack_require__(/*! buffer */ 2).Buffer;
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
    }

    if (base === 16) {
      this._parseHex(number, start);
    } else {
      this._parseBase(number, base, start);
    }

    if (number[0] === '-') {
      this.negative = 1;
    }

    this.strip();

    if (endian !== 'le') return;

    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [ number & 0x3ffffff ];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [ 0 ];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this.strip();
  };

  function parseHex (str, start, end) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r <<= 4;

      // 'a' - 'f'
      if (c >= 49 && c <= 54) {
        r |= c - 49 + 0xa;

      // 'A' - 'F'
      } else if (c >= 17 && c <= 22) {
        r |= c - 17 + 0xa;

      // '0' - '9'
      } else {
        r |= c & 0xf;
      }
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    // Scan 24-bit chunks and add them to the number
    var off = 0;
    for (i = number.length - 6, j = 0; i >= start; i -= 6) {
      w = parseHex(number, i, i + 6);
      this.words[j] |= (w << off) & 0x3ffffff;
      // NOTE: `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb
      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
      off += 24;
      if (off >= 26) {
        off -= 26;
        j++;
      }
    }
    if (i + 6 !== start) {
      w = parseHex(number, start, i + 6);
      this.words[j] |= (w << off) & 0x3ffffff;
      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
    }
    this.strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        r += c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        r += c - 17 + 0xa;

      // '0' - '9'
      } else {
        r += c;
      }
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [ 0 ];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype.strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  BN.prototype.inspect = function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  };

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16);
  };

  BN.prototype.toBuffer = function toBuffer (endian, length) {
    assert(typeof Buffer !== 'undefined');
    return this.toArrayLike(Buffer, endian, length);
  };

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    this.strip();
    var littleEndian = endian === 'le';
    var res = new ArrayType(reqLength);

    var b, i;
    var q = this.clone();
    if (!littleEndian) {
      // Assume big-endian
      for (i = 0; i < reqLength - byteLength; i++) {
        res[i] = 0;
      }

      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[reqLength - i - 1] = b;
      }
    } else {
      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[i] = b;
      }

      for (; i < reqLength; i++) {
        res[i] = 0;
      }
    }

    return res;
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this.strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this.strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this.strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this.strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this.strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this.strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out.strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out.strip();
  }

  function jumboMulTo (self, num, out) {
    var fftm = new FFTM();
    return fftm.mulp(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out.strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this.strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this.strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this.strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) < num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this.strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this.strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this.strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q.strip();
    }
    a.strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modn = function modn (num) {
    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return acc;
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    return this.strip();
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this.strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      r.strip();
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    return a.umod(this.m)._forceRed(this);
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})( false || module, this);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/brorand/index.js":
/*!***************************************!*\
  !*** ./node_modules/brorand/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var r;

module.exports = function rand(len) {
  if (!r)
    r = new Rand(null);

  return r.generate(len);
};

function Rand(rand) {
  this.rand = rand;
}
module.exports.Rand = Rand;

Rand.prototype.generate = function generate(len) {
  return this._rand(len);
};

// Emulate crypto API using randy
Rand.prototype._rand = function _rand(n) {
  if (this.rand.getBytes)
    return this.rand.getBytes(n);

  var res = new Uint8Array(n);
  for (var i = 0; i < res.length; i++)
    res[i] = this.rand.getByte();
  return res;
};

if (typeof self === 'object') {
  if (self.crypto && self.crypto.getRandomValues) {
    // Modern browsers
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.crypto.getRandomValues(arr);
      return arr;
    };
  } else if (self.msCrypto && self.msCrypto.getRandomValues) {
    // IE
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.msCrypto.getRandomValues(arr);
      return arr;
    };

  // Safari's WebWorkers do not have `crypto`
  } else if (typeof window === 'object') {
    // Old junk
    Rand.prototype._rand = function() {
      throw new Error('Not implemented yet');
    };
  }
} else {
  // Node.js or Web worker with no crypto support
  try {
    var crypto = __webpack_require__(/*! crypto */ 3);
    if (typeof crypto.randomBytes !== 'function')
      throw new Error('Not supported');

    Rand.prototype._rand = function _rand(n) {
      return crypto.randomBytes(n);
    };
  } catch (e) {
  }
}


/***/ }),

/***/ "./node_modules/browserify-aes/aes.js":
/*!********************************************!*\
  !*** ./node_modules/browserify-aes/aes.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// based on the aes implimentation in triple sec
// https://github.com/keybase/triplesec
// which is in turn based on the one from crypto-js
// https://code.google.com/p/crypto-js/

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

function asUInt32Array (buf) {
  if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)

  var len = (buf.length / 4) | 0
  var out = new Array(len)

  for (var i = 0; i < len; i++) {
    out[i] = buf.readUInt32BE(i * 4)
  }

  return out
}

function scrubVec (v) {
  for (var i = 0; i < v.length; v++) {
    v[i] = 0
  }
}

function cryptBlock (M, keySchedule, SUB_MIX, SBOX, nRounds) {
  var SUB_MIX0 = SUB_MIX[0]
  var SUB_MIX1 = SUB_MIX[1]
  var SUB_MIX2 = SUB_MIX[2]
  var SUB_MIX3 = SUB_MIX[3]

  var s0 = M[0] ^ keySchedule[0]
  var s1 = M[1] ^ keySchedule[1]
  var s2 = M[2] ^ keySchedule[2]
  var s3 = M[3] ^ keySchedule[3]
  var t0, t1, t2, t3
  var ksRow = 4

  for (var round = 1; round < nRounds; round++) {
    t0 = SUB_MIX0[s0 >>> 24] ^ SUB_MIX1[(s1 >>> 16) & 0xff] ^ SUB_MIX2[(s2 >>> 8) & 0xff] ^ SUB_MIX3[s3 & 0xff] ^ keySchedule[ksRow++]
    t1 = SUB_MIX0[s1 >>> 24] ^ SUB_MIX1[(s2 >>> 16) & 0xff] ^ SUB_MIX2[(s3 >>> 8) & 0xff] ^ SUB_MIX3[s0 & 0xff] ^ keySchedule[ksRow++]
    t2 = SUB_MIX0[s2 >>> 24] ^ SUB_MIX1[(s3 >>> 16) & 0xff] ^ SUB_MIX2[(s0 >>> 8) & 0xff] ^ SUB_MIX3[s1 & 0xff] ^ keySchedule[ksRow++]
    t3 = SUB_MIX0[s3 >>> 24] ^ SUB_MIX1[(s0 >>> 16) & 0xff] ^ SUB_MIX2[(s1 >>> 8) & 0xff] ^ SUB_MIX3[s2 & 0xff] ^ keySchedule[ksRow++]
    s0 = t0
    s1 = t1
    s2 = t2
    s3 = t3
  }

  t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++]
  t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++]
  t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++]
  t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++]
  t0 = t0 >>> 0
  t1 = t1 >>> 0
  t2 = t2 >>> 0
  t3 = t3 >>> 0

  return [t0, t1, t2, t3]
}

// AES constants
var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36]
var G = (function () {
  // Compute double table
  var d = new Array(256)
  for (var j = 0; j < 256; j++) {
    if (j < 128) {
      d[j] = j << 1
    } else {
      d[j] = (j << 1) ^ 0x11b
    }
  }

  var SBOX = []
  var INV_SBOX = []
  var SUB_MIX = [[], [], [], []]
  var INV_SUB_MIX = [[], [], [], []]

  // Walk GF(2^8)
  var x = 0
  var xi = 0
  for (var i = 0; i < 256; ++i) {
    // Compute sbox
    var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4)
    sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63
    SBOX[x] = sx
    INV_SBOX[sx] = x

    // Compute multiplication
    var x2 = d[x]
    var x4 = d[x2]
    var x8 = d[x4]

    // Compute sub bytes, mix columns tables
    var t = (d[sx] * 0x101) ^ (sx * 0x1010100)
    SUB_MIX[0][x] = (t << 24) | (t >>> 8)
    SUB_MIX[1][x] = (t << 16) | (t >>> 16)
    SUB_MIX[2][x] = (t << 8) | (t >>> 24)
    SUB_MIX[3][x] = t

    // Compute inv sub bytes, inv mix columns tables
    t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100)
    INV_SUB_MIX[0][sx] = (t << 24) | (t >>> 8)
    INV_SUB_MIX[1][sx] = (t << 16) | (t >>> 16)
    INV_SUB_MIX[2][sx] = (t << 8) | (t >>> 24)
    INV_SUB_MIX[3][sx] = t

    if (x === 0) {
      x = xi = 1
    } else {
      x = x2 ^ d[d[d[x8 ^ x2]]]
      xi ^= d[d[xi]]
    }
  }

  return {
    SBOX: SBOX,
    INV_SBOX: INV_SBOX,
    SUB_MIX: SUB_MIX,
    INV_SUB_MIX: INV_SUB_MIX
  }
})()

function AES (key) {
  this._key = asUInt32Array(key)
  this._reset()
}

AES.blockSize = 4 * 4
AES.keySize = 256 / 8
AES.prototype.blockSize = AES.blockSize
AES.prototype.keySize = AES.keySize
AES.prototype._reset = function () {
  var keyWords = this._key
  var keySize = keyWords.length
  var nRounds = keySize + 6
  var ksRows = (nRounds + 1) * 4

  var keySchedule = []
  for (var k = 0; k < keySize; k++) {
    keySchedule[k] = keyWords[k]
  }

  for (k = keySize; k < ksRows; k++) {
    var t = keySchedule[k - 1]

    if (k % keySize === 0) {
      t = (t << 8) | (t >>> 24)
      t =
        (G.SBOX[t >>> 24] << 24) |
        (G.SBOX[(t >>> 16) & 0xff] << 16) |
        (G.SBOX[(t >>> 8) & 0xff] << 8) |
        (G.SBOX[t & 0xff])

      t ^= RCON[(k / keySize) | 0] << 24
    } else if (keySize > 6 && k % keySize === 4) {
      t =
        (G.SBOX[t >>> 24] << 24) |
        (G.SBOX[(t >>> 16) & 0xff] << 16) |
        (G.SBOX[(t >>> 8) & 0xff] << 8) |
        (G.SBOX[t & 0xff])
    }

    keySchedule[k] = keySchedule[k - keySize] ^ t
  }

  var invKeySchedule = []
  for (var ik = 0; ik < ksRows; ik++) {
    var ksR = ksRows - ik
    var tt = keySchedule[ksR - (ik % 4 ? 0 : 4)]

    if (ik < 4 || ksR <= 4) {
      invKeySchedule[ik] = tt
    } else {
      invKeySchedule[ik] =
        G.INV_SUB_MIX[0][G.SBOX[tt >>> 24]] ^
        G.INV_SUB_MIX[1][G.SBOX[(tt >>> 16) & 0xff]] ^
        G.INV_SUB_MIX[2][G.SBOX[(tt >>> 8) & 0xff]] ^
        G.INV_SUB_MIX[3][G.SBOX[tt & 0xff]]
    }
  }

  this._nRounds = nRounds
  this._keySchedule = keySchedule
  this._invKeySchedule = invKeySchedule
}

AES.prototype.encryptBlockRaw = function (M) {
  M = asUInt32Array(M)
  return cryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds)
}

AES.prototype.encryptBlock = function (M) {
  var out = this.encryptBlockRaw(M)
  var buf = Buffer.allocUnsafe(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[1], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[3], 12)
  return buf
}

AES.prototype.decryptBlock = function (M) {
  M = asUInt32Array(M)

  // swap
  var m1 = M[1]
  M[1] = M[3]
  M[3] = m1

  var out = cryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds)
  var buf = Buffer.allocUnsafe(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[3], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[1], 12)
  return buf
}

AES.prototype.scrub = function () {
  scrubVec(this._keySchedule)
  scrubVec(this._invKeySchedule)
  scrubVec(this._key)
}

module.exports.AES = AES


/***/ }),

/***/ "./node_modules/browserify-aes/authCipher.js":
/*!***************************************************!*\
  !*** ./node_modules/browserify-aes/authCipher.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var aes = __webpack_require__(/*! ./aes */ "./node_modules/browserify-aes/aes.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
var Transform = __webpack_require__(/*! cipher-base */ "./node_modules/cipher-base/index.js")
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var GHASH = __webpack_require__(/*! ./ghash */ "./node_modules/browserify-aes/ghash.js")
var xor = __webpack_require__(/*! buffer-xor */ "./node_modules/buffer-xor/index.js")
var incr32 = __webpack_require__(/*! ./incr32 */ "./node_modules/browserify-aes/incr32.js")

function xorTest (a, b) {
  var out = 0
  if (a.length !== b.length) out++

  var len = Math.min(a.length, b.length)
  for (var i = 0; i < len; ++i) {
    out += (a[i] ^ b[i])
  }

  return out
}

function calcIv (self, iv, ck) {
  if (iv.length === 12) {
    self._finID = Buffer.concat([iv, Buffer.from([0, 0, 0, 1])])
    return Buffer.concat([iv, Buffer.from([0, 0, 0, 2])])
  }
  var ghash = new GHASH(ck)
  var len = iv.length
  var toPad = len % 16
  ghash.update(iv)
  if (toPad) {
    toPad = 16 - toPad
    ghash.update(Buffer.alloc(toPad, 0))
  }
  ghash.update(Buffer.alloc(8, 0))
  var ivBits = len * 8
  var tail = Buffer.alloc(8)
  tail.writeUIntBE(ivBits, 0, 8)
  ghash.update(tail)
  self._finID = ghash.state
  var out = Buffer.from(self._finID)
  incr32(out)
  return out
}
function StreamCipher (mode, key, iv, decrypt) {
  Transform.call(this)

  var h = Buffer.alloc(4, 0)

  this._cipher = new aes.AES(key)
  var ck = this._cipher.encryptBlock(h)
  this._ghash = new GHASH(ck)
  iv = calcIv(this, iv, ck)

  this._prev = Buffer.from(iv)
  this._cache = Buffer.allocUnsafe(0)
  this._secCache = Buffer.allocUnsafe(0)
  this._decrypt = decrypt
  this._alen = 0
  this._len = 0
  this._mode = mode

  this._authTag = null
  this._called = false
}

inherits(StreamCipher, Transform)

StreamCipher.prototype._update = function (chunk) {
  if (!this._called && this._alen) {
    var rump = 16 - (this._alen % 16)
    if (rump < 16) {
      rump = Buffer.alloc(rump, 0)
      this._ghash.update(rump)
    }
  }

  this._called = true
  var out = this._mode.encrypt(this, chunk)
  if (this._decrypt) {
    this._ghash.update(chunk)
  } else {
    this._ghash.update(out)
  }
  this._len += chunk.length
  return out
}

StreamCipher.prototype._final = function () {
  if (this._decrypt && !this._authTag) throw new Error('Unsupported state or unable to authenticate data')

  var tag = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID))
  if (this._decrypt && xorTest(tag, this._authTag)) throw new Error('Unsupported state or unable to authenticate data')

  this._authTag = tag
  this._cipher.scrub()
}

StreamCipher.prototype.getAuthTag = function getAuthTag () {
  if (this._decrypt || !Buffer.isBuffer(this._authTag)) throw new Error('Attempting to get auth tag in unsupported state')

  return this._authTag
}

StreamCipher.prototype.setAuthTag = function setAuthTag (tag) {
  if (!this._decrypt) throw new Error('Attempting to set auth tag in unsupported state')

  this._authTag = tag
}

StreamCipher.prototype.setAAD = function setAAD (buf) {
  if (this._called) throw new Error('Attempting to set AAD in unsupported state')

  this._ghash.update(buf)
  this._alen += buf.length
}

module.exports = StreamCipher


/***/ }),

/***/ "./node_modules/browserify-aes/browser.js":
/*!************************************************!*\
  !*** ./node_modules/browserify-aes/browser.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ciphers = __webpack_require__(/*! ./encrypter */ "./node_modules/browserify-aes/encrypter.js")
var deciphers = __webpack_require__(/*! ./decrypter */ "./node_modules/browserify-aes/decrypter.js")
var modes = __webpack_require__(/*! ./modes/list.json */ "./node_modules/browserify-aes/modes/list.json")

function getCiphers () {
  return Object.keys(modes)
}

exports.createCipher = exports.Cipher = ciphers.createCipher
exports.createCipheriv = exports.Cipheriv = ciphers.createCipheriv
exports.createDecipher = exports.Decipher = deciphers.createDecipher
exports.createDecipheriv = exports.Decipheriv = deciphers.createDecipheriv
exports.listCiphers = exports.getCiphers = getCiphers


/***/ }),

/***/ "./node_modules/browserify-aes/decrypter.js":
/*!**************************************************!*\
  !*** ./node_modules/browserify-aes/decrypter.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var AuthCipher = __webpack_require__(/*! ./authCipher */ "./node_modules/browserify-aes/authCipher.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
var MODES = __webpack_require__(/*! ./modes */ "./node_modules/browserify-aes/modes/index.js")
var StreamCipher = __webpack_require__(/*! ./streamCipher */ "./node_modules/browserify-aes/streamCipher.js")
var Transform = __webpack_require__(/*! cipher-base */ "./node_modules/cipher-base/index.js")
var aes = __webpack_require__(/*! ./aes */ "./node_modules/browserify-aes/aes.js")
var ebtk = __webpack_require__(/*! evp_bytestokey */ "./node_modules/evp_bytestokey/index.js")
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")

function Decipher (mode, key, iv) {
  Transform.call(this)

  this._cache = new Splitter()
  this._last = void 0
  this._cipher = new aes.AES(key)
  this._prev = Buffer.from(iv)
  this._mode = mode
  this._autopadding = true
}

inherits(Decipher, Transform)

Decipher.prototype._update = function (data) {
  this._cache.add(data)
  var chunk
  var thing
  var out = []
  while ((chunk = this._cache.get(this._autopadding))) {
    thing = this._mode.decrypt(this, chunk)
    out.push(thing)
  }
  return Buffer.concat(out)
}

Decipher.prototype._final = function () {
  var chunk = this._cache.flush()
  if (this._autopadding) {
    return unpad(this._mode.decrypt(this, chunk))
  } else if (chunk) {
    throw new Error('data not multiple of block length')
  }
}

Decipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo
  return this
}

function Splitter () {
  this.cache = Buffer.allocUnsafe(0)
}

Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data])
}

Splitter.prototype.get = function (autoPadding) {
  var out
  if (autoPadding) {
    if (this.cache.length > 16) {
      out = this.cache.slice(0, 16)
      this.cache = this.cache.slice(16)
      return out
    }
  } else {
    if (this.cache.length >= 16) {
      out = this.cache.slice(0, 16)
      this.cache = this.cache.slice(16)
      return out
    }
  }

  return null
}

Splitter.prototype.flush = function () {
  if (this.cache.length) return this.cache
}

function unpad (last) {
  var padded = last[15]
  if (padded < 1 || padded > 16) {
    throw new Error('unable to decrypt data')
  }
  var i = -1
  while (++i < padded) {
    if (last[(i + (16 - padded))] !== padded) {
      throw new Error('unable to decrypt data')
    }
  }
  if (padded === 16) return

  return last.slice(0, 16 - padded)
}

function createDecipheriv (suite, password, iv) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  if (typeof iv === 'string') iv = Buffer.from(iv)
  if (config.mode !== 'GCM' && iv.length !== config.iv) throw new TypeError('invalid iv length ' + iv.length)

  if (typeof password === 'string') password = Buffer.from(password)
  if (password.length !== config.key / 8) throw new TypeError('invalid key length ' + password.length)

  if (config.type === 'stream') {
    return new StreamCipher(config.module, password, iv, true)
  } else if (config.type === 'auth') {
    return new AuthCipher(config.module, password, iv, true)
  }

  return new Decipher(config.module, password, iv)
}

function createDecipher (suite, password) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  var keys = ebtk(password, false, config.key, config.iv)
  return createDecipheriv(suite, keys.key, keys.iv)
}

exports.createDecipher = createDecipher
exports.createDecipheriv = createDecipheriv


/***/ }),

/***/ "./node_modules/browserify-aes/encrypter.js":
/*!**************************************************!*\
  !*** ./node_modules/browserify-aes/encrypter.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var MODES = __webpack_require__(/*! ./modes */ "./node_modules/browserify-aes/modes/index.js")
var AuthCipher = __webpack_require__(/*! ./authCipher */ "./node_modules/browserify-aes/authCipher.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
var StreamCipher = __webpack_require__(/*! ./streamCipher */ "./node_modules/browserify-aes/streamCipher.js")
var Transform = __webpack_require__(/*! cipher-base */ "./node_modules/cipher-base/index.js")
var aes = __webpack_require__(/*! ./aes */ "./node_modules/browserify-aes/aes.js")
var ebtk = __webpack_require__(/*! evp_bytestokey */ "./node_modules/evp_bytestokey/index.js")
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")

function Cipher (mode, key, iv) {
  Transform.call(this)

  this._cache = new Splitter()
  this._cipher = new aes.AES(key)
  this._prev = Buffer.from(iv)
  this._mode = mode
  this._autopadding = true
}

inherits(Cipher, Transform)

Cipher.prototype._update = function (data) {
  this._cache.add(data)
  var chunk
  var thing
  var out = []

  while ((chunk = this._cache.get())) {
    thing = this._mode.encrypt(this, chunk)
    out.push(thing)
  }

  return Buffer.concat(out)
}

var PADDING = Buffer.alloc(16, 0x10)

Cipher.prototype._final = function () {
  var chunk = this._cache.flush()
  if (this._autopadding) {
    chunk = this._mode.encrypt(this, chunk)
    this._cipher.scrub()
    return chunk
  }

  if (!chunk.equals(PADDING)) {
    this._cipher.scrub()
    throw new Error('data not multiple of block length')
  }
}

Cipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo
  return this
}

function Splitter () {
  this.cache = Buffer.allocUnsafe(0)
}

Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data])
}

Splitter.prototype.get = function () {
  if (this.cache.length > 15) {
    var out = this.cache.slice(0, 16)
    this.cache = this.cache.slice(16)
    return out
  }
  return null
}

Splitter.prototype.flush = function () {
  var len = 16 - this.cache.length
  var padBuff = Buffer.allocUnsafe(len)

  var i = -1
  while (++i < len) {
    padBuff.writeUInt8(len, i)
  }

  return Buffer.concat([this.cache, padBuff])
}

function createCipheriv (suite, password, iv) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  if (typeof password === 'string') password = Buffer.from(password)
  if (password.length !== config.key / 8) throw new TypeError('invalid key length ' + password.length)

  if (typeof iv === 'string') iv = Buffer.from(iv)
  if (config.mode !== 'GCM' && iv.length !== config.iv) throw new TypeError('invalid iv length ' + iv.length)

  if (config.type === 'stream') {
    return new StreamCipher(config.module, password, iv)
  } else if (config.type === 'auth') {
    return new AuthCipher(config.module, password, iv)
  }

  return new Cipher(config.module, password, iv)
}

function createCipher (suite, password) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  var keys = ebtk(password, false, config.key, config.iv)
  return createCipheriv(suite, keys.key, keys.iv)
}

exports.createCipheriv = createCipheriv
exports.createCipher = createCipher


/***/ }),

/***/ "./node_modules/browserify-aes/ghash.js":
/*!**********************************************!*\
  !*** ./node_modules/browserify-aes/ghash.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
var ZEROES = Buffer.alloc(16, 0)

function toArray (buf) {
  return [
    buf.readUInt32BE(0),
    buf.readUInt32BE(4),
    buf.readUInt32BE(8),
    buf.readUInt32BE(12)
  ]
}

function fromArray (out) {
  var buf = Buffer.allocUnsafe(16)
  buf.writeUInt32BE(out[0] >>> 0, 0)
  buf.writeUInt32BE(out[1] >>> 0, 4)
  buf.writeUInt32BE(out[2] >>> 0, 8)
  buf.writeUInt32BE(out[3] >>> 0, 12)
  return buf
}

function GHASH (key) {
  this.h = key
  this.state = Buffer.alloc(16, 0)
  this.cache = Buffer.allocUnsafe(0)
}

// from http://bitwiseshiftleft.github.io/sjcl/doc/symbols/src/core_gcm.js.html
// by Juho Vh-Herttua
GHASH.prototype.ghash = function (block) {
  var i = -1
  while (++i < block.length) {
    this.state[i] ^= block[i]
  }
  this._multiply()
}

GHASH.prototype._multiply = function () {
  var Vi = toArray(this.h)
  var Zi = [0, 0, 0, 0]
  var j, xi, lsbVi
  var i = -1
  while (++i < 128) {
    xi = (this.state[~~(i / 8)] & (1 << (7 - (i % 8)))) !== 0
    if (xi) {
      // Z_i+1 = Z_i ^ V_i
      Zi[0] ^= Vi[0]
      Zi[1] ^= Vi[1]
      Zi[2] ^= Vi[2]
      Zi[3] ^= Vi[3]
    }

    // Store the value of LSB(V_i)
    lsbVi = (Vi[3] & 1) !== 0

    // V_i+1 = V_i >> 1
    for (j = 3; j > 0; j--) {
      Vi[j] = (Vi[j] >>> 1) | ((Vi[j - 1] & 1) << 31)
    }
    Vi[0] = Vi[0] >>> 1

    // If LSB(V_i) is 1, V_i+1 = (V_i >> 1) ^ R
    if (lsbVi) {
      Vi[0] = Vi[0] ^ (0xe1 << 24)
    }
  }
  this.state = fromArray(Zi)
}

GHASH.prototype.update = function (buf) {
  this.cache = Buffer.concat([this.cache, buf])
  var chunk
  while (this.cache.length >= 16) {
    chunk = this.cache.slice(0, 16)
    this.cache = this.cache.slice(16)
    this.ghash(chunk)
  }
}

GHASH.prototype.final = function (abl, bl) {
  if (this.cache.length) {
    this.ghash(Buffer.concat([this.cache, ZEROES], 16))
  }

  this.ghash(fromArray([0, abl, 0, bl]))
  return this.state
}

module.exports = GHASH


/***/ }),

/***/ "./node_modules/browserify-aes/incr32.js":
/*!***********************************************!*\
  !*** ./node_modules/browserify-aes/incr32.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function incr32 (iv) {
  var len = iv.length
  var item
  while (len--) {
    item = iv.readUInt8(len)
    if (item === 255) {
      iv.writeUInt8(0, len)
    } else {
      item++
      iv.writeUInt8(item, len)
      break
    }
  }
}
module.exports = incr32


/***/ }),

/***/ "./node_modules/browserify-aes/modes/cbc.js":
/*!**************************************************!*\
  !*** ./node_modules/browserify-aes/modes/cbc.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var xor = __webpack_require__(/*! buffer-xor */ "./node_modules/buffer-xor/index.js")

exports.encrypt = function (self, block) {
  var data = xor(block, self._prev)

  self._prev = self._cipher.encryptBlock(data)
  return self._prev
}

exports.decrypt = function (self, block) {
  var pad = self._prev

  self._prev = block
  var out = self._cipher.decryptBlock(block)

  return xor(out, pad)
}


/***/ }),

/***/ "./node_modules/browserify-aes/modes/cfb.js":
/*!**************************************************!*\
  !*** ./node_modules/browserify-aes/modes/cfb.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
var xor = __webpack_require__(/*! buffer-xor */ "./node_modules/buffer-xor/index.js")

function encryptStart (self, data, decrypt) {
  var len = data.length
  var out = xor(data, self._cache)
  self._cache = self._cache.slice(len)
  self._prev = Buffer.concat([self._prev, decrypt ? data : out])
  return out
}

exports.encrypt = function (self, data, decrypt) {
  var out = Buffer.allocUnsafe(0)
  var len

  while (data.length) {
    if (self._cache.length === 0) {
      self._cache = self._cipher.encryptBlock(self._prev)
      self._prev = Buffer.allocUnsafe(0)
    }

    if (self._cache.length <= data.length) {
      len = self._cache.length
      out = Buffer.concat([out, encryptStart(self, data.slice(0, len), decrypt)])
      data = data.slice(len)
    } else {
      out = Buffer.concat([out, encryptStart(self, data, decrypt)])
      break
    }
  }

  return out
}


/***/ }),

/***/ "./node_modules/browserify-aes/modes/cfb1.js":
/*!***************************************************!*\
  !*** ./node_modules/browserify-aes/modes/cfb1.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

function encryptByte (self, byteParam, decrypt) {
  var pad
  var i = -1
  var len = 8
  var out = 0
  var bit, value
  while (++i < len) {
    pad = self._cipher.encryptBlock(self._prev)
    bit = (byteParam & (1 << (7 - i))) ? 0x80 : 0
    value = pad[0] ^ bit
    out += ((value & 0x80) >> (i % 8))
    self._prev = shiftIn(self._prev, decrypt ? bit : value)
  }
  return out
}

function shiftIn (buffer, value) {
  var len = buffer.length
  var i = -1
  var out = Buffer.allocUnsafe(buffer.length)
  buffer = Buffer.concat([buffer, Buffer.from([value])])

  while (++i < len) {
    out[i] = buffer[i] << 1 | buffer[i + 1] >> (7)
  }

  return out
}

exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length
  var out = Buffer.allocUnsafe(len)
  var i = -1

  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt)
  }

  return out
}


/***/ }),

/***/ "./node_modules/browserify-aes/modes/cfb8.js":
/*!***************************************************!*\
  !*** ./node_modules/browserify-aes/modes/cfb8.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

function encryptByte (self, byteParam, decrypt) {
  var pad = self._cipher.encryptBlock(self._prev)
  var out = pad[0] ^ byteParam

  self._prev = Buffer.concat([
    self._prev.slice(1),
    Buffer.from([decrypt ? byteParam : out])
  ])

  return out
}

exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length
  var out = Buffer.allocUnsafe(len)
  var i = -1

  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt)
  }

  return out
}


/***/ }),

/***/ "./node_modules/browserify-aes/modes/ctr.js":
/*!**************************************************!*\
  !*** ./node_modules/browserify-aes/modes/ctr.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var xor = __webpack_require__(/*! buffer-xor */ "./node_modules/buffer-xor/index.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
var incr32 = __webpack_require__(/*! ../incr32 */ "./node_modules/browserify-aes/incr32.js")

function getBlock (self) {
  var out = self._cipher.encryptBlockRaw(self._prev)
  incr32(self._prev)
  return out
}

var blockSize = 16
exports.encrypt = function (self, chunk) {
  var chunkNum = Math.ceil(chunk.length / blockSize)
  var start = self._cache.length
  self._cache = Buffer.concat([
    self._cache,
    Buffer.allocUnsafe(chunkNum * blockSize)
  ])
  for (var i = 0; i < chunkNum; i++) {
    var out = getBlock(self)
    var offset = start + i * blockSize
    self._cache.writeUInt32BE(out[0], offset + 0)
    self._cache.writeUInt32BE(out[1], offset + 4)
    self._cache.writeUInt32BE(out[2], offset + 8)
    self._cache.writeUInt32BE(out[3], offset + 12)
  }
  var pad = self._cache.slice(0, chunk.length)
  self._cache = self._cache.slice(chunk.length)
  return xor(chunk, pad)
}


/***/ }),

/***/ "./node_modules/browserify-aes/modes/ecb.js":
/*!**************************************************!*\
  !*** ./node_modules/browserify-aes/modes/ecb.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.encrypt = function (self, block) {
  return self._cipher.encryptBlock(block)
}

exports.decrypt = function (self, block) {
  return self._cipher.decryptBlock(block)
}


/***/ }),

/***/ "./node_modules/browserify-aes/modes/index.js":
/*!****************************************************!*\
  !*** ./node_modules/browserify-aes/modes/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var modeModules = {
  ECB: __webpack_require__(/*! ./ecb */ "./node_modules/browserify-aes/modes/ecb.js"),
  CBC: __webpack_require__(/*! ./cbc */ "./node_modules/browserify-aes/modes/cbc.js"),
  CFB: __webpack_require__(/*! ./cfb */ "./node_modules/browserify-aes/modes/cfb.js"),
  CFB8: __webpack_require__(/*! ./cfb8 */ "./node_modules/browserify-aes/modes/cfb8.js"),
  CFB1: __webpack_require__(/*! ./cfb1 */ "./node_modules/browserify-aes/modes/cfb1.js"),
  OFB: __webpack_require__(/*! ./ofb */ "./node_modules/browserify-aes/modes/ofb.js"),
  CTR: __webpack_require__(/*! ./ctr */ "./node_modules/browserify-aes/modes/ctr.js"),
  GCM: __webpack_require__(/*! ./ctr */ "./node_modules/browserify-aes/modes/ctr.js")
}

var modes = __webpack_require__(/*! ./list.json */ "./node_modules/browserify-aes/modes/list.json")

for (var key in modes) {
  modes[key].module = modeModules[modes[key].mode]
}

module.exports = modes


/***/ }),

/***/ "./node_modules/browserify-aes/modes/list.json":
/*!*****************************************************!*\
  !*** ./node_modules/browserify-aes/modes/list.json ***!
  \*****************************************************/
/*! exports provided: aes-128-ecb, aes-192-ecb, aes-256-ecb, aes-128-cbc, aes-192-cbc, aes-256-cbc, aes128, aes192, aes256, aes-128-cfb, aes-192-cfb, aes-256-cfb, aes-128-cfb8, aes-192-cfb8, aes-256-cfb8, aes-128-cfb1, aes-192-cfb1, aes-256-cfb1, aes-128-ofb, aes-192-ofb, aes-256-ofb, aes-128-ctr, aes-192-ctr, aes-256-ctr, aes-128-gcm, aes-192-gcm, aes-256-gcm, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"aes-128-ecb\":{\"cipher\":\"AES\",\"key\":128,\"iv\":0,\"mode\":\"ECB\",\"type\":\"block\"},\"aes-192-ecb\":{\"cipher\":\"AES\",\"key\":192,\"iv\":0,\"mode\":\"ECB\",\"type\":\"block\"},\"aes-256-ecb\":{\"cipher\":\"AES\",\"key\":256,\"iv\":0,\"mode\":\"ECB\",\"type\":\"block\"},\"aes-128-cbc\":{\"cipher\":\"AES\",\"key\":128,\"iv\":16,\"mode\":\"CBC\",\"type\":\"block\"},\"aes-192-cbc\":{\"cipher\":\"AES\",\"key\":192,\"iv\":16,\"mode\":\"CBC\",\"type\":\"block\"},\"aes-256-cbc\":{\"cipher\":\"AES\",\"key\":256,\"iv\":16,\"mode\":\"CBC\",\"type\":\"block\"},\"aes128\":{\"cipher\":\"AES\",\"key\":128,\"iv\":16,\"mode\":\"CBC\",\"type\":\"block\"},\"aes192\":{\"cipher\":\"AES\",\"key\":192,\"iv\":16,\"mode\":\"CBC\",\"type\":\"block\"},\"aes256\":{\"cipher\":\"AES\",\"key\":256,\"iv\":16,\"mode\":\"CBC\",\"type\":\"block\"},\"aes-128-cfb\":{\"cipher\":\"AES\",\"key\":128,\"iv\":16,\"mode\":\"CFB\",\"type\":\"stream\"},\"aes-192-cfb\":{\"cipher\":\"AES\",\"key\":192,\"iv\":16,\"mode\":\"CFB\",\"type\":\"stream\"},\"aes-256-cfb\":{\"cipher\":\"AES\",\"key\":256,\"iv\":16,\"mode\":\"CFB\",\"type\":\"stream\"},\"aes-128-cfb8\":{\"cipher\":\"AES\",\"key\":128,\"iv\":16,\"mode\":\"CFB8\",\"type\":\"stream\"},\"aes-192-cfb8\":{\"cipher\":\"AES\",\"key\":192,\"iv\":16,\"mode\":\"CFB8\",\"type\":\"stream\"},\"aes-256-cfb8\":{\"cipher\":\"AES\",\"key\":256,\"iv\":16,\"mode\":\"CFB8\",\"type\":\"stream\"},\"aes-128-cfb1\":{\"cipher\":\"AES\",\"key\":128,\"iv\":16,\"mode\":\"CFB1\",\"type\":\"stream\"},\"aes-192-cfb1\":{\"cipher\":\"AES\",\"key\":192,\"iv\":16,\"mode\":\"CFB1\",\"type\":\"stream\"},\"aes-256-cfb1\":{\"cipher\":\"AES\",\"key\":256,\"iv\":16,\"mode\":\"CFB1\",\"type\":\"stream\"},\"aes-128-ofb\":{\"cipher\":\"AES\",\"key\":128,\"iv\":16,\"mode\":\"OFB\",\"type\":\"stream\"},\"aes-192-ofb\":{\"cipher\":\"AES\",\"key\":192,\"iv\":16,\"mode\":\"OFB\",\"type\":\"stream\"},\"aes-256-ofb\":{\"cipher\":\"AES\",\"key\":256,\"iv\":16,\"mode\":\"OFB\",\"type\":\"stream\"},\"aes-128-ctr\":{\"cipher\":\"AES\",\"key\":128,\"iv\":16,\"mode\":\"CTR\",\"type\":\"stream\"},\"aes-192-ctr\":{\"cipher\":\"AES\",\"key\":192,\"iv\":16,\"mode\":\"CTR\",\"type\":\"stream\"},\"aes-256-ctr\":{\"cipher\":\"AES\",\"key\":256,\"iv\":16,\"mode\":\"CTR\",\"type\":\"stream\"},\"aes-128-gcm\":{\"cipher\":\"AES\",\"key\":128,\"iv\":12,\"mode\":\"GCM\",\"type\":\"auth\"},\"aes-192-gcm\":{\"cipher\":\"AES\",\"key\":192,\"iv\":12,\"mode\":\"GCM\",\"type\":\"auth\"},\"aes-256-gcm\":{\"cipher\":\"AES\",\"key\":256,\"iv\":12,\"mode\":\"GCM\",\"type\":\"auth\"}}");

/***/ }),

/***/ "./node_modules/browserify-aes/modes/ofb.js":
/*!**************************************************!*\
  !*** ./node_modules/browserify-aes/modes/ofb.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var xor = __webpack_require__(/*! buffer-xor */ "./node_modules/buffer-xor/index.js")

function getBlock (self) {
  self._prev = self._cipher.encryptBlock(self._prev)
  return self._prev
}

exports.encrypt = function (self, chunk) {
  while (self._cache.length < chunk.length) {
    self._cache = Buffer.concat([self._cache, getBlock(self)])
  }

  var pad = self._cache.slice(0, chunk.length)
  self._cache = self._cache.slice(chunk.length)
  return xor(chunk, pad)
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/browserify-aes/streamCipher.js":
/*!*****************************************************!*\
  !*** ./node_modules/browserify-aes/streamCipher.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var aes = __webpack_require__(/*! ./aes */ "./node_modules/browserify-aes/aes.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
var Transform = __webpack_require__(/*! cipher-base */ "./node_modules/cipher-base/index.js")
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")

function StreamCipher (mode, key, iv, decrypt) {
  Transform.call(this)

  this._cipher = new aes.AES(key)
  this._prev = Buffer.from(iv)
  this._cache = Buffer.allocUnsafe(0)
  this._secCache = Buffer.allocUnsafe(0)
  this._decrypt = decrypt
  this._mode = mode
}

inherits(StreamCipher, Transform)

StreamCipher.prototype._update = function (chunk) {
  return this._mode.encrypt(this, chunk, this._decrypt)
}

StreamCipher.prototype._final = function () {
  this._cipher.scrub()
}

module.exports = StreamCipher


/***/ }),

/***/ "./node_modules/browserify-cipher/browser.js":
/*!***************************************************!*\
  !*** ./node_modules/browserify-cipher/browser.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DES = __webpack_require__(/*! browserify-des */ "./node_modules/browserify-des/index.js")
var aes = __webpack_require__(/*! browserify-aes/browser */ "./node_modules/browserify-aes/browser.js")
var aesModes = __webpack_require__(/*! browserify-aes/modes */ "./node_modules/browserify-aes/modes/index.js")
var desModes = __webpack_require__(/*! browserify-des/modes */ "./node_modules/browserify-des/modes.js")
var ebtk = __webpack_require__(/*! evp_bytestokey */ "./node_modules/evp_bytestokey/index.js")

function createCipher (suite, password) {
  suite = suite.toLowerCase()

  var keyLen, ivLen
  if (aesModes[suite]) {
    keyLen = aesModes[suite].key
    ivLen = aesModes[suite].iv
  } else if (desModes[suite]) {
    keyLen = desModes[suite].key * 8
    ivLen = desModes[suite].iv
  } else {
    throw new TypeError('invalid suite type')
  }

  var keys = ebtk(password, false, keyLen, ivLen)
  return createCipheriv(suite, keys.key, keys.iv)
}

function createDecipher (suite, password) {
  suite = suite.toLowerCase()

  var keyLen, ivLen
  if (aesModes[suite]) {
    keyLen = aesModes[suite].key
    ivLen = aesModes[suite].iv
  } else if (desModes[suite]) {
    keyLen = desModes[suite].key * 8
    ivLen = desModes[suite].iv
  } else {
    throw new TypeError('invalid suite type')
  }

  var keys = ebtk(password, false, keyLen, ivLen)
  return createDecipheriv(suite, keys.key, keys.iv)
}

function createCipheriv (suite, key, iv) {
  suite = suite.toLowerCase()
  if (aesModes[suite]) return aes.createCipheriv(suite, key, iv)
  if (desModes[suite]) return new DES({ key: key, iv: iv, mode: suite })

  throw new TypeError('invalid suite type')
}

function createDecipheriv (suite, key, iv) {
  suite = suite.toLowerCase()
  if (aesModes[suite]) return aes.createDecipheriv(suite, key, iv)
  if (desModes[suite]) return new DES({ key: key, iv: iv, mode: suite, decrypt: true })

  throw new TypeError('invalid suite type')
}

function getCiphers () {
  return Object.keys(desModes).concat(aes.getCiphers())
}

exports.createCipher = exports.Cipher = createCipher
exports.createCipheriv = exports.Cipheriv = createCipheriv
exports.createDecipher = exports.Decipher = createDecipher
exports.createDecipheriv = exports.Decipheriv = createDecipheriv
exports.listCiphers = exports.getCiphers = getCiphers


/***/ }),

/***/ "./node_modules/browserify-des/index.js":
/*!**********************************************!*\
  !*** ./node_modules/browserify-des/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var CipherBase = __webpack_require__(/*! cipher-base */ "./node_modules/cipher-base/index.js")
var des = __webpack_require__(/*! des.js */ "./node_modules/des.js/lib/des.js")
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

var modes = {
  'des-ede3-cbc': des.CBC.instantiate(des.EDE),
  'des-ede3': des.EDE,
  'des-ede-cbc': des.CBC.instantiate(des.EDE),
  'des-ede': des.EDE,
  'des-cbc': des.CBC.instantiate(des.DES),
  'des-ecb': des.DES
}
modes.des = modes['des-cbc']
modes.des3 = modes['des-ede3-cbc']
module.exports = DES
inherits(DES, CipherBase)
function DES (opts) {
  CipherBase.call(this)
  var modeName = opts.mode.toLowerCase()
  var mode = modes[modeName]
  var type
  if (opts.decrypt) {
    type = 'decrypt'
  } else {
    type = 'encrypt'
  }
  var key = opts.key
  if (!Buffer.isBuffer(key)) {
    key = Buffer.from(key)
  }
  if (modeName === 'des-ede' || modeName === 'des-ede-cbc') {
    key = Buffer.concat([key, key.slice(0, 8)])
  }
  var iv = opts.iv
  if (!Buffer.isBuffer(iv)) {
    iv = Buffer.from(iv)
  }
  this._des = mode.create({
    key: key,
    iv: iv,
    type: type
  })
}
DES.prototype._update = function (data) {
  return Buffer.from(this._des.update(data))
}
DES.prototype._final = function () {
  return Buffer.from(this._des.final())
}


/***/ }),

/***/ "./node_modules/browserify-des/modes.js":
/*!**********************************************!*\
  !*** ./node_modules/browserify-des/modes.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports['des-ecb'] = {
  key: 8,
  iv: 0
}
exports['des-cbc'] = exports.des = {
  key: 8,
  iv: 8
}
exports['des-ede3-cbc'] = exports.des3 = {
  key: 24,
  iv: 8
}
exports['des-ede3'] = {
  key: 24,
  iv: 0
}
exports['des-ede-cbc'] = {
  key: 16,
  iv: 8
}
exports['des-ede'] = {
  key: 16,
  iv: 0
}


/***/ }),

/***/ "./node_modules/browserify-rsa/index.js":
/*!**********************************************!*\
  !*** ./node_modules/browserify-rsa/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var bn = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");
var randomBytes = __webpack_require__(/*! randombytes */ "./node_modules/randombytes/browser.js");
module.exports = crt;
function blind(priv) {
  var r = getr(priv);
  var blinder = r.toRed(bn.mont(priv.modulus))
  .redPow(new bn(priv.publicExponent)).fromRed();
  return {
    blinder: blinder,
    unblinder:r.invm(priv.modulus)
  };
}
function crt(msg, priv) {
  var blinds = blind(priv);
  var len = priv.modulus.byteLength();
  var mod = bn.mont(priv.modulus);
  var blinded = new bn(msg).mul(blinds.blinder).umod(priv.modulus);
  var c1 = blinded.toRed(bn.mont(priv.prime1));
  var c2 = blinded.toRed(bn.mont(priv.prime2));
  var qinv = priv.coefficient;
  var p = priv.prime1;
  var q = priv.prime2;
  var m1 = c1.redPow(priv.exponent1);
  var m2 = c2.redPow(priv.exponent2);
  m1 = m1.fromRed();
  m2 = m2.fromRed();
  var h = m1.isub(m2).imul(qinv).umod(p);
  h.imul(q);
  m2.iadd(h);
  return new Buffer(m2.imul(blinds.unblinder).umod(priv.modulus).toArray(false, len));
}
crt.getr = getr;
function getr(priv) {
  var len = priv.modulus.byteLength();
  var r = new bn(randomBytes(len));
  while (r.cmp(priv.modulus) >=  0 || !r.umod(priv.prime1) || !r.umod(priv.prime2)) {
    r = new bn(randomBytes(len));
  }
  return r;
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/browserify-sign/algos.js":
/*!***********************************************!*\
  !*** ./node_modules/browserify-sign/algos.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./browser/algorithms.json */ "./node_modules/browserify-sign/browser/algorithms.json")


/***/ }),

/***/ "./node_modules/browserify-sign/browser/algorithms.json":
/*!**************************************************************!*\
  !*** ./node_modules/browserify-sign/browser/algorithms.json ***!
  \**************************************************************/
/*! exports provided: sha224WithRSAEncryption, RSA-SHA224, sha256WithRSAEncryption, RSA-SHA256, sha384WithRSAEncryption, RSA-SHA384, sha512WithRSAEncryption, RSA-SHA512, RSA-SHA1, ecdsa-with-SHA1, sha256, sha224, sha384, sha512, DSA-SHA, DSA-SHA1, DSA, DSA-WITH-SHA224, DSA-SHA224, DSA-WITH-SHA256, DSA-SHA256, DSA-WITH-SHA384, DSA-SHA384, DSA-WITH-SHA512, DSA-SHA512, DSA-RIPEMD160, ripemd160WithRSA, RSA-RIPEMD160, md5WithRSAEncryption, RSA-MD5, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"sha224WithRSAEncryption\":{\"sign\":\"rsa\",\"hash\":\"sha224\",\"id\":\"302d300d06096086480165030402040500041c\"},\"RSA-SHA224\":{\"sign\":\"ecdsa/rsa\",\"hash\":\"sha224\",\"id\":\"302d300d06096086480165030402040500041c\"},\"sha256WithRSAEncryption\":{\"sign\":\"rsa\",\"hash\":\"sha256\",\"id\":\"3031300d060960864801650304020105000420\"},\"RSA-SHA256\":{\"sign\":\"ecdsa/rsa\",\"hash\":\"sha256\",\"id\":\"3031300d060960864801650304020105000420\"},\"sha384WithRSAEncryption\":{\"sign\":\"rsa\",\"hash\":\"sha384\",\"id\":\"3041300d060960864801650304020205000430\"},\"RSA-SHA384\":{\"sign\":\"ecdsa/rsa\",\"hash\":\"sha384\",\"id\":\"3041300d060960864801650304020205000430\"},\"sha512WithRSAEncryption\":{\"sign\":\"rsa\",\"hash\":\"sha512\",\"id\":\"3051300d060960864801650304020305000440\"},\"RSA-SHA512\":{\"sign\":\"ecdsa/rsa\",\"hash\":\"sha512\",\"id\":\"3051300d060960864801650304020305000440\"},\"RSA-SHA1\":{\"sign\":\"rsa\",\"hash\":\"sha1\",\"id\":\"3021300906052b0e03021a05000414\"},\"ecdsa-with-SHA1\":{\"sign\":\"ecdsa\",\"hash\":\"sha1\",\"id\":\"\"},\"sha256\":{\"sign\":\"ecdsa\",\"hash\":\"sha256\",\"id\":\"\"},\"sha224\":{\"sign\":\"ecdsa\",\"hash\":\"sha224\",\"id\":\"\"},\"sha384\":{\"sign\":\"ecdsa\",\"hash\":\"sha384\",\"id\":\"\"},\"sha512\":{\"sign\":\"ecdsa\",\"hash\":\"sha512\",\"id\":\"\"},\"DSA-SHA\":{\"sign\":\"dsa\",\"hash\":\"sha1\",\"id\":\"\"},\"DSA-SHA1\":{\"sign\":\"dsa\",\"hash\":\"sha1\",\"id\":\"\"},\"DSA\":{\"sign\":\"dsa\",\"hash\":\"sha1\",\"id\":\"\"},\"DSA-WITH-SHA224\":{\"sign\":\"dsa\",\"hash\":\"sha224\",\"id\":\"\"},\"DSA-SHA224\":{\"sign\":\"dsa\",\"hash\":\"sha224\",\"id\":\"\"},\"DSA-WITH-SHA256\":{\"sign\":\"dsa\",\"hash\":\"sha256\",\"id\":\"\"},\"DSA-SHA256\":{\"sign\":\"dsa\",\"hash\":\"sha256\",\"id\":\"\"},\"DSA-WITH-SHA384\":{\"sign\":\"dsa\",\"hash\":\"sha384\",\"id\":\"\"},\"DSA-SHA384\":{\"sign\":\"dsa\",\"hash\":\"sha384\",\"id\":\"\"},\"DSA-WITH-SHA512\":{\"sign\":\"dsa\",\"hash\":\"sha512\",\"id\":\"\"},\"DSA-SHA512\":{\"sign\":\"dsa\",\"hash\":\"sha512\",\"id\":\"\"},\"DSA-RIPEMD160\":{\"sign\":\"dsa\",\"hash\":\"rmd160\",\"id\":\"\"},\"ripemd160WithRSA\":{\"sign\":\"rsa\",\"hash\":\"rmd160\",\"id\":\"3021300906052b2403020105000414\"},\"RSA-RIPEMD160\":{\"sign\":\"rsa\",\"hash\":\"rmd160\",\"id\":\"3021300906052b2403020105000414\"},\"md5WithRSAEncryption\":{\"sign\":\"rsa\",\"hash\":\"md5\",\"id\":\"3020300c06082a864886f70d020505000410\"},\"RSA-MD5\":{\"sign\":\"rsa\",\"hash\":\"md5\",\"id\":\"3020300c06082a864886f70d020505000410\"}}");

/***/ }),

/***/ "./node_modules/browserify-sign/browser/curves.json":
/*!**********************************************************!*\
  !*** ./node_modules/browserify-sign/browser/curves.json ***!
  \**********************************************************/
/*! exports provided: 1.3.132.0.10, 1.3.132.0.33, 1.2.840.10045.3.1.1, 1.2.840.10045.3.1.7, 1.3.132.0.34, 1.3.132.0.35, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"1.3.132.0.10\":\"secp256k1\",\"1.3.132.0.33\":\"p224\",\"1.2.840.10045.3.1.1\":\"p192\",\"1.2.840.10045.3.1.7\":\"p256\",\"1.3.132.0.34\":\"p384\",\"1.3.132.0.35\":\"p521\"}");

/***/ }),

/***/ "./node_modules/browserify-sign/browser/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/browserify-sign/browser/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var createHash = __webpack_require__(/*! create-hash */ "./node_modules/create-hash/browser.js")
var stream = __webpack_require__(/*! stream */ "./node_modules/stream-browserify/index.js")
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var sign = __webpack_require__(/*! ./sign */ "./node_modules/browserify-sign/browser/sign.js")
var verify = __webpack_require__(/*! ./verify */ "./node_modules/browserify-sign/browser/verify.js")

var algorithms = __webpack_require__(/*! ./algorithms.json */ "./node_modules/browserify-sign/browser/algorithms.json")
Object.keys(algorithms).forEach(function (key) {
  algorithms[key].id = new Buffer(algorithms[key].id, 'hex')
  algorithms[key.toLowerCase()] = algorithms[key]
})

function Sign (algorithm) {
  stream.Writable.call(this)

  var data = algorithms[algorithm]
  if (!data) throw new Error('Unknown message digest')

  this._hashType = data.hash
  this._hash = createHash(data.hash)
  this._tag = data.id
  this._signType = data.sign
}
inherits(Sign, stream.Writable)

Sign.prototype._write = function _write (data, _, done) {
  this._hash.update(data)
  done()
}

Sign.prototype.update = function update (data, enc) {
  if (typeof data === 'string') data = new Buffer(data, enc)

  this._hash.update(data)
  return this
}

Sign.prototype.sign = function signMethod (key, enc) {
  this.end()
  var hash = this._hash.digest()
  var sig = sign(hash, key, this._hashType, this._signType, this._tag)

  return enc ? sig.toString(enc) : sig
}

function Verify (algorithm) {
  stream.Writable.call(this)

  var data = algorithms[algorithm]
  if (!data) throw new Error('Unknown message digest')

  this._hash = createHash(data.hash)
  this._tag = data.id
  this._signType = data.sign
}
inherits(Verify, stream.Writable)

Verify.prototype._write = function _write (data, _, done) {
  this._hash.update(data)
  done()
}

Verify.prototype.update = function update (data, enc) {
  if (typeof data === 'string') data = new Buffer(data, enc)

  this._hash.update(data)
  return this
}

Verify.prototype.verify = function verifyMethod (key, sig, enc) {
  if (typeof sig === 'string') sig = new Buffer(sig, enc)

  this.end()
  var hash = this._hash.digest()
  return verify(sig, hash, key, this._signType, this._tag)
}

function createSign (algorithm) {
  return new Sign(algorithm)
}

function createVerify (algorithm) {
  return new Verify(algorithm)
}

module.exports = {
  Sign: createSign,
  Verify: createVerify,
  createSign: createSign,
  createVerify: createVerify
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/browserify-sign/browser/sign.js":
/*!******************************************************!*\
  !*** ./node_modules/browserify-sign/browser/sign.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
var createHmac = __webpack_require__(/*! create-hmac */ "./node_modules/create-hmac/browser.js")
var crt = __webpack_require__(/*! browserify-rsa */ "./node_modules/browserify-rsa/index.js")
var EC = __webpack_require__(/*! elliptic */ "./node_modules/elliptic/lib/elliptic.js").ec
var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js")
var parseKeys = __webpack_require__(/*! parse-asn1 */ "./node_modules/parse-asn1/index.js")
var curves = __webpack_require__(/*! ./curves.json */ "./node_modules/browserify-sign/browser/curves.json")

function sign (hash, key, hashType, signType, tag) {
  var priv = parseKeys(key)
  if (priv.curve) {
    // rsa keys can be interpreted as ecdsa ones in openssl
    if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') throw new Error('wrong private key type')
    return ecSign(hash, priv)
  } else if (priv.type === 'dsa') {
    if (signType !== 'dsa') throw new Error('wrong private key type')
    return dsaSign(hash, priv, hashType)
  } else {
    if (signType !== 'rsa' && signType !== 'ecdsa/rsa') throw new Error('wrong private key type')
  }
  hash = Buffer.concat([tag, hash])
  var len = priv.modulus.byteLength()
  var pad = [ 0, 1 ]
  while (hash.length + pad.length + 1 < len) pad.push(0xff)
  pad.push(0x00)
  var i = -1
  while (++i < hash.length) pad.push(hash[i])

  var out = crt(pad, priv)
  return out
}

function ecSign (hash, priv) {
  var curveId = curves[priv.curve.join('.')]
  if (!curveId) throw new Error('unknown curve ' + priv.curve.join('.'))

  var curve = new EC(curveId)
  var key = curve.keyFromPrivate(priv.privateKey)
  var out = key.sign(hash)

  return new Buffer(out.toDER())
}

function dsaSign (hash, priv, algo) {
  var x = priv.params.priv_key
  var p = priv.params.p
  var q = priv.params.q
  var g = priv.params.g
  var r = new BN(0)
  var k
  var H = bits2int(hash, q).mod(q)
  var s = false
  var kv = getKey(x, q, hash, algo)
  while (s === false) {
    k = makeKey(q, kv, algo)
    r = makeR(g, k, p, q)
    s = k.invm(q).imul(H.add(x.mul(r))).mod(q)
    if (s.cmpn(0) === 0) {
      s = false
      r = new BN(0)
    }
  }
  return toDER(r, s)
}

function toDER (r, s) {
  r = r.toArray()
  s = s.toArray()

  // Pad values
  if (r[0] & 0x80) r = [ 0 ].concat(r)
  if (s[0] & 0x80) s = [ 0 ].concat(s)

  var total = r.length + s.length + 4
  var res = [ 0x30, total, 0x02, r.length ]
  res = res.concat(r, [ 0x02, s.length ], s)
  return new Buffer(res)
}

function getKey (x, q, hash, algo) {
  x = new Buffer(x.toArray())
  if (x.length < q.byteLength()) {
    var zeros = new Buffer(q.byteLength() - x.length)
    zeros.fill(0)
    x = Buffer.concat([ zeros, x ])
  }
  var hlen = hash.length
  var hbits = bits2octets(hash, q)
  var v = new Buffer(hlen)
  v.fill(1)
  var k = new Buffer(hlen)
  k.fill(0)
  k = createHmac(algo, k).update(v).update(new Buffer([ 0 ])).update(x).update(hbits).digest()
  v = createHmac(algo, k).update(v).digest()
  k = createHmac(algo, k).update(v).update(new Buffer([ 1 ])).update(x).update(hbits).digest()
  v = createHmac(algo, k).update(v).digest()
  return { k: k, v: v }
}

function bits2int (obits, q) {
  var bits = new BN(obits)
  var shift = (obits.length << 3) - q.bitLength()
  if (shift > 0) bits.ishrn(shift)
  return bits
}

function bits2octets (bits, q) {
  bits = bits2int(bits, q)
  bits = bits.mod(q)
  var out = new Buffer(bits.toArray())
  if (out.length < q.byteLength()) {
    var zeros = new Buffer(q.byteLength() - out.length)
    zeros.fill(0)
    out = Buffer.concat([ zeros, out ])
  }
  return out
}

function makeKey (q, kv, algo) {
  var t
  var k

  do {
    t = new Buffer(0)

    while (t.length * 8 < q.bitLength()) {
      kv.v = createHmac(algo, kv.k).update(kv.v).digest()
      t = Buffer.concat([ t, kv.v ])
    }

    k = bits2int(t, q)
    kv.k = createHmac(algo, kv.k).update(kv.v).update(new Buffer([ 0 ])).digest()
    kv.v = createHmac(algo, kv.k).update(kv.v).digest()
  } while (k.cmp(q) !== -1)

  return k
}

function makeR (g, k, p, q) {
  return g.toRed(BN.mont(p)).redPow(k).fromRed().mod(q)
}

module.exports = sign
module.exports.getKey = getKey
module.exports.makeKey = makeKey

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/browserify-sign/browser/verify.js":
/*!********************************************************!*\
  !*** ./node_modules/browserify-sign/browser/verify.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js")
var EC = __webpack_require__(/*! elliptic */ "./node_modules/elliptic/lib/elliptic.js").ec
var parseKeys = __webpack_require__(/*! parse-asn1 */ "./node_modules/parse-asn1/index.js")
var curves = __webpack_require__(/*! ./curves.json */ "./node_modules/browserify-sign/browser/curves.json")

function verify (sig, hash, key, signType, tag) {
  var pub = parseKeys(key)
  if (pub.type === 'ec') {
    // rsa keys can be interpreted as ecdsa ones in openssl
    if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') throw new Error('wrong public key type')
    return ecVerify(sig, hash, pub)
  } else if (pub.type === 'dsa') {
    if (signType !== 'dsa') throw new Error('wrong public key type')
    return dsaVerify(sig, hash, pub)
  } else {
    if (signType !== 'rsa' && signType !== 'ecdsa/rsa') throw new Error('wrong public key type')
  }
  hash = Buffer.concat([tag, hash])
  var len = pub.modulus.byteLength()
  var pad = [ 1 ]
  var padNum = 0
  while (hash.length + pad.length + 2 < len) {
    pad.push(0xff)
    padNum++
  }
  pad.push(0x00)
  var i = -1
  while (++i < hash.length) {
    pad.push(hash[i])
  }
  pad = new Buffer(pad)
  var red = BN.mont(pub.modulus)
  sig = new BN(sig).toRed(red)

  sig = sig.redPow(new BN(pub.publicExponent))
  sig = new Buffer(sig.fromRed().toArray())
  var out = padNum < 8 ? 1 : 0
  len = Math.min(sig.length, pad.length)
  if (sig.length !== pad.length) out = 1

  i = -1
  while (++i < len) out |= sig[i] ^ pad[i]
  return out === 0
}

function ecVerify (sig, hash, pub) {
  var curveId = curves[pub.data.algorithm.curve.join('.')]
  if (!curveId) throw new Error('unknown curve ' + pub.data.algorithm.curve.join('.'))

  var curve = new EC(curveId)
  var pubkey = pub.data.subjectPrivateKey.data

  return curve.verify(hash, sig, pubkey)
}

function dsaVerify (sig, hash, pub) {
  var p = pub.data.p
  var q = pub.data.q
  var g = pub.data.g
  var y = pub.data.pub_key
  var unpacked = parseKeys.signature.decode(sig, 'der')
  var s = unpacked.s
  var r = unpacked.r
  checkValue(s, q)
  checkValue(r, q)
  var montp = BN.mont(p)
  var w = s.invm(q)
  var v = g.toRed(montp)
    .redPow(new BN(hash).mul(w).mod(q))
    .fromRed()
    .mul(y.toRed(montp).redPow(r.mul(w).mod(q)).fromRed())
    .mod(p)
    .mod(q)
  return v.cmp(r) === 0
}

function checkValue (b, q) {
  if (b.cmpn(0) <= 0) throw new Error('invalid sig')
  if (b.cmp(q) >= q) throw new Error('invalid sig')
}

module.exports = verify

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/buffer-xor/index.js":
/*!******************************************!*\
  !*** ./node_modules/buffer-xor/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {module.exports = function xor (a, b) {
  var length = Math.min(a.length, b.length)
  var buffer = new Buffer(length)

  for (var i = 0; i < length; ++i) {
    buffer[i] = a[i] ^ b[i]
  }

  return buffer
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js")
var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js")
var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js")

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/cipher-base/index.js":
/*!*******************************************!*\
  !*** ./node_modules/cipher-base/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
var Transform = __webpack_require__(/*! stream */ "./node_modules/stream-browserify/index.js").Transform
var StringDecoder = __webpack_require__(/*! string_decoder */ "./node_modules/string_decoder/lib/string_decoder.js").StringDecoder
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")

function CipherBase (hashMode) {
  Transform.call(this)
  this.hashMode = typeof hashMode === 'string'
  if (this.hashMode) {
    this[hashMode] = this._finalOrDigest
  } else {
    this.final = this._finalOrDigest
  }
  if (this._final) {
    this.__final = this._final
    this._final = null
  }
  this._decoder = null
  this._encoding = null
}
inherits(CipherBase, Transform)

CipherBase.prototype.update = function (data, inputEnc, outputEnc) {
  if (typeof data === 'string') {
    data = Buffer.from(data, inputEnc)
  }

  var outData = this._update(data)
  if (this.hashMode) return this

  if (outputEnc) {
    outData = this._toString(outData, outputEnc)
  }

  return outData
}

CipherBase.prototype.setAutoPadding = function () {}
CipherBase.prototype.getAuthTag = function () {
  throw new Error('trying to get auth tag in unsupported state')
}

CipherBase.prototype.setAuthTag = function () {
  throw new Error('trying to set auth tag in unsupported state')
}

CipherBase.prototype.setAAD = function () {
  throw new Error('trying to set aad in unsupported state')
}

CipherBase.prototype._transform = function (data, _, next) {
  var err
  try {
    if (this.hashMode) {
      this._update(data)
    } else {
      this.push(this._update(data))
    }
  } catch (e) {
    err = e
  } finally {
    next(err)
  }
}
CipherBase.prototype._flush = function (done) {
  var err
  try {
    this.push(this.__final())
  } catch (e) {
    err = e
  }

  done(err)
}
CipherBase.prototype._finalOrDigest = function (outputEnc) {
  var outData = this.__final() || Buffer.alloc(0)
  if (outputEnc) {
    outData = this._toString(outData, outputEnc, true)
  }
  return outData
}

CipherBase.prototype._toString = function (value, enc, fin) {
  if (!this._decoder) {
    this._decoder = new StringDecoder(enc)
    this._encoding = enc
  }

  if (this._encoding !== enc) throw new Error('can\'t switch encodings')

  var out = this._decoder.write(value)
  if (fin) {
    out += this._decoder.end()
  }

  return out
}

module.exports = CipherBase


/***/ }),

/***/ "./node_modules/core-util-is/lib/util.js":
/*!***********************************************!*\
  !*** ./node_modules/core-util-is/lib/util.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/create-ecdh/browser.js":
/*!*********************************************!*\
  !*** ./node_modules/create-ecdh/browser.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var elliptic = __webpack_require__(/*! elliptic */ "./node_modules/elliptic/lib/elliptic.js")
var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js")

module.exports = function createECDH (curve) {
  return new ECDH(curve)
}

var aliases = {
  secp256k1: {
    name: 'secp256k1',
    byteLength: 32
  },
  secp224r1: {
    name: 'p224',
    byteLength: 28
  },
  prime256v1: {
    name: 'p256',
    byteLength: 32
  },
  prime192v1: {
    name: 'p192',
    byteLength: 24
  },
  ed25519: {
    name: 'ed25519',
    byteLength: 32
  },
  secp384r1: {
    name: 'p384',
    byteLength: 48
  },
  secp521r1: {
    name: 'p521',
    byteLength: 66
  }
}

aliases.p224 = aliases.secp224r1
aliases.p256 = aliases.secp256r1 = aliases.prime256v1
aliases.p192 = aliases.secp192r1 = aliases.prime192v1
aliases.p384 = aliases.secp384r1
aliases.p521 = aliases.secp521r1

function ECDH (curve) {
  this.curveType = aliases[curve]
  if (!this.curveType) {
    this.curveType = {
      name: curve
    }
  }
  this.curve = new elliptic.ec(this.curveType.name) // eslint-disable-line new-cap
  this.keys = void 0
}

ECDH.prototype.generateKeys = function (enc, format) {
  this.keys = this.curve.genKeyPair()
  return this.getPublicKey(enc, format)
}

ECDH.prototype.computeSecret = function (other, inenc, enc) {
  inenc = inenc || 'utf8'
  if (!Buffer.isBuffer(other)) {
    other = new Buffer(other, inenc)
  }
  var otherPub = this.curve.keyFromPublic(other).getPublic()
  var out = otherPub.mul(this.keys.getPrivate()).getX()
  return formatReturnValue(out, enc, this.curveType.byteLength)
}

ECDH.prototype.getPublicKey = function (enc, format) {
  var key = this.keys.getPublic(format === 'compressed', true)
  if (format === 'hybrid') {
    if (key[key.length - 1] % 2) {
      key[0] = 7
    } else {
      key[0] = 6
    }
  }
  return formatReturnValue(key, enc)
}

ECDH.prototype.getPrivateKey = function (enc) {
  return formatReturnValue(this.keys.getPrivate(), enc)
}

ECDH.prototype.setPublicKey = function (pub, enc) {
  enc = enc || 'utf8'
  if (!Buffer.isBuffer(pub)) {
    pub = new Buffer(pub, enc)
  }
  this.keys._importPublic(pub)
  return this
}

ECDH.prototype.setPrivateKey = function (priv, enc) {
  enc = enc || 'utf8'
  if (!Buffer.isBuffer(priv)) {
    priv = new Buffer(priv, enc)
  }

  var _priv = new BN(priv)
  _priv = _priv.toString(16)
  this.keys = this.curve.genKeyPair()
  this.keys._importPrivate(_priv)
  return this
}

function formatReturnValue (bn, enc, len) {
  if (!Array.isArray(bn)) {
    bn = bn.toArray()
  }
  var buf = new Buffer(bn)
  if (len && buf.length < len) {
    var zeros = new Buffer(len - buf.length)
    zeros.fill(0)
    buf = Buffer.concat([zeros, buf])
  }
  if (!enc) {
    return buf
  } else {
    return buf.toString(enc)
  }
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/create-hash/browser.js":
/*!*********************************************!*\
  !*** ./node_modules/create-hash/browser.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var MD5 = __webpack_require__(/*! md5.js */ "./node_modules/md5.js/index.js")
var RIPEMD160 = __webpack_require__(/*! ripemd160 */ "./node_modules/ripemd160/index.js")
var sha = __webpack_require__(/*! sha.js */ "./node_modules/sha.js/index.js")
var Base = __webpack_require__(/*! cipher-base */ "./node_modules/cipher-base/index.js")

function Hash (hash) {
  Base.call(this, 'digest')

  this._hash = hash
}

inherits(Hash, Base)

Hash.prototype._update = function (data) {
  this._hash.update(data)
}

Hash.prototype._final = function () {
  return this._hash.digest()
}

module.exports = function createHash (alg) {
  alg = alg.toLowerCase()
  if (alg === 'md5') return new MD5()
  if (alg === 'rmd160' || alg === 'ripemd160') return new RIPEMD160()

  return new Hash(sha(alg))
}


/***/ }),

/***/ "./node_modules/create-hash/md5.js":
/*!*****************************************!*\
  !*** ./node_modules/create-hash/md5.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var MD5 = __webpack_require__(/*! md5.js */ "./node_modules/md5.js/index.js")

module.exports = function (buffer) {
  return new MD5().update(buffer).digest()
}


/***/ }),

/***/ "./node_modules/create-hmac/browser.js":
/*!*********************************************!*\
  !*** ./node_modules/create-hmac/browser.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var Legacy = __webpack_require__(/*! ./legacy */ "./node_modules/create-hmac/legacy.js")
var Base = __webpack_require__(/*! cipher-base */ "./node_modules/cipher-base/index.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
var md5 = __webpack_require__(/*! create-hash/md5 */ "./node_modules/create-hash/md5.js")
var RIPEMD160 = __webpack_require__(/*! ripemd160 */ "./node_modules/ripemd160/index.js")

var sha = __webpack_require__(/*! sha.js */ "./node_modules/sha.js/index.js")

var ZEROS = Buffer.alloc(128)

function Hmac (alg, key) {
  Base.call(this, 'digest')
  if (typeof key === 'string') {
    key = Buffer.from(key)
  }

  var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64

  this._alg = alg
  this._key = key
  if (key.length > blocksize) {
    var hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg)
    key = hash.update(key).digest()
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = this._ipad = Buffer.allocUnsafe(blocksize)
  var opad = this._opad = Buffer.allocUnsafe(blocksize)

  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }
  this._hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg)
  this._hash.update(ipad)
}

inherits(Hmac, Base)

Hmac.prototype._update = function (data) {
  this._hash.update(data)
}

Hmac.prototype._final = function () {
  var h = this._hash.digest()
  var hash = this._alg === 'rmd160' ? new RIPEMD160() : sha(this._alg)
  return hash.update(this._opad).update(h).digest()
}

module.exports = function createHmac (alg, key) {
  alg = alg.toLowerCase()
  if (alg === 'rmd160' || alg === 'ripemd160') {
    return new Hmac('rmd160', key)
  }
  if (alg === 'md5') {
    return new Legacy(md5, key)
  }
  return new Hmac(alg, key)
}


/***/ }),

/***/ "./node_modules/create-hmac/legacy.js":
/*!********************************************!*\
  !*** ./node_modules/create-hmac/legacy.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

var Base = __webpack_require__(/*! cipher-base */ "./node_modules/cipher-base/index.js")

var ZEROS = Buffer.alloc(128)
var blocksize = 64

function Hmac (alg, key) {
  Base.call(this, 'digest')
  if (typeof key === 'string') {
    key = Buffer.from(key)
  }

  this._alg = alg
  this._key = key

  if (key.length > blocksize) {
    key = alg(key)
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = this._ipad = Buffer.allocUnsafe(blocksize)
  var opad = this._opad = Buffer.allocUnsafe(blocksize)

  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }

  this._hash = [ipad]
}

inherits(Hmac, Base)

Hmac.prototype._update = function (data) {
  this._hash.push(data)
}

Hmac.prototype._final = function () {
  var h = this._alg(Buffer.concat(this._hash))
  return this._alg(Buffer.concat([this._opad, h]))
}
module.exports = Hmac


/***/ }),

/***/ "./node_modules/crypto-browserify/index.js":
/*!*************************************************!*\
  !*** ./node_modules/crypto-browserify/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.randomBytes = exports.rng = exports.pseudoRandomBytes = exports.prng = __webpack_require__(/*! randombytes */ "./node_modules/randombytes/browser.js")
exports.createHash = exports.Hash = __webpack_require__(/*! create-hash */ "./node_modules/create-hash/browser.js")
exports.createHmac = exports.Hmac = __webpack_require__(/*! create-hmac */ "./node_modules/create-hmac/browser.js")

var algos = __webpack_require__(/*! browserify-sign/algos */ "./node_modules/browserify-sign/algos.js")
var algoKeys = Object.keys(algos)
var hashes = ['sha1', 'sha224', 'sha256', 'sha384', 'sha512', 'md5', 'rmd160'].concat(algoKeys)
exports.getHashes = function () {
  return hashes
}

var p = __webpack_require__(/*! pbkdf2 */ "./node_modules/pbkdf2/browser.js")
exports.pbkdf2 = p.pbkdf2
exports.pbkdf2Sync = p.pbkdf2Sync

var aes = __webpack_require__(/*! browserify-cipher */ "./node_modules/browserify-cipher/browser.js")

exports.Cipher = aes.Cipher
exports.createCipher = aes.createCipher
exports.Cipheriv = aes.Cipheriv
exports.createCipheriv = aes.createCipheriv
exports.Decipher = aes.Decipher
exports.createDecipher = aes.createDecipher
exports.Decipheriv = aes.Decipheriv
exports.createDecipheriv = aes.createDecipheriv
exports.getCiphers = aes.getCiphers
exports.listCiphers = aes.listCiphers

var dh = __webpack_require__(/*! diffie-hellman */ "./node_modules/diffie-hellman/browser.js")

exports.DiffieHellmanGroup = dh.DiffieHellmanGroup
exports.createDiffieHellmanGroup = dh.createDiffieHellmanGroup
exports.getDiffieHellman = dh.getDiffieHellman
exports.createDiffieHellman = dh.createDiffieHellman
exports.DiffieHellman = dh.DiffieHellman

var sign = __webpack_require__(/*! browserify-sign */ "./node_modules/browserify-sign/browser/index.js")

exports.createSign = sign.createSign
exports.Sign = sign.Sign
exports.createVerify = sign.createVerify
exports.Verify = sign.Verify

exports.createECDH = __webpack_require__(/*! create-ecdh */ "./node_modules/create-ecdh/browser.js")

var publicEncrypt = __webpack_require__(/*! public-encrypt */ "./node_modules/public-encrypt/browser.js")

exports.publicEncrypt = publicEncrypt.publicEncrypt
exports.privateEncrypt = publicEncrypt.privateEncrypt
exports.publicDecrypt = publicEncrypt.publicDecrypt
exports.privateDecrypt = publicEncrypt.privateDecrypt

// the least I can do is make error messages for the rest of the node.js/crypto api.
// ;[
//   'createCredentials'
// ].forEach(function (name) {
//   exports[name] = function () {
//     throw new Error([
//       'sorry, ' + name + ' is not implemented yet',
//       'we accept pull requests',
//       'https://github.com/crypto-browserify/crypto-browserify'
//     ].join('\n'))
//   }
// })

var rf = __webpack_require__(/*! randomfill */ "./node_modules/randomfill/browser.js")

exports.randomFill = rf.randomFill
exports.randomFillSync = rf.randomFillSync

exports.createCredentials = function () {
  throw new Error([
    'sorry, createCredentials is not implemented yet',
    'we accept pull requests',
    'https://github.com/crypto-browserify/crypto-browserify'
  ].join('\n'))
}

exports.constants = {
  'DH_CHECK_P_NOT_SAFE_PRIME': 2,
  'DH_CHECK_P_NOT_PRIME': 1,
  'DH_UNABLE_TO_CHECK_GENERATOR': 4,
  'DH_NOT_SUITABLE_GENERATOR': 8,
  'NPN_ENABLED': 1,
  'ALPN_ENABLED': 1,
  'RSA_PKCS1_PADDING': 1,
  'RSA_SSLV23_PADDING': 2,
  'RSA_NO_PADDING': 3,
  'RSA_PKCS1_OAEP_PADDING': 4,
  'RSA_X931_PADDING': 5,
  'RSA_PKCS1_PSS_PADDING': 6,
  'POINT_CONVERSION_COMPRESSED': 2,
  'POINT_CONVERSION_UNCOMPRESSED': 4,
  'POINT_CONVERSION_HYBRID': 6
}


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/style.css":
/*!*************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/style.css ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js")(false);
// Module
exports.push([module.i, "body {\n    min-height: 100vh;\n}\n.board {\n   min-height: 300px;\n   min-width: 600px;\n   background-color: aqua;\n}\n\n#pointer {\n    width: 0.5em;\n    height: 0.5em;\n    border-radius: 50%;\n    background-color: red;\n    border: 4px solid #fff;\n    box-shadow: 0 0 0 5px red;\n    position: absolute;\n    top: -100px;\n    left: -100px;\n}\n\n#srcvideo {\n    display: none;\n}", ""]);


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
// eslint-disable-next-line func-names
module.exports = function (useSourceMap) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item, useSourceMap);

      if (item[2]) {
        return "@media ".concat(item[2], "{").concat(content, "}");
      }

      return content;
    }).join('');
  }; // import a list of modules into the list
  // eslint-disable-next-line func-names


  list.i = function (modules, mediaQuery) {
    if (typeof modules === 'string') {
      // eslint-disable-next-line no-param-reassign
      modules = [[null, modules, '']];
    }

    var alreadyImportedModules = {};

    for (var i = 0; i < this.length; i++) {
      // eslint-disable-next-line prefer-destructuring
      var id = this[i][0];

      if (id != null) {
        alreadyImportedModules[id] = true;
      }
    }

    for (var _i = 0; _i < modules.length; _i++) {
      var item = modules[_i]; // skip already imported module
      // this implementation is not 100% perfect for weird media query combinations
      // when a module is imported multiple times with different media queries.
      // I hope this will never occur (Hey this way we have smaller bundles)

      if (item[0] == null || !alreadyImportedModules[item[0]]) {
        if (mediaQuery && !item[2]) {
          item[2] = mediaQuery;
        } else if (mediaQuery) {
          item[2] = "(".concat(item[2], ") and (").concat(mediaQuery, ")");
        }

        list.push(item);
      }
    }
  };

  return list;
};

function cssWithMappingToString(item, useSourceMap) {
  var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring

  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (useSourceMap && typeof btoa === 'function') {
    var sourceMapping = toComment(cssMapping);
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot).concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
  }

  return [content].join('\n');
} // Adapted from convert-source-map (MIT)


function toComment(sourceMap) {
  // eslint-disable-next-line no-undef
  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
  var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
  return "/*# ".concat(data, " */");
}

/***/ }),

/***/ "./node_modules/des.js/lib/des.js":
/*!****************************************!*\
  !*** ./node_modules/des.js/lib/des.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.utils = __webpack_require__(/*! ./des/utils */ "./node_modules/des.js/lib/des/utils.js");
exports.Cipher = __webpack_require__(/*! ./des/cipher */ "./node_modules/des.js/lib/des/cipher.js");
exports.DES = __webpack_require__(/*! ./des/des */ "./node_modules/des.js/lib/des/des.js");
exports.CBC = __webpack_require__(/*! ./des/cbc */ "./node_modules/des.js/lib/des/cbc.js");
exports.EDE = __webpack_require__(/*! ./des/ede */ "./node_modules/des.js/lib/des/ede.js");


/***/ }),

/***/ "./node_modules/des.js/lib/des/cbc.js":
/*!********************************************!*\
  !*** ./node_modules/des.js/lib/des/cbc.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/minimalistic-assert/index.js");
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

var proto = {};

function CBCState(iv) {
  assert.equal(iv.length, 8, 'Invalid IV length');

  this.iv = new Array(8);
  for (var i = 0; i < this.iv.length; i++)
    this.iv[i] = iv[i];
}

function instantiate(Base) {
  function CBC(options) {
    Base.call(this, options);
    this._cbcInit();
  }
  inherits(CBC, Base);

  var keys = Object.keys(proto);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    CBC.prototype[key] = proto[key];
  }

  CBC.create = function create(options) {
    return new CBC(options);
  };

  return CBC;
}

exports.instantiate = instantiate;

proto._cbcInit = function _cbcInit() {
  var state = new CBCState(this.options.iv);
  this._cbcState = state;
};

proto._update = function _update(inp, inOff, out, outOff) {
  var state = this._cbcState;
  var superProto = this.constructor.super_.prototype;

  var iv = state.iv;
  if (this.type === 'encrypt') {
    for (var i = 0; i < this.blockSize; i++)
      iv[i] ^= inp[inOff + i];

    superProto._update.call(this, iv, 0, out, outOff);

    for (var i = 0; i < this.blockSize; i++)
      iv[i] = out[outOff + i];
  } else {
    superProto._update.call(this, inp, inOff, out, outOff);

    for (var i = 0; i < this.blockSize; i++)
      out[outOff + i] ^= iv[i];

    for (var i = 0; i < this.blockSize; i++)
      iv[i] = inp[inOff + i];
  }
};


/***/ }),

/***/ "./node_modules/des.js/lib/des/cipher.js":
/*!***********************************************!*\
  !*** ./node_modules/des.js/lib/des/cipher.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/minimalistic-assert/index.js");

function Cipher(options) {
  this.options = options;

  this.type = this.options.type;
  this.blockSize = 8;
  this._init();

  this.buffer = new Array(this.blockSize);
  this.bufferOff = 0;
}
module.exports = Cipher;

Cipher.prototype._init = function _init() {
  // Might be overrided
};

Cipher.prototype.update = function update(data) {
  if (data.length === 0)
    return [];

  if (this.type === 'decrypt')
    return this._updateDecrypt(data);
  else
    return this._updateEncrypt(data);
};

Cipher.prototype._buffer = function _buffer(data, off) {
  // Append data to buffer
  var min = Math.min(this.buffer.length - this.bufferOff, data.length - off);
  for (var i = 0; i < min; i++)
    this.buffer[this.bufferOff + i] = data[off + i];
  this.bufferOff += min;

  // Shift next
  return min;
};

Cipher.prototype._flushBuffer = function _flushBuffer(out, off) {
  this._update(this.buffer, 0, out, off);
  this.bufferOff = 0;
  return this.blockSize;
};

Cipher.prototype._updateEncrypt = function _updateEncrypt(data) {
  var inputOff = 0;
  var outputOff = 0;

  var count = ((this.bufferOff + data.length) / this.blockSize) | 0;
  var out = new Array(count * this.blockSize);

  if (this.bufferOff !== 0) {
    inputOff += this._buffer(data, inputOff);

    if (this.bufferOff === this.buffer.length)
      outputOff += this._flushBuffer(out, outputOff);
  }

  // Write blocks
  var max = data.length - ((data.length - inputOff) % this.blockSize);
  for (; inputOff < max; inputOff += this.blockSize) {
    this._update(data, inputOff, out, outputOff);
    outputOff += this.blockSize;
  }

  // Queue rest
  for (; inputOff < data.length; inputOff++, this.bufferOff++)
    this.buffer[this.bufferOff] = data[inputOff];

  return out;
};

Cipher.prototype._updateDecrypt = function _updateDecrypt(data) {
  var inputOff = 0;
  var outputOff = 0;

  var count = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1;
  var out = new Array(count * this.blockSize);

  // TODO(indutny): optimize it, this is far from optimal
  for (; count > 0; count--) {
    inputOff += this._buffer(data, inputOff);
    outputOff += this._flushBuffer(out, outputOff);
  }

  // Buffer rest of the input
  inputOff += this._buffer(data, inputOff);

  return out;
};

Cipher.prototype.final = function final(buffer) {
  var first;
  if (buffer)
    first = this.update(buffer);

  var last;
  if (this.type === 'encrypt')
    last = this._finalEncrypt();
  else
    last = this._finalDecrypt();

  if (first)
    return first.concat(last);
  else
    return last;
};

Cipher.prototype._pad = function _pad(buffer, off) {
  if (off === 0)
    return false;

  while (off < buffer.length)
    buffer[off++] = 0;

  return true;
};

Cipher.prototype._finalEncrypt = function _finalEncrypt() {
  if (!this._pad(this.buffer, this.bufferOff))
    return [];

  var out = new Array(this.blockSize);
  this._update(this.buffer, 0, out, 0);
  return out;
};

Cipher.prototype._unpad = function _unpad(buffer) {
  return buffer;
};

Cipher.prototype._finalDecrypt = function _finalDecrypt() {
  assert.equal(this.bufferOff, this.blockSize, 'Not enough data to decrypt');
  var out = new Array(this.blockSize);
  this._flushBuffer(out, 0);

  return this._unpad(out);
};


/***/ }),

/***/ "./node_modules/des.js/lib/des/des.js":
/*!********************************************!*\
  !*** ./node_modules/des.js/lib/des/des.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/minimalistic-assert/index.js");
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

var des = __webpack_require__(/*! ../des */ "./node_modules/des.js/lib/des.js");
var utils = des.utils;
var Cipher = des.Cipher;

function DESState() {
  this.tmp = new Array(2);
  this.keys = null;
}

function DES(options) {
  Cipher.call(this, options);

  var state = new DESState();
  this._desState = state;

  this.deriveKeys(state, options.key);
}
inherits(DES, Cipher);
module.exports = DES;

DES.create = function create(options) {
  return new DES(options);
};

var shiftTable = [
  1, 1, 2, 2, 2, 2, 2, 2,
  1, 2, 2, 2, 2, 2, 2, 1
];

DES.prototype.deriveKeys = function deriveKeys(state, key) {
  state.keys = new Array(16 * 2);

  assert.equal(key.length, this.blockSize, 'Invalid key length');

  var kL = utils.readUInt32BE(key, 0);
  var kR = utils.readUInt32BE(key, 4);

  utils.pc1(kL, kR, state.tmp, 0);
  kL = state.tmp[0];
  kR = state.tmp[1];
  for (var i = 0; i < state.keys.length; i += 2) {
    var shift = shiftTable[i >>> 1];
    kL = utils.r28shl(kL, shift);
    kR = utils.r28shl(kR, shift);
    utils.pc2(kL, kR, state.keys, i);
  }
};

DES.prototype._update = function _update(inp, inOff, out, outOff) {
  var state = this._desState;

  var l = utils.readUInt32BE(inp, inOff);
  var r = utils.readUInt32BE(inp, inOff + 4);

  // Initial Permutation
  utils.ip(l, r, state.tmp, 0);
  l = state.tmp[0];
  r = state.tmp[1];

  if (this.type === 'encrypt')
    this._encrypt(state, l, r, state.tmp, 0);
  else
    this._decrypt(state, l, r, state.tmp, 0);

  l = state.tmp[0];
  r = state.tmp[1];

  utils.writeUInt32BE(out, l, outOff);
  utils.writeUInt32BE(out, r, outOff + 4);
};

DES.prototype._pad = function _pad(buffer, off) {
  var value = buffer.length - off;
  for (var i = off; i < buffer.length; i++)
    buffer[i] = value;

  return true;
};

DES.prototype._unpad = function _unpad(buffer) {
  var pad = buffer[buffer.length - 1];
  for (var i = buffer.length - pad; i < buffer.length; i++)
    assert.equal(buffer[i], pad);

  return buffer.slice(0, buffer.length - pad);
};

DES.prototype._encrypt = function _encrypt(state, lStart, rStart, out, off) {
  var l = lStart;
  var r = rStart;

  // Apply f() x16 times
  for (var i = 0; i < state.keys.length; i += 2) {
    var keyL = state.keys[i];
    var keyR = state.keys[i + 1];

    // f(r, k)
    utils.expand(r, state.tmp, 0);

    keyL ^= state.tmp[0];
    keyR ^= state.tmp[1];
    var s = utils.substitute(keyL, keyR);
    var f = utils.permute(s);

    var t = r;
    r = (l ^ f) >>> 0;
    l = t;
  }

  // Reverse Initial Permutation
  utils.rip(r, l, out, off);
};

DES.prototype._decrypt = function _decrypt(state, lStart, rStart, out, off) {
  var l = rStart;
  var r = lStart;

  // Apply f() x16 times
  for (var i = state.keys.length - 2; i >= 0; i -= 2) {
    var keyL = state.keys[i];
    var keyR = state.keys[i + 1];

    // f(r, k)
    utils.expand(l, state.tmp, 0);

    keyL ^= state.tmp[0];
    keyR ^= state.tmp[1];
    var s = utils.substitute(keyL, keyR);
    var f = utils.permute(s);

    var t = l;
    l = (r ^ f) >>> 0;
    r = t;
  }

  // Reverse Initial Permutation
  utils.rip(l, r, out, off);
};


/***/ }),

/***/ "./node_modules/des.js/lib/des/ede.js":
/*!********************************************!*\
  !*** ./node_modules/des.js/lib/des/ede.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/minimalistic-assert/index.js");
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

var des = __webpack_require__(/*! ../des */ "./node_modules/des.js/lib/des.js");
var Cipher = des.Cipher;
var DES = des.DES;

function EDEState(type, key) {
  assert.equal(key.length, 24, 'Invalid key length');

  var k1 = key.slice(0, 8);
  var k2 = key.slice(8, 16);
  var k3 = key.slice(16, 24);

  if (type === 'encrypt') {
    this.ciphers = [
      DES.create({ type: 'encrypt', key: k1 }),
      DES.create({ type: 'decrypt', key: k2 }),
      DES.create({ type: 'encrypt', key: k3 })
    ];
  } else {
    this.ciphers = [
      DES.create({ type: 'decrypt', key: k3 }),
      DES.create({ type: 'encrypt', key: k2 }),
      DES.create({ type: 'decrypt', key: k1 })
    ];
  }
}

function EDE(options) {
  Cipher.call(this, options);

  var state = new EDEState(this.type, this.options.key);
  this._edeState = state;
}
inherits(EDE, Cipher);

module.exports = EDE;

EDE.create = function create(options) {
  return new EDE(options);
};

EDE.prototype._update = function _update(inp, inOff, out, outOff) {
  var state = this._edeState;

  state.ciphers[0]._update(inp, inOff, out, outOff);
  state.ciphers[1]._update(out, outOff, out, outOff);
  state.ciphers[2]._update(out, outOff, out, outOff);
};

EDE.prototype._pad = DES.prototype._pad;
EDE.prototype._unpad = DES.prototype._unpad;


/***/ }),

/***/ "./node_modules/des.js/lib/des/utils.js":
/*!**********************************************!*\
  !*** ./node_modules/des.js/lib/des/utils.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.readUInt32BE = function readUInt32BE(bytes, off) {
  var res =  (bytes[0 + off] << 24) |
             (bytes[1 + off] << 16) |
             (bytes[2 + off] << 8) |
             bytes[3 + off];
  return res >>> 0;
};

exports.writeUInt32BE = function writeUInt32BE(bytes, value, off) {
  bytes[0 + off] = value >>> 24;
  bytes[1 + off] = (value >>> 16) & 0xff;
  bytes[2 + off] = (value >>> 8) & 0xff;
  bytes[3 + off] = value & 0xff;
};

exports.ip = function ip(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  for (var i = 6; i >= 0; i -= 2) {
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inR >>> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inL >>> (j + i)) & 1;
    }
  }

  for (var i = 6; i >= 0; i -= 2) {
    for (var j = 1; j <= 25; j += 8) {
      outR <<= 1;
      outR |= (inR >>> (j + i)) & 1;
    }
    for (var j = 1; j <= 25; j += 8) {
      outR <<= 1;
      outR |= (inL >>> (j + i)) & 1;
    }
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.rip = function rip(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  for (var i = 0; i < 4; i++) {
    for (var j = 24; j >= 0; j -= 8) {
      outL <<= 1;
      outL |= (inR >>> (j + i)) & 1;
      outL <<= 1;
      outL |= (inL >>> (j + i)) & 1;
    }
  }
  for (var i = 4; i < 8; i++) {
    for (var j = 24; j >= 0; j -= 8) {
      outR <<= 1;
      outR |= (inR >>> (j + i)) & 1;
      outR <<= 1;
      outR |= (inL >>> (j + i)) & 1;
    }
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.pc1 = function pc1(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  // 7, 15, 23, 31, 39, 47, 55, 63
  // 6, 14, 22, 30, 39, 47, 55, 63
  // 5, 13, 21, 29, 39, 47, 55, 63
  // 4, 12, 20, 28
  for (var i = 7; i >= 5; i--) {
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inR >> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inL >> (j + i)) & 1;
    }
  }
  for (var j = 0; j <= 24; j += 8) {
    outL <<= 1;
    outL |= (inR >> (j + i)) & 1;
  }

  // 1, 9, 17, 25, 33, 41, 49, 57
  // 2, 10, 18, 26, 34, 42, 50, 58
  // 3, 11, 19, 27, 35, 43, 51, 59
  // 36, 44, 52, 60
  for (var i = 1; i <= 3; i++) {
    for (var j = 0; j <= 24; j += 8) {
      outR <<= 1;
      outR |= (inR >> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outR <<= 1;
      outR |= (inL >> (j + i)) & 1;
    }
  }
  for (var j = 0; j <= 24; j += 8) {
    outR <<= 1;
    outR |= (inL >> (j + i)) & 1;
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.r28shl = function r28shl(num, shift) {
  return ((num << shift) & 0xfffffff) | (num >>> (28 - shift));
};

var pc2table = [
  // inL => outL
  14, 11, 17, 4, 27, 23, 25, 0,
  13, 22, 7, 18, 5, 9, 16, 24,
  2, 20, 12, 21, 1, 8, 15, 26,

  // inR => outR
  15, 4, 25, 19, 9, 1, 26, 16,
  5, 11, 23, 8, 12, 7, 17, 0,
  22, 3, 10, 14, 6, 20, 27, 24
];

exports.pc2 = function pc2(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  var len = pc2table.length >>> 1;
  for (var i = 0; i < len; i++) {
    outL <<= 1;
    outL |= (inL >>> pc2table[i]) & 0x1;
  }
  for (var i = len; i < pc2table.length; i++) {
    outR <<= 1;
    outR |= (inR >>> pc2table[i]) & 0x1;
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.expand = function expand(r, out, off) {
  var outL = 0;
  var outR = 0;

  outL = ((r & 1) << 5) | (r >>> 27);
  for (var i = 23; i >= 15; i -= 4) {
    outL <<= 6;
    outL |= (r >>> i) & 0x3f;
  }
  for (var i = 11; i >= 3; i -= 4) {
    outR |= (r >>> i) & 0x3f;
    outR <<= 6;
  }
  outR |= ((r & 0x1f) << 1) | (r >>> 31);

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

var sTable = [
  14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1,
  3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8,
  4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7,
  15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13,

  15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14,
  9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5,
  0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2,
  5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9,

  10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10,
  1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1,
  13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7,
  11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12,

  7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3,
  1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9,
  10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8,
  15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14,

  2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1,
  8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6,
  4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13,
  15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3,

  12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5,
  0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8,
  9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10,
  7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13,

  4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10,
  3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6,
  1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7,
  10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12,

  13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4,
  10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2,
  7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13,
  0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11
];

exports.substitute = function substitute(inL, inR) {
  var out = 0;
  for (var i = 0; i < 4; i++) {
    var b = (inL >>> (18 - i * 6)) & 0x3f;
    var sb = sTable[i * 0x40 + b];

    out <<= 4;
    out |= sb;
  }
  for (var i = 0; i < 4; i++) {
    var b = (inR >>> (18 - i * 6)) & 0x3f;
    var sb = sTable[4 * 0x40 + i * 0x40 + b];

    out <<= 4;
    out |= sb;
  }
  return out >>> 0;
};

var permuteTable = [
  16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22,
  30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7
];

exports.permute = function permute(num) {
  var out = 0;
  for (var i = 0; i < permuteTable.length; i++) {
    out <<= 1;
    out |= (num >>> permuteTable[i]) & 0x1;
  }
  return out >>> 0;
};

exports.padSplit = function padSplit(num, size, group) {
  var str = num.toString(2);
  while (str.length < size)
    str = '0' + str;

  var out = [];
  for (var i = 0; i < size; i += group)
    out.push(str.slice(i, i + group));
  return out.join(' ');
};


/***/ }),

/***/ "./node_modules/diffie-hellman/browser.js":
/*!************************************************!*\
  !*** ./node_modules/diffie-hellman/browser.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var generatePrime = __webpack_require__(/*! ./lib/generatePrime */ "./node_modules/diffie-hellman/lib/generatePrime.js")
var primes = __webpack_require__(/*! ./lib/primes.json */ "./node_modules/diffie-hellman/lib/primes.json")

var DH = __webpack_require__(/*! ./lib/dh */ "./node_modules/diffie-hellman/lib/dh.js")

function getDiffieHellman (mod) {
  var prime = new Buffer(primes[mod].prime, 'hex')
  var gen = new Buffer(primes[mod].gen, 'hex')

  return new DH(prime, gen)
}

var ENCODINGS = {
  'binary': true, 'hex': true, 'base64': true
}

function createDiffieHellman (prime, enc, generator, genc) {
  if (Buffer.isBuffer(enc) || ENCODINGS[enc] === undefined) {
    return createDiffieHellman(prime, 'binary', enc, generator)
  }

  enc = enc || 'binary'
  genc = genc || 'binary'
  generator = generator || new Buffer([2])

  if (!Buffer.isBuffer(generator)) {
    generator = new Buffer(generator, genc)
  }

  if (typeof prime === 'number') {
    return new DH(generatePrime(prime, generator), generator, true)
  }

  if (!Buffer.isBuffer(prime)) {
    prime = new Buffer(prime, enc)
  }

  return new DH(prime, generator, true)
}

exports.DiffieHellmanGroup = exports.createDiffieHellmanGroup = exports.getDiffieHellman = getDiffieHellman
exports.createDiffieHellman = exports.DiffieHellman = createDiffieHellman

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/diffie-hellman/lib/dh.js":
/*!***********************************************!*\
  !*** ./node_modules/diffie-hellman/lib/dh.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");
var MillerRabin = __webpack_require__(/*! miller-rabin */ "./node_modules/miller-rabin/lib/mr.js");
var millerRabin = new MillerRabin();
var TWENTYFOUR = new BN(24);
var ELEVEN = new BN(11);
var TEN = new BN(10);
var THREE = new BN(3);
var SEVEN = new BN(7);
var primes = __webpack_require__(/*! ./generatePrime */ "./node_modules/diffie-hellman/lib/generatePrime.js");
var randomBytes = __webpack_require__(/*! randombytes */ "./node_modules/randombytes/browser.js");
module.exports = DH;

function setPublicKey(pub, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(pub)) {
    pub = new Buffer(pub, enc);
  }
  this._pub = new BN(pub);
  return this;
}

function setPrivateKey(priv, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(priv)) {
    priv = new Buffer(priv, enc);
  }
  this._priv = new BN(priv);
  return this;
}

var primeCache = {};
function checkPrime(prime, generator) {
  var gen = generator.toString('hex');
  var hex = [gen, prime.toString(16)].join('_');
  if (hex in primeCache) {
    return primeCache[hex];
  }
  var error = 0;

  if (prime.isEven() ||
    !primes.simpleSieve ||
    !primes.fermatTest(prime) ||
    !millerRabin.test(prime)) {
    //not a prime so +1
    error += 1;

    if (gen === '02' || gen === '05') {
      // we'd be able to check the generator
      // it would fail so +8
      error += 8;
    } else {
      //we wouldn't be able to test the generator
      // so +4
      error += 4;
    }
    primeCache[hex] = error;
    return error;
  }
  if (!millerRabin.test(prime.shrn(1))) {
    //not a safe prime
    error += 2;
  }
  var rem;
  switch (gen) {
    case '02':
      if (prime.mod(TWENTYFOUR).cmp(ELEVEN)) {
        // unsuidable generator
        error += 8;
      }
      break;
    case '05':
      rem = prime.mod(TEN);
      if (rem.cmp(THREE) && rem.cmp(SEVEN)) {
        // prime mod 10 needs to equal 3 or 7
        error += 8;
      }
      break;
    default:
      error += 4;
  }
  primeCache[hex] = error;
  return error;
}

function DH(prime, generator, malleable) {
  this.setGenerator(generator);
  this.__prime = new BN(prime);
  this._prime = BN.mont(this.__prime);
  this._primeLen = prime.length;
  this._pub = undefined;
  this._priv = undefined;
  this._primeCode = undefined;
  if (malleable) {
    this.setPublicKey = setPublicKey;
    this.setPrivateKey = setPrivateKey;
  } else {
    this._primeCode = 8;
  }
}
Object.defineProperty(DH.prototype, 'verifyError', {
  enumerable: true,
  get: function () {
    if (typeof this._primeCode !== 'number') {
      this._primeCode = checkPrime(this.__prime, this.__gen);
    }
    return this._primeCode;
  }
});
DH.prototype.generateKeys = function () {
  if (!this._priv) {
    this._priv = new BN(randomBytes(this._primeLen));
  }
  this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed();
  return this.getPublicKey();
};

DH.prototype.computeSecret = function (other) {
  other = new BN(other);
  other = other.toRed(this._prime);
  var secret = other.redPow(this._priv).fromRed();
  var out = new Buffer(secret.toArray());
  var prime = this.getPrime();
  if (out.length < prime.length) {
    var front = new Buffer(prime.length - out.length);
    front.fill(0);
    out = Buffer.concat([front, out]);
  }
  return out;
};

DH.prototype.getPublicKey = function getPublicKey(enc) {
  return formatReturnValue(this._pub, enc);
};

DH.prototype.getPrivateKey = function getPrivateKey(enc) {
  return formatReturnValue(this._priv, enc);
};

DH.prototype.getPrime = function (enc) {
  return formatReturnValue(this.__prime, enc);
};

DH.prototype.getGenerator = function (enc) {
  return formatReturnValue(this._gen, enc);
};

DH.prototype.setGenerator = function (gen, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(gen)) {
    gen = new Buffer(gen, enc);
  }
  this.__gen = gen;
  this._gen = new BN(gen);
  return this;
};

function formatReturnValue(bn, enc) {
  var buf = new Buffer(bn.toArray());
  if (!enc) {
    return buf;
  } else {
    return buf.toString(enc);
  }
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/diffie-hellman/lib/generatePrime.js":
/*!**********************************************************!*\
  !*** ./node_modules/diffie-hellman/lib/generatePrime.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var randomBytes = __webpack_require__(/*! randombytes */ "./node_modules/randombytes/browser.js");
module.exports = findPrime;
findPrime.simpleSieve = simpleSieve;
findPrime.fermatTest = fermatTest;
var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");
var TWENTYFOUR = new BN(24);
var MillerRabin = __webpack_require__(/*! miller-rabin */ "./node_modules/miller-rabin/lib/mr.js");
var millerRabin = new MillerRabin();
var ONE = new BN(1);
var TWO = new BN(2);
var FIVE = new BN(5);
var SIXTEEN = new BN(16);
var EIGHT = new BN(8);
var TEN = new BN(10);
var THREE = new BN(3);
var SEVEN = new BN(7);
var ELEVEN = new BN(11);
var FOUR = new BN(4);
var TWELVE = new BN(12);
var primes = null;

function _getPrimes() {
  if (primes !== null)
    return primes;

  var limit = 0x100000;
  var res = [];
  res[0] = 2;
  for (var i = 1, k = 3; k < limit; k += 2) {
    var sqrt = Math.ceil(Math.sqrt(k));
    for (var j = 0; j < i && res[j] <= sqrt; j++)
      if (k % res[j] === 0)
        break;

    if (i !== j && res[j] <= sqrt)
      continue;

    res[i++] = k;
  }
  primes = res;
  return res;
}

function simpleSieve(p) {
  var primes = _getPrimes();

  for (var i = 0; i < primes.length; i++)
    if (p.modn(primes[i]) === 0) {
      if (p.cmpn(primes[i]) === 0) {
        return true;
      } else {
        return false;
      }
    }

  return true;
}

function fermatTest(p) {
  var red = BN.mont(p);
  return TWO.toRed(red).redPow(p.subn(1)).fromRed().cmpn(1) === 0;
}

function findPrime(bits, gen) {
  if (bits < 16) {
    // this is what openssl does
    if (gen === 2 || gen === 5) {
      return new BN([0x8c, 0x7b]);
    } else {
      return new BN([0x8c, 0x27]);
    }
  }
  gen = new BN(gen);

  var num, n2;

  while (true) {
    num = new BN(randomBytes(Math.ceil(bits / 8)));
    while (num.bitLength() > bits) {
      num.ishrn(1);
    }
    if (num.isEven()) {
      num.iadd(ONE);
    }
    if (!num.testn(1)) {
      num.iadd(TWO);
    }
    if (!gen.cmp(TWO)) {
      while (num.mod(TWENTYFOUR).cmp(ELEVEN)) {
        num.iadd(FOUR);
      }
    } else if (!gen.cmp(FIVE)) {
      while (num.mod(TEN).cmp(THREE)) {
        num.iadd(FOUR);
      }
    }
    n2 = num.shrn(1);
    if (simpleSieve(n2) && simpleSieve(num) &&
      fermatTest(n2) && fermatTest(num) &&
      millerRabin.test(n2) && millerRabin.test(num)) {
      return num;
    }
  }

}


/***/ }),

/***/ "./node_modules/diffie-hellman/lib/primes.json":
/*!*****************************************************!*\
  !*** ./node_modules/diffie-hellman/lib/primes.json ***!
  \*****************************************************/
/*! exports provided: modp1, modp2, modp5, modp14, modp15, modp16, modp17, modp18, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"modp1\":{\"gen\":\"02\",\"prime\":\"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff\"},\"modp2\":{\"gen\":\"02\",\"prime\":\"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff\"},\"modp5\":{\"gen\":\"02\",\"prime\":\"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff\"},\"modp14\":{\"gen\":\"02\",\"prime\":\"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff\"},\"modp15\":{\"gen\":\"02\",\"prime\":\"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff\"},\"modp16\":{\"gen\":\"02\",\"prime\":\"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff\"},\"modp17\":{\"gen\":\"02\",\"prime\":\"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff\"},\"modp18\":{\"gen\":\"02\",\"prime\":\"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff\"}}");

/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic.js":
/*!***********************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var elliptic = exports;

elliptic.version = __webpack_require__(/*! ../package.json */ "./node_modules/elliptic/package.json").version;
elliptic.utils = __webpack_require__(/*! ./elliptic/utils */ "./node_modules/elliptic/lib/elliptic/utils.js");
elliptic.rand = __webpack_require__(/*! brorand */ "./node_modules/brorand/index.js");
elliptic.curve = __webpack_require__(/*! ./elliptic/curve */ "./node_modules/elliptic/lib/elliptic/curve/index.js");
elliptic.curves = __webpack_require__(/*! ./elliptic/curves */ "./node_modules/elliptic/lib/elliptic/curves.js");

// Protocols
elliptic.ec = __webpack_require__(/*! ./elliptic/ec */ "./node_modules/elliptic/lib/elliptic/ec/index.js");
elliptic.eddsa = __webpack_require__(/*! ./elliptic/eddsa */ "./node_modules/elliptic/lib/elliptic/eddsa/index.js");


/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/curve/base.js":
/*!**********************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/curve/base.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");
var utils = __webpack_require__(/*! ../utils */ "./node_modules/elliptic/lib/elliptic/utils.js");
var getNAF = utils.getNAF;
var getJSF = utils.getJSF;
var assert = utils.assert;

function BaseCurve(type, conf) {
  this.type = type;
  this.p = new BN(conf.p, 16);

  // Use Montgomery, when there is no fast reduction for the prime
  this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);

  // Useful for many curves
  this.zero = new BN(0).toRed(this.red);
  this.one = new BN(1).toRed(this.red);
  this.two = new BN(2).toRed(this.red);

  // Curve configuration, optional
  this.n = conf.n && new BN(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);

  // Temporary arrays
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);

  // Generalized Greg Maxwell's trick
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
module.exports = BaseCurve;

BaseCurve.prototype.point = function point() {
  throw new Error('Not implemented');
};

BaseCurve.prototype.validate = function validate() {
  throw new Error('Not implemented');
};

BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
  assert(p.precomputed);
  var doubles = p._getDoubles();

  var naf = getNAF(k, 1);
  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);
  I /= 3;

  // Translate into more windowed form
  var repr = [];
  for (var j = 0; j < naf.length; j += doubles.step) {
    var nafW = 0;
    for (var k = j + doubles.step - 1; k >= j; k--)
      nafW = (nafW << 1) + naf[k];
    repr.push(nafW);
  }

  var a = this.jpoint(null, null, null);
  var b = this.jpoint(null, null, null);
  for (var i = I; i > 0; i--) {
    for (var j = 0; j < repr.length; j++) {
      var nafW = repr[j];
      if (nafW === i)
        b = b.mixedAdd(doubles.points[j]);
      else if (nafW === -i)
        b = b.mixedAdd(doubles.points[j].neg());
    }
    a = a.add(b);
  }
  return a.toP();
};

BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
  var w = 4;

  // Precompute window
  var nafPoints = p._getNAFPoints(w);
  w = nafPoints.wnd;
  var wnd = nafPoints.points;

  // Get NAF form
  var naf = getNAF(k, w);

  // Add `this`*(N+1) for every w-NAF index
  var acc = this.jpoint(null, null, null);
  for (var i = naf.length - 1; i >= 0; i--) {
    // Count zeroes
    for (var k = 0; i >= 0 && naf[i] === 0; i--)
      k++;
    if (i >= 0)
      k++;
    acc = acc.dblp(k);

    if (i < 0)
      break;
    var z = naf[i];
    assert(z !== 0);
    if (p.type === 'affine') {
      // J +- P
      if (z > 0)
        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);
      else
        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());
    } else {
      // J +- J
      if (z > 0)
        acc = acc.add(wnd[(z - 1) >> 1]);
      else
        acc = acc.add(wnd[(-z - 1) >> 1].neg());
    }
  }
  return p.type === 'affine' ? acc.toP() : acc;
};

BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,
                                                       points,
                                                       coeffs,
                                                       len,
                                                       jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;

  // Fill all arrays
  var max = 0;
  for (var i = 0; i < len; i++) {
    var p = points[i];
    var nafPoints = p._getNAFPoints(defW);
    wndWidth[i] = nafPoints.wnd;
    wnd[i] = nafPoints.points;
  }

  // Comb small window NAFs
  for (var i = len - 1; i >= 1; i -= 2) {
    var a = i - 1;
    var b = i;
    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
      naf[a] = getNAF(coeffs[a], wndWidth[a]);
      naf[b] = getNAF(coeffs[b], wndWidth[b]);
      max = Math.max(naf[a].length, max);
      max = Math.max(naf[b].length, max);
      continue;
    }

    var comb = [
      points[a], /* 1 */
      null, /* 3 */
      null, /* 5 */
      points[b] /* 7 */
    ];

    // Try to avoid Projective points, if possible
    if (points[a].y.cmp(points[b].y) === 0) {
      comb[1] = points[a].add(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].add(points[b].neg());
    } else {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    }

    var index = [
      -3, /* -1 -1 */
      -1, /* -1 0 */
      -5, /* -1 1 */
      -7, /* 0 -1 */
      0, /* 0 0 */
      7, /* 0 1 */
      5, /* 1 -1 */
      1, /* 1 0 */
      3  /* 1 1 */
    ];

    var jsf = getJSF(coeffs[a], coeffs[b]);
    max = Math.max(jsf[0].length, max);
    naf[a] = new Array(max);
    naf[b] = new Array(max);
    for (var j = 0; j < max; j++) {
      var ja = jsf[0][j] | 0;
      var jb = jsf[1][j] | 0;

      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b][j] = 0;
      wnd[a] = comb;
    }
  }

  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (var i = max; i >= 0; i--) {
    var k = 0;

    while (i >= 0) {
      var zero = true;
      for (var j = 0; j < len; j++) {
        tmp[j] = naf[j][i] | 0;
        if (tmp[j] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k++;
      i--;
    }
    if (i >= 0)
      k++;
    acc = acc.dblp(k);
    if (i < 0)
      break;

    for (var j = 0; j < len; j++) {
      var z = tmp[j];
      var p;
      if (z === 0)
        continue;
      else if (z > 0)
        p = wnd[j][(z - 1) >> 1];
      else if (z < 0)
        p = wnd[j][(-z - 1) >> 1].neg();

      if (p.type === 'affine')
        acc = acc.mixedAdd(p);
      else
        acc = acc.add(p);
    }
  }
  // Zeroify references
  for (var i = 0; i < len; i++)
    wnd[i] = null;

  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};

function BasePoint(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;

BasePoint.prototype.eq = function eq(/*other*/) {
  throw new Error('Not implemented');
};

BasePoint.prototype.validate = function validate() {
  return this.curve.validate(this);
};

BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  bytes = utils.toArray(bytes, enc);

  var len = this.p.byteLength();

  // uncompressed, hybrid-odd, hybrid-even
  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&
      bytes.length - 1 === 2 * len) {
    if (bytes[0] === 0x06)
      assert(bytes[bytes.length - 1] % 2 === 0);
    else if (bytes[0] === 0x07)
      assert(bytes[bytes.length - 1] % 2 === 1);

    var res =  this.point(bytes.slice(1, 1 + len),
                          bytes.slice(1 + len, 1 + 2 * len));

    return res;
  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&
              bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
  }
  throw new Error('Unknown point format');
};

BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
  return this.encode(enc, true);
};

BasePoint.prototype._encode = function _encode(compact) {
  var len = this.curve.p.byteLength();
  var x = this.getX().toArray('be', len);

  if (compact)
    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);

  return [ 0x04 ].concat(x, this.getY().toArray('be', len)) ;
};

BasePoint.prototype.encode = function encode(enc, compact) {
  return utils.encode(this._encode(compact), enc);
};

BasePoint.prototype.precompute = function precompute(power) {
  if (this.precomputed)
    return this;

  var precomputed = {
    doubles: null,
    naf: null,
    beta: null
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;

  return this;
};

BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
  if (!this.precomputed)
    return false;

  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;

  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
};

BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;

  var doubles = [ this ];
  var acc = this;
  for (var i = 0; i < power; i += step) {
    for (var j = 0; j < step; j++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step: step,
    points: doubles
  };
};

BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;

  var res = [ this ];
  var max = (1 << wnd) - 1;
  var dbl = max === 1 ? null : this.dbl();
  for (var i = 1; i < max; i++)
    res[i] = res[i - 1].add(dbl);
  return {
    wnd: wnd,
    points: res
  };
};

BasePoint.prototype._getBeta = function _getBeta() {
  return null;
};

BasePoint.prototype.dblp = function dblp(k) {
  var r = this;
  for (var i = 0; i < k; i++)
    r = r.dbl();
  return r;
};


/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/curve/edwards.js":
/*!*************************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/curve/edwards.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/elliptic/lib/elliptic/utils.js");
var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
var Base = __webpack_require__(/*! ./base */ "./node_modules/elliptic/lib/elliptic/curve/base.js");

var assert = utils.assert;

function EdwardsCurve(conf) {
  // NOTE: Important as we are creating point in Base.call()
  this.twisted = (conf.a | 0) !== 1;
  this.mOneA = this.twisted && (conf.a | 0) === -1;
  this.extended = this.mOneA;

  Base.call(this, 'edwards', conf);

  this.a = new BN(conf.a, 16).umod(this.red.m);
  this.a = this.a.toRed(this.red);
  this.c = new BN(conf.c, 16).toRed(this.red);
  this.c2 = this.c.redSqr();
  this.d = new BN(conf.d, 16).toRed(this.red);
  this.dd = this.d.redAdd(this.d);

  assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
  this.oneC = (conf.c | 0) === 1;
}
inherits(EdwardsCurve, Base);
module.exports = EdwardsCurve;

EdwardsCurve.prototype._mulA = function _mulA(num) {
  if (this.mOneA)
    return num.redNeg();
  else
    return this.a.redMul(num);
};

EdwardsCurve.prototype._mulC = function _mulC(num) {
  if (this.oneC)
    return num;
  else
    return this.c.redMul(num);
};

// Just for compatibility with Short curve
EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
  return this.point(x, y, z, t);
};

EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var x2 = x.redSqr();
  var rhs = this.c2.redSub(this.a.redMul(x2));
  var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));

  var y2 = rhs.redMul(lhs.redInvm());
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
  y = new BN(y, 16);
  if (!y.red)
    y = y.toRed(this.red);

  // x^2 = (y^2 - c^2) / (c^2 d y^2 - a)
  var y2 = y.redSqr();
  var lhs = y2.redSub(this.c2);
  var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
  var x2 = lhs.redMul(rhs.redInvm());

  if (x2.cmp(this.zero) === 0) {
    if (odd)
      throw new Error('invalid point');
    else
      return this.point(this.zero, y);
  }

  var x = x2.redSqrt();
  if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  if (x.fromRed().isOdd() !== odd)
    x = x.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.validate = function validate(point) {
  if (point.isInfinity())
    return true;

  // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)
  point.normalize();

  var x2 = point.x.redSqr();
  var y2 = point.y.redSqr();
  var lhs = x2.redMul(this.a).redAdd(y2);
  var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));

  return lhs.cmp(rhs) === 0;
};

function Point(curve, x, y, z, t) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && y === null && z === null) {
    this.x = this.curve.zero;
    this.y = this.curve.one;
    this.z = this.curve.one;
    this.t = this.curve.zero;
    this.zOne = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = z ? new BN(z, 16) : this.curve.one;
    this.t = t && new BN(t, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
    if (this.t && !this.t.red)
      this.t = this.t.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;

    // Use extended coordinates
    if (this.curve.extended && !this.t) {
      this.t = this.x.redMul(this.y);
      if (!this.zOne)
        this.t = this.t.redMul(this.z.redInvm());
    }
  }
}
inherits(Point, Base.BasePoint);

EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

EdwardsCurve.prototype.point = function point(x, y, z, t) {
  return new Point(this, x, y, z, t);
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1], obj[2]);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.x.cmpn(0) === 0 &&
    (this.y.cmp(this.z) === 0 ||
    (this.zOne && this.y.cmp(this.curve.c) === 0));
};

Point.prototype._extDbl = function _extDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #doubling-dbl-2008-hwcd
  // 4M + 4S

  // A = X1^2
  var a = this.x.redSqr();
  // B = Y1^2
  var b = this.y.redSqr();
  // C = 2 * Z1^2
  var c = this.z.redSqr();
  c = c.redIAdd(c);
  // D = a * A
  var d = this.curve._mulA(a);
  // E = (X1 + Y1)^2 - A - B
  var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
  // G = D + B
  var g = d.redAdd(b);
  // F = G - C
  var f = g.redSub(c);
  // H = D - B
  var h = d.redSub(b);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projDbl = function _projDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #doubling-dbl-2008-bbjlp
  //     #doubling-dbl-2007-bl
  // and others
  // Generally 3M + 4S or 2M + 4S

  // B = (X1 + Y1)^2
  var b = this.x.redAdd(this.y).redSqr();
  // C = X1^2
  var c = this.x.redSqr();
  // D = Y1^2
  var d = this.y.redSqr();

  var nx;
  var ny;
  var nz;
  if (this.curve.twisted) {
    // E = a * C
    var e = this.curve._mulA(c);
    // F = E + D
    var f = e.redAdd(d);
    if (this.zOne) {
      // X3 = (B - C - D) * (F - 2)
      nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F^2 - 2 * F
      nz = f.redSqr().redSub(f).redSub(f);
    } else {
      // H = Z1^2
      var h = this.z.redSqr();
      // J = F - 2 * H
      var j = f.redSub(h).redISub(h);
      // X3 = (B-C-D)*J
      nx = b.redSub(c).redISub(d).redMul(j);
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F * J
      nz = f.redMul(j);
    }
  } else {
    // E = C + D
    var e = c.redAdd(d);
    // H = (c * Z1)^2
    var h = this.curve._mulC(this.z).redSqr();
    // J = E - 2 * H
    var j = e.redSub(h).redSub(h);
    // X3 = c * (B - E) * J
    nx = this.curve._mulC(b.redISub(e)).redMul(j);
    // Y3 = c * E * (C - D)
    ny = this.curve._mulC(e).redMul(c.redISub(d));
    // Z3 = E * J
    nz = e.redMul(j);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  // Double in extended coordinates
  if (this.curve.extended)
    return this._extDbl();
  else
    return this._projDbl();
};

Point.prototype._extAdd = function _extAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #addition-add-2008-hwcd-3
  // 8M

  // A = (Y1 - X1) * (Y2 - X2)
  var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
  // B = (Y1 + X1) * (Y2 + X2)
  var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
  // C = T1 * k * T2
  var c = this.t.redMul(this.curve.dd).redMul(p.t);
  // D = Z1 * 2 * Z2
  var d = this.z.redMul(p.z.redAdd(p.z));
  // E = B - A
  var e = b.redSub(a);
  // F = D - C
  var f = d.redSub(c);
  // G = D + C
  var g = d.redAdd(c);
  // H = B + A
  var h = b.redAdd(a);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projAdd = function _projAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #addition-add-2008-bbjlp
  //     #addition-add-2007-bl
  // 10M + 1S

  // A = Z1 * Z2
  var a = this.z.redMul(p.z);
  // B = A^2
  var b = a.redSqr();
  // C = X1 * X2
  var c = this.x.redMul(p.x);
  // D = Y1 * Y2
  var d = this.y.redMul(p.y);
  // E = d * C * D
  var e = this.curve.d.redMul(c).redMul(d);
  // F = B - E
  var f = b.redSub(e);
  // G = B + E
  var g = b.redAdd(e);
  // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)
  var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
  var nx = a.redMul(f).redMul(tmp);
  var ny;
  var nz;
  if (this.curve.twisted) {
    // Y3 = A * G * (D - a * C)
    ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
    // Z3 = F * G
    nz = f.redMul(g);
  } else {
    // Y3 = A * G * (D - C)
    ny = a.redMul(g).redMul(d.redSub(c));
    // Z3 = c * F * G
    nz = this.curve._mulC(f).redMul(g);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.add = function add(p) {
  if (this.isInfinity())
    return p;
  if (p.isInfinity())
    return this;

  if (this.curve.extended)
    return this._extAdd(p);
  else
    return this._projAdd(p);
};

Point.prototype.mul = function mul(k) {
  if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, false);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, true);
};

Point.prototype.normalize = function normalize() {
  if (this.zOne)
    return this;

  // Normalize coordinates
  var zi = this.z.redInvm();
  this.x = this.x.redMul(zi);
  this.y = this.y.redMul(zi);
  if (this.t)
    this.t = this.t.redMul(zi);
  this.z = this.curve.one;
  this.zOne = true;
  return this;
};

Point.prototype.neg = function neg() {
  return this.curve.point(this.x.redNeg(),
                          this.y,
                          this.z,
                          this.t && this.t.redNeg());
};

Point.prototype.getX = function getX() {
  this.normalize();
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  this.normalize();
  return this.y.fromRed();
};

Point.prototype.eq = function eq(other) {
  return this === other ||
         this.getX().cmp(other.getX()) === 0 &&
         this.getY().cmp(other.getY()) === 0;
};

Point.prototype.eqXToP = function eqXToP(x) {
  var rx = x.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(this.z);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};

// Compatibility with BaseCurve
Point.prototype.toP = Point.prototype.normalize;
Point.prototype.mixedAdd = Point.prototype.add;


/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/curve/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/curve/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var curve = exports;

curve.base = __webpack_require__(/*! ./base */ "./node_modules/elliptic/lib/elliptic/curve/base.js");
curve.short = __webpack_require__(/*! ./short */ "./node_modules/elliptic/lib/elliptic/curve/short.js");
curve.mont = __webpack_require__(/*! ./mont */ "./node_modules/elliptic/lib/elliptic/curve/mont.js");
curve.edwards = __webpack_require__(/*! ./edwards */ "./node_modules/elliptic/lib/elliptic/curve/edwards.js");


/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/curve/mont.js":
/*!**********************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/curve/mont.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
var Base = __webpack_require__(/*! ./base */ "./node_modules/elliptic/lib/elliptic/curve/base.js");

var utils = __webpack_require__(/*! ../utils */ "./node_modules/elliptic/lib/elliptic/utils.js");

function MontCurve(conf) {
  Base.call(this, 'mont', conf);

  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.i4 = new BN(4).toRed(this.red).redInvm();
  this.two = new BN(2).toRed(this.red);
  this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits(MontCurve, Base);
module.exports = MontCurve;

MontCurve.prototype.validate = function validate(point) {
  var x = point.normalize().x;
  var x2 = x.redSqr();
  var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
  var y = rhs.redSqrt();

  return y.redSqr().cmp(rhs) === 0;
};

function Point(curve, x, z) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && z === null) {
    this.x = this.curve.one;
    this.z = this.curve.zero;
  } else {
    this.x = new BN(x, 16);
    this.z = new BN(z, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
  }
}
inherits(Point, Base.BasePoint);

MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  return this.point(utils.toArray(bytes, enc), 1);
};

MontCurve.prototype.point = function point(x, z) {
  return new Point(this, x, z);
};

MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

Point.prototype.precompute = function precompute() {
  // No-op
};

Point.prototype._encode = function _encode() {
  return this.getX().toArray('be', this.curve.p.byteLength());
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1] || curve.one);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

Point.prototype.dbl = function dbl() {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
  // 2M + 2S + 4A

  // A = X1 + Z1
  var a = this.x.redAdd(this.z);
  // AA = A^2
  var aa = a.redSqr();
  // B = X1 - Z1
  var b = this.x.redSub(this.z);
  // BB = B^2
  var bb = b.redSqr();
  // C = AA - BB
  var c = aa.redSub(bb);
  // X3 = AA * BB
  var nx = aa.redMul(bb);
  // Z3 = C * (BB + A24 * C)
  var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
  return this.curve.point(nx, nz);
};

Point.prototype.add = function add() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.diffAdd = function diffAdd(p, diff) {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
  // 4M + 2S + 6A

  // A = X2 + Z2
  var a = this.x.redAdd(this.z);
  // B = X2 - Z2
  var b = this.x.redSub(this.z);
  // C = X3 + Z3
  var c = p.x.redAdd(p.z);
  // D = X3 - Z3
  var d = p.x.redSub(p.z);
  // DA = D * A
  var da = d.redMul(a);
  // CB = C * B
  var cb = c.redMul(b);
  // X5 = Z1 * (DA + CB)^2
  var nx = diff.z.redMul(da.redAdd(cb).redSqr());
  // Z5 = X1 * (DA - CB)^2
  var nz = diff.x.redMul(da.redISub(cb).redSqr());
  return this.curve.point(nx, nz);
};

Point.prototype.mul = function mul(k) {
  var t = k.clone();
  var a = this; // (N / 2) * Q + Q
  var b = this.curve.point(null, null); // (N / 2) * Q
  var c = this; // Q

  for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
    bits.push(t.andln(1));

  for (var i = bits.length - 1; i >= 0; i--) {
    if (bits[i] === 0) {
      // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
      a = a.diffAdd(b, c);
      // N * Q = 2 * ((N / 2) * Q + Q))
      b = b.dbl();
    } else {
      // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
      b = a.diffAdd(b, c);
      // N * Q + Q = 2 * ((N / 2) * Q + Q)
      a = a.dbl();
    }
  }
  return b;
};

Point.prototype.mulAdd = function mulAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.jumlAdd = function jumlAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.eq = function eq(other) {
  return this.getX().cmp(other.getX()) === 0;
};

Point.prototype.normalize = function normalize() {
  this.x = this.x.redMul(this.z.redInvm());
  this.z = this.curve.one;
  return this;
};

Point.prototype.getX = function getX() {
  // Normalize coordinates
  this.normalize();

  return this.x.fromRed();
};


/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/curve/short.js":
/*!***********************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/curve/short.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/elliptic/lib/elliptic/utils.js");
var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
var Base = __webpack_require__(/*! ./base */ "./node_modules/elliptic/lib/elliptic/curve/base.js");

var assert = utils.assert;

function ShortCurve(conf) {
  Base.call(this, 'short', conf);

  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();

  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;

  // If the curve is endomorphic, precalculate beta and lambda
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits(ShortCurve, Base);
module.exports = ShortCurve;

ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
  // No efficient endomorphism
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;

  // Compute beta and lambda, that lambda * P = (beta * Px; Py)
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new BN(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    // Choose the smallest beta
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new BN(conf.lambda, 16);
  } else {
    // Choose the lambda that is matching selected beta
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }

  // Get basis vectors, used for balanced length-two representation
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new BN(vec.a, 16),
        b: new BN(vec.b, 16)
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }

  return {
    beta: beta,
    lambda: lambda,
    basis: basis
  };
};

ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
  // Find roots of for x^2 + x + 1 in F
  // Root = (-1 +- Sqrt(-3)) / 2
  //
  var red = num === this.p ? this.red : BN.mont(num);
  var tinv = new BN(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();

  var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);

  var l1 = ntinv.redAdd(s).fromRed();
  var l2 = ntinv.redSub(s).fromRed();
  return [ l1, l2 ];
};

ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  // aprxSqrt >= sqrt(this.n)
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));

  // 3.74
  // Run EGCD, until r(L + 1) < aprxSqrt
  var u = lambda;
  var v = this.n.clone();
  var x1 = new BN(1);
  var y1 = new BN(0);
  var x2 = new BN(0);
  var y2 = new BN(1);

  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
  var a0;
  var b0;
  // First vector
  var a1;
  var b1;
  // Second vector
  var a2;
  var b2;

  var prevR;
  var i = 0;
  var r;
  var x;
  while (u.cmpn(0) !== 0) {
    var q = v.div(u);
    r = v.sub(q.mul(u));
    x = x2.sub(q.mul(x1));
    var y = y2.sub(q.mul(y1));

    if (!a1 && r.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r.neg();
      b1 = x;
    } else if (a1 && ++i === 2) {
      break;
    }
    prevR = r;

    v = u;
    u = r;
    x2 = x1;
    x1 = x;
    y2 = y1;
    y1 = y;
  }
  a2 = r.neg();
  b2 = x;

  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }

  // Normalize signs
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }

  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 }
  ];
};

ShortCurve.prototype._endoSplit = function _endoSplit(k) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];

  var c1 = v2.b.mul(k).divRound(this.n);
  var c2 = v1.b.neg().mul(k).divRound(this.n);

  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);

  // Calculate answer
  var k1 = k.sub(p1).sub(p2);
  var k2 = q1.add(q2).neg();
  return { k1: k1, k2: k2 };
};

ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  // XXX Is there any way to tell if the number is odd without converting it
  // to non-red form?
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

ShortCurve.prototype.validate = function validate(point) {
  if (point.inf)
    return true;

  var x = point.x;
  var y = point.y;

  var ax = this.a.redMul(x);
  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
  return y.redSqr().redISub(rhs).cmpn(0) === 0;
};

ShortCurve.prototype._endoWnafMulAdd =
    function _endoWnafMulAdd(points, coeffs, jacobianResult) {
  var npoints = this._endoWnafT1;
  var ncoeffs = this._endoWnafT2;
  for (var i = 0; i < points.length; i++) {
    var split = this._endoSplit(coeffs[i]);
    var p = points[i];
    var beta = p._getBeta();

    if (split.k1.negative) {
      split.k1.ineg();
      p = p.neg(true);
    }
    if (split.k2.negative) {
      split.k2.ineg();
      beta = beta.neg(true);
    }

    npoints[i * 2] = p;
    npoints[i * 2 + 1] = beta;
    ncoeffs[i * 2] = split.k1;
    ncoeffs[i * 2 + 1] = split.k2;
  }
  var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);

  // Clean-up references to points and coefficients
  for (var j = 0; j < i * 2; j++) {
    npoints[j] = null;
    ncoeffs[j] = null;
  }
  return res;
};

function Point(curve, x, y, isRed) {
  Base.BasePoint.call(this, curve, 'affine');
  if (x === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    // Force redgomery representation when loading from JSON
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits(Point, Base.BasePoint);

ShortCurve.prototype.point = function point(x, y, isRed) {
  return new Point(this, x, y, isRed);
};

ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
  return Point.fromJSON(this, obj, red);
};

Point.prototype._getBeta = function _getBeta() {
  if (!this.curve.endo)
    return;

  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;

  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = function(p) {
      return curve.point(p.x.redMul(curve.endo.beta), p.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul)
      }
    };
  }
  return beta;
};

Point.prototype.toJSON = function toJSON() {
  if (!this.precomputed)
    return [ this.x, this.y ];

  return [ this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  } ];
};

Point.fromJSON = function fromJSON(curve, obj, red) {
  if (typeof obj === 'string')
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;

  function obj2point(obj) {
    return curve.point(obj[0], obj[1], red);
  }

  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [ res ].concat(pre.doubles.points.map(obj2point))
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [ res ].concat(pre.naf.points.map(obj2point))
    }
  };
  return res;
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  return this.inf;
};

Point.prototype.add = function add(p) {
  // O + P = P
  if (this.inf)
    return p;

  // P + O = P
  if (p.inf)
    return this;

  // P + P = 2P
  if (this.eq(p))
    return this.dbl();

  // P + (-P) = O
  if (this.neg().eq(p))
    return this.curve.point(null, null);

  // P + Q = O
  if (this.x.cmp(p.x) === 0)
    return this.curve.point(null, null);

  var c = this.y.redSub(p.y);
  if (c.cmpn(0) !== 0)
    c = c.redMul(this.x.redSub(p.x).redInvm());
  var nx = c.redSqr().redISub(this.x).redISub(p.x);
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.dbl = function dbl() {
  if (this.inf)
    return this;

  // 2P = O
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);

  var a = this.curve.a;

  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);

  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.getX = function getX() {
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  return this.y.fromRed();
};

Point.prototype.mul = function mul(k) {
  k = new BN(k, 16);
  if (this.isInfinity())
    return this;
  else if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([ this ], [ k ]);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};

Point.prototype.eq = function eq(p) {
  return this === p ||
         this.inf === p.inf &&
             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
};

Point.prototype.neg = function neg(_precompute) {
  if (this.inf)
    return this;

  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p) {
      return p.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate)
      }
    };
  }
  return res;
};

Point.prototype.toJ = function toJ() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);

  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};

function JPoint(curve, x, y, z) {
  Base.BasePoint.call(this, curve, 'jacobian');
  if (x === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new BN(0);
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = new BN(z, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);

  this.zOne = this.z === this.curve.one;
}
inherits(JPoint, Base.BasePoint);

ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
  return new JPoint(this, x, y, z);
};

JPoint.prototype.toP = function toP() {
  if (this.isInfinity())
    return this.curve.point(null, null);

  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);

  return this.curve.point(ax, ay);
};

JPoint.prototype.neg = function neg() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};

JPoint.prototype.add = function add(p) {
  // O + P = P
  if (this.isInfinity())
    return p;

  // P + O = P
  if (p.isInfinity())
    return this;

  // 12M + 4S + 7A
  var pz2 = p.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p.z));
  var s2 = p.y.redMul(z2.redMul(this.z));

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p.z).redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mixedAdd = function mixedAdd(p) {
  // O + P = P
  if (this.isInfinity())
    return p.toJ();

  // P + O = P
  if (p.isInfinity())
    return this;

  // 8M + 3S + 7A
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p.x.redMul(z2);
  var s1 = this.y;
  var s2 = p.y.redMul(z2).redMul(this.z);

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.dblp = function dblp(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();

  if (this.curve.zeroA || this.curve.threeA) {
    var r = this;
    for (var i = 0; i < pow; i++)
      r = r.dbl();
    return r;
  }

  // 1M + 2S + 1A + N * (4S + 5M + 8A)
  // N = 1 => 6M + 6S + 9A
  var a = this.curve.a;
  var tinv = this.curve.tinv;

  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  // Reuse results
  var jyd = jy.redAdd(jy);
  for (var i = 0; i < pow; i++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

    var t1 = jx.redMul(jyd2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i + 1 < pow)
      jz4 = jz4.redMul(jyd4);

    jx = nx;
    jz = nz;
    jyd = dny;
  }

  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};

JPoint.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};

JPoint.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 14A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a; a = 0
    var m = xx.redAdd(xx).redIAdd(xx);
    // T = M ^ 2 - 2*S
    var t = m.redSqr().redISub(s).redISub(s);

    // 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);

    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2*Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-dbl-2009-l
    // 2M + 5S + 13A

    // A = X1^2
    var a = this.x.redSqr();
    // B = Y1^2
    var b = this.y.redSqr();
    // C = B^2
    var c = b.redSqr();
    // D = 2 * ((X1 + B)^2 - A - C)
    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
    d = d.redIAdd(d);
    // E = 3 * A
    var e = a.redAdd(a).redIAdd(a);
    // F = E^2
    var f = e.redSqr();

    // 8 * C
    var c8 = c.redIAdd(c);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);

    // X3 = F - 2 * D
    nx = f.redISub(d).redISub(d);
    // Y3 = E * (D - X3) - 8 * C
    ny = e.redMul(d.redISub(nx)).redISub(c8);
    // Z3 = 2 * Y1 * Z1
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 15A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a
    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    // T = M^2 - 2 * S
    var t = m.redSqr().redISub(s).redISub(s);
    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2 * Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
    // 3M + 5S

    // delta = Z1^2
    var delta = this.z.redSqr();
    // gamma = Y1^2
    var gamma = this.y.redSqr();
    // beta = X1 * gamma
    var beta = this.x.redMul(gamma);
    // alpha = 3 * (X1 - delta) * (X1 + delta)
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    // X3 = alpha^2 - 8 * beta
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    // Z3 = (Y1 + Z1)^2 - gamma - delta
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._dbl = function _dbl() {
  var a = this.curve.a;

  // 4M + 6S + 10A
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();

  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);

  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.trpl = function trpl() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);

  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
  // 5M + 10S + ...

  // XX = X1^2
  var xx = this.x.redSqr();
  // YY = Y1^2
  var yy = this.y.redSqr();
  // ZZ = Z1^2
  var zz = this.z.redSqr();
  // YYYY = YY^2
  var yyyy = yy.redSqr();
  // M = 3 * XX + a * ZZ2; a = 0
  var m = xx.redAdd(xx).redIAdd(xx);
  // MM = M^2
  var mm = m.redSqr();
  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e = e.redIAdd(e);
  e = e.redAdd(e).redIAdd(e);
  e = e.redISub(mm);
  // EE = E^2
  var ee = e.redSqr();
  // T = 16*YYYY
  var t = yyyy.redIAdd(yyyy);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  // U = (M + E)^2 - MM - EE - T
  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
  // X3 = 4 * (X1 * EE - 4 * YY * U)
  var yyu4 = yy.redMul(u);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  // Z3 = (Z1 + E)^2 - ZZ - EE
  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mul = function mul(k, kbase) {
  k = new BN(k, kbase);

  return this.curve._wnafMul(this, k);
};

JPoint.prototype.eq = function eq(p) {
  if (p.type === 'affine')
    return this.eq(p.toJ());

  if (this === p)
    return true;

  // x1 * z2^2 == x2 * z1^2
  var z2 = this.z.redSqr();
  var pz2 = p.z.redSqr();
  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
    return false;

  // y1 * z2^3 == y2 * z1^3
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p.z);
  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
};

JPoint.prototype.eqXToP = function eqXToP(x) {
  var zs = this.z.redSqr();
  var rx = x.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(zs);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};

JPoint.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC JPoint Infinity>';
  return '<EC JPoint x: ' + this.x.toString(16, 2) +
      ' y: ' + this.y.toString(16, 2) +
      ' z: ' + this.z.toString(16, 2) + '>';
};

JPoint.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};


/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/curves.js":
/*!******************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/curves.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var curves = exports;

var hash = __webpack_require__(/*! hash.js */ "./node_modules/hash.js/lib/hash.js");
var curve = __webpack_require__(/*! ./curve */ "./node_modules/elliptic/lib/elliptic/curve/index.js");
var utils = __webpack_require__(/*! ./utils */ "./node_modules/elliptic/lib/elliptic/utils.js");

var assert = utils.assert;

function PresetCurve(options) {
  if (options.type === 'short')
    this.curve = new curve.short(options);
  else if (options.type === 'edwards')
    this.curve = new curve.edwards(options);
  else
    this.curve = new curve.mont(options);
  this.g = this.curve.g;
  this.n = this.curve.n;
  this.hash = options.hash;

  assert(this.g.validate(), 'Invalid curve');
  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
}
curves.PresetCurve = PresetCurve;

function defineCurve(name, options) {
  Object.defineProperty(curves, name, {
    configurable: true,
    enumerable: true,
    get: function() {
      var curve = new PresetCurve(options);
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        value: curve
      });
      return curve;
    }
  });
}

defineCurve('p192', {
  type: 'short',
  prime: 'p192',
  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
  hash: hash.sha256,
  gRed: false,
  g: [
    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811'
  ]
});

defineCurve('p224', {
  type: 'short',
  prime: 'p224',
  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
  hash: hash.sha256,
  gRed: false,
  g: [
    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34'
  ]
});

defineCurve('p256', {
  type: 'short',
  prime: null,
  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
  hash: hash.sha256,
  gRed: false,
  g: [
    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5'
  ]
});

defineCurve('p384', {
  type: 'short',
  prime: null,
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 ffffffff',
  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 fffffffc',
  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +
     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +
     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
  hash: hash.sha384,
  gRed: false,
  g: [
    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +
    '5502f25d bf55296c 3a545e38 72760ab7',
    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +
    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f'
  ]
});

defineCurve('p521', {
  type: 'short',
  prime: null,
  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff',
  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff fffffffc',
  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +
     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +
     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +
     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
  hash: hash.sha512,
  gRed: false,
  g: [
    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +
    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +
    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',
    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +
    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +
    '3fad0761 353c7086 a272c240 88be9476 9fd16650'
  ]
});

defineCurve('curve25519', {
  type: 'mont',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '76d06',
  b: '1',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '9'
  ]
});

defineCurve('ed25519', {
  type: 'edwards',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '-1',
  c: '1',
  // -121665 * (121666^(-1)) (mod P)
  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',

    // 4/5
    '6666666666666666666666666666666666666666666666666666666666666658'
  ]
});

var pre;
try {
  pre = __webpack_require__(/*! ./precomputed/secp256k1 */ "./node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js");
} catch (e) {
  pre = undefined;
}

defineCurve('secp256k1', {
  type: 'short',
  prime: 'k256',
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
  a: '0',
  b: '7',
  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
  h: '1',
  hash: hash.sha256,

  // Precomputed endomorphism
  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
  basis: [
    {
      a: '3086d221a7d46bcde86c90e49284eb15',
      b: '-e4437ed6010e88286f547fa90abfe4c3'
    },
    {
      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
      b: '3086d221a7d46bcde86c90e49284eb15'
    }
  ],

  gRed: false,
  g: [
    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
    pre
  ]
});


/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/ec/index.js":
/*!********************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/ec/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");
var HmacDRBG = __webpack_require__(/*! hmac-drbg */ "./node_modules/hmac-drbg/lib/hmac-drbg.js");
var utils = __webpack_require__(/*! ../utils */ "./node_modules/elliptic/lib/elliptic/utils.js");
var curves = __webpack_require__(/*! ../curves */ "./node_modules/elliptic/lib/elliptic/curves.js");
var rand = __webpack_require__(/*! brorand */ "./node_modules/brorand/index.js");
var assert = utils.assert;

var KeyPair = __webpack_require__(/*! ./key */ "./node_modules/elliptic/lib/elliptic/ec/key.js");
var Signature = __webpack_require__(/*! ./signature */ "./node_modules/elliptic/lib/elliptic/ec/signature.js");

function EC(options) {
  if (!(this instanceof EC))
    return new EC(options);

  // Shortcut `elliptic.ec(curve-name)`
  if (typeof options === 'string') {
    assert(curves.hasOwnProperty(options), 'Unknown curve ' + options);

    options = curves[options];
  }

  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
  if (options instanceof curves.PresetCurve)
    options = { curve: options };

  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;

  // Point on curve
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);

  // Hash for function for DRBG
  this.hash = options.hash || options.curve.hash;
}
module.exports = EC;

EC.prototype.keyPair = function keyPair(options) {
  return new KeyPair(this, options);
};

EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
  return KeyPair.fromPrivate(this, priv, enc);
};

EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
  return KeyPair.fromPublic(this, pub, enc);
};

EC.prototype.genKeyPair = function genKeyPair(options) {
  if (!options)
    options = {};

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8',
    entropy: options.entropy || rand(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || 'utf8',
    nonce: this.n.toArray()
  });

  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new BN(2));
  do {
    var priv = new BN(drbg.generate(bytes));
    if (priv.cmp(ns2) > 0)
      continue;

    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  } while (true);
};

EC.prototype._truncateToN = function truncateToN(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};

EC.prototype.sign = function sign(msg, key, enc, options) {
  if (typeof enc === 'object') {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};

  key = this.keyFromPrivate(key, enc);
  msg = this._truncateToN(new BN(msg, 16));

  // Zero-extend key to provide enough entropy
  var bytes = this.n.byteLength();
  var bkey = key.getPrivate().toArray('be', bytes);

  // Zero-extend nonce to have the same byte size as N
  var nonce = msg.toArray('be', bytes);

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    entropy: bkey,
    nonce: nonce,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8'
  });

  // Number of bytes to generate
  var ns1 = this.n.sub(new BN(1));

  for (var iter = 0; true; iter++) {
    var k = options.k ?
        options.k(iter) :
        new BN(drbg.generate(this.n.byteLength()));
    k = this._truncateToN(k, true);
    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
      continue;

    var kp = this.g.mul(k);
    if (kp.isInfinity())
      continue;

    var kpX = kp.getX();
    var r = kpX.umod(this.n);
    if (r.cmpn(0) === 0)
      continue;

    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
    s = s.umod(this.n);
    if (s.cmpn(0) === 0)
      continue;

    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |
                        (kpX.cmp(r) !== 0 ? 2 : 0);

    // Use complement of `s`, if it is > `n / 2`
    if (options.canonical && s.cmp(this.nh) > 0) {
      s = this.n.sub(s);
      recoveryParam ^= 1;
    }

    return new Signature({ r: r, s: s, recoveryParam: recoveryParam });
  }
};

EC.prototype.verify = function verify(msg, signature, key, enc) {
  msg = this._truncateToN(new BN(msg, 16));
  key = this.keyFromPublic(key, enc);
  signature = new Signature(signature, 'hex');

  // Perform primitive values validation
  var r = signature.r;
  var s = signature.s;
  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
    return false;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
    return false;

  // Validate signature
  var sinv = s.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r).umod(this.n);

  if (!this.curve._maxwellTrick) {
    var p = this.g.mulAdd(u1, key.getPublic(), u2);
    if (p.isInfinity())
      return false;

    return p.getX().umod(this.n).cmp(r) === 0;
  }

  // NOTE: Greg Maxwell's trick, inspired by:
  // https://git.io/vad3K

  var p = this.g.jmulAdd(u1, key.getPublic(), u2);
  if (p.isInfinity())
    return false;

  // Compare `p.x` of Jacobian point with `r`,
  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the
  // inverse of `p.z^2`
  return p.eqXToP(r);
};

EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
  assert((3 & j) === j, 'The recovery param is more than two bits');
  signature = new Signature(signature, enc);

  var n = this.n;
  var e = new BN(msg);
  var r = signature.r;
  var s = signature.s;

  // A set LSB signifies that the y-coordinate is odd
  var isYOdd = j & 1;
  var isSecondKey = j >> 1;
  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error('Unable to find sencond key candinate');

  // 1.1. Let x = r + jn.
  if (isSecondKey)
    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
  else
    r = this.curve.pointFromX(r, isYOdd);

  var rInv = signature.r.invm(n);
  var s1 = n.sub(e).mul(rInv).umod(n);
  var s2 = s.mul(rInv).umod(n);

  // 1.6.1 Compute Q = r^-1 (sR -  eG)
  //               Q = r^-1 (sR + -eG)
  return this.g.mulAdd(s1, r, s2);
};

EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
  signature = new Signature(signature, enc);
  if (signature.recoveryParam !== null)
    return signature.recoveryParam;

  for (var i = 0; i < 4; i++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e, signature, i);
    } catch (e) {
      continue;
    }

    if (Qprime.eq(Q))
      return i;
  }
  throw new Error('Unable to find valid recovery factor');
};


/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/ec/key.js":
/*!******************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/ec/key.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");
var utils = __webpack_require__(/*! ../utils */ "./node_modules/elliptic/lib/elliptic/utils.js");
var assert = utils.assert;

function KeyPair(ec, options) {
  this.ec = ec;
  this.priv = null;
  this.pub = null;

  // KeyPair(ec, { priv: ..., pub: ... })
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
module.exports = KeyPair;

KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
  if (pub instanceof KeyPair)
    return pub;

  return new KeyPair(ec, {
    pub: pub,
    pubEnc: enc
  });
};

KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
  if (priv instanceof KeyPair)
    return priv;

  return new KeyPair(ec, {
    priv: priv,
    privEnc: enc
  });
};

KeyPair.prototype.validate = function validate() {
  var pub = this.getPublic();

  if (pub.isInfinity())
    return { result: false, reason: 'Invalid public key' };
  if (!pub.validate())
    return { result: false, reason: 'Public key is not a point' };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: 'Public key * N != O' };

  return { result: true, reason: null };
};

KeyPair.prototype.getPublic = function getPublic(compact, enc) {
  // compact is optional argument
  if (typeof compact === 'string') {
    enc = compact;
    compact = null;
  }

  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);

  if (!enc)
    return this.pub;

  return this.pub.encode(enc, compact);
};

KeyPair.prototype.getPrivate = function getPrivate(enc) {
  if (enc === 'hex')
    return this.priv.toString(16, 2);
  else
    return this.priv;
};

KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
  this.priv = new BN(key, enc || 16);

  // Ensure that the priv won't be bigger than n, otherwise we may fail
  // in fixed multiplication method
  this.priv = this.priv.umod(this.ec.curve.n);
};

KeyPair.prototype._importPublic = function _importPublic(key, enc) {
  if (key.x || key.y) {
    // Montgomery points only have an `x` coordinate.
    // Weierstrass/Edwards points on the other hand have both `x` and
    // `y` coordinates.
    if (this.ec.curve.type === 'mont') {
      assert(key.x, 'Need x coordinate');
    } else if (this.ec.curve.type === 'short' ||
               this.ec.curve.type === 'edwards') {
      assert(key.x && key.y, 'Need both x and y coordinate');
    }
    this.pub = this.ec.curve.point(key.x, key.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key, enc);
};

// ECDH
KeyPair.prototype.derive = function derive(pub) {
  return pub.mul(this.priv).getX();
};

// ECDSA
KeyPair.prototype.sign = function sign(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};

KeyPair.prototype.verify = function verify(msg, signature) {
  return this.ec.verify(msg, signature, this);
};

KeyPair.prototype.inspect = function inspect() {
  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +
         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
};


/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/ec/signature.js":
/*!************************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/ec/signature.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");

var utils = __webpack_require__(/*! ../utils */ "./node_modules/elliptic/lib/elliptic/utils.js");
var assert = utils.assert;

function Signature(options, enc) {
  if (options instanceof Signature)
    return options;

  if (this._importDER(options, enc))
    return;

  assert(options.r && options.s, 'Signature without r or s');
  this.r = new BN(options.r, 16);
  this.s = new BN(options.s, 16);
  if (options.recoveryParam === undefined)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
module.exports = Signature;

function Position() {
  this.place = 0;
}

function getLength(buf, p) {
  var initial = buf[p.place++];
  if (!(initial & 0x80)) {
    return initial;
  }
  var octetLen = initial & 0xf;
  var val = 0;
  for (var i = 0, off = p.place; i < octetLen; i++, off++) {
    val <<= 8;
    val |= buf[off];
  }
  p.place = off;
  return val;
}

function rmPadding(buf) {
  var i = 0;
  var len = buf.length - 1;
  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {
    i++;
  }
  if (i === 0) {
    return buf;
  }
  return buf.slice(i);
}

Signature.prototype._importDER = function _importDER(data, enc) {
  data = utils.toArray(data, enc);
  var p = new Position();
  if (data[p.place++] !== 0x30) {
    return false;
  }
  var len = getLength(data, p);
  if ((len + p.place) !== data.length) {
    return false;
  }
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var rlen = getLength(data, p);
  var r = data.slice(p.place, rlen + p.place);
  p.place += rlen;
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var slen = getLength(data, p);
  if (data.length !== slen + p.place) {
    return false;
  }
  var s = data.slice(p.place, slen + p.place);
  if (r[0] === 0 && (r[1] & 0x80)) {
    r = r.slice(1);
  }
  if (s[0] === 0 && (s[1] & 0x80)) {
    s = s.slice(1);
  }

  this.r = new BN(r);
  this.s = new BN(s);
  this.recoveryParam = null;

  return true;
};

function constructLength(arr, len) {
  if (len < 0x80) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 0x80);
  while (--octets) {
    arr.push((len >>> (octets << 3)) & 0xff);
  }
  arr.push(len);
}

Signature.prototype.toDER = function toDER(enc) {
  var r = this.r.toArray();
  var s = this.s.toArray();

  // Pad values
  if (r[0] & 0x80)
    r = [ 0 ].concat(r);
  // Pad values
  if (s[0] & 0x80)
    s = [ 0 ].concat(s);

  r = rmPadding(r);
  s = rmPadding(s);

  while (!s[0] && !(s[1] & 0x80)) {
    s = s.slice(1);
  }
  var arr = [ 0x02 ];
  constructLength(arr, r.length);
  arr = arr.concat(r);
  arr.push(0x02);
  constructLength(arr, s.length);
  var backHalf = arr.concat(s);
  var res = [ 0x30 ];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils.encode(res, enc);
};


/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/eddsa/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/eddsa/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var hash = __webpack_require__(/*! hash.js */ "./node_modules/hash.js/lib/hash.js");
var curves = __webpack_require__(/*! ../curves */ "./node_modules/elliptic/lib/elliptic/curves.js");
var utils = __webpack_require__(/*! ../utils */ "./node_modules/elliptic/lib/elliptic/utils.js");
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var KeyPair = __webpack_require__(/*! ./key */ "./node_modules/elliptic/lib/elliptic/eddsa/key.js");
var Signature = __webpack_require__(/*! ./signature */ "./node_modules/elliptic/lib/elliptic/eddsa/signature.js");

function EDDSA(curve) {
  assert(curve === 'ed25519', 'only tested with ed25519 so far');

  if (!(this instanceof EDDSA))
    return new EDDSA(curve);

  var curve = curves[curve].curve;
  this.curve = curve;
  this.g = curve.g;
  this.g.precompute(curve.n.bitLength() + 1);

  this.pointClass = curve.point().constructor;
  this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
  this.hash = hash.sha512;
}

module.exports = EDDSA;

/**
* @param {Array|String} message - message bytes
* @param {Array|String|KeyPair} secret - secret bytes or a keypair
* @returns {Signature} - signature
*/
EDDSA.prototype.sign = function sign(message, secret) {
  message = parseBytes(message);
  var key = this.keyFromSecret(secret);
  var r = this.hashInt(key.messagePrefix(), message);
  var R = this.g.mul(r);
  var Rencoded = this.encodePoint(R);
  var s_ = this.hashInt(Rencoded, key.pubBytes(), message)
               .mul(key.priv());
  var S = r.add(s_).umod(this.curve.n);
  return this.makeSignature({ R: R, S: S, Rencoded: Rencoded });
};

/**
* @param {Array} message - message bytes
* @param {Array|String|Signature} sig - sig bytes
* @param {Array|String|Point|KeyPair} pub - public key
* @returns {Boolean} - true if public key matches sig of message
*/
EDDSA.prototype.verify = function verify(message, sig, pub) {
  message = parseBytes(message);
  sig = this.makeSignature(sig);
  var key = this.keyFromPublic(pub);
  var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
  var SG = this.g.mul(sig.S());
  var RplusAh = sig.R().add(key.pub().mul(h));
  return RplusAh.eq(SG);
};

EDDSA.prototype.hashInt = function hashInt() {
  var hash = this.hash();
  for (var i = 0; i < arguments.length; i++)
    hash.update(arguments[i]);
  return utils.intFromLE(hash.digest()).umod(this.curve.n);
};

EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
  return KeyPair.fromPublic(this, pub);
};

EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
  return KeyPair.fromSecret(this, secret);
};

EDDSA.prototype.makeSignature = function makeSignature(sig) {
  if (sig instanceof Signature)
    return sig;
  return new Signature(this, sig);
};

/**
* * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2
*
* EDDSA defines methods for encoding and decoding points and integers. These are
* helper convenience methods, that pass along to utility functions implied
* parameters.
*
*/
EDDSA.prototype.encodePoint = function encodePoint(point) {
  var enc = point.getY().toArray('le', this.encodingLength);
  enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;
  return enc;
};

EDDSA.prototype.decodePoint = function decodePoint(bytes) {
  bytes = utils.parseBytes(bytes);

  var lastIx = bytes.length - 1;
  var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);
  var xIsOdd = (bytes[lastIx] & 0x80) !== 0;

  var y = utils.intFromLE(normed);
  return this.curve.pointFromY(y, xIsOdd);
};

EDDSA.prototype.encodeInt = function encodeInt(num) {
  return num.toArray('le', this.encodingLength);
};

EDDSA.prototype.decodeInt = function decodeInt(bytes) {
  return utils.intFromLE(bytes);
};

EDDSA.prototype.isPoint = function isPoint(val) {
  return val instanceof this.pointClass;
};


/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/eddsa/key.js":
/*!*********************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/eddsa/key.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/elliptic/lib/elliptic/utils.js");
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var cachedProperty = utils.cachedProperty;

/**
* @param {EDDSA} eddsa - instance
* @param {Object} params - public/private key parameters
*
* @param {Array<Byte>} [params.secret] - secret seed bytes
* @param {Point} [params.pub] - public key point (aka `A` in eddsa terms)
* @param {Array<Byte>} [params.pub] - public key point encoded as bytes
*
*/
function KeyPair(eddsa, params) {
  this.eddsa = eddsa;
  this._secret = parseBytes(params.secret);
  if (eddsa.isPoint(params.pub))
    this._pub = params.pub;
  else
    this._pubBytes = parseBytes(params.pub);
}

KeyPair.fromPublic = function fromPublic(eddsa, pub) {
  if (pub instanceof KeyPair)
    return pub;
  return new KeyPair(eddsa, { pub: pub });
};

KeyPair.fromSecret = function fromSecret(eddsa, secret) {
  if (secret instanceof KeyPair)
    return secret;
  return new KeyPair(eddsa, { secret: secret });
};

KeyPair.prototype.secret = function secret() {
  return this._secret;
};

cachedProperty(KeyPair, 'pubBytes', function pubBytes() {
  return this.eddsa.encodePoint(this.pub());
});

cachedProperty(KeyPair, 'pub', function pub() {
  if (this._pubBytes)
    return this.eddsa.decodePoint(this._pubBytes);
  return this.eddsa.g.mul(this.priv());
});

cachedProperty(KeyPair, 'privBytes', function privBytes() {
  var eddsa = this.eddsa;
  var hash = this.hash();
  var lastIx = eddsa.encodingLength - 1;

  var a = hash.slice(0, eddsa.encodingLength);
  a[0] &= 248;
  a[lastIx] &= 127;
  a[lastIx] |= 64;

  return a;
});

cachedProperty(KeyPair, 'priv', function priv() {
  return this.eddsa.decodeInt(this.privBytes());
});

cachedProperty(KeyPair, 'hash', function hash() {
  return this.eddsa.hash().update(this.secret()).digest();
});

cachedProperty(KeyPair, 'messagePrefix', function messagePrefix() {
  return this.hash().slice(this.eddsa.encodingLength);
});

KeyPair.prototype.sign = function sign(message) {
  assert(this._secret, 'KeyPair can only verify');
  return this.eddsa.sign(message, this);
};

KeyPair.prototype.verify = function verify(message, sig) {
  return this.eddsa.verify(message, sig, this);
};

KeyPair.prototype.getSecret = function getSecret(enc) {
  assert(this._secret, 'KeyPair is public only');
  return utils.encode(this.secret(), enc);
};

KeyPair.prototype.getPublic = function getPublic(enc) {
  return utils.encode(this.pubBytes(), enc);
};

module.exports = KeyPair;


/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/eddsa/signature.js":
/*!***************************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/eddsa/signature.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");
var utils = __webpack_require__(/*! ../utils */ "./node_modules/elliptic/lib/elliptic/utils.js");
var assert = utils.assert;
var cachedProperty = utils.cachedProperty;
var parseBytes = utils.parseBytes;

/**
* @param {EDDSA} eddsa - eddsa instance
* @param {Array<Bytes>|Object} sig -
* @param {Array<Bytes>|Point} [sig.R] - R point as Point or bytes
* @param {Array<Bytes>|bn} [sig.S] - S scalar as bn or bytes
* @param {Array<Bytes>} [sig.Rencoded] - R point encoded
* @param {Array<Bytes>} [sig.Sencoded] - S scalar encoded
*/
function Signature(eddsa, sig) {
  this.eddsa = eddsa;

  if (typeof sig !== 'object')
    sig = parseBytes(sig);

  if (Array.isArray(sig)) {
    sig = {
      R: sig.slice(0, eddsa.encodingLength),
      S: sig.slice(eddsa.encodingLength)
    };
  }

  assert(sig.R && sig.S, 'Signature without R or S');

  if (eddsa.isPoint(sig.R))
    this._R = sig.R;
  if (sig.S instanceof BN)
    this._S = sig.S;

  this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
  this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
}

cachedProperty(Signature, 'S', function S() {
  return this.eddsa.decodeInt(this.Sencoded());
});

cachedProperty(Signature, 'R', function R() {
  return this.eddsa.decodePoint(this.Rencoded());
});

cachedProperty(Signature, 'Rencoded', function Rencoded() {
  return this.eddsa.encodePoint(this.R());
});

cachedProperty(Signature, 'Sencoded', function Sencoded() {
  return this.eddsa.encodeInt(this.S());
});

Signature.prototype.toBytes = function toBytes() {
  return this.Rencoded().concat(this.Sencoded());
};

Signature.prototype.toHex = function toHex() {
  return utils.encode(this.toBytes(), 'hex').toUpperCase();
};

module.exports = Signature;


/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js":
/*!*********************************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {
  doubles: {
    step: 4,
    points: [
      [
        'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',
        'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821'
      ],
      [
        '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',
        '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf'
      ],
      [
        '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',
        'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695'
      ],
      [
        '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',
        '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9'
      ],
      [
        '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',
        '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36'
      ],
      [
        '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',
        '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f'
      ],
      [
        'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',
        '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999'
      ],
      [
        '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',
        'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09'
      ],
      [
        'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',
        '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d'
      ],
      [
        'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',
        'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088'
      ],
      [
        'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',
        '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d'
      ],
      [
        '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',
        '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8'
      ],
      [
        '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',
        '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a'
      ],
      [
        '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',
        '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453'
      ],
      [
        '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',
        '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160'
      ],
      [
        '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',
        '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0'
      ],
      [
        '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',
        '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6'
      ],
      [
        '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',
        '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589'
      ],
      [
        '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',
        'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17'
      ],
      [
        'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',
        '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda'
      ],
      [
        'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',
        '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd'
      ],
      [
        '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',
        '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2'
      ],
      [
        '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',
        '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6'
      ],
      [
        'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',
        '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f'
      ],
      [
        '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',
        'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01'
      ],
      [
        'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',
        '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3'
      ],
      [
        'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',
        'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f'
      ],
      [
        'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',
        '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7'
      ],
      [
        'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',
        'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78'
      ],
      [
        'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',
        '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1'
      ],
      [
        '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',
        'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150'
      ],
      [
        '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',
        '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82'
      ],
      [
        'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',
        '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc'
      ],
      [
        '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',
        'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b'
      ],
      [
        'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',
        '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51'
      ],
      [
        'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',
        '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45'
      ],
      [
        'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',
        'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120'
      ],
      [
        '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',
        '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84'
      ],
      [
        '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',
        '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d'
      ],
      [
        '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',
        'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d'
      ],
      [
        '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',
        '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8'
      ],
      [
        'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',
        '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8'
      ],
      [
        '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',
        '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac'
      ],
      [
        '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',
        'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f'
      ],
      [
        '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',
        '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962'
      ],
      [
        'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',
        '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907'
      ],
      [
        '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',
        'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec'
      ],
      [
        'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',
        'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d'
      ],
      [
        'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',
        '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414'
      ],
      [
        '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',
        'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd'
      ],
      [
        '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',
        'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0'
      ],
      [
        'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',
        '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811'
      ],
      [
        'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',
        '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1'
      ],
      [
        'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',
        '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c'
      ],
      [
        '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',
        'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73'
      ],
      [
        '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',
        '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd'
      ],
      [
        'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',
        'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405'
      ],
      [
        '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',
        'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589'
      ],
      [
        '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',
        '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e'
      ],
      [
        '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',
        '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27'
      ],
      [
        'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',
        'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1'
      ],
      [
        '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',
        '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482'
      ],
      [
        '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',
        '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945'
      ],
      [
        'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',
        '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573'
      ],
      [
        'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',
        'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82'
      ]
    ]
  },
  naf: {
    wnd: 7,
    points: [
      [
        'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',
        '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672'
      ],
      [
        '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',
        'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6'
      ],
      [
        '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',
        '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da'
      ],
      [
        'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',
        'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37'
      ],
      [
        '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',
        'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b'
      ],
      [
        'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',
        'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81'
      ],
      [
        'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',
        '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58'
      ],
      [
        'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',
        '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77'
      ],
      [
        '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',
        '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a'
      ],
      [
        '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',
        '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c'
      ],
      [
        '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',
        '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67'
      ],
      [
        '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',
        '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402'
      ],
      [
        'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',
        'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55'
      ],
      [
        'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',
        '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482'
      ],
      [
        '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',
        'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82'
      ],
      [
        '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',
        'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396'
      ],
      [
        '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',
        '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49'
      ],
      [
        '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',
        '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf'
      ],
      [
        '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',
        '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a'
      ],
      [
        '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',
        'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7'
      ],
      [
        'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',
        'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933'
      ],
      [
        '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',
        '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a'
      ],
      [
        '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',
        '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6'
      ],
      [
        'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',
        'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37'
      ],
      [
        '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',
        '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e'
      ],
      [
        'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',
        'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6'
      ],
      [
        'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',
        'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476'
      ],
      [
        '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',
        '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40'
      ],
      [
        '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',
        '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61'
      ],
      [
        '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',
        '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683'
      ],
      [
        'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',
        '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5'
      ],
      [
        '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',
        '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b'
      ],
      [
        'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',
        '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417'
      ],
      [
        '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',
        'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868'
      ],
      [
        '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',
        'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a'
      ],
      [
        'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',
        'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6'
      ],
      [
        '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',
        '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996'
      ],
      [
        '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',
        'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e'
      ],
      [
        'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',
        'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d'
      ],
      [
        '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',
        '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2'
      ],
      [
        '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',
        'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e'
      ],
      [
        '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',
        '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437'
      ],
      [
        '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',
        'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311'
      ],
      [
        'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',
        '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4'
      ],
      [
        '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',
        '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575'
      ],
      [
        '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',
        'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d'
      ],
      [
        '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',
        'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d'
      ],
      [
        'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',
        'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629'
      ],
      [
        'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',
        'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06'
      ],
      [
        '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',
        '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374'
      ],
      [
        '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',
        '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee'
      ],
      [
        'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',
        '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1'
      ],
      [
        'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',
        'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b'
      ],
      [
        '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',
        '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661'
      ],
      [
        '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',
        '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6'
      ],
      [
        'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',
        '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e'
      ],
      [
        '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',
        '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d'
      ],
      [
        'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',
        'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc'
      ],
      [
        '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',
        'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4'
      ],
      [
        '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',
        '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c'
      ],
      [
        'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',
        '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b'
      ],
      [
        'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',
        '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913'
      ],
      [
        '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',
        '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154'
      ],
      [
        '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',
        '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865'
      ],
      [
        '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',
        'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc'
      ],
      [
        '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',
        'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224'
      ],
      [
        '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',
        '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e'
      ],
      [
        '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',
        '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6'
      ],
      [
        '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',
        '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511'
      ],
      [
        '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',
        'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b'
      ],
      [
        'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',
        'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2'
      ],
      [
        '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',
        'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c'
      ],
      [
        'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',
        '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3'
      ],
      [
        'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',
        '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d'
      ],
      [
        'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',
        '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700'
      ],
      [
        'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',
        '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4'
      ],
      [
        '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',
        'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196'
      ],
      [
        '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',
        '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4'
      ],
      [
        '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',
        'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257'
      ],
      [
        'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',
        'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13'
      ],
      [
        'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',
        '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096'
      ],
      [
        'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',
        'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38'
      ],
      [
        'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',
        '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f'
      ],
      [
        '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',
        '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448'
      ],
      [
        'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',
        '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a'
      ],
      [
        'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',
        '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4'
      ],
      [
        '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',
        '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437'
      ],
      [
        '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',
        'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7'
      ],
      [
        'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',
        '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d'
      ],
      [
        'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',
        '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a'
      ],
      [
        'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',
        '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54'
      ],
      [
        '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',
        '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77'
      ],
      [
        'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',
        'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517'
      ],
      [
        '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',
        'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10'
      ],
      [
        'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',
        'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125'
      ],
      [
        'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',
        '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e'
      ],
      [
        '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',
        'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1'
      ],
      [
        'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',
        '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2'
      ],
      [
        'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',
        '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423'
      ],
      [
        'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',
        '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8'
      ],
      [
        '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',
        'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758'
      ],
      [
        '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',
        'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375'
      ],
      [
        'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',
        '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d'
      ],
      [
        '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',
        'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec'
      ],
      [
        '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',
        '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0'
      ],
      [
        '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',
        'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c'
      ],
      [
        'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',
        'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4'
      ],
      [
        '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',
        'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f'
      ],
      [
        '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',
        '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649'
      ],
      [
        '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',
        'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826'
      ],
      [
        '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',
        '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5'
      ],
      [
        'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',
        'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87'
      ],
      [
        '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',
        '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b'
      ],
      [
        'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',
        '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc'
      ],
      [
        '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',
        '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c'
      ],
      [
        'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',
        'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f'
      ],
      [
        'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',
        '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a'
      ],
      [
        'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',
        'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46'
      ],
      [
        '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',
        'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f'
      ],
      [
        '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',
        '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03'
      ],
      [
        '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',
        'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08'
      ],
      [
        '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',
        '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8'
      ],
      [
        '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',
        '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373'
      ],
      [
        '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',
        'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3'
      ],
      [
        '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',
        '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8'
      ],
      [
        '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',
        '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1'
      ],
      [
        '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',
        '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9'
      ]
    ]
  }
};


/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/utils.js":
/*!*****************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/utils.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = exports;
var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");
var minAssert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/minimalistic-assert/index.js");
var minUtils = __webpack_require__(/*! minimalistic-crypto-utils */ "./node_modules/minimalistic-crypto-utils/lib/utils.js");

utils.assert = minAssert;
utils.toArray = minUtils.toArray;
utils.zero2 = minUtils.zero2;
utils.toHex = minUtils.toHex;
utils.encode = minUtils.encode;

// Represent num in a w-NAF form
function getNAF(num, w) {
  var naf = [];
  var ws = 1 << (w + 1);
  var k = num.clone();
  while (k.cmpn(1) >= 0) {
    var z;
    if (k.isOdd()) {
      var mod = k.andln(ws - 1);
      if (mod > (ws >> 1) - 1)
        z = (ws >> 1) - mod;
      else
        z = mod;
      k.isubn(z);
    } else {
      z = 0;
    }
    naf.push(z);

    // Optimization, shift by word if possible
    var shift = (k.cmpn(0) !== 0 && k.andln(ws - 1) === 0) ? (w + 1) : 1;
    for (var i = 1; i < shift; i++)
      naf.push(0);
    k.iushrn(shift);
  }

  return naf;
}
utils.getNAF = getNAF;

// Represent k1, k2 in a Joint Sparse Form
function getJSF(k1, k2) {
  var jsf = [
    [],
    []
  ];

  k1 = k1.clone();
  k2 = k2.clone();
  var d1 = 0;
  var d2 = 0;
  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {

    // First phase
    var m14 = (k1.andln(3) + d1) & 3;
    var m24 = (k2.andln(3) + d2) & 3;
    if (m14 === 3)
      m14 = -1;
    if (m24 === 3)
      m24 = -1;
    var u1;
    if ((m14 & 1) === 0) {
      u1 = 0;
    } else {
      var m8 = (k1.andln(7) + d1) & 7;
      if ((m8 === 3 || m8 === 5) && m24 === 2)
        u1 = -m14;
      else
        u1 = m14;
    }
    jsf[0].push(u1);

    var u2;
    if ((m24 & 1) === 0) {
      u2 = 0;
    } else {
      var m8 = (k2.andln(7) + d2) & 7;
      if ((m8 === 3 || m8 === 5) && m14 === 2)
        u2 = -m24;
      else
        u2 = m24;
    }
    jsf[1].push(u2);

    // Second phase
    if (2 * d1 === u1 + 1)
      d1 = 1 - d1;
    if (2 * d2 === u2 + 1)
      d2 = 1 - d2;
    k1.iushrn(1);
    k2.iushrn(1);
  }

  return jsf;
}
utils.getJSF = getJSF;

function cachedProperty(obj, name, computer) {
  var key = '_' + name;
  obj.prototype[name] = function cachedProperty() {
    return this[key] !== undefined ? this[key] :
           this[key] = computer.call(this);
  };
}
utils.cachedProperty = cachedProperty;

function parseBytes(bytes) {
  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :
                                     bytes;
}
utils.parseBytes = parseBytes;

function intFromLE(bytes) {
  return new BN(bytes, 'hex', 'le');
}
utils.intFromLE = intFromLE;



/***/ }),

/***/ "./node_modules/elliptic/package.json":
/*!********************************************!*\
  !*** ./node_modules/elliptic/package.json ***!
  \********************************************/
/*! exports provided: _args, _development, _from, _id, _inBundle, _integrity, _location, _phantomChildren, _requested, _requiredBy, _resolved, _spec, _where, author, bugs, dependencies, description, devDependencies, files, homepage, keywords, license, main, name, repository, scripts, version, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"_args\":[[\"elliptic@6.5.1\",\"/Users/dheeraj.suthar/Projects/demo/hand-recognition\"]],\"_development\":true,\"_from\":\"elliptic@6.5.1\",\"_id\":\"elliptic@6.5.1\",\"_inBundle\":false,\"_integrity\":\"sha512-xvJINNLbTeWQjrl6X+7eQCrIy/YPv5XCpKW6kB5mKvtnGILoLDcySuwomfdzt0BMdLNVnuRNTuzKNHj0bva1Cg==\",\"_location\":\"/elliptic\",\"_phantomChildren\":{},\"_requested\":{\"type\":\"version\",\"registry\":true,\"raw\":\"elliptic@6.5.1\",\"name\":\"elliptic\",\"escapedName\":\"elliptic\",\"rawSpec\":\"6.5.1\",\"saveSpec\":null,\"fetchSpec\":\"6.5.1\"},\"_requiredBy\":[\"/browserify-sign\",\"/create-ecdh\"],\"_resolved\":\"https://registry.npmjs.org/elliptic/-/elliptic-6.5.1.tgz\",\"_spec\":\"6.5.1\",\"_where\":\"/Users/dheeraj.suthar/Projects/demo/hand-recognition\",\"author\":{\"name\":\"Fedor Indutny\",\"email\":\"fedor@indutny.com\"},\"bugs\":{\"url\":\"https://github.com/indutny/elliptic/issues\"},\"dependencies\":{\"bn.js\":\"^4.4.0\",\"brorand\":\"^1.0.1\",\"hash.js\":\"^1.0.0\",\"hmac-drbg\":\"^1.0.0\",\"inherits\":\"^2.0.1\",\"minimalistic-assert\":\"^1.0.0\",\"minimalistic-crypto-utils\":\"^1.0.0\"},\"description\":\"EC cryptography\",\"devDependencies\":{\"brfs\":\"^1.4.3\",\"coveralls\":\"^3.0.4\",\"grunt\":\"^1.0.4\",\"grunt-browserify\":\"^5.0.0\",\"grunt-cli\":\"^1.2.0\",\"grunt-contrib-connect\":\"^1.0.0\",\"grunt-contrib-copy\":\"^1.0.0\",\"grunt-contrib-uglify\":\"^1.0.1\",\"grunt-mocha-istanbul\":\"^3.0.1\",\"grunt-saucelabs\":\"^9.0.1\",\"istanbul\":\"^0.4.2\",\"jscs\":\"^3.0.7\",\"jshint\":\"^2.6.0\",\"mocha\":\"^6.1.4\"},\"files\":[\"lib\"],\"homepage\":\"https://github.com/indutny/elliptic\",\"keywords\":[\"EC\",\"Elliptic\",\"curve\",\"Cryptography\"],\"license\":\"MIT\",\"main\":\"lib/elliptic.js\",\"name\":\"elliptic\",\"repository\":{\"type\":\"git\",\"url\":\"git+ssh://git@github.com/indutny/elliptic.git\"},\"scripts\":{\"jscs\":\"jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js\",\"jshint\":\"jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js\",\"lint\":\"npm run jscs && npm run jshint\",\"test\":\"npm run lint && npm run unit\",\"unit\":\"istanbul test _mocha --reporter=spec test/index.js\",\"version\":\"grunt dist && git add dist/\"},\"version\":\"6.5.1\"}");

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = $getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  var args = [];
  for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    ReflectApply(this.listener, this.target, args);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function') {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function') {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}


/***/ }),

/***/ "./node_modules/evp_bytestokey/index.js":
/*!**********************************************!*\
  !*** ./node_modules/evp_bytestokey/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
var MD5 = __webpack_require__(/*! md5.js */ "./node_modules/md5.js/index.js")

/* eslint-disable camelcase */
function EVP_BytesToKey (password, salt, keyBits, ivLen) {
  if (!Buffer.isBuffer(password)) password = Buffer.from(password, 'binary')
  if (salt) {
    if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, 'binary')
    if (salt.length !== 8) throw new RangeError('salt should be Buffer with 8 byte length')
  }

  var keyLen = keyBits / 8
  var key = Buffer.alloc(keyLen)
  var iv = Buffer.alloc(ivLen || 0)
  var tmp = Buffer.alloc(0)

  while (keyLen > 0 || ivLen > 0) {
    var hash = new MD5()
    hash.update(tmp)
    hash.update(password)
    if (salt) hash.update(salt)
    tmp = hash.digest()

    var used = 0

    if (keyLen > 0) {
      var keyStart = key.length - keyLen
      used = Math.min(keyLen, tmp.length)
      tmp.copy(key, keyStart, 0, used)
      keyLen -= used
    }

    if (used < tmp.length && ivLen > 0) {
      var ivStart = iv.length - ivLen
      var length = Math.min(ivLen, tmp.length - used)
      tmp.copy(iv, ivStart, used, used + length)
      ivLen -= length
    }
  }

  tmp.fill(0)
  return { key: key, iv: iv }
}

module.exports = EVP_BytesToKey


/***/ }),

/***/ "./node_modules/handtrackjs/src/index.js":
/*!***********************************************!*\
  !*** ./node_modules/handtrackjs/src/index.js ***!
  \***********************************************/
/*! exports provided: load, startVideo, stopVideo, ObjectDetection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "load", function() { return load; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "startVideo", function() { return startVideo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stopVideo", function() { return stopVideo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ObjectDetection", function() { return ObjectDetection; });
/* harmony import */ var _tensorflow_tfjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs */ "./node_modules/@tensorflow/tfjs/dist/tf.esm.js");
/**
 * @license
 * Copyright 2019 Victor Dibia.
 * Handtrack.js - A library for prototyping realtime hand tracking using neural networks.
 * Licensed under the MIT License (the "License"); 
 * Code snippets from the tensorflow coco-ssd example are reused here - https://github.com/tensorflow/tfjs-models/tree/master/coco-ssd
 * =============================================================================
 */




// const basePath = "https://cdn.jsdelivr.net/npm/handtrackjs/models/web/"
const basePath = "http://localhost:8080/"

const defaultParams = {
  flipHorizontal: true,
  outputStride: 16,
  imageScaleFactor: 0.7,
  maxNumBoxes: 20,
  iouThreshold: 0.5,
  scoreThreshold: 0.99,
  modelType: "ssdlitemobilenetv2"
}

async function load(params) {
  let modelParams = Object.assign({}, defaultParams, params);
  // console.log(modelParams) 
  const objectDetection = new ObjectDetection(modelParams);
  await objectDetection.load();
  return (objectDetection);
}

function startVideo(video) {
  // Video must have height and width in order to be used as input for NN
  // Aspect ratio of 3/4 is used to support safari browser.
  video.width = video.width || 640;
  video.height = video.height || video.width * (3 / 4)

  return new Promise(function (resolve, reject) {
    navigator.mediaDevices
      .getUserMedia({
        audio: false,
        video: {
          facingMode: "user"
        }
      })
      .then(stream => {
        window.localStream = stream;
        video.srcObject = stream
        video.onloadedmetadata = () => {
          video.play()
          resolve(true)
        }
      }).catch(function (err) {
        resolve(false)
      });
  });

}

async function stopVideo() {
  if (window.localStream) {
    window.localStream.getTracks().forEach((track) => {
      track.stop();
      return true;
    });
  } else {
    return false;
  }
}

class ObjectDetection {
  constructor(modelParams) {
    this.modelPath = basePath + modelParams.modelType + "/tensorflowjs_model.pb";
    this.weightPath = basePath + modelParams.modelType + "/weights_manifest.json";
    this.modelParams = modelParams
  }

  async load() {
    this.fps = 0
    this.model = await _tensorflow_tfjs__WEBPACK_IMPORTED_MODULE_0__["loadFrozenModel"](this.modelPath, this.weightPath);

    // Warmup the model.
    const result = await this.model.executeAsync(_tensorflow_tfjs__WEBPACK_IMPORTED_MODULE_0__["zeros"]([1, 300, 300, 3]));
    result.map(async (t) => await t.data());
    result.map(async (t) => t.dispose());
    // console.log("model loaded and warmed up")
  }

  async detect(input) {

    let timeBegin = Date.now()
    const [height, width] = getInputTensorDimensions(input);
    const resizedHeight = getValidResolution(this.modelParams.imageScaleFactor, height, this.modelParams.outputStride);
    const resizedWidth = getValidResolution(this.modelParams.imageScaleFactor, width, this.modelParams.outputStride);

    const batched = _tensorflow_tfjs__WEBPACK_IMPORTED_MODULE_0__["tidy"](() => {
      const imageTensor = _tensorflow_tfjs__WEBPACK_IMPORTED_MODULE_0__["fromPixels"](input)
      if (this.modelParams.flipHorizontal) {
        return imageTensor.reverse(1).resizeBilinear([resizedHeight, resizedWidth]).expandDims(0);
      } else {
        return imageTensor.resizeBilinear([resizedHeight, resizedWidth]).expandDims(0);
      }
    })

    // const result = await this.model.executeAsync(batched);
    self = this
    return this.model.executeAsync(batched).then(function (result) {


      const scores = result[0].dataSync()
      const boxes = result[1].dataSync()

      // clean the webgl tensors
      batched.dispose()
      _tensorflow_tfjs__WEBPACK_IMPORTED_MODULE_0__["dispose"](result)

      // console.log("scores result",scores, boxes)

      const [maxScores, classes] = calculateMaxScores(scores, result[0].shape[1], result[0].shape[2]);
      const prevBackend = _tensorflow_tfjs__WEBPACK_IMPORTED_MODULE_0__["getBackend"]()
      // run post process in cpu
      _tensorflow_tfjs__WEBPACK_IMPORTED_MODULE_0__["setBackend"]('cpu')
      const indexTensor = _tensorflow_tfjs__WEBPACK_IMPORTED_MODULE_0__["tidy"](() => {
        const boxes2 = _tensorflow_tfjs__WEBPACK_IMPORTED_MODULE_0__["tensor2d"](boxes, [
          result[1].shape[1],
          result[1].shape[3]
        ])
        return _tensorflow_tfjs__WEBPACK_IMPORTED_MODULE_0__["image"].nonMaxSuppression(
          boxes2,
          scores,
          self.modelParams.maxNumBoxes, // maxNumBoxes
          self.modelParams.iouThreshold, // iou_threshold
          self.modelParams.scoreThreshold // score_threshold
        )
      })
      const indexes = indexTensor.dataSync()
      indexTensor.dispose()
      // restore previous backend
      _tensorflow_tfjs__WEBPACK_IMPORTED_MODULE_0__["setBackend"](prevBackend)

      const predictions = self.buildDetectedObjects(
        width,
        height,
        boxes,
        scores,
        indexes,
        classes
      )
      let timeEnd = Date.now()
      self.fps = Math.round(1000 / (timeEnd - timeBegin))

      return predictions

    })

  }

  buildDetectedObjects(width, height, boxes, scores, indexes, classes) {
    const count = indexes.length
    const objects = []
    for (let i = 0; i < count; i++) {
      const bbox = []
      for (let j = 0; j < 4; j++) {
        bbox[j] = boxes[indexes[i] * 4 + j]
      }
      const minY = bbox[0] * height
      const minX = bbox[1] * width
      const maxY = bbox[2] * height
      const maxX = bbox[3] * width
      bbox[0] = minX
      bbox[1] = minY
      bbox[2] = maxX - minX
      bbox[3] = maxY - minY
      objects.push({
        bbox: bbox,
        class: classes[indexes[i]],
        score: scores[indexes[i]]
      })
    }
    return objects
  }

  getFPS() {
    return this.fps;
  }

  setModelParameters(params) {
    this.modelParams = Object.assign({}, this.modelParams, params);
  }

  getModelParameters() {
    return this.modelParams;
  }

  renderPredictions(predictions, canvas, context, mediasource) {

    context.clearRect(0, 0, canvas.width, canvas.height);
    canvas.width = mediasource.width;
    canvas.height = mediasource.height;
    // console.log("render", mediasource.width, mediasource.height)

    context.save();
    if (this.modelParams.flipHorizontal) {
      context.scale(-1, 1);
      context.translate(-mediasource.width, 0);
    }
    context.drawImage(mediasource, 0, 0, mediasource.width, mediasource.height);
    context.restore();
    context.font = '10px Arial';

    // console.log('number of detections: ', predictions.length);
    for (let i = 0; i < predictions.length; i++) {
      context.beginPath();
      context.fillStyle = "rgba(255, 255, 255, 0.6)";
      context.fillRect(predictions[i].bbox[0], predictions[i].bbox[1] - 17, predictions[i].bbox[2], 17)
      context.rect(...predictions[i].bbox);

      // draw a dot at the center of bounding box


      context.lineWidth = 1;
      context.strokeStyle = '#0063FF';
      context.fillStyle = "#0063FF" // "rgba(244,247,251,1)";
      context.fillRect(predictions[i].bbox[0] + (predictions[i].bbox[2] / 2), predictions[i].bbox[1] + (predictions[i].bbox[3] / 2), 5, 5)

      context.stroke();
      context.fillText(
        predictions[i].score.toFixed(3) + ' ' + " | hand",
        predictions[i].bbox[0] + 5,
        predictions[i].bbox[1] > 10 ? predictions[i].bbox[1] - 5 : 10);
    }

    // Write FPS to top left
    context.font = "bold 12px Arial"
    context.fillText("[FPS]: " + this.fps, 10, 20)
  }

  dispose() {
    if (this.model) {
      this.model.dispose();
    }
  }

}



function getValidResolution(imageScaleFactor, inputDimension, outputStride) {
  const evenResolution = inputDimension * imageScaleFactor - 1;
  return evenResolution - (evenResolution % outputStride) + 1;
}

function getInputTensorDimensions(input) {
  return input instanceof _tensorflow_tfjs__WEBPACK_IMPORTED_MODULE_0__["Tensor"] ? [input.shape[0], input.shape[1]] : [input.height, input.width];
}

function calculateMaxScores(scores, numBoxes, numClasses) {
  const maxes = [];
  const classes = [];
  for (let i = 0; i < numBoxes; i++) {
    let max = Number.MIN_VALUE;
    let index = -1;
    for (let j = 0; j < numClasses; j++) {
      if (scores[i * numClasses + j] > max) {
        max = scores[i * numClasses + j];
        index = j;
      }
    }
    maxes[i] = max;
    classes[i] = index;
  }
  // console.log([maxes, classes])
  return [maxes, classes];
}

/***/ }),

/***/ "./node_modules/hash-base/index.js":
/*!*****************************************!*\
  !*** ./node_modules/hash-base/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
var Transform = __webpack_require__(/*! stream */ "./node_modules/stream-browserify/index.js").Transform
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")

function throwIfNotStringOrBuffer (val, prefix) {
  if (!Buffer.isBuffer(val) && typeof val !== 'string') {
    throw new TypeError(prefix + ' must be a string or a buffer')
  }
}

function HashBase (blockSize) {
  Transform.call(this)

  this._block = Buffer.allocUnsafe(blockSize)
  this._blockSize = blockSize
  this._blockOffset = 0
  this._length = [0, 0, 0, 0]

  this._finalized = false
}

inherits(HashBase, Transform)

HashBase.prototype._transform = function (chunk, encoding, callback) {
  var error = null
  try {
    this.update(chunk, encoding)
  } catch (err) {
    error = err
  }

  callback(error)
}

HashBase.prototype._flush = function (callback) {
  var error = null
  try {
    this.push(this.digest())
  } catch (err) {
    error = err
  }

  callback(error)
}

HashBase.prototype.update = function (data, encoding) {
  throwIfNotStringOrBuffer(data, 'Data')
  if (this._finalized) throw new Error('Digest already called')
  if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding)

  // consume data
  var block = this._block
  var offset = 0
  while (this._blockOffset + data.length - offset >= this._blockSize) {
    for (var i = this._blockOffset; i < this._blockSize;) block[i++] = data[offset++]
    this._update()
    this._blockOffset = 0
  }
  while (offset < data.length) block[this._blockOffset++] = data[offset++]

  // update length
  for (var j = 0, carry = data.length * 8; carry > 0; ++j) {
    this._length[j] += carry
    carry = (this._length[j] / 0x0100000000) | 0
    if (carry > 0) this._length[j] -= 0x0100000000 * carry
  }

  return this
}

HashBase.prototype._update = function () {
  throw new Error('_update is not implemented')
}

HashBase.prototype.digest = function (encoding) {
  if (this._finalized) throw new Error('Digest already called')
  this._finalized = true

  var digest = this._digest()
  if (encoding !== undefined) digest = digest.toString(encoding)

  // reset state
  this._block.fill(0)
  this._blockOffset = 0
  for (var i = 0; i < 4; ++i) this._length[i] = 0

  return digest
}

HashBase.prototype._digest = function () {
  throw new Error('_digest is not implemented')
}

module.exports = HashBase


/***/ }),

/***/ "./node_modules/hash.js/lib/hash.js":
/*!******************************************!*\
  !*** ./node_modules/hash.js/lib/hash.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var hash = exports;

hash.utils = __webpack_require__(/*! ./hash/utils */ "./node_modules/hash.js/lib/hash/utils.js");
hash.common = __webpack_require__(/*! ./hash/common */ "./node_modules/hash.js/lib/hash/common.js");
hash.sha = __webpack_require__(/*! ./hash/sha */ "./node_modules/hash.js/lib/hash/sha.js");
hash.ripemd = __webpack_require__(/*! ./hash/ripemd */ "./node_modules/hash.js/lib/hash/ripemd.js");
hash.hmac = __webpack_require__(/*! ./hash/hmac */ "./node_modules/hash.js/lib/hash/hmac.js");

// Proxy hash functions to the main object
hash.sha1 = hash.sha.sha1;
hash.sha256 = hash.sha.sha256;
hash.sha224 = hash.sha.sha224;
hash.sha384 = hash.sha.sha384;
hash.sha512 = hash.sha.sha512;
hash.ripemd160 = hash.ripemd.ripemd160;


/***/ }),

/***/ "./node_modules/hash.js/lib/hash/common.js":
/*!*************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/common.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/hash.js/lib/hash/utils.js");
var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/minimalistic-assert/index.js");

function BlockHash() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = 'big';

  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
exports.BlockHash = BlockHash;

BlockHash.prototype.update = function update(msg, enc) {
  // Convert message to array, pad it, and join into 32bit blocks
  msg = utils.toArray(msg, enc);
  if (!this.pending)
    this.pending = msg;
  else
    this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;

  // Enough data, try updating
  if (this.pending.length >= this._delta8) {
    msg = this.pending;

    // Process pending data in blocks
    var r = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r, msg.length);
    if (this.pending.length === 0)
      this.pending = null;

    msg = utils.join32(msg, 0, msg.length - r, this.endian);
    for (var i = 0; i < msg.length; i += this._delta32)
      this._update(msg, i, i + this._delta32);
  }

  return this;
};

BlockHash.prototype.digest = function digest(enc) {
  this.update(this._pad());
  assert(this.pending === null);

  return this._digest(enc);
};

BlockHash.prototype._pad = function pad() {
  var len = this.pendingTotal;
  var bytes = this._delta8;
  var k = bytes - ((len + this.padLength) % bytes);
  var res = new Array(k + this.padLength);
  res[0] = 0x80;
  for (var i = 1; i < k; i++)
    res[i] = 0;

  // Append length
  len <<= 3;
  if (this.endian === 'big') {
    for (var t = 8; t < this.padLength; t++)
      res[i++] = 0;

    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = len & 0xff;
  } else {
    res[i++] = len & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;

    for (t = 8; t < this.padLength; t++)
      res[i++] = 0;
  }

  return res;
};


/***/ }),

/***/ "./node_modules/hash.js/lib/hash/hmac.js":
/*!***********************************************!*\
  !*** ./node_modules/hash.js/lib/hash/hmac.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/hash.js/lib/hash/utils.js");
var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/minimalistic-assert/index.js");

function Hmac(hash, key, enc) {
  if (!(this instanceof Hmac))
    return new Hmac(hash, key, enc);
  this.Hash = hash;
  this.blockSize = hash.blockSize / 8;
  this.outSize = hash.outSize / 8;
  this.inner = null;
  this.outer = null;

  this._init(utils.toArray(key, enc));
}
module.exports = Hmac;

Hmac.prototype._init = function init(key) {
  // Shorten key, if needed
  if (key.length > this.blockSize)
    key = new this.Hash().update(key).digest();
  assert(key.length <= this.blockSize);

  // Add padding to key
  for (var i = key.length; i < this.blockSize; i++)
    key.push(0);

  for (i = 0; i < key.length; i++)
    key[i] ^= 0x36;
  this.inner = new this.Hash().update(key);

  // 0x36 ^ 0x5c = 0x6a
  for (i = 0; i < key.length; i++)
    key[i] ^= 0x6a;
  this.outer = new this.Hash().update(key);
};

Hmac.prototype.update = function update(msg, enc) {
  this.inner.update(msg, enc);
  return this;
};

Hmac.prototype.digest = function digest(enc) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc);
};


/***/ }),

/***/ "./node_modules/hash.js/lib/hash/ripemd.js":
/*!*************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/ripemd.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/hash.js/lib/hash/utils.js");
var common = __webpack_require__(/*! ./common */ "./node_modules/hash.js/lib/hash/common.js");

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_3 = utils.sum32_3;
var sum32_4 = utils.sum32_4;
var BlockHash = common.BlockHash;

function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();

  BlockHash.call(this);

  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];
  this.endian = 'little';
}
utils.inherits(RIPEMD160, BlockHash);
exports.ripemd160 = RIPEMD160;

RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;

RIPEMD160.prototype._update = function update(msg, start) {
  var A = this.h[0];
  var B = this.h[1];
  var C = this.h[2];
  var D = this.h[3];
  var E = this.h[4];
  var Ah = A;
  var Bh = B;
  var Ch = C;
  var Dh = D;
  var Eh = E;
  for (var j = 0; j < 80; j++) {
    var T = sum32(
      rotl32(
        sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
        s[j]),
      E);
    A = E;
    E = D;
    D = rotl32(C, 10);
    C = B;
    B = T;
    T = sum32(
      rotl32(
        sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
        sh[j]),
      Eh);
    Ah = Eh;
    Eh = Dh;
    Dh = rotl32(Ch, 10);
    Ch = Bh;
    Bh = T;
  }
  T = sum32_3(this.h[1], C, Dh);
  this.h[1] = sum32_3(this.h[2], D, Eh);
  this.h[2] = sum32_3(this.h[3], E, Ah);
  this.h[3] = sum32_3(this.h[4], A, Bh);
  this.h[4] = sum32_3(this.h[0], B, Ch);
  this.h[0] = T;
};

RIPEMD160.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'little');
  else
    return utils.split32(this.h, 'little');
};

function f(j, x, y, z) {
  if (j <= 15)
    return x ^ y ^ z;
  else if (j <= 31)
    return (x & y) | ((~x) & z);
  else if (j <= 47)
    return (x | (~y)) ^ z;
  else if (j <= 63)
    return (x & z) | (y & (~z));
  else
    return x ^ (y | (~z));
}

function K(j) {
  if (j <= 15)
    return 0x00000000;
  else if (j <= 31)
    return 0x5a827999;
  else if (j <= 47)
    return 0x6ed9eba1;
  else if (j <= 63)
    return 0x8f1bbcdc;
  else
    return 0xa953fd4e;
}

function Kh(j) {
  if (j <= 15)
    return 0x50a28be6;
  else if (j <= 31)
    return 0x5c4dd124;
  else if (j <= 47)
    return 0x6d703ef3;
  else if (j <= 63)
    return 0x7a6d76e9;
  else
    return 0x00000000;
}

var r = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
];

var rh = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
];

var s = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
];

var sh = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
];


/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha.js":
/*!**********************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.sha1 = __webpack_require__(/*! ./sha/1 */ "./node_modules/hash.js/lib/hash/sha/1.js");
exports.sha224 = __webpack_require__(/*! ./sha/224 */ "./node_modules/hash.js/lib/hash/sha/224.js");
exports.sha256 = __webpack_require__(/*! ./sha/256 */ "./node_modules/hash.js/lib/hash/sha/256.js");
exports.sha384 = __webpack_require__(/*! ./sha/384 */ "./node_modules/hash.js/lib/hash/sha/384.js");
exports.sha512 = __webpack_require__(/*! ./sha/512 */ "./node_modules/hash.js/lib/hash/sha/512.js");


/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha/1.js":
/*!************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/1.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/hash.js/lib/hash/utils.js");
var common = __webpack_require__(/*! ../common */ "./node_modules/hash.js/lib/hash/common.js");
var shaCommon = __webpack_require__(/*! ./common */ "./node_modules/hash.js/lib/hash/sha/common.js");

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_5 = utils.sum32_5;
var ft_1 = shaCommon.ft_1;
var BlockHash = common.BlockHash;

var sha1_K = [
  0x5A827999, 0x6ED9EBA1,
  0x8F1BBCDC, 0xCA62C1D6
];

function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();

  BlockHash.call(this);
  this.h = [
    0x67452301, 0xefcdab89, 0x98badcfe,
    0x10325476, 0xc3d2e1f0 ];
  this.W = new Array(80);
}

utils.inherits(SHA1, BlockHash);
module.exports = SHA1;

SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;

SHA1.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];

  for(; i < W.length; i++)
    W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];

  for (i = 0; i < W.length; i++) {
    var s = ~~(i / 20);
    var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
    e = d;
    d = c;
    c = rotl32(b, 30);
    b = a;
    a = t;
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
};

SHA1.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};


/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha/224.js":
/*!**************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/224.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/hash.js/lib/hash/utils.js");
var SHA256 = __webpack_require__(/*! ./256 */ "./node_modules/hash.js/lib/hash/sha/256.js");

function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();

  SHA256.call(this);
  this.h = [
    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
    0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4 ];
}
utils.inherits(SHA224, SHA256);
module.exports = SHA224;

SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;

SHA224.prototype._digest = function digest(enc) {
  // Just truncate output
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 7), 'big');
  else
    return utils.split32(this.h.slice(0, 7), 'big');
};



/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha/256.js":
/*!**************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/256.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/hash.js/lib/hash/utils.js");
var common = __webpack_require__(/*! ../common */ "./node_modules/hash.js/lib/hash/common.js");
var shaCommon = __webpack_require__(/*! ./common */ "./node_modules/hash.js/lib/hash/sha/common.js");
var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/minimalistic-assert/index.js");

var sum32 = utils.sum32;
var sum32_4 = utils.sum32_4;
var sum32_5 = utils.sum32_5;
var ch32 = shaCommon.ch32;
var maj32 = shaCommon.maj32;
var s0_256 = shaCommon.s0_256;
var s1_256 = shaCommon.s1_256;
var g0_256 = shaCommon.g0_256;
var g1_256 = shaCommon.g1_256;

var BlockHash = common.BlockHash;

var sha256_K = [
  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
];

function SHA256() {
  if (!(this instanceof SHA256))
    return new SHA256();

  BlockHash.call(this);
  this.h = [
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
  ];
  this.k = sha256_K;
  this.W = new Array(64);
}
utils.inherits(SHA256, BlockHash);
module.exports = SHA256;

SHA256.blockSize = 512;
SHA256.outSize = 256;
SHA256.hmacStrength = 192;
SHA256.padLength = 64;

SHA256.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i++)
    W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];
  var f = this.h[5];
  var g = this.h[6];
  var h = this.h[7];

  assert(this.k.length === W.length);
  for (i = 0; i < W.length; i++) {
    var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
    var T2 = sum32(s0_256(a), maj32(a, b, c));
    h = g;
    g = f;
    f = e;
    e = sum32(d, T1);
    d = c;
    c = b;
    b = a;
    a = sum32(T1, T2);
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
  this.h[5] = sum32(this.h[5], f);
  this.h[6] = sum32(this.h[6], g);
  this.h[7] = sum32(this.h[7], h);
};

SHA256.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};


/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha/384.js":
/*!**************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/384.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/hash.js/lib/hash/utils.js");

var SHA512 = __webpack_require__(/*! ./512 */ "./node_modules/hash.js/lib/hash/sha/512.js");

function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();

  SHA512.call(this);
  this.h = [
    0xcbbb9d5d, 0xc1059ed8,
    0x629a292a, 0x367cd507,
    0x9159015a, 0x3070dd17,
    0x152fecd8, 0xf70e5939,
    0x67332667, 0xffc00b31,
    0x8eb44a87, 0x68581511,
    0xdb0c2e0d, 0x64f98fa7,
    0x47b5481d, 0xbefa4fa4 ];
}
utils.inherits(SHA384, SHA512);
module.exports = SHA384;

SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;

SHA384.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 12), 'big');
  else
    return utils.split32(this.h.slice(0, 12), 'big');
};


/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha/512.js":
/*!**************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/512.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/hash.js/lib/hash/utils.js");
var common = __webpack_require__(/*! ../common */ "./node_modules/hash.js/lib/hash/common.js");
var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/minimalistic-assert/index.js");

var rotr64_hi = utils.rotr64_hi;
var rotr64_lo = utils.rotr64_lo;
var shr64_hi = utils.shr64_hi;
var shr64_lo = utils.shr64_lo;
var sum64 = utils.sum64;
var sum64_hi = utils.sum64_hi;
var sum64_lo = utils.sum64_lo;
var sum64_4_hi = utils.sum64_4_hi;
var sum64_4_lo = utils.sum64_4_lo;
var sum64_5_hi = utils.sum64_5_hi;
var sum64_5_lo = utils.sum64_5_lo;

var BlockHash = common.BlockHash;

var sha512_K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
];

function SHA512() {
  if (!(this instanceof SHA512))
    return new SHA512();

  BlockHash.call(this);
  this.h = [
    0x6a09e667, 0xf3bcc908,
    0xbb67ae85, 0x84caa73b,
    0x3c6ef372, 0xfe94f82b,
    0xa54ff53a, 0x5f1d36f1,
    0x510e527f, 0xade682d1,
    0x9b05688c, 0x2b3e6c1f,
    0x1f83d9ab, 0xfb41bd6b,
    0x5be0cd19, 0x137e2179 ];
  this.k = sha512_K;
  this.W = new Array(160);
}
utils.inherits(SHA512, BlockHash);
module.exports = SHA512;

SHA512.blockSize = 1024;
SHA512.outSize = 512;
SHA512.hmacStrength = 192;
SHA512.padLength = 128;

SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
  var W = this.W;

  // 32 x 32bit words
  for (var i = 0; i < 32; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i += 2) {
    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);  // i - 2
    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
    var c1_hi = W[i - 14];  // i - 7
    var c1_lo = W[i - 13];
    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);  // i - 15
    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
    var c3_hi = W[i - 32];  // i - 16
    var c3_lo = W[i - 31];

    W[i] = sum64_4_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
    W[i + 1] = sum64_4_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
  }
};

SHA512.prototype._update = function _update(msg, start) {
  this._prepareBlock(msg, start);

  var W = this.W;

  var ah = this.h[0];
  var al = this.h[1];
  var bh = this.h[2];
  var bl = this.h[3];
  var ch = this.h[4];
  var cl = this.h[5];
  var dh = this.h[6];
  var dl = this.h[7];
  var eh = this.h[8];
  var el = this.h[9];
  var fh = this.h[10];
  var fl = this.h[11];
  var gh = this.h[12];
  var gl = this.h[13];
  var hh = this.h[14];
  var hl = this.h[15];

  assert(this.k.length === W.length);
  for (var i = 0; i < W.length; i += 2) {
    var c0_hi = hh;
    var c0_lo = hl;
    var c1_hi = s1_512_hi(eh, el);
    var c1_lo = s1_512_lo(eh, el);
    var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
    var c3_hi = this.k[i];
    var c3_lo = this.k[i + 1];
    var c4_hi = W[i];
    var c4_lo = W[i + 1];

    var T1_hi = sum64_5_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);
    var T1_lo = sum64_5_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);

    c0_hi = s0_512_hi(ah, al);
    c0_lo = s0_512_lo(ah, al);
    c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
    c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);

    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);

    hh = gh;
    hl = gl;

    gh = fh;
    gl = fl;

    fh = eh;
    fl = el;

    eh = sum64_hi(dh, dl, T1_hi, T1_lo);
    el = sum64_lo(dl, dl, T1_hi, T1_lo);

    dh = ch;
    dl = cl;

    ch = bh;
    cl = bl;

    bh = ah;
    bl = al;

    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
  }

  sum64(this.h, 0, ah, al);
  sum64(this.h, 2, bh, bl);
  sum64(this.h, 4, ch, cl);
  sum64(this.h, 6, dh, dl);
  sum64(this.h, 8, eh, el);
  sum64(this.h, 10, fh, fl);
  sum64(this.h, 12, gh, gl);
  sum64(this.h, 14, hh, hl);
};

SHA512.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

function ch64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ ((~xh) & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function ch64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ ((~xl) & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 28);
  var c1_hi = rotr64_hi(xl, xh, 2);  // 34
  var c2_hi = rotr64_hi(xl, xh, 7);  // 39

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 28);
  var c1_lo = rotr64_lo(xl, xh, 2);  // 34
  var c2_lo = rotr64_lo(xl, xh, 7);  // 39

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 14);
  var c1_hi = rotr64_hi(xh, xl, 18);
  var c2_hi = rotr64_hi(xl, xh, 9);  // 41

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 14);
  var c1_lo = rotr64_lo(xh, xl, 18);
  var c2_lo = rotr64_lo(xl, xh, 9);  // 41

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 1);
  var c1_hi = rotr64_hi(xh, xl, 8);
  var c2_hi = shr64_hi(xh, xl, 7);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 1);
  var c1_lo = rotr64_lo(xh, xl, 8);
  var c2_lo = shr64_lo(xh, xl, 7);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 19);
  var c1_hi = rotr64_hi(xl, xh, 29);  // 61
  var c2_hi = shr64_hi(xh, xl, 6);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 19);
  var c1_lo = rotr64_lo(xl, xh, 29);  // 61
  var c2_lo = shr64_lo(xh, xl, 6);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}


/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha/common.js":
/*!*****************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/common.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/hash.js/lib/hash/utils.js");
var rotr32 = utils.rotr32;

function ft_1(s, x, y, z) {
  if (s === 0)
    return ch32(x, y, z);
  if (s === 1 || s === 3)
    return p32(x, y, z);
  if (s === 2)
    return maj32(x, y, z);
}
exports.ft_1 = ft_1;

function ch32(x, y, z) {
  return (x & y) ^ ((~x) & z);
}
exports.ch32 = ch32;

function maj32(x, y, z) {
  return (x & y) ^ (x & z) ^ (y & z);
}
exports.maj32 = maj32;

function p32(x, y, z) {
  return x ^ y ^ z;
}
exports.p32 = p32;

function s0_256(x) {
  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
}
exports.s0_256 = s0_256;

function s1_256(x) {
  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
}
exports.s1_256 = s1_256;

function g0_256(x) {
  return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);
}
exports.g0_256 = g0_256;

function g1_256(x) {
  return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);
}
exports.g1_256 = g1_256;


/***/ }),

/***/ "./node_modules/hash.js/lib/hash/utils.js":
/*!************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/utils.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/minimalistic-assert/index.js");
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

exports.inherits = inherits;

function isSurrogatePair(msg, i) {
  if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {
    return false;
  }
  if (i < 0 || i + 1 >= msg.length) {
    return false;
  }
  return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;
}

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg === 'string') {
    if (!enc) {
      // Inspired by stringToUtf8ByteArray() in closure-library by Google
      // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143
      // Apache License 2.0
      // https://github.com/google/closure-library/blob/master/LICENSE
      var p = 0;
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        if (c < 128) {
          res[p++] = c;
        } else if (c < 2048) {
          res[p++] = (c >> 6) | 192;
          res[p++] = (c & 63) | 128;
        } else if (isSurrogatePair(msg, i)) {
          c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);
          res[p++] = (c >> 18) | 240;
          res[p++] = ((c >> 12) & 63) | 128;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        } else {
          res[p++] = (c >> 12) | 224;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        }
      }
    } else if (enc === 'hex') {
      msg = msg.replace(/[^a-z0-9]+/ig, '');
      if (msg.length % 2 !== 0)
        msg = '0' + msg;
      for (i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    }
  } else {
    for (i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
  }
  return res;
}
exports.toArray = toArray;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
exports.toHex = toHex;

function htonl(w) {
  var res = (w >>> 24) |
            ((w >>> 8) & 0xff00) |
            ((w << 8) & 0xff0000) |
            ((w & 0xff) << 24);
  return res >>> 0;
}
exports.htonl = htonl;

function toHex32(msg, endian) {
  var res = '';
  for (var i = 0; i < msg.length; i++) {
    var w = msg[i];
    if (endian === 'little')
      w = htonl(w);
    res += zero8(w.toString(16));
  }
  return res;
}
exports.toHex32 = toHex32;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
exports.zero2 = zero2;

function zero8(word) {
  if (word.length === 7)
    return '0' + word;
  else if (word.length === 6)
    return '00' + word;
  else if (word.length === 5)
    return '000' + word;
  else if (word.length === 4)
    return '0000' + word;
  else if (word.length === 3)
    return '00000' + word;
  else if (word.length === 2)
    return '000000' + word;
  else if (word.length === 1)
    return '0000000' + word;
  else
    return word;
}
exports.zero8 = zero8;

function join32(msg, start, end, endian) {
  var len = end - start;
  assert(len % 4 === 0);
  var res = new Array(len / 4);
  for (var i = 0, k = start; i < res.length; i++, k += 4) {
    var w;
    if (endian === 'big')
      w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
    else
      w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
    res[i] = w >>> 0;
  }
  return res;
}
exports.join32 = join32;

function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
    var m = msg[i];
    if (endian === 'big') {
      res[k] = m >>> 24;
      res[k + 1] = (m >>> 16) & 0xff;
      res[k + 2] = (m >>> 8) & 0xff;
      res[k + 3] = m & 0xff;
    } else {
      res[k + 3] = m >>> 24;
      res[k + 2] = (m >>> 16) & 0xff;
      res[k + 1] = (m >>> 8) & 0xff;
      res[k] = m & 0xff;
    }
  }
  return res;
}
exports.split32 = split32;

function rotr32(w, b) {
  return (w >>> b) | (w << (32 - b));
}
exports.rotr32 = rotr32;

function rotl32(w, b) {
  return (w << b) | (w >>> (32 - b));
}
exports.rotl32 = rotl32;

function sum32(a, b) {
  return (a + b) >>> 0;
}
exports.sum32 = sum32;

function sum32_3(a, b, c) {
  return (a + b + c) >>> 0;
}
exports.sum32_3 = sum32_3;

function sum32_4(a, b, c, d) {
  return (a + b + c + d) >>> 0;
}
exports.sum32_4 = sum32_4;

function sum32_5(a, b, c, d, e) {
  return (a + b + c + d + e) >>> 0;
}
exports.sum32_5 = sum32_5;

function sum64(buf, pos, ah, al) {
  var bh = buf[pos];
  var bl = buf[pos + 1];

  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  buf[pos] = hi >>> 0;
  buf[pos + 1] = lo;
}
exports.sum64 = sum64;

function sum64_hi(ah, al, bh, bl) {
  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  return hi >>> 0;
}
exports.sum64_hi = sum64_hi;

function sum64_lo(ah, al, bh, bl) {
  var lo = al + bl;
  return lo >>> 0;
}
exports.sum64_lo = sum64_lo;

function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;

  var hi = ah + bh + ch + dh + carry;
  return hi >>> 0;
}
exports.sum64_4_hi = sum64_4_hi;

function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
  var lo = al + bl + cl + dl;
  return lo >>> 0;
}
exports.sum64_4_lo = sum64_4_lo;

function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;
  lo = (lo + el) >>> 0;
  carry += lo < el ? 1 : 0;

  var hi = ah + bh + ch + dh + eh + carry;
  return hi >>> 0;
}
exports.sum64_5_hi = sum64_5_hi;

function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var lo = al + bl + cl + dl + el;

  return lo >>> 0;
}
exports.sum64_5_lo = sum64_5_lo;

function rotr64_hi(ah, al, num) {
  var r = (al << (32 - num)) | (ah >>> num);
  return r >>> 0;
}
exports.rotr64_hi = rotr64_hi;

function rotr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
exports.rotr64_lo = rotr64_lo;

function shr64_hi(ah, al, num) {
  return ah >>> num;
}
exports.shr64_hi = shr64_hi;

function shr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
exports.shr64_lo = shr64_lo;


/***/ }),

/***/ "./node_modules/hmac-drbg/lib/hmac-drbg.js":
/*!*************************************************!*\
  !*** ./node_modules/hmac-drbg/lib/hmac-drbg.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var hash = __webpack_require__(/*! hash.js */ "./node_modules/hash.js/lib/hash.js");
var utils = __webpack_require__(/*! minimalistic-crypto-utils */ "./node_modules/minimalistic-crypto-utils/lib/utils.js");
var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/minimalistic-assert/index.js");

function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;

  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;

  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;

  var entropy = utils.toArray(options.entropy, options.entropyEnc || 'hex');
  var nonce = utils.toArray(options.nonce, options.nonceEnc || 'hex');
  var pers = utils.toArray(options.pers, options.persEnc || 'hex');
  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
  this._init(entropy, nonce, pers);
}
module.exports = HmacDRBG;

HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);

  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i = 0; i < this.V.length; i++) {
    this.K[i] = 0x00;
    this.V[i] = 0x01;
  }

  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 0x1000000000000;  // 2^48
};

HmacDRBG.prototype._hmac = function hmac() {
  return new hash.hmac(this.hash, this.K);
};

HmacDRBG.prototype._update = function update(seed) {
  var kmac = this._hmac()
                 .update(this.V)
                 .update([ 0x00 ]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;

  this.K = this._hmac()
               .update(this.V)
               .update([ 0x01 ])
               .update(seed)
               .digest();
  this.V = this._hmac().update(this.V).digest();
};

HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
  // Optional entropy enc
  if (typeof entropyEnc !== 'string') {
    addEnc = add;
    add = entropyEnc;
    entropyEnc = null;
  }

  entropy = utils.toArray(entropy, entropyEnc);
  add = utils.toArray(add, addEnc);

  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');

  this._update(entropy.concat(add || []));
  this._reseed = 1;
};

HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error('Reseed is required');

  // Optional encoding
  if (typeof enc !== 'string') {
    addEnc = add;
    add = enc;
    enc = null;
  }

  // Optional additional data
  if (add) {
    add = utils.toArray(add, addEnc || 'hex');
    this._update(add);
  }

  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }

  var res = temp.slice(0, len);
  this._update(add);
  this._reseed++;
  return utils.encode(res, enc);
};


/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}


/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "./node_modules/md5.js/index.js":
/*!**************************************!*\
  !*** ./node_modules/md5.js/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var HashBase = __webpack_require__(/*! hash-base */ "./node_modules/hash-base/index.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

var ARRAY16 = new Array(16)

function MD5 () {
  HashBase.call(this, 64)

  // state
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
}

inherits(MD5, HashBase)

MD5.prototype._update = function () {
  var M = ARRAY16
  for (var i = 0; i < 16; ++i) M[i] = this._block.readInt32LE(i * 4)

  var a = this._a
  var b = this._b
  var c = this._c
  var d = this._d

  a = fnF(a, b, c, d, M[0], 0xd76aa478, 7)
  d = fnF(d, a, b, c, M[1], 0xe8c7b756, 12)
  c = fnF(c, d, a, b, M[2], 0x242070db, 17)
  b = fnF(b, c, d, a, M[3], 0xc1bdceee, 22)
  a = fnF(a, b, c, d, M[4], 0xf57c0faf, 7)
  d = fnF(d, a, b, c, M[5], 0x4787c62a, 12)
  c = fnF(c, d, a, b, M[6], 0xa8304613, 17)
  b = fnF(b, c, d, a, M[7], 0xfd469501, 22)
  a = fnF(a, b, c, d, M[8], 0x698098d8, 7)
  d = fnF(d, a, b, c, M[9], 0x8b44f7af, 12)
  c = fnF(c, d, a, b, M[10], 0xffff5bb1, 17)
  b = fnF(b, c, d, a, M[11], 0x895cd7be, 22)
  a = fnF(a, b, c, d, M[12], 0x6b901122, 7)
  d = fnF(d, a, b, c, M[13], 0xfd987193, 12)
  c = fnF(c, d, a, b, M[14], 0xa679438e, 17)
  b = fnF(b, c, d, a, M[15], 0x49b40821, 22)

  a = fnG(a, b, c, d, M[1], 0xf61e2562, 5)
  d = fnG(d, a, b, c, M[6], 0xc040b340, 9)
  c = fnG(c, d, a, b, M[11], 0x265e5a51, 14)
  b = fnG(b, c, d, a, M[0], 0xe9b6c7aa, 20)
  a = fnG(a, b, c, d, M[5], 0xd62f105d, 5)
  d = fnG(d, a, b, c, M[10], 0x02441453, 9)
  c = fnG(c, d, a, b, M[15], 0xd8a1e681, 14)
  b = fnG(b, c, d, a, M[4], 0xe7d3fbc8, 20)
  a = fnG(a, b, c, d, M[9], 0x21e1cde6, 5)
  d = fnG(d, a, b, c, M[14], 0xc33707d6, 9)
  c = fnG(c, d, a, b, M[3], 0xf4d50d87, 14)
  b = fnG(b, c, d, a, M[8], 0x455a14ed, 20)
  a = fnG(a, b, c, d, M[13], 0xa9e3e905, 5)
  d = fnG(d, a, b, c, M[2], 0xfcefa3f8, 9)
  c = fnG(c, d, a, b, M[7], 0x676f02d9, 14)
  b = fnG(b, c, d, a, M[12], 0x8d2a4c8a, 20)

  a = fnH(a, b, c, d, M[5], 0xfffa3942, 4)
  d = fnH(d, a, b, c, M[8], 0x8771f681, 11)
  c = fnH(c, d, a, b, M[11], 0x6d9d6122, 16)
  b = fnH(b, c, d, a, M[14], 0xfde5380c, 23)
  a = fnH(a, b, c, d, M[1], 0xa4beea44, 4)
  d = fnH(d, a, b, c, M[4], 0x4bdecfa9, 11)
  c = fnH(c, d, a, b, M[7], 0xf6bb4b60, 16)
  b = fnH(b, c, d, a, M[10], 0xbebfbc70, 23)
  a = fnH(a, b, c, d, M[13], 0x289b7ec6, 4)
  d = fnH(d, a, b, c, M[0], 0xeaa127fa, 11)
  c = fnH(c, d, a, b, M[3], 0xd4ef3085, 16)
  b = fnH(b, c, d, a, M[6], 0x04881d05, 23)
  a = fnH(a, b, c, d, M[9], 0xd9d4d039, 4)
  d = fnH(d, a, b, c, M[12], 0xe6db99e5, 11)
  c = fnH(c, d, a, b, M[15], 0x1fa27cf8, 16)
  b = fnH(b, c, d, a, M[2], 0xc4ac5665, 23)

  a = fnI(a, b, c, d, M[0], 0xf4292244, 6)
  d = fnI(d, a, b, c, M[7], 0x432aff97, 10)
  c = fnI(c, d, a, b, M[14], 0xab9423a7, 15)
  b = fnI(b, c, d, a, M[5], 0xfc93a039, 21)
  a = fnI(a, b, c, d, M[12], 0x655b59c3, 6)
  d = fnI(d, a, b, c, M[3], 0x8f0ccc92, 10)
  c = fnI(c, d, a, b, M[10], 0xffeff47d, 15)
  b = fnI(b, c, d, a, M[1], 0x85845dd1, 21)
  a = fnI(a, b, c, d, M[8], 0x6fa87e4f, 6)
  d = fnI(d, a, b, c, M[15], 0xfe2ce6e0, 10)
  c = fnI(c, d, a, b, M[6], 0xa3014314, 15)
  b = fnI(b, c, d, a, M[13], 0x4e0811a1, 21)
  a = fnI(a, b, c, d, M[4], 0xf7537e82, 6)
  d = fnI(d, a, b, c, M[11], 0xbd3af235, 10)
  c = fnI(c, d, a, b, M[2], 0x2ad7d2bb, 15)
  b = fnI(b, c, d, a, M[9], 0xeb86d391, 21)

  this._a = (this._a + a) | 0
  this._b = (this._b + b) | 0
  this._c = (this._c + c) | 0
  this._d = (this._d + d) | 0
}

MD5.prototype._digest = function () {
  // create padding and handle blocks
  this._block[this._blockOffset++] = 0x80
  if (this._blockOffset > 56) {
    this._block.fill(0, this._blockOffset, 64)
    this._update()
    this._blockOffset = 0
  }

  this._block.fill(0, this._blockOffset, 56)
  this._block.writeUInt32LE(this._length[0], 56)
  this._block.writeUInt32LE(this._length[1], 60)
  this._update()

  // produce result
  var buffer = Buffer.allocUnsafe(16)
  buffer.writeInt32LE(this._a, 0)
  buffer.writeInt32LE(this._b, 4)
  buffer.writeInt32LE(this._c, 8)
  buffer.writeInt32LE(this._d, 12)
  return buffer
}

function rotl (x, n) {
  return (x << n) | (x >>> (32 - n))
}

function fnF (a, b, c, d, m, k, s) {
  return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + b) | 0
}

function fnG (a, b, c, d, m, k, s) {
  return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + b) | 0
}

function fnH (a, b, c, d, m, k, s) {
  return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + b) | 0
}

function fnI (a, b, c, d, m, k, s) {
  return (rotl((a + ((c ^ (b | (~d)))) + m + k) | 0, s) + b) | 0
}

module.exports = MD5


/***/ }),

/***/ "./node_modules/miller-rabin/lib/mr.js":
/*!*********************************************!*\
  !*** ./node_modules/miller-rabin/lib/mr.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var bn = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");
var brorand = __webpack_require__(/*! brorand */ "./node_modules/brorand/index.js");

function MillerRabin(rand) {
  this.rand = rand || new brorand.Rand();
}
module.exports = MillerRabin;

MillerRabin.create = function create(rand) {
  return new MillerRabin(rand);
};

MillerRabin.prototype._randbelow = function _randbelow(n) {
  var len = n.bitLength();
  var min_bytes = Math.ceil(len / 8);

  // Generage random bytes until a number less than n is found.
  // This ensures that 0..n-1 have an equal probability of being selected.
  do
    var a = new bn(this.rand.generate(min_bytes));
  while (a.cmp(n) >= 0);

  return a;
};

MillerRabin.prototype._randrange = function _randrange(start, stop) {
  // Generate a random number greater than or equal to start and less than stop.
  var size = stop.sub(start);
  return start.add(this._randbelow(size));
};

MillerRabin.prototype.test = function test(n, k, cb) {
  var len = n.bitLength();
  var red = bn.mont(n);
  var rone = new bn(1).toRed(red);

  if (!k)
    k = Math.max(1, (len / 48) | 0);

  // Find d and s, (n - 1) = (2 ^ s) * d;
  var n1 = n.subn(1);
  for (var s = 0; !n1.testn(s); s++) {}
  var d = n.shrn(s);

  var rn1 = n1.toRed(red);

  var prime = true;
  for (; k > 0; k--) {
    var a = this._randrange(new bn(2), n1);
    if (cb)
      cb(a);

    var x = a.toRed(red).redPow(d);
    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
      continue;

    for (var i = 1; i < s; i++) {
      x = x.redSqr();

      if (x.cmp(rone) === 0)
        return false;
      if (x.cmp(rn1) === 0)
        break;
    }

    if (i === s)
      return false;
  }

  return prime;
};

MillerRabin.prototype.getDivisor = function getDivisor(n, k) {
  var len = n.bitLength();
  var red = bn.mont(n);
  var rone = new bn(1).toRed(red);

  if (!k)
    k = Math.max(1, (len / 48) | 0);

  // Find d and s, (n - 1) = (2 ^ s) * d;
  var n1 = n.subn(1);
  for (var s = 0; !n1.testn(s); s++) {}
  var d = n.shrn(s);

  var rn1 = n1.toRed(red);

  for (; k > 0; k--) {
    var a = this._randrange(new bn(2), n1);

    var g = n.gcd(a);
    if (g.cmpn(1) !== 0)
      return g;

    var x = a.toRed(red).redPow(d);
    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
      continue;

    for (var i = 1; i < s; i++) {
      x = x.redSqr();

      if (x.cmp(rone) === 0)
        return x.fromRed().subn(1).gcd(n);
      if (x.cmp(rn1) === 0)
        break;
    }

    if (i === s) {
      x = x.redSqr();
      return x.fromRed().subn(1).gcd(n);
    }
  }

  return false;
};


/***/ }),

/***/ "./node_modules/minimalistic-assert/index.js":
/*!***************************************************!*\
  !*** ./node_modules/minimalistic-assert/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = assert;

function assert(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
}

assert.equal = function assertEqual(l, r, msg) {
  if (l != r)
    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
};


/***/ }),

/***/ "./node_modules/minimalistic-crypto-utils/lib/utils.js":
/*!*************************************************************!*\
  !*** ./node_modules/minimalistic-crypto-utils/lib/utils.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = exports;

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg !== 'string') {
    for (var i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
    return res;
  }
  if (enc === 'hex') {
    msg = msg.replace(/[^a-z0-9]+/ig, '');
    if (msg.length % 2 !== 0)
      msg = '0' + msg;
    for (var i = 0; i < msg.length; i += 2)
      res.push(parseInt(msg[i] + msg[i + 1], 16));
  } else {
    for (var i = 0; i < msg.length; i++) {
      var c = msg.charCodeAt(i);
      var hi = c >> 8;
      var lo = c & 0xff;
      if (hi)
        res.push(hi, lo);
      else
        res.push(lo);
    }
  }
  return res;
}
utils.toArray = toArray;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
utils.zero2 = zero2;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
utils.toHex = toHex;

utils.encode = function encode(arr, enc) {
  if (enc === 'hex')
    return toHex(arr);
  else
    return arr;
};


/***/ }),

/***/ "./node_modules/parse-asn1/aesid.json":
/*!********************************************!*\
  !*** ./node_modules/parse-asn1/aesid.json ***!
  \********************************************/
/*! exports provided: 2.16.840.1.101.3.4.1.1, 2.16.840.1.101.3.4.1.2, 2.16.840.1.101.3.4.1.3, 2.16.840.1.101.3.4.1.4, 2.16.840.1.101.3.4.1.21, 2.16.840.1.101.3.4.1.22, 2.16.840.1.101.3.4.1.23, 2.16.840.1.101.3.4.1.24, 2.16.840.1.101.3.4.1.41, 2.16.840.1.101.3.4.1.42, 2.16.840.1.101.3.4.1.43, 2.16.840.1.101.3.4.1.44, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"2.16.840.1.101.3.4.1.1\":\"aes-128-ecb\",\"2.16.840.1.101.3.4.1.2\":\"aes-128-cbc\",\"2.16.840.1.101.3.4.1.3\":\"aes-128-ofb\",\"2.16.840.1.101.3.4.1.4\":\"aes-128-cfb\",\"2.16.840.1.101.3.4.1.21\":\"aes-192-ecb\",\"2.16.840.1.101.3.4.1.22\":\"aes-192-cbc\",\"2.16.840.1.101.3.4.1.23\":\"aes-192-ofb\",\"2.16.840.1.101.3.4.1.24\":\"aes-192-cfb\",\"2.16.840.1.101.3.4.1.41\":\"aes-256-ecb\",\"2.16.840.1.101.3.4.1.42\":\"aes-256-cbc\",\"2.16.840.1.101.3.4.1.43\":\"aes-256-ofb\",\"2.16.840.1.101.3.4.1.44\":\"aes-256-cfb\"}");

/***/ }),

/***/ "./node_modules/parse-asn1/asn1.js":
/*!*****************************************!*\
  !*** ./node_modules/parse-asn1/asn1.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// from https://github.com/indutny/self-signed/blob/gh-pages/lib/asn1.js
// Fedor, you are amazing.


var asn1 = __webpack_require__(/*! asn1.js */ "./node_modules/asn1.js/lib/asn1.js")

exports.certificate = __webpack_require__(/*! ./certificate */ "./node_modules/parse-asn1/certificate.js")

var RSAPrivateKey = asn1.define('RSAPrivateKey', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('modulus').int(),
    this.key('publicExponent').int(),
    this.key('privateExponent').int(),
    this.key('prime1').int(),
    this.key('prime2').int(),
    this.key('exponent1').int(),
    this.key('exponent2').int(),
    this.key('coefficient').int()
  )
})
exports.RSAPrivateKey = RSAPrivateKey

var RSAPublicKey = asn1.define('RSAPublicKey', function () {
  this.seq().obj(
    this.key('modulus').int(),
    this.key('publicExponent').int()
  )
})
exports.RSAPublicKey = RSAPublicKey

var PublicKey = asn1.define('SubjectPublicKeyInfo', function () {
  this.seq().obj(
    this.key('algorithm').use(AlgorithmIdentifier),
    this.key('subjectPublicKey').bitstr()
  )
})
exports.PublicKey = PublicKey

var AlgorithmIdentifier = asn1.define('AlgorithmIdentifier', function () {
  this.seq().obj(
    this.key('algorithm').objid(),
    this.key('none').null_().optional(),
    this.key('curve').objid().optional(),
    this.key('params').seq().obj(
      this.key('p').int(),
      this.key('q').int(),
      this.key('g').int()
    ).optional()
  )
})

var PrivateKeyInfo = asn1.define('PrivateKeyInfo', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('algorithm').use(AlgorithmIdentifier),
    this.key('subjectPrivateKey').octstr()
  )
})
exports.PrivateKey = PrivateKeyInfo
var EncryptedPrivateKeyInfo = asn1.define('EncryptedPrivateKeyInfo', function () {
  this.seq().obj(
    this.key('algorithm').seq().obj(
      this.key('id').objid(),
      this.key('decrypt').seq().obj(
        this.key('kde').seq().obj(
          this.key('id').objid(),
          this.key('kdeparams').seq().obj(
            this.key('salt').octstr(),
            this.key('iters').int()
          )
        ),
        this.key('cipher').seq().obj(
          this.key('algo').objid(),
          this.key('iv').octstr()
        )
      )
    ),
    this.key('subjectPrivateKey').octstr()
  )
})

exports.EncryptedPrivateKey = EncryptedPrivateKeyInfo

var DSAPrivateKey = asn1.define('DSAPrivateKey', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('p').int(),
    this.key('q').int(),
    this.key('g').int(),
    this.key('pub_key').int(),
    this.key('priv_key').int()
  )
})
exports.DSAPrivateKey = DSAPrivateKey

exports.DSAparam = asn1.define('DSAparam', function () {
  this.int()
})

var ECPrivateKey = asn1.define('ECPrivateKey', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('privateKey').octstr(),
    this.key('parameters').optional().explicit(0).use(ECParameters),
    this.key('publicKey').optional().explicit(1).bitstr()
  )
})
exports.ECPrivateKey = ECPrivateKey

var ECParameters = asn1.define('ECParameters', function () {
  this.choice({
    namedCurve: this.objid()
  })
})

exports.signature = asn1.define('signature', function () {
  this.seq().obj(
    this.key('r').int(),
    this.key('s').int()
  )
})


/***/ }),

/***/ "./node_modules/parse-asn1/certificate.js":
/*!************************************************!*\
  !*** ./node_modules/parse-asn1/certificate.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// from https://github.com/Rantanen/node-dtls/blob/25a7dc861bda38cfeac93a723500eea4f0ac2e86/Certificate.js
// thanks to @Rantanen



var asn = __webpack_require__(/*! asn1.js */ "./node_modules/asn1.js/lib/asn1.js")

var Time = asn.define('Time', function () {
  this.choice({
    utcTime: this.utctime(),
    generalTime: this.gentime()
  })
})

var AttributeTypeValue = asn.define('AttributeTypeValue', function () {
  this.seq().obj(
    this.key('type').objid(),
    this.key('value').any()
  )
})

var AlgorithmIdentifier = asn.define('AlgorithmIdentifier', function () {
  this.seq().obj(
    this.key('algorithm').objid(),
    this.key('parameters').optional(),
    this.key('curve').objid().optional()
  )
})

var SubjectPublicKeyInfo = asn.define('SubjectPublicKeyInfo', function () {
  this.seq().obj(
    this.key('algorithm').use(AlgorithmIdentifier),
    this.key('subjectPublicKey').bitstr()
  )
})

var RelativeDistinguishedName = asn.define('RelativeDistinguishedName', function () {
  this.setof(AttributeTypeValue)
})

var RDNSequence = asn.define('RDNSequence', function () {
  this.seqof(RelativeDistinguishedName)
})

var Name = asn.define('Name', function () {
  this.choice({
    rdnSequence: this.use(RDNSequence)
  })
})

var Validity = asn.define('Validity', function () {
  this.seq().obj(
    this.key('notBefore').use(Time),
    this.key('notAfter').use(Time)
  )
})

var Extension = asn.define('Extension', function () {
  this.seq().obj(
    this.key('extnID').objid(),
    this.key('critical').bool().def(false),
    this.key('extnValue').octstr()
  )
})

var TBSCertificate = asn.define('TBSCertificate', function () {
  this.seq().obj(
    this.key('version').explicit(0).int().optional(),
    this.key('serialNumber').int(),
    this.key('signature').use(AlgorithmIdentifier),
    this.key('issuer').use(Name),
    this.key('validity').use(Validity),
    this.key('subject').use(Name),
    this.key('subjectPublicKeyInfo').use(SubjectPublicKeyInfo),
    this.key('issuerUniqueID').implicit(1).bitstr().optional(),
    this.key('subjectUniqueID').implicit(2).bitstr().optional(),
    this.key('extensions').explicit(3).seqof(Extension).optional()
  )
})

var X509Certificate = asn.define('X509Certificate', function () {
  this.seq().obj(
    this.key('tbsCertificate').use(TBSCertificate),
    this.key('signatureAlgorithm').use(AlgorithmIdentifier),
    this.key('signatureValue').bitstr()
  )
})

module.exports = X509Certificate


/***/ }),

/***/ "./node_modules/parse-asn1/fixProc.js":
/*!********************************************!*\
  !*** ./node_modules/parse-asn1/fixProc.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// adapted from https://github.com/apatil/pemstrip
var findProc = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r\+\/\=]+)[\n\r]+/m
var startRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m
var fullRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r\+\/\=]+)-----END \1-----$/m
var evp = __webpack_require__(/*! evp_bytestokey */ "./node_modules/evp_bytestokey/index.js")
var ciphers = __webpack_require__(/*! browserify-aes */ "./node_modules/browserify-aes/browser.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
module.exports = function (okey, password) {
  var key = okey.toString()
  var match = key.match(findProc)
  var decrypted
  if (!match) {
    var match2 = key.match(fullRegex)
    decrypted = new Buffer(match2[2].replace(/[\r\n]/g, ''), 'base64')
  } else {
    var suite = 'aes' + match[1]
    var iv = Buffer.from(match[2], 'hex')
    var cipherText = Buffer.from(match[3].replace(/[\r\n]/g, ''), 'base64')
    var cipherKey = evp(password, iv.slice(0, 8), parseInt(match[1], 10)).key
    var out = []
    var cipher = ciphers.createDecipheriv(suite, cipherKey, iv)
    out.push(cipher.update(cipherText))
    out.push(cipher.final())
    decrypted = Buffer.concat(out)
  }
  var tag = key.match(startRegex)[1]
  return {
    tag: tag,
    data: decrypted
  }
}


/***/ }),

/***/ "./node_modules/parse-asn1/index.js":
/*!******************************************!*\
  !*** ./node_modules/parse-asn1/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var asn1 = __webpack_require__(/*! ./asn1 */ "./node_modules/parse-asn1/asn1.js")
var aesid = __webpack_require__(/*! ./aesid.json */ "./node_modules/parse-asn1/aesid.json")
var fixProc = __webpack_require__(/*! ./fixProc */ "./node_modules/parse-asn1/fixProc.js")
var ciphers = __webpack_require__(/*! browserify-aes */ "./node_modules/browserify-aes/browser.js")
var compat = __webpack_require__(/*! pbkdf2 */ "./node_modules/pbkdf2/browser.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
module.exports = parseKeys

function parseKeys (buffer) {
  var password
  if (typeof buffer === 'object' && !Buffer.isBuffer(buffer)) {
    password = buffer.passphrase
    buffer = buffer.key
  }
  if (typeof buffer === 'string') {
    buffer = Buffer.from(buffer)
  }

  var stripped = fixProc(buffer, password)

  var type = stripped.tag
  var data = stripped.data
  var subtype, ndata
  switch (type) {
    case 'CERTIFICATE':
      ndata = asn1.certificate.decode(data, 'der').tbsCertificate.subjectPublicKeyInfo
      // falls through
    case 'PUBLIC KEY':
      if (!ndata) {
        ndata = asn1.PublicKey.decode(data, 'der')
      }
      subtype = ndata.algorithm.algorithm.join('.')
      switch (subtype) {
        case '1.2.840.113549.1.1.1':
          return asn1.RSAPublicKey.decode(ndata.subjectPublicKey.data, 'der')
        case '1.2.840.10045.2.1':
          ndata.subjectPrivateKey = ndata.subjectPublicKey
          return {
            type: 'ec',
            data: ndata
          }
        case '1.2.840.10040.4.1':
          ndata.algorithm.params.pub_key = asn1.DSAparam.decode(ndata.subjectPublicKey.data, 'der')
          return {
            type: 'dsa',
            data: ndata.algorithm.params
          }
        default: throw new Error('unknown key id ' + subtype)
      }
      throw new Error('unknown key type ' + type)
    case 'ENCRYPTED PRIVATE KEY':
      data = asn1.EncryptedPrivateKey.decode(data, 'der')
      data = decrypt(data, password)
      // falls through
    case 'PRIVATE KEY':
      ndata = asn1.PrivateKey.decode(data, 'der')
      subtype = ndata.algorithm.algorithm.join('.')
      switch (subtype) {
        case '1.2.840.113549.1.1.1':
          return asn1.RSAPrivateKey.decode(ndata.subjectPrivateKey, 'der')
        case '1.2.840.10045.2.1':
          return {
            curve: ndata.algorithm.curve,
            privateKey: asn1.ECPrivateKey.decode(ndata.subjectPrivateKey, 'der').privateKey
          }
        case '1.2.840.10040.4.1':
          ndata.algorithm.params.priv_key = asn1.DSAparam.decode(ndata.subjectPrivateKey, 'der')
          return {
            type: 'dsa',
            params: ndata.algorithm.params
          }
        default: throw new Error('unknown key id ' + subtype)
      }
      throw new Error('unknown key type ' + type)
    case 'RSA PUBLIC KEY':
      return asn1.RSAPublicKey.decode(data, 'der')
    case 'RSA PRIVATE KEY':
      return asn1.RSAPrivateKey.decode(data, 'der')
    case 'DSA PRIVATE KEY':
      return {
        type: 'dsa',
        params: asn1.DSAPrivateKey.decode(data, 'der')
      }
    case 'EC PRIVATE KEY':
      data = asn1.ECPrivateKey.decode(data, 'der')
      return {
        curve: data.parameters.value,
        privateKey: data.privateKey
      }
    default: throw new Error('unknown key type ' + type)
  }
}
parseKeys.signature = asn1.signature
function decrypt (data, password) {
  var salt = data.algorithm.decrypt.kde.kdeparams.salt
  var iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10)
  var algo = aesid[data.algorithm.decrypt.cipher.algo.join('.')]
  var iv = data.algorithm.decrypt.cipher.iv
  var cipherText = data.subjectPrivateKey
  var keylen = parseInt(algo.split('-')[1], 10) / 8
  var key = compat.pbkdf2Sync(password, salt, iters, keylen, 'sha1')
  var cipher = ciphers.createDecipheriv(algo, key, iv)
  var out = []
  out.push(cipher.update(cipherText))
  out.push(cipher.final())
  return Buffer.concat(out)
}


/***/ }),

/***/ "./node_modules/pbkdf2/browser.js":
/*!****************************************!*\
  !*** ./node_modules/pbkdf2/browser.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports.pbkdf2 = __webpack_require__(/*! ./lib/async */ "./node_modules/pbkdf2/lib/async.js")
exports.pbkdf2Sync = __webpack_require__(/*! ./lib/sync */ "./node_modules/pbkdf2/lib/sync-browser.js")


/***/ }),

/***/ "./node_modules/pbkdf2/lib/async.js":
/*!******************************************!*\
  !*** ./node_modules/pbkdf2/lib/async.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {var checkParameters = __webpack_require__(/*! ./precondition */ "./node_modules/pbkdf2/lib/precondition.js")
var defaultEncoding = __webpack_require__(/*! ./default-encoding */ "./node_modules/pbkdf2/lib/default-encoding.js")
var sync = __webpack_require__(/*! ./sync */ "./node_modules/pbkdf2/lib/sync-browser.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

var ZERO_BUF
var subtle = global.crypto && global.crypto.subtle
var toBrowser = {
  'sha': 'SHA-1',
  'sha-1': 'SHA-1',
  'sha1': 'SHA-1',
  'sha256': 'SHA-256',
  'sha-256': 'SHA-256',
  'sha384': 'SHA-384',
  'sha-384': 'SHA-384',
  'sha-512': 'SHA-512',
  'sha512': 'SHA-512'
}
var checks = []
function checkNative (algo) {
  if (global.process && !global.process.browser) {
    return Promise.resolve(false)
  }
  if (!subtle || !subtle.importKey || !subtle.deriveBits) {
    return Promise.resolve(false)
  }
  if (checks[algo] !== undefined) {
    return checks[algo]
  }
  ZERO_BUF = ZERO_BUF || Buffer.alloc(8)
  var prom = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, algo)
    .then(function () {
      return true
    }).catch(function () {
      return false
    })
  checks[algo] = prom
  return prom
}

function browserPbkdf2 (password, salt, iterations, length, algo) {
  return subtle.importKey(
    'raw', password, {name: 'PBKDF2'}, false, ['deriveBits']
  ).then(function (key) {
    return subtle.deriveBits({
      name: 'PBKDF2',
      salt: salt,
      iterations: iterations,
      hash: {
        name: algo
      }
    }, key, length << 3)
  }).then(function (res) {
    return Buffer.from(res)
  })
}

function resolvePromise (promise, callback) {
  promise.then(function (out) {
    process.nextTick(function () {
      callback(null, out)
    })
  }, function (e) {
    process.nextTick(function () {
      callback(e)
    })
  })
}
module.exports = function (password, salt, iterations, keylen, digest, callback) {
  if (typeof digest === 'function') {
    callback = digest
    digest = undefined
  }

  digest = digest || 'sha1'
  var algo = toBrowser[digest.toLowerCase()]

  if (!algo || typeof global.Promise !== 'function') {
    return process.nextTick(function () {
      var out
      try {
        out = sync(password, salt, iterations, keylen, digest)
      } catch (e) {
        return callback(e)
      }
      callback(null, out)
    })
  }

  checkParameters(password, salt, iterations, keylen)
  if (typeof callback !== 'function') throw new Error('No callback provided to pbkdf2')
  if (!Buffer.isBuffer(password)) password = Buffer.from(password, defaultEncoding)
  if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, defaultEncoding)

  resolvePromise(checkNative(algo).then(function (resp) {
    if (resp) return browserPbkdf2(password, salt, iterations, keylen, algo)

    return sync(password, salt, iterations, keylen, digest)
  }), callback)
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/pbkdf2/lib/default-encoding.js":
/*!*****************************************************!*\
  !*** ./node_modules/pbkdf2/lib/default-encoding.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {var defaultEncoding
/* istanbul ignore next */
if (process.browser) {
  defaultEncoding = 'utf-8'
} else {
  var pVersionMajor = parseInt(process.version.split('.')[0].slice(1), 10)

  defaultEncoding = pVersionMajor >= 6 ? 'utf-8' : 'binary'
}
module.exports = defaultEncoding

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/pbkdf2/lib/precondition.js":
/*!*************************************************!*\
  !*** ./node_modules/pbkdf2/lib/precondition.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var MAX_ALLOC = Math.pow(2, 30) - 1 // default in iojs

function checkBuffer (buf, name) {
  if (typeof buf !== 'string' && !Buffer.isBuffer(buf)) {
    throw new TypeError(name + ' must be a buffer or string')
  }
}

module.exports = function (password, salt, iterations, keylen) {
  checkBuffer(password, 'Password')
  checkBuffer(salt, 'Salt')

  if (typeof iterations !== 'number') {
    throw new TypeError('Iterations not a number')
  }

  if (iterations < 0) {
    throw new TypeError('Bad iterations')
  }

  if (typeof keylen !== 'number') {
    throw new TypeError('Key length not a number')
  }

  if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen) { /* eslint no-self-compare: 0 */
    throw new TypeError('Bad key length')
  }
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/pbkdf2/lib/sync-browser.js":
/*!*************************************************!*\
  !*** ./node_modules/pbkdf2/lib/sync-browser.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var md5 = __webpack_require__(/*! create-hash/md5 */ "./node_modules/create-hash/md5.js")
var RIPEMD160 = __webpack_require__(/*! ripemd160 */ "./node_modules/ripemd160/index.js")
var sha = __webpack_require__(/*! sha.js */ "./node_modules/sha.js/index.js")

var checkParameters = __webpack_require__(/*! ./precondition */ "./node_modules/pbkdf2/lib/precondition.js")
var defaultEncoding = __webpack_require__(/*! ./default-encoding */ "./node_modules/pbkdf2/lib/default-encoding.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
var ZEROS = Buffer.alloc(128)
var sizes = {
  md5: 16,
  sha1: 20,
  sha224: 28,
  sha256: 32,
  sha384: 48,
  sha512: 64,
  rmd160: 20,
  ripemd160: 20
}

function Hmac (alg, key, saltLen) {
  var hash = getDigest(alg)
  var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64

  if (key.length > blocksize) {
    key = hash(key)
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = Buffer.allocUnsafe(blocksize + sizes[alg])
  var opad = Buffer.allocUnsafe(blocksize + sizes[alg])
  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }

  var ipad1 = Buffer.allocUnsafe(blocksize + saltLen + 4)
  ipad.copy(ipad1, 0, 0, blocksize)
  this.ipad1 = ipad1
  this.ipad2 = ipad
  this.opad = opad
  this.alg = alg
  this.blocksize = blocksize
  this.hash = hash
  this.size = sizes[alg]
}

Hmac.prototype.run = function (data, ipad) {
  data.copy(ipad, this.blocksize)
  var h = this.hash(ipad)
  h.copy(this.opad, this.blocksize)
  return this.hash(this.opad)
}

function getDigest (alg) {
  function shaFunc (data) {
    return sha(alg).update(data).digest()
  }
  function rmd160Func (data) {
    return new RIPEMD160().update(data).digest()
  }

  if (alg === 'rmd160' || alg === 'ripemd160') return rmd160Func
  if (alg === 'md5') return md5
  return shaFunc
}

function pbkdf2 (password, salt, iterations, keylen, digest) {
  checkParameters(password, salt, iterations, keylen)

  if (!Buffer.isBuffer(password)) password = Buffer.from(password, defaultEncoding)
  if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, defaultEncoding)

  digest = digest || 'sha1'

  var hmac = new Hmac(digest, password, salt.length)

  var DK = Buffer.allocUnsafe(keylen)
  var block1 = Buffer.allocUnsafe(salt.length + 4)
  salt.copy(block1, 0, 0, salt.length)

  var destPos = 0
  var hLen = sizes[digest]
  var l = Math.ceil(keylen / hLen)

  for (var i = 1; i <= l; i++) {
    block1.writeUInt32BE(i, salt.length)

    var T = hmac.run(block1, hmac.ipad1)
    var U = T

    for (var j = 1; j < iterations; j++) {
      U = hmac.run(U, hmac.ipad2)
      for (var k = 0; k < hLen; k++) T[k] ^= U[k]
    }

    T.copy(DK, destPos)
    destPos += hLen
  }

  return DK
}

module.exports = pbkdf2


/***/ }),

/***/ "./node_modules/process-nextick-args/index.js":
/*!****************************************************!*\
  !*** ./node_modules/process-nextick-args/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

if (typeof process === 'undefined' ||
    !process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}


/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/public-encrypt/browser.js":
/*!************************************************!*\
  !*** ./node_modules/public-encrypt/browser.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports.publicEncrypt = __webpack_require__(/*! ./publicEncrypt */ "./node_modules/public-encrypt/publicEncrypt.js")
exports.privateDecrypt = __webpack_require__(/*! ./privateDecrypt */ "./node_modules/public-encrypt/privateDecrypt.js")

exports.privateEncrypt = function privateEncrypt (key, buf) {
  return exports.publicEncrypt(key, buf, true)
}

exports.publicDecrypt = function publicDecrypt (key, buf) {
  return exports.privateDecrypt(key, buf, true)
}


/***/ }),

/***/ "./node_modules/public-encrypt/mgf.js":
/*!********************************************!*\
  !*** ./node_modules/public-encrypt/mgf.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var createHash = __webpack_require__(/*! create-hash */ "./node_modules/create-hash/browser.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

module.exports = function (seed, len) {
  var t = Buffer.alloc(0)
  var i = 0
  var c
  while (t.length < len) {
    c = i2ops(i++)
    t = Buffer.concat([t, createHash('sha1').update(seed).update(c).digest()])
  }
  return t.slice(0, len)
}

function i2ops (c) {
  var out = Buffer.allocUnsafe(4)
  out.writeUInt32BE(c, 0)
  return out
}


/***/ }),

/***/ "./node_modules/public-encrypt/privateDecrypt.js":
/*!*******************************************************!*\
  !*** ./node_modules/public-encrypt/privateDecrypt.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var parseKeys = __webpack_require__(/*! parse-asn1 */ "./node_modules/parse-asn1/index.js")
var mgf = __webpack_require__(/*! ./mgf */ "./node_modules/public-encrypt/mgf.js")
var xor = __webpack_require__(/*! ./xor */ "./node_modules/public-encrypt/xor.js")
var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js")
var crt = __webpack_require__(/*! browserify-rsa */ "./node_modules/browserify-rsa/index.js")
var createHash = __webpack_require__(/*! create-hash */ "./node_modules/create-hash/browser.js")
var withPublic = __webpack_require__(/*! ./withPublic */ "./node_modules/public-encrypt/withPublic.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

module.exports = function privateDecrypt (privateKey, enc, reverse) {
  var padding
  if (privateKey.padding) {
    padding = privateKey.padding
  } else if (reverse) {
    padding = 1
  } else {
    padding = 4
  }

  var key = parseKeys(privateKey)
  var k = key.modulus.byteLength()
  if (enc.length > k || new BN(enc).cmp(key.modulus) >= 0) {
    throw new Error('decryption error')
  }
  var msg
  if (reverse) {
    msg = withPublic(new BN(enc), key)
  } else {
    msg = crt(enc, key)
  }
  var zBuffer = Buffer.alloc(k - msg.length)
  msg = Buffer.concat([zBuffer, msg], k)
  if (padding === 4) {
    return oaep(key, msg)
  } else if (padding === 1) {
    return pkcs1(key, msg, reverse)
  } else if (padding === 3) {
    return msg
  } else {
    throw new Error('unknown padding')
  }
}

function oaep (key, msg) {
  var k = key.modulus.byteLength()
  var iHash = createHash('sha1').update(Buffer.alloc(0)).digest()
  var hLen = iHash.length
  if (msg[0] !== 0) {
    throw new Error('decryption error')
  }
  var maskedSeed = msg.slice(1, hLen + 1)
  var maskedDb = msg.slice(hLen + 1)
  var seed = xor(maskedSeed, mgf(maskedDb, hLen))
  var db = xor(maskedDb, mgf(seed, k - hLen - 1))
  if (compare(iHash, db.slice(0, hLen))) {
    throw new Error('decryption error')
  }
  var i = hLen
  while (db[i] === 0) {
    i++
  }
  if (db[i++] !== 1) {
    throw new Error('decryption error')
  }
  return db.slice(i)
}

function pkcs1 (key, msg, reverse) {
  var p1 = msg.slice(0, 2)
  var i = 2
  var status = 0
  while (msg[i++] !== 0) {
    if (i >= msg.length) {
      status++
      break
    }
  }
  var ps = msg.slice(2, i - 1)

  if ((p1.toString('hex') !== '0002' && !reverse) || (p1.toString('hex') !== '0001' && reverse)) {
    status++
  }
  if (ps.length < 8) {
    status++
  }
  if (status) {
    throw new Error('decryption error')
  }
  return msg.slice(i)
}
function compare (a, b) {
  a = Buffer.from(a)
  b = Buffer.from(b)
  var dif = 0
  var len = a.length
  if (a.length !== b.length) {
    dif++
    len = Math.min(a.length, b.length)
  }
  var i = -1
  while (++i < len) {
    dif += (a[i] ^ b[i])
  }
  return dif
}


/***/ }),

/***/ "./node_modules/public-encrypt/publicEncrypt.js":
/*!******************************************************!*\
  !*** ./node_modules/public-encrypt/publicEncrypt.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var parseKeys = __webpack_require__(/*! parse-asn1 */ "./node_modules/parse-asn1/index.js")
var randomBytes = __webpack_require__(/*! randombytes */ "./node_modules/randombytes/browser.js")
var createHash = __webpack_require__(/*! create-hash */ "./node_modules/create-hash/browser.js")
var mgf = __webpack_require__(/*! ./mgf */ "./node_modules/public-encrypt/mgf.js")
var xor = __webpack_require__(/*! ./xor */ "./node_modules/public-encrypt/xor.js")
var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js")
var withPublic = __webpack_require__(/*! ./withPublic */ "./node_modules/public-encrypt/withPublic.js")
var crt = __webpack_require__(/*! browserify-rsa */ "./node_modules/browserify-rsa/index.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

module.exports = function publicEncrypt (publicKey, msg, reverse) {
  var padding
  if (publicKey.padding) {
    padding = publicKey.padding
  } else if (reverse) {
    padding = 1
  } else {
    padding = 4
  }
  var key = parseKeys(publicKey)
  var paddedMsg
  if (padding === 4) {
    paddedMsg = oaep(key, msg)
  } else if (padding === 1) {
    paddedMsg = pkcs1(key, msg, reverse)
  } else if (padding === 3) {
    paddedMsg = new BN(msg)
    if (paddedMsg.cmp(key.modulus) >= 0) {
      throw new Error('data too long for modulus')
    }
  } else {
    throw new Error('unknown padding')
  }
  if (reverse) {
    return crt(paddedMsg, key)
  } else {
    return withPublic(paddedMsg, key)
  }
}

function oaep (key, msg) {
  var k = key.modulus.byteLength()
  var mLen = msg.length
  var iHash = createHash('sha1').update(Buffer.alloc(0)).digest()
  var hLen = iHash.length
  var hLen2 = 2 * hLen
  if (mLen > k - hLen2 - 2) {
    throw new Error('message too long')
  }
  var ps = Buffer.alloc(k - mLen - hLen2 - 2)
  var dblen = k - hLen - 1
  var seed = randomBytes(hLen)
  var maskedDb = xor(Buffer.concat([iHash, ps, Buffer.alloc(1, 1), msg], dblen), mgf(seed, dblen))
  var maskedSeed = xor(seed, mgf(maskedDb, hLen))
  return new BN(Buffer.concat([Buffer.alloc(1), maskedSeed, maskedDb], k))
}
function pkcs1 (key, msg, reverse) {
  var mLen = msg.length
  var k = key.modulus.byteLength()
  if (mLen > k - 11) {
    throw new Error('message too long')
  }
  var ps
  if (reverse) {
    ps = Buffer.alloc(k - mLen - 3, 0xff)
  } else {
    ps = nonZero(k - mLen - 3)
  }
  return new BN(Buffer.concat([Buffer.from([0, reverse ? 1 : 2]), ps, Buffer.alloc(1), msg], k))
}
function nonZero (len) {
  var out = Buffer.allocUnsafe(len)
  var i = 0
  var cache = randomBytes(len * 2)
  var cur = 0
  var num
  while (i < len) {
    if (cur === cache.length) {
      cache = randomBytes(len * 2)
      cur = 0
    }
    num = cache[cur++]
    if (num) {
      out[i++] = num
    }
  }
  return out
}


/***/ }),

/***/ "./node_modules/public-encrypt/withPublic.js":
/*!***************************************************!*\
  !*** ./node_modules/public-encrypt/withPublic.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

function withPublic (paddedMsg, key) {
  return Buffer.from(paddedMsg
    .toRed(BN.mont(key.modulus))
    .redPow(new BN(key.publicExponent))
    .fromRed()
    .toArray())
}

module.exports = withPublic


/***/ }),

/***/ "./node_modules/public-encrypt/xor.js":
/*!********************************************!*\
  !*** ./node_modules/public-encrypt/xor.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function xor (a, b) {
  var len = a.length
  var i = -1
  while (++i < len) {
    a[i] ^= b[i]
  }
  return a
}


/***/ }),

/***/ "./node_modules/randombytes/browser.js":
/*!*********************************************!*\
  !*** ./node_modules/randombytes/browser.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {

// limit of Crypto.getRandomValues()
// https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues
var MAX_BYTES = 65536

// Node supports requesting up to this number of bytes
// https://github.com/nodejs/node/blob/master/lib/internal/crypto/random.js#L48
var MAX_UINT32 = 4294967295

function oldBrowser () {
  throw new Error('Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11')
}

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
var crypto = global.crypto || global.msCrypto

if (crypto && crypto.getRandomValues) {
  module.exports = randomBytes
} else {
  module.exports = oldBrowser
}

function randomBytes (size, cb) {
  // phantomjs needs to throw
  if (size > MAX_UINT32) throw new RangeError('requested too many random bytes')

  var bytes = Buffer.allocUnsafe(size)

  if (size > 0) {  // getRandomValues fails on IE if size == 0
    if (size > MAX_BYTES) { // this is the max bytes crypto.getRandomValues
      // can do at once see https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
      for (var generated = 0; generated < size; generated += MAX_BYTES) {
        // buffer.slice automatically checks if the end is past the end of
        // the buffer so we don't have to here
        crypto.getRandomValues(bytes.slice(generated, generated + MAX_BYTES))
      }
    } else {
      crypto.getRandomValues(bytes)
    }
  }

  if (typeof cb === 'function') {
    return process.nextTick(function () {
      cb(null, bytes)
    })
  }

  return bytes
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/randomfill/browser.js":
/*!********************************************!*\
  !*** ./node_modules/randomfill/browser.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {

function oldBrowser () {
  throw new Error('secure random number generation not supported by this browser\nuse chrome, FireFox or Internet Explorer 11')
}
var safeBuffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js")
var randombytes = __webpack_require__(/*! randombytes */ "./node_modules/randombytes/browser.js")
var Buffer = safeBuffer.Buffer
var kBufferMaxLength = safeBuffer.kMaxLength
var crypto = global.crypto || global.msCrypto
var kMaxUint32 = Math.pow(2, 32) - 1
function assertOffset (offset, length) {
  if (typeof offset !== 'number' || offset !== offset) { // eslint-disable-line no-self-compare
    throw new TypeError('offset must be a number')
  }

  if (offset > kMaxUint32 || offset < 0) {
    throw new TypeError('offset must be a uint32')
  }

  if (offset > kBufferMaxLength || offset > length) {
    throw new RangeError('offset out of range')
  }
}

function assertSize (size, offset, length) {
  if (typeof size !== 'number' || size !== size) { // eslint-disable-line no-self-compare
    throw new TypeError('size must be a number')
  }

  if (size > kMaxUint32 || size < 0) {
    throw new TypeError('size must be a uint32')
  }

  if (size + offset > length || size > kBufferMaxLength) {
    throw new RangeError('buffer too small')
  }
}
if ((crypto && crypto.getRandomValues) || !process.browser) {
  exports.randomFill = randomFill
  exports.randomFillSync = randomFillSync
} else {
  exports.randomFill = oldBrowser
  exports.randomFillSync = oldBrowser
}
function randomFill (buf, offset, size, cb) {
  if (!Buffer.isBuffer(buf) && !(buf instanceof global.Uint8Array)) {
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array')
  }

  if (typeof offset === 'function') {
    cb = offset
    offset = 0
    size = buf.length
  } else if (typeof size === 'function') {
    cb = size
    size = buf.length - offset
  } else if (typeof cb !== 'function') {
    throw new TypeError('"cb" argument must be a function')
  }
  assertOffset(offset, buf.length)
  assertSize(size, offset, buf.length)
  return actualFill(buf, offset, size, cb)
}

function actualFill (buf, offset, size, cb) {
  if (process.browser) {
    var ourBuf = buf.buffer
    var uint = new Uint8Array(ourBuf, offset, size)
    crypto.getRandomValues(uint)
    if (cb) {
      process.nextTick(function () {
        cb(null, buf)
      })
      return
    }
    return buf
  }
  if (cb) {
    randombytes(size, function (err, bytes) {
      if (err) {
        return cb(err)
      }
      bytes.copy(buf, offset)
      cb(null, buf)
    })
    return
  }
  var bytes = randombytes(size)
  bytes.copy(buf, offset)
  return buf
}
function randomFillSync (buf, offset, size) {
  if (typeof offset === 'undefined') {
    offset = 0
  }
  if (!Buffer.isBuffer(buf) && !(buf instanceof global.Uint8Array)) {
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array')
  }

  assertOffset(offset, buf.length)

  if (size === undefined) size = buf.length - offset

  assertSize(size, offset, buf.length)

  return actualFill(buf, offset, size)
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/readable-stream/duplex-browser.js":
/*!********************************************************!*\
  !*** ./node_modules/readable-stream/duplex-browser.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./lib/_stream_duplex.js */ "./node_modules/readable-stream/lib/_stream_duplex.js");


/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_duplex.js":
/*!************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_duplex.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.



/*<replacement>*/

var pna = __webpack_require__(/*! process-nextick-args */ "./node_modules/process-nextick-args/index.js");
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = __webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js");
util.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/*</replacement>*/

var Readable = __webpack_require__(/*! ./_stream_readable */ "./node_modules/readable-stream/lib/_stream_readable.js");
var Writable = __webpack_require__(/*! ./_stream_writable */ "./node_modules/readable-stream/lib/_stream_writable.js");

util.inherits(Duplex, Readable);

{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_passthrough.js":
/*!*****************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_passthrough.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.



module.exports = PassThrough;

var Transform = __webpack_require__(/*! ./_stream_transform */ "./node_modules/readable-stream/lib/_stream_transform.js");

/*<replacement>*/
var util = __webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js");
util.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_readable.js":
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_readable.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var pna = __webpack_require__(/*! process-nextick-args */ "./node_modules/process-nextick-args/index.js");
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js");
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = __webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = __webpack_require__(/*! ./internal/streams/stream */ "./node_modules/readable-stream/lib/internal/streams/stream-browser.js");
/*</replacement>*/

/*<replacement>*/

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = __webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js");
util.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/*</replacement>*/

/*<replacement>*/
var debugUtil = __webpack_require__(/*! util */ 0);
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = __webpack_require__(/*! ./internal/streams/BufferList */ "./node_modules/readable-stream/lib/internal/streams/BufferList.js");
var destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ "./node_modules/readable-stream/lib/internal/streams/destroy.js");
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ "./node_modules/string_decoder/lib/string_decoder.js").StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ "./node_modules/string_decoder/lib/string_decoder.js").StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_transform.js":
/*!***************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_transform.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.



module.exports = Transform;

var Duplex = __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");

/*<replacement>*/
var util = __webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js");
util.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_writable.js":
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_writable.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, setImmediate, global) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.



/*<replacement>*/

var pna = __webpack_require__(/*! process-nextick-args */ "./node_modules/process-nextick-args/index.js");
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = __webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js");
util.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: __webpack_require__(/*! util-deprecate */ "./node_modules/util-deprecate/browser.js")
};
/*</replacement>*/

/*<replacement>*/
var Stream = __webpack_require__(/*! ./internal/streams/stream */ "./node_modules/readable-stream/lib/internal/streams/stream-browser.js");
/*</replacement>*/

/*<replacement>*/

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

var destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ "./node_modules/readable-stream/lib/internal/streams/destroy.js");

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  pna.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js"), __webpack_require__(/*! ./../../timers-browserify/main.js */ "./node_modules/timers-browserify/main.js").setImmediate, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/BufferList.js":
/*!*************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/BufferList.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer;
var util = __webpack_require__(/*! util */ 1);

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/destroy.js":
/*!**********************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/destroy.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*<replacement>*/

var pna = __webpack_require__(/*! process-nextick-args */ "./node_modules/process-nextick-args/index.js");
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/stream-browser.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/stream-browser.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter;


/***/ }),

/***/ "./node_modules/readable-stream/passthrough.js":
/*!*****************************************************!*\
  !*** ./node_modules/readable-stream/passthrough.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./readable */ "./node_modules/readable-stream/readable-browser.js").PassThrough


/***/ }),

/***/ "./node_modules/readable-stream/readable-browser.js":
/*!**********************************************************!*\
  !*** ./node_modules/readable-stream/readable-browser.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ./lib/_stream_readable.js */ "./node_modules/readable-stream/lib/_stream_readable.js");
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = __webpack_require__(/*! ./lib/_stream_writable.js */ "./node_modules/readable-stream/lib/_stream_writable.js");
exports.Duplex = __webpack_require__(/*! ./lib/_stream_duplex.js */ "./node_modules/readable-stream/lib/_stream_duplex.js");
exports.Transform = __webpack_require__(/*! ./lib/_stream_transform.js */ "./node_modules/readable-stream/lib/_stream_transform.js");
exports.PassThrough = __webpack_require__(/*! ./lib/_stream_passthrough.js */ "./node_modules/readable-stream/lib/_stream_passthrough.js");


/***/ }),

/***/ "./node_modules/readable-stream/transform.js":
/*!***************************************************!*\
  !*** ./node_modules/readable-stream/transform.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./readable */ "./node_modules/readable-stream/readable-browser.js").Transform


/***/ }),

/***/ "./node_modules/readable-stream/writable-browser.js":
/*!**********************************************************!*\
  !*** ./node_modules/readable-stream/writable-browser.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./lib/_stream_writable.js */ "./node_modules/readable-stream/lib/_stream_writable.js");


/***/ }),

/***/ "./node_modules/ripemd160/index.js":
/*!*****************************************!*\
  !*** ./node_modules/ripemd160/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js").Buffer
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var HashBase = __webpack_require__(/*! hash-base */ "./node_modules/hash-base/index.js")

var ARRAY16 = new Array(16)

var zl = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
]

var zr = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
]

var sl = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
]

var sr = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
]

var hl = [0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e]
var hr = [0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000]

function RIPEMD160 () {
  HashBase.call(this, 64)

  // state
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0
}

inherits(RIPEMD160, HashBase)

RIPEMD160.prototype._update = function () {
  var words = ARRAY16
  for (var j = 0; j < 16; ++j) words[j] = this._block.readInt32LE(j * 4)

  var al = this._a | 0
  var bl = this._b | 0
  var cl = this._c | 0
  var dl = this._d | 0
  var el = this._e | 0

  var ar = this._a | 0
  var br = this._b | 0
  var cr = this._c | 0
  var dr = this._d | 0
  var er = this._e | 0

  // computation
  for (var i = 0; i < 80; i += 1) {
    var tl
    var tr
    if (i < 16) {
      tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i])
      tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i])
    } else if (i < 32) {
      tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i])
      tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i])
    } else if (i < 48) {
      tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i])
      tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i])
    } else if (i < 64) {
      tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i])
      tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i])
    } else { // if (i<80) {
      tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i])
      tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i])
    }

    al = el
    el = dl
    dl = rotl(cl, 10)
    cl = bl
    bl = tl

    ar = er
    er = dr
    dr = rotl(cr, 10)
    cr = br
    br = tr
  }

  // update state
  var t = (this._b + cl + dr) | 0
  this._b = (this._c + dl + er) | 0
  this._c = (this._d + el + ar) | 0
  this._d = (this._e + al + br) | 0
  this._e = (this._a + bl + cr) | 0
  this._a = t
}

RIPEMD160.prototype._digest = function () {
  // create padding and handle blocks
  this._block[this._blockOffset++] = 0x80
  if (this._blockOffset > 56) {
    this._block.fill(0, this._blockOffset, 64)
    this._update()
    this._blockOffset = 0
  }

  this._block.fill(0, this._blockOffset, 56)
  this._block.writeUInt32LE(this._length[0], 56)
  this._block.writeUInt32LE(this._length[1], 60)
  this._update()

  // produce result
  var buffer = Buffer.alloc ? Buffer.alloc(20) : new Buffer(20)
  buffer.writeInt32LE(this._a, 0)
  buffer.writeInt32LE(this._b, 4)
  buffer.writeInt32LE(this._c, 8)
  buffer.writeInt32LE(this._d, 12)
  buffer.writeInt32LE(this._e, 16)
  return buffer
}

function rotl (x, n) {
  return (x << n) | (x >>> (32 - n))
}

function fn1 (a, b, c, d, e, m, k, s) {
  return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + e) | 0
}

function fn2 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + e) | 0
}

function fn3 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b | (~c)) ^ d) + m + k) | 0, s) + e) | 0
}

function fn4 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + e) | 0
}

function fn5 (a, b, c, d, e, m, k, s) {
  return (rotl((a + (b ^ (c | (~d))) + m + k) | 0, s) + e) | 0
}

module.exports = RIPEMD160


/***/ }),

/***/ "./node_modules/safe-buffer/index.js":
/*!*******************************************!*\
  !*** ./node_modules/safe-buffer/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 68
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/sha.js/hash.js":
/*!*************************************!*\
  !*** ./node_modules/sha.js/hash.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

// prototype class for hash functions
function Hash (blockSize, finalSize) {
  this._block = Buffer.alloc(blockSize)
  this._finalSize = finalSize
  this._blockSize = blockSize
  this._len = 0
}

Hash.prototype.update = function (data, enc) {
  if (typeof data === 'string') {
    enc = enc || 'utf8'
    data = Buffer.from(data, enc)
  }

  var block = this._block
  var blockSize = this._blockSize
  var length = data.length
  var accum = this._len

  for (var offset = 0; offset < length;) {
    var assigned = accum % blockSize
    var remainder = Math.min(length - offset, blockSize - assigned)

    for (var i = 0; i < remainder; i++) {
      block[assigned + i] = data[offset + i]
    }

    accum += remainder
    offset += remainder

    if ((accum % blockSize) === 0) {
      this._update(block)
    }
  }

  this._len += length
  return this
}

Hash.prototype.digest = function (enc) {
  var rem = this._len % this._blockSize

  this._block[rem] = 0x80

  // zero (rem + 1) trailing bits, where (rem + 1) is the smallest
  // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize
  this._block.fill(0, rem + 1)

  if (rem >= this._finalSize) {
    this._update(this._block)
    this._block.fill(0)
  }

  var bits = this._len * 8

  // uint32
  if (bits <= 0xffffffff) {
    this._block.writeUInt32BE(bits, this._blockSize - 4)

  // uint64
  } else {
    var lowBits = (bits & 0xffffffff) >>> 0
    var highBits = (bits - lowBits) / 0x100000000

    this._block.writeUInt32BE(highBits, this._blockSize - 8)
    this._block.writeUInt32BE(lowBits, this._blockSize - 4)
  }

  this._update(this._block)
  var hash = this._hash()

  return enc ? hash.toString(enc) : hash
}

Hash.prototype._update = function () {
  throw new Error('_update must be implemented by subclass')
}

module.exports = Hash


/***/ }),

/***/ "./node_modules/sha.js/index.js":
/*!**************************************!*\
  !*** ./node_modules/sha.js/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var exports = module.exports = function SHA (algorithm) {
  algorithm = algorithm.toLowerCase()

  var Algorithm = exports[algorithm]
  if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)')

  return new Algorithm()
}

exports.sha = __webpack_require__(/*! ./sha */ "./node_modules/sha.js/sha.js")
exports.sha1 = __webpack_require__(/*! ./sha1 */ "./node_modules/sha.js/sha1.js")
exports.sha224 = __webpack_require__(/*! ./sha224 */ "./node_modules/sha.js/sha224.js")
exports.sha256 = __webpack_require__(/*! ./sha256 */ "./node_modules/sha.js/sha256.js")
exports.sha384 = __webpack_require__(/*! ./sha384 */ "./node_modules/sha.js/sha384.js")
exports.sha512 = __webpack_require__(/*! ./sha512 */ "./node_modules/sha.js/sha512.js")


/***/ }),

/***/ "./node_modules/sha.js/sha.js":
/*!************************************!*\
  !*** ./node_modules/sha.js/sha.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
 * in FIPS PUB 180-1
 * This source code is derived from sha1.js of the same repository.
 * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
 * operation was added.
 */

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var Hash = __webpack_require__(/*! ./hash */ "./node_modules/sha.js/hash.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha, Hash)

Sha.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha.prototype._hash = function () {
  var H = Buffer.allocUnsafe(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha


/***/ }),

/***/ "./node_modules/sha.js/sha1.js":
/*!*************************************!*\
  !*** ./node_modules/sha.js/sha1.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var Hash = __webpack_require__(/*! ./hash */ "./node_modules/sha.js/hash.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha1 () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha1, Hash)

Sha1.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl1 (num) {
  return (num << 1) | (num >>> 31)
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha1.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16])

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha1.prototype._hash = function () {
  var H = Buffer.allocUnsafe(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha1


/***/ }),

/***/ "./node_modules/sha.js/sha224.js":
/*!***************************************!*\
  !*** ./node_modules/sha.js/sha224.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var Sha256 = __webpack_require__(/*! ./sha256 */ "./node_modules/sha.js/sha256.js")
var Hash = __webpack_require__(/*! ./hash */ "./node_modules/sha.js/hash.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

var W = new Array(64)

function Sha224 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha224, Sha256)

Sha224.prototype.init = function () {
  this._a = 0xc1059ed8
  this._b = 0x367cd507
  this._c = 0x3070dd17
  this._d = 0xf70e5939
  this._e = 0xffc00b31
  this._f = 0x68581511
  this._g = 0x64f98fa7
  this._h = 0xbefa4fa4

  return this
}

Sha224.prototype._hash = function () {
  var H = Buffer.allocUnsafe(28)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)

  return H
}

module.exports = Sha224


/***/ }),

/***/ "./node_modules/sha.js/sha256.js":
/*!***************************************!*\
  !*** ./node_modules/sha.js/sha256.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var Hash = __webpack_require__(/*! ./hash */ "./node_modules/sha.js/hash.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

var K = [
  0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
  0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
  0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
  0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
  0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
  0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
  0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
  0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
  0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
  0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
  0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
  0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
  0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
  0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
  0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
  0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
]

var W = new Array(64)

function Sha256 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha256, Hash)

Sha256.prototype.init = function () {
  this._a = 0x6a09e667
  this._b = 0xbb67ae85
  this._c = 0x3c6ef372
  this._d = 0xa54ff53a
  this._e = 0x510e527f
  this._f = 0x9b05688c
  this._g = 0x1f83d9ab
  this._h = 0x5be0cd19

  return this
}

function ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x) {
  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10)
}

function sigma1 (x) {
  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7)
}

function gamma0 (x) {
  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3)
}

function gamma1 (x) {
  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10)
}

Sha256.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0
  var f = this._f | 0
  var g = this._g | 0
  var h = this._h | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 64; ++i) W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0

  for (var j = 0; j < 64; ++j) {
    var T1 = (h + sigma1(e) + ch(e, f, g) + K[j] + W[j]) | 0
    var T2 = (sigma0(a) + maj(a, b, c)) | 0

    h = g
    g = f
    f = e
    e = (d + T1) | 0
    d = c
    c = b
    b = a
    a = (T1 + T2) | 0
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
  this._f = (f + this._f) | 0
  this._g = (g + this._g) | 0
  this._h = (h + this._h) | 0
}

Sha256.prototype._hash = function () {
  var H = Buffer.allocUnsafe(32)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)
  H.writeInt32BE(this._h, 28)

  return H
}

module.exports = Sha256


/***/ }),

/***/ "./node_modules/sha.js/sha384.js":
/*!***************************************!*\
  !*** ./node_modules/sha.js/sha384.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var SHA512 = __webpack_require__(/*! ./sha512 */ "./node_modules/sha.js/sha512.js")
var Hash = __webpack_require__(/*! ./hash */ "./node_modules/sha.js/hash.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

var W = new Array(160)

function Sha384 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha384, SHA512)

Sha384.prototype.init = function () {
  this._ah = 0xcbbb9d5d
  this._bh = 0x629a292a
  this._ch = 0x9159015a
  this._dh = 0x152fecd8
  this._eh = 0x67332667
  this._fh = 0x8eb44a87
  this._gh = 0xdb0c2e0d
  this._hh = 0x47b5481d

  this._al = 0xc1059ed8
  this._bl = 0x367cd507
  this._cl = 0x3070dd17
  this._dl = 0xf70e5939
  this._el = 0xffc00b31
  this._fl = 0x68581511
  this._gl = 0x64f98fa7
  this._hl = 0xbefa4fa4

  return this
}

Sha384.prototype._hash = function () {
  var H = Buffer.allocUnsafe(48)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)

  return H
}

module.exports = Sha384


/***/ }),

/***/ "./node_modules/sha.js/sha512.js":
/*!***************************************!*\
  !*** ./node_modules/sha.js/sha512.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var Hash = __webpack_require__(/*! ./hash */ "./node_modules/sha.js/hash.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

var K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
]

var W = new Array(160)

function Sha512 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha512, Hash)

Sha512.prototype.init = function () {
  this._ah = 0x6a09e667
  this._bh = 0xbb67ae85
  this._ch = 0x3c6ef372
  this._dh = 0xa54ff53a
  this._eh = 0x510e527f
  this._fh = 0x9b05688c
  this._gh = 0x1f83d9ab
  this._hh = 0x5be0cd19

  this._al = 0xf3bcc908
  this._bl = 0x84caa73b
  this._cl = 0xfe94f82b
  this._dl = 0x5f1d36f1
  this._el = 0xade682d1
  this._fl = 0x2b3e6c1f
  this._gl = 0xfb41bd6b
  this._hl = 0x137e2179

  return this
}

function Ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x, xl) {
  return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25)
}

function sigma1 (x, xl) {
  return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23)
}

function Gamma0 (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7)
}

function Gamma0l (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25)
}

function Gamma1 (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6)
}

function Gamma1l (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26)
}

function getCarry (a, b) {
  return (a >>> 0) < (b >>> 0) ? 1 : 0
}

Sha512.prototype._update = function (M) {
  var W = this._w

  var ah = this._ah | 0
  var bh = this._bh | 0
  var ch = this._ch | 0
  var dh = this._dh | 0
  var eh = this._eh | 0
  var fh = this._fh | 0
  var gh = this._gh | 0
  var hh = this._hh | 0

  var al = this._al | 0
  var bl = this._bl | 0
  var cl = this._cl | 0
  var dl = this._dl | 0
  var el = this._el | 0
  var fl = this._fl | 0
  var gl = this._gl | 0
  var hl = this._hl | 0

  for (var i = 0; i < 32; i += 2) {
    W[i] = M.readInt32BE(i * 4)
    W[i + 1] = M.readInt32BE(i * 4 + 4)
  }
  for (; i < 160; i += 2) {
    var xh = W[i - 15 * 2]
    var xl = W[i - 15 * 2 + 1]
    var gamma0 = Gamma0(xh, xl)
    var gamma0l = Gamma0l(xl, xh)

    xh = W[i - 2 * 2]
    xl = W[i - 2 * 2 + 1]
    var gamma1 = Gamma1(xh, xl)
    var gamma1l = Gamma1l(xl, xh)

    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
    var Wi7h = W[i - 7 * 2]
    var Wi7l = W[i - 7 * 2 + 1]

    var Wi16h = W[i - 16 * 2]
    var Wi16l = W[i - 16 * 2 + 1]

    var Wil = (gamma0l + Wi7l) | 0
    var Wih = (gamma0 + Wi7h + getCarry(Wil, gamma0l)) | 0
    Wil = (Wil + gamma1l) | 0
    Wih = (Wih + gamma1 + getCarry(Wil, gamma1l)) | 0
    Wil = (Wil + Wi16l) | 0
    Wih = (Wih + Wi16h + getCarry(Wil, Wi16l)) | 0

    W[i] = Wih
    W[i + 1] = Wil
  }

  for (var j = 0; j < 160; j += 2) {
    Wih = W[j]
    Wil = W[j + 1]

    var majh = maj(ah, bh, ch)
    var majl = maj(al, bl, cl)

    var sigma0h = sigma0(ah, al)
    var sigma0l = sigma0(al, ah)
    var sigma1h = sigma1(eh, el)
    var sigma1l = sigma1(el, eh)

    // t1 = h + sigma1 + ch + K[j] + W[j]
    var Kih = K[j]
    var Kil = K[j + 1]

    var chh = Ch(eh, fh, gh)
    var chl = Ch(el, fl, gl)

    var t1l = (hl + sigma1l) | 0
    var t1h = (hh + sigma1h + getCarry(t1l, hl)) | 0
    t1l = (t1l + chl) | 0
    t1h = (t1h + chh + getCarry(t1l, chl)) | 0
    t1l = (t1l + Kil) | 0
    t1h = (t1h + Kih + getCarry(t1l, Kil)) | 0
    t1l = (t1l + Wil) | 0
    t1h = (t1h + Wih + getCarry(t1l, Wil)) | 0

    // t2 = sigma0 + maj
    var t2l = (sigma0l + majl) | 0
    var t2h = (sigma0h + majh + getCarry(t2l, sigma0l)) | 0

    hh = gh
    hl = gl
    gh = fh
    gl = fl
    fh = eh
    fl = el
    el = (dl + t1l) | 0
    eh = (dh + t1h + getCarry(el, dl)) | 0
    dh = ch
    dl = cl
    ch = bh
    cl = bl
    bh = ah
    bl = al
    al = (t1l + t2l) | 0
    ah = (t1h + t2h + getCarry(al, t1l)) | 0
  }

  this._al = (this._al + al) | 0
  this._bl = (this._bl + bl) | 0
  this._cl = (this._cl + cl) | 0
  this._dl = (this._dl + dl) | 0
  this._el = (this._el + el) | 0
  this._fl = (this._fl + fl) | 0
  this._gl = (this._gl + gl) | 0
  this._hl = (this._hl + hl) | 0

  this._ah = (this._ah + ah + getCarry(this._al, al)) | 0
  this._bh = (this._bh + bh + getCarry(this._bl, bl)) | 0
  this._ch = (this._ch + ch + getCarry(this._cl, cl)) | 0
  this._dh = (this._dh + dh + getCarry(this._dl, dl)) | 0
  this._eh = (this._eh + eh + getCarry(this._el, el)) | 0
  this._fh = (this._fh + fh + getCarry(this._fl, fl)) | 0
  this._gh = (this._gh + gh + getCarry(this._gl, gl)) | 0
  this._hh = (this._hh + hh + getCarry(this._hl, hl)) | 0
}

Sha512.prototype._hash = function () {
  var H = Buffer.allocUnsafe(64)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)
  writeInt64BE(this._gh, this._gl, 48)
  writeInt64BE(this._hh, this._hl, 56)

  return H
}

module.exports = Sha512


/***/ }),

/***/ "./node_modules/stream-browserify/index.js":
/*!*************************************************!*\
  !*** ./node_modules/stream-browserify/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = __webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter;
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

inherits(Stream, EE);
Stream.Readable = __webpack_require__(/*! readable-stream/readable.js */ "./node_modules/readable-stream/readable-browser.js");
Stream.Writable = __webpack_require__(/*! readable-stream/writable.js */ "./node_modules/readable-stream/writable-browser.js");
Stream.Duplex = __webpack_require__(/*! readable-stream/duplex.js */ "./node_modules/readable-stream/duplex-browser.js");
Stream.Transform = __webpack_require__(/*! readable-stream/transform.js */ "./node_modules/readable-stream/transform.js");
Stream.PassThrough = __webpack_require__(/*! readable-stream/passthrough.js */ "./node_modules/readable-stream/passthrough.js");

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};


/***/ }),

/***/ "./node_modules/string_decoder/lib/string_decoder.js":
/*!***********************************************************!*\
  !*** ./node_modules/string_decoder/lib/string_decoder.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var stylesInDom = {};

var isOldIE = function isOldIE() {
  var memo;
  return function memorize() {
    if (typeof memo === 'undefined') {
      // Test for IE <= 9 as proposed by Browserhacks
      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
      // Tests for existence of standard globals is to allow style-loader
      // to operate correctly into non-standard environments
      // @see https://github.com/webpack-contrib/style-loader/issues/177
      memo = Boolean(window && document && document.all && !window.atob);
    }

    return memo;
  };
}();

var getTarget = function getTarget() {
  var memo = {};
  return function memorize(target) {
    if (typeof memo[target] === 'undefined') {
      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
        try {
          // This will throw an exception if access to iframe is blocked
          // due to cross-origin restrictions
          styleTarget = styleTarget.contentDocument.head;
        } catch (e) {
          // istanbul ignore next
          styleTarget = null;
        }
      }

      memo[target] = styleTarget;
    }

    return memo[target];
  };
}();

function listToStyles(list, options) {
  var styles = [];
  var newStyles = {};

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var css = item[1];
    var media = item[2];
    var sourceMap = item[3];
    var part = {
      css: css,
      media: media,
      sourceMap: sourceMap
    };

    if (!newStyles[id]) {
      styles.push(newStyles[id] = {
        id: id,
        parts: [part]
      });
    } else {
      newStyles[id].parts.push(part);
    }
  }

  return styles;
}

function addStylesToDom(styles, options) {
  for (var i = 0; i < styles.length; i++) {
    var item = styles[i];
    var domStyle = stylesInDom[item.id];
    var j = 0;

    if (domStyle) {
      domStyle.refs++;

      for (; j < domStyle.parts.length; j++) {
        domStyle.parts[j](item.parts[j]);
      }

      for (; j < item.parts.length; j++) {
        domStyle.parts.push(addStyle(item.parts[j], options));
      }
    } else {
      var parts = [];

      for (; j < item.parts.length; j++) {
        parts.push(addStyle(item.parts[j], options));
      }

      stylesInDom[item.id] = {
        id: item.id,
        refs: 1,
        parts: parts
      };
    }
  }
}

function insertStyleElement(options) {
  var style = document.createElement('style');

  if (typeof options.attributes.nonce === 'undefined') {
    var nonce =  true ? __webpack_require__.nc : undefined;

    if (nonce) {
      options.attributes.nonce = nonce;
    }
  }

  Object.keys(options.attributes).forEach(function (key) {
    style.setAttribute(key, options.attributes[key]);
  });

  if (typeof options.insert === 'function') {
    options.insert(style);
  } else {
    var target = getTarget(options.insert || 'head');

    if (!target) {
      throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
    }

    target.appendChild(style);
  }

  return style;
}

function removeStyleElement(style) {
  // istanbul ignore if
  if (style.parentNode === null) {
    return false;
  }

  style.parentNode.removeChild(style);
}
/* istanbul ignore next  */


var replaceText = function replaceText() {
  var textStore = [];
  return function replace(index, replacement) {
    textStore[index] = replacement;
    return textStore.filter(Boolean).join('\n');
  };
}();

function applyToSingletonTag(style, index, remove, obj) {
  var css = remove ? '' : obj.css; // For old IE

  /* istanbul ignore if  */

  if (style.styleSheet) {
    style.styleSheet.cssText = replaceText(index, css);
  } else {
    var cssNode = document.createTextNode(css);
    var childNodes = style.childNodes;

    if (childNodes[index]) {
      style.removeChild(childNodes[index]);
    }

    if (childNodes.length) {
      style.insertBefore(cssNode, childNodes[index]);
    } else {
      style.appendChild(cssNode);
    }
  }
}

function applyToTag(style, options, obj) {
  var css = obj.css;
  var media = obj.media;
  var sourceMap = obj.sourceMap;

  if (media) {
    style.setAttribute('media', media);
  }

  if (sourceMap && btoa) {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    while (style.firstChild) {
      style.removeChild(style.firstChild);
    }

    style.appendChild(document.createTextNode(css));
  }
}

var singleton = null;
var singletonCounter = 0;

function addStyle(obj, options) {
  var style;
  var update;
  var remove;

  if (options.singleton) {
    var styleIndex = singletonCounter++;
    style = singleton || (singleton = insertStyleElement(options));
    update = applyToSingletonTag.bind(null, style, styleIndex, false);
    remove = applyToSingletonTag.bind(null, style, styleIndex, true);
  } else {
    style = insertStyleElement(options);
    update = applyToTag.bind(null, style, options);

    remove = function remove() {
      removeStyleElement(style);
    };
  }

  update(obj);
  return function updateStyle(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {
        return;
      }

      update(obj = newObj);
    } else {
      remove();
    }
  };
}

module.exports = function (list, options) {
  options = options || {};
  options.attributes = typeof options.attributes === 'object' ? options.attributes : {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
  // tags it will allow on a page

  if (!options.singleton && typeof options.singleton !== 'boolean') {
    options.singleton = isOldIE();
  }

  var styles = listToStyles(list, options);
  addStylesToDom(styles, options);
  return function update(newList) {
    var mayRemove = [];

    for (var i = 0; i < styles.length; i++) {
      var item = styles[i];
      var domStyle = stylesInDom[item.id];

      if (domStyle) {
        domStyle.refs--;
        mayRemove.push(domStyle);
      }
    }

    if (newList) {
      var newStyles = listToStyles(newList, options);
      addStylesToDom(newStyles, options);
    }

    for (var _i = 0; _i < mayRemove.length; _i++) {
      var _domStyle = mayRemove[_i];

      if (_domStyle.refs === 0) {
        for (var j = 0; j < _domStyle.parts.length; j++) {
          _domStyle.parts[j]();
        }

        delete stylesInDom[_domStyle.id];
      }
    }
  };
};

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||
            (typeof self !== "undefined" && self) ||
            window;
var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(scope, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(/*! setimmediate */ "./node_modules/setimmediate/setImmediate.js");
// On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
                       (typeof global !== "undefined" && global.setImmediate) ||
                       (this && this.setImmediate);
exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
                         (typeof global !== "undefined" && global.clearImmediate) ||
                         (this && this.clearImmediate);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/util-deprecate/browser.js":
/*!************************************************!*\
  !*** ./node_modules/util-deprecate/browser.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {
/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/vm-browserify/index.js":
/*!*********************************************!*\
  !*** ./node_modules/vm-browserify/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var indexOf = function (xs, item) {
    if (xs.indexOf) return xs.indexOf(item);
    else for (var i = 0; i < xs.length; i++) {
        if (xs[i] === item) return i;
    }
    return -1;
};
var Object_keys = function (obj) {
    if (Object.keys) return Object.keys(obj)
    else {
        var res = [];
        for (var key in obj) res.push(key)
        return res;
    }
};

var forEach = function (xs, fn) {
    if (xs.forEach) return xs.forEach(fn)
    else for (var i = 0; i < xs.length; i++) {
        fn(xs[i], i, xs);
    }
};

var defineProp = (function() {
    try {
        Object.defineProperty({}, '_', {});
        return function(obj, name, value) {
            Object.defineProperty(obj, name, {
                writable: true,
                enumerable: false,
                configurable: true,
                value: value
            })
        };
    } catch(e) {
        return function(obj, name, value) {
            obj[name] = value;
        };
    }
}());

var globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function',
'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError',
'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError',
'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape',
'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];

function Context() {}
Context.prototype = {};

var Script = exports.Script = function NodeScript (code) {
    if (!(this instanceof Script)) return new Script(code);
    this.code = code;
};

Script.prototype.runInContext = function (context) {
    if (!(context instanceof Context)) {
        throw new TypeError("needs a 'context' argument.");
    }
    
    var iframe = document.createElement('iframe');
    if (!iframe.style) iframe.style = {};
    iframe.style.display = 'none';
    
    document.body.appendChild(iframe);
    
    var win = iframe.contentWindow;
    var wEval = win.eval, wExecScript = win.execScript;

    if (!wEval && wExecScript) {
        // win.eval() magically appears when this is called in IE:
        wExecScript.call(win, 'null');
        wEval = win.eval;
    }
    
    forEach(Object_keys(context), function (key) {
        win[key] = context[key];
    });
    forEach(globals, function (key) {
        if (context[key]) {
            win[key] = context[key];
        }
    });
    
    var winKeys = Object_keys(win);

    var res = wEval.call(win, this.code);
    
    forEach(Object_keys(win), function (key) {
        // Avoid copying circular objects like `top` and `window` by only
        // updating existing context properties or new properties in the `win`
        // that was only introduced after the eval.
        if (key in context || indexOf(winKeys, key) === -1) {
            context[key] = win[key];
        }
    });

    forEach(globals, function (key) {
        if (!(key in context)) {
            defineProp(context, key, win[key]);
        }
    });
    
    document.body.removeChild(iframe);
    
    return res;
};

Script.prototype.runInThisContext = function () {
    return eval(this.code); // maybe...
};

Script.prototype.runInNewContext = function (context) {
    var ctx = Script.createContext(context);
    var res = this.runInContext(ctx);

    if (context) {
        forEach(Object_keys(ctx), function (key) {
            context[key] = ctx[key];
        });
    }

    return res;
};

forEach(Object_keys(Script.prototype), function (name) {
    exports[name] = Script[name] = function (code) {
        var s = Script(code);
        return s[name].apply(s, [].slice.call(arguments, 1));
    };
});

exports.isContext = function (context) {
    return context instanceof Context;
};

exports.createScript = function (code) {
    return exports.Script(code);
};

exports.createContext = Script.createContext = function (context) {
    var copy = new Context();
    if(typeof context === 'object') {
        forEach(Object_keys(context), function (key) {
            copy[key] = context[key];
        });
    }
    return copy;
};


/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var handtrackjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! handtrackjs */ "./node_modules/handtrackjs/src/index.js");
/* harmony import */ var _style_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./style.css */ "./src/style.css");
/* harmony import */ var _style_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_style_css__WEBPACK_IMPORTED_MODULE_1__);



const video = document.getElementById("srcvideo");
const canvas = document.getElementById("canvas");
const context = canvas.getContext("2d");
const trackButton = document.getElementById("track");
const pointer = document.getElementById("pointer");
let updateNote = document.getElementById("updatenote");
let log = document.getElementById("log");


let isVideo = false;
let model = null;
let lastMidX = -100;
let lastMidY = -100;

const modelParams = {
    flipHorizontal: true,   // flip e.g for video  
    maxNumBoxes: 1,        // maximum number of boxes to detect
    iouThreshold: 0.5,      // ioU threshold for non-max suppression
    scoreThreshold: 0.6,    // confidence threshold for predictions.
}

function startVideo() {
    handtrackjs__WEBPACK_IMPORTED_MODULE_0__["startVideo"](video).then(function (status) {
        console.log("video started", status);
        if (status) {
            updateNote.innerText = "Video started. Now tracking"
            isVideo = true
            runDetection()
        } else {
            updateNote.innerText = "Please enable video"
        }
    });
}

function toggleVideo() {
    if (!isVideo) {
        updateNote.innerText = "Starting video"
        startVideo();
    } else {
        updateNote.innerText = "Stopping video"
        handtrackjs__WEBPACK_IMPORTED_MODULE_0__["stopVideo"](video)
        isVideo = false;
        updateNote.innerText = "Video stopped"
    }
}

trackButton.addEventListener("click", function () {
    toggleVideo();
});

function moveCursor(x, y) {
    pointer.style.position = "absolute";
    pointer.style.left = (x - pointer.clientWidth / 2) + 'px';
    pointer.style.top = (y - pointer.clientHeight / 2) + 'px';

}

function processPrediction(prediction) {
    const [x, y, width, height] = prediction.bbox;
    let midX = Math.round(x + (width / 2));
    let screenX = Math.round(document.body.clientWidth * (midX / video.width));
    let midY = Math.round(y + (height / 2));
    let screenY = Math.round(document.body.clientHeight * (midY / video.height));
    log.innerText += `score: ${Math.round(prediction.score)} (x,y): (${midX},${midY}) 
    diff: (${lastMidX - midX},${lastMidY - midY})\n`;
    // console.log('doc: ', document.body.clientWidth, document.body.clientHeight);
    // console.log('vid: ', x, y, width, height);
    // console.log('sceen: ', screenX, screenY);
    lastMidX = midX;
    lastMidY = midY;
    moveCursor(screenX, screenY);

}
function runDetection() {
    model.detect(video).then(predictions => {

        model.renderPredictions(predictions, canvas, context, video);
        console.log(predictions);

        if (predictions[0]) {
            processPrediction(predictions[0]);
        }
        if (isVideo) {
            requestAnimationFrame(runDetection);
        }
    });
}

// Load the model.
handtrackjs__WEBPACK_IMPORTED_MODULE_0__["load"](modelParams).then(lmodel => {
    // detect objects in the image.
    model = lmodel
    updateNote.innerText = "Loaded Model!"
    trackButton.disabled = false
});


/***/ }),

/***/ "./src/style.css":
/*!***********************!*\
  !*** ./src/style.css ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var content = __webpack_require__(/*! !../node_modules/css-loader/dist/cjs.js!./style.css */ "./node_modules/css-loader/dist/cjs.js!./src/style.css");

if (typeof content === 'string') {
  content = [[module.i, content, '']];
}

var options = {}

options.insert = "head";
options.singleton = false;

var update = __webpack_require__(/*! ../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js")(content, options);

if (content.locals) {
  module.exports = content.locals;
}


/***/ }),

/***/ 0:
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 1:
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 2:
/*!************************!*\
  !*** buffer (ignored) ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 3:
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29udmVydGVyL2Rpc3QvdGYtY29udmVydGVyLmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3QvdGYtY29yZS5lc20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtbGF5ZXJzL2Rpc3QvdGYtbGF5ZXJzLmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy9kaXN0L3RmLmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXNuMS5qcy9saWIvYXNuMS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXNuMS5qcy9saWIvYXNuMS9hcGkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FzbjEuanMvbGliL2FzbjEvYmFzZS9idWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FzbjEuanMvbGliL2FzbjEvYmFzZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXNuMS5qcy9saWIvYXNuMS9iYXNlL25vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FzbjEuanMvbGliL2FzbjEvYmFzZS9yZXBvcnRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXNuMS5qcy9saWIvYXNuMS9jb25zdGFudHMvZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hc24xLmpzL2xpYi9hc24xL2NvbnN0YW50cy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXNuMS5qcy9saWIvYXNuMS9kZWNvZGVycy9kZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FzbjEuanMvbGliL2FzbjEvZGVjb2RlcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FzbjEuanMvbGliL2FzbjEvZGVjb2RlcnMvcGVtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hc24xLmpzL2xpYi9hc24xL2VuY29kZXJzL2Rlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXNuMS5qcy9saWIvYXNuMS9lbmNvZGVycy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXNuMS5qcy9saWIvYXNuMS9lbmNvZGVycy9wZW0uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYm4uanMvbGliL2JuLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9icm9yYW5kL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9hZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL2F1dGhDaXBoZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL2RlY3J5cHRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvZW5jcnlwdGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9naGFzaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvaW5jcjMyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9tb2Rlcy9jYmMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL21vZGVzL2NmYi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvbW9kZXMvY2ZiMS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvbW9kZXMvY2ZiOC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvbW9kZXMvY3RyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9tb2Rlcy9lY2IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL21vZGVzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9tb2Rlcy9vZmIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL3N0cmVhbUNpcGhlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1jaXBoZXIvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1kZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktZGVzL21vZGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXJzYS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL2FsZ29zLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vYnJvd3Nlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL2Jyb3dzZXIvc2lnbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL2Jyb3dzZXIvdmVyaWZ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9idWZmZXIteG9yL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NpcGhlci1iYXNlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLXV0aWwtaXMvbGliL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NyZWF0ZS1lY2RoL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NyZWF0ZS1oYXNoL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NyZWF0ZS1oYXNoL21kNS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3JlYXRlLWhtYWMvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3JlYXRlLWhtYWMvbGVnYWN5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc3R5bGUuY3NzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Rlcy5qcy9saWIvZGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kZXMuanMvbGliL2Rlcy9jYmMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Rlcy5qcy9saWIvZGVzL2NpcGhlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVzLmpzL2xpYi9kZXMvZGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kZXMuanMvbGliL2Rlcy9lZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Rlcy5qcy9saWIvZGVzL3V0aWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kaWZmaWUtaGVsbG1hbi9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kaWZmaWUtaGVsbG1hbi9saWIvZGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RpZmZpZS1oZWxsbWFuL2xpYi9nZW5lcmF0ZVByaW1lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy9jdXJ2ZS9iYXNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMvY3VydmUvZWR3YXJkcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljL2N1cnZlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMvY3VydmUvbW9udC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljL2N1cnZlL3Nob3J0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMvY3VydmVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMvZWMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy9lYy9rZXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy9lYy9zaWduYXR1cmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy9lZGRzYS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljL2VkZHNhL2tleS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljL2VkZHNhL3NpZ25hdHVyZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljL3ByZWNvbXB1dGVkL3NlY3AyNTZrMS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljL3V0aWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ldnBfYnl0ZXN0b2tleS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGFuZHRyYWNranMvc3JjL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oYXNoLWJhc2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hhc2guanMvbGliL2hhc2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hhc2guanMvbGliL2hhc2gvY29tbW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oYXNoLmpzL2xpYi9oYXNoL2htYWMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hhc2guanMvbGliL2hhc2gvcmlwZW1kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oYXNoLmpzL2xpYi9oYXNoL3NoYS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9zaGEvMS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9zaGEvMjI0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oYXNoLmpzL2xpYi9oYXNoL3NoYS8yNTYuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hhc2guanMvbGliL2hhc2gvc2hhLzM4NC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9zaGEvNTEyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oYXNoLmpzL2xpYi9oYXNoL3NoYS9jb21tb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hhc2guanMvbGliL2hhc2gvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2htYWMtZHJiZy9saWIvaG1hYy1kcmJnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZDUuanMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21pbGxlci1yYWJpbi9saWIvbXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21pbmltYWxpc3RpYy1hc3NlcnQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21pbmltYWxpc3RpYy1jcnlwdG8tdXRpbHMvbGliL3V0aWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL2FzbjEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvY2VydGlmaWNhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvZml4UHJvYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGFyc2UtYXNuMS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGJrZGYyL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Bia2RmMi9saWIvYXN5bmMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Bia2RmMi9saWIvZGVmYXVsdC1lbmNvZGluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGJrZGYyL2xpYi9wcmVjb25kaXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Bia2RmMi9saWIvc3luYy1icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9jZXNzLW5leHRpY2stYXJncy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wdWJsaWMtZW5jcnlwdC9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wdWJsaWMtZW5jcnlwdC9tZ2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3B1YmxpYy1lbmNyeXB0L3ByaXZhdGVEZWNyeXB0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wdWJsaWMtZW5jcnlwdC9wdWJsaWNFbmNyeXB0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wdWJsaWMtZW5jcnlwdC93aXRoUHVibGljLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wdWJsaWMtZW5jcnlwdC94b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JhbmRvbWJ5dGVzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JhbmRvbWZpbGwvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2R1cGxleC1icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3kuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0tYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUtYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLWJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JpcGVtZDE2MC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2FmZS1idWZmZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NoYS5qcy9oYXNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zaGEuanMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NoYS5qcy9zaGEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NoYS5qcy9zaGExLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zaGEuanMvc2hhMjI0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zaGEuanMvc2hhMjU2LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zaGEuanMvc2hhMzg0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zaGEuanMvc2hhNTEyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3RyaW5nX2RlY29kZXIvbGliL3N0cmluZ19kZWNvZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXRpbC1kZXByZWNhdGUvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdm0tYnJvd3NlcmlmeS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9zdHlsZS5jc3M/OTgxOSIsIndlYnBhY2s6Ly8vdXRpbCAoaWdub3JlZCkiLCJ3ZWJwYWNrOi8vL3V0aWwgKGlnbm9yZWQpPzA1ZTQiLCJ3ZWJwYWNrOi8vL2J1ZmZlciAoaWdub3JlZCkiLCJ3ZWJwYWNrOi8vL2NyeXB0byAoaWdub3JlZCkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtRQUFBO1FBQ0E7O1FBRUE7UUFDQTs7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QUFpRSw2Q0FBNkMsRUFBRSw2Q0FBNkMsRUFBRSxpRUFBaUUsRUFBRSxFQUFFLCtEQUErRCw2Q0FBNkMsRUFBRSxpRUFBaUUsRUFBRSxFQUFFLDZFQUE2RSw2Q0FBNkMsRUFBRSxzRUFBc0UsRUFBRSxzRUFBc0UsRUFBRSxFQUFFLDZEQUE2RCw2Q0FBNkMsRUFBRSxpRUFBaUUsRUFBRSxFQUFFLCtEQUErRCw2Q0FBNkMsRUFBRSxpRUFBaUUsRUFBRSxFQUFFLDZEQUE2RCw2Q0FBNkMsRUFBRSxpRUFBaUUsRUFBRSxFQUFFLDZEQUE2RCw2Q0FBNkMsRUFBRSxpRUFBaUUsRUFBRSxFQUFFLGlFQUFpRSw2Q0FBNkMsRUFBRSxpRUFBaUUsRUFBRSxFQUFFLDZEQUE2RCw2Q0FBNkMsRUFBRSxpRUFBaUUsRUFBRSxFQUFFLDZEQUE2RCw2Q0FBNkMsRUFBRSxpRUFBaUUsRUFBRSxFQUFFLCtEQUErRCw2Q0FBNkMsRUFBRSxpRUFBaUUsRUFBRSxFQUFFLHVFQUF1RSw2Q0FBNkMsRUFBRSxpRUFBaUUsRUFBRSx3REFBd0QsRUFBRSx3REFBd0QsRUFBRSxFQUFFLCtEQUErRCw2Q0FBNkMsRUFBRSxpRUFBaUUsRUFBRSxFQUFFLHFFQUFxRSw2Q0FBNkMsRUFBRSxpRUFBaUUsRUFBRSxFQUFFLDZEQUE2RCw2Q0FBNkMsRUFBRSxpRUFBaUUsRUFBRSxFQUFFLCtEQUErRCw2Q0FBNkMsRUFBRSxpRUFBaUUsRUFBRSxFQUFFLCtEQUErRCw2Q0FBNkMsRUFBRSxpRUFBaUUsRUFBRSxFQUFFLGlFQUFpRSw2Q0FBNkMsRUFBRSxpRUFBaUUsRUFBRSxFQUFFLG1FQUFtRSw2Q0FBNkMsRUFBRSxpRUFBaUUsRUFBRSxFQUFFLDZEQUE2RCw2Q0FBNkMsRUFBRSxpRUFBaUUsRUFBRSxFQUFFLCtEQUErRCw2Q0FBNkMsRUFBRSxpRUFBaUUsRUFBRSxFQUFFLCtEQUErRCw2Q0FBNkMsRUFBRSxpRUFBaUUsRUFBRSxFQUFFLGlFQUFpRSw2Q0FBNkMsRUFBRSxpRUFBaUUsRUFBRSxFQUFFLGlFQUFpRSw2Q0FBNkMsRUFBRSxpRUFBaUUs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QThDLHNCQUFzQix1REFBdUQsNEZBQTRGLGFBQWEsR0FBRyxlQUFpWjtBQUNsL2dPOzs7Ozs7Ozs7Ozs7O0FDakJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQzhRLGdDQUFnQyxZQUFZLGtFQUFZLGVBQWUsc0VBQWMsa0JB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Q0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3puQkEsZUFBZSxtQkFBTyxDQUFDLDZEQUFVOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUN4SEEsZ0JBQWdCLG1CQUFPLENBQUMsd0VBQWM7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3pDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQSxnQkFBZ0IsbUJBQU8sQ0FBQywrREFBTzs7Ozs7Ozs7Ozs7O0FDbEIvQixlQUFlLG1CQUFPLENBQUMsNkRBQVU7O0FBRWpDLFdBQVcsbUJBQU8sQ0FBQyxzREFBWTtBQUMvQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEMsVUFBVTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7O0FDdkpBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw0QkFBNEI7QUFDN0M7QUFDQTs7QUFFQSxpQkFBaUIsYUFBYTtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsaUJBQWlCLGFBQWE7QUFDOUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBOztBQUVBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsNkJBQTZCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDZCQUE2QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFdBQVc7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxXQUFXO0FBQy9EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixPQUFPO0FBQzFCOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCLE9BQU87QUFDNUI7QUFDQTs7QUFFQSx1QkFBdUIsT0FBTztBQUM5QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLEdBQUc7QUFDMUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CLFdBQVc7QUFDOUI7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLFdBQVc7QUFDOUI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCOztBQUVBLGtDQUFrQztBQUNsQyxzQ0FBc0M7QUFDdEM7O0FBRUE7QUFDQSxxQkFBcUIsT0FBTztBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLGNBQWM7QUFDM0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQixRQUFRO0FBQ3ZDO0FBQ0E7O0FBRUEsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLE9BQU87QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIsbUNBQW1DO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQiwrQ0FBK0M7QUFDbEU7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EscUJBQXFCLHNDQUFzQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUseUJBQXlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixjQUFjO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsUUFBUTtBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsUUFBUTtBQUN6QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDLFFBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLG1DQUFtQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkIsbUNBQW1DO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsNkJBQTZCLG1DQUFtQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDZCQUE2QixtQ0FBbUM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLDBCQUEwQjtBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsZ0NBQWdDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsUUFBUTtBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsWUFBWTtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9CQUFvQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0EsNkJBQTZCLFFBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNqSEEsYUFBYSxtQkFBTyxDQUFDLHdEQUFhO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7OztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7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OztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELEVBQUU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGVBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQSxxQkFBcUIsZUFBZTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQsT0FBTztBQUM5RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixZQUFZO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzV2REEsYUFBYSxtQkFBTyxDQUFDLHdEQUFhO0FBQ2xDLGdCQUFnQixtQkFBTyxDQUFDLHlEQUFRO0FBQ2hDLG9CQUFvQixtQkFBTyxDQUFDLDJFQUFnQjtBQUM1QyxlQUFlLG1CQUFPLENBQUMsNkRBQVU7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7OztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzFHQSw2REFBZSxtQkFBTyxDQUFDLHlEQUFVO0FBQ2pDLFNBQVMsbUJBQU8sQ0FBQyw2Q0FBTzs7QUFFeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUMzSFk7QUFDWixlQUFlLG1CQUFPLENBQUMsNkRBQVU7QUFDakMsVUFBVSxtQkFBTyxDQUFDLDhDQUFRO0FBQzFCLGdCQUFnQixtQkFBTyxDQUFDLG9EQUFXO0FBQ25DLFVBQVUsbUJBQU8sQ0FBQyw4Q0FBUTtBQUMxQixXQUFXLG1CQUFPLENBQUMsd0RBQWE7O0FBRWhDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzdCQSxVQUFVLG1CQUFPLENBQUMsOENBQVE7O0FBRTFCO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ0pZO0FBQ1osZUFBZSxtQkFBTyxDQUFDLDZEQUFVO0FBQ2pDLGFBQWEsbUJBQU8sQ0FBQyxzREFBVTtBQUMvQixXQUFXLG1CQUFPLENBQUMsd0RBQWE7QUFDaEMsYUFBYSxtQkFBTyxDQUFDLHdEQUFhO0FBQ2xDLFVBQVUsbUJBQU8sQ0FBQywwREFBaUI7QUFDbkMsZ0JBQWdCLG1CQUFPLENBQUMsb0RBQVc7O0FBRW5DLFVBQVUsbUJBQU8sQ0FBQyw4Q0FBUTs7QUFFMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsZUFBZTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM3RFk7QUFDWixlQUFlLG1CQUFPLENBQUMsNkRBQVU7QUFDakMsYUFBYSxtQkFBTyxDQUFDLHdEQUFhOztBQUVsQyxXQUFXLG1CQUFPLENBQUMsd0RBQWE7O0FBRWhDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixlQUFlO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDN0NZOztBQUVaLCtFQUErRSxtQkFBTyxDQUFDLDBEQUFhO0FBQ3BHLG9DQUFvQyxtQkFBTyxDQUFDLDBEQUFhO0FBQ3pELG9DQUFvQyxtQkFBTyxDQUFDLDBEQUFhOztBQUV6RCxZQUFZLG1CQUFPLENBQUMsc0VBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxtQkFBTyxDQUFDLGdEQUFRO0FBQ3hCO0FBQ0E7O0FBRUEsVUFBVSxtQkFBTyxDQUFDLHNFQUFtQjs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxtQkFBTyxDQUFDLGdFQUFnQjs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLG1CQUFPLENBQUMsd0VBQWlCOztBQUVwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsbUJBQU8sQ0FBQywwREFBYTs7QUFFMUMsb0JBQW9CLG1CQUFPLENBQUMsZ0VBQWdCOztBQUU1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKLFNBQVMsbUJBQU8sQ0FBQyx3REFBWTs7QUFFN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNoR0EsMkJBQTJCLG1CQUFPLENBQUMscUdBQWdEO0FBQ25GO0FBQ0EsY0FBYyxRQUFTLFNBQVMsd0JBQXdCLEdBQUcsVUFBVSx1QkFBdUIsc0JBQXNCLDRCQUE0QixHQUFHLGNBQWMsbUJBQW1CLG9CQUFvQix5QkFBeUIsNEJBQTRCLDZCQUE2QixnQ0FBZ0MseUJBQXlCLGtCQUFrQixtQkFBbUIsR0FBRyxlQUFlLG9CQUFvQixHQUFHOzs7Ozs7Ozs7Ozs7O0FDRmxaOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkMscUJBQXFCO0FBQ2hFOztBQUVBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLHFCQUFxQjtBQUN6Qyw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7O0FBRTlCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0EscURBQXFELGNBQWM7QUFDbkU7QUFDQSxDOzs7Ozs7Ozs7Ozs7QUN6RmE7O0FBRWIsZ0JBQWdCLG1CQUFPLENBQUMsMkRBQWE7QUFDckMsaUJBQWlCLG1CQUFPLENBQUMsNkRBQWM7QUFDdkMsY0FBYyxtQkFBTyxDQUFDLHVEQUFXO0FBQ2pDLGNBQWMsbUJBQU8sQ0FBQyx1REFBVztBQUNqQyxjQUFjLG1CQUFPLENBQUMsdURBQVc7Ozs7Ozs7Ozs7Ozs7QUNOcEI7O0FBRWIsYUFBYSxtQkFBTyxDQUFDLHdFQUFxQjtBQUMxQyxlQUFlLG1CQUFPLENBQUMsNkRBQVU7O0FBRWpDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsb0JBQW9CO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDOztBQUVBOztBQUVBLG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsbUJBQW1CLG9CQUFvQjtBQUN2Qzs7QUFFQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2hFYTs7QUFFYixhQUFhLG1CQUFPLENBQUMsd0VBQXFCOztBQUUxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUSxnQkFBZ0I7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSx3QkFBd0I7QUFDaEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFFBQVEsV0FBVztBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7OztBQzVJYTs7QUFFYixhQUFhLG1CQUFPLENBQUMsd0VBQXFCO0FBQzFDLGVBQWUsbUJBQU8sQ0FBQyw2REFBVTs7QUFFakMsVUFBVSxtQkFBTyxDQUFDLGdEQUFRO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHVCQUF1QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQyxtQkFBbUI7QUFDdEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDLFFBQVE7QUFDN0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzlJYTs7QUFFYixhQUFhLG1CQUFPLENBQUMsd0VBQXFCO0FBQzFDLGVBQWUsbUJBQU8sQ0FBQyw2REFBVTs7QUFFakMsVUFBVSxtQkFBTyxDQUFDLGdEQUFRO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQiwyQkFBMkI7QUFDN0Msa0JBQWtCLDJCQUEyQjtBQUM3QyxrQkFBa0IsMkJBQTJCO0FBQzdDO0FBQ0EsR0FBRztBQUNIO0FBQ0Esa0JBQWtCLDJCQUEyQjtBQUM3QyxrQkFBa0IsMkJBQTJCO0FBQzdDLGtCQUFrQiwyQkFBMkI7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3REYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixRQUFRO0FBQ3pCLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixRQUFRO0FBQ3pCLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLE9BQU87QUFDeEIsb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEIsb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QixtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixxQkFBcUI7QUFDeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLHlCQUF5QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUMvUEEsa0VBQW9CLG1CQUFPLENBQUMsK0VBQXFCO0FBQ2pELGFBQWEsbUJBQU8sQ0FBQyx3RUFBbUI7O0FBRXhDLFNBQVMsbUJBQU8sQ0FBQyx5REFBVTs7QUFFM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN6Q0EsdURBQVMsbUJBQU8sQ0FBQyw2Q0FBTztBQUN4QixrQkFBa0IsbUJBQU8sQ0FBQywyREFBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsMkVBQWlCO0FBQ3RDLGtCQUFrQixtQkFBTyxDQUFDLDBEQUFhO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ25LQSxrQkFBa0IsbUJBQU8sQ0FBQywwREFBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQSxTQUFTLG1CQUFPLENBQUMsNkNBQU87QUFDeEI7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQywyREFBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFdBQVc7QUFDbkM7QUFDQSxtQkFBbUIseUJBQXlCO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDeEdhOztBQUViOztBQUVBLG1CQUFtQixtQkFBTyxDQUFDLDZEQUFpQjtBQUM1QyxpQkFBaUIsbUJBQU8sQ0FBQyx1RUFBa0I7QUFDM0MsZ0JBQWdCLG1CQUFPLENBQUMsZ0RBQVM7QUFDakMsaUJBQWlCLG1CQUFPLENBQUMsNkVBQWtCO0FBQzNDLGtCQUFrQixtQkFBTyxDQUFDLHlFQUFtQjs7QUFFN0M7QUFDQSxjQUFjLG1CQUFPLENBQUMsdUVBQWU7QUFDckMsaUJBQWlCLG1CQUFPLENBQUMsNkVBQWtCOzs7Ozs7Ozs7Ozs7O0FDWjlCOztBQUViLFNBQVMsbUJBQU8sQ0FBQyw2Q0FBTztBQUN4QixZQUFZLG1CQUFPLENBQUMsK0RBQVU7QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QixtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCLFFBQVE7QUFDdEM7QUFDQSxtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixXQUFXO0FBQzVCLG1CQUFtQixVQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3JYYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsK0RBQVU7QUFDOUIsU0FBUyxtQkFBTyxDQUFDLDZDQUFPO0FBQ3hCLGVBQWUsbUJBQU8sQ0FBQyw2REFBVTtBQUNqQyxXQUFXLG1CQUFPLENBQUMsa0VBQVE7O0FBRTNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLLGVBQWU7QUFDcEIsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsV0FBVztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3g2QmE7O0FBRWI7O0FBRUEsV0FBVyxtQkFBTyxDQUFDLG1EQUFTO0FBQzVCLFlBQVksbUJBQU8sQ0FBQyxvRUFBUztBQUM3QixZQUFZLG1CQUFPLENBQUMsOERBQVM7O0FBRTdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLFFBQVEsbUJBQU8sQ0FBQyw4RkFBeUI7QUFDekMsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7OztBQzdNWTs7QUFFYixTQUFTLG1CQUFPLENBQUMsNkNBQU87QUFDeEIsZUFBZSxtQkFBTyxDQUFDLDREQUFXO0FBQ2xDLFlBQVksbUJBQU8sQ0FBQywrREFBVTtBQUM5QixhQUFhLG1CQUFPLENBQUMsaUVBQVc7QUFDaEMsV0FBVyxtQkFBTyxDQUFDLGdEQUFTO0FBQzVCOztBQUVBLGNBQWMsbUJBQU8sQ0FBQyw2REFBTztBQUM3QixnQkFBZ0IsbUJBQU8sQ0FBQyx5RUFBYTs7QUFFckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUEsb0JBQW9CLE1BQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCLDJDQUEyQztBQUNyRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDaFBhOztBQUViLFNBQVMsbUJBQU8sQ0FBQyw2Q0FBTztBQUN4QixZQUFZLG1CQUFPLENBQUMsK0RBQVU7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZOztBQUVaLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNySGE7O0FBRWIsU0FBUyxtQkFBTyxDQUFDLDZDQUFPOztBQUV4QixZQUFZLG1CQUFPLENBQUMsK0RBQVU7QUFDOUI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxjQUFjO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNySWE7O0FBRWIsV0FBVyxtQkFBTyxDQUFDLG1EQUFTO0FBQzVCLGFBQWEsbUJBQU8sQ0FBQyxpRUFBVztBQUNoQyxZQUFZLG1CQUFPLENBQUMsK0RBQVU7QUFDOUI7QUFDQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxnRUFBTztBQUM3QixnQkFBZ0IsbUJBQU8sQ0FBQyw0RUFBYTs7QUFFckM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsVUFBVSxhQUFhO0FBQ3ZCLFVBQVUscUJBQXFCO0FBQy9CLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpQ0FBaUM7QUFDOUQ7O0FBRUE7QUFDQSxVQUFVLE1BQU07QUFDaEIsVUFBVSx1QkFBdUI7QUFDakMsVUFBVSwyQkFBMkI7QUFDckMsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDckhhOztBQUViLFlBQVksbUJBQU8sQ0FBQywrREFBVTtBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLE1BQU07QUFDaEIsVUFBVSxPQUFPO0FBQ2pCO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCLFVBQVUsTUFBTTtBQUNoQixVQUFVLFlBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFdBQVc7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGlCQUFpQjtBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDOUZhOztBQUViLFNBQVMsbUJBQU8sQ0FBQyw2Q0FBTztBQUN4QixZQUFZLG1CQUFPLENBQUMsK0RBQVU7QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxNQUFNO0FBQ2hCLFVBQVUsb0JBQW9CO0FBQzlCLFVBQVUsbUJBQW1CO0FBQzdCLFVBQVUsZ0JBQWdCO0FBQzFCLFVBQVUsYUFBYTtBQUN2QixVQUFVLGFBQWE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMzd0JhOztBQUViO0FBQ0EsU0FBUyxtQkFBTyxDQUFDLDZDQUFPO0FBQ3hCLGdCQUFnQixtQkFBTyxDQUFDLHdFQUFxQjtBQUM3QyxlQUFlLG1CQUFPLENBQUMsd0ZBQTJCOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsV0FBVztBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVB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QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7O0FDekhEO0FBQ0E7O0FBRVk7O0FBRVosVUFBVSxtQkFBTyxDQUFDLG1EQUFTOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7Ozs7Ozs7Ozs7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxtQkFBTyxDQUFDLDhEQUFnQjtBQUNs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Ozs7Ozs7Ozs7OztBQzNDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDOztB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RztBQUNsRyxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGO0FBQzVGLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGdEQUFnRDs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0MsbUJBQU8sQ0FBQyw0RUFBaUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDRDQUE0Qzs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9COztBQUVwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FB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O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlEQUFpRCwwRkFBMEY7O0FBRTNJO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLG1CQUFPLENBQUMsOEVBQWtCOztBQUUvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDOztBQUVqQzs7QUFFQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvREFBb0Q7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7Ozs7Ozs7OztBQzlxQmE7O0FBRWIsaURBQWlELDBD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUNsS0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsOENBQVE7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzdEQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNB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QUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDOUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLHdEQUFhO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsc0NBQXNDLHNDQUFzQztBQUN6RztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQzs7Ozs7Ozs7Ozs7O0FDdlNhOztBQUViOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FB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QU8sQ0FBQyxrSEFBc0Q7O0FBRTVFO0FBQ0EsY0FBYyxRQUFTO0FBQ3ZCOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLG1KQUF3RTs7QUFFN0Y7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNmQSxlOzs7Ozs7Ozs7OztBQ0FBLGU7Ozs7Ozs7Ozs7O0FDQUEsZTs7Ozs7Ozs7Ozs7QUNBQSxlIiwiZmlsZSI6ImJ1bmRsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vc3JjL2luZGV4LmpzXCIpO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuaW1wb3J0e2NvbmNhdCxzbGljZSxzdGFjayx0ZW5zb3IsdGlkeSx1bnN0YWNrLHV0aWwsaW8sVGVuc29yLGFkZCxhZGROLG1vZCxtdWwsZGl2LGZsb29yRGl2LHN1YixtaW5pbXVtLG1heGltdW0scG93LHNxdWFyZWREaWZmZXJlbmNlLGFicyxhY29zLGFjb3NoLGFzaW4sYXNpbmgsYXRhbixhdGFuMixhdGFuaCxjZWlsLGNvcyxjb3NoLGVsdSxlcmYsZXhwLGV4cG0xLGZsb29yLGxvZyxsb2cxcCxuZWcscmVjaXByb2NhbCxyZWx1LHJvdW5kLHNlbHUsc2lnbW9pZCxzaW4sc2lnbixzaW5oLHNvZnRwbHVzLHNxcnQsc3F1YXJlLHRhbmgsdGFuLGNsaXBCeVZhbHVlLHNjYWxhcixwcm9kLGxlYWt5UmVsdSxjb252MWQsY29udjJkLGNvbnYyZFRyYW5zcG9zZSxkZXB0aHdpc2VDb252MmQsYXZnUG9vbCxtYXhQb29sLGZpbGwsbGluc3BhY2Usb25lSG90LG9uZXMsb25lc0xpa2UscmFuZG9tVW5pZm9ybSxyYW5nZSx0cnVuY2F0ZWROb3JtYWwsemVyb3MsemVyb3NMaWtlLGltYWdlLHdoZXJlQXN5bmMsc2V0ZGlmZjFkQXN5bmMsdG9wayx0ZW5zb3IxZCxlcXVhbCxub3RFcXVhbCxncmVhdGVyLGdyZWF0ZXJFcXVhbCxsZXNzLGxlc3NFcXVhbCxsb2dpY2FsQW5kLGxvZ2ljYWxOb3QsbG9naWNhbE9yLHdoZXJlLG1hdE11bCx0cmFuc3Bvc2UsYmF0Y2hOb3JtYWxpemF0aW9uLGxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uLHNvZnRtYXgsbG9nU29mdG1heCxzcGFyc2VUb0RlbnNlLG1heCxtZWFuLG1pbixzdW0sYWxsLGFueSxhcmdNYXgsYXJnTWluLGdhdGhlcixyZXZlcnNlLHN0cmlkZWRTbGljZSx0aWxlLHNwbGl0LHNjYXR0ZXJORCxnYXRoZXJORCxjYXN0LGV4cGFuZERpbXMsc3F1ZWV6ZSxyZXNoYXBlLHBhZCxzcGFjZVRvQmF0Y2hORCxiYXRjaFRvU3BhY2VORCxkZXB0aFRvU3BhY2V9ZnJvbVwiQHRlbnNvcmZsb3cvdGZqcy1jb3JlXCI7dmFyIF9fYXNzaWduPU9iamVjdC5hc3NpZ258fGZ1bmN0aW9uKGUpe2Zvcih2YXIgdCxhPTEscj1hcmd1bWVudHMubGVuZ3RoO2E8cjthKyspZm9yKHZhciBuIGluIHQ9YXJndW1lbnRzW2FdKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LG4pJiYoZVtuXT10W25dKTtyZXR1cm4gZX07ZnVuY3Rpb24gX19hd2FpdGVyKGUsdCxhLHIpe3JldHVybiBuZXcoYXx8KGE9UHJvbWlzZSkpKGZ1bmN0aW9uKG4sbyl7ZnVuY3Rpb24gcyhlKXt0cnl7cChyLm5leHQoZSkpfWNhdGNoKGUpe28oZSl9fWZ1bmN0aW9uIGkoZSl7dHJ5e3Aoci50aHJvdyhlKSl9Y2F0Y2goZSl7byhlKX19ZnVuY3Rpb24gcChlKXtlLmRvbmU/bihlLnZhbHVlKTpuZXcgYShmdW5jdGlvbih0KXt0KGUudmFsdWUpfSkudGhlbihzLGkpfXAoKHI9ci5hcHBseShlLHR8fFtdKSkubmV4dCgpKX0pfWZ1bmN0aW9uIF9fZ2VuZXJhdG9yKGUsdCl7dmFyIGEscixuLG8scz17bGFiZWw6MCxzZW50OmZ1bmN0aW9uKCl7aWYoMSZuWzBdKXRocm93IG5bMV07cmV0dXJuIG5bMV19LHRyeXM6W10sb3BzOltdfTtyZXR1cm4gbz17bmV4dDppKDApLHRocm93OmkoMSkscmV0dXJuOmkoMil9LFwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmKG9bU3ltYm9sLml0ZXJhdG9yXT1mdW5jdGlvbigpe3JldHVybiB0aGlzfSksbztmdW5jdGlvbiBpKG8pe3JldHVybiBmdW5jdGlvbihpKXtyZXR1cm4gZnVuY3Rpb24obyl7aWYoYSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtmb3IoO3M7KXRyeXtpZihhPTEsciYmKG49clsyJm9bMF0/XCJyZXR1cm5cIjpvWzBdP1widGhyb3dcIjpcIm5leHRcIl0pJiYhKG49bi5jYWxsKHIsb1sxXSkpLmRvbmUpcmV0dXJuIG47c3dpdGNoKHI9MCxuJiYobz1bMCxuLnZhbHVlXSksb1swXSl7Y2FzZSAwOmNhc2UgMTpuPW87YnJlYWs7Y2FzZSA0OnJldHVybiBzLmxhYmVsKysse3ZhbHVlOm9bMV0sZG9uZTohMX07Y2FzZSA1OnMubGFiZWwrKyxyPW9bMV0sbz1bMF07Y29udGludWU7Y2FzZSA3Om89cy5vcHMucG9wKCkscy50cnlzLnBvcCgpO2NvbnRpbnVlO2RlZmF1bHQ6aWYoIShuPShuPXMudHJ5cykubGVuZ3RoPjAmJm5bbi5sZW5ndGgtMV0pJiYoNj09PW9bMF18fDI9PT1vWzBdKSl7cz0wO2NvbnRpbnVlfWlmKDM9PT1vWzBdJiYoIW58fG9bMV0+blswXSYmb1sxXTxuWzNdKSl7cy5sYWJlbD1vWzFdO2JyZWFrfWlmKDY9PT1vWzBdJiZzLmxhYmVsPG5bMV0pe3MubGFiZWw9blsxXSxuPW87YnJlYWt9aWYobiYmcy5sYWJlbDxuWzJdKXtzLmxhYmVsPW5bMl0scy5vcHMucHVzaChvKTticmVha31uWzJdJiZzLm9wcy5wb3AoKSxzLnRyeXMucG9wKCk7Y29udGludWV9bz10LmNhbGwoZSxzKX1jYXRjaChlKXtvPVs2LGVdLHI9MH1maW5hbGx5e2E9bj0wfWlmKDUmb1swXSl0aHJvdyBvWzFdO3JldHVybnt2YWx1ZTpvWzBdP29bMV06dm9pZCAwLGRvbmU6ITB9fShbbyxpXSl9fX12YXIgY29tbW9uanNHbG9iYWw9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3c6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9nbG9iYWw6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGY/c2VsZjp7fTtmdW5jdGlvbiBjcmVhdGVDb21tb25qc01vZHVsZShlLHQpe3JldHVybiBlKHQ9e2V4cG9ydHM6e319LHQuZXhwb3J0cyksdC5leHBvcnRzfXZhciBhc3Byb21pc2U9YXNQcm9taXNlO2Z1bmN0aW9uIGFzUHJvbWlzZShlLHQpe2Zvcih2YXIgYT1uZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aC0xKSxyPTAsbj0yLG89ITA7bjxhcmd1bWVudHMubGVuZ3RoOylhW3IrK109YXJndW1lbnRzW24rK107cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKG4scyl7YVtyXT1mdW5jdGlvbihlKXtpZihvKWlmKG89ITEsZSlzKGUpO2Vsc2V7Zm9yKHZhciB0PW5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoLTEpLGE9MDthPHQubGVuZ3RoOyl0W2ErK109YXJndW1lbnRzW2FdO24uYXBwbHkobnVsbCx0KX19O3RyeXtlLmFwcGx5KHR8fG51bGwsYSl9Y2F0Y2goZSl7byYmKG89ITEscyhlKSl9fSl9dmFyIGJhc2U2NF8xPWNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uKGUsdCl7dmFyIGE9dDthLmxlbmd0aD1mdW5jdGlvbihlKXt2YXIgdD1lLmxlbmd0aDtpZighdClyZXR1cm4gMDtmb3IodmFyIGE9MDstLXQlND4xJiZcIj1cIj09PWUuY2hhckF0KHQpOykrK2E7cmV0dXJuIE1hdGguY2VpbCgzKmUubGVuZ3RoKS80LWF9O2Zvcih2YXIgcj1uZXcgQXJyYXkoNjQpLG49bmV3IEFycmF5KDEyMyksbz0wO288NjQ7KW5bcltvXT1vPDI2P28rNjU6bzw1Mj9vKzcxOm88NjI/by00Om8tNTl8NDNdPW8rKzthLmVuY29kZT1mdW5jdGlvbihlLHQsYSl7Zm9yKHZhciBuLG89bnVsbCxzPVtdLGk9MCxwPTA7dDxhOyl7dmFyIG09ZVt0KytdO3N3aXRjaChwKXtjYXNlIDA6c1tpKytdPXJbbT4+Ml0sbj0oMyZtKTw8NCxwPTE7YnJlYWs7Y2FzZSAxOnNbaSsrXT1yW258bT4+NF0sbj0oMTUmbSk8PDIscD0yO2JyZWFrO2Nhc2UgMjpzW2krK109cltufG0+PjZdLHNbaSsrXT1yWzYzJm1dLHA9MH1pPjgxOTEmJigob3x8KG89W10pKS5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLHMpKSxpPTApfXJldHVybiBwJiYoc1tpKytdPXJbbl0sc1tpKytdPTYxLDE9PT1wJiYoc1tpKytdPTYxKSksbz8oaSYmby5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLHMuc2xpY2UoMCxpKSkpLG8uam9pbihcIlwiKSk6U3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcscy5zbGljZSgwLGkpKX07YS5kZWNvZGU9ZnVuY3Rpb24oZSx0LGEpe2Zvcih2YXIgcixvPWEscz0wLGk9MDtpPGUubGVuZ3RoOyl7dmFyIHA9ZS5jaGFyQ29kZUF0KGkrKyk7aWYoNjE9PT1wJiZzPjEpYnJlYWs7aWYodm9pZCAwPT09KHA9bltwXSkpdGhyb3cgRXJyb3IoXCJpbnZhbGlkIGVuY29kaW5nXCIpO3N3aXRjaChzKXtjYXNlIDA6cj1wLHM9MTticmVhaztjYXNlIDE6dFthKytdPXI8PDJ8KDQ4JnApPj40LHI9cCxzPTI7YnJlYWs7Y2FzZSAyOnRbYSsrXT0oMTUmcik8PDR8KDYwJnApPj4yLHI9cCxzPTM7YnJlYWs7Y2FzZSAzOnRbYSsrXT0oMyZyKTw8NnxwLHM9MH19aWYoMT09PXMpdGhyb3cgRXJyb3IoXCJpbnZhbGlkIGVuY29kaW5nXCIpO3JldHVybiBhLW99LGEudGVzdD1mdW5jdGlvbihlKXtyZXR1cm4vXig/OltBLVphLXowLTkrL117NH0pKig/OltBLVphLXowLTkrL117Mn09PXxbQS1aYS16MC05Ky9dezN9PSk/JC8udGVzdChlKX19KSxldmVudGVtaXR0ZXI9RXZlbnRFbWl0dGVyO2Z1bmN0aW9uIEV2ZW50RW1pdHRlcigpe3RoaXMuX2xpc3RlbmVycz17fX1FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uPWZ1bmN0aW9uKGUsdCxhKXtyZXR1cm4odGhpcy5fbGlzdGVuZXJzW2VdfHwodGhpcy5fbGlzdGVuZXJzW2VdPVtdKSkucHVzaCh7Zm46dCxjdHg6YXx8dGhpc30pLHRoaXN9LEV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmPWZ1bmN0aW9uKGUsdCl7aWYodm9pZCAwPT09ZSl0aGlzLl9saXN0ZW5lcnM9e307ZWxzZSBpZih2b2lkIDA9PT10KXRoaXMuX2xpc3RlbmVyc1tlXT1bXTtlbHNlIGZvcih2YXIgYT10aGlzLl9saXN0ZW5lcnNbZV0scj0wO3I8YS5sZW5ndGg7KWFbcl0uZm49PT10P2Euc3BsaWNlKHIsMSk6KytyO3JldHVybiB0aGlzfSxFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQ9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5fbGlzdGVuZXJzW2VdO2lmKHQpe2Zvcih2YXIgYT1bXSxyPTE7cjxhcmd1bWVudHMubGVuZ3RoOylhLnB1c2goYXJndW1lbnRzW3IrK10pO2ZvcihyPTA7cjx0Lmxlbmd0aDspdFtyXS5mbi5hcHBseSh0W3IrK10uY3R4LGEpfXJldHVybiB0aGlzfTt2YXIgZmxvYXRfMT1mYWN0b3J5KGZhY3RvcnkpO2Z1bmN0aW9uIGZhY3RvcnkoZSl7cmV0dXJuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIEZsb2F0MzJBcnJheT9mdW5jdGlvbigpe3ZhciB0PW5ldyBGbG9hdDMyQXJyYXkoWy0wXSksYT1uZXcgVWludDhBcnJheSh0LmJ1ZmZlcikscj0xMjg9PT1hWzNdO2Z1bmN0aW9uIG4oZSxyLG4pe3RbMF09ZSxyW25dPWFbMF0scltuKzFdPWFbMV0scltuKzJdPWFbMl0scltuKzNdPWFbM119ZnVuY3Rpb24gbyhlLHIsbil7dFswXT1lLHJbbl09YVszXSxyW24rMV09YVsyXSxyW24rMl09YVsxXSxyW24rM109YVswXX1mdW5jdGlvbiBzKGUscil7cmV0dXJuIGFbMF09ZVtyXSxhWzFdPWVbcisxXSxhWzJdPWVbcisyXSxhWzNdPWVbciszXSx0WzBdfWZ1bmN0aW9uIGkoZSxyKXtyZXR1cm4gYVszXT1lW3JdLGFbMl09ZVtyKzFdLGFbMV09ZVtyKzJdLGFbMF09ZVtyKzNdLHRbMF19ZS53cml0ZUZsb2F0TEU9cj9uOm8sZS53cml0ZUZsb2F0QkU9cj9vOm4sZS5yZWFkRmxvYXRMRT1yP3M6aSxlLnJlYWRGbG9hdEJFPXI/aTpzfSgpOmZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChlLHQsYSxyKXt2YXIgbj10PDA/MTowO2lmKG4mJih0PS10KSwwPT09dCllKDEvdD4wPzA6MjE0NzQ4MzY0OCxhLHIpO2Vsc2UgaWYoaXNOYU4odCkpZSgyMTQzMjg5MzQ0LGEscik7ZWxzZSBpZih0PjMuNDAyODIzNDY2Mzg1Mjg4NmUzOCllKChuPDwzMXwyMTM5MDk1MDQwKT4+PjAsYSxyKTtlbHNlIGlmKHQ8MS4xNzU0OTQzNTA4MjIyODc1ZS0zOCllKChuPDwzMXxNYXRoLnJvdW5kKHQvMS40MDEyOTg0NjQzMjQ4MTdlLTQ1KSk+Pj4wLGEscik7ZWxzZXt2YXIgbz1NYXRoLmZsb29yKE1hdGgubG9nKHQpL01hdGguTE4yKTtlKChuPDwzMXxvKzEyNzw8MjN8ODM4ODYwNyZNYXRoLnJvdW5kKHQqTWF0aC5wb3coMiwtbykqODM4ODYwOCkpPj4+MCxhLHIpfX1mdW5jdGlvbiBhKGUsdCxhKXt2YXIgcj1lKHQsYSksbj0yKihyPj4zMSkrMSxvPXI+Pj4yMyYyNTUscz04Mzg4NjA3JnI7cmV0dXJuIDI1NT09PW8/cz9OYU46biooMS8wKTowPT09bz8xLjQwMTI5ODQ2NDMyNDgxN2UtNDUqbipzOm4qTWF0aC5wb3coMixvLTE1MCkqKHMrODM4ODYwOCl9ZS53cml0ZUZsb2F0TEU9dC5iaW5kKG51bGwsd3JpdGVVaW50TEUpLGUud3JpdGVGbG9hdEJFPXQuYmluZChudWxsLHdyaXRlVWludEJFKSxlLnJlYWRGbG9hdExFPWEuYmluZChudWxsLHJlYWRVaW50TEUpLGUucmVhZEZsb2F0QkU9YS5iaW5kKG51bGwscmVhZFVpbnRCRSl9KCksXCJ1bmRlZmluZWRcIiE9dHlwZW9mIEZsb2F0NjRBcnJheT9mdW5jdGlvbigpe3ZhciB0PW5ldyBGbG9hdDY0QXJyYXkoWy0wXSksYT1uZXcgVWludDhBcnJheSh0LmJ1ZmZlcikscj0xMjg9PT1hWzddO2Z1bmN0aW9uIG4oZSxyLG4pe3RbMF09ZSxyW25dPWFbMF0scltuKzFdPWFbMV0scltuKzJdPWFbMl0scltuKzNdPWFbM10scltuKzRdPWFbNF0scltuKzVdPWFbNV0scltuKzZdPWFbNl0scltuKzddPWFbN119ZnVuY3Rpb24gbyhlLHIsbil7dFswXT1lLHJbbl09YVs3XSxyW24rMV09YVs2XSxyW24rMl09YVs1XSxyW24rM109YVs0XSxyW24rNF09YVszXSxyW24rNV09YVsyXSxyW24rNl09YVsxXSxyW24rN109YVswXX1mdW5jdGlvbiBzKGUscil7cmV0dXJuIGFbMF09ZVtyXSxhWzFdPWVbcisxXSxhWzJdPWVbcisyXSxhWzNdPWVbciszXSxhWzRdPWVbcis0XSxhWzVdPWVbcis1XSxhWzZdPWVbcis2XSxhWzddPWVbcis3XSx0WzBdfWZ1bmN0aW9uIGkoZSxyKXtyZXR1cm4gYVs3XT1lW3JdLGFbNl09ZVtyKzFdLGFbNV09ZVtyKzJdLGFbNF09ZVtyKzNdLGFbM109ZVtyKzRdLGFbMl09ZVtyKzVdLGFbMV09ZVtyKzZdLGFbMF09ZVtyKzddLHRbMF19ZS53cml0ZURvdWJsZUxFPXI/bjpvLGUud3JpdGVEb3VibGVCRT1yP286bixlLnJlYWREb3VibGVMRT1yP3M6aSxlLnJlYWREb3VibGVCRT1yP2k6c30oKTpmdW5jdGlvbigpe2Z1bmN0aW9uIHQoZSx0LGEscixuLG8pe3ZhciBzPXI8MD8xOjA7aWYocyYmKHI9LXIpLDA9PT1yKWUoMCxuLG8rdCksZSgxL3I+MD8wOjIxNDc0ODM2NDgsbixvK2EpO2Vsc2UgaWYoaXNOYU4ocikpZSgwLG4sbyt0KSxlKDIxNDY5NTkzNjAsbixvK2EpO2Vsc2UgaWYocj4xLjc5NzY5MzEzNDg2MjMxNTdlMzA4KWUoMCxuLG8rdCksZSgoczw8MzF8MjE0NjQzNTA3Mik+Pj4wLG4sbythKTtlbHNle3ZhciBpO2lmKHI8Mi4yMjUwNzM4NTg1MDcyMDE0ZS0zMDgpZSgoaT1yLzVlLTMyNCk+Pj4wLG4sbyt0KSxlKChzPDwzMXxpLzQyOTQ5NjcyOTYpPj4+MCxuLG8rYSk7ZWxzZXt2YXIgcD1NYXRoLmZsb29yKE1hdGgubG9nKHIpL01hdGguTE4yKTsxMDI0PT09cCYmKHA9MTAyMyksZSg0NTAzNTk5NjI3MzcwNDk2KihpPXIqTWF0aC5wb3coMiwtcCkpPj4+MCxuLG8rdCksZSgoczw8MzF8cCsxMDIzPDwyMHwxMDQ4NTc2KmkmMTA0ODU3NSk+Pj4wLG4sbythKX19fWZ1bmN0aW9uIGEoZSx0LGEscixuKXt2YXIgbz1lKHIsbit0KSxzPWUocixuK2EpLGk9Mioocz4+MzEpKzEscD1zPj4+MjAmMjA0NyxtPTQyOTQ5NjcyOTYqKDEwNDg1NzUmcykrbztyZXR1cm4gMjA0Nz09PXA/bT9OYU46aSooMS8wKTowPT09cD81ZS0zMjQqaSptOmkqTWF0aC5wb3coMixwLTEwNzUpKihtKzQ1MDM1OTk2MjczNzA0OTYpfWUud3JpdGVEb3VibGVMRT10LmJpbmQobnVsbCx3cml0ZVVpbnRMRSwwLDQpLGUud3JpdGVEb3VibGVCRT10LmJpbmQobnVsbCx3cml0ZVVpbnRCRSw0LDApLGUucmVhZERvdWJsZUxFPWEuYmluZChudWxsLHJlYWRVaW50TEUsMCw0KSxlLnJlYWREb3VibGVCRT1hLmJpbmQobnVsbCxyZWFkVWludEJFLDQsMCl9KCksZX1mdW5jdGlvbiB3cml0ZVVpbnRMRShlLHQsYSl7dFthXT0yNTUmZSx0W2ErMV09ZT4+PjgmMjU1LHRbYSsyXT1lPj4+MTYmMjU1LHRbYSszXT1lPj4+MjR9ZnVuY3Rpb24gd3JpdGVVaW50QkUoZSx0LGEpe3RbYV09ZT4+PjI0LHRbYSsxXT1lPj4+MTYmMjU1LHRbYSsyXT1lPj4+OCYyNTUsdFthKzNdPTI1NSZlfWZ1bmN0aW9uIHJlYWRVaW50TEUoZSx0KXtyZXR1cm4oZVt0XXxlW3QrMV08PDh8ZVt0KzJdPDwxNnxlW3QrM108PDI0KT4+PjB9ZnVuY3Rpb24gcmVhZFVpbnRCRShlLHQpe3JldHVybihlW3RdPDwyNHxlW3QrMV08PDE2fGVbdCsyXTw8OHxlW3QrM10pPj4+MH12YXIgaW5xdWlyZV8xPWlucXVpcmU7ZnVuY3Rpb24gaW5xdWlyZShtb2R1bGVOYW1lKXt0cnl7dmFyIG1vZCQkMT1ldmFsKFwicXVpcmVcIi5yZXBsYWNlKC9eLyxcInJlXCIpKShtb2R1bGVOYW1lKTtpZihtb2QkJDEmJihtb2QkJDEubGVuZ3RofHxPYmplY3Qua2V5cyhtb2QkJDEpLmxlbmd0aCkpcmV0dXJuIG1vZCQkMX1jYXRjaChlKXt9cmV0dXJuIG51bGx9dmFyIHV0ZjhfMT1jcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbihlLHQpe3ZhciBhPXQ7YS5sZW5ndGg9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PTAsYT0wLHI9MDtyPGUubGVuZ3RoOysrcikoYT1lLmNoYXJDb2RlQXQocikpPDEyOD90Kz0xOmE8MjA0OD90Kz0yOjU1Mjk2PT0oNjQ1MTImYSkmJjU2MzIwPT0oNjQ1MTImZS5jaGFyQ29kZUF0KHIrMSkpPygrK3IsdCs9NCk6dCs9MztyZXR1cm4gdH0sYS5yZWFkPWZ1bmN0aW9uKGUsdCxhKXtpZihhLXQ8MSlyZXR1cm5cIlwiO2Zvcih2YXIgcixuPW51bGwsbz1bXSxzPTA7dDxhOykocj1lW3QrK10pPDEyOD9vW3MrK109cjpyPjE5MSYmcjwyMjQ/b1tzKytdPSgzMSZyKTw8Nnw2MyZlW3QrK106cj4yMzkmJnI8MzY1PyhyPSgoNyZyKTw8MTh8KDYzJmVbdCsrXSk8PDEyfCg2MyZlW3QrK10pPDw2fDYzJmVbdCsrXSktNjU1MzYsb1tzKytdPTU1Mjk2KyhyPj4xMCksb1tzKytdPTU2MzIwKygxMDIzJnIpKTpvW3MrK109KDE1JnIpPDwxMnwoNjMmZVt0KytdKTw8Nnw2MyZlW3QrK10scz44MTkxJiYoKG58fChuPVtdKSkucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZyxvKSkscz0wKTtyZXR1cm4gbj8ocyYmbi5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLG8uc2xpY2UoMCxzKSkpLG4uam9pbihcIlwiKSk6U3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsby5zbGljZSgwLHMpKX0sYS53cml0ZT1mdW5jdGlvbihlLHQsYSl7Zm9yKHZhciByLG4sbz1hLHM9MDtzPGUubGVuZ3RoOysrcykocj1lLmNoYXJDb2RlQXQocykpPDEyOD90W2ErK109cjpyPDIwNDg/KHRbYSsrXT1yPj42fDE5Mix0W2ErK109NjMmcnwxMjgpOjU1Mjk2PT0oNjQ1MTImcikmJjU2MzIwPT0oNjQ1MTImKG49ZS5jaGFyQ29kZUF0KHMrMSkpKT8ocj02NTUzNisoKDEwMjMmcik8PDEwKSsoMTAyMyZuKSwrK3MsdFthKytdPXI+PjE4fDI0MCx0W2ErK109cj4+MTImNjN8MTI4LHRbYSsrXT1yPj42JjYzfDEyOCx0W2ErK109NjMmcnwxMjgpOih0W2ErK109cj4+MTJ8MjI0LHRbYSsrXT1yPj42JjYzfDEyOCx0W2ErK109NjMmcnwxMjgpO3JldHVybiBhLW99fSkscG9vbF8xPXBvb2w7ZnVuY3Rpb24gcG9vbChlLHQsYSl7dmFyIHI9YXx8ODE5MixuPXI+Pj4xLG89bnVsbCxzPXI7cmV0dXJuIGZ1bmN0aW9uKGEpe2lmKGE8MXx8YT5uKXJldHVybiBlKGEpO3MrYT5yJiYobz1lKHIpLHM9MCk7dmFyIGk9dC5jYWxsKG8scyxzKz1hKTtyZXR1cm4gNyZzJiYocz0xKyg3fHMpKSxpfX12YXIgbG9uZ2JpdHM9TG9uZ0JpdHM7ZnVuY3Rpb24gTG9uZ0JpdHMoZSx0KXt0aGlzLmxvPWU+Pj4wLHRoaXMuaGk9dD4+PjB9dmFyIHplcm89TG9uZ0JpdHMuemVybz1uZXcgTG9uZ0JpdHMoMCwwKTt6ZXJvLnRvTnVtYmVyPWZ1bmN0aW9uKCl7cmV0dXJuIDB9LHplcm8uenpFbmNvZGU9emVyby56ekRlY29kZT1mdW5jdGlvbigpe3JldHVybiB0aGlzfSx6ZXJvLmxlbmd0aD1mdW5jdGlvbigpe3JldHVybiAxfTt2YXIgemVyb0hhc2g9TG9uZ0JpdHMuemVyb0hhc2g9XCJcXDBcXDBcXDBcXDBcXDBcXDBcXDBcXDBcIjtMb25nQml0cy5mcm9tTnVtYmVyPWZ1bmN0aW9uKGUpe2lmKDA9PT1lKXJldHVybiB6ZXJvO3ZhciB0PWU8MDt0JiYoZT0tZSk7dmFyIGE9ZT4+PjAscj0oZS1hKS80Mjk0OTY3Mjk2Pj4+MDtyZXR1cm4gdCYmKHI9fnI+Pj4wLGE9fmE+Pj4wLCsrYT40Mjk0OTY3Mjk1JiYoYT0wLCsrcj40Mjk0OTY3Mjk1JiYocj0wKSkpLG5ldyBMb25nQml0cyhhLHIpfSxMb25nQml0cy5mcm9tPWZ1bmN0aW9uKGUpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBlKXJldHVybiBMb25nQml0cy5mcm9tTnVtYmVyKGUpO2lmKG1pbmltYWwuaXNTdHJpbmcoZSkpe2lmKCFtaW5pbWFsLkxvbmcpcmV0dXJuIExvbmdCaXRzLmZyb21OdW1iZXIocGFyc2VJbnQoZSwxMCkpO2U9bWluaW1hbC5Mb25nLmZyb21TdHJpbmcoZSl9cmV0dXJuIGUubG93fHxlLmhpZ2g/bmV3IExvbmdCaXRzKGUubG93Pj4+MCxlLmhpZ2g+Pj4wKTp6ZXJvfSxMb25nQml0cy5wcm90b3R5cGUudG9OdW1iZXI9ZnVuY3Rpb24oZSl7aWYoIWUmJnRoaXMuaGk+Pj4zMSl7dmFyIHQ9MSt+dGhpcy5sbz4+PjAsYT1+dGhpcy5oaT4+PjA7cmV0dXJuIHR8fChhPWErMT4+PjApLC0odCs0Mjk0OTY3Mjk2KmEpfXJldHVybiB0aGlzLmxvKzQyOTQ5NjcyOTYqdGhpcy5oaX0sTG9uZ0JpdHMucHJvdG90eXBlLnRvTG9uZz1mdW5jdGlvbihlKXtyZXR1cm4gbWluaW1hbC5Mb25nP25ldyBtaW5pbWFsLkxvbmcoMHx0aGlzLmxvLDB8dGhpcy5oaSxCb29sZWFuKGUpKTp7bG93OjB8dGhpcy5sbyxoaWdoOjB8dGhpcy5oaSx1bnNpZ25lZDpCb29sZWFuKGUpfX07dmFyIGNoYXJDb2RlQXQ9U3RyaW5nLnByb3RvdHlwZS5jaGFyQ29kZUF0O0xvbmdCaXRzLmZyb21IYXNoPWZ1bmN0aW9uKGUpe3JldHVybiBlPT09emVyb0hhc2g/emVybzpuZXcgTG9uZ0JpdHMoKGNoYXJDb2RlQXQuY2FsbChlLDApfGNoYXJDb2RlQXQuY2FsbChlLDEpPDw4fGNoYXJDb2RlQXQuY2FsbChlLDIpPDwxNnxjaGFyQ29kZUF0LmNhbGwoZSwzKTw8MjQpPj4+MCwoY2hhckNvZGVBdC5jYWxsKGUsNCl8Y2hhckNvZGVBdC5jYWxsKGUsNSk8PDh8Y2hhckNvZGVBdC5jYWxsKGUsNik8PDE2fGNoYXJDb2RlQXQuY2FsbChlLDcpPDwyNCk+Pj4wKX0sTG9uZ0JpdHMucHJvdG90eXBlLnRvSGFzaD1mdW5jdGlvbigpe3JldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKDI1NSZ0aGlzLmxvLHRoaXMubG8+Pj44JjI1NSx0aGlzLmxvPj4+MTYmMjU1LHRoaXMubG8+Pj4yNCwyNTUmdGhpcy5oaSx0aGlzLmhpPj4+OCYyNTUsdGhpcy5oaT4+PjE2JjI1NSx0aGlzLmhpPj4+MjQpfSxMb25nQml0cy5wcm90b3R5cGUuenpFbmNvZGU9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLmhpPj4zMTtyZXR1cm4gdGhpcy5oaT0oKHRoaXMuaGk8PDF8dGhpcy5sbz4+PjMxKV5lKT4+PjAsdGhpcy5sbz0odGhpcy5sbzw8MV5lKT4+PjAsdGhpc30sTG9uZ0JpdHMucHJvdG90eXBlLnp6RGVjb2RlPWZ1bmN0aW9uKCl7dmFyIGU9LSgxJnRoaXMubG8pO3JldHVybiB0aGlzLmxvPSgodGhpcy5sbz4+PjF8dGhpcy5oaTw8MzEpXmUpPj4+MCx0aGlzLmhpPSh0aGlzLmhpPj4+MV5lKT4+PjAsdGhpc30sTG9uZ0JpdHMucHJvdG90eXBlLmxlbmd0aD1mdW5jdGlvbigpe3ZhciBlPXRoaXMubG8sdD0odGhpcy5sbz4+PjI4fHRoaXMuaGk8PDQpPj4+MCxhPXRoaXMuaGk+Pj4yNDtyZXR1cm4gMD09PWE/MD09PXQ/ZTwxNjM4ND9lPDEyOD8xOjI6ZTwyMDk3MTUyPzM6NDp0PDE2Mzg0P3Q8MTI4PzU6Njp0PDIwOTcxNTI/Nzo4OmE8MTI4Pzk6MTB9O3ZhciBtaW5pbWFsPWNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uKGUsdCl7dmFyIGE9dDtmdW5jdGlvbiByKGUsdCxhKXtmb3IodmFyIHI9T2JqZWN0LmtleXModCksbj0wO248ci5sZW5ndGg7KytuKXZvaWQgMCE9PWVbcltuXV0mJmF8fChlW3Jbbl1dPXRbcltuXV0pO3JldHVybiBlfWZ1bmN0aW9uIG4oZSl7ZnVuY3Rpb24gdChlLGEpe2lmKCEodGhpcyBpbnN0YW5jZW9mIHQpKXJldHVybiBuZXcgdChlLGEpO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLFwibWVzc2FnZVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZX19KSxFcnJvci5jYXB0dXJlU3RhY2tUcmFjZT9FcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLHQpOk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLFwic3RhY2tcIix7dmFsdWU6KG5ldyBFcnJvcikuc3RhY2t8fFwiXCJ9KSxhJiZyKHRoaXMsYSl9cmV0dXJuKHQucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKSkuY29uc3RydWN0b3I9dCxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJuYW1lXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBlfX0pLHQucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubmFtZStcIjogXCIrdGhpcy5tZXNzYWdlfSx0fWEuYXNQcm9taXNlPWFzcHJvbWlzZSxhLmJhc2U2ND1iYXNlNjRfMSxhLkV2ZW50RW1pdHRlcj1ldmVudGVtaXR0ZXIsYS5mbG9hdD1mbG9hdF8xLGEuaW5xdWlyZT1pbnF1aXJlXzEsYS51dGY4PXV0ZjhfMSxhLnBvb2w9cG9vbF8xLGEuTG9uZ0JpdHM9bG9uZ2JpdHMsYS5lbXB0eUFycmF5PU9iamVjdC5mcmVlemU/T2JqZWN0LmZyZWV6ZShbXSk6W10sYS5lbXB0eU9iamVjdD1PYmplY3QuZnJlZXplP09iamVjdC5mcmVlemUoe30pOnt9LGEuaXNOb2RlPUJvb2xlYW4oY29tbW9uanNHbG9iYWwucHJvY2VzcyYmY29tbW9uanNHbG9iYWwucHJvY2Vzcy52ZXJzaW9ucyYmY29tbW9uanNHbG9iYWwucHJvY2Vzcy52ZXJzaW9ucy5ub2RlKSxhLmlzSW50ZWdlcj1OdW1iZXIuaXNJbnRlZ2VyfHxmdW5jdGlvbihlKXtyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgZSYmaXNGaW5pdGUoZSkmJk1hdGguZmxvb3IoZSk9PT1lfSxhLmlzU3RyaW5nPWZ1bmN0aW9uKGUpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiBlfHxlIGluc3RhbmNlb2YgU3RyaW5nfSxhLmlzT2JqZWN0PWZ1bmN0aW9uKGUpe3JldHVybiBlJiZcIm9iamVjdFwiPT10eXBlb2YgZX0sYS5pc3NldD1hLmlzU2V0PWZ1bmN0aW9uKGUsdCl7dmFyIGE9ZVt0XTtyZXR1cm4hKG51bGw9PWF8fCFlLmhhc093blByb3BlcnR5KHQpKSYmKFwib2JqZWN0XCIhPXR5cGVvZiBhfHwoQXJyYXkuaXNBcnJheShhKT9hLmxlbmd0aDpPYmplY3Qua2V5cyhhKS5sZW5ndGgpPjApfSxhLkJ1ZmZlcj1mdW5jdGlvbigpe3RyeXt2YXIgZT1hLmlucXVpcmUoXCJidWZmZXJcIikuQnVmZmVyO3JldHVybiBlLnByb3RvdHlwZS51dGY4V3JpdGU/ZTpudWxsfWNhdGNoKGUpe3JldHVybiBudWxsfX0oKSxhLl9CdWZmZXJfZnJvbT1udWxsLGEuX0J1ZmZlcl9hbGxvY1Vuc2FmZT1udWxsLGEubmV3QnVmZmVyPWZ1bmN0aW9uKGUpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiBlP2EuQnVmZmVyP2EuX0J1ZmZlcl9hbGxvY1Vuc2FmZShlKTpuZXcgYS5BcnJheShlKTphLkJ1ZmZlcj9hLl9CdWZmZXJfZnJvbShlKTpcInVuZGVmaW5lZFwiPT10eXBlb2YgVWludDhBcnJheT9lOm5ldyBVaW50OEFycmF5KGUpfSxhLkFycmF5PVwidW5kZWZpbmVkXCIhPXR5cGVvZiBVaW50OEFycmF5P1VpbnQ4QXJyYXk6QXJyYXksYS5Mb25nPWNvbW1vbmpzR2xvYmFsLmRjb2RlSU8mJmNvbW1vbmpzR2xvYmFsLmRjb2RlSU8uTG9uZ3x8YS5pbnF1aXJlKFwibG9uZ1wiKSxhLmtleTJSZT0vXnRydWV8ZmFsc2V8MHwxJC8sYS5rZXkzMlJlPS9eLT8oPzowfFsxLTldWzAtOV0qKSQvLGEua2V5NjRSZT0vXig/OltcXFxceDAwLVxcXFx4ZmZdezh9fC0/KD86MHxbMS05XVswLTldKikpJC8sYS5sb25nVG9IYXNoPWZ1bmN0aW9uKGUpe3JldHVybiBlP2EuTG9uZ0JpdHMuZnJvbShlKS50b0hhc2goKTphLkxvbmdCaXRzLnplcm9IYXNofSxhLmxvbmdGcm9tSGFzaD1mdW5jdGlvbihlLHQpe3ZhciByPWEuTG9uZ0JpdHMuZnJvbUhhc2goZSk7cmV0dXJuIGEuTG9uZz9hLkxvbmcuZnJvbUJpdHMoci5sbyxyLmhpLHQpOnIudG9OdW1iZXIoQm9vbGVhbih0KSl9LGEubWVyZ2U9cixhLmxjRmlyc3Q9ZnVuY3Rpb24oZSl7cmV0dXJuIGUuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkrZS5zdWJzdHJpbmcoMSl9LGEubmV3RXJyb3I9bixhLlByb3RvY29sRXJyb3I9bihcIlByb3RvY29sRXJyb3JcIiksYS5vbmVPZkdldHRlcj1mdW5jdGlvbihlKXtmb3IodmFyIHQ9e30sYT0wO2E8ZS5sZW5ndGg7KythKXRbZVthXV09MTtyZXR1cm4gZnVuY3Rpb24oKXtmb3IodmFyIGU9T2JqZWN0LmtleXModGhpcyksYT1lLmxlbmd0aC0xO2E+LTE7LS1hKWlmKDE9PT10W2VbYV1dJiZ2b2lkIDAhPT10aGlzW2VbYV1dJiZudWxsIT09dGhpc1tlW2FdXSlyZXR1cm4gZVthXX19LGEub25lT2ZTZXR0ZXI9ZnVuY3Rpb24oZSl7cmV0dXJuIGZ1bmN0aW9uKHQpe2Zvcih2YXIgYT0wO2E8ZS5sZW5ndGg7KythKWVbYV0hPT10JiZkZWxldGUgdGhpc1tlW2FdXX19LGEudG9KU09OT3B0aW9ucz17bG9uZ3M6U3RyaW5nLGVudW1zOlN0cmluZyxieXRlczpTdHJpbmcsanNvbjohMH0sYS5fY29uZmlndXJlPWZ1bmN0aW9uKCl7dmFyIGU9YS5CdWZmZXI7ZT8oYS5fQnVmZmVyX2Zyb209ZS5mcm9tIT09VWludDhBcnJheS5mcm9tJiZlLmZyb218fGZ1bmN0aW9uKHQsYSl7cmV0dXJuIG5ldyBlKHQsYSl9LGEuX0J1ZmZlcl9hbGxvY1Vuc2FmZT1lLmFsbG9jVW5zYWZlfHxmdW5jdGlvbih0KXtyZXR1cm4gbmV3IGUodCl9KTphLl9CdWZmZXJfZnJvbT1hLl9CdWZmZXJfYWxsb2NVbnNhZmU9bnVsbH19KSx3cml0ZXI9V3JpdGVyLEJ1ZmZlcldyaXRlcixMb25nQml0cyQxPW1pbmltYWwuTG9uZ0JpdHMsYmFzZTY0PW1pbmltYWwuYmFzZTY0LHV0Zjg9bWluaW1hbC51dGY4O2Z1bmN0aW9uIE9wKGUsdCxhKXt0aGlzLmZuPWUsdGhpcy5sZW49dCx0aGlzLm5leHQ9dm9pZCAwLHRoaXMudmFsPWF9ZnVuY3Rpb24gbm9vcCgpe31mdW5jdGlvbiBTdGF0ZShlKXt0aGlzLmhlYWQ9ZS5oZWFkLHRoaXMudGFpbD1lLnRhaWwsdGhpcy5sZW49ZS5sZW4sdGhpcy5uZXh0PWUuc3RhdGVzfWZ1bmN0aW9uIFdyaXRlcigpe3RoaXMubGVuPTAsdGhpcy5oZWFkPW5ldyBPcChub29wLDAsMCksdGhpcy50YWlsPXRoaXMuaGVhZCx0aGlzLnN0YXRlcz1udWxsfWZ1bmN0aW9uIHdyaXRlQnl0ZShlLHQsYSl7dFthXT0yNTUmZX1mdW5jdGlvbiB3cml0ZVZhcmludDMyKGUsdCxhKXtmb3IoO2U+MTI3Oyl0W2ErK109MTI3JmV8MTI4LGU+Pj49Nzt0W2FdPWV9ZnVuY3Rpb24gVmFyaW50T3AoZSx0KXt0aGlzLmxlbj1lLHRoaXMubmV4dD12b2lkIDAsdGhpcy52YWw9dH1mdW5jdGlvbiB3cml0ZVZhcmludDY0KGUsdCxhKXtmb3IoO2UuaGk7KXRbYSsrXT0xMjcmZS5sb3wxMjgsZS5sbz0oZS5sbz4+Pjd8ZS5oaTw8MjUpPj4+MCxlLmhpPj4+PTc7Zm9yKDtlLmxvPjEyNzspdFthKytdPTEyNyZlLmxvfDEyOCxlLmxvPWUubG8+Pj43O3RbYSsrXT1lLmxvfWZ1bmN0aW9uIHdyaXRlRml4ZWQzMihlLHQsYSl7dFthXT0yNTUmZSx0W2ErMV09ZT4+PjgmMjU1LHRbYSsyXT1lPj4+MTYmMjU1LHRbYSszXT1lPj4+MjR9V3JpdGVyLmNyZWF0ZT1taW5pbWFsLkJ1ZmZlcj9mdW5jdGlvbigpe3JldHVybihXcml0ZXIuY3JlYXRlPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBCdWZmZXJXcml0ZXJ9KSgpfTpmdW5jdGlvbigpe3JldHVybiBuZXcgV3JpdGVyfSxXcml0ZXIuYWxsb2M9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBtaW5pbWFsLkFycmF5KGUpfSxtaW5pbWFsLkFycmF5IT09QXJyYXkmJihXcml0ZXIuYWxsb2M9bWluaW1hbC5wb29sKFdyaXRlci5hbGxvYyxtaW5pbWFsLkFycmF5LnByb3RvdHlwZS5zdWJhcnJheSkpLFdyaXRlci5wcm90b3R5cGUuX3B1c2g9ZnVuY3Rpb24oZSx0LGEpe3JldHVybiB0aGlzLnRhaWw9dGhpcy50YWlsLm5leHQ9bmV3IE9wKGUsdCxhKSx0aGlzLmxlbis9dCx0aGlzfSxWYXJpbnRPcC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShPcC5wcm90b3R5cGUpLFZhcmludE9wLnByb3RvdHlwZS5mbj13cml0ZVZhcmludDMyLFdyaXRlci5wcm90b3R5cGUudWludDMyPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmxlbis9KHRoaXMudGFpbD10aGlzLnRhaWwubmV4dD1uZXcgVmFyaW50T3AoKGU+Pj49MCk8MTI4PzE6ZTwxNjM4ND8yOmU8MjA5NzE1Mj8zOmU8MjY4NDM1NDU2PzQ6NSxlKSkubGVuLHRoaXN9LFdyaXRlci5wcm90b3R5cGUuaW50MzI9ZnVuY3Rpb24oZSl7cmV0dXJuIGU8MD90aGlzLl9wdXNoKHdyaXRlVmFyaW50NjQsMTAsTG9uZ0JpdHMkMS5mcm9tTnVtYmVyKGUpKTp0aGlzLnVpbnQzMihlKX0sV3JpdGVyLnByb3RvdHlwZS5zaW50MzI9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudWludDMyKChlPDwxXmU+PjMxKT4+PjApfSxXcml0ZXIucHJvdG90eXBlLnVpbnQ2ND1mdW5jdGlvbihlKXt2YXIgdD1Mb25nQml0cyQxLmZyb20oZSk7cmV0dXJuIHRoaXMuX3B1c2god3JpdGVWYXJpbnQ2NCx0Lmxlbmd0aCgpLHQpfSxXcml0ZXIucHJvdG90eXBlLmludDY0PVdyaXRlci5wcm90b3R5cGUudWludDY0LFdyaXRlci5wcm90b3R5cGUuc2ludDY0PWZ1bmN0aW9uKGUpe3ZhciB0PUxvbmdCaXRzJDEuZnJvbShlKS56ekVuY29kZSgpO3JldHVybiB0aGlzLl9wdXNoKHdyaXRlVmFyaW50NjQsdC5sZW5ndGgoKSx0KX0sV3JpdGVyLnByb3RvdHlwZS5ib29sPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLl9wdXNoKHdyaXRlQnl0ZSwxLGU/MTowKX0sV3JpdGVyLnByb3RvdHlwZS5maXhlZDMyPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLl9wdXNoKHdyaXRlRml4ZWQzMiw0LGU+Pj4wKX0sV3JpdGVyLnByb3RvdHlwZS5zZml4ZWQzMj1Xcml0ZXIucHJvdG90eXBlLmZpeGVkMzIsV3JpdGVyLnByb3RvdHlwZS5maXhlZDY0PWZ1bmN0aW9uKGUpe3ZhciB0PUxvbmdCaXRzJDEuZnJvbShlKTtyZXR1cm4gdGhpcy5fcHVzaCh3cml0ZUZpeGVkMzIsNCx0LmxvKS5fcHVzaCh3cml0ZUZpeGVkMzIsNCx0LmhpKX0sV3JpdGVyLnByb3RvdHlwZS5zZml4ZWQ2ND1Xcml0ZXIucHJvdG90eXBlLmZpeGVkNjQsV3JpdGVyLnByb3RvdHlwZS5mbG9hdD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5fcHVzaChtaW5pbWFsLmZsb2F0LndyaXRlRmxvYXRMRSw0LGUpfSxXcml0ZXIucHJvdG90eXBlLmRvdWJsZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5fcHVzaChtaW5pbWFsLmZsb2F0LndyaXRlRG91YmxlTEUsOCxlKX07dmFyIHdyaXRlQnl0ZXM9bWluaW1hbC5BcnJheS5wcm90b3R5cGUuc2V0P2Z1bmN0aW9uKGUsdCxhKXt0LnNldChlLGEpfTpmdW5jdGlvbihlLHQsYSl7Zm9yKHZhciByPTA7cjxlLmxlbmd0aDsrK3IpdFthK3JdPWVbcl19O1dyaXRlci5wcm90b3R5cGUuYnl0ZXM9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5sZW5ndGg+Pj4wO2lmKCF0KXJldHVybiB0aGlzLl9wdXNoKHdyaXRlQnl0ZSwxLDApO2lmKG1pbmltYWwuaXNTdHJpbmcoZSkpe3ZhciBhPVdyaXRlci5hbGxvYyh0PWJhc2U2NC5sZW5ndGgoZSkpO2Jhc2U2NC5kZWNvZGUoZSxhLDApLGU9YX1yZXR1cm4gdGhpcy51aW50MzIodCkuX3B1c2god3JpdGVCeXRlcyx0LGUpfSxXcml0ZXIucHJvdG90eXBlLnN0cmluZz1mdW5jdGlvbihlKXt2YXIgdD11dGY4Lmxlbmd0aChlKTtyZXR1cm4gdD90aGlzLnVpbnQzMih0KS5fcHVzaCh1dGY4LndyaXRlLHQsZSk6dGhpcy5fcHVzaCh3cml0ZUJ5dGUsMSwwKX0sV3JpdGVyLnByb3RvdHlwZS5mb3JrPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3RhdGVzPW5ldyBTdGF0ZSh0aGlzKSx0aGlzLmhlYWQ9dGhpcy50YWlsPW5ldyBPcChub29wLDAsMCksdGhpcy5sZW49MCx0aGlzfSxXcml0ZXIucHJvdG90eXBlLnJlc2V0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3RhdGVzPyh0aGlzLmhlYWQ9dGhpcy5zdGF0ZXMuaGVhZCx0aGlzLnRhaWw9dGhpcy5zdGF0ZXMudGFpbCx0aGlzLmxlbj10aGlzLnN0YXRlcy5sZW4sdGhpcy5zdGF0ZXM9dGhpcy5zdGF0ZXMubmV4dCk6KHRoaXMuaGVhZD10aGlzLnRhaWw9bmV3IE9wKG5vb3AsMCwwKSx0aGlzLmxlbj0wKSx0aGlzfSxXcml0ZXIucHJvdG90eXBlLmxkZWxpbT1mdW5jdGlvbigpe3ZhciBlPXRoaXMuaGVhZCx0PXRoaXMudGFpbCxhPXRoaXMubGVuO3JldHVybiB0aGlzLnJlc2V0KCkudWludDMyKGEpLGEmJih0aGlzLnRhaWwubmV4dD1lLm5leHQsdGhpcy50YWlsPXQsdGhpcy5sZW4rPWEpLHRoaXN9LFdyaXRlci5wcm90b3R5cGUuZmluaXNoPWZ1bmN0aW9uKCl7Zm9yKHZhciBlPXRoaXMuaGVhZC5uZXh0LHQ9dGhpcy5jb25zdHJ1Y3Rvci5hbGxvYyh0aGlzLmxlbiksYT0wO2U7KWUuZm4oZS52YWwsdCxhKSxhKz1lLmxlbixlPWUubmV4dDtyZXR1cm4gdH0sV3JpdGVyLl9jb25maWd1cmU9ZnVuY3Rpb24oZSl7QnVmZmVyV3JpdGVyPWV9O3ZhciB3cml0ZXJfYnVmZmVyPUJ1ZmZlcldyaXRlciQxOyhCdWZmZXJXcml0ZXIkMS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh3cml0ZXIucHJvdG90eXBlKSkuY29uc3RydWN0b3I9QnVmZmVyV3JpdGVyJDE7dmFyIEJ1ZmZlcj1taW5pbWFsLkJ1ZmZlcjtmdW5jdGlvbiBCdWZmZXJXcml0ZXIkMSgpe3dyaXRlci5jYWxsKHRoaXMpfUJ1ZmZlcldyaXRlciQxLmFsbG9jPWZ1bmN0aW9uKGUpe3JldHVybihCdWZmZXJXcml0ZXIkMS5hbGxvYz1taW5pbWFsLl9CdWZmZXJfYWxsb2NVbnNhZmUpKGUpfTt2YXIgd3JpdGVCeXRlc0J1ZmZlcj1CdWZmZXImJkJ1ZmZlci5wcm90b3R5cGUgaW5zdGFuY2VvZiBVaW50OEFycmF5JiZcInNldFwiPT09QnVmZmVyLnByb3RvdHlwZS5zZXQubmFtZT9mdW5jdGlvbihlLHQsYSl7dC5zZXQoZSxhKX06ZnVuY3Rpb24oZSx0LGEpe2lmKGUuY29weSllLmNvcHkodCxhLDAsZS5sZW5ndGgpO2Vsc2UgZm9yKHZhciByPTA7cjxlLmxlbmd0aDspdFthKytdPWVbcisrXX07ZnVuY3Rpb24gd3JpdGVTdHJpbmdCdWZmZXIoZSx0LGEpe2UubGVuZ3RoPDQwP21pbmltYWwudXRmOC53cml0ZShlLHQsYSk6dC51dGY4V3JpdGUoZSxhKX1CdWZmZXJXcml0ZXIkMS5wcm90b3R5cGUuYnl0ZXM9ZnVuY3Rpb24oZSl7bWluaW1hbC5pc1N0cmluZyhlKSYmKGU9bWluaW1hbC5fQnVmZmVyX2Zyb20oZSxcImJhc2U2NFwiKSk7dmFyIHQ9ZS5sZW5ndGg+Pj4wO3JldHVybiB0aGlzLnVpbnQzMih0KSx0JiZ0aGlzLl9wdXNoKHdyaXRlQnl0ZXNCdWZmZXIsdCxlKSx0aGlzfSxCdWZmZXJXcml0ZXIkMS5wcm90b3R5cGUuc3RyaW5nPWZ1bmN0aW9uKGUpe3ZhciB0PUJ1ZmZlci5ieXRlTGVuZ3RoKGUpO3JldHVybiB0aGlzLnVpbnQzMih0KSx0JiZ0aGlzLl9wdXNoKHdyaXRlU3RyaW5nQnVmZmVyLHQsZSksdGhpc307dmFyIHJlYWRlcj1SZWFkZXIsQnVmZmVyUmVhZGVyLExvbmdCaXRzJDI9bWluaW1hbC5Mb25nQml0cyx1dGY4JDE9bWluaW1hbC51dGY4O2Z1bmN0aW9uIGluZGV4T3V0T2ZSYW5nZShlLHQpe3JldHVybiBSYW5nZUVycm9yKFwiaW5kZXggb3V0IG9mIHJhbmdlOiBcIitlLnBvcytcIiArIFwiKyh0fHwxKStcIiA+IFwiK2UubGVuKX1mdW5jdGlvbiBSZWFkZXIoZSl7dGhpcy5idWY9ZSx0aGlzLnBvcz0wLHRoaXMubGVuPWUubGVuZ3RofXZhciBjcmVhdGVfYXJyYXk9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFVpbnQ4QXJyYXk/ZnVuY3Rpb24oZSl7aWYoZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXl8fEFycmF5LmlzQXJyYXkoZSkpcmV0dXJuIG5ldyBSZWFkZXIoZSk7dGhyb3cgRXJyb3IoXCJpbGxlZ2FsIGJ1ZmZlclwiKX06ZnVuY3Rpb24oZSl7aWYoQXJyYXkuaXNBcnJheShlKSlyZXR1cm4gbmV3IFJlYWRlcihlKTt0aHJvdyBFcnJvcihcImlsbGVnYWwgYnVmZmVyXCIpfTtmdW5jdGlvbiByZWFkTG9uZ1ZhcmludCgpe3ZhciBlPW5ldyBMb25nQml0cyQyKDAsMCksdD0wO2lmKCEodGhpcy5sZW4tdGhpcy5wb3M+NCkpe2Zvcig7dDwzOysrdCl7aWYodGhpcy5wb3M+PXRoaXMubGVuKXRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzKTtpZihlLmxvPShlLmxvfCgxMjcmdGhpcy5idWZbdGhpcy5wb3NdKTw8Nyp0KT4+PjAsdGhpcy5idWZbdGhpcy5wb3MrK108MTI4KXJldHVybiBlfXJldHVybiBlLmxvPShlLmxvfCgxMjcmdGhpcy5idWZbdGhpcy5wb3MrK10pPDw3KnQpPj4+MCxlfWZvcig7dDw0OysrdClpZihlLmxvPShlLmxvfCgxMjcmdGhpcy5idWZbdGhpcy5wb3NdKTw8Nyp0KT4+PjAsdGhpcy5idWZbdGhpcy5wb3MrK108MTI4KXJldHVybiBlO2lmKGUubG89KGUubG98KDEyNyZ0aGlzLmJ1Zlt0aGlzLnBvc10pPDwyOCk+Pj4wLGUuaGk9KGUuaGl8KDEyNyZ0aGlzLmJ1Zlt0aGlzLnBvc10pPj40KT4+PjAsdGhpcy5idWZbdGhpcy5wb3MrK108MTI4KXJldHVybiBlO2lmKHQ9MCx0aGlzLmxlbi10aGlzLnBvcz40KXtmb3IoO3Q8NTsrK3QpaWYoZS5oaT0oZS5oaXwoMTI3JnRoaXMuYnVmW3RoaXMucG9zXSk8PDcqdCszKT4+PjAsdGhpcy5idWZbdGhpcy5wb3MrK108MTI4KXJldHVybiBlfWVsc2UgZm9yKDt0PDU7Kyt0KXtpZih0aGlzLnBvcz49dGhpcy5sZW4pdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMpO2lmKGUuaGk9KGUuaGl8KDEyNyZ0aGlzLmJ1Zlt0aGlzLnBvc10pPDw3KnQrMyk+Pj4wLHRoaXMuYnVmW3RoaXMucG9zKytdPDEyOClyZXR1cm4gZX10aHJvdyBFcnJvcihcImludmFsaWQgdmFyaW50IGVuY29kaW5nXCIpfWZ1bmN0aW9uIHJlYWRGaXhlZDMyX2VuZChlLHQpe3JldHVybihlW3QtNF18ZVt0LTNdPDw4fGVbdC0yXTw8MTZ8ZVt0LTFdPDwyNCk+Pj4wfWZ1bmN0aW9uIHJlYWRGaXhlZDY0KCl7aWYodGhpcy5wb3MrOD50aGlzLmxlbil0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcyw4KTtyZXR1cm4gbmV3IExvbmdCaXRzJDIocmVhZEZpeGVkMzJfZW5kKHRoaXMuYnVmLHRoaXMucG9zKz00KSxyZWFkRml4ZWQzMl9lbmQodGhpcy5idWYsdGhpcy5wb3MrPTQpKX1SZWFkZXIuY3JlYXRlPW1pbmltYWwuQnVmZmVyP2Z1bmN0aW9uKGUpe3JldHVybihSZWFkZXIuY3JlYXRlPWZ1bmN0aW9uKGUpe3JldHVybiBtaW5pbWFsLkJ1ZmZlci5pc0J1ZmZlcihlKT9uZXcgQnVmZmVyUmVhZGVyKGUpOmNyZWF0ZV9hcnJheShlKX0pKGUpfTpjcmVhdGVfYXJyYXksUmVhZGVyLnByb3RvdHlwZS5fc2xpY2U9bWluaW1hbC5BcnJheS5wcm90b3R5cGUuc3ViYXJyYXl8fG1pbmltYWwuQXJyYXkucHJvdG90eXBlLnNsaWNlLFJlYWRlci5wcm90b3R5cGUudWludDMyPWZ1bmN0aW9uKCl7dmFyIGU9NDI5NDk2NzI5NTtyZXR1cm4gZnVuY3Rpb24oKXtpZihlPSgxMjcmdGhpcy5idWZbdGhpcy5wb3NdKT4+PjAsdGhpcy5idWZbdGhpcy5wb3MrK108MTI4KXJldHVybiBlO2lmKGU9KGV8KDEyNyZ0aGlzLmJ1Zlt0aGlzLnBvc10pPDw3KT4+PjAsdGhpcy5idWZbdGhpcy5wb3MrK108MTI4KXJldHVybiBlO2lmKGU9KGV8KDEyNyZ0aGlzLmJ1Zlt0aGlzLnBvc10pPDwxNCk+Pj4wLHRoaXMuYnVmW3RoaXMucG9zKytdPDEyOClyZXR1cm4gZTtpZihlPShlfCgxMjcmdGhpcy5idWZbdGhpcy5wb3NdKTw8MjEpPj4+MCx0aGlzLmJ1Zlt0aGlzLnBvcysrXTwxMjgpcmV0dXJuIGU7aWYoZT0oZXwoMTUmdGhpcy5idWZbdGhpcy5wb3NdKTw8MjgpPj4+MCx0aGlzLmJ1Zlt0aGlzLnBvcysrXTwxMjgpcmV0dXJuIGU7aWYoKHRoaXMucG9zKz01KT50aGlzLmxlbil0aHJvdyB0aGlzLnBvcz10aGlzLmxlbixpbmRleE91dE9mUmFuZ2UodGhpcywxMCk7cmV0dXJuIGV9fSgpLFJlYWRlci5wcm90b3R5cGUuaW50MzI9ZnVuY3Rpb24oKXtyZXR1cm4gMHx0aGlzLnVpbnQzMigpfSxSZWFkZXIucHJvdG90eXBlLnNpbnQzMj1mdW5jdGlvbigpe3ZhciBlPXRoaXMudWludDMyKCk7cmV0dXJuIGU+Pj4xXi0oMSZlKXwwfSxSZWFkZXIucHJvdG90eXBlLmJvb2w9ZnVuY3Rpb24oKXtyZXR1cm4gMCE9PXRoaXMudWludDMyKCl9LFJlYWRlci5wcm90b3R5cGUuZml4ZWQzMj1mdW5jdGlvbigpe2lmKHRoaXMucG9zKzQ+dGhpcy5sZW4pdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsNCk7cmV0dXJuIHJlYWRGaXhlZDMyX2VuZCh0aGlzLmJ1Zix0aGlzLnBvcys9NCl9LFJlYWRlci5wcm90b3R5cGUuc2ZpeGVkMzI9ZnVuY3Rpb24oKXtpZih0aGlzLnBvcys0PnRoaXMubGVuKXRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLDQpO3JldHVybiAwfHJlYWRGaXhlZDMyX2VuZCh0aGlzLmJ1Zix0aGlzLnBvcys9NCl9LFJlYWRlci5wcm90b3R5cGUuZmxvYXQ9ZnVuY3Rpb24oKXtpZih0aGlzLnBvcys0PnRoaXMubGVuKXRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLDQpO3ZhciBlPW1pbmltYWwuZmxvYXQucmVhZEZsb2F0TEUodGhpcy5idWYsdGhpcy5wb3MpO3JldHVybiB0aGlzLnBvcys9NCxlfSxSZWFkZXIucHJvdG90eXBlLmRvdWJsZT1mdW5jdGlvbigpe2lmKHRoaXMucG9zKzg+dGhpcy5sZW4pdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsNCk7dmFyIGU9bWluaW1hbC5mbG9hdC5yZWFkRG91YmxlTEUodGhpcy5idWYsdGhpcy5wb3MpO3JldHVybiB0aGlzLnBvcys9OCxlfSxSZWFkZXIucHJvdG90eXBlLmJ5dGVzPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy51aW50MzIoKSx0PXRoaXMucG9zLGE9dGhpcy5wb3MrZTtpZihhPnRoaXMubGVuKXRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLGUpO3JldHVybiB0aGlzLnBvcys9ZSxBcnJheS5pc0FycmF5KHRoaXMuYnVmKT90aGlzLmJ1Zi5zbGljZSh0LGEpOnQ9PT1hP25ldyB0aGlzLmJ1Zi5jb25zdHJ1Y3RvcigwKTp0aGlzLl9zbGljZS5jYWxsKHRoaXMuYnVmLHQsYSl9LFJlYWRlci5wcm90b3R5cGUuc3RyaW5nPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5ieXRlcygpO3JldHVybiB1dGY4JDEucmVhZChlLDAsZS5sZW5ndGgpfSxSZWFkZXIucHJvdG90eXBlLnNraXA9ZnVuY3Rpb24oZSl7aWYoXCJudW1iZXJcIj09dHlwZW9mIGUpe2lmKHRoaXMucG9zK2U+dGhpcy5sZW4pdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsZSk7dGhpcy5wb3MrPWV9ZWxzZSBkb3tpZih0aGlzLnBvcz49dGhpcy5sZW4pdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMpfXdoaWxlKDEyOCZ0aGlzLmJ1Zlt0aGlzLnBvcysrXSk7cmV0dXJuIHRoaXN9LFJlYWRlci5wcm90b3R5cGUuc2tpcFR5cGU9ZnVuY3Rpb24oZSl7c3dpdGNoKGUpe2Nhc2UgMDp0aGlzLnNraXAoKTticmVhaztjYXNlIDE6dGhpcy5za2lwKDgpO2JyZWFrO2Nhc2UgMjp0aGlzLnNraXAodGhpcy51aW50MzIoKSk7YnJlYWs7Y2FzZSAzOmZvcig7Oyl7aWYoND09KGU9NyZ0aGlzLnVpbnQzMigpKSlicmVhazt0aGlzLnNraXBUeXBlKGUpfWJyZWFrO2Nhc2UgNTp0aGlzLnNraXAoNCk7YnJlYWs7ZGVmYXVsdDp0aHJvdyBFcnJvcihcImludmFsaWQgd2lyZSB0eXBlIFwiK2UrXCIgYXQgb2Zmc2V0IFwiK3RoaXMucG9zKX1yZXR1cm4gdGhpc30sUmVhZGVyLl9jb25maWd1cmU9ZnVuY3Rpb24oZSl7QnVmZmVyUmVhZGVyPWU7dmFyIHQ9bWluaW1hbC5Mb25nP1widG9Mb25nXCI6XCJ0b051bWJlclwiO21pbmltYWwubWVyZ2UoUmVhZGVyLnByb3RvdHlwZSx7aW50NjQ6ZnVuY3Rpb24oKXtyZXR1cm4gcmVhZExvbmdWYXJpbnQuY2FsbCh0aGlzKVt0XSghMSl9LHVpbnQ2NDpmdW5jdGlvbigpe3JldHVybiByZWFkTG9uZ1ZhcmludC5jYWxsKHRoaXMpW3RdKCEwKX0sc2ludDY0OmZ1bmN0aW9uKCl7cmV0dXJuIHJlYWRMb25nVmFyaW50LmNhbGwodGhpcykuenpEZWNvZGUoKVt0XSghMSl9LGZpeGVkNjQ6ZnVuY3Rpb24oKXtyZXR1cm4gcmVhZEZpeGVkNjQuY2FsbCh0aGlzKVt0XSghMCl9LHNmaXhlZDY0OmZ1bmN0aW9uKCl7cmV0dXJuIHJlYWRGaXhlZDY0LmNhbGwodGhpcylbdF0oITEpfX0pfTt2YXIgcmVhZGVyX2J1ZmZlcj1CdWZmZXJSZWFkZXIkMTtmdW5jdGlvbiBCdWZmZXJSZWFkZXIkMShlKXtyZWFkZXIuY2FsbCh0aGlzLGUpfShCdWZmZXJSZWFkZXIkMS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShyZWFkZXIucHJvdG90eXBlKSkuY29uc3RydWN0b3I9QnVmZmVyUmVhZGVyJDEsbWluaW1hbC5CdWZmZXImJihCdWZmZXJSZWFkZXIkMS5wcm90b3R5cGUuX3NsaWNlPW1pbmltYWwuQnVmZmVyLnByb3RvdHlwZS5zbGljZSksQnVmZmVyUmVhZGVyJDEucHJvdG90eXBlLnN0cmluZz1mdW5jdGlvbigpe3ZhciBlPXRoaXMudWludDMyKCk7cmV0dXJuIHRoaXMuYnVmLnV0ZjhTbGljZSh0aGlzLnBvcyx0aGlzLnBvcz1NYXRoLm1pbih0aGlzLnBvcytlLHRoaXMubGVuKSl9O3ZhciBzZXJ2aWNlPVNlcnZpY2U7ZnVuY3Rpb24gU2VydmljZShlLHQsYSl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZSl0aHJvdyBUeXBlRXJyb3IoXCJycGNJbXBsIG11c3QgYmUgYSBmdW5jdGlvblwiKTttaW5pbWFsLkV2ZW50RW1pdHRlci5jYWxsKHRoaXMpLHRoaXMucnBjSW1wbD1lLHRoaXMucmVxdWVzdERlbGltaXRlZD1Cb29sZWFuKHQpLHRoaXMucmVzcG9uc2VEZWxpbWl0ZWQ9Qm9vbGVhbihhKX0oU2VydmljZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShtaW5pbWFsLkV2ZW50RW1pdHRlci5wcm90b3R5cGUpKS5jb25zdHJ1Y3Rvcj1TZXJ2aWNlLFNlcnZpY2UucHJvdG90eXBlLnJwY0NhbGw9ZnVuY3Rpb24gZSh0LGEscixuLG8pe2lmKCFuKXRocm93IFR5cGVFcnJvcihcInJlcXVlc3QgbXVzdCBiZSBzcGVjaWZpZWRcIik7dmFyIHM9dGhpcztpZighbylyZXR1cm4gbWluaW1hbC5hc1Byb21pc2UoZSxzLHQsYSxyLG4pO2lmKHMucnBjSW1wbCl0cnl7cmV0dXJuIHMucnBjSW1wbCh0LGFbcy5yZXF1ZXN0RGVsaW1pdGVkP1wiZW5jb2RlRGVsaW1pdGVkXCI6XCJlbmNvZGVcIl0obikuZmluaXNoKCksZnVuY3Rpb24oZSxhKXtpZihlKXJldHVybiBzLmVtaXQoXCJlcnJvclwiLGUsdCksbyhlKTtpZihudWxsIT09YSl7aWYoIShhIGluc3RhbmNlb2YgcikpdHJ5e2E9cltzLnJlc3BvbnNlRGVsaW1pdGVkP1wiZGVjb2RlRGVsaW1pdGVkXCI6XCJkZWNvZGVcIl0oYSl9Y2F0Y2goZSl7cmV0dXJuIHMuZW1pdChcImVycm9yXCIsZSx0KSxvKGUpfXJldHVybiBzLmVtaXQoXCJkYXRhXCIsYSx0KSxvKG51bGwsYSl9cy5lbmQoITApfSl9Y2F0Y2goZSl7cmV0dXJuIHMuZW1pdChcImVycm9yXCIsZSx0KSx2b2lkIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtvKGUpfSwwKX1lbHNlIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtvKEVycm9yKFwiYWxyZWFkeSBlbmRlZFwiKSl9LDApfSxTZXJ2aWNlLnByb3RvdHlwZS5lbmQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucnBjSW1wbCYmKGV8fHRoaXMucnBjSW1wbChudWxsLG51bGwsbnVsbCksdGhpcy5ycGNJbXBsPW51bGwsdGhpcy5lbWl0KFwiZW5kXCIpLm9mZigpKSx0aGlzfTt2YXIgcnBjXzE9Y3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24oZSx0KXt0LlNlcnZpY2U9c2VydmljZX0pLHJvb3RzPXt9LGluZGV4TWluaW1hbD1jcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbihlLHQpe3ZhciBhPXQ7ZnVuY3Rpb24gcigpe2EuUmVhZGVyLl9jb25maWd1cmUoYS5CdWZmZXJSZWFkZXIpLGEudXRpbC5fY29uZmlndXJlKCl9YS5idWlsZD1cIm1pbmltYWxcIixhLldyaXRlcj13cml0ZXIsYS5CdWZmZXJXcml0ZXI9d3JpdGVyX2J1ZmZlcixhLlJlYWRlcj1yZWFkZXIsYS5CdWZmZXJSZWFkZXI9cmVhZGVyX2J1ZmZlcixhLnV0aWw9bWluaW1hbCxhLnJwYz1ycGNfMSxhLnJvb3RzPXJvb3RzLGEuY29uZmlndXJlPXIsYS5Xcml0ZXIuX2NvbmZpZ3VyZShhLkJ1ZmZlcldyaXRlcikscigpfSksbWluaW1hbCQxPWluZGV4TWluaW1hbCxtaW5pbWFsXzE9bWluaW1hbCQxLnJvb3RzLG1pbmltYWxfMj1taW5pbWFsJDEuUmVhZGVyLG1pbmltYWxfMz1taW5pbWFsJDEudXRpbCwkUmVhZGVyPW1pbmltYWwkMS5SZWFkZXIsJHV0aWw9bWluaW1hbCQxLnV0aWwsJHJvb3Q9bWluaW1hbCQxLnJvb3RzLmRlZmF1bHR8fChtaW5pbWFsJDEucm9vdHMuZGVmYXVsdD17fSk7JHJvb3QudGVuc29yZmxvdz1mdW5jdGlvbigpe3ZhciBlLHQsYT17fTtyZXR1cm4gYS5Bbnk9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUpe2lmKGUpZm9yKHZhciB0PU9iamVjdC5rZXlzKGUpLGE9MDthPHQubGVuZ3RoOysrYSludWxsIT1lW3RbYV1dJiYodGhpc1t0W2FdXT1lW3RbYV1dKX1yZXR1cm4gZS5wcm90b3R5cGUudHlwZVVybD1cIlwiLGUucHJvdG90eXBlLnZhbHVlPSR1dGlsLm5ld0J1ZmZlcihbXSksZS5kZWNvZGU9ZnVuY3Rpb24oZSx0KXtlIGluc3RhbmNlb2YgJFJlYWRlcnx8KGU9JFJlYWRlci5jcmVhdGUoZSkpO2Zvcih2YXIgYT12b2lkIDA9PT10P2UubGVuOmUucG9zK3Qscj1uZXcgJHJvb3QudGVuc29yZmxvdy5Bbnk7ZS5wb3M8YTspe3ZhciBuPWUudWludDMyKCk7c3dpdGNoKG4+Pj4zKXtjYXNlIDE6ci50eXBlVXJsPWUuc3RyaW5nKCk7YnJlYWs7Y2FzZSAyOnIudmFsdWU9ZS5ieXRlcygpO2JyZWFrO2RlZmF1bHQ6ZS5za2lwVHlwZSg3Jm4pfX1yZXR1cm4gcn0sZX0oKSxhLkRhdGFUeXBlPShlPXt9LCh0PU9iamVjdC5jcmVhdGUoZSkpW2VbMF09XCJEVF9JTlZBTElEXCJdPTAsdFtlWzFdPVwiRFRfRkxPQVRcIl09MSx0W2VbMl09XCJEVF9ET1VCTEVcIl09Mix0W2VbM109XCJEVF9JTlQzMlwiXT0zLHRbZVs0XT1cIkRUX1VJTlQ4XCJdPTQsdFtlWzVdPVwiRFRfSU5UMTZcIl09NSx0W2VbNl09XCJEVF9JTlQ4XCJdPTYsdFtlWzddPVwiRFRfU1RSSU5HXCJdPTcsdFtlWzhdPVwiRFRfQ09NUExFWDY0XCJdPTgsdFtlWzldPVwiRFRfSU5UNjRcIl09OSx0W2VbMTBdPVwiRFRfQk9PTFwiXT0xMCx0W2VbMTFdPVwiRFRfUUlOVDhcIl09MTEsdFtlWzEyXT1cIkRUX1FVSU5UOFwiXT0xMix0W2VbMTNdPVwiRFRfUUlOVDMyXCJdPTEzLHRbZVsxNF09XCJEVF9CRkxPQVQxNlwiXT0xNCx0W2VbMTAxXT1cIkRUX0ZMT0FUX1JFRlwiXT0xMDEsdFtlWzEwMl09XCJEVF9ET1VCTEVfUkVGXCJdPTEwMix0W2VbMTAzXT1cIkRUX0lOVDMyX1JFRlwiXT0xMDMsdFtlWzEwNF09XCJEVF9VSU5UOF9SRUZcIl09MTA0LHRbZVsxMDVdPVwiRFRfSU5UMTZfUkVGXCJdPTEwNSx0W2VbMTA2XT1cIkRUX0lOVDhfUkVGXCJdPTEwNix0W2VbMTA3XT1cIkRUX1NUUklOR19SRUZcIl09MTA3LHRbZVsxMDhdPVwiRFRfQ09NUExFWDY0X1JFRlwiXT0xMDgsdFtlWzEwOV09XCJEVF9JTlQ2NF9SRUZcIl09MTA5LHRbZVsxMTBdPVwiRFRfQk9PTF9SRUZcIl09MTEwLHRbZVsxMTFdPVwiRFRfUUlOVDhfUkVGXCJdPTExMSx0W2VbMTEyXT1cIkRUX1FVSU5UOF9SRUZcIl09MTEyLHRbZVsxMTNdPVwiRFRfUUlOVDMyX1JFRlwiXT0xMTMsdFtlWzExNF09XCJEVF9CRkxPQVQxNl9SRUZcIl09MTE0LHQpLGEuVGVuc29yU2hhcGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUpe2lmKHRoaXMuZGltPVtdLGUpZm9yKHZhciB0PU9iamVjdC5rZXlzKGUpLGE9MDthPHQubGVuZ3RoOysrYSludWxsIT1lW3RbYV1dJiYodGhpc1t0W2FdXT1lW3RbYV1dKX1yZXR1cm4gZS5wcm90b3R5cGUuZGltPSR1dGlsLmVtcHR5QXJyYXksZS5wcm90b3R5cGUudW5rbm93blJhbms9ITEsZS5kZWNvZGU9ZnVuY3Rpb24oZSx0KXtlIGluc3RhbmNlb2YgJFJlYWRlcnx8KGU9JFJlYWRlci5jcmVhdGUoZSkpO2Zvcih2YXIgYT12b2lkIDA9PT10P2UubGVuOmUucG9zK3Qscj1uZXcgJHJvb3QudGVuc29yZmxvdy5UZW5zb3JTaGFwZTtlLnBvczxhOyl7dmFyIG49ZS51aW50MzIoKTtzd2l0Y2gobj4+PjMpe2Nhc2UgMjpyLmRpbSYmci5kaW0ubGVuZ3RofHwoci5kaW09W10pLHIuZGltLnB1c2goJHJvb3QudGVuc29yZmxvdy5UZW5zb3JTaGFwZS5EaW0uZGVjb2RlKGUsZS51aW50MzIoKSkpO2JyZWFrO2Nhc2UgMzpyLnVua25vd25SYW5rPWUuYm9vbCgpO2JyZWFrO2RlZmF1bHQ6ZS5za2lwVHlwZSg3Jm4pfX1yZXR1cm4gcn0sZS5EaW09ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUpe2lmKGUpZm9yKHZhciB0PU9iamVjdC5rZXlzKGUpLGE9MDthPHQubGVuZ3RoOysrYSludWxsIT1lW3RbYV1dJiYodGhpc1t0W2FdXT1lW3RbYV1dKX1yZXR1cm4gZS5wcm90b3R5cGUuc2l6ZT0kdXRpbC5Mb25nPyR1dGlsLkxvbmcuZnJvbUJpdHMoMCwwLCExKTowLGUucHJvdG90eXBlLm5hbWU9XCJcIixlLmRlY29kZT1mdW5jdGlvbihlLHQpe2UgaW5zdGFuY2VvZiAkUmVhZGVyfHwoZT0kUmVhZGVyLmNyZWF0ZShlKSk7Zm9yKHZhciBhPXZvaWQgMD09PXQ/ZS5sZW46ZS5wb3MrdCxyPW5ldyAkcm9vdC50ZW5zb3JmbG93LlRlbnNvclNoYXBlLkRpbTtlLnBvczxhOyl7dmFyIG49ZS51aW50MzIoKTtzd2l0Y2gobj4+PjMpe2Nhc2UgMTpyLnNpemU9ZS5pbnQ2NCgpO2JyZWFrO2Nhc2UgMjpyLm5hbWU9ZS5zdHJpbmcoKTticmVhaztkZWZhdWx0OmUuc2tpcFR5cGUoNyZuKX19cmV0dXJuIHJ9LGV9KCksZX0oKSxhLlRlbnNvcj1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSl7aWYodGhpcy5mbG9hdFZhbD1bXSx0aGlzLmRvdWJsZVZhbD1bXSx0aGlzLmludFZhbD1bXSx0aGlzLnN0cmluZ1ZhbD1bXSx0aGlzLnNjb21wbGV4VmFsPVtdLHRoaXMuaW50NjRWYWw9W10sdGhpcy5ib29sVmFsPVtdLHRoaXMudWludDMyVmFsPVtdLHRoaXMudWludDY0VmFsPVtdLGUpZm9yKHZhciB0PU9iamVjdC5rZXlzKGUpLGE9MDthPHQubGVuZ3RoOysrYSludWxsIT1lW3RbYV1dJiYodGhpc1t0W2FdXT1lW3RbYV1dKX1yZXR1cm4gZS5wcm90b3R5cGUuZHR5cGU9MCxlLnByb3RvdHlwZS50ZW5zb3JTaGFwZT1udWxsLGUucHJvdG90eXBlLnZlcnNpb25OdW1iZXI9MCxlLnByb3RvdHlwZS50ZW5zb3JDb250ZW50PSR1dGlsLm5ld0J1ZmZlcihbXSksZS5wcm90b3R5cGUuZmxvYXRWYWw9JHV0aWwuZW1wdHlBcnJheSxlLnByb3RvdHlwZS5kb3VibGVWYWw9JHV0aWwuZW1wdHlBcnJheSxlLnByb3RvdHlwZS5pbnRWYWw9JHV0aWwuZW1wdHlBcnJheSxlLnByb3RvdHlwZS5zdHJpbmdWYWw9JHV0aWwuZW1wdHlBcnJheSxlLnByb3RvdHlwZS5zY29tcGxleFZhbD0kdXRpbC5lbXB0eUFycmF5LGUucHJvdG90eXBlLmludDY0VmFsPSR1dGlsLmVtcHR5QXJyYXksZS5wcm90b3R5cGUuYm9vbFZhbD0kdXRpbC5lbXB0eUFycmF5LGUucHJvdG90eXBlLnVpbnQzMlZhbD0kdXRpbC5lbXB0eUFycmF5LGUucHJvdG90eXBlLnVpbnQ2NFZhbD0kdXRpbC5lbXB0eUFycmF5LGUuZGVjb2RlPWZ1bmN0aW9uKGUsdCl7ZSBpbnN0YW5jZW9mICRSZWFkZXJ8fChlPSRSZWFkZXIuY3JlYXRlKGUpKTtmb3IodmFyIGE9dm9pZCAwPT09dD9lLmxlbjplLnBvcyt0LHI9bmV3ICRyb290LnRlbnNvcmZsb3cuVGVuc29yO2UucG9zPGE7KXt2YXIgbj1lLnVpbnQzMigpO3N3aXRjaChuPj4+Myl7Y2FzZSAxOnIuZHR5cGU9ZS5pbnQzMigpO2JyZWFrO2Nhc2UgMjpyLnRlbnNvclNoYXBlPSRyb290LnRlbnNvcmZsb3cuVGVuc29yU2hhcGUuZGVjb2RlKGUsZS51aW50MzIoKSk7YnJlYWs7Y2FzZSAzOnIudmVyc2lvbk51bWJlcj1lLmludDMyKCk7YnJlYWs7Y2FzZSA0OnIudGVuc29yQ29udGVudD1lLmJ5dGVzKCk7YnJlYWs7Y2FzZSA1OmlmKHIuZmxvYXRWYWwmJnIuZmxvYXRWYWwubGVuZ3RofHwoci5mbG9hdFZhbD1bXSksMj09KDcmbikpZm9yKHZhciBvPWUudWludDMyKCkrZS5wb3M7ZS5wb3M8bzspci5mbG9hdFZhbC5wdXNoKGUuZmxvYXQoKSk7ZWxzZSByLmZsb2F0VmFsLnB1c2goZS5mbG9hdCgpKTticmVhaztjYXNlIDY6aWYoci5kb3VibGVWYWwmJnIuZG91YmxlVmFsLmxlbmd0aHx8KHIuZG91YmxlVmFsPVtdKSwyPT0oNyZuKSlmb3Iobz1lLnVpbnQzMigpK2UucG9zO2UucG9zPG87KXIuZG91YmxlVmFsLnB1c2goZS5kb3VibGUoKSk7ZWxzZSByLmRvdWJsZVZhbC5wdXNoKGUuZG91YmxlKCkpO2JyZWFrO2Nhc2UgNzppZihyLmludFZhbCYmci5pbnRWYWwubGVuZ3RofHwoci5pbnRWYWw9W10pLDI9PSg3Jm4pKWZvcihvPWUudWludDMyKCkrZS5wb3M7ZS5wb3M8bzspci5pbnRWYWwucHVzaChlLmludDMyKCkpO2Vsc2Ugci5pbnRWYWwucHVzaChlLmludDMyKCkpO2JyZWFrO2Nhc2UgODpyLnN0cmluZ1ZhbCYmci5zdHJpbmdWYWwubGVuZ3RofHwoci5zdHJpbmdWYWw9W10pLHIuc3RyaW5nVmFsLnB1c2goZS5ieXRlcygpKTticmVhaztjYXNlIDk6aWYoci5zY29tcGxleFZhbCYmci5zY29tcGxleFZhbC5sZW5ndGh8fChyLnNjb21wbGV4VmFsPVtdKSwyPT0oNyZuKSlmb3Iobz1lLnVpbnQzMigpK2UucG9zO2UucG9zPG87KXIuc2NvbXBsZXhWYWwucHVzaChlLmZsb2F0KCkpO2Vsc2Ugci5zY29tcGxleFZhbC5wdXNoKGUuZmxvYXQoKSk7YnJlYWs7Y2FzZSAxMDppZihyLmludDY0VmFsJiZyLmludDY0VmFsLmxlbmd0aHx8KHIuaW50NjRWYWw9W10pLDI9PSg3Jm4pKWZvcihvPWUudWludDMyKCkrZS5wb3M7ZS5wb3M8bzspci5pbnQ2NFZhbC5wdXNoKGUuaW50NjQoKSk7ZWxzZSByLmludDY0VmFsLnB1c2goZS5pbnQ2NCgpKTticmVhaztjYXNlIDExOmlmKHIuYm9vbFZhbCYmci5ib29sVmFsLmxlbmd0aHx8KHIuYm9vbFZhbD1bXSksMj09KDcmbikpZm9yKG89ZS51aW50MzIoKStlLnBvcztlLnBvczxvOylyLmJvb2xWYWwucHVzaChlLmJvb2woKSk7ZWxzZSByLmJvb2xWYWwucHVzaChlLmJvb2woKSk7YnJlYWs7Y2FzZSAxNjppZihyLnVpbnQzMlZhbCYmci51aW50MzJWYWwubGVuZ3RofHwoci51aW50MzJWYWw9W10pLDI9PSg3Jm4pKWZvcihvPWUudWludDMyKCkrZS5wb3M7ZS5wb3M8bzspci51aW50MzJWYWwucHVzaChlLnVpbnQzMigpKTtlbHNlIHIudWludDMyVmFsLnB1c2goZS51aW50MzIoKSk7YnJlYWs7Y2FzZSAxNzppZihyLnVpbnQ2NFZhbCYmci51aW50NjRWYWwubGVuZ3RofHwoci51aW50NjRWYWw9W10pLDI9PSg3Jm4pKWZvcihvPWUudWludDMyKCkrZS5wb3M7ZS5wb3M8bzspci51aW50NjRWYWwucHVzaChlLnVpbnQ2NCgpKTtlbHNlIHIudWludDY0VmFsLnB1c2goZS51aW50NjQoKSk7YnJlYWs7ZGVmYXVsdDplLnNraXBUeXBlKDcmbil9fXJldHVybiByfSxlfSgpLGEuQXR0clZhbHVlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlKXtpZihlKWZvcih2YXIgdD1PYmplY3Qua2V5cyhlKSxhPTA7YTx0Lmxlbmd0aDsrK2EpbnVsbCE9ZVt0W2FdXSYmKHRoaXNbdFthXV09ZVt0W2FdXSl9dmFyIHQ7cmV0dXJuIGUucHJvdG90eXBlLmxpc3Q9bnVsbCxlLnByb3RvdHlwZS5zPSR1dGlsLm5ld0J1ZmZlcihbXSksZS5wcm90b3R5cGUuaT0kdXRpbC5Mb25nPyR1dGlsLkxvbmcuZnJvbUJpdHMoMCwwLCExKTowLGUucHJvdG90eXBlLmY9MCxlLnByb3RvdHlwZS5iPSExLGUucHJvdG90eXBlLnR5cGU9MCxlLnByb3RvdHlwZS5zaGFwZT1udWxsLGUucHJvdG90eXBlLnRlbnNvcj1udWxsLGUucHJvdG90eXBlLnBsYWNlaG9sZGVyPVwiXCIsZS5wcm90b3R5cGUuZnVuYz1udWxsLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcInZhbHVlXCIse2dldDokdXRpbC5vbmVPZkdldHRlcih0PVtcImxpc3RcIixcInNcIixcImlcIixcImZcIixcImJcIixcInR5cGVcIixcInNoYXBlXCIsXCJ0ZW5zb3JcIixcInBsYWNlaG9sZGVyXCIsXCJmdW5jXCJdKSxzZXQ6JHV0aWwub25lT2ZTZXR0ZXIodCl9KSxlLmRlY29kZT1mdW5jdGlvbihlLHQpe2UgaW5zdGFuY2VvZiAkUmVhZGVyfHwoZT0kUmVhZGVyLmNyZWF0ZShlKSk7Zm9yKHZhciBhPXZvaWQgMD09PXQ/ZS5sZW46ZS5wb3MrdCxyPW5ldyAkcm9vdC50ZW5zb3JmbG93LkF0dHJWYWx1ZTtlLnBvczxhOyl7dmFyIG49ZS51aW50MzIoKTtzd2l0Y2gobj4+PjMpe2Nhc2UgMTpyLmxpc3Q9JHJvb3QudGVuc29yZmxvdy5BdHRyVmFsdWUuTGlzdFZhbHVlLmRlY29kZShlLGUudWludDMyKCkpO2JyZWFrO2Nhc2UgMjpyLnM9ZS5ieXRlcygpO2JyZWFrO2Nhc2UgMzpyLmk9ZS5pbnQ2NCgpO2JyZWFrO2Nhc2UgNDpyLmY9ZS5mbG9hdCgpO2JyZWFrO2Nhc2UgNTpyLmI9ZS5ib29sKCk7YnJlYWs7Y2FzZSA2OnIudHlwZT1lLmludDMyKCk7YnJlYWs7Y2FzZSA3OnIuc2hhcGU9JHJvb3QudGVuc29yZmxvdy5UZW5zb3JTaGFwZS5kZWNvZGUoZSxlLnVpbnQzMigpKTticmVhaztjYXNlIDg6ci50ZW5zb3I9JHJvb3QudGVuc29yZmxvdy5UZW5zb3IuZGVjb2RlKGUsZS51aW50MzIoKSk7YnJlYWs7Y2FzZSA5OnIucGxhY2Vob2xkZXI9ZS5zdHJpbmcoKTticmVhaztjYXNlIDEwOnIuZnVuYz0kcm9vdC50ZW5zb3JmbG93Lk5hbWVBdHRyTGlzdC5kZWNvZGUoZSxlLnVpbnQzMigpKTticmVhaztkZWZhdWx0OmUuc2tpcFR5cGUoNyZuKX19cmV0dXJuIHJ9LGUuTGlzdFZhbHVlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlKXtpZih0aGlzLnM9W10sdGhpcy5pPVtdLHRoaXMuZj1bXSx0aGlzLmI9W10sdGhpcy50eXBlPVtdLHRoaXMuc2hhcGU9W10sdGhpcy50ZW5zb3I9W10sdGhpcy5mdW5jPVtdLGUpZm9yKHZhciB0PU9iamVjdC5rZXlzKGUpLGE9MDthPHQubGVuZ3RoOysrYSludWxsIT1lW3RbYV1dJiYodGhpc1t0W2FdXT1lW3RbYV1dKX1yZXR1cm4gZS5wcm90b3R5cGUucz0kdXRpbC5lbXB0eUFycmF5LGUucHJvdG90eXBlLmk9JHV0aWwuZW1wdHlBcnJheSxlLnByb3RvdHlwZS5mPSR1dGlsLmVtcHR5QXJyYXksZS5wcm90b3R5cGUuYj0kdXRpbC5lbXB0eUFycmF5LGUucHJvdG90eXBlLnR5cGU9JHV0aWwuZW1wdHlBcnJheSxlLnByb3RvdHlwZS5zaGFwZT0kdXRpbC5lbXB0eUFycmF5LGUucHJvdG90eXBlLnRlbnNvcj0kdXRpbC5lbXB0eUFycmF5LGUucHJvdG90eXBlLmZ1bmM9JHV0aWwuZW1wdHlBcnJheSxlLmRlY29kZT1mdW5jdGlvbihlLHQpe2UgaW5zdGFuY2VvZiAkUmVhZGVyfHwoZT0kUmVhZGVyLmNyZWF0ZShlKSk7Zm9yKHZhciBhPXZvaWQgMD09PXQ/ZS5sZW46ZS5wb3MrdCxyPW5ldyAkcm9vdC50ZW5zb3JmbG93LkF0dHJWYWx1ZS5MaXN0VmFsdWU7ZS5wb3M8YTspe3ZhciBuPWUudWludDMyKCk7c3dpdGNoKG4+Pj4zKXtjYXNlIDI6ci5zJiZyLnMubGVuZ3RofHwoci5zPVtdKSxyLnMucHVzaChlLmJ5dGVzKCkpO2JyZWFrO2Nhc2UgMzppZihyLmkmJnIuaS5sZW5ndGh8fChyLmk9W10pLDI9PSg3Jm4pKWZvcih2YXIgbz1lLnVpbnQzMigpK2UucG9zO2UucG9zPG87KXIuaS5wdXNoKGUuaW50NjQoKSk7ZWxzZSByLmkucHVzaChlLmludDY0KCkpO2JyZWFrO2Nhc2UgNDppZihyLmYmJnIuZi5sZW5ndGh8fChyLmY9W10pLDI9PSg3Jm4pKWZvcihvPWUudWludDMyKCkrZS5wb3M7ZS5wb3M8bzspci5mLnB1c2goZS5mbG9hdCgpKTtlbHNlIHIuZi5wdXNoKGUuZmxvYXQoKSk7YnJlYWs7Y2FzZSA1OmlmKHIuYiYmci5iLmxlbmd0aHx8KHIuYj1bXSksMj09KDcmbikpZm9yKG89ZS51aW50MzIoKStlLnBvcztlLnBvczxvOylyLmIucHVzaChlLmJvb2woKSk7ZWxzZSByLmIucHVzaChlLmJvb2woKSk7YnJlYWs7Y2FzZSA2OmlmKHIudHlwZSYmci50eXBlLmxlbmd0aHx8KHIudHlwZT1bXSksMj09KDcmbikpZm9yKG89ZS51aW50MzIoKStlLnBvcztlLnBvczxvOylyLnR5cGUucHVzaChlLmludDMyKCkpO2Vsc2Ugci50eXBlLnB1c2goZS5pbnQzMigpKTticmVhaztjYXNlIDc6ci5zaGFwZSYmci5zaGFwZS5sZW5ndGh8fChyLnNoYXBlPVtdKSxyLnNoYXBlLnB1c2goJHJvb3QudGVuc29yZmxvdy5UZW5zb3JTaGFwZS5kZWNvZGUoZSxlLnVpbnQzMigpKSk7YnJlYWs7Y2FzZSA4OnIudGVuc29yJiZyLnRlbnNvci5sZW5ndGh8fChyLnRlbnNvcj1bXSksci50ZW5zb3IucHVzaCgkcm9vdC50ZW5zb3JmbG93LlRlbnNvci5kZWNvZGUoZSxlLnVpbnQzMigpKSk7YnJlYWs7Y2FzZSA5OnIuZnVuYyYmci5mdW5jLmxlbmd0aHx8KHIuZnVuYz1bXSksci5mdW5jLnB1c2goJHJvb3QudGVuc29yZmxvdy5OYW1lQXR0ckxpc3QuZGVjb2RlKGUsZS51aW50MzIoKSkpO2JyZWFrO2RlZmF1bHQ6ZS5za2lwVHlwZSg3Jm4pfX1yZXR1cm4gcn0sZX0oKSxlfSgpLGEuTmFtZUF0dHJMaXN0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlKXtpZih0aGlzLmF0dHI9e30sZSlmb3IodmFyIHQ9T2JqZWN0LmtleXMoZSksYT0wO2E8dC5sZW5ndGg7KythKW51bGwhPWVbdFthXV0mJih0aGlzW3RbYV1dPWVbdFthXV0pfXJldHVybiBlLnByb3RvdHlwZS5uYW1lPVwiXCIsZS5wcm90b3R5cGUuYXR0cj0kdXRpbC5lbXB0eU9iamVjdCxlLmRlY29kZT1mdW5jdGlvbihlLHQpe2UgaW5zdGFuY2VvZiAkUmVhZGVyfHwoZT0kUmVhZGVyLmNyZWF0ZShlKSk7Zm9yKHZhciBhLHI9dm9pZCAwPT09dD9lLmxlbjplLnBvcyt0LG49bmV3ICRyb290LnRlbnNvcmZsb3cuTmFtZUF0dHJMaXN0O2UucG9zPHI7KXt2YXIgbz1lLnVpbnQzMigpO3N3aXRjaChvPj4+Myl7Y2FzZSAxOm4ubmFtZT1lLnN0cmluZygpO2JyZWFrO2Nhc2UgMjplLnNraXAoKS5wb3MrKyxuLmF0dHI9PT0kdXRpbC5lbXB0eU9iamVjdCYmKG4uYXR0cj17fSksYT1lLnN0cmluZygpLGUucG9zKyssbi5hdHRyW2FdPSRyb290LnRlbnNvcmZsb3cuQXR0clZhbHVlLmRlY29kZShlLGUudWludDMyKCkpO2JyZWFrO2RlZmF1bHQ6ZS5za2lwVHlwZSg3Jm8pfX1yZXR1cm4gbn0sZX0oKSxhLk5vZGVEZWY9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUpe2lmKHRoaXMuaW5wdXQ9W10sdGhpcy5hdHRyPXt9LGUpZm9yKHZhciB0PU9iamVjdC5rZXlzKGUpLGE9MDthPHQubGVuZ3RoOysrYSludWxsIT1lW3RbYV1dJiYodGhpc1t0W2FdXT1lW3RbYV1dKX1yZXR1cm4gZS5wcm90b3R5cGUubmFtZT1cIlwiLGUucHJvdG90eXBlLm9wPVwiXCIsZS5wcm90b3R5cGUuaW5wdXQ9JHV0aWwuZW1wdHlBcnJheSxlLnByb3RvdHlwZS5kZXZpY2U9XCJcIixlLnByb3RvdHlwZS5hdHRyPSR1dGlsLmVtcHR5T2JqZWN0LGUuZGVjb2RlPWZ1bmN0aW9uKGUsdCl7ZSBpbnN0YW5jZW9mICRSZWFkZXJ8fChlPSRSZWFkZXIuY3JlYXRlKGUpKTtmb3IodmFyIGEscj12b2lkIDA9PT10P2UubGVuOmUucG9zK3Qsbj1uZXcgJHJvb3QudGVuc29yZmxvdy5Ob2RlRGVmO2UucG9zPHI7KXt2YXIgbz1lLnVpbnQzMigpO3N3aXRjaChvPj4+Myl7Y2FzZSAxOm4ubmFtZT1lLnN0cmluZygpO2JyZWFrO2Nhc2UgMjpuLm9wPWUuc3RyaW5nKCk7YnJlYWs7Y2FzZSAzOm4uaW5wdXQmJm4uaW5wdXQubGVuZ3RofHwobi5pbnB1dD1bXSksbi5pbnB1dC5wdXNoKGUuc3RyaW5nKCkpO2JyZWFrO2Nhc2UgNDpuLmRldmljZT1lLnN0cmluZygpO2JyZWFrO2Nhc2UgNTplLnNraXAoKS5wb3MrKyxuLmF0dHI9PT0kdXRpbC5lbXB0eU9iamVjdCYmKG4uYXR0cj17fSksYT1lLnN0cmluZygpLGUucG9zKyssbi5hdHRyW2FdPSRyb290LnRlbnNvcmZsb3cuQXR0clZhbHVlLmRlY29kZShlLGUudWludDMyKCkpO2JyZWFrO2RlZmF1bHQ6ZS5za2lwVHlwZSg3Jm8pfX1yZXR1cm4gbn0sZX0oKSxhLlZlcnNpb25EZWY9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUpe2lmKHRoaXMuYmFkQ29uc3VtZXJzPVtdLGUpZm9yKHZhciB0PU9iamVjdC5rZXlzKGUpLGE9MDthPHQubGVuZ3RoOysrYSludWxsIT1lW3RbYV1dJiYodGhpc1t0W2FdXT1lW3RbYV1dKX1yZXR1cm4gZS5wcm90b3R5cGUucHJvZHVjZXI9MCxlLnByb3RvdHlwZS5taW5Db25zdW1lcj0wLGUucHJvdG90eXBlLmJhZENvbnN1bWVycz0kdXRpbC5lbXB0eUFycmF5LGUuZGVjb2RlPWZ1bmN0aW9uKGUsdCl7ZSBpbnN0YW5jZW9mICRSZWFkZXJ8fChlPSRSZWFkZXIuY3JlYXRlKGUpKTtmb3IodmFyIGE9dm9pZCAwPT09dD9lLmxlbjplLnBvcyt0LHI9bmV3ICRyb290LnRlbnNvcmZsb3cuVmVyc2lvbkRlZjtlLnBvczxhOyl7dmFyIG49ZS51aW50MzIoKTtzd2l0Y2gobj4+PjMpe2Nhc2UgMTpyLnByb2R1Y2VyPWUuaW50MzIoKTticmVhaztjYXNlIDI6ci5taW5Db25zdW1lcj1lLmludDMyKCk7YnJlYWs7Y2FzZSAzOmlmKHIuYmFkQ29uc3VtZXJzJiZyLmJhZENvbnN1bWVycy5sZW5ndGh8fChyLmJhZENvbnN1bWVycz1bXSksMj09KDcmbikpZm9yKHZhciBvPWUudWludDMyKCkrZS5wb3M7ZS5wb3M8bzspci5iYWRDb25zdW1lcnMucHVzaChlLmludDMyKCkpO2Vsc2Ugci5iYWRDb25zdW1lcnMucHVzaChlLmludDMyKCkpO2JyZWFrO2RlZmF1bHQ6ZS5za2lwVHlwZSg3Jm4pfX1yZXR1cm4gcn0sZX0oKSxhLkdyYXBoRGVmPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlKXtpZih0aGlzLm5vZGU9W10sZSlmb3IodmFyIHQ9T2JqZWN0LmtleXMoZSksYT0wO2E8dC5sZW5ndGg7KythKW51bGwhPWVbdFthXV0mJih0aGlzW3RbYV1dPWVbdFthXV0pfXJldHVybiBlLnByb3RvdHlwZS5ub2RlPSR1dGlsLmVtcHR5QXJyYXksZS5wcm90b3R5cGUudmVyc2lvbnM9bnVsbCxlLnByb3RvdHlwZS5saWJyYXJ5PW51bGwsZS5kZWNvZGU9ZnVuY3Rpb24oZSx0KXtlIGluc3RhbmNlb2YgJFJlYWRlcnx8KGU9JFJlYWRlci5jcmVhdGUoZSkpO2Zvcih2YXIgYT12b2lkIDA9PT10P2UubGVuOmUucG9zK3Qscj1uZXcgJHJvb3QudGVuc29yZmxvdy5HcmFwaERlZjtlLnBvczxhOyl7dmFyIG49ZS51aW50MzIoKTtzd2l0Y2gobj4+PjMpe2Nhc2UgMTpyLm5vZGUmJnIubm9kZS5sZW5ndGh8fChyLm5vZGU9W10pLHIubm9kZS5wdXNoKCRyb290LnRlbnNvcmZsb3cuTm9kZURlZi5kZWNvZGUoZSxlLnVpbnQzMigpKSk7YnJlYWs7Y2FzZSA0OnIudmVyc2lvbnM9JHJvb3QudGVuc29yZmxvdy5WZXJzaW9uRGVmLmRlY29kZShlLGUudWludDMyKCkpO2JyZWFrO2Nhc2UgMjpyLmxpYnJhcnk9JHJvb3QudGVuc29yZmxvdy5GdW5jdGlvbkRlZkxpYnJhcnkuZGVjb2RlKGUsZS51aW50MzIoKSk7YnJlYWs7ZGVmYXVsdDplLnNraXBUeXBlKDcmbil9fXJldHVybiByfSxlfSgpLGEuQ29sbGVjdGlvbkRlZj1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSl7aWYoZSlmb3IodmFyIHQ9T2JqZWN0LmtleXMoZSksYT0wO2E8dC5sZW5ndGg7KythKW51bGwhPWVbdFthXV0mJih0aGlzW3RbYV1dPWVbdFthXV0pfXZhciB0O3JldHVybiBlLnByb3RvdHlwZS5ub2RlTGlzdD1udWxsLGUucHJvdG90eXBlLmJ5dGVzTGlzdD1udWxsLGUucHJvdG90eXBlLmludDY0TGlzdD1udWxsLGUucHJvdG90eXBlLmZsb2F0TGlzdD1udWxsLGUucHJvdG90eXBlLmFueUxpc3Q9bnVsbCxPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5wcm90b3R5cGUsXCJraW5kXCIse2dldDokdXRpbC5vbmVPZkdldHRlcih0PVtcIm5vZGVMaXN0XCIsXCJieXRlc0xpc3RcIixcImludDY0TGlzdFwiLFwiZmxvYXRMaXN0XCIsXCJhbnlMaXN0XCJdKSxzZXQ6JHV0aWwub25lT2ZTZXR0ZXIodCl9KSxlLmRlY29kZT1mdW5jdGlvbihlLHQpe2UgaW5zdGFuY2VvZiAkUmVhZGVyfHwoZT0kUmVhZGVyLmNyZWF0ZShlKSk7Zm9yKHZhciBhPXZvaWQgMD09PXQ/ZS5sZW46ZS5wb3MrdCxyPW5ldyAkcm9vdC50ZW5zb3JmbG93LkNvbGxlY3Rpb25EZWY7ZS5wb3M8YTspe3ZhciBuPWUudWludDMyKCk7c3dpdGNoKG4+Pj4zKXtjYXNlIDE6ci5ub2RlTGlzdD0kcm9vdC50ZW5zb3JmbG93LkNvbGxlY3Rpb25EZWYuTm9kZUxpc3QuZGVjb2RlKGUsZS51aW50MzIoKSk7YnJlYWs7Y2FzZSAyOnIuYnl0ZXNMaXN0PSRyb290LnRlbnNvcmZsb3cuQ29sbGVjdGlvbkRlZi5CeXRlc0xpc3QuZGVjb2RlKGUsZS51aW50MzIoKSk7YnJlYWs7Y2FzZSAzOnIuaW50NjRMaXN0PSRyb290LnRlbnNvcmZsb3cuQ29sbGVjdGlvbkRlZi5JbnQ2NExpc3QuZGVjb2RlKGUsZS51aW50MzIoKSk7YnJlYWs7Y2FzZSA0OnIuZmxvYXRMaXN0PSRyb290LnRlbnNvcmZsb3cuQ29sbGVjdGlvbkRlZi5GbG9hdExpc3QuZGVjb2RlKGUsZS51aW50MzIoKSk7YnJlYWs7Y2FzZSA1OnIuYW55TGlzdD0kcm9vdC50ZW5zb3JmbG93LkNvbGxlY3Rpb25EZWYuQW55TGlzdC5kZWNvZGUoZSxlLnVpbnQzMigpKTticmVhaztkZWZhdWx0OmUuc2tpcFR5cGUoNyZuKX19cmV0dXJuIHJ9LGUuTm9kZUxpc3Q9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUpe2lmKHRoaXMudmFsdWU9W10sZSlmb3IodmFyIHQ9T2JqZWN0LmtleXMoZSksYT0wO2E8dC5sZW5ndGg7KythKW51bGwhPWVbdFthXV0mJih0aGlzW3RbYV1dPWVbdFthXV0pfXJldHVybiBlLnByb3RvdHlwZS52YWx1ZT0kdXRpbC5lbXB0eUFycmF5LGUuZGVjb2RlPWZ1bmN0aW9uKGUsdCl7ZSBpbnN0YW5jZW9mICRSZWFkZXJ8fChlPSRSZWFkZXIuY3JlYXRlKGUpKTtmb3IodmFyIGE9dm9pZCAwPT09dD9lLmxlbjplLnBvcyt0LHI9bmV3ICRyb290LnRlbnNvcmZsb3cuQ29sbGVjdGlvbkRlZi5Ob2RlTGlzdDtlLnBvczxhOyl7dmFyIG49ZS51aW50MzIoKTtzd2l0Y2gobj4+PjMpe2Nhc2UgMTpyLnZhbHVlJiZyLnZhbHVlLmxlbmd0aHx8KHIudmFsdWU9W10pLHIudmFsdWUucHVzaChlLnN0cmluZygpKTticmVhaztkZWZhdWx0OmUuc2tpcFR5cGUoNyZuKX19cmV0dXJuIHJ9LGV9KCksZS5CeXRlc0xpc3Q9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUpe2lmKHRoaXMudmFsdWU9W10sZSlmb3IodmFyIHQ9T2JqZWN0LmtleXMoZSksYT0wO2E8dC5sZW5ndGg7KythKW51bGwhPWVbdFthXV0mJih0aGlzW3RbYV1dPWVbdFthXV0pfXJldHVybiBlLnByb3RvdHlwZS52YWx1ZT0kdXRpbC5lbXB0eUFycmF5LGUuZGVjb2RlPWZ1bmN0aW9uKGUsdCl7ZSBpbnN0YW5jZW9mICRSZWFkZXJ8fChlPSRSZWFkZXIuY3JlYXRlKGUpKTtmb3IodmFyIGE9dm9pZCAwPT09dD9lLmxlbjplLnBvcyt0LHI9bmV3ICRyb290LnRlbnNvcmZsb3cuQ29sbGVjdGlvbkRlZi5CeXRlc0xpc3Q7ZS5wb3M8YTspe3ZhciBuPWUudWludDMyKCk7c3dpdGNoKG4+Pj4zKXtjYXNlIDE6ci52YWx1ZSYmci52YWx1ZS5sZW5ndGh8fChyLnZhbHVlPVtdKSxyLnZhbHVlLnB1c2goZS5ieXRlcygpKTticmVhaztkZWZhdWx0OmUuc2tpcFR5cGUoNyZuKX19cmV0dXJuIHJ9LGV9KCksZS5JbnQ2NExpc3Q9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUpe2lmKHRoaXMudmFsdWU9W10sZSlmb3IodmFyIHQ9T2JqZWN0LmtleXMoZSksYT0wO2E8dC5sZW5ndGg7KythKW51bGwhPWVbdFthXV0mJih0aGlzW3RbYV1dPWVbdFthXV0pfXJldHVybiBlLnByb3RvdHlwZS52YWx1ZT0kdXRpbC5lbXB0eUFycmF5LGUuZGVjb2RlPWZ1bmN0aW9uKGUsdCl7ZSBpbnN0YW5jZW9mICRSZWFkZXJ8fChlPSRSZWFkZXIuY3JlYXRlKGUpKTtmb3IodmFyIGE9dm9pZCAwPT09dD9lLmxlbjplLnBvcyt0LHI9bmV3ICRyb290LnRlbnNvcmZsb3cuQ29sbGVjdGlvbkRlZi5JbnQ2NExpc3Q7ZS5wb3M8YTspe3ZhciBuPWUudWludDMyKCk7c3dpdGNoKG4+Pj4zKXtjYXNlIDE6aWYoci52YWx1ZSYmci52YWx1ZS5sZW5ndGh8fChyLnZhbHVlPVtdKSwyPT0oNyZuKSlmb3IodmFyIG89ZS51aW50MzIoKStlLnBvcztlLnBvczxvOylyLnZhbHVlLnB1c2goZS5pbnQ2NCgpKTtlbHNlIHIudmFsdWUucHVzaChlLmludDY0KCkpO2JyZWFrO2RlZmF1bHQ6ZS5za2lwVHlwZSg3Jm4pfX1yZXR1cm4gcn0sZX0oKSxlLkZsb2F0TGlzdD1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSl7aWYodGhpcy52YWx1ZT1bXSxlKWZvcih2YXIgdD1PYmplY3Qua2V5cyhlKSxhPTA7YTx0Lmxlbmd0aDsrK2EpbnVsbCE9ZVt0W2FdXSYmKHRoaXNbdFthXV09ZVt0W2FdXSl9cmV0dXJuIGUucHJvdG90eXBlLnZhbHVlPSR1dGlsLmVtcHR5QXJyYXksZS5kZWNvZGU9ZnVuY3Rpb24oZSx0KXtlIGluc3RhbmNlb2YgJFJlYWRlcnx8KGU9JFJlYWRlci5jcmVhdGUoZSkpO2Zvcih2YXIgYT12b2lkIDA9PT10P2UubGVuOmUucG9zK3Qscj1uZXcgJHJvb3QudGVuc29yZmxvdy5Db2xsZWN0aW9uRGVmLkZsb2F0TGlzdDtlLnBvczxhOyl7dmFyIG49ZS51aW50MzIoKTtzd2l0Y2gobj4+PjMpe2Nhc2UgMTppZihyLnZhbHVlJiZyLnZhbHVlLmxlbmd0aHx8KHIudmFsdWU9W10pLDI9PSg3Jm4pKWZvcih2YXIgbz1lLnVpbnQzMigpK2UucG9zO2UucG9zPG87KXIudmFsdWUucHVzaChlLmZsb2F0KCkpO2Vsc2Ugci52YWx1ZS5wdXNoKGUuZmxvYXQoKSk7YnJlYWs7ZGVmYXVsdDplLnNraXBUeXBlKDcmbil9fXJldHVybiByfSxlfSgpLGUuQW55TGlzdD1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSl7aWYodGhpcy52YWx1ZT1bXSxlKWZvcih2YXIgdD1PYmplY3Qua2V5cyhlKSxhPTA7YTx0Lmxlbmd0aDsrK2EpbnVsbCE9ZVt0W2FdXSYmKHRoaXNbdFthXV09ZVt0W2FdXSl9cmV0dXJuIGUucHJvdG90eXBlLnZhbHVlPSR1dGlsLmVtcHR5QXJyYXksZS5kZWNvZGU9ZnVuY3Rpb24oZSx0KXtlIGluc3RhbmNlb2YgJFJlYWRlcnx8KGU9JFJlYWRlci5jcmVhdGUoZSkpO2Zvcih2YXIgYT12b2lkIDA9PT10P2UubGVuOmUucG9zK3Qscj1uZXcgJHJvb3QudGVuc29yZmxvdy5Db2xsZWN0aW9uRGVmLkFueUxpc3Q7ZS5wb3M8YTspe3ZhciBuPWUudWludDMyKCk7c3dpdGNoKG4+Pj4zKXtjYXNlIDE6ci52YWx1ZSYmci52YWx1ZS5sZW5ndGh8fChyLnZhbHVlPVtdKSxyLnZhbHVlLnB1c2goJHJvb3QudGVuc29yZmxvdy5BbnkuZGVjb2RlKGUsZS51aW50MzIoKSkpO2JyZWFrO2RlZmF1bHQ6ZS5za2lwVHlwZSg3Jm4pfX1yZXR1cm4gcn0sZX0oKSxlfSgpLGEuU2F2ZXJEZWY9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUpe2lmKGUpZm9yKHZhciB0PU9iamVjdC5rZXlzKGUpLGE9MDthPHQubGVuZ3RoOysrYSludWxsIT1lW3RbYV1dJiYodGhpc1t0W2FdXT1lW3RbYV1dKX12YXIgdCxhO3JldHVybiBlLnByb3RvdHlwZS5maWxlbmFtZVRlbnNvck5hbWU9XCJcIixlLnByb3RvdHlwZS5zYXZlVGVuc29yTmFtZT1cIlwiLGUucHJvdG90eXBlLnJlc3RvcmVPcE5hbWU9XCJcIixlLnByb3RvdHlwZS5tYXhUb0tlZXA9MCxlLnByb3RvdHlwZS5zaGFyZGVkPSExLGUucHJvdG90eXBlLmtlZXBDaGVja3BvaW50RXZlcnlOSG91cnM9MCxlLnByb3RvdHlwZS52ZXJzaW9uPTAsZS5kZWNvZGU9ZnVuY3Rpb24oZSx0KXtlIGluc3RhbmNlb2YgJFJlYWRlcnx8KGU9JFJlYWRlci5jcmVhdGUoZSkpO2Zvcih2YXIgYT12b2lkIDA9PT10P2UubGVuOmUucG9zK3Qscj1uZXcgJHJvb3QudGVuc29yZmxvdy5TYXZlckRlZjtlLnBvczxhOyl7dmFyIG49ZS51aW50MzIoKTtzd2l0Y2gobj4+PjMpe2Nhc2UgMTpyLmZpbGVuYW1lVGVuc29yTmFtZT1lLnN0cmluZygpO2JyZWFrO2Nhc2UgMjpyLnNhdmVUZW5zb3JOYW1lPWUuc3RyaW5nKCk7YnJlYWs7Y2FzZSAzOnIucmVzdG9yZU9wTmFtZT1lLnN0cmluZygpO2JyZWFrO2Nhc2UgNDpyLm1heFRvS2VlcD1lLmludDMyKCk7YnJlYWs7Y2FzZSA1OnIuc2hhcmRlZD1lLmJvb2woKTticmVhaztjYXNlIDY6ci5rZWVwQ2hlY2twb2ludEV2ZXJ5TkhvdXJzPWUuZmxvYXQoKTticmVhaztjYXNlIDc6ci52ZXJzaW9uPWUuaW50MzIoKTticmVhaztkZWZhdWx0OmUuc2tpcFR5cGUoNyZuKX19cmV0dXJuIHJ9LGUuQ2hlY2twb2ludEZvcm1hdFZlcnNpb249KHQ9e30sKGE9T2JqZWN0LmNyZWF0ZSh0KSlbdFswXT1cIkxFR0FDWVwiXT0wLGFbdFsxXT1cIlYxXCJdPTEsYVt0WzJdPVwiVjJcIl09MixhKSxlfSgpLGEuVGVuc29ySW5mbz1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSl7aWYoZSlmb3IodmFyIHQ9T2JqZWN0LmtleXMoZSksYT0wO2E8dC5sZW5ndGg7KythKW51bGwhPWVbdFthXV0mJih0aGlzW3RbYV1dPWVbdFthXV0pfXZhciB0O3JldHVybiBlLnByb3RvdHlwZS5uYW1lPVwiXCIsZS5wcm90b3R5cGUuY29vU3BhcnNlPW51bGwsZS5wcm90b3R5cGUuZHR5cGU9MCxlLnByb3RvdHlwZS50ZW5zb3JTaGFwZT1udWxsLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcImVuY29kaW5nXCIse2dldDokdXRpbC5vbmVPZkdldHRlcih0PVtcIm5hbWVcIixcImNvb1NwYXJzZVwiXSksc2V0OiR1dGlsLm9uZU9mU2V0dGVyKHQpfSksZS5kZWNvZGU9ZnVuY3Rpb24oZSx0KXtlIGluc3RhbmNlb2YgJFJlYWRlcnx8KGU9JFJlYWRlci5jcmVhdGUoZSkpO2Zvcih2YXIgYT12b2lkIDA9PT10P2UubGVuOmUucG9zK3Qscj1uZXcgJHJvb3QudGVuc29yZmxvdy5UZW5zb3JJbmZvO2UucG9zPGE7KXt2YXIgbj1lLnVpbnQzMigpO3N3aXRjaChuPj4+Myl7Y2FzZSAxOnIubmFtZT1lLnN0cmluZygpO2JyZWFrO2Nhc2UgNDpyLmNvb1NwYXJzZT0kcm9vdC50ZW5zb3JmbG93LlRlbnNvckluZm8uQ29vU3BhcnNlLmRlY29kZShlLGUudWludDMyKCkpO2JyZWFrO2Nhc2UgMjpyLmR0eXBlPWUuaW50MzIoKTticmVhaztjYXNlIDM6ci50ZW5zb3JTaGFwZT0kcm9vdC50ZW5zb3JmbG93LlRlbnNvclNoYXBlLmRlY29kZShlLGUudWludDMyKCkpO2JyZWFrO2RlZmF1bHQ6ZS5za2lwVHlwZSg3Jm4pfX1yZXR1cm4gcn0sZS5Db29TcGFyc2U9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUpe2lmKGUpZm9yKHZhciB0PU9iamVjdC5rZXlzKGUpLGE9MDthPHQubGVuZ3RoOysrYSludWxsIT1lW3RbYV1dJiYodGhpc1t0W2FdXT1lW3RbYV1dKX1yZXR1cm4gZS5wcm90b3R5cGUudmFsdWVzVGVuc29yTmFtZT1cIlwiLGUucHJvdG90eXBlLmluZGljZXNUZW5zb3JOYW1lPVwiXCIsZS5wcm90b3R5cGUuZGVuc2VTaGFwZVRlbnNvck5hbWU9XCJcIixlLmRlY29kZT1mdW5jdGlvbihlLHQpe2UgaW5zdGFuY2VvZiAkUmVhZGVyfHwoZT0kUmVhZGVyLmNyZWF0ZShlKSk7Zm9yKHZhciBhPXZvaWQgMD09PXQ/ZS5sZW46ZS5wb3MrdCxyPW5ldyAkcm9vdC50ZW5zb3JmbG93LlRlbnNvckluZm8uQ29vU3BhcnNlO2UucG9zPGE7KXt2YXIgbj1lLnVpbnQzMigpO3N3aXRjaChuPj4+Myl7Y2FzZSAxOnIudmFsdWVzVGVuc29yTmFtZT1lLnN0cmluZygpO2JyZWFrO2Nhc2UgMjpyLmluZGljZXNUZW5zb3JOYW1lPWUuc3RyaW5nKCk7YnJlYWs7Y2FzZSAzOnIuZGVuc2VTaGFwZVRlbnNvck5hbWU9ZS5zdHJpbmcoKTticmVhaztkZWZhdWx0OmUuc2tpcFR5cGUoNyZuKX19cmV0dXJuIHJ9LGV9KCksZX0oKSxhLlNpZ25hdHVyZURlZj1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSl7aWYodGhpcy5pbnB1dHM9e30sdGhpcy5vdXRwdXRzPXt9LGUpZm9yKHZhciB0PU9iamVjdC5rZXlzKGUpLGE9MDthPHQubGVuZ3RoOysrYSludWxsIT1lW3RbYV1dJiYodGhpc1t0W2FdXT1lW3RbYV1dKX1yZXR1cm4gZS5wcm90b3R5cGUuaW5wdXRzPSR1dGlsLmVtcHR5T2JqZWN0LGUucHJvdG90eXBlLm91dHB1dHM9JHV0aWwuZW1wdHlPYmplY3QsZS5wcm90b3R5cGUubWV0aG9kTmFtZT1cIlwiLGUuZGVjb2RlPWZ1bmN0aW9uKGUsdCl7ZSBpbnN0YW5jZW9mICRSZWFkZXJ8fChlPSRSZWFkZXIuY3JlYXRlKGUpKTtmb3IodmFyIGEscj12b2lkIDA9PT10P2UubGVuOmUucG9zK3Qsbj1uZXcgJHJvb3QudGVuc29yZmxvdy5TaWduYXR1cmVEZWY7ZS5wb3M8cjspe3ZhciBvPWUudWludDMyKCk7c3dpdGNoKG8+Pj4zKXtjYXNlIDE6ZS5za2lwKCkucG9zKyssbi5pbnB1dHM9PT0kdXRpbC5lbXB0eU9iamVjdCYmKG4uaW5wdXRzPXt9KSxhPWUuc3RyaW5nKCksZS5wb3MrKyxuLmlucHV0c1thXT0kcm9vdC50ZW5zb3JmbG93LlRlbnNvckluZm8uZGVjb2RlKGUsZS51aW50MzIoKSk7YnJlYWs7Y2FzZSAyOmUuc2tpcCgpLnBvcysrLG4ub3V0cHV0cz09PSR1dGlsLmVtcHR5T2JqZWN0JiYobi5vdXRwdXRzPXt9KSxhPWUuc3RyaW5nKCksZS5wb3MrKyxuLm91dHB1dHNbYV09JHJvb3QudGVuc29yZmxvdy5UZW5zb3JJbmZvLmRlY29kZShlLGUudWludDMyKCkpO2JyZWFrO2Nhc2UgMzpuLm1ldGhvZE5hbWU9ZS5zdHJpbmcoKTticmVhaztkZWZhdWx0OmUuc2tpcFR5cGUoNyZvKX19cmV0dXJuIG59LGV9KCksYS5Bc3NldEZpbGVEZWY9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUpe2lmKGUpZm9yKHZhciB0PU9iamVjdC5rZXlzKGUpLGE9MDthPHQubGVuZ3RoOysrYSludWxsIT1lW3RbYV1dJiYodGhpc1t0W2FdXT1lW3RbYV1dKX1yZXR1cm4gZS5wcm90b3R5cGUudGVuc29ySW5mbz1udWxsLGUucHJvdG90eXBlLmZpbGVuYW1lPVwiXCIsZS5kZWNvZGU9ZnVuY3Rpb24oZSx0KXtlIGluc3RhbmNlb2YgJFJlYWRlcnx8KGU9JFJlYWRlci5jcmVhdGUoZSkpO2Zvcih2YXIgYT12b2lkIDA9PT10P2UubGVuOmUucG9zK3Qscj1uZXcgJHJvb3QudGVuc29yZmxvdy5Bc3NldEZpbGVEZWY7ZS5wb3M8YTspe3ZhciBuPWUudWludDMyKCk7c3dpdGNoKG4+Pj4zKXtjYXNlIDE6ci50ZW5zb3JJbmZvPSRyb290LnRlbnNvcmZsb3cuVGVuc29ySW5mby5kZWNvZGUoZSxlLnVpbnQzMigpKTticmVhaztjYXNlIDI6ci5maWxlbmFtZT1lLnN0cmluZygpO2JyZWFrO2RlZmF1bHQ6ZS5za2lwVHlwZSg3Jm4pfX1yZXR1cm4gcn0sZX0oKSxhLk9wRGVmPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlKXtpZih0aGlzLmlucHV0QXJnPVtdLHRoaXMub3V0cHV0QXJnPVtdLHRoaXMuYXR0cj1bXSxlKWZvcih2YXIgdD1PYmplY3Qua2V5cyhlKSxhPTA7YTx0Lmxlbmd0aDsrK2EpbnVsbCE9ZVt0W2FdXSYmKHRoaXNbdFthXV09ZVt0W2FdXSl9cmV0dXJuIGUucHJvdG90eXBlLm5hbWU9XCJcIixlLnByb3RvdHlwZS5pbnB1dEFyZz0kdXRpbC5lbXB0eUFycmF5LGUucHJvdG90eXBlLm91dHB1dEFyZz0kdXRpbC5lbXB0eUFycmF5LGUucHJvdG90eXBlLmF0dHI9JHV0aWwuZW1wdHlBcnJheSxlLnByb3RvdHlwZS5kZXByZWNhdGlvbj1udWxsLGUucHJvdG90eXBlLnN1bW1hcnk9XCJcIixlLnByb3RvdHlwZS5kZXNjcmlwdGlvbj1cIlwiLGUucHJvdG90eXBlLmlzQ29tbXV0YXRpdmU9ITEsZS5wcm90b3R5cGUuaXNBZ2dyZWdhdGU9ITEsZS5wcm90b3R5cGUuaXNTdGF0ZWZ1bD0hMSxlLnByb3RvdHlwZS5hbGxvd3NVbmluaXRpYWxpemVkSW5wdXQ9ITEsZS5kZWNvZGU9ZnVuY3Rpb24oZSx0KXtlIGluc3RhbmNlb2YgJFJlYWRlcnx8KGU9JFJlYWRlci5jcmVhdGUoZSkpO2Zvcih2YXIgYT12b2lkIDA9PT10P2UubGVuOmUucG9zK3Qscj1uZXcgJHJvb3QudGVuc29yZmxvdy5PcERlZjtlLnBvczxhOyl7dmFyIG49ZS51aW50MzIoKTtzd2l0Y2gobj4+PjMpe2Nhc2UgMTpyLm5hbWU9ZS5zdHJpbmcoKTticmVhaztjYXNlIDI6ci5pbnB1dEFyZyYmci5pbnB1dEFyZy5sZW5ndGh8fChyLmlucHV0QXJnPVtdKSxyLmlucHV0QXJnLnB1c2goJHJvb3QudGVuc29yZmxvdy5PcERlZi5BcmdEZWYuZGVjb2RlKGUsZS51aW50MzIoKSkpO2JyZWFrO2Nhc2UgMzpyLm91dHB1dEFyZyYmci5vdXRwdXRBcmcubGVuZ3RofHwoci5vdXRwdXRBcmc9W10pLHIub3V0cHV0QXJnLnB1c2goJHJvb3QudGVuc29yZmxvdy5PcERlZi5BcmdEZWYuZGVjb2RlKGUsZS51aW50MzIoKSkpO2JyZWFrO2Nhc2UgNDpyLmF0dHImJnIuYXR0ci5sZW5ndGh8fChyLmF0dHI9W10pLHIuYXR0ci5wdXNoKCRyb290LnRlbnNvcmZsb3cuT3BEZWYuQXR0ckRlZi5kZWNvZGUoZSxlLnVpbnQzMigpKSk7YnJlYWs7Y2FzZSA4OnIuZGVwcmVjYXRpb249JHJvb3QudGVuc29yZmxvdy5PcERlZi5PcERlcHJlY2F0aW9uLmRlY29kZShlLGUudWludDMyKCkpO2JyZWFrO2Nhc2UgNTpyLnN1bW1hcnk9ZS5zdHJpbmcoKTticmVhaztjYXNlIDY6ci5kZXNjcmlwdGlvbj1lLnN0cmluZygpO2JyZWFrO2Nhc2UgMTg6ci5pc0NvbW11dGF0aXZlPWUuYm9vbCgpO2JyZWFrO2Nhc2UgMTY6ci5pc0FnZ3JlZ2F0ZT1lLmJvb2woKTticmVhaztjYXNlIDE3OnIuaXNTdGF0ZWZ1bD1lLmJvb2woKTticmVhaztjYXNlIDE5OnIuYWxsb3dzVW5pbml0aWFsaXplZElucHV0PWUuYm9vbCgpO2JyZWFrO2RlZmF1bHQ6ZS5za2lwVHlwZSg3Jm4pfX1yZXR1cm4gcn0sZS5BcmdEZWY9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUpe2lmKGUpZm9yKHZhciB0PU9iamVjdC5rZXlzKGUpLGE9MDthPHQubGVuZ3RoOysrYSludWxsIT1lW3RbYV1dJiYodGhpc1t0W2FdXT1lW3RbYV1dKX1yZXR1cm4gZS5wcm90b3R5cGUubmFtZT1cIlwiLGUucHJvdG90eXBlLmRlc2NyaXB0aW9uPVwiXCIsZS5wcm90b3R5cGUudHlwZT0wLGUucHJvdG90eXBlLnR5cGVBdHRyPVwiXCIsZS5wcm90b3R5cGUubnVtYmVyQXR0cj1cIlwiLGUucHJvdG90eXBlLnR5cGVMaXN0QXR0cj1cIlwiLGUucHJvdG90eXBlLmlzUmVmPSExLGUuZGVjb2RlPWZ1bmN0aW9uKGUsdCl7ZSBpbnN0YW5jZW9mICRSZWFkZXJ8fChlPSRSZWFkZXIuY3JlYXRlKGUpKTtmb3IodmFyIGE9dm9pZCAwPT09dD9lLmxlbjplLnBvcyt0LHI9bmV3ICRyb290LnRlbnNvcmZsb3cuT3BEZWYuQXJnRGVmO2UucG9zPGE7KXt2YXIgbj1lLnVpbnQzMigpO3N3aXRjaChuPj4+Myl7Y2FzZSAxOnIubmFtZT1lLnN0cmluZygpO2JyZWFrO2Nhc2UgMjpyLmRlc2NyaXB0aW9uPWUuc3RyaW5nKCk7YnJlYWs7Y2FzZSAzOnIudHlwZT1lLmludDMyKCk7YnJlYWs7Y2FzZSA0OnIudHlwZUF0dHI9ZS5zdHJpbmcoKTticmVhaztjYXNlIDU6ci5udW1iZXJBdHRyPWUuc3RyaW5nKCk7YnJlYWs7Y2FzZSA2OnIudHlwZUxpc3RBdHRyPWUuc3RyaW5nKCk7YnJlYWs7Y2FzZSAxNjpyLmlzUmVmPWUuYm9vbCgpO2JyZWFrO2RlZmF1bHQ6ZS5za2lwVHlwZSg3Jm4pfX1yZXR1cm4gcn0sZX0oKSxlLkF0dHJEZWY9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUpe2lmKGUpZm9yKHZhciB0PU9iamVjdC5rZXlzKGUpLGE9MDthPHQubGVuZ3RoOysrYSludWxsIT1lW3RbYV1dJiYodGhpc1t0W2FdXT1lW3RbYV1dKX1yZXR1cm4gZS5wcm90b3R5cGUubmFtZT1cIlwiLGUucHJvdG90eXBlLnR5cGU9XCJcIixlLnByb3RvdHlwZS5kZWZhdWx0VmFsdWU9bnVsbCxlLnByb3RvdHlwZS5kZXNjcmlwdGlvbj1cIlwiLGUucHJvdG90eXBlLmhhc01pbmltdW09ITEsZS5wcm90b3R5cGUubWluaW11bT0kdXRpbC5Mb25nPyR1dGlsLkxvbmcuZnJvbUJpdHMoMCwwLCExKTowLGUucHJvdG90eXBlLmFsbG93ZWRWYWx1ZXM9bnVsbCxlLmRlY29kZT1mdW5jdGlvbihlLHQpe2UgaW5zdGFuY2VvZiAkUmVhZGVyfHwoZT0kUmVhZGVyLmNyZWF0ZShlKSk7Zm9yKHZhciBhPXZvaWQgMD09PXQ/ZS5sZW46ZS5wb3MrdCxyPW5ldyAkcm9vdC50ZW5zb3JmbG93Lk9wRGVmLkF0dHJEZWY7ZS5wb3M8YTspe3ZhciBuPWUudWludDMyKCk7c3dpdGNoKG4+Pj4zKXtjYXNlIDE6ci5uYW1lPWUuc3RyaW5nKCk7YnJlYWs7Y2FzZSAyOnIudHlwZT1lLnN0cmluZygpO2JyZWFrO2Nhc2UgMzpyLmRlZmF1bHRWYWx1ZT0kcm9vdC50ZW5zb3JmbG93LkF0dHJWYWx1ZS5kZWNvZGUoZSxlLnVpbnQzMigpKTticmVhaztjYXNlIDQ6ci5kZXNjcmlwdGlvbj1lLnN0cmluZygpO2JyZWFrO2Nhc2UgNTpyLmhhc01pbmltdW09ZS5ib29sKCk7YnJlYWs7Y2FzZSA2OnIubWluaW11bT1lLmludDY0KCk7YnJlYWs7Y2FzZSA3OnIuYWxsb3dlZFZhbHVlcz0kcm9vdC50ZW5zb3JmbG93LkF0dHJWYWx1ZS5kZWNvZGUoZSxlLnVpbnQzMigpKTticmVhaztkZWZhdWx0OmUuc2tpcFR5cGUoNyZuKX19cmV0dXJuIHJ9LGV9KCksZS5PcERlcHJlY2F0aW9uPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlKXtpZihlKWZvcih2YXIgdD1PYmplY3Qua2V5cyhlKSxhPTA7YTx0Lmxlbmd0aDsrK2EpbnVsbCE9ZVt0W2FdXSYmKHRoaXNbdFthXV09ZVt0W2FdXSl9cmV0dXJuIGUucHJvdG90eXBlLnZlcnNpb249MCxlLnByb3RvdHlwZS5leHBsYW5hdGlvbj1cIlwiLGUuZGVjb2RlPWZ1bmN0aW9uKGUsdCl7ZSBpbnN0YW5jZW9mICRSZWFkZXJ8fChlPSRSZWFkZXIuY3JlYXRlKGUpKTtmb3IodmFyIGE9dm9pZCAwPT09dD9lLmxlbjplLnBvcyt0LHI9bmV3ICRyb290LnRlbnNvcmZsb3cuT3BEZWYuT3BEZXByZWNhdGlvbjtlLnBvczxhOyl7dmFyIG49ZS51aW50MzIoKTtzd2l0Y2gobj4+PjMpe2Nhc2UgMTpyLnZlcnNpb249ZS5pbnQzMigpO2JyZWFrO2Nhc2UgMjpyLmV4cGxhbmF0aW9uPWUuc3RyaW5nKCk7YnJlYWs7ZGVmYXVsdDplLnNraXBUeXBlKDcmbil9fXJldHVybiByfSxlfSgpLGV9KCksYS5PcExpc3Q9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUpe2lmKHRoaXMub3A9W10sZSlmb3IodmFyIHQ9T2JqZWN0LmtleXMoZSksYT0wO2E8dC5sZW5ndGg7KythKW51bGwhPWVbdFthXV0mJih0aGlzW3RbYV1dPWVbdFthXV0pfXJldHVybiBlLnByb3RvdHlwZS5vcD0kdXRpbC5lbXB0eUFycmF5LGUuZGVjb2RlPWZ1bmN0aW9uKGUsdCl7ZSBpbnN0YW5jZW9mICRSZWFkZXJ8fChlPSRSZWFkZXIuY3JlYXRlKGUpKTtmb3IodmFyIGE9dm9pZCAwPT09dD9lLmxlbjplLnBvcyt0LHI9bmV3ICRyb290LnRlbnNvcmZsb3cuT3BMaXN0O2UucG9zPGE7KXt2YXIgbj1lLnVpbnQzMigpO3N3aXRjaChuPj4+Myl7Y2FzZSAxOnIub3AmJnIub3AubGVuZ3RofHwoci5vcD1bXSksci5vcC5wdXNoKCRyb290LnRlbnNvcmZsb3cuT3BEZWYuZGVjb2RlKGUsZS51aW50MzIoKSkpO2JyZWFrO2RlZmF1bHQ6ZS5za2lwVHlwZSg3Jm4pfX1yZXR1cm4gcn0sZX0oKSxhLk1ldGFHcmFwaERlZj1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSl7aWYodGhpcy5jb2xsZWN0aW9uRGVmPXt9LHRoaXMuc2lnbmF0dXJlRGVmPXt9LHRoaXMuYXNzZXRGaWxlRGVmPVtdLGUpZm9yKHZhciB0PU9iamVjdC5rZXlzKGUpLGE9MDthPHQubGVuZ3RoOysrYSludWxsIT1lW3RbYV1dJiYodGhpc1t0W2FdXT1lW3RbYV1dKX1yZXR1cm4gZS5wcm90b3R5cGUubWV0YUluZm9EZWY9bnVsbCxlLnByb3RvdHlwZS5ncmFwaERlZj1udWxsLGUucHJvdG90eXBlLnNhdmVyRGVmPW51bGwsZS5wcm90b3R5cGUuY29sbGVjdGlvbkRlZj0kdXRpbC5lbXB0eU9iamVjdCxlLnByb3RvdHlwZS5zaWduYXR1cmVEZWY9JHV0aWwuZW1wdHlPYmplY3QsZS5wcm90b3R5cGUuYXNzZXRGaWxlRGVmPSR1dGlsLmVtcHR5QXJyYXksZS5kZWNvZGU9ZnVuY3Rpb24oZSx0KXtlIGluc3RhbmNlb2YgJFJlYWRlcnx8KGU9JFJlYWRlci5jcmVhdGUoZSkpO2Zvcih2YXIgYSxyPXZvaWQgMD09PXQ/ZS5sZW46ZS5wb3MrdCxuPW5ldyAkcm9vdC50ZW5zb3JmbG93Lk1ldGFHcmFwaERlZjtlLnBvczxyOyl7dmFyIG89ZS51aW50MzIoKTtzd2l0Y2gobz4+PjMpe2Nhc2UgMTpuLm1ldGFJbmZvRGVmPSRyb290LnRlbnNvcmZsb3cuTWV0YUdyYXBoRGVmLk1ldGFJbmZvRGVmLmRlY29kZShlLGUudWludDMyKCkpO2JyZWFrO2Nhc2UgMjpuLmdyYXBoRGVmPSRyb290LnRlbnNvcmZsb3cuR3JhcGhEZWYuZGVjb2RlKGUsZS51aW50MzIoKSk7YnJlYWs7Y2FzZSAzOm4uc2F2ZXJEZWY9JHJvb3QudGVuc29yZmxvdy5TYXZlckRlZi5kZWNvZGUoZSxlLnVpbnQzMigpKTticmVhaztjYXNlIDQ6ZS5za2lwKCkucG9zKyssbi5jb2xsZWN0aW9uRGVmPT09JHV0aWwuZW1wdHlPYmplY3QmJihuLmNvbGxlY3Rpb25EZWY9e30pLGE9ZS5zdHJpbmcoKSxlLnBvcysrLG4uY29sbGVjdGlvbkRlZlthXT0kcm9vdC50ZW5zb3JmbG93LkNvbGxlY3Rpb25EZWYuZGVjb2RlKGUsZS51aW50MzIoKSk7YnJlYWs7Y2FzZSA1OmUuc2tpcCgpLnBvcysrLG4uc2lnbmF0dXJlRGVmPT09JHV0aWwuZW1wdHlPYmplY3QmJihuLnNpZ25hdHVyZURlZj17fSksYT1lLnN0cmluZygpLGUucG9zKyssbi5zaWduYXR1cmVEZWZbYV09JHJvb3QudGVuc29yZmxvdy5TaWduYXR1cmVEZWYuZGVjb2RlKGUsZS51aW50MzIoKSk7YnJlYWs7Y2FzZSA2Om4uYXNzZXRGaWxlRGVmJiZuLmFzc2V0RmlsZURlZi5sZW5ndGh8fChuLmFzc2V0RmlsZURlZj1bXSksbi5hc3NldEZpbGVEZWYucHVzaCgkcm9vdC50ZW5zb3JmbG93LkFzc2V0RmlsZURlZi5kZWNvZGUoZSxlLnVpbnQzMigpKSk7YnJlYWs7ZGVmYXVsdDplLnNraXBUeXBlKDcmbyl9fXJldHVybiBufSxlLk1ldGFJbmZvRGVmPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlKXtpZih0aGlzLnRhZ3M9W10sZSlmb3IodmFyIHQ9T2JqZWN0LmtleXMoZSksYT0wO2E8dC5sZW5ndGg7KythKW51bGwhPWVbdFthXV0mJih0aGlzW3RbYV1dPWVbdFthXV0pfXJldHVybiBlLnByb3RvdHlwZS5tZXRhR3JhcGhWZXJzaW9uPVwiXCIsZS5wcm90b3R5cGUuc3RyaXBwZWRPcExpc3Q9bnVsbCxlLnByb3RvdHlwZS5hbnlJbmZvPW51bGwsZS5wcm90b3R5cGUudGFncz0kdXRpbC5lbXB0eUFycmF5LGUucHJvdG90eXBlLnRlbnNvcmZsb3dWZXJzaW9uPVwiXCIsZS5wcm90b3R5cGUudGVuc29yZmxvd0dpdFZlcnNpb249XCJcIixlLmRlY29kZT1mdW5jdGlvbihlLHQpe2UgaW5zdGFuY2VvZiAkUmVhZGVyfHwoZT0kUmVhZGVyLmNyZWF0ZShlKSk7Zm9yKHZhciBhPXZvaWQgMD09PXQ/ZS5sZW46ZS5wb3MrdCxyPW5ldyAkcm9vdC50ZW5zb3JmbG93Lk1ldGFHcmFwaERlZi5NZXRhSW5mb0RlZjtlLnBvczxhOyl7dmFyIG49ZS51aW50MzIoKTtzd2l0Y2gobj4+PjMpe2Nhc2UgMTpyLm1ldGFHcmFwaFZlcnNpb249ZS5zdHJpbmcoKTticmVhaztjYXNlIDI6ci5zdHJpcHBlZE9wTGlzdD0kcm9vdC50ZW5zb3JmbG93Lk9wTGlzdC5kZWNvZGUoZSxlLnVpbnQzMigpKTticmVhaztjYXNlIDM6ci5hbnlJbmZvPSRyb290LnRlbnNvcmZsb3cuQW55LmRlY29kZShlLGUudWludDMyKCkpO2JyZWFrO2Nhc2UgNDpyLnRhZ3MmJnIudGFncy5sZW5ndGh8fChyLnRhZ3M9W10pLHIudGFncy5wdXNoKGUuc3RyaW5nKCkpO2JyZWFrO2Nhc2UgNTpyLnRlbnNvcmZsb3dWZXJzaW9uPWUuc3RyaW5nKCk7YnJlYWs7Y2FzZSA2OnIudGVuc29yZmxvd0dpdFZlcnNpb249ZS5zdHJpbmcoKTticmVhaztkZWZhdWx0OmUuc2tpcFR5cGUoNyZuKX19cmV0dXJuIHJ9LGV9KCksZX0oKSxhLlNhdmVkTW9kZWw9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUpe2lmKHRoaXMubWV0YUdyYXBocz1bXSxlKWZvcih2YXIgdD1PYmplY3Qua2V5cyhlKSxhPTA7YTx0Lmxlbmd0aDsrK2EpbnVsbCE9ZVt0W2FdXSYmKHRoaXNbdFthXV09ZVt0W2FdXSl9cmV0dXJuIGUucHJvdG90eXBlLnNhdmVkTW9kZWxTY2hlbWFWZXJzaW9uPSR1dGlsLkxvbmc/JHV0aWwuTG9uZy5mcm9tQml0cygwLDAsITEpOjAsZS5wcm90b3R5cGUubWV0YUdyYXBocz0kdXRpbC5lbXB0eUFycmF5LGUuZGVjb2RlPWZ1bmN0aW9uKGUsdCl7ZSBpbnN0YW5jZW9mICRSZWFkZXJ8fChlPSRSZWFkZXIuY3JlYXRlKGUpKTtmb3IodmFyIGE9dm9pZCAwPT09dD9lLmxlbjplLnBvcyt0LHI9bmV3ICRyb290LnRlbnNvcmZsb3cuU2F2ZWRNb2RlbDtlLnBvczxhOyl7dmFyIG49ZS51aW50MzIoKTtzd2l0Y2gobj4+PjMpe2Nhc2UgMTpyLnNhdmVkTW9kZWxTY2hlbWFWZXJzaW9uPWUuaW50NjQoKTticmVhaztjYXNlIDI6ci5tZXRhR3JhcGhzJiZyLm1ldGFHcmFwaHMubGVuZ3RofHwoci5tZXRhR3JhcGhzPVtdKSxyLm1ldGFHcmFwaHMucHVzaCgkcm9vdC50ZW5zb3JmbG93Lk1ldGFHcmFwaERlZi5kZWNvZGUoZSxlLnVpbnQzMigpKSk7YnJlYWs7ZGVmYXVsdDplLnNraXBUeXBlKDcmbil9fXJldHVybiByfSxlfSgpLGEuRnVuY3Rpb25EZWZMaWJyYXJ5PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlKXtpZih0aGlzLmZ1bmN0aW9uPVtdLHRoaXMuZ3JhZGllbnQ9W10sZSlmb3IodmFyIHQ9T2JqZWN0LmtleXMoZSksYT0wO2E8dC5sZW5ndGg7KythKW51bGwhPWVbdFthXV0mJih0aGlzW3RbYV1dPWVbdFthXV0pfXJldHVybiBlLnByb3RvdHlwZS5mdW5jdGlvbj0kdXRpbC5lbXB0eUFycmF5LGUucHJvdG90eXBlLmdyYWRpZW50PSR1dGlsLmVtcHR5QXJyYXksZS5kZWNvZGU9ZnVuY3Rpb24oZSx0KXtlIGluc3RhbmNlb2YgJFJlYWRlcnx8KGU9JFJlYWRlci5jcmVhdGUoZSkpO2Zvcih2YXIgYT12b2lkIDA9PT10P2UubGVuOmUucG9zK3Qscj1uZXcgJHJvb3QudGVuc29yZmxvdy5GdW5jdGlvbkRlZkxpYnJhcnk7ZS5wb3M8YTspe3ZhciBuPWUudWludDMyKCk7c3dpdGNoKG4+Pj4zKXtjYXNlIDE6ci5mdW5jdGlvbiYmci5mdW5jdGlvbi5sZW5ndGh8fChyLmZ1bmN0aW9uPVtdKSxyLmZ1bmN0aW9uLnB1c2goJHJvb3QudGVuc29yZmxvdy5GdW5jdGlvbkRlZi5kZWNvZGUoZSxlLnVpbnQzMigpKSk7YnJlYWs7Y2FzZSAyOnIuZ3JhZGllbnQmJnIuZ3JhZGllbnQubGVuZ3RofHwoci5ncmFkaWVudD1bXSksci5ncmFkaWVudC5wdXNoKCRyb290LnRlbnNvcmZsb3cuR3JhZGllbnREZWYuZGVjb2RlKGUsZS51aW50MzIoKSkpO2JyZWFrO2RlZmF1bHQ6ZS5za2lwVHlwZSg3Jm4pfX1yZXR1cm4gcn0sZX0oKSxhLkZ1bmN0aW9uRGVmPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlKXtpZih0aGlzLmF0dHI9e30sdGhpcy5ub2RlRGVmPVtdLHRoaXMucmV0PXt9LGUpZm9yKHZhciB0PU9iamVjdC5rZXlzKGUpLGE9MDthPHQubGVuZ3RoOysrYSludWxsIT1lW3RbYV1dJiYodGhpc1t0W2FdXT1lW3RbYV1dKX1yZXR1cm4gZS5wcm90b3R5cGUuc2lnbmF0dXJlPW51bGwsZS5wcm90b3R5cGUuYXR0cj0kdXRpbC5lbXB0eU9iamVjdCxlLnByb3RvdHlwZS5ub2RlRGVmPSR1dGlsLmVtcHR5QXJyYXksZS5wcm90b3R5cGUucmV0PSR1dGlsLmVtcHR5T2JqZWN0LGUuZGVjb2RlPWZ1bmN0aW9uKGUsdCl7ZSBpbnN0YW5jZW9mICRSZWFkZXJ8fChlPSRSZWFkZXIuY3JlYXRlKGUpKTtmb3IodmFyIGEscj12b2lkIDA9PT10P2UubGVuOmUucG9zK3Qsbj1uZXcgJHJvb3QudGVuc29yZmxvdy5GdW5jdGlvbkRlZjtlLnBvczxyOyl7dmFyIG89ZS51aW50MzIoKTtzd2l0Y2gobz4+PjMpe2Nhc2UgMTpuLnNpZ25hdHVyZT0kcm9vdC50ZW5zb3JmbG93Lk9wRGVmLmRlY29kZShlLGUudWludDMyKCkpO2JyZWFrO2Nhc2UgNTplLnNraXAoKS5wb3MrKyxuLmF0dHI9PT0kdXRpbC5lbXB0eU9iamVjdCYmKG4uYXR0cj17fSksYT1lLnN0cmluZygpLGUucG9zKyssbi5hdHRyW2FdPSRyb290LnRlbnNvcmZsb3cuQXR0clZhbHVlLmRlY29kZShlLGUudWludDMyKCkpO2JyZWFrO2Nhc2UgMzpuLm5vZGVEZWYmJm4ubm9kZURlZi5sZW5ndGh8fChuLm5vZGVEZWY9W10pLG4ubm9kZURlZi5wdXNoKCRyb290LnRlbnNvcmZsb3cuTm9kZURlZi5kZWNvZGUoZSxlLnVpbnQzMigpKSk7YnJlYWs7Y2FzZSA0OmUuc2tpcCgpLnBvcysrLG4ucmV0PT09JHV0aWwuZW1wdHlPYmplY3QmJihuLnJldD17fSksYT1lLnN0cmluZygpLGUucG9zKyssbi5yZXRbYV09ZS5zdHJpbmcoKTticmVhaztkZWZhdWx0OmUuc2tpcFR5cGUoNyZvKX19cmV0dXJuIG59LGV9KCksYS5HcmFkaWVudERlZj1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSl7aWYoZSlmb3IodmFyIHQ9T2JqZWN0LmtleXMoZSksYT0wO2E8dC5sZW5ndGg7KythKW51bGwhPWVbdFthXV0mJih0aGlzW3RbYV1dPWVbdFthXV0pfXJldHVybiBlLnByb3RvdHlwZS5mdW5jdGlvbk5hbWU9XCJcIixlLnByb3RvdHlwZS5ncmFkaWVudEZ1bmM9XCJcIixlLmRlY29kZT1mdW5jdGlvbihlLHQpe2UgaW5zdGFuY2VvZiAkUmVhZGVyfHwoZT0kUmVhZGVyLmNyZWF0ZShlKSk7Zm9yKHZhciBhPXZvaWQgMD09PXQ/ZS5sZW46ZS5wb3MrdCxyPW5ldyAkcm9vdC50ZW5zb3JmbG93LkdyYWRpZW50RGVmO2UucG9zPGE7KXt2YXIgbj1lLnVpbnQzMigpO3N3aXRjaChuPj4+Myl7Y2FzZSAxOnIuZnVuY3Rpb25OYW1lPWUuc3RyaW5nKCk7YnJlYWs7Y2FzZSAyOnIuZ3JhZGllbnRGdW5jPWUuc3RyaW5nKCk7YnJlYWs7ZGVmYXVsdDplLnNraXBUeXBlKDcmbil9fXJldHVybiByfSxlfSgpLGF9KCk7dmFyIGNvbXBpbGVkX2FwaT0kcm9vdCxjb21waWxlZF9hcGlfMT1jb21waWxlZF9hcGkudGVuc29yZmxvdztmdW5jdGlvbiBnZXRQYXJhbVZhbHVlKGUsdCxhLHIpe3ZhciBuPXQucGFyYW1zW2VdO2lmKG4mJnZvaWQgMCE9PW4uaW5wdXRJbmRleCl7aWYoXCJ0ZW5zb3JcIj09PW4udHlwZSlyZXR1cm4gZ2V0VGVuc29yKHQuaW5wdXROYW1lc1tuLmlucHV0SW5kZXhdLGEscik7aWYoXCJ0ZW5zb3JzXCI9PT1uLnR5cGUpcmV0dXJuKDA9PT1uLmlucHV0SW5kZXg/MD09PW4uaW5wdXRQYXJhbUxlbmd0aD90LmlucHV0TmFtZXM6dC5pbnB1dE5hbWVzLnNsaWNlKG4uaW5wdXRJbmRleCwtbi5pbnB1dFBhcmFtTGVuZ3RoKTp0LmlucHV0TmFtZXMuc3BsaWNlKG4uaW5wdXRJbmRleCkpLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZ2V0VGVuc29yKGUsYSxyKX0pO3ZhciBvPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGdldFRlbnNvcih0LmlucHV0TmFtZXMuc2xpY2Uobi5pbnB1dEluZGV4KVswXSxhLHIpLmRhdGFTeW5jKCkpO3JldHVyblwibnVtYmVyXCI9PT1uLnR5cGU/b1swXTpvfXJldHVybiBuJiZuLnZhbHVlfWZ1bmN0aW9uIGdldFRlbnNvcihlLHQsYSl7dmFyIHI9cGFyc2VOb2RlTmFtZShlKSxuPXJbMF0sbz1yWzFdLHM9YS5jdXJyZW50Q29udGV4dElkcy5maW5kKGZ1bmN0aW9uKGUpe3JldHVybiEhdFtnZXROb2RlTmFtZVdpdGhDb250ZXh0SWQobixlKV19KTtyZXR1cm4gdm9pZCAwIT09cz90W2dldE5vZGVOYW1lV2l0aENvbnRleHRJZChuLHMpXVtvXTp2b2lkIDB9ZnVuY3Rpb24gZ2V0VGVuc29yc0ZvckN1cnJlbnRDb250ZW54dChlLHQsYSl7cmV0dXJuIHRbZ2V0Tm9kZU5hbWVXaXRoQ29udGV4dElkKGUsYS5jdXJyZW50Q29udGV4dElkKV19ZnVuY3Rpb24gZ2V0Tm9kZU5hbWVBbmRJbmRleChlLHQpe3ZhciBhPXBhcnNlTm9kZU5hbWUoZSkscj1hWzBdLG49YVsxXTtyZXR1cm5bZ2V0Tm9kZU5hbWVXaXRoQ29udGV4dElkKHIsdCYmdC5jdXJyZW50Q29udGV4dElkKSxuXX1mdW5jdGlvbiBnZXROb2RlTmFtZVdpdGhDb250ZXh0SWQoZSx0KXtyZXR1cm4gdD9lK1wiLVwiK3Q6ZX1mdW5jdGlvbiBwYXJzZU5vZGVOYW1lKGUpe3ZhciB0PWUubGFzdEluZGV4T2YoXCI6XCIpO3JldHVybi0xPT09dD9bZSwwXTpbZS5zdWJzdHJpbmcoMCx0KSxOdW1iZXIoZS5zdWJzdHJpbmcodCsxKSldfWZ1bmN0aW9uIHNwbGl0JDEoZSx0KXtmb3IodmFyIGE9W10scj0wO3I8ZS5sZW5ndGg7cis9dClhLnB1c2goZS5zbGljZShyLHIrdCkpO3JldHVybiBhfXZhciBqc29uPVt7dGZPcE5hbWU6XCJBZGRcIixkbE9wTmFtZTpcImFkZFwiLGNhdGVnb3J5OlwiYXJpdGhtZXRpY1wiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDoxLGRsUGFyYW1OYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmUGFyYW1OYW1lOlwiVFwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiQWRkTlwiLGRsT3BOYW1lOlwiYWRkTlwiLGNhdGVnb3J5OlwiYXJpdGhtZXRpY1wiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLHRmSW5wdXRQYXJhbUxlbmd0aDowLGRsUGFyYW1OYW1lOlwidGVuc29yc1wiLHR5cGU6XCJ0ZW5zb3JzXCJ9XX0se3RmT3BOYW1lOlwiQmlhc0FkZFwiLGRsT3BOYW1lOlwiYWRkXCIsY2F0ZWdvcnk6XCJhcml0aG1ldGljXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7dGZJbnB1dEluZGV4OjEsZGxQYXJhbU5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifSx7dGZQYXJhbU5hbWU6XCJUXCIsZGxQYXJhbU5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJTdWJcIixkbE9wTmFtZTpcInN1YlwiLGNhdGVnb3J5OlwiYXJpdGhtZXRpY1wiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDoxLGRsUGFyYW1OYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmUGFyYW1OYW1lOlwiVFwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiUmVhbERpdlwiLGRsT3BOYW1lOlwiZGl2XCIsY2F0ZWdvcnk6XCJhcml0aG1ldGljXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7dGZJbnB1dEluZGV4OjEsZGxQYXJhbU5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifSx7dGZQYXJhbU5hbWU6XCJUXCIsZGxQYXJhbU5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJEaXZcIixkbE9wTmFtZTpcImRpdlwiLGNhdGVnb3J5OlwiYXJpdGhtZXRpY1wiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDoxLGRsUGFyYW1OYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmUGFyYW1OYW1lOlwiVFwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiRmxvb3JEaXZcIixkbE9wTmFtZTpcImZsb29yRGl2XCIsY2F0ZWdvcnk6XCJhcml0aG1ldGljXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7dGZJbnB1dEluZGV4OjEsZGxQYXJhbU5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifSx7dGZQYXJhbU5hbWU6XCJUXCIsZGxQYXJhbU5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJNdWxcIixkbE9wTmFtZTpcIm11bFwiLGNhdGVnb3J5OlwiYXJpdGhtZXRpY1wiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDoxLGRsUGFyYW1OYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmUGFyYW1OYW1lOlwiVFwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiTWF4aW11bVwiLGRsT3BOYW1lOlwibWF4aW11bVwiLGNhdGVnb3J5OlwiYXJpdGhtZXRpY1wiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDoxLGRsUGFyYW1OYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn1dfSx7dGZPcE5hbWU6XCJNaW5pbXVtXCIsZGxPcE5hbWU6XCJtaW5pbXVtXCIsY2F0ZWdvcnk6XCJhcml0aG1ldGljXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7dGZJbnB1dEluZGV4OjEsZGxQYXJhbU5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifV19LHt0Zk9wTmFtZTpcIlBvd1wiLGRsT3BOYW1lOlwicG93XCIsY2F0ZWdvcnk6XCJhcml0aG1ldGljXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7dGZJbnB1dEluZGV4OjEsZGxQYXJhbU5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifSx7dGZQYXJhbU5hbWU6XCJUXCIsZGxQYXJhbU5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJTcXVhcmVkRGlmZmVyZW5jZVwiLGRsT3BOYW1lOlwic3F1YXJlZERpZmZlcmVuY2VcIixjYXRlZ29yeTpcImFyaXRobWV0aWNcIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHt0ZklucHV0SW5kZXg6MSxkbFBhcmFtTmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9LHt0ZlBhcmFtTmFtZTpcIlRcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIk1vZFwiLGRsT3BOYW1lOlwibW9kXCIsY2F0ZWdvcnk6XCJhcml0aG1ldGljXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7dGZJbnB1dEluZGV4OjEsZGxQYXJhbU5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifSx7dGZQYXJhbU5hbWU6XCJUXCIsZGxQYXJhbU5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJGbG9vck1vZFwiLGRsT3BOYW1lOlwibW9kXCIsY2F0ZWdvcnk6XCJhcml0aG1ldGljXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7dGZJbnB1dEluZGV4OjEsZGxQYXJhbU5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifSx7dGZQYXJhbU5hbWU6XCJUXCIsZGxQYXJhbU5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfV0sYXJpdGhtZXRpYz1PYmplY3QuZnJlZXplKHtqc29uOmpzb259KSxqc29uJDE9W3t0Zk9wTmFtZTpcIkFic1wiLGRsT3BOYW1lOlwiYWJzXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7dGZQYXJhbU5hbWU6XCJUXCIsZGxQYXJhbU5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJBY29zXCIsZGxPcE5hbWU6XCJhY29zXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7dGZQYXJhbU5hbWU6XCJUXCIsZGxQYXJhbU5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJBc2luXCIsZGxPcE5hbWU6XCJhc2luXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7dGZQYXJhbU5hbWU6XCJUXCIsZGxQYXJhbU5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJBdGFuXCIsZGxPcE5hbWU6XCJhdGFuXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7dGZQYXJhbU5hbWU6XCJUXCIsZGxQYXJhbU5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJBdGFuMlwiLGRsT3BOYW1lOlwiYXRhbjJcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHt0ZklucHV0SW5kZXg6MSxkbFBhcmFtTmFtZTpcInlcIix0eXBlOlwidGVuc29yXCJ9LHt0ZlBhcmFtTmFtZTpcIlRcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkNlaWxcIixkbE9wTmFtZTpcImNlaWxcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHt0ZlBhcmFtTmFtZTpcIlRcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkNsaXBCeVZhbHVlXCIsZGxPcE5hbWU6XCJjbGlwQnlWYWx1ZVwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmUGFyYW1OYW1lOlwiY2xpcF92YWx1ZV9taW5cIixkbFBhcmFtTmFtZTpcImNsaXBWYWx1ZU1pblwiLHR5cGU6XCJudW1iZXJcIn0se3RmUGFyYW1OYW1lOlwiY2xpcF92YWx1ZV9tYXhcIixkbFBhcmFtTmFtZTpcImNsaXBWYWx1ZU1heFwiLHR5cGU6XCJudW1iZXJcIn1dfSx7dGZPcE5hbWU6XCJDb3NcIixkbE9wTmFtZTpcImNvc1wiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmUGFyYW1OYW1lOlwiVFwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiQ29zaFwiLGRsT3BOYW1lOlwiY29zaFwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmUGFyYW1OYW1lOlwiVFwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiRWx1XCIsZGxPcE5hbWU6XCJlbHVcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHt0ZlBhcmFtTmFtZTpcIlRcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkV4cFwiLGRsT3BOYW1lOlwiZXhwXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7dGZQYXJhbU5hbWU6XCJUXCIsZGxQYXJhbU5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJGbG9vclwiLGRsT3BOYW1lOlwiZmxvb3JcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHt0ZlBhcmFtTmFtZTpcIlRcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkxvZ1wiLGRsT3BOYW1lOlwibG9nXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7dGZQYXJhbU5hbWU6XCJUXCIsZGxQYXJhbU5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJOZWdcIixkbE9wTmFtZTpcIm5lZ1wiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmUGFyYW1OYW1lOlwiVFwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiUmVsdVwiLGRsT3BOYW1lOlwicmVsdVwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmUGFyYW1OYW1lOlwiVFwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiUmVsdTZcIixkbE9wTmFtZTpcImNsaXBCeVZhbHVlXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7dGZQYXJhbU5hbWU6XCJUXCIsZGxQYXJhbU5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH0se2RsUGFyYW1OYW1lOlwiY2xpcFZhbHVlTWluXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowfSx7ZGxQYXJhbU5hbWU6XCJjbGlwVmFsdWVNYXhcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjZ9XX0se3RmT3BOYW1lOlwiU2VsdVwiLGRsT3BOYW1lOlwic2VsdVwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmUGFyYW1OYW1lOlwiVFwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiU2lnbW9pZFwiLGRsT3BOYW1lOlwic2lnbW9pZFwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmUGFyYW1OYW1lOlwiVFwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiU2luXCIsZGxPcE5hbWU6XCJzaW5cIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHt0ZlBhcmFtTmFtZTpcIlRcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlNpbmhcIixkbE9wTmFtZTpcInNpbmhcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHt0ZlBhcmFtTmFtZTpcIlRcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlNxcnRcIixkbE9wTmFtZTpcInNxcnRcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHt0ZlBhcmFtTmFtZTpcIlRcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlJzcXJ0XCIsZGxPcE5hbWU6XCJyc3FydFwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmUGFyYW1OYW1lOlwiVFwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiU3F1YXJlXCIsZGxPcE5hbWU6XCJzcXVhcmVcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHt0ZlBhcmFtTmFtZTpcIlRcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlRhblwiLGRsT3BOYW1lOlwidGFuXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7dGZQYXJhbU5hbWU6XCJUXCIsZGxQYXJhbU5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJUYW5oXCIsZGxPcE5hbWU6XCJ0YW5oXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7dGZQYXJhbU5hbWU6XCJUXCIsZGxQYXJhbU5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJTaWduXCIsZGxPcE5hbWU6XCJzaWduXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7dGZQYXJhbU5hbWU6XCJUXCIsZGxQYXJhbU5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJSb3VuZFwiLGRsT3BOYW1lOlwicm91bmRcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHt0ZlBhcmFtTmFtZTpcIlRcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkV4cG0xXCIsZGxPcE5hbWU6XCJleHBtMVwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmUGFyYW1OYW1lOlwiVFwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiTG9nMXBcIixkbE9wTmFtZTpcImxvZzFwXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7dGZQYXJhbU5hbWU6XCJUXCIsZGxQYXJhbU5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJSZWNpcHJvY2FsXCIsZGxPcE5hbWU6XCJyZWNpcHJvY2FsXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7dGZQYXJhbU5hbWU6XCJUXCIsZGxQYXJhbU5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJSZWNpcHJvY2FsXCIsZGxPcE5hbWU6XCJyZWNpcHJvY2FsXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7dGZQYXJhbU5hbWU6XCJUXCIsZGxQYXJhbU5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJTb2Z0cGx1c1wiLGRsT3BOYW1lOlwic29mdHBsdXNcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHt0ZlBhcmFtTmFtZTpcIlRcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkFzaW5oXCIsZGxPcE5hbWU6XCJhc2luaFwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmUGFyYW1OYW1lOlwiVFwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiQWNvc2hcIixkbE9wTmFtZTpcImFjb3NoXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7dGZQYXJhbU5hbWU6XCJUXCIsZGxQYXJhbU5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJBdGFuaFwiLGRsT3BOYW1lOlwiYXRhbmhcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHt0ZlBhcmFtTmFtZTpcIlRcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkVyZlwiLGRsT3BOYW1lOlwiZXJmXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7dGZQYXJhbU5hbWU6XCJUXCIsZGxQYXJhbU5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJQcm9kXCIsZGxPcE5hbWU6XCJwcm9kXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7dGZJbnB1dEluZGV4OjEsZGxQYXJhbU5hbWU6XCJheGVzXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0ZlBhcmFtTmFtZTpcImtlZXBfZGltc1wiLGRsUGFyYW1OYW1lOlwia2VlcERpbXNcIix0eXBlOlwiYm9vbFwiLG5vdFN1cHBvcnRlZDohMH0se3RmUGFyYW1OYW1lOlwiVFwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiTGVha3lSZWx1XCIsZGxPcE5hbWU6XCJsZWFreVJlbHVcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHt0ZlBhcmFtTmFtZTpcImFscGhhXCIsZGxQYXJhbU5hbWU6XCJhbHBoYVwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6LjJ9LHt0ZlBhcmFtTmFtZTpcIlRcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19XSxiYXNpY01hdGg9T2JqZWN0LmZyZWV6ZSh7anNvbjpqc29uJDF9KSxqc29uJDI9W3t0Zk9wTmFtZTpcIkxvb3BDb25kXCIsZGxPcE5hbWU6XCJsb29wQ29uZFwiLGNhdGVnb3J5OlwiY29udHJvbFwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwicHJlZFwiLHR5cGU6XCJ0ZW5zb3JcIn1dfSx7dGZPcE5hbWU6XCJTd2l0Y2hcIixkbE9wTmFtZTpcInN3aXRjaFwiLGNhdGVnb3J5OlwiY29udHJvbFwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwiZGF0YVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDoxLGRsUGFyYW1OYW1lOlwicHJlZFwiLHR5cGU6XCJ0ZW5zb3JcIn1dfSx7dGZPcE5hbWU6XCJNZXJnZVwiLGRsT3BOYW1lOlwibWVyZ2VcIixjYXRlZ29yeTpcImNvbnRyb2xcIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCx0ZklucHV0UGFyYW1MZW5ndGg6MCxkbFBhcmFtTmFtZTpcInRlbnNvcnNcIix0eXBlOlwidGVuc29yc1wifV19LHt0Zk9wTmFtZTpcIkVudGVyXCIsZGxPcE5hbWU6XCJlbnRlclwiLGNhdGVnb3J5OlwiY29udHJvbFwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwidGVuc29yXCIsdHlwZTpcInRlbnNvclwifSx7dGZQYXJhbU5hbWU6XCJUXCIsZGxQYXJhbU5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH0se3RmUGFyYW1OYW1lOlwiZnJhbWVfbmFtZVwiLGRsUGFyYW1OYW1lOlwiZnJhbWVOYW1lXCIsdHlwZTpcInN0cmluZ1wifSx7dGZQYXJhbU5hbWU6XCJpc19jb25zdGFudFwiLGRsUGFyYW1OYW1lOlwiaXNDb25zdGFudFwiLHR5cGU6XCJib29sXCJ9XX0se3RmT3BOYW1lOlwiRXhpdFwiLGRsT3BOYW1lOlwiZXhpdFwiLGNhdGVnb3J5OlwiY29udHJvbFwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwidGVuc29yXCIsdHlwZTpcInRlbnNvclwifSx7dGZQYXJhbU5hbWU6XCJUXCIsZGxQYXJhbU5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJOZXh0SXRlcmF0aW9uXCIsZGxPcE5hbWU6XCJuZXh0SXRlcmF0aW9uXCIsY2F0ZWdvcnk6XCJjb250cm9sXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ0ZW5zb3JcIix0eXBlOlwidGVuc29yXCJ9LHt0ZlBhcmFtTmFtZTpcIlRcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlRlbnNvckFycmF5VjNcIixkbE9wTmFtZTpcInRlbnNvckFycmF5XCIsY2F0ZWdvcnk6XCJjb250cm9sXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJzaXplXCIsdHlwZTpcIm51bWJlclwifSx7dGZQYXJhbU5hbWU6XCJkdHlwZVwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIn0se3RmUGFyYW1OYW1lOlwiZWxlbWVudF9zaGFwZVwiLGRsUGFyYW1OYW1lOlwiZWxlbWVudFNoYXBlXCIsdHlwZTpcInNoYXBlXCJ9LHt0ZlBhcmFtTmFtZTpcImR5bmFtaWNfc2l6ZVwiLGRsUGFyYW1OYW1lOlwiZHluYW1pY1NpemVcIix0eXBlOlwiYm9vbFwifSx7dGZQYXJhbU5hbWU6XCJjbGVhcl9hZnRlcl9yZWFkXCIsZGxQYXJhbU5hbWU6XCJjbGVhckFmdGVyUmVhZFwiLHR5cGU6XCJib29sXCJ9LHt0ZlBhcmFtTmFtZTpcImlkZW50aWNhbF9lbGVtZW50X3NoYXBlc1wiLGRsUGFyYW1OYW1lOlwiaWRlbnRpY2FsRWxlbWVudFNoYXBlc1wiLHR5cGU6XCJib29sXCJ9LHt0ZlBhcmFtTmFtZTpcInRlbnNvcl9hcnJheV9uYW1lXCIsZGxQYXJhbU5hbWU6XCJuYW1lXCIsdHlwZTpcInN0cmluZ1wifV19LHt0Zk9wTmFtZTpcIlRlbnNvckFycmF5V3JpdGVWM1wiLGRsT3BOYW1lOlwidGVuc29yQXJyYXlXcml0ZVwiLGNhdGVnb3J5OlwiY29udHJvbFwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwidGVuc29yQXJyYXlJZFwiLHR5cGU6XCJudW1iZXJcIn0se3RmSW5wdXRJbmRleDoxLGRsUGFyYW1OYW1lOlwiaW5kZXhcIix0eXBlOlwibnVtYmVyXCJ9LHt0ZklucHV0SW5kZXg6MixkbFBhcmFtTmFtZTpcInRlbnNvclwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDozLGRsUGFyYW1OYW1lOlwiZmxvd0luXCIsdHlwZTpcIm51bWJlclwifSx7dGZQYXJhbU5hbWU6XCJUXCIsZGxQYXJhbU5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJUZW5zb3JBcnJheVJlYWRWM1wiLGRsT3BOYW1lOlwidGVuc29yQXJyYXlSZWFkXCIsY2F0ZWdvcnk6XCJjb250cm9sXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ0ZW5zb3JBcnJheUlkXCIsdHlwZTpcIm51bWJlclwifSx7dGZJbnB1dEluZGV4OjEsZGxQYXJhbU5hbWU6XCJpbmRleFwiLHR5cGU6XCJudW1iZXJcIn0se3RmSW5wdXRJbmRleDoyLGRsUGFyYW1OYW1lOlwiZmxvd0luXCIsdHlwZTpcIm51bWJlclwifSx7dGZQYXJhbU5hbWU6XCJkdHlwZVwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiVGVuc29yQXJyYXlHYXRoZXJWM1wiLGRsT3BOYW1lOlwidGVuc29yQXJyYXlHYXRoZXJcIixjYXRlZ29yeTpcImNvbnRyb2xcIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInRlbnNvckFycmF5SWRcIix0eXBlOlwibnVtYmVyXCJ9LHt0ZklucHV0SW5kZXg6MSxkbFBhcmFtTmFtZTpcImluZGljZXNcIix0eXBlOlwibnVtYmVyW11cIn0se3RmSW5wdXRJbmRleDoyLGRsUGFyYW1OYW1lOlwiZmxvd0luXCIsdHlwZTpcIm51bWJlclwifSx7dGZQYXJhbU5hbWU6XCJkdHlwZVwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIn0se3RmUGFyYW1OYW1lOlwiZWxlbWVudF9zaGFwZVwiLGRsUGFyYW1OYW1lOlwiZWxlbWVudFNoYXBlXCIsdHlwZTpcInNoYXBlXCJ9XX0se3RmT3BOYW1lOlwiVGVuc29yQXJyYXlTY2F0dGVyVjNcIixkbE9wTmFtZTpcInRlbnNvckFycmF5U2NhdHRlclwiLGNhdGVnb3J5OlwiY29udHJvbFwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwidGVuc29yQXJyYXlJZFwiLHR5cGU6XCJudW1iZXJcIn0se3RmSW5wdXRJbmRleDoxLGRsUGFyYW1OYW1lOlwiaW5kaWNlc1wiLHR5cGU6XCJudW1iZXJbXVwifSx7dGZJbnB1dEluZGV4OjIsZGxQYXJhbU5hbWU6XCJ0ZW5zb3JcIix0eXBlOlwidGVuc29yXCJ9LHt0ZklucHV0SW5kZXg6MyxkbFBhcmFtTmFtZTpcImZsb3dJblwiLHR5cGU6XCJudW1iZXJcIn0se3RmUGFyYW1OYW1lOlwiVFwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIn1dfSx7dGZPcE5hbWU6XCJUZW5zb3JBcnJheUNvbmNhdFYzXCIsZGxPcE5hbWU6XCJ0ZW5zb3JBcnJheUNvbmNhdFwiLGNhdGVnb3J5OlwiY29udHJvbFwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwidGVuc29yQXJyYXlJZFwiLHR5cGU6XCJudW1iZXJcIn0se3RmSW5wdXRJbmRleDoxLGRsUGFyYW1OYW1lOlwiZmxvd0luXCIsdHlwZTpcIm51bWJlclwifSx7dGZQYXJhbU5hbWU6XCJkdHlwZVwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIn0se3RmUGFyYW1OYW1lOlwiZWxlbWVudF9zaGFwZV9leGNlcHQwXCIsZGxQYXJhbU5hbWU6XCJlbGVtZW50U2hhcGVFeGNlcHQwXCIsdHlwZTpcInNoYXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlRlbnNvckFycmF5U3BsaXRWM1wiLGRsT3BOYW1lOlwidGVuc29yQXJyYXlTcGxpdFwiLGNhdGVnb3J5OlwiY29udHJvbFwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwidGVuc29yQXJyYXlJZFwiLHR5cGU6XCJudW1iZXJcIn0se3RmSW5wdXRJbmRleDoxLGRsUGFyYW1OYW1lOlwidGVuc29yXCIsdHlwZTpcInRlbnNvclwifSx7dGZJbnB1dEluZGV4OjIsZGxQYXJhbU5hbWU6XCJsZW5ndGhzXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0ZklucHV0SW5kZXg6MyxkbFBhcmFtTmFtZTpcImZsb3dJblwiLHR5cGU6XCJudW1iZXJcIn0se3RmUGFyYW1OYW1lOlwiVFwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIn1dfSx7dGZPcE5hbWU6XCJUZW5zb3JBcnJheVNpemVWM1wiLGRsT3BOYW1lOlwidGVuc29yQXJyYXlTaXplXCIsY2F0ZWdvcnk6XCJjb250cm9sXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ0ZW5zb3JBcnJheUlkXCIsdHlwZTpcIm51bWJlclwifSx7dGZJbnB1dEluZGV4OjEsZGxQYXJhbU5hbWU6XCJmbG93SW5cIix0eXBlOlwibnVtYmVyXCJ9XX0se3RmT3BOYW1lOlwiVGVuc29yQXJyYXlDbG9zZVYzXCIsZGxPcE5hbWU6XCJ0ZW5zb3JBcnJheUNsb3NlXCIsY2F0ZWdvcnk6XCJjb250cm9sXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ0ZW5zb3JBcnJheUlkXCIsdHlwZTpcIm51bWJlclwifV19XSxjb250cm9sPU9iamVjdC5mcmVlemUoe2pzb246anNvbiQyfSksanNvbiQzPVt7dGZPcE5hbWU6XCJBdmdQb29sXCIsZGxPcE5hbWU6XCJhdmdQb29sXCIsY2F0ZWdvcnk6XCJjb252b2x1dGlvblwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmUGFyYW1OYW1lOlwic3RyaWRlc1wiLGRsUGFyYW1OYW1lOlwic3RyaWRlc1wiLHR5cGU6XCJudW1iZXJbXVwifSx7dGZQYXJhbU5hbWU6XCJwYWRkaW5nXCIsZGxQYXJhbU5hbWU6XCJwYWRcIix0eXBlOlwic3RyaW5nXCJ9LHt0ZlBhcmFtTmFtZTpcImRhdGFfZm9ybWF0XCIsZGxQYXJhbU5hbWU6XCJkYXRhRm9ybWF0XCIsdHlwZTpcInN0cmluZ1wiLG5vdFN1cHBvcnRlZDohMH0se3RmUGFyYW1OYW1lOlwia3NpemVcIixkbFBhcmFtTmFtZTpcImtlcm5lbFNpemVcIix0eXBlOlwibnVtYmVyW11cIn0se3RmUGFyYW1OYW1lOlwiVFwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiTWF4UG9vbFwiLGRsT3BOYW1lOlwibWF4UG9vbFwiLGNhdGVnb3J5OlwiY29udm9sdXRpb25cIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHt0ZlBhcmFtTmFtZTpcInN0cmlkZXNcIixkbFBhcmFtTmFtZTpcInN0cmlkZXNcIix0eXBlOlwibnVtYmVyW11cIn0se3RmUGFyYW1OYW1lOlwicGFkZGluZ1wiLGRsUGFyYW1OYW1lOlwicGFkXCIsdHlwZTpcInN0cmluZ1wifSx7dGZQYXJhbU5hbWU6XCJkYXRhX2Zvcm1hdFwiLGRsUGFyYW1OYW1lOlwiZGF0YUZvcm1hdFwiLHR5cGU6XCJzdHJpbmdcIixub3RTdXBwb3J0ZWQ6ITB9LHt0ZlBhcmFtTmFtZTpcImtzaXplXCIsZGxQYXJhbU5hbWU6XCJrZXJuZWxTaXplXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0ZlBhcmFtTmFtZTpcIlRcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkNvbnYxRFwiLGRsT3BOYW1lOlwiY29udjFkXCIsY2F0ZWdvcnk6XCJjb252b2x1dGlvblwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDoxLGRsUGFyYW1OYW1lOlwiZmlsdGVyXCIsdHlwZTpcInRlbnNvclwifSx7dGZQYXJhbU5hbWU6XCJzdHJpZGVcIixkbFBhcmFtTmFtZTpcInN0cmlkZVwiLHR5cGU6XCJudW1iZXJcIn0se3RmUGFyYW1OYW1lOlwicGFkZGluZ1wiLGRsUGFyYW1OYW1lOlwicGFkXCIsdHlwZTpcInN0cmluZ1wifSx7dGZQYXJhbU5hbWU6XCJkYXRhX2Zvcm1hdFwiLGRsUGFyYW1OYW1lOlwiZGF0YUZvcm1hdFwiLHR5cGU6XCJzdHJpbmdcIixkZWZhdWx0VmFsdWU6XCJOV0NcIn0se3RmUGFyYW1OYW1lOlwiVFwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9LHt0ZlBhcmFtTmFtZTpcImRpbGF0aW9uXCIsZGxQYXJhbU5hbWU6XCJkaWxhdGlvblwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MX1dfSx7dGZPcE5hbWU6XCJDb252MkRcIixkbE9wTmFtZTpcImNvbnYyZFwiLGNhdGVnb3J5OlwiY29udm9sdXRpb25cIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHt0ZklucHV0SW5kZXg6MSxkbFBhcmFtTmFtZTpcImZpbHRlclwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmUGFyYW1OYW1lOlwiVFwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9LHt0ZlBhcmFtTmFtZTpcInN0cmlkZXNcIixkbFBhcmFtTmFtZTpcInN0cmlkZXNcIix0eXBlOlwibnVtYmVyW11cIn0se3RmUGFyYW1OYW1lOlwicGFkZGluZ1wiLGRsUGFyYW1OYW1lOlwicGFkXCIsdHlwZTpcInN0cmluZ1wifSx7dGZQYXJhbU5hbWU6XCJ1c2VDdWRubk9uR3B1XCIsZGxQYXJhbU5hbWU6XCJ1c2VDdWRubk9uR3B1XCIsdHlwZTpcImJvb2xcIn0se3RmUGFyYW1OYW1lOlwiZGF0YV9mb3JtYXRcIixkbFBhcmFtTmFtZTpcImRhdGFGb3JtYXRcIix0eXBlOlwic3RyaW5nXCIsZGVmYXVsdFZhbHVlOlwiTkhXQ1wifSx7dGZQYXJhbU5hbWU6XCJkaWxhdGlvbnNcIixkbFBhcmFtTmFtZTpcImRpbGF0aW9uc1wiLHR5cGU6XCJudW1iZXJbXVwifV19LHt0Zk9wTmFtZTpcIkNvbnYyREJhY2twcm9wSW5wdXRcIixkbE9wTmFtZTpcImNvbnYyZFRyYW5zcG9zZVwiLGNhdGVnb3J5OlwiY29udm9sdXRpb25cIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MixkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHt0ZklucHV0SW5kZXg6MSxkbFBhcmFtTmFtZTpcImZpbHRlclwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwib3V0cHV0U2hhcGVcIix0eXBlOlwibnVtYmVyW11cIn0se3RmUGFyYW1OYW1lOlwic3RyaWRlc1wiLGRsUGFyYW1OYW1lOlwic3RyaWRlc1wiLHR5cGU6XCJudW1iZXJbXVwifSx7dGZQYXJhbU5hbWU6XCJwYWRkaW5nXCIsZGxQYXJhbU5hbWU6XCJwYWRcIix0eXBlOlwic3RyaW5nXCJ9LHt0ZlBhcmFtTmFtZTpcImRhdGFfZm9ybWF0XCIsZGxQYXJhbU5hbWU6XCJkYXRhRm9ybWF0XCIsdHlwZTpcInN0cmluZ1wiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJEZXB0aHdpc2VDb252MmRcIixkbE9wTmFtZTpcImRlcHRod2lzZUNvbnYyZFwiLGNhdGVnb3J5OlwiY29udm9sdXRpb25cIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcImlucHV0XCIsdHlwZTpcInRlbnNvclwifSx7dGZJbnB1dEluZGV4OjEsZGxQYXJhbU5hbWU6XCJmaWx0ZXJcIix0eXBlOlwidGVuc29yXCJ9LHt0ZlBhcmFtTmFtZTpcInN0cmlkZXNcIixkbFBhcmFtTmFtZTpcInN0cmlkZXNcIix0eXBlOlwibnVtYmVyW11cIn0se3RmUGFyYW1OYW1lOlwicGFkZGluZ1wiLGRsUGFyYW1OYW1lOlwicGFkXCIsdHlwZTpcInN0cmluZ1wifSx7dGZQYXJhbU5hbWU6XCJkYXRhX2Zvcm1hdFwiLGRsUGFyYW1OYW1lOlwiZGF0YUZvcm1hdFwiLHR5cGU6XCJzdHJpbmdcIixkZWZhdWx0VmFsdWU6XCJOSFdDXCJ9LHt0ZlBhcmFtTmFtZTpcImRpbGF0aW9uc1wiLGRsUGFyYW1OYW1lOlwiZGlsYXRpb25zXCIsdHlwZTpcIm51bWJlcltdXCJ9XX0se3RmT3BOYW1lOlwiRGVwdGh3aXNlQ29udjJkTmF0aXZlXCIsZGxPcE5hbWU6XCJkZXB0aHdpc2VDb252MmRcIixjYXRlZ29yeTpcImNvbnZvbHV0aW9uXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJpbnB1dFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDoxLGRsUGFyYW1OYW1lOlwiZmlsdGVyXCIsdHlwZTpcInRlbnNvclwifSx7dGZQYXJhbU5hbWU6XCJzdHJpZGVzXCIsZGxQYXJhbU5hbWU6XCJzdHJpZGVzXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0ZlBhcmFtTmFtZTpcInBhZGRpbmdcIixkbFBhcmFtTmFtZTpcInBhZFwiLHR5cGU6XCJzdHJpbmdcIn0se3RmUGFyYW1OYW1lOlwiZGF0YV9mb3JtYXRcIixkbFBhcmFtTmFtZTpcImRhdGFGb3JtYXRcIix0eXBlOlwic3RyaW5nXCIsZGVmYXVsdFZhbHVlOlwiTkhXQ1wifSx7dGZQYXJhbU5hbWU6XCJkaWxhdGlvbnNcIixkbFBhcmFtTmFtZTpcImRpbGF0aW9uc1wiLHR5cGU6XCJudW1iZXJbXVwifV19XSxjb252b2x1dGlvbj1PYmplY3QuZnJlZXplKHtqc29uOmpzb24kM30pLGpzb24kND1be3RmT3BOYW1lOlwiRmlsbFwiLGRsT3BOYW1lOlwiZmlsbFwiLGNhdGVnb3J5OlwiY3JlYXRpb25cIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInNoYXBlXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0ZklucHV0SW5kZXg6MSxkbFBhcmFtTmFtZTpcInZhbHVlXCIsdHlwZTpcIm51bWJlclwifSx7dGZQYXJhbU5hbWU6XCJUXCIsZGxQYXJhbU5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwifV19LHt0Zk9wTmFtZTpcIkxpblNwYWNlXCIsZGxPcE5hbWU6XCJsaW5zcGFjZVwiLGNhdGVnb3J5OlwiY3JlYXRpb25cIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInN0YXJ0XCIsdHlwZTpcIm51bWJlclwifSx7dGZJbnB1dEluZGV4OjEsZGxQYXJhbU5hbWU6XCJzdG9wXCIsdHlwZTpcIm51bWJlclwifSx7dGZJbnB1dEluZGV4OjIsZGxQYXJhbU5hbWU6XCJudW1cIix0eXBlOlwibnVtYmVyXCJ9LHt0ZlBhcmFtTmFtZTpcIlRcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIk9uZUhvdFwiLGRsT3BOYW1lOlwib25lSG90XCIsY2F0ZWdvcnk6XCJjcmVhdGlvblwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwiaW5kaWNlc1wiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDoxLGRsUGFyYW1OYW1lOlwiZGVwdGhcIix0eXBlOlwibnVtYmVyXCJ9LHt0ZklucHV0SW5kZXg6MixkbFBhcmFtTmFtZTpcIm9uVmFsdWVcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjF9LHt0ZklucHV0SW5kZXg6MyxkbFBhcmFtTmFtZTpcIm9mZlZhbHVlXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowfSx7dGZQYXJhbU5hbWU6XCJheGlzXCIsZGxQYXJhbU5hbWU6XCJheGlzXCIsdHlwZTpcIm51bWJlclwiLG5vdFN1cHBvcnRlZDohMH0se3RmUGFyYW1OYW1lOlwiVFwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiT25lc1wiLGRsT3BOYW1lOlwib25lc1wiLGNhdGVnb3J5OlwiY3JlYXRpb25cIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInNoYXBlXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0ZlBhcmFtTmFtZTpcIlRcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCJ9XX0se3RmT3BOYW1lOlwiT25lc0xpa2VcIixkbE9wTmFtZTpcIm9uZXNMaWtlXCIsY2F0ZWdvcnk6XCJjcmVhdGlvblwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmUGFyYW1OYW1lOlwiZHR5cGVcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCJ9XX0se3RmT3BOYW1lOlwiUmFuZG9tVW5pZm9ybVwiLGRsT3BOYW1lOlwicmFuZG9tVW5pZm9ybVwiLGNhdGVnb3J5OlwiY3JlYXRpb25cIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInNoYXBlXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0ZlBhcmFtTmFtZTpcIm1pbnZhbFwiLGRsUGFyYW1OYW1lOlwibWludmFsXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowfSx7dGZQYXJhbU5hbWU6XCJtYXh2YWxcIixkbFBhcmFtTmFtZTpcIm1heHZhbFwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MX0se3RmUGFyYW1OYW1lOlwiZHR5cGVcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCJ9LHt0ZlBhcmFtTmFtZTpcInNlZWRcIixkbFBhcmFtTmFtZTpcInNlZWRcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjB9LHt0ZlBhcmFtTmFtZTpcInNlZWQyXCIsZGxQYXJhbU5hbWU6XCJzZWVkMlwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MCxub3RTdXBwb3J0ZWQ6ITB9LHt0ZlBhcmFtTmFtZTpcIlRcIixkbFBhcmFtTmFtZTpcIlRcIix0eXBlOlwibnVtYmVyXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlJhbmdlXCIsZGxPcE5hbWU6XCJyYW5nZVwiLGNhdGVnb3J5OlwiY3JlYXRpb25cIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInN0YXJ0XCIsdHlwZTpcIm51bWJlclwifSx7dGZJbnB1dEluZGV4OjEsZGxQYXJhbU5hbWU6XCJzdG9wXCIsdHlwZTpcIm51bWJlclwifSx7dGZJbnB1dEluZGV4OjIsZGxQYXJhbU5hbWU6XCJzdGVwXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowfSx7dGZQYXJhbU5hbWU6XCJUaWR4XCIsZGxQYXJhbU5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwifV19LHt0Zk9wTmFtZTpcInRydW5jYXRlZE5vcm1hbFwiLGRsT3BOYW1lOlwidHJ1bmNhdGVkTm9ybWFsXCIsY2F0ZWdvcnk6XCJjcmVhdGlvblwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwic2hhcGVcIix0eXBlOlwibnVtYmVyW11cIn0se3RmUGFyYW1OYW1lOlwibWVhbnNcIixkbFBhcmFtTmFtZTpcIm1lYW5cIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjB9LHt0ZlBhcmFtTmFtZTpcInN0ZGRldlwiLGRsUGFyYW1OYW1lOlwic3RkRGV2XCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZToxfSx7dGZQYXJhbU5hbWU6XCJzZWVkXCIsZGxQYXJhbU5hbWU6XCJzZWVkXCIsdHlwZTpcIm51bWJlclwifSx7dGZQYXJhbU5hbWU6XCJzZWVkMlwiLGRsUGFyYW1OYW1lOlwic2VlZDJcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjAsbm90U3VwcG9ydGVkOiEwfSx7dGZQYXJhbU5hbWU6XCJkdHlwZVwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIn0se3RmUGFyYW1OYW1lOlwiVFwiLGRsUGFyYW1OYW1lOlwiVFwiLHR5cGU6XCJudW1iZXJcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiWmVyb3NcIixkbE9wTmFtZTpcInplcm9zXCIsY2F0ZWdvcnk6XCJjcmVhdGlvblwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwic2hhcGVcIix0eXBlOlwibnVtYmVyW11cIn0se3RmUGFyYW1OYW1lOlwiVFwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIn1dfSx7dGZPcE5hbWU6XCJaZXJvc0xpa2VcIixkbE9wTmFtZTpcInplcm9zTGlrZVwiLGNhdGVnb3J5OlwiY3JlYXRpb25cIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHt0ZlBhcmFtTmFtZTpcIlRcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCJ9XX1dLGNyZWF0aW9uPU9iamVjdC5mcmVlemUoe2pzb246anNvbiQ0fSksanNvbiQ1PVt7dGZPcE5hbWU6XCJOb25NYXhTdXBwcmVzc2lvblYyXCIsZGxPcE5hbWU6XCJub25NYXhTdXBwcmVzc2lvblwiLGNhdGVnb3J5OlwiZHluYW1pY1wiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwiYm94ZXNcIix0eXBlOlwidGVuc29yXCJ9LHt0ZklucHV0SW5kZXg6MSxkbFBhcmFtTmFtZTpcInNjb3Jlc1wiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDoyLGRsUGFyYW1OYW1lOlwibWF4T3V0cHV0U2l6ZVwiLHR5cGU6XCJudW1iZXJcIn0se3RmSW5wdXRJbmRleDozLGRsUGFyYW1OYW1lOlwiaW91VGhyZXNob2xkXCIsdHlwZTpcIm51bWJlclwifV19LHt0Zk9wTmFtZTpcIk5vbk1heFN1cHByZXNzaW9uVjNcIixkbE9wTmFtZTpcIm5vbk1heFN1cHByZXNzaW9uXCIsY2F0ZWdvcnk6XCJkeW5hbWljXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJib3hlc1wiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDoxLGRsUGFyYW1OYW1lOlwic2NvcmVzXCIsdHlwZTpcInRlbnNvclwifSx7dGZJbnB1dEluZGV4OjIsZGxQYXJhbU5hbWU6XCJtYXhPdXRwdXRTaXplXCIsdHlwZTpcIm51bWJlclwifSx7dGZJbnB1dEluZGV4OjMsZGxQYXJhbU5hbWU6XCJpb3VUaHJlc2hvbGRcIix0eXBlOlwibnVtYmVyXCJ9LHt0ZklucHV0SW5kZXg6NCxkbFBhcmFtTmFtZTpcInNjb3JlVGhyZXNob2xkXCIsdHlwZTpcIm51bWJlclwifV19LHt0Zk9wTmFtZTpcIldoZXJlXCIsZGxPcE5hbWU6XCJ3aGVyZUFzeW5jXCIsY2F0ZWdvcnk6XCJkeW5hbWljXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJjb25kaXRpb25cIix0eXBlOlwidGVuc29yXCJ9LHt0ZlBhcmFtTmFtZTpcIlRcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkxpc3REaWZmXCIsZGxPcE5hbWU6XCJzZXRkaWZmMWRBc3luY1wiLGNhdGVnb3J5OlwiZHluYW1pY1wiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDoxLGRsUGFyYW1OYW1lOlwieVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmUGFyYW1OYW1lOlwiVFwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX1dLGR5bmFtaWM9T2JqZWN0LmZyZWV6ZSh7anNvbjpqc29uJDV9KSxqc29uJDY9W3t0Zk9wTmFtZTpcIlRvcEtWMlwiLGRsT3BOYW1lOlwidG9wS1wiLGNhdGVnb3J5OlwiZXZhbHVhdGlvblwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDoxLGRsUGFyYW1OYW1lOlwia1wiLHR5cGU6XCJudW1iZXJcIn0se3RmUGFyYW1OYW1lOlwic29ydGVkXCIsZGxQYXJhbU5hbWU6XCJzb3J0ZWRcIix0eXBlOlwiYm9vbFwifV19XSxldmFsdWF0aW9uPU9iamVjdC5mcmVlemUoe2pzb246anNvbiQ2fSksanNvbiQ3PVt7dGZPcE5hbWU6XCJQbGFjZWhvbGRlcldpdGhEZWZhdWx0XCIsZGxPcE5hbWU6XCJwbGFjZWhvbGRlclwiLGNhdGVnb3J5OlwiZ3JhcGhcIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcImRlZmF1bHRcIix0eXBlOlwidGVuc29yXCJ9LHt0ZlBhcmFtTmFtZTpcInNoYXBlXCIsZGxQYXJhbU5hbWU6XCJzaGFwZVwiLHR5cGU6XCJzaGFwZVwifSx7dGZQYXJhbU5hbWU6XCJkdHlwZVwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIn1dfSx7dGZPcE5hbWU6XCJQbGFjZWhvbGRlclwiLGRsT3BOYW1lOlwicGxhY2Vob2xkZXJcIixjYXRlZ29yeTpcImdyYXBoXCIscGFyYW1zOlt7dGZQYXJhbU5hbWU6XCJzaGFwZVwiLGRsUGFyYW1OYW1lOlwic2hhcGVcIix0eXBlOlwic2hhcGVcIn0se3RmUGFyYW1OYW1lOlwiZHR5cGVcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCJ9XX0se3RmT3BOYW1lOlwiQ29uc3RcIixkbE9wTmFtZTpcImNvbnN0XCIsY2F0ZWdvcnk6XCJncmFwaFwifSx7dGZPcE5hbWU6XCJJZGVudGl0eVwiLGRsT3BOYW1lOlwiaWRlbnRpdHlcIixjYXRlZ29yeTpcImdyYXBoXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV19LHt0Zk9wTmFtZTpcIlNuYXBzaG90XCIsZGxPcE5hbWU6XCJzbmFwc2hvdFwiLGNhdGVnb3J5OlwiZ3JhcGhcIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XX0se3RmT3BOYW1lOlwiUmFua1wiLGRsT3BOYW1lOlwicmFua1wiLGNhdGVnb3J5OlwiZ3JhcGhcIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XX0se3RmT3BOYW1lOlwiU2l6ZVwiLGRsT3BOYW1lOlwic2l6ZVwiLGNhdGVnb3J5OlwiZ3JhcGhcIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XX0se3RmT3BOYW1lOlwiU2hhcGVcIixkbE9wTmFtZTpcInNoYXBlXCIsY2F0ZWdvcnk6XCJncmFwaFwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dfSx7dGZPcE5hbWU6XCJTaGFwZU5cIixkbE9wTmFtZTpcInNoYXBlTlwiLGNhdGVnb3J5OlwiZ3JhcGhcIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCx0ZklucHV0UGFyYW1MZW5ndGg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yc1wifV19LHt0Zk9wTmFtZTpcIlByaW50XCIsZGxPcE5hbWU6XCJwcmludFwiLGNhdGVnb3J5OlwiZ3JhcGhcIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHt0ZklucHV0SW5kZXg6MSx0ZklucHV0UGFyYW1MZW5ndGg6MSxkbFBhcmFtTmFtZTpcImRhdGFcIix0eXBlOlwidGVuc29yc1wifSx7dGZQYXJhbU5hbWU6XCJtZXNzYWdlXCIsZGxQYXJhbU5hbWU6XCJtZXNzYWdlXCIsdHlwZTpcInN0cmluZ1wifSx7dGZQYXJhbU5hbWU6XCJmaXJzdF9uXCIsZGxQYXJhbU5hbWU6XCJmaXJzdE5cIix0eXBlOlwibnVtYmVyXCIsbm90U3VwcHJ0ZWQ6ITB9LHt0ZlBhcmFtTmFtZTpcInN1bW1hcml6ZVwiLGRsUGFyYW1OYW1lOlwic3VtbWFyaXplXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTozfV19LHt0Zk9wTmFtZTpcIk5vT3BcIixkbE9wTmFtZTpcIm5vb3BcIixjYXRlZ29yeTpcImdyYXBoXCIscGFyYW1zOltdfSx7dGZPcE5hbWU6XCJTdG9wR3JhZGllbnRcIixkbE9wTmFtZTpcInN0b3BHcmFkaWVudFwiLGNhdGVnb3J5OlwiZ3JhcGhcIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XX0se3RmT3BOYW1lOlwiRmFrZVF1YW50V2l0aE1pbk1heFZhcnNcIixkbE9wTmFtZTpcImZha2VRdWFudFdpdGhNaW5NYXhWYXJzXCIsY2F0ZWdvcnk6XCJncmFwaFwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmUGFyYW1OYW1lOlwibWluXCIsZGxQYXJhbU5hbWU6XCJtaW5cIix0eXBlOlwibnVtYmVyXCJ9LHt0ZlBhcmFtTmFtZTpcIm1heFwiLGRsUGFyYW1OYW1lOlwibWF4XCIsdHlwZTpcIm51bWJlclwifV19XSxncmFwaD1PYmplY3QuZnJlZXplKHtqc29uOmpzb24kN30pLGpzb24kOD1be3RmT3BOYW1lOlwiUmVzaXplQmlsaW5lYXJcIixkbE9wTmFtZTpcInJlc2l6ZUJpbGluZWFyXCIsY2F0ZWdvcnk6XCJpbWFnZVwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwiaW1hZ2VzXCIsdHlwZTpcInRlbnNvclwifSx7dGZJbnB1dEluZGV4OjEsZGxQYXJhbU5hbWU6XCJzaXplXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0ZlBhcmFtTmFtZTpcImFsaWduX2Nvcm5lcnNcIixkbFBhcmFtTmFtZTpcImFsaWduQ29ybmVyc1wiLHR5cGU6XCJib29sXCJ9LHt0ZlBhcmFtTmFtZTpcIlRcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlJlc2l6ZU5lYXJlc3ROZWlnaGJvclwiLGRsT3BOYW1lOlwicmVzaXplTmVhcmVzdE5laWdoYm9yXCIsY2F0ZWdvcnk6XCJpbWFnZVwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwiaW1hZ2VzXCIsdHlwZTpcInRlbnNvclwifSx7dGZJbnB1dEluZGV4OjEsZGxQYXJhbU5hbWU6XCJzaXplXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0ZlBhcmFtTmFtZTpcImFsaWduX2Nvcm5lcnNcIixkbFBhcmFtTmFtZTpcImFsaWduQ29ybmVyc1wiLHR5cGU6XCJib29sXCJ9LHt0ZlBhcmFtTmFtZTpcIlRcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkNyb3BBbmRSZXNpemVcIixkbE9wTmFtZTpcImNyb3BBbmRSZXNpemVcIixjYXRlZ29yeTpcImltYWdlXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJpbWFnZVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDoxLGRsUGFyYW1OYW1lOlwiYm94ZXNcIix0eXBlOlwidGVuc29yXCJ9LHt0ZklucHV0SW5kZXg6MixkbFBhcmFtTmFtZTpcImJveEluZFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDozLGRsUGFyYW1OYW1lOlwiY3JvcFNpemVcIix0eXBlOlwibnVtYmVyW11cIn0se3RmUGFyYW1OYW1lOlwibWV0aG9kXCIsZGxQYXJhbU5hbWU6XCJtZXRob2RcIix0eXBlOlwic3RyaW5nXCJ9LHt0ZlBhcmFtTmFtZTpcImV4dHJhcG9sYXRpb25fdmFsdWVcIixkbFBhcmFtTmFtZTpcImV4dHJhcG9sYXRpb25WYWx1ZVwiLHR5cGU6XCJudW1iZXJcIn1dfV0saW1hZ2UkMT1PYmplY3QuZnJlZXplKHtqc29uOmpzb24kOH0pLGpzb24kOT1be3RmT3BOYW1lOlwiRXF1YWxcIixkbE9wTmFtZTpcImVxdWFsXCIsY2F0ZWdvcnk6XCJsb2dpY2FsXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7dGZJbnB1dEluZGV4OjEsZGxQYXJhbU5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifSx7dGZQYXJhbU5hbWU6XCJUXCIsZGxQYXJhbU5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJOb3RFcXVhbFwiLGRsT3BOYW1lOlwibm90RXF1YWxcIixjYXRlZ29yeTpcImxvZ2ljYWxcIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHt0ZklucHV0SW5kZXg6MSxkbFBhcmFtTmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9LHt0ZlBhcmFtTmFtZTpcIlRcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkdyZWF0ZXJcIixkbE9wTmFtZTpcImdyZWF0ZXJcIixjYXRlZ29yeTpcImxvZ2ljYWxcIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHt0ZklucHV0SW5kZXg6MSxkbFBhcmFtTmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9LHt0ZlBhcmFtTmFtZTpcIlRcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkdyZWF0ZXJFcXVhbFwiLGRsT3BOYW1lOlwiZ3JlYXRlckVxdWFsXCIsY2F0ZWdvcnk6XCJsb2dpY2FsXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7dGZJbnB1dEluZGV4OjEsZGxQYXJhbU5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifSx7dGZQYXJhbU5hbWU6XCJUXCIsZGxQYXJhbU5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJMZXNzXCIsZGxPcE5hbWU6XCJsZXNzXCIsY2F0ZWdvcnk6XCJsb2dpY2FsXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7dGZJbnB1dEluZGV4OjEsZGxQYXJhbU5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifSx7dGZQYXJhbU5hbWU6XCJUXCIsZGxQYXJhbU5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJMZXNzRXF1YWxcIixkbE9wTmFtZTpcImxlc3NFcXVhbFwiLGNhdGVnb3J5OlwibG9naWNhbFwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDoxLGRsUGFyYW1OYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmUGFyYW1OYW1lOlwiVFwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiTG9naWNhbEFuZFwiLGRsT3BOYW1lOlwibG9naWNhbEFuZFwiLGNhdGVnb3J5OlwibG9naWNhbFwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDoxLGRsUGFyYW1OYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmUGFyYW1OYW1lOlwiVFwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiTG9naWNhbE5vdFwiLGRsT3BOYW1lOlwibG9naWNhbE5vdFwiLGNhdGVnb3J5OlwibG9naWNhbFwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmUGFyYW1OYW1lOlwiVFwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiTG9naWNhbE9yXCIsZGxPcE5hbWU6XCJsb2dpY2FsT3JcIixjYXRlZ29yeTpcImxvZ2ljYWxcIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHt0ZklucHV0SW5kZXg6MSxkbFBhcmFtTmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9LHt0ZlBhcmFtTmFtZTpcIlRcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlNlbGVjdFwiLGRsT3BOYW1lOlwid2hlcmVcIixjYXRlZ29yeTpcImxvZ2ljYWxcIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcImNvbmRpdGlvblwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDoxLGRsUGFyYW1OYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDoyLGRsUGFyYW1OYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmUGFyYW1OYW1lOlwiVFwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX1dLGxvZ2ljYWw9T2JqZWN0LmZyZWV6ZSh7anNvbjpqc29uJDl9KSxqc29uJDEwPVt7dGZPcE5hbWU6XCJNYXRNdWxcIixkbE9wTmFtZTpcIm1hdE11bFwiLGNhdGVnb3J5OlwibWF0cmljZXNcIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHt0ZklucHV0SW5kZXg6MSxkbFBhcmFtTmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9LHt0ZlBhcmFtTmFtZTpcInRyYW5zcG9zZV9hXCIsZGxQYXJhbU5hbWU6XCJ0cmFuc3Bvc2VBXCIsdHlwZTpcImJvb2xcIixkZWZhdWx0VmFsdWU6ITF9LHt0ZlBhcmFtTmFtZTpcInRyYW5zcG9zZV9iXCIsZGxQYXJhbU5hbWU6XCJ0cmFuc3Bvc2VCXCIsdHlwZTpcImJvb2xcIixkZWZhdWx0VmFsdWU6ITF9LHt0ZlBhcmFtTmFtZTpcIlRcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkJhdGNoTWF0TXVsXCIsZGxPcE5hbWU6XCJtYXRNdWxcIixjYXRlZ29yeTpcIm1hdHJpY2VzXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7dGZJbnB1dEluZGV4OjEsZGxQYXJhbU5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifSx7dGZQYXJhbU5hbWU6XCJhZGpfeFwiLGRsUGFyYW1OYW1lOlwidHJhbnNwb3NlQVwiLHR5cGU6XCJib29sXCIsZGVmYXVsdFZhbHVlOiExfSx7dGZQYXJhbU5hbWU6XCJhZGpfeVwiLGRsUGFyYW1OYW1lOlwidHJhbnNwb3NlQlwiLHR5cGU6XCJib29sXCIsZGVmYXVsdFZhbHVlOiExfSx7dGZQYXJhbU5hbWU6XCJUXCIsZGxQYXJhbU5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJUcmFuc3Bvc2VcIixkbE9wTmFtZTpcInRyYW5zcG9zZVwiLGNhdGVnb3J5OlwibWF0cmljZXNcIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHt0ZklucHV0SW5kZXg6MSxkbFBhcmFtTmFtZTpcInBlcm1cIix0eXBlOlwibnVtYmVyW11cIn0se3RmUGFyYW1OYW1lOlwiVFwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX1dLG1hdHJpY2VzPU9iamVjdC5mcmVlemUoe2pzb246anNvbiQxMH0pLGpzb24kMTE9W3t0Zk9wTmFtZTpcIkZ1c2VkQmF0Y2hOb3JtXCIsZGxPcE5hbWU6XCJiYXRjaE5vcm1hbGl6YXRpb25cIixjYXRlZ29yeTpcIm5vcm1hbGl6YXRpb25cIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHt0ZklucHV0SW5kZXg6MSxkbFBhcmFtTmFtZTpcInNjYWxlXCIsdHlwZTpcInRlbnNvclwifSx7dGZJbnB1dEluZGV4OjIsZGxQYXJhbU5hbWU6XCJvZmZzZXRcIix0eXBlOlwidGVuc29yXCJ9LHt0ZklucHV0SW5kZXg6MyxkbFBhcmFtTmFtZTpcIm1lYW5cIix0eXBlOlwidGVuc29yXCJ9LHt0ZklucHV0SW5kZXg6NCxkbFBhcmFtTmFtZTpcInZhcmlhbmNlXCIsdHlwZTpcInRlbnNvclwifSx7dGZQYXJhbU5hbWU6XCJlcHNpbG9uXCIsZGxQYXJhbU5hbWU6XCJlcHNpbG9uXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTouMDAxfSx7dGZQYXJhbU5hbWU6XCJkYXRhX2Zvcm1hdFwiLGRsUGFyYW1OYW1lOlwiZGF0YUZvcm1hdFwiLHR5cGU6XCJzdHJpbmdcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiRnVzZWRCYXRjaE5vcm1WMlwiLGRsT3BOYW1lOlwiYmF0Y2hOb3JtYWxpemF0aW9uXCIsY2F0ZWdvcnk6XCJub3JtYWxpemF0aW9uXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7dGZJbnB1dEluZGV4OjEsZGxQYXJhbU5hbWU6XCJzY2FsZVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDoyLGRsUGFyYW1OYW1lOlwib2Zmc2V0XCIsdHlwZTpcInRlbnNvclwifSx7dGZJbnB1dEluZGV4OjMsZGxQYXJhbU5hbWU6XCJtZWFuXCIsdHlwZTpcInRlbnNvclwifSx7dGZJbnB1dEluZGV4OjQsZGxQYXJhbU5hbWU6XCJ2YXJpYW5jZVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmUGFyYW1OYW1lOlwiZXBzaWxvblwiLGRsUGFyYW1OYW1lOlwiZXBzaWxvblwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6LjAwMX0se3RmUGFyYW1OYW1lOlwiZGF0YV9mb3JtYXRcIixkbFBhcmFtTmFtZTpcImRhdGFGb3JtYXRcIix0eXBlOlwic3RyaW5nXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkxSTlwiLGRsT3BOYW1lOlwibG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb25cIixjYXRlZ29yeTpcIm5vcm1hbGl6YXRpb25cIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHt0ZlBhcmFtTmFtZTpcImRlcHRoX3JhZGl1c1wiLGRsUGFyYW1OYW1lOlwicmFkaXVzXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTo1fSx7dGZQYXJhbU5hbWU6XCJiaWFzXCIsZGxQYXJhbU5hbWU6XCJiaWFzXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZToxfSx7dGZQYXJhbU5hbWU6XCJhbHBoYVwiLGRsUGFyYW1OYW1lOlwiYWxwaGFcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjF9LHt0ZlBhcmFtTmFtZTpcImJldGFcIixkbFBhcmFtTmFtZTpcImJldGFcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOi41fV19LHt0Zk9wTmFtZTpcIlNvZnRtYXhcIixkbE9wTmFtZTpcInNvZnRtYXhcIixjYXRlZ29yeTpcIm5vcm1hbGl6YXRpb25cIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XX0se3RmT3BOYW1lOlwiTG9nU29mdG1heFwiLGRsT3BOYW1lOlwibG9nU29mdG1heFwiLGNhdGVnb3J5Olwibm9ybWFsaXphdGlvblwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dfSx7dGZPcE5hbWU6XCJTcGFyc2VUb0RlbnNlXCIsZGxPcE5hbWU6XCJzcGFyc2VUb0RlbnNlXCIsY2F0ZWdvcnk6XCJub3JtYWxpemF0aW9uXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJzcGFyc2VJbmRpY2VzXCIsdHlwZTpcInRlbnNvclwifSx7dGZJbnB1dEluZGV4OjEsZGxQYXJhbU5hbWU6XCJvdXRwdXRTaGFwZVwiLHR5cGU6XCJudW1iZXJbXVwifSx7dGZJbnB1dEluZGV4OjIsZGxQYXJhbU5hbWU6XCJzcGFyc2VWYWx1ZXNcIix0eXBlOlwidGVuc29yXCJ9LHt0ZklucHV0SW5kZXg6MyxkbFBhcmFtTmFtZTpcImRlZmF1bHRWYWx1ZVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmUGFyYW1OYW1lOlwidmFsaWRhdGVfaW5kaWNlc1wiLGRsUGFyYW1OYW1lOlwidmFsaWRhdGVJbmRpY2VzXCIsdHlwZTpcImJvb2xcIixkZWZhdWx0VmFsdWU6ITAsbm90U3VwcG9ydGVkOiEwfV19XSxub3JtYWxpemF0aW9uPU9iamVjdC5mcmVlemUoe2pzb246anNvbiQxMX0pLGpzb24kMTI9W3t0Zk9wTmFtZTpcIk1heFwiLGRsT3BOYW1lOlwibWF4XCIsY2F0ZWdvcnk6XCJyZWR1Y3Rpb25cIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHt0ZklucHV0SW5kZXg6MSxkbFBhcmFtTmFtZTpcImF4aXNcIix0eXBlOlwibnVtYmVyW11cIn0se3RmUGFyYW1OYW1lOlwia2VlcF9kaW1zXCIsZGxQYXJhbU5hbWU6XCJrZWVwRGltc1wiLHR5cGU6XCJib29sXCJ9XX0se3RmT3BOYW1lOlwiTWVhblwiLGRsT3BOYW1lOlwibWVhblwiLGNhdGVnb3J5OlwicmVkdWN0aW9uXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7dGZJbnB1dEluZGV4OjEsZGxQYXJhbU5hbWU6XCJheGlzXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0ZlBhcmFtTmFtZTpcImtlZXBfZGltc1wiLGRsUGFyYW1OYW1lOlwia2VlcERpbXNcIix0eXBlOlwiYm9vbFwifV19LHt0Zk9wTmFtZTpcIk1pblwiLGRsT3BOYW1lOlwibWluXCIsY2F0ZWdvcnk6XCJyZWR1Y3Rpb25cIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHt0ZklucHV0SW5kZXg6MSxkbFBhcmFtTmFtZTpcImF4aXNcIix0eXBlOlwibnVtYmVyW11cIn0se3RmUGFyYW1OYW1lOlwia2VlcF9kaW1zXCIsZGxQYXJhbU5hbWU6XCJrZWVwRGltc1wiLHR5cGU6XCJib29sXCJ9XX0se3RmT3BOYW1lOlwiU3VtXCIsZGxPcE5hbWU6XCJzdW1cIixjYXRlZ29yeTpcInJlZHVjdGlvblwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDoxLGRsUGFyYW1OYW1lOlwiYXhpc1wiLHR5cGU6XCJudW1iZXJbXVwifSx7dGZQYXJhbU5hbWU6XCJrZWVwX2RpbXNcIixkbFBhcmFtTmFtZTpcImtlZXBEaW1zXCIsdHlwZTpcImJvb2xcIn1dfSx7dGZPcE5hbWU6XCJBbGxcIixkbE9wTmFtZTpcImFsbFwiLGNhdGVnb3J5OlwicmVkdWN0aW9uXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7dGZJbnB1dEluZGV4OjEsZGxQYXJhbU5hbWU6XCJheGlzXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0ZlBhcmFtTmFtZTpcImtlZXBfZGltc1wiLGRsUGFyYW1OYW1lOlwia2VlcERpbXNcIix0eXBlOlwiYm9vbFwifV19LHt0Zk9wTmFtZTpcIkFueVwiLGRsT3BOYW1lOlwiYW55XCIsY2F0ZWdvcnk6XCJyZWR1Y3Rpb25cIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHt0ZklucHV0SW5kZXg6MSxkbFBhcmFtTmFtZTpcImF4aXNcIix0eXBlOlwibnVtYmVyW11cIn0se3RmUGFyYW1OYW1lOlwia2VlcF9kaW1zXCIsZGxQYXJhbU5hbWU6XCJrZWVwRGltc1wiLHR5cGU6XCJib29sXCJ9XX0se3RmT3BOYW1lOlwiQXJnTWF4XCIsZGxPcE5hbWU6XCJhcmdNYXhcIixjYXRlZ29yeTpcInJlZHVjdGlvblwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDoxLGRsUGFyYW1OYW1lOlwiYXhpc1wiLHR5cGU6XCJudW1iZXJcIn1dfSx7dGZPcE5hbWU6XCJBcmdNaW5cIixkbE9wTmFtZTpcImFyZ01pblwiLGNhdGVnb3J5OlwicmVkdWN0aW9uXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7dGZJbnB1dEluZGV4OjEsZGxQYXJhbU5hbWU6XCJheGlzXCIsdHlwZTpcIm51bWJlclwifV19LHt0Zk9wTmFtZTpcIlByb2RcIixkbE9wTmFtZTpcInByb2RcIixjYXRlZ29yeTpcInJlZHVjdGlvblwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDoxLGRsUGFyYW1OYW1lOlwiYXhpc1wiLHR5cGU6XCJudW1iZXJbXVwifSx7dGZQYXJhbU5hbWU6XCJrZWVwX2RpbXNcIixkbFBhcmFtTmFtZTpcImtlZXBEaW1zXCIsdHlwZTpcImJvb2xcIn1dfV0scmVkdWN0aW9uPU9iamVjdC5mcmVlemUoe2pzb246anNvbiQxMn0pLGpzb24kMTM9W3t0Zk9wTmFtZTpcIkNvbmNhdFYyXCIsZGxPcE5hbWU6XCJjb25jYXRcIixjYXRlZ29yeTpcInNsaWNlX2pvaW5cIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCx0ZklucHV0UGFyYW1MZW5ndGg6MSxkbFBhcmFtTmFtZTpcInRlbnNvcnNcIix0eXBlOlwidGVuc29yc1wifSx7dGZJbnB1dEluZGV4Oi0xLGRsUGFyYW1OYW1lOlwiYXhpc1wiLHR5cGU6XCJudW1iZXJcIn1dfSx7dGZPcE5hbWU6XCJDb25jYXRcIixkbE9wTmFtZTpcImNvbmNhdFwiLGNhdGVnb3J5Olwic2xpY2Vfam9pblwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDoxLHRmSW5wdXRQYXJhbUxlbmd0aDoxLGRsUGFyYW1OYW1lOlwidGVuc29yc1wiLHR5cGU6XCJ0ZW5zb3JzXCJ9LHt0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcImF4aXNcIix0eXBlOlwibnVtYmVyXCJ9XX0se3RmT3BOYW1lOlwiR2F0aGVyVjJcIixkbE9wTmFtZTpcImdhdGhlclwiLGNhdGVnb3J5Olwic2xpY2Vfam9pblwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDoxLGRsUGFyYW1OYW1lOlwiaW5kaWNlc1wiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDoyLGRsUGFyYW1OYW1lOlwiYXhpc1wiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MH1dfSx7dGZPcE5hbWU6XCJHYXRoZXJcIixkbE9wTmFtZTpcImdhdGhlclwiLGNhdGVnb3J5Olwic2xpY2Vfam9pblwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDoxLGRsUGFyYW1OYW1lOlwiaW5kaWNlc1wiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmUGFyYW1OYW1lOlwiYXhpc1wiLGRsUGFyYW1OYW1lOlwiYXhpc1wiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MH0se3RmUGFyYW1OYW1lOlwidmFsaWRhdGVfaW5kaWNlc1wiLGRsUGFyYW1OYW1lOlwidmFsaWRhdGVJbmRpY2VzXCIsdHlwZTpcImJvb2xcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiUmV2ZXJzZVwiLGRsT3BOYW1lOlwicmV2ZXJzZVwiLGNhdGVnb3J5Olwic2xpY2Vfam9pblwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDoxLGRsUGFyYW1OYW1lOlwiZGltc1wiLHR5cGU6XCJib29sXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlJldmVyc2VWMlwiLGRsT3BOYW1lOlwicmV2ZXJzZVwiLGNhdGVnb3J5Olwic2xpY2Vfam9pblwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDoxLGRsUGFyYW1OYW1lOlwiYXhpc1wiLHR5cGU6XCJudW1iZXJbXVwifV19LHt0Zk9wTmFtZTpcIlNsaWNlXCIsZGxPcE5hbWU6XCJzbGljZVwiLGNhdGVnb3J5Olwic2xpY2Vfam9pblwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDoxLGRsUGFyYW1OYW1lOlwiYmVnaW5cIix0eXBlOlwibnVtYmVyW11cIn0se3RmSW5wdXRJbmRleDoyLGRsUGFyYW1OYW1lOlwic2l6ZVwiLHR5cGU6XCJudW1iZXJbXVwifV19LHt0Zk9wTmFtZTpcIlN0cmlkZWRTbGljZVwiLGRsT3BOYW1lOlwic3RyaWRlZFNsaWNlXCIsY2F0ZWdvcnk6XCJzbGljZV9qb2luXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7dGZJbnB1dEluZGV4OjEsZGxQYXJhbU5hbWU6XCJiZWdpblwiLHR5cGU6XCJudW1iZXJbXVwifSx7dGZJbnB1dEluZGV4OjIsZGxQYXJhbU5hbWU6XCJlbmRcIix0eXBlOlwibnVtYmVyW11cIn0se3RmSW5wdXRJbmRleDozLGRsUGFyYW1OYW1lOlwic3RyaWRlc1wiLHR5cGU6XCJudW1iZXJbXVwifSx7dGZQYXJhbU5hbWU6XCJiZWdpbl9tYXNrXCIsZGxQYXJhbU5hbWU6XCJiZWdpbk1hc2tcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjB9LHt0ZlBhcmFtTmFtZTpcImVuZF9tYXNrXCIsZGxQYXJhbU5hbWU6XCJlbmRNYXNrXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowfSx7dGZQYXJhbU5hbWU6XCJuZXdfYXhpc19tYXNrXCIsZGxQYXJhbU5hbWU6XCJuZXdBeGlzTWFza1wiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MH0se3RmUGFyYW1OYW1lOlwiZWxsaXBzaXNfbWFza1wiLGRsUGFyYW1OYW1lOlwiZWxsaXBzaXNNYXNrXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowfSx7dGZQYXJhbU5hbWU6XCJzaHJpbmtfYXhpc19tYXNrXCIsZGxQYXJhbU5hbWU6XCJzaHJpbmtBeGlzTWFza1wiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MH1dfSx7dGZPcE5hbWU6XCJQYWNrXCIsZGxPcE5hbWU6XCJzdGFja1wiLGNhdGVnb3J5Olwic2xpY2Vfam9pblwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLHRmSW5wdXRQYXJhbUxlbmd0aDowLGRsUGFyYW1OYW1lOlwidGVuc29yc1wiLHR5cGU6XCJ0ZW5zb3JzXCJ9LHt0ZlBhcmFtTmFtZTpcImF4aXNcIixkbFBhcmFtTmFtZTpcImF4aXNcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjB9XX0se3RmT3BOYW1lOlwiVW5wYWNrXCIsZGxPcE5hbWU6XCJ1bnN0YWNrXCIsY2F0ZWdvcnk6XCJzbGljZV9qb2luXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsdGZJbnB1dFBhcmFtTGVuZ3RoOjAsZGxQYXJhbU5hbWU6XCJ0ZW5zb3JcIix0eXBlOlwidGVuc29yXCJ9LHt0ZlBhcmFtTmFtZTpcImF4aXNcIixkbFBhcmFtTmFtZTpcImF4aXNcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjB9LHt0ZlBhcmFtTmFtZTpcIm51bVwiLGRsUGFyYW1OYW1lOlwibnVtXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJUaWxlXCIsZGxPcE5hbWU6XCJ0aWxlXCIsY2F0ZWdvcnk6XCJzbGljZV9qb2luXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7dGZJbnB1dEluZGV4OjEsZGxQYXJhbU5hbWU6XCJyZXBzXCIsdHlwZTpcIm51bWJlcltdXCJ9XX0se3RmT3BOYW1lOlwiU3BsaXRcIixkbE9wTmFtZTpcInNwbGl0XCIsY2F0ZWdvcnk6XCJzbGljZV9qb2luXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJheGlzXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowfSx7dGZJbnB1dEluZGV4OjEsZGxQYXJhbU5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7dGZQYXJhbU5hbWU6XCJudW1fc3BsaXRcIixkbFBhcmFtTmFtZTpcIm51bU9yU2l6ZVNwbGl0c1wiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MX1dfSx7dGZPcE5hbWU6XCJTcGxpdFZcIixkbE9wTmFtZTpcInNwbGl0XCIsY2F0ZWdvcnk6XCJzbGljZV9qb2luXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7dGZJbnB1dEluZGV4OjEsZGxQYXJhbU5hbWU6XCJudW1PclNpemVTcGxpdHNcIix0eXBlOlwibnVtYmVyW11cIn0se3RmSW5wdXRJbmRleDoyLGRsUGFyYW1OYW1lOlwiYXhpc1wiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MH1dfSx7dGZPcE5hbWU6XCJTY2F0dGVyTmRcIixkbE9wTmFtZTpcInNjYXR0ZXJOZFwiLGNhdGVnb3J5Olwic2xpY2Vfam9pblwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwiaW5kaWNlc1wiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDoxLGRsUGFyYW1OYW1lOlwidmFsdWVzXCIsdHlwZTpcInRlbnNvclwifSx7dGZJbnB1dEluZGV4OjIsZGxQYXJhbU5hbWU6XCJzaGFwZVwiLHR5cGU6XCJudW1iZXJbXVwifV19LHt0Zk9wTmFtZTpcIkdhdGhlck5kXCIsZGxPcE5hbWU6XCJnYXRoZXJOZFwiLGNhdGVnb3J5Olwic2xpY2Vfam9pblwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDoxLGRsUGFyYW1OYW1lOlwiaW5kaWNlc1wiLHR5cGU6XCJ0ZW5zb3JcIn1dfSx7dGZPcE5hbWU6XCJTcGFyc2VUb0RlbnNlXCIsZGxPcE5hbWU6XCJzcGFyc2VUb0RlbnNlXCIsY2F0ZWdvcnk6XCJzbGljZV9qb2luXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJzcGFyc2VJbmRpY2VzXCIsdHlwZTpcInRlbnNvclwifSx7dGZJbnB1dEluZGV4OjEsZGxQYXJhbU5hbWU6XCJvdXRwdXRTaGFwZVwiLHR5cGU6XCJudW1iZXJbXVwifSx7dGZJbnB1dEluZGV4OjIsZGxQYXJhbU5hbWU6XCJzcGFyc2VWYWx1ZXNcIix0eXBlOlwidGVuc29yXCJ9LHt0ZklucHV0SW5kZXg6MyxkbFBhcmFtTmFtZTpcImRlZmF1bHRWYWx1ZVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmUGFyYW1OYW1lOlwidmFsaWRhdGVfaW5kaWNlc1wiLGRsUGFyYW1OYW1lOlwidmFsaWRhdGVJbmRpY2VzXCIsdHlwZTpcImJvb2xcIixkZWZhdWx0VmFsdWU6ITEsbm90U3VwcG9ydGVkOiEwfV19XSxzbGljZUpvaW49T2JqZWN0LmZyZWV6ZSh7anNvbjpqc29uJDEzfSksanNvbiQxND1be3RmT3BOYW1lOlwiQ2FzdFwiLGRsT3BOYW1lOlwiY2FzdFwiLGNhdGVnb3J5OlwidHJhbnNmb3JtYXRpb25cIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHt0ZlBhcmFtTmFtZTpcIlNyY1RcIixkbFBhcmFtTmFtZTpcInNkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH0se3RmUGFyYW1OYW1lOlwiRHN0VFwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIn1dfSx7dGZPcE5hbWU6XCJFeHBhbmREaW1zXCIsZGxPcE5hbWU6XCJleHBhbmREaW1zXCIsY2F0ZWdvcnk6XCJ0cmFuc2Zvcm1hdGlvblwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDoxLHRmUGFyYW1OYW1lRGVwcmVjYXRlZDpcImRpbVwiLGRsUGFyYW1OYW1lOlwiYXhpc1wiLHR5cGU6XCJudW1iZXJcIn1dfSx7dGZPcE5hbWU6XCJQYWRcIixkbE9wTmFtZTpcInBhZFwiLGNhdGVnb3J5OlwidHJhbnNmb3JtYXRpb25cIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHt0ZklucHV0SW5kZXg6MSxkbFBhcmFtTmFtZTpcInBhZGRpbmdcIix0eXBlOlwibnVtYmVyW11cIn0se3RmUGFyYW1OYW1lOlwiY29uc3RhbnRfdmFsdWVcIixkbFBhcmFtTmFtZTpcImNvbnN0YW50VmFsdWVcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjB9XX0se3RmT3BOYW1lOlwiUGFkVjJcIixkbE9wTmFtZTpcInBhZFwiLGNhdGVnb3J5OlwidHJhbnNmb3JtYXRpb25cIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHt0ZklucHV0SW5kZXg6MSxkbFBhcmFtTmFtZTpcInBhZGRpbmdcIix0eXBlOlwibnVtYmVyW11cIn0se3RmSW5wdXRJbmRleDoyLGRsUGFyYW1OYW1lOlwiY29uc3RhbnRWYWx1ZVwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MH1dfSx7dGZPcE5hbWU6XCJSZXNoYXBlXCIsZGxPcE5hbWU6XCJyZXNoYXBlXCIsY2F0ZWdvcnk6XCJ0cmFuc2Zvcm1hdGlvblwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDoxLGRsUGFyYW1OYW1lOlwic2hhcGVcIix0eXBlOlwibnVtYmVyW11cIn1dfSx7dGZPcE5hbWU6XCJTcXVlZXplXCIsZGxPcE5hbWU6XCJzcXVlZXplXCIsY2F0ZWdvcnk6XCJ0cmFuc2Zvcm1hdGlvblwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmUGFyYW1OYW1lOlwiYXhpc1wiLHRmUGFyYW1OYW1lRGVwcmVjYXRlZDpcInNxdWVlemVfZGltc1wiLGRsUGFyYW1OYW1lOlwiYXhpc1wiLHR5cGU6XCJudW1iZXJbXVwifV19LHt0Zk9wTmFtZTpcIlNwYWNlVG9CYXRjaE5EXCIsZGxPcE5hbWU6XCJzcGFjZVRvQmF0Y2hORFwiLGNhdGVnb3J5OlwidHJhbnNmb3JtYXRpb25cIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHt0ZklucHV0SW5kZXg6MSxkbFBhcmFtTmFtZTpcImJsb2NrU2hhcGVcIix0eXBlOlwibnVtYmVyW11cIn0se3RmSW5wdXRJbmRleDoyLGRsUGFyYW1OYW1lOlwicGFkZGluZ3NcIix0eXBlOlwibnVtYmVyW11cIn1dfSx7dGZPcE5hbWU6XCJCYXRjaFRvU3BhY2VORFwiLGRsT3BOYW1lOlwiYmF0Y2hUb1NwYWNlTkRcIixjYXRlZ29yeTpcInRyYW5zZm9ybWF0aW9uXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7dGZJbnB1dEluZGV4OjEsZGxQYXJhbU5hbWU6XCJibG9ja1NoYXBlXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0ZklucHV0SW5kZXg6MixkbFBhcmFtTmFtZTpcImNyb3BzXCIsdHlwZTpcIm51bWJlcltdXCJ9XX0se3RmT3BOYW1lOlwiRGVwdGhUb1NwYWNlXCIsZGxPcE5hbWU6XCJkZXB0aFRvU3BhY2VcIixjYXRlZ29yeTpcInRyYW5zZm9ybWF0aW9uXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7dGZQYXJhbU5hbWU6XCJibG9ja19zaXplXCIsZGxQYXJhbU5hbWU6XCJibG9ja1NpemVcIix0eXBlOlwibnVtYmVyXCJ9LHt0ZlBhcmFtTmFtZTpcImRhdGFfZm9ybWF0XCIsZGxQYXJhbU5hbWU6XCJkYXRhRm9ybWF0XCIsdHlwZTpcInN0cmluZ1wifV19XSx0cmFuc2Zvcm1hdGlvbj1PYmplY3QuZnJlZXplKHtqc29uOmpzb24kMTR9KSxDT05UUk9MX0ZMT1dfT1BTPVtcIlN3aXRjaFwiLFwiTWVyZ2VcIixcIkVudGVyXCIsXCJFeGl0XCIsXCJOZXh0SXRlcmF0aW9uXCJdLERZTkFNSUNfU0hBUEVfT1BTPVtcIk5vbk1heFN1cHByZXNzaW9uVjJcIixcIk5vbk1heFN1cHByZXNzaW9uVjNcIixcIldoZXJlXCJdLE9wZXJhdGlvbk1hcHBlcj1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXt2YXIgZT1bYXJpdGhtZXRpYyxiYXNpY01hdGgsY29udHJvbCxjb252b2x1dGlvbixjcmVhdGlvbixkeW5hbWljLGV2YWx1YXRpb24sbG9naWNhbCxpbWFnZSQxLGdyYXBoLG1hdHJpY2VzLG5vcm1hbGl6YXRpb24scmVkdWN0aW9uLHNsaWNlSm9pbix0cmFuc2Zvcm1hdGlvbl0sdD1bXS5jb25jYXQuYXBwbHkoW10sZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUuanNvbn0pKTt0aGlzLm9wTWFwcGVycz10LnJlZHVjZShmdW5jdGlvbihlLHQpe3JldHVybiBlW3QudGZPcE5hbWVdPXQsZX0se30pfXJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIkluc3RhbmNlXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9pbnN0YW5jZXx8KHRoaXMuX2luc3RhbmNlPW5ldyB0aGlzKX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxlLnByb3RvdHlwZS5pc0NvbnRyb2xGbG93PWZ1bmN0aW9uKGUpe3JldHVybiBDT05UUk9MX0ZMT1dfT1BTLnNvbWUoZnVuY3Rpb24odCl7cmV0dXJuIHQ9PT1lLm9wfSl9LGUucHJvdG90eXBlLmlzRHluYW1pY1NoYXBlPWZ1bmN0aW9uKGUpe3JldHVybiBEWU5BTUlDX1NIQVBFX09QUy5zb21lKGZ1bmN0aW9uKHQpe3JldHVybiB0PT09ZS5vcH0pfSxlLnByb3RvdHlwZS50cmFuc2Zvcm1HcmFwaD1mdW5jdGlvbihlKXt2YXIgdD10aGlzLGE9ITEscj0hMSxuPVtdLG89W10scz1lLm5vZGUucmVkdWNlKGZ1bmN0aW9uKGUscyl7cmV0dXJuIGVbcy5uYW1lXT10Lm1hcE5vZGUocyksdC5pc0NvbnRyb2xGbG93KHMpJiYoYT0hMCksdC5pc0R5bmFtaWNTaGFwZShzKSYmKHI9ITApLFwiUGxhY2Vob2xkZXJcIj09PXMub3AmJm4ucHVzaChlW3MubmFtZV0pLFwiQ29uc3RcIj09PXMub3AmJm8ucHVzaChlW3MubmFtZV0pLGV9LHt9KSxpPVtdLHA9W107cmV0dXJuIE9iamVjdC5rZXlzKHMpLmZvckVhY2goZnVuY3Rpb24oZSl7dmFyIHQ9c1tlXTt0LmlucHV0TmFtZXMuZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgYT1nZXROb2RlTmFtZUFuZEluZGV4KGUpWzBdO3QuaW5wdXRzLnB1c2goc1thXSksc1thXS5jaGlsZHJlbi5wdXNoKHQpfSksMD09PXQuaW5wdXRzLmxlbmd0aCYmaS5wdXNoKHQpfSksT2JqZWN0LmtleXMocykuZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgdD1zW2VdOzA9PT10LmNoaWxkcmVuLmxlbmd0aCYmcC5wdXNoKHQpfSkse25vZGVzOnMsaW5wdXRzOmksb3V0cHV0czpwLHdlaWdodHM6byxwbGFjZWhvbGRlcnM6bix3aXRoQ29udHJvbEZsb3c6YSx3aXRoRHluYW1pY1NoYXBlOnJ9fSxlLnByb3RvdHlwZS5tYXBOb2RlPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMsYT10aGlzLm9wTWFwcGVyc1tlLm9wXTtpZih2b2lkIDA9PT1hKXRocm93IG5ldyBFcnJvcihcIlRlbnNvcmZsb3cgT3AgaXMgbm90IHN1cHBvcnRlZDogXCIrZS5vcCk7dmFyIHI9e25hbWU6ZS5uYW1lLG9wOmEuZGxPcE5hbWUsY2F0ZWdvcnk6YS5jYXRlZ29yeSxpbnB1dE5hbWVzOihlLmlucHV0fHxbXSkubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLnN0YXJ0c1dpdGgoXCJeXCIpP2Uuc3Vic3RyKDEpOmV9KSxpbnB1dHM6W10sY2hpbGRyZW46W10scGFyYW1zOnt9fTtyZXR1cm4gYS5wYXJhbXMmJihyLnBhcmFtcz1hLnBhcmFtcy5yZWR1Y2UoZnVuY3Rpb24oYSxyKXt2YXIgbj1yLnRmSW5wdXRJbmRleCxvPXIudGZJbnB1dFBhcmFtTGVuZ3RoLHM9ci50eXBlLGk9dm9pZCAwO2lmKHZvaWQgMD09PW4pc3dpdGNoKHIudHlwZSl7Y2FzZVwic3RyaW5nXCI6dm9pZCAwPT09KGk9dC5nZXRTdHJpbmdQYXJhbShlLmF0dHIsci50ZlBhcmFtTmFtZSxyLmRlZmF1bHRWYWx1ZSkpJiZyLnRmUGFyYW1OYW1lRGVwcmVjYXRlZCYmKGk9dC5nZXRTdHJpbmdQYXJhbShlLmF0dHIsci50ZlBhcmFtTmFtZURlcHJlY2F0ZWQsci5kZWZhdWx0VmFsdWUpKTticmVhaztjYXNlXCJudW1iZXJcIjp2b2lkIDA9PT0oaT10LmdldE51bWJlclBhcmFtKGUuYXR0cixyLnRmUGFyYW1OYW1lLHIuZGVmYXVsdFZhbHVlKSkmJnIudGZQYXJhbU5hbWVEZXByZWNhdGVkJiYoaT10LmdldE51bWJlclBhcmFtKGUuYXR0cixyLnRmUGFyYW1OYW1lRGVwcmVjYXRlZCxyLmRlZmF1bHRWYWx1ZSkpO2JyZWFrO2Nhc2VcIm51bWJlcltdXCI6dm9pZCAwPT09KGk9dC5nZXROdW1lcmljQXJyYXlQYXJhbShlLmF0dHIsci50ZlBhcmFtTmFtZSxyLmRlZmF1bHRWYWx1ZSkpJiZyLnRmUGFyYW1OYW1lRGVwcmVjYXRlZCYmKGk9dC5nZXROdW1lcmljQXJyYXlQYXJhbShlLmF0dHIsci50ZlBhcmFtTmFtZURlcHJlY2F0ZWQsci5kZWZhdWx0VmFsdWUpKTticmVhaztjYXNlXCJib29sXCI6dm9pZCAwPT09KGk9dC5nZXRCb29sUGFyYW0oZS5hdHRyLHIudGZQYXJhbU5hbWUsci5kZWZhdWx0VmFsdWUpKSYmci50ZlBhcmFtTmFtZURlcHJlY2F0ZWQmJihpPXQuZ2V0Qm9vbFBhcmFtKGUuYXR0cixyLnRmUGFyYW1OYW1lRGVwcmVjYXRlZCxyLmRlZmF1bHRWYWx1ZSkpO2JyZWFrO2Nhc2VcInNoYXBlXCI6dm9pZCAwPT09KGk9dC5nZXRUZW5zb3JTaGFwZVBhcmFtKGUuYXR0cixyLnRmUGFyYW1OYW1lLHIuZGVmYXVsdFZhbHVlKSkmJnIudGZQYXJhbU5hbWVEZXByZWNhdGVkJiYoaT10LmdldFRlbnNvclNoYXBlUGFyYW0oZS5hdHRyLHIudGZQYXJhbU5hbWVEZXByZWNhdGVkLHIuZGVmYXVsdFZhbHVlKSk7YnJlYWs7Y2FzZVwiZHR5cGVcIjp2b2lkIDA9PT0oaT10LmdldER0eXBlUGFyYW0oZS5hdHRyLHIudGZQYXJhbU5hbWUsci5kZWZhdWx0VmFsdWUpKSYmci50ZlBhcmFtTmFtZURlcHJlY2F0ZWQmJihpPXQuZ2V0RHR5cGVQYXJhbShlLmF0dHIsci50ZlBhcmFtTmFtZURlcHJlY2F0ZWQsci5kZWZhdWx0VmFsdWUpKTticmVhaztjYXNlXCJ0ZW5zb3JcIjpjYXNlXCJ0ZW5zb3JzXCI6YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBwYXJhbSB0eXBlOiBcIityLnR5cGUrXCIgZm9yIG9wOiBcIitlLm9wKX1yZXR1cm4gYVtyLmRsUGFyYW1OYW1lXT17dmFsdWU6aSxpbnB1dEluZGV4Om4sdHlwZTpzLGlucHV0UGFyYW1MZW5ndGg6b30sYX0se30pKSxyfSxlLnByb3RvdHlwZS5nZXRTdHJpbmdQYXJhbT1mdW5jdGlvbihlLHQsYSxyKXt2b2lkIDA9PT1yJiYocj0hMSk7dmFyIG49ZVt0XTtpZih2b2lkIDAhPT1uKXt2YXIgbz1TdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsbi5zKTtyZXR1cm4gcj9vOm8udG9Mb3dlckNhc2UoKX1yZXR1cm4gYX0sZS5wcm90b3R5cGUuZ2V0Qm9vbFBhcmFtPWZ1bmN0aW9uKGUsdCxhKXt2YXIgcj1lW3RdO3JldHVybiByP3IuYjphfSxlLnByb3RvdHlwZS5nZXROdW1iZXJQYXJhbT1mdW5jdGlvbihlLHQsYSl7dmFyIHI9ZVt0XSxuPXI/cltyLnZhbHVlXTphO3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiBuP246bi50b0ludCgpfSxlLnByb3RvdHlwZS5nZXREdHlwZVBhcmFtPWZ1bmN0aW9uKGUsdCxhKXt2YXIgcj1lW3RdO2lmKHImJnIudHlwZSlzd2l0Y2goci50eXBlKXtjYXNlIGNvbXBpbGVkX2FwaV8xLkRhdGFUeXBlLkRUX0ZMT0FUOnJldHVyblwiZmxvYXQzMlwiO2Nhc2UgY29tcGlsZWRfYXBpXzEuRGF0YVR5cGUuRFRfSU5UMzI6cmV0dXJuXCJpbnQzMlwiO2Nhc2UgY29tcGlsZWRfYXBpXzEuRGF0YVR5cGUuRFRfQk9PTDpyZXR1cm5cImJvb2xcIjtkZWZhdWx0OnJldHVybiBhfXJldHVybiBhfSxlLnByb3RvdHlwZS5nZXRUZW5zb3JTaGFwZVBhcmFtPWZ1bmN0aW9uKGUsdCxhKXt2YXIgcj1lW3RdO3JldHVybiByJiZyLnNoYXBlP3Iuc2hhcGUuZGltLm1hcChmdW5jdGlvbihlKXtyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgZS5zaXplP2Uuc2l6ZTplLnNpemUudG9JbnQoKX0pOmF9LGUucHJvdG90eXBlLmdldE51bWVyaWNBcnJheVBhcmFtPWZ1bmN0aW9uKGUsdCxhKXt2YXIgcj1lW3RdO3JldHVybiByPyhyLmxpc3QuZiYmci5saXN0LmYubGVuZ3RoP3IubGlzdC5mOnIubGlzdC5pKS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIGU/ZTplLnRvSW50KCl9KTphfSxlfSgpLGV4ZWN1dGVPcD1mdW5jdGlvbihlLHQsYSl7c3dpdGNoKGUub3Ape2Nhc2VcImFkZFwiOnJldHVyblthZGQoZ2V0UGFyYW1WYWx1ZShcImFcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImJcIixlLHQsYSkpXTtjYXNlXCJhZGROXCI6cmV0dXJuW2FkZE4oZ2V0UGFyYW1WYWx1ZShcInRlbnNvcnNcIixlLHQsYSkpXTtjYXNlXCJtb2RcIjpyZXR1cm5bbW9kKGdldFBhcmFtVmFsdWUoXCJhXCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJiXCIsZSx0LGEpKV07Y2FzZVwibXVsXCI6cmV0dXJuW211bChnZXRQYXJhbVZhbHVlKFwiYVwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiYlwiLGUsdCxhKSldO2Nhc2VcImRpdlwiOnJldHVybltkaXYoZ2V0UGFyYW1WYWx1ZShcImFcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImJcIixlLHQsYSkpXTtjYXNlXCJmbG9vckRpdlwiOnJldHVybltmbG9vckRpdihnZXRQYXJhbVZhbHVlKFwiYVwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiYlwiLGUsdCxhKSldO2Nhc2VcInN1YlwiOnJldHVybltzdWIoZ2V0UGFyYW1WYWx1ZShcImFcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImJcIixlLHQsYSkpXTtjYXNlXCJtaW5pbXVtXCI6cmV0dXJuW21pbmltdW0oZ2V0UGFyYW1WYWx1ZShcImFcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImJcIixlLHQsYSkpXTtjYXNlXCJtYXhpbXVtXCI6cmV0dXJuW21heGltdW0oZ2V0UGFyYW1WYWx1ZShcImFcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImJcIixlLHQsYSkpXTtjYXNlXCJwb3dcIjpyZXR1cm5bcG93KGdldFBhcmFtVmFsdWUoXCJhXCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJiXCIsZSx0LGEpKV07Y2FzZVwic3F1YXJlZERpZmZlcmVuY2VcIjpyZXR1cm5bc3F1YXJlZERpZmZlcmVuY2UoZ2V0UGFyYW1WYWx1ZShcImFcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImJcIixlLHQsYSkpXTtkZWZhdWx0OnRocm93IFR5cGVFcnJvcihcIk5vZGUgdHlwZSBcIitlLm9wK1wiIGlzIG5vdCBpbXBsZW1lbnRlZFwiKX19LGV4ZWN1dGVPcCQxPWZ1bmN0aW9uKGUsdCxhKXtzd2l0Y2goZS5vcCl7Y2FzZVwiYWJzXCI6cmV0dXJuW2FicyhnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcImFjb3NcIjpyZXR1cm5bYWNvcyhnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcImFjb3NoXCI6cmV0dXJuW2Fjb3NoKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwiYXNpblwiOnJldHVyblthc2luKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwiYXNpbmhcIjpyZXR1cm5bYXNpbmgoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkpXTtjYXNlXCJhdGFuXCI6cmV0dXJuW2F0YW4oZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkpXTtjYXNlXCJhdGFuMlwiOnJldHVyblthdGFuMihnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwieVwiLGUsdCxhKSldO2Nhc2VcImF0YW5oXCI6cmV0dXJuW2F0YW5oKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwiY2VpbFwiOnJldHVybltjZWlsKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwiY29zXCI6cmV0dXJuW2NvcyhnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcImNvc2hcIjpyZXR1cm5bY29zaChnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcImVsdVwiOnJldHVybltlbHUoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkpXTtjYXNlXCJlcmZcIjpyZXR1cm5bZXJmKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwiZXhwXCI6cmV0dXJuW2V4cChnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcImV4cG0xXCI6cmV0dXJuW2V4cG0xKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwiZmxvb3JcIjpyZXR1cm5bZmxvb3IoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkpXTtjYXNlXCJsb2dcIjpyZXR1cm5bbG9nKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwibG9nMXBcIjpyZXR1cm5bbG9nMXAoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkpXTtjYXNlXCJuZWdcIjpyZXR1cm5bbmVnKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwicmVjaXByb2NhbFwiOnJldHVybltyZWNpcHJvY2FsKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwicmVsdVwiOnJldHVybltyZWx1KGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwicm91bmRcIjpyZXR1cm5bcm91bmQoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkpXTtjYXNlXCJzZWx1XCI6cmV0dXJuW3NlbHUoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkpXTtjYXNlXCJzaWdtb2lkXCI6cmV0dXJuW3NpZ21vaWQoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkpXTtjYXNlXCJzaW5cIjpyZXR1cm5bc2luKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwic2lnblwiOnJldHVybltzaWduKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwic2luaFwiOnJldHVybltzaW5oKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwic29mdHBsdXNcIjpyZXR1cm5bc29mdHBsdXMoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkpXTtjYXNlXCJzcXJ0XCI6cmV0dXJuW3NxcnQoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkpXTtjYXNlXCJzcXVhcmVcIjpyZXR1cm5bc3F1YXJlKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwidGFuaFwiOnJldHVyblt0YW5oKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwidGFuXCI6cmV0dXJuW3RhbihnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcImNsaXBCeVZhbHVlXCI6cmV0dXJuW2NsaXBCeVZhbHVlKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJjbGlwVmFsdWVNaW5cIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImNsaXBWYWx1ZU1heFwiLGUsdCxhKSldO2Nhc2VcInJzcXJ0XCI6cmV0dXJuW2RpdihzY2FsYXIoMSxcImZsb2F0MzJcIiksc3FydChnZXRUZW5zb3IoZS5pbnB1dE5hbWVzWzBdLHQsYSkpKV07Y2FzZVwicHJvZFwiOnJldHVybltwcm9kKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJheGVzXCIsZSx0LGEpKV07Y2FzZVwibGVha3lSZWx1XCI6cmV0dXJuW2xlYWt5UmVsdShnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiYWxwaGFcIixlLHQsYSkpXTtkZWZhdWx0OnRocm93IFR5cGVFcnJvcihcIk5vZGUgdHlwZSBcIitlLm9wK1wiIGlzIG5vdCBpbXBsZW1lbnRlZFwiKX19LFRlbnNvckFycmF5PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0LGEscixuLG8scyxpKXt0aGlzLm5hbWU9dCx0aGlzLmR0eXBlPWEsdGhpcy5tYXhTaXplPXIsdGhpcy5lbGVtZW50U2hhcGU9bix0aGlzLmlkZW50aWNhbEVsZW1lbnRTaGFwZXM9byx0aGlzLmR5bmFtaWNTaXplPXMsdGhpcy5jbGVhckFmdGVyUmVhZD1pLHRoaXMudGVuc29ycz1bXSx0aGlzLmNsb3NlZF89ITEsdGhpcy5pZD1lLm5leHRJZCsrfXJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5wcm90b3R5cGUsXCJjbG9zZWRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2xvc2VkX30sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxlLnByb3RvdHlwZS5jbGVhckFuZENsb3NlPWZ1bmN0aW9uKCl7dGhpcy50ZW5zb3JzLmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIGUudGVuc29yLmRpc3Bvc2UoKX0pLHRoaXMudGVuc29ycz1bXSx0aGlzLmNsb3NlZF89ITB9LGUucHJvdG90eXBlLnNpemU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50ZW5zb3JzLmxlbmd0aH0sZS5wcm90b3R5cGUucmVhZD1mdW5jdGlvbihlKXtpZih0aGlzLmNsb3NlZF8pdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yQXJyYXkgXCIrdGhpcy5uYW1lK1wiIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkLlwiKTtpZihlPDB8fGU+PXRoaXMudGVuc29ycy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiVHJpZWQgdG8gcmVhZCBmcm9tIGluZGV4IFwiK2UrXCIsIGJ1dCBhcnJheSBzaXplIGlzOiBcIit0aGlzLnRlbnNvcnMubGVuZ3RoKTt2YXIgdD10aGlzLnRlbnNvcnNbZV07aWYodC5jbGVhcmVkKXRocm93IG5ldyBFcnJvcihcIlRlbnNvckFycmF5IFwiK3RoaXMubmFtZStcIjogQ291bGQgbm90IHJlYWQgaW5kZXggXCIrZStcIiB0d2ljZSBiZWNhdXNlIGl0IHdhcyBjbGVhcmVkIGFmdGVyIGEgcHJldmlvdXMgcmVhZCAocGVyaGFwcyB0cnkgc2V0dGluZyBjbGVhcl9hZnRlcl9yZWFkID0gZmFsc2U/KS5cIik7cmV0dXJuIHRoaXMuY2xlYXJBZnRlclJlYWQmJih0LmNsZWFyZWQ9ITApLHQucmVhZD0hMCx0LnRlbnNvcn0sZS5wcm90b3R5cGUucmVhZE1hbnk9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztyZXR1cm4gZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIHQucmVhZChlKX0pfSxlLnByb3RvdHlwZS53cml0ZT1mdW5jdGlvbihlLHQpe2lmKHRoaXMuY2xvc2VkXyl0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3JBcnJheSBcIit0aGlzLm5hbWUrXCIgaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQuXCIpO2lmKGU8MHx8IXRoaXMuZHluYW1pY1NpemUmJmU+PXRoaXMubWF4U2l6ZSl0aHJvdyBuZXcgRXJyb3IoXCJUcmllZCB0byB3cml0ZSB0byBpbmRleCBcIitlK1wiLCBidXQgYXJyYXkgaXMgbm90IHJlc2l6ZWFibGUgYW5kIHNpemUgaXM6IFwiK3RoaXMubWF4U2l6ZSk7dmFyIGE9dGhpcy50ZW5zb3JzW2VdfHx7fTtpZih0LmR0eXBlIT09dGhpcy5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3JBcnJheSBcIit0aGlzLm5hbWUrXCI6IENvdWxkIG5vdCB3cml0ZSB0byBUZW5zb3JBcnJheSBpbmRleCBcIitlK1wiLFxcbiAgICAgICAgICBiZWNhdXNlIHRoZSB2YWx1ZSBkdHlwZSBpcyBcIit0LmR0eXBlK1wiLCBidXQgVGVuc29yQXJyYXkgZHR5cGUgaXMgXCIrdGhpcy5kdHlwZStcIi5cIik7aWYoMD09PXRoaXMuc2l6ZSgpJiYwPT09dGhpcy5lbGVtZW50U2hhcGUubGVuZ3RoJiYodGhpcy5lbGVtZW50U2hhcGU9dC5zaGFwZSksdGhpcy5hc3NlcnRTaGFwZXNNYXRjaCh0aGlzLmVsZW1lbnRTaGFwZSx0LnNoYXBlLFwiVGVuc29yQXJyYXkgXCIrdGhpcy5uYW1lK1wiOiBDb3VsZCBub3Qgd3JpdGUgdG8gVGVuc29yQXJyYXkgaW5kZXggXCIrZStcIi5cIiksYSYmYS5yZWFkKXRocm93IG5ldyBFcnJvcihcIlRlbnNvckFycmF5IFwiK3RoaXMubmFtZStcIjogQ291bGQgbm90IHdyaXRlIHRvIFRlbnNvckFycmF5IGluZGV4IFwiK2UrXCIsIGJlY2F1c2UgaXQgaGFzIGFscmVhZHkgYmVlbiByZWFkLlwiKTtpZihhJiZhLndyaXR0ZW4pdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yQXJyYXkgXCIrdGhpcy5uYW1lK1wiOiBDb3VsZCBub3Qgd3JpdGUgdG8gVGVuc29yQXJyYXkgaW5kZXggXCIrZStcIiwgYmVjYXVzZSBpdCBoYXMgYWxyZWFkeSBiZWVuIHdyaXR0ZW4uXCIpO2EudGVuc29yPXQsYS53cml0dGVuPSEwLHRoaXMudGVuc29yc1tlXT1hfSxlLnByb3RvdHlwZS53cml0ZU1hbnk9ZnVuY3Rpb24oZSx0KXt2YXIgYT10aGlzO2lmKGUubGVuZ3RoIT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yQXJyYXkgXCIrdGhpcy5uYW1lK1wiOiBjb3VsZCBub3Qgd3JpdGUgbXVsdGlwbGUgdGVuc29ycyxiZWNhdXNlIHRoZSBpbmRleCBzaXplOiBcIitlLmxlbmd0aCtcIiBpcyBub3QgdGhlIHNhbWUgYXMgdGVuc29ycyBzaXplOiBcIit0Lmxlbmd0aCtcIi5cIik7ZS5mb3JFYWNoKGZ1bmN0aW9uKGUscil7cmV0dXJuIGEud3JpdGUoZSx0W3JdKX0pfSxlLnByb3RvdHlwZS5nYXRoZXI9ZnVuY3Rpb24oZSx0KXtpZih0JiZ0IT09dGhpcy5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3JBcnJheSBkdHlwZSBpcyBcIit0aGlzLmR0eXBlK1wiIGJ1dCBnYXRoZXIgcmVxdWVzdGVkIGR0eXBlIFwiK3QpO2lmKCFlKXtlPVtdO2Zvcih2YXIgYT0wO2E8dGhpcy5zaXplKCk7YSsrKWUucHVzaChhKX1pZigwPT09ZS5sZW5ndGgpcmV0dXJuIHRlbnNvcihbXSxbMF0uY29uY2F0KHRoaXMuZWxlbWVudFNoYXBlKSk7dmFyIHI9dGhpcy5yZWFkTWFueShlKTtyZXR1cm4gdGhpcy5hc3NlcnRTaGFwZXNNYXRjaCh0aGlzLmVsZW1lbnRTaGFwZSxyWzBdLnNoYXBlLFwiVGVuc29yQXJyYXkgc2hhcGUgbWlzbWF0Y2g6IFwiKSxzdGFjayhyLDApfSxlLnByb3RvdHlwZS5jb25jYXQ9ZnVuY3Rpb24oZSl7aWYoZSYmZSE9PXRoaXMuZHR5cGUpdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yQXJyYXkgZHR5cGUgaXMgXCIrdGhpcy5kdHlwZStcIiBidXQgY29uY2F0IHJlcXVlc3RlZCBkdHlwZSBcIitlKTtpZigwPT09dGhpcy5zaXplKCkpcmV0dXJuIHRlbnNvcihbXSxbMF0uY29uY2F0KHRoaXMuZWxlbWVudFNoYXBlKSk7Zm9yKHZhciB0PVtdLGE9MDthPHRoaXMuc2l6ZSgpO2ErKyl0LnB1c2goYSk7dmFyIHI9dGhpcy5yZWFkTWFueSh0KTtyZXR1cm4gdGhpcy5hc3NlcnRTaGFwZXNNYXRjaCh0aGlzLmVsZW1lbnRTaGFwZSxyWzBdLnNoYXBlLFwiVGVuc29yQXJyYXkgc2hhcGUgbWlzbWF0Y2g6IHRlbnNvciBhcnJheSBzaGFwZSAoXCIrdGhpcy5lbGVtZW50U2hhcGUrXCIpIHZzIGZpcnN0IHRlbnNvciBzaGFwZSAoXCIrclswXS5zaGFwZStcIilcIiksY29uY2F0KHIsMCl9LGUucHJvdG90eXBlLnNjYXR0ZXI9ZnVuY3Rpb24oZSx0KXtpZih0LmR0eXBlIT09dGhpcy5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3JBcnJheSBkdHlwZSBpcyBcIit0aGlzLmR0eXBlK1wiIGJ1dCB0ZW5zb3IgaGFzIGR0eXBlIFwiK3QuZHR5cGUpO2lmKGUubGVuZ3RoIT09dC5zaGFwZVswXSl0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBsZW4oaW5kaWNlcykgPT0gdGVuc29yLnNoYXBlWzBdLCBidXQgc2F3OiBcIitlLmxlbmd0aCtcIiB2cy4gXCIrdC5zaGFwZVswXSk7dmFyIGE9TWF0aC5tYXguYXBwbHkoTWF0aCxlKTtpZighdGhpcy5keW5hbWljU2l6ZSYmYT49dGhpcy5tYXhTaXplKXRocm93IG5ldyBFcnJvcihcIk1heCBpbmRleCBtdXN0IGJlIDwgYXJyYXkgc2l6ZSAoXCIrYStcIiAgdnMuIFwiK3RoaXMubWF4U2l6ZStcIilcIik7dGhpcy53cml0ZU1hbnkoZSx1bnN0YWNrKHQsMCkpfSxlLnByb3RvdHlwZS5zcGxpdD1mdW5jdGlvbihlLHQpe3ZhciBhPXRoaXM7aWYodC5kdHlwZSE9PXRoaXMuZHR5cGUpdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yQXJyYXkgZHR5cGUgaXMgXCIrdGhpcy5kdHlwZStcIiBidXQgdGVuc29yIGhhcyBkdHlwZSBcIit0LmR0eXBlKTt2YXIgcj0wLG49ZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIHIrPWV9KTtpZihyIT09dC5zaGFwZVswXSl0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBzdW0gb2YgbGVuZ3RocyB0byBiZSBlcXVhbCB0b1xcbiAgICAgICAgICB0ZW5zb3Iuc2hhcGVbMF0sIGJ1dCBzdW0gb2YgbGVuZ3RocyBpc1xcbiAgICAgICAgXCIrcitcIiwgYW5kIHRlbnNvcidzIHNoYXBlIGlzOiBcIit0LnNoYXBlKTtpZighdGhpcy5keW5hbWljU2l6ZSYmZS5sZW5ndGghPT10aGlzLm1heFNpemUpdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yQXJyYXkncyBzaXplIGlzIG5vdCBlcXVhbCB0byB0aGUgc2l6ZSBvZiBsZW5ndGhzIChcIit0aGlzLm1heFNpemUrXCIgdnMuIFwiK2UubGVuZ3RoK1wiKSwgYW5kIHRoZSBUZW5zb3JBcnJheSBpcyBub3QgbWFya2VkIGFzIGR5bmFtaWNhbGx5IHJlc2l6ZWFibGVcIik7dmFyIG89MD09PXI/MDp0LnNpemUvcixzPVtdO3RpZHkoZnVuY3Rpb24oKXt0PXQucmVzaGFwZShbMSxyLG9dKTtmb3IodmFyIGk9MDtpPGUubGVuZ3RoOysraSl7dmFyIHA9WzAsMD09PWk/MDpuW2ktMV0sMF0sbT1bMSxlW2ldLG9dO3NbaV09c2xpY2UodCxwLG0pLnJlc2hhcGUoYS5lbGVtZW50U2hhcGUpfXJldHVybiBzfSk7Zm9yKHZhciBpPVtdLHA9MDtwPGUubGVuZ3RoO3ArKylpW3BdPXA7dGhpcy53cml0ZU1hbnkoaSxzKX0sZS5wcm90b3R5cGUuYXNzZXJ0U2hhcGVzTWF0Y2g9ZnVuY3Rpb24oZSx0LGEpe3ZvaWQgMD09PWEmJihhPVwiXCIpLHV0aWwuYXNzZXJ0KHRoaXMuYXJyYXlzRXF1YWwoZSx0KSxhK1wiIFNoYXBlcyBcIitlK1wiIGFuZCBcIit0K1wiIG11c3QgbWF0Y2hcIil9LGUucHJvdG90eXBlLmFycmF5c0VxdWFsPWZ1bmN0aW9uKGUsdCl7aWYoZS5sZW5ndGghPT10Lmxlbmd0aClyZXR1cm4hMTtmb3IodmFyIGE9MDthPGUubGVuZ3RoO2ErKylpZigtMSE9PWVbYV0mJi0xIT09dFthXSYmZVthXSE9PXRbYV0pcmV0dXJuITE7cmV0dXJuITB9LGUubmV4dElkPTAsZX0oKTtmdW5jdGlvbiBleGVjdXRlT3AkMihlLHQsYSl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgcixuLG8scyxpLHAsbSx1LGwsZCxjLGYseSxoLGcsTixQLHgsYixJLHYsTyxWLHcsVCxrLFMsJCxfLEEsRCxqLEUsQyxSO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKEwpe3N3aXRjaChMLmxhYmVsKXtjYXNlIDA6c3dpdGNoKGUub3Ape2Nhc2VcImxvb3BDb25kXCI6cmV0dXJuWzMsMV07Y2FzZVwic3dpdGNoXCI6cmV0dXJuWzMsMl07Y2FzZVwibWVyZ2VcIjpyZXR1cm5bMyw0XTtjYXNlXCJlbnRlclwiOnJldHVyblszLDVdO2Nhc2VcImV4aXRcIjpyZXR1cm5bMyw2XTtjYXNlXCJuZXh0SXRlcmF0aW9uXCI6cmV0dXJuWzMsN107Y2FzZVwidGVuc29yQXJyYXlcIjpyZXR1cm5bMyw4XTtjYXNlXCJ0ZW5zb3JBcnJheVdyaXRlXCI6cmV0dXJuWzMsOV07Y2FzZVwidGVuc29yQXJyYXlSZWFkXCI6cmV0dXJuWzMsMTBdO2Nhc2VcInRlbnNvckFycmF5R2F0aGVyXCI6cmV0dXJuWzMsMTFdO2Nhc2VcInRlbnNvckFycmF5U2NhdHRlclwiOnJldHVyblszLDEyXTtjYXNlXCJ0ZW5zb3JBcnJheUNvbmNhdFwiOnJldHVyblszLDEzXTtjYXNlXCJ0ZW5zb3JBcnJheVNwbGl0XCI6cmV0dXJuWzMsMTRdO2Nhc2VcInRlbnNvckFycmF5U2l6ZVwiOnJldHVyblszLDE1XTtjYXNlXCJ0ZW5zb3JBcnJheUNsb3NlXCI6cmV0dXJuWzMsMTZdfXJldHVyblszLDE3XTtjYXNlIDE6cmV0dXJuWzIsW2dldFBhcmFtVmFsdWUoXCJwcmVkXCIsZSx0LGEpLmNsb25lKCldXTtjYXNlIDI6cmV0dXJuIHI9Z2V0UGFyYW1WYWx1ZShcInByZWRcIixlLHQsYSksbj1nZXRQYXJhbVZhbHVlKFwiZGF0YVwiLGUsdCxhKSxbNCxyLmRhdGEoKV07Y2FzZSAzOnJldHVyblsyLEwuc2VudCgpWzBdP1t2b2lkIDAsbi5jbG9uZSgpXTpbbi5jbG9uZSgpLHZvaWQgMF1dO2Nhc2UgNDpyZXR1cm5bMiwobz1lLmlucHV0TmFtZXMuZmluZChmdW5jdGlvbihlKXtyZXR1cm4gdm9pZCAwIT09Z2V0VGVuc29yKGUsdCxhKX0pKT9bZ2V0VGVuc29yKG8sdCxhKS5jbG9uZSgpXTp2b2lkIDBdO2Nhc2UgNTpyZXR1cm4gcz1nZXRQYXJhbVZhbHVlKFwiZnJhbWVOYW1lXCIsZSx0LGEpLGk9Z2V0UGFyYW1WYWx1ZShcInRlbnNvclwiLGUsdCxhKSxhLmVudGVyRnJhbWUocyksWzIsW2kuY2xvbmUoKV1dO2Nhc2UgNjpyZXR1cm4gcD1nZXRQYXJhbVZhbHVlKFwidGVuc29yXCIsZSx0LGEpLGEuZXhpdEZyYW1lKCksWzIsW3AuY2xvbmUoKV1dO2Nhc2UgNzpyZXR1cm4gbT1nZXRQYXJhbVZhbHVlKFwidGVuc29yXCIsZSx0LGEpLGEubmV4dEl0ZXJhdGlvbigpLFsyLFttLmNsb25lKCldXTtjYXNlIDg6cmV0dXJuIHU9Z2V0UGFyYW1WYWx1ZShcInNpemVcIixlLHQsYSksbD1nZXRQYXJhbVZhbHVlKFwiZHR5cGVcIixlLHQsYSksZD1nZXRQYXJhbVZhbHVlKFwiZWxlbWVudFNoYXBlXCIsZSx0LGEpLGM9Z2V0UGFyYW1WYWx1ZShcImR5bmFtaWNTaXplXCIsZSx0LGEpLGY9Z2V0UGFyYW1WYWx1ZShcImNsZWFyQWZ0ZXJSZWFkXCIsZSx0LGEpLHk9Z2V0UGFyYW1WYWx1ZShcImlkZW50aWNhbEVsZW1lbnRTaGFwZXNcIixlLHQsYSksaD1nZXRQYXJhbVZhbHVlKFwibmFtZVwiLGUsdCxhKSxnPW5ldyBUZW5zb3JBcnJheShoLGwsdSxkLHksYyxmKSxhLmFkZFRlbnNvckFycmF5KGcpLFsyLFtzY2FsYXIoZy5pZCksc2NhbGFyKDEpXV07Y2FzZSA5OnJldHVybiBOPWdldFBhcmFtVmFsdWUoXCJ0ZW5zb3JBcnJheUlkXCIsZSx0LGEpLFA9Z2V0UGFyYW1WYWx1ZShcImluZGV4XCIsZSx0LGEpLHg9Z2V0UGFyYW1WYWx1ZShcInRlbnNvclwiLGUsdCxhKSxhLmdldFRlbnNvckFycmF5KE4pLndyaXRlKFAseCksWzIsW3NjYWxhcigxKV1dO2Nhc2UgMTA6cmV0dXJuIGI9Z2V0UGFyYW1WYWx1ZShcInRlbnNvckFycmF5SWRcIixlLHQsYSksST1nZXRQYXJhbVZhbHVlKFwiaW5kZXhcIixlLHQsYSksWzIsW2EuZ2V0VGVuc29yQXJyYXkoYikucmVhZChJKV1dO2Nhc2UgMTE6cmV0dXJuIHY9Z2V0UGFyYW1WYWx1ZShcInRlbnNvckFycmF5SWRcIixlLHQsYSksTz1nZXRQYXJhbVZhbHVlKFwiaW5kaWNlc1wiLGUsdCxhKSxWPWdldFBhcmFtVmFsdWUoXCJkdHlwZVwiLGUsdCxhKSxbMixbYS5nZXRUZW5zb3JBcnJheSh2KS5nYXRoZXIoTyxWKV1dO2Nhc2UgMTI6cmV0dXJuIHc9Z2V0UGFyYW1WYWx1ZShcInRlbnNvckFycmF5SWRcIixlLHQsYSksVD1nZXRQYXJhbVZhbHVlKFwiaW5kaWNlc1wiLGUsdCxhKSxrPWdldFBhcmFtVmFsdWUoXCJ0ZW5zb3JcIixlLHQsYSksYS5nZXRUZW5zb3JBcnJheSh3KS5zY2F0dGVyKFQsayksWzIsW3NjYWxhcigxKV1dO2Nhc2UgMTM6cmV0dXJuIFM9Z2V0UGFyYW1WYWx1ZShcInRlbnNvckFycmF5SWRcIixlLHQsYSksJD1hLmdldFRlbnNvckFycmF5KFMpLF89Z2V0UGFyYW1WYWx1ZShcImR0eXBlXCIsZSx0LGEpLFsyLFskLmNvbmNhdChfKV1dO2Nhc2UgMTQ6cmV0dXJuIEE9Z2V0UGFyYW1WYWx1ZShcInRlbnNvckFycmF5SWRcIixlLHQsYSksRD1nZXRQYXJhbVZhbHVlKFwidGVuc29yXCIsZSx0LGEpLGo9Z2V0UGFyYW1WYWx1ZShcImxlbmd0aHNcIixlLHQsYSksYS5nZXRUZW5zb3JBcnJheShBKS5zcGxpdChqLEQpLFsyLFtzY2FsYXIoMSldXTtjYXNlIDE1OnJldHVybiBFPWdldFBhcmFtVmFsdWUoXCJ0ZW5zb3JBcnJheUlkXCIsZSx0LGEpLEM9YS5nZXRUZW5zb3JBcnJheShFKSxbMixbc2NhbGFyKEMuc2l6ZSgpLFwiaW50MzJcIildXTtjYXNlIDE2OnJldHVybiBSPWdldFBhcmFtVmFsdWUoXCJ0ZW5zb3JBcnJheUlkXCIsZSx0LGEpLGEuZ2V0VGVuc29yQXJyYXkoUikuY2xlYXJBbmRDbG9zZSgpLFsyLFtdXTtjYXNlIDE3OnRocm93IFR5cGVFcnJvcihcIk5vZGUgdHlwZSBcIitlLm9wK1wiIGlzIG5vdCBpbXBsZW1lbnRlZFwiKX19KX0pfXZhciBleGVjdXRlT3AkMz1mdW5jdGlvbihlLHQsYSl7c3dpdGNoKGUub3Ape2Nhc2VcImNvbnYxZFwiOnZhciByPWdldFBhcmFtVmFsdWUoXCJzdHJpZGVcIixlLHQsYSksbj1nZXRQYXJhbVZhbHVlKFwicGFkXCIsZSx0LGEpLG89Z2V0UGFyYW1WYWx1ZShcImRhdGFGb3JtYXRcIixlLHQsYSkudG9VcHBlckNhc2UoKSxzPWdldFBhcmFtVmFsdWUoXCJkaWxhdGlvblwiLGUsdCxhKTtyZXR1cm5bY29udjFkKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJmaWx0ZXJcIixlLHQsYSkscixuLG8scyldO2Nhc2VcImNvbnYyZFwiOnI9Z2V0UGFyYW1WYWx1ZShcInN0cmlkZXNcIixlLHQsYSksbj1nZXRQYXJhbVZhbHVlKFwicGFkXCIsZSx0LGEpLG89Z2V0UGFyYW1WYWx1ZShcImRhdGFGb3JtYXRcIixlLHQsYSkudG9VcHBlckNhc2UoKTt2YXIgaT1nZXRQYXJhbVZhbHVlKFwiZGlsYXRpb25zXCIsZSx0LGEpO3JldHVybltjb252MmQoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImZpbHRlclwiLGUsdCxhKSxbclsxXSxyWzJdXSxuLG8sW2lbMF0saVsxXV0pXTtjYXNlXCJjb252MmRUcmFuc3Bvc2VcIjp2YXIgcD1nZXRQYXJhbVZhbHVlKFwib3V0cHV0U2hhcGVcIixlLHQsYSk7cj1nZXRQYXJhbVZhbHVlKFwic3RyaWRlc1wiLGUsdCxhKSxuPWdldFBhcmFtVmFsdWUoXCJwYWRcIixlLHQsYSk7cmV0dXJuW2NvbnYyZFRyYW5zcG9zZShnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiZmlsdGVyXCIsZSx0LGEpLHAsW3JbMV0sclsyXV0sbildO2Nhc2VcImRlcHRod2lzZUNvbnYyZFwiOnI9Z2V0UGFyYW1WYWx1ZShcInN0cmlkZXNcIixlLHQsYSksbj1nZXRQYXJhbVZhbHVlKFwicGFkXCIsZSx0LGEpLGk9Z2V0UGFyYW1WYWx1ZShcImRpbGF0aW9uc1wiLGUsdCxhKSxvPWdldFBhcmFtVmFsdWUoXCJkYXRhRm9ybWF0XCIsZSx0LGEpLnRvVXBwZXJDYXNlKCk7cmV0dXJuW2RlcHRod2lzZUNvbnYyZChnZXRQYXJhbVZhbHVlKFwiaW5wdXRcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImZpbHRlclwiLGUsdCxhKSxbclsxXSxyWzJdXSxuLG8sW2lbMF0saVsxXV0pXTtjYXNlXCJhdmdQb29sXCI6cj1nZXRQYXJhbVZhbHVlKFwic3RyaWRlc1wiLGUsdCxhKSxuPWdldFBhcmFtVmFsdWUoXCJwYWRcIixlLHQsYSk7dmFyIG09Z2V0UGFyYW1WYWx1ZShcImtlcm5lbFNpemVcIixlLHQsYSk7cmV0dXJuW2F2Z1Bvb2woZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSksW21bMV0sbVsyXV0sW3JbMV0sclsyXV0sbildO2Nhc2VcIm1heFBvb2xcIjpyPWdldFBhcmFtVmFsdWUoXCJzdHJpZGVzXCIsZSx0LGEpLG49Z2V0UGFyYW1WYWx1ZShcInBhZFwiLGUsdCxhKSxtPWdldFBhcmFtVmFsdWUoXCJrZXJuZWxTaXplXCIsZSx0LGEpO3JldHVyblttYXhQb29sKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLFttWzFdLG1bMl1dLFtyWzFdLHJbMl1dLG4pXTtkZWZhdWx0OnRocm93IFR5cGVFcnJvcihcIk5vZGUgdHlwZSBcIitlLm9wK1wiIGlzIG5vdCBpbXBsZW1lbnRlZFwiKX19LGV4ZWN1dGVPcCQ0PWZ1bmN0aW9uKGUsdCxhKXtzd2l0Y2goZS5vcCl7Y2FzZVwiZmlsbFwiOnZhciByPWdldFBhcmFtVmFsdWUoXCJzaGFwZVwiLGUsdCxhKSxuPWdldFBhcmFtVmFsdWUoXCJkdHlwZVwiLGUsdCxhKSxvPWdldFBhcmFtVmFsdWUoXCJ2YWx1ZVwiLGUsdCxhKTtyZXR1cm5bZmlsbChyLG8sbildO2Nhc2VcImxpbnNwYWNlXCI6dmFyIHM9Z2V0UGFyYW1WYWx1ZShcInN0YXJ0XCIsZSx0LGEpLGk9Z2V0UGFyYW1WYWx1ZShcInN0b3BcIixlLHQsYSkscD1nZXRQYXJhbVZhbHVlKFwibnVtXCIsZSx0LGEpO3JldHVybltsaW5zcGFjZShzLGkscCldO2Nhc2VcIm9uZUhvdFwiOnZhciBtPWdldFBhcmFtVmFsdWUoXCJpbmRpY2VzXCIsZSx0LGEpLHU9Z2V0UGFyYW1WYWx1ZShcImRlcHRoXCIsZSx0LGEpLGw9Z2V0UGFyYW1WYWx1ZShcIm9uVmFsdWVcIixlLHQsYSksZD1nZXRQYXJhbVZhbHVlKFwib2ZmVmFsdWVcIixlLHQsYSk7cmV0dXJuW29uZUhvdChtLHUsbCxkKV07Y2FzZVwib25lc1wiOnJldHVybltvbmVzKGdldFBhcmFtVmFsdWUoXCJzaGFwZVwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiZHR5cGVcIixlLHQsYSkpXTtjYXNlXCJvbmVzTGlrZVwiOnJldHVybltvbmVzTGlrZShnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcInJhbmRvbVVuaWZvcm1cIjpyZXR1cm5bcmFuZG9tVW5pZm9ybShnZXRQYXJhbVZhbHVlKFwic2hhcGVcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcIm1pbnZhbFwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwibWF4dmFsXCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJkdHlwZVwiLGUsdCxhKSldO2Nhc2VcInJhbmdlXCI6cz1nZXRQYXJhbVZhbHVlKFwic3RhcnRcIixlLHQsYSk7dmFyIGM9Z2V0UGFyYW1WYWx1ZShcInN0b3BcIixlLHQsYSksZj1nZXRQYXJhbVZhbHVlKFwic3RlcFwiLGUsdCxhKTtyZXR1cm5bcmFuZ2UocyxjLGYsZ2V0UGFyYW1WYWx1ZShcImR0eXBlXCIsZSx0LGEpKV07Y2FzZVwidHJ1bmNhdGVkTm9ybWFsXCI6cj1nZXRQYXJhbVZhbHVlKFwic2hhcGVcIixlLHQsYSk7dmFyIHk9Z2V0UGFyYW1WYWx1ZShcIm1lYW5cIixlLHQsYSksaD1nZXRQYXJhbVZhbHVlKFwic3RkRGV2XCIsZSx0LGEpLGc9Z2V0UGFyYW1WYWx1ZShcInNlZWRcIixlLHQsYSk7cmV0dXJuW3RydW5jYXRlZE5vcm1hbChyLHksaCxnZXRQYXJhbVZhbHVlKFwiZHR5cGVcIixlLHQsYSksZyldO2Nhc2VcInplcm9zXCI6cmV0dXJuW3plcm9zKGdldFBhcmFtVmFsdWUoXCJzaGFwZVwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiZHR5cGVcIixlLHQsYSkpXTtjYXNlXCJ6ZXJvc0xpa2VcIjpyZXR1cm5bemVyb3NMaWtlKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07ZGVmYXVsdDp0aHJvdyBUeXBlRXJyb3IoXCJOb2RlIHR5cGUgXCIrZS5vcCtcIiBpcyBub3QgaW1wbGVtZW50ZWRcIil9fTtmdW5jdGlvbiBleGVjdXRlT3AkNShlLHQsYSl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgcixuLG8scyxpO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHApe3N3aXRjaChwLmxhYmVsKXtjYXNlIDA6c3dpdGNoKGUub3Ape2Nhc2VcIm5vbk1heFN1cHByZXNzaW9uXCI6cmV0dXJuWzMsMV07Y2FzZVwid2hlcmVBc3luY1wiOnJldHVyblszLDNdO2Nhc2VcInNldGRpZmYxZEFzeW5jXCI6cmV0dXJuWzMsNV19cmV0dXJuWzMsN107Y2FzZSAxOnJldHVybiByPWdldFBhcmFtVmFsdWUoXCJib3hlc1wiLGUsdCxhKSxuPWdldFBhcmFtVmFsdWUoXCJzY29yZXNcIixlLHQsYSksbz1nZXRQYXJhbVZhbHVlKFwibWF4T3V0cHV0U2l6ZVwiLGUsdCxhKSxzPWdldFBhcmFtVmFsdWUoXCJpb3VUaHJlc2hvbGRcIixlLHQsYSksaT1nZXRQYXJhbVZhbHVlKFwic2NvcmVUaHJlc2hvbGRcIixlLHQsYSksWzQsaW1hZ2Uubm9uTWF4U3VwcHJlc3Npb25Bc3luYyhyLG4sbyxzLGkpXTtjYXNlIDI6cmV0dXJuWzIsW3Auc2VudCgpXV07Y2FzZSAzOnJldHVybls0LHdoZXJlQXN5bmMoZ2V0UGFyYW1WYWx1ZShcImNvbmRpdGlvblwiLGUsdCxhKSldO2Nhc2UgNDpyZXR1cm5bMixbcC5zZW50KCldXTtjYXNlIDU6cmV0dXJuWzQsc2V0ZGlmZjFkQXN5bmMoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcInlcIixlLHQsYSkpXTtjYXNlIDY6cmV0dXJuWzIscC5zZW50KCldO2Nhc2UgNzp0aHJvdyBUeXBlRXJyb3IoXCJOb2RlIHR5cGUgXCIrZS5vcCtcIiBpcyBub3QgaW1wbGVtZW50ZWRcIil9fSl9KX12YXIgZXhlY3V0ZU9wJDY9ZnVuY3Rpb24oZSx0LGEpe3N3aXRjaChlLm9wKXtjYXNlXCJ0b3BLXCI6dmFyIHI9Z2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSksbj1nZXRQYXJhbVZhbHVlKFwia1wiLGUsdCxhKSxvPWdldFBhcmFtVmFsdWUoXCJzb3J0ZWRcIixlLHQsYSkscz10b3BrKHIsbixvKTtyZXR1cm5bcy52YWx1ZXMscy5pbmRpY2VzXTtkZWZhdWx0OnRocm93IFR5cGVFcnJvcihcIk5vZGUgdHlwZSBcIitlLm9wK1wiIGlzIG5vdCBpbXBsZW1lbnRlZFwiKX19LGV4ZWN1dGVPcCQ3PWZ1bmN0aW9uKGUsdCxhKXtzd2l0Y2goZS5vcCl7Y2FzZVwiY29uc3RcIjpyZXR1cm4gdFtlLm5hbWVdO2Nhc2VcInBsYWNlaG9sZGVyXCI6dmFyIHI9Z2V0UGFyYW1WYWx1ZShcImRlZmF1bHRcIixlLHQsYSk7cmV0dXJuW2dldFRlbnNvcihlLm5hbWUsdCxhKXx8cl07Y2FzZVwiaWRlbnRpdHlcIjpjYXNlXCJzdG9wR3JhZGllbnRcIjpjYXNlXCJmYWtlUXVhbnRXaXRoTWluTWF4VmFyc1wiOnJldHVybltnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKS5jbG9uZSgpXTtjYXNlXCJzbmFwc2hvdFwiOnJldHVybltnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKS5jbG9uZSgpXTtjYXNlXCJzaGFwZVwiOnJldHVyblt0ZW5zb3IxZChnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKS5zaGFwZSxcImludDMyXCIpXTtjYXNlXCJzaGFwZU5cIjpyZXR1cm4gZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkubWFwKGZ1bmN0aW9uKGUpe3JldHVybiB0ZW5zb3IxZChlLnNoYXBlKX0pO2Nhc2VcInNpemVcIjpyZXR1cm5bc2NhbGFyKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLnNpemUsXCJpbnQzMlwiKV07Y2FzZVwicmFua1wiOnJldHVybltzY2FsYXIoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkucmFuayxcImludDMyXCIpXTtjYXNlXCJub29wXCI6cmV0dXJuW107Y2FzZVwicHJpbnRcIjp2YXIgbj1nZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxvPWdldFBhcmFtVmFsdWUoXCJkYXRhXCIsZSx0LGEpLHM9Z2V0UGFyYW1WYWx1ZShcIm1lc3NhZ2VcIixlLHQsYSksaT1nZXRQYXJhbVZhbHVlKFwic3VtbWFyaXplXCIsZSx0LGEpO2NvbnNvbGUud2FybihcIlRoZSBncmFwaCBoYXMgYSB0Zi5wcmludCgpIG9wZXJhdGlvbix1c3VhbGx5IHVzZWQgZm9yIGRlYnVnZ2luZywgd2hpY2ggc2xvd3MgZG93biBwZXJmb3JtYW5jZS5cIiksY29uc29sZS5sb2cocyk7Zm9yKHZhciBwPTA7cDxvLmxlbmd0aDtwKyspY29uc29sZS5sb2coQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwob1swXS5kYXRhU3luYygpKS5zbGljZSgwLGkpKTtyZXR1cm5bbl07ZGVmYXVsdDp0aHJvdyBUeXBlRXJyb3IoXCJOb2RlIHR5cGUgXCIrZS5vcCtcIiBpcyBub3QgaW1wbGVtZW50ZWRcIil9fSxleGVjdXRlT3AkOD1mdW5jdGlvbihlLHQsYSl7c3dpdGNoKGUub3Ape2Nhc2VcInJlc2l6ZUJpbGluZWFyXCI6dmFyIHI9Z2V0UGFyYW1WYWx1ZShcImltYWdlc1wiLGUsdCxhKSxuPWdldFBhcmFtVmFsdWUoXCJzaXplXCIsZSx0LGEpLG89Z2V0UGFyYW1WYWx1ZShcImFsaWduQ29ybmVyc1wiLGUsdCxhKTtyZXR1cm5baW1hZ2UucmVzaXplQmlsaW5lYXIocixbblswXSxuWzFdXSxvKV07Y2FzZVwicmVzaXplTmVhcmVzdE5laWdoYm9yXCI6cj1nZXRQYXJhbVZhbHVlKFwiaW1hZ2VzXCIsZSx0LGEpLG49Z2V0UGFyYW1WYWx1ZShcInNpemVcIixlLHQsYSksbz1nZXRQYXJhbVZhbHVlKFwiYWxpZ25Db3JuZXJzXCIsZSx0LGEpO3JldHVybltpbWFnZS5yZXNpemVOZWFyZXN0TmVpZ2hib3IocixbblswXSxuWzFdXSxvKV07Y2FzZVwiY3JvcEFuZFJlc2l6ZVwiOnZhciBzPWdldFBhcmFtVmFsdWUoXCJpbWFnZVwiLGUsdCxhKSxpPWdldFBhcmFtVmFsdWUoXCJib3hlc1wiLGUsdCxhKSxwPWdldFBhcmFtVmFsdWUoXCJib3hJbmRcIixlLHQsYSksbT1nZXRQYXJhbVZhbHVlKFwiY3JvcFNpemVcIixlLHQsYSksdT1nZXRQYXJhbVZhbHVlKFwibWV0aG9kXCIsZSx0LGEpLGw9Z2V0UGFyYW1WYWx1ZShcImV4dHJhcG9sYXRpb25WYWx1ZVwiLGUsdCxhKTtyZXR1cm5baW1hZ2UuY3JvcEFuZFJlc2l6ZShzLGkscCxtLHUsbCldO2RlZmF1bHQ6dGhyb3cgVHlwZUVycm9yKFwiTm9kZSB0eXBlIFwiK2Uub3ArXCIgaXMgbm90IGltcGxlbWVudGVkXCIpfX0sZXhlY3V0ZU9wJDk9ZnVuY3Rpb24oZSx0LGEpe3N3aXRjaChlLm9wKXtjYXNlXCJlcXVhbFwiOnJldHVybltlcXVhbChnZXRQYXJhbVZhbHVlKFwiYVwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiYlwiLGUsdCxhKSldO2Nhc2VcIm5vdEVxdWFsXCI6cmV0dXJuW25vdEVxdWFsKGdldFBhcmFtVmFsdWUoXCJhXCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJiXCIsZSx0LGEpKV07Y2FzZVwiZ3JlYXRlclwiOnJldHVybltncmVhdGVyKGdldFBhcmFtVmFsdWUoXCJhXCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJiXCIsZSx0LGEpKV07Y2FzZVwiZ3JlYXRlckVxdWFsXCI6cmV0dXJuW2dyZWF0ZXJFcXVhbChnZXRQYXJhbVZhbHVlKFwiYVwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiYlwiLGUsdCxhKSldO2Nhc2VcImxlc3NcIjpyZXR1cm5bbGVzcyhnZXRQYXJhbVZhbHVlKFwiYVwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiYlwiLGUsdCxhKSldO2Nhc2VcImxlc3NFcXVhbFwiOnJldHVybltsZXNzRXF1YWwoZ2V0UGFyYW1WYWx1ZShcImFcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImJcIixlLHQsYSkpXTtjYXNlXCJsb2dpY2FsQW5kXCI6cmV0dXJuW2xvZ2ljYWxBbmQoZ2V0UGFyYW1WYWx1ZShcImFcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImJcIixlLHQsYSkpXTtjYXNlXCJsb2dpY2FsTm90XCI6cmV0dXJuW2xvZ2ljYWxOb3QoZ2V0UGFyYW1WYWx1ZShcImFcIixlLHQsYSkpXTtjYXNlXCJsb2dpY2FsT3JcIjpyZXR1cm5bbG9naWNhbE9yKGdldFBhcmFtVmFsdWUoXCJhXCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJiXCIsZSx0LGEpKV07Y2FzZVwid2hlcmVcIjpyZXR1cm5bd2hlcmUoZ2V0UGFyYW1WYWx1ZShcImNvbmRpdGlvblwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiYVwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiYlwiLGUsdCxhKSldO2RlZmF1bHQ6dGhyb3cgVHlwZUVycm9yKFwiTm9kZSB0eXBlIFwiK2Uub3ArXCIgaXMgbm90IGltcGxlbWVudGVkXCIpfX0sZXhlY3V0ZU9wJDEwPWZ1bmN0aW9uKGUsdCxhKXtzd2l0Y2goZS5vcCl7Y2FzZVwibWF0TXVsXCI6cmV0dXJuW21hdE11bChnZXRQYXJhbVZhbHVlKFwiYVwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiYlwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwidHJhbnNwb3NlQVwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwidHJhbnNwb3NlQlwiLGUsdCxhKSldO2Nhc2VcInRyYW5zcG9zZVwiOnJldHVyblt0cmFuc3Bvc2UoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcInBlcm1cIixlLHQsYSkpXTtkZWZhdWx0OnRocm93IFR5cGVFcnJvcihcIk5vZGUgdHlwZSBcIitlLm9wK1wiIGlzIG5vdCBpbXBsZW1lbnRlZFwiKX19LGV4ZWN1dGVPcCQxMT1mdW5jdGlvbihlLHQsYSl7c3dpdGNoKGUub3Ape2Nhc2VcImJhdGNoTm9ybWFsaXphdGlvblwiOnJldHVybltiYXRjaE5vcm1hbGl6YXRpb24oZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcIm1lYW5cIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcInZhcmlhbmNlXCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJlcHNpbG9uXCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJzY2FsZVwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwib2Zmc2V0XCIsZSx0LGEpKV07Y2FzZVwibG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb25cIjpyZXR1cm5bbG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb24oZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcInJhZGl1c1wiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiYmlhc1wiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiYWxwaGFcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImJldGFcIixlLHQsYSkpXTtjYXNlXCJzb2Z0bWF4XCI6cmV0dXJuW3NvZnRtYXgoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkpXTtjYXNlXCJsb2dTb2Z0bWF4XCI6cmV0dXJuW2xvZ1NvZnRtYXgoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkpXTtjYXNlXCJzcGFyc2VUb0RlbnNlXCI6cmV0dXJuW3NwYXJzZVRvRGVuc2UoZ2V0UGFyYW1WYWx1ZShcInNwYXJzZUluZGljZXNcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcIm91dHB1dFNoYXBlXCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJzcGFyc2VWYWx1ZXNcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImRlZmF1bHRWYWx1ZVwiLGUsdCxhKSldO2RlZmF1bHQ6dGhyb3cgVHlwZUVycm9yKFwiTm9kZSB0eXBlIFwiK2Uub3ArXCIgaXMgbm90IGltcGxlbWVudGVkXCIpfX0sZXhlY3V0ZU9wJDEyPWZ1bmN0aW9uKGUsdCxhKXtzd2l0Y2goZS5vcCl7Y2FzZVwibWF4XCI6dmFyIHI9Z2V0UGFyYW1WYWx1ZShcImF4aXNcIixlLHQsYSksbj1nZXRQYXJhbVZhbHVlKFwia2VlcERpbXNcIixlLHQsYSk7cmV0dXJuW21heChnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxyLG4pXTtjYXNlXCJtZWFuXCI6cj1nZXRQYXJhbVZhbHVlKFwiYXhpc1wiLGUsdCxhKSxuPWdldFBhcmFtVmFsdWUoXCJrZWVwRGltc1wiLGUsdCxhKTtyZXR1cm5bbWVhbihnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxyLG4pXTtjYXNlXCJtaW5cIjpyPWdldFBhcmFtVmFsdWUoXCJheGlzXCIsZSx0LGEpLG49Z2V0UGFyYW1WYWx1ZShcImtlZXBEaW1zXCIsZSx0LGEpO3JldHVyblttaW4oZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkscixuKV07Y2FzZVwic3VtXCI6cj1nZXRQYXJhbVZhbHVlKFwiYXhpc1wiLGUsdCxhKSxuPWdldFBhcmFtVmFsdWUoXCJrZWVwRGltc1wiLGUsdCxhKTtyZXR1cm5bc3VtKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLHIsbildO2Nhc2VcImFsbFwiOnI9Z2V0UGFyYW1WYWx1ZShcImF4aXNcIixlLHQsYSksbj1nZXRQYXJhbVZhbHVlKFwia2VlcERpbXNcIixlLHQsYSk7cmV0dXJuW2FsbChnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxyLG4pXTtjYXNlXCJhbnlcIjpyPWdldFBhcmFtVmFsdWUoXCJheGlzXCIsZSx0LGEpLG49Z2V0UGFyYW1WYWx1ZShcImtlZXBEaW1zXCIsZSx0LGEpO3JldHVyblthbnkoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkscixuKV07Y2FzZVwiYXJnTWF4XCI6cj1nZXRQYXJhbVZhbHVlKFwiYXhpc1wiLGUsdCxhKTtyZXR1cm5bYXJnTWF4KGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLHIpXTtjYXNlXCJhcmdNaW5cIjpyPWdldFBhcmFtVmFsdWUoXCJheGlzXCIsZSx0LGEpO3JldHVyblthcmdNaW4oZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkscildO2Nhc2VcInByb2RcIjpyPWdldFBhcmFtVmFsdWUoXCJheGlzXCIsZSx0LGEpLG49Z2V0UGFyYW1WYWx1ZShcImtlZXBEaW1zXCIsZSx0LGEpO3JldHVybltwcm9kKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLHIsbildO2RlZmF1bHQ6dGhyb3cgVHlwZUVycm9yKFwiTm9kZSB0eXBlIFwiK2Uub3ArXCIgaXMgbm90IGltcGxlbWVudGVkXCIpfX0sZXhlY3V0ZU9wJDEzPWZ1bmN0aW9uKGUsdCxhKXtzd2l0Y2goZS5vcCl7Y2FzZVwiY29uY2F0XCI6dmFyIHI9Z2V0UGFyYW1WYWx1ZShcImF4aXNcIixlLHQsYSksbj1nZXRQYXJhbVZhbHVlKFwidGVuc29yc1wiLGUsdCxhKTtyZXR1cm5bY29uY2F0KG4scildO2Nhc2VcImdhdGhlclwiOnI9Z2V0UGFyYW1WYWx1ZShcImF4aXNcIixlLHQsYSk7dmFyIG89Z2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkscz1nZXRQYXJhbVZhbHVlKFwiaW5kaWNlc1wiLGUsdCxhKTtyZXR1cm5bZ2F0aGVyKG8scyxyKV07Y2FzZVwicmV2ZXJzZVwiOnI9Z2V0UGFyYW1WYWx1ZShcImF4aXNcIixlLHQsYSksbz1nZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKTtyZXR1cm5bcmV2ZXJzZShvLHIpXTtjYXNlXCJzbGljZVwiOnZhciBpPWdldFBhcmFtVmFsdWUoXCJiZWdpblwiLGUsdCxhKSxwPWdldFBhcmFtVmFsdWUoXCJzaXplXCIsZSx0LGEpO3JldHVybltzbGljZShnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxpLHApXTtjYXNlXCJzdHJpZGVkU2xpY2VcIjppPWdldFBhcmFtVmFsdWUoXCJiZWdpblwiLGUsdCxhKTt2YXIgbT1nZXRQYXJhbVZhbHVlKFwiZW5kXCIsZSx0LGEpLHU9Z2V0UGFyYW1WYWx1ZShcInN0cmlkZXNcIixlLHQsYSksbD1nZXRQYXJhbVZhbHVlKFwiYmVnaW5NYXNrXCIsZSx0LGEpLGQ9Z2V0UGFyYW1WYWx1ZShcImVuZE1hc2tcIixlLHQsYSksYz1nZXRQYXJhbVZhbHVlKFwiZWxsaXBzaXNNYXNrXCIsZSx0LGEpLGY9Z2V0UGFyYW1WYWx1ZShcIm5ld0F4aXNNYXNrXCIsZSx0LGEpLHk9Z2V0UGFyYW1WYWx1ZShcInNocmlua0F4aXNNYXNrXCIsZSx0LGEpLGg9Z2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSk7aWYoMT09PWkubGVuZ3RoJiZoLnNoYXBlLmxlbmd0aD4xKWZvcih2YXIgZz0xO2c8aC5zaGFwZS5sZW5ndGg7ZysrKWkucHVzaCgwKSxtLnB1c2goaC5zaGFwZVtnXSksdS5wdXNoKHVbMF0pO3JldHVybltzdHJpZGVkU2xpY2UoaCxpLG0sdSxsLGQsYyxmLHkpXTtjYXNlXCJzdGFja1wiOnJldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIHI9Z2V0UGFyYW1WYWx1ZShcImF4aXNcIixlLHQsYSksbj1nZXRQYXJhbVZhbHVlKFwidGVuc29yc1wiLGUsdCxhKSxvPW5bMF0uc2hhcGUscz1uWzBdLnNxdWVlemUoKS5zaGFwZSxpPW4ubWFwKGZ1bmN0aW9uKGUpe3ZhciB0PXV0aWwuYXJyYXlzRXF1YWwoZS5zaGFwZSxvKTtpZighdCYmIXV0aWwuYXJyYXlzRXF1YWwoZS5zcXVlZXplKCkuc2hhcGUscykpdGhyb3cgbmV3IEVycm9yKFwidGhlIGlucHV0IHRlbnNvcnMgc2hhcGUgZG9lcyBub3QgbWF0Y2hcIik7cmV0dXJuIHQ/ZTplLnJlc2hhcGUobyl9KTtyZXR1cm5bc3RhY2soaSxyKV19KTtjYXNlXCJ1bnN0YWNrXCI6cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXt2YXIgcj1nZXRQYXJhbVZhbHVlKFwiYXhpc1wiLGUsdCxhKSxuPWdldFBhcmFtVmFsdWUoXCJ0ZW5zb3JcIixlLHQsYSk7cmV0dXJuIHVuc3RhY2sobixyKX0pO2Nhc2VcInRpbGVcIjp2YXIgTj1nZXRQYXJhbVZhbHVlKFwicmVwc1wiLGUsdCxhKTtyZXR1cm5bdGlsZShnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxOKV07Y2FzZVwic3BsaXRcIjpyPWdldFBhcmFtVmFsdWUoXCJheGlzXCIsZSx0LGEpO3ZhciBQPWdldFBhcmFtVmFsdWUoXCJudW1PclNpemVTcGxpdHNcIixlLHQsYSk7cmV0dXJuIHNwbGl0KGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLFAscik7Y2FzZVwic2NhdHRlck5kXCI6cz1nZXRQYXJhbVZhbHVlKFwiaW5kaWNlc1wiLGUsdCxhKTt2YXIgeD1nZXRQYXJhbVZhbHVlKFwidmFsdWVzXCIsZSx0LGEpLGI9Z2V0UGFyYW1WYWx1ZShcInNoYXBlXCIsZSx0LGEpO3JldHVybltzY2F0dGVyTkQocyx4LGIpXTtjYXNlXCJnYXRoZXJOZFwiOnZhciBJPWdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpO3M9Z2V0UGFyYW1WYWx1ZShcImluZGljZXNcIixlLHQsYSk7cmV0dXJuW2dhdGhlck5EKEkscyldO2Nhc2VcInNwYXJzZVRvRGVuc2VcIjpzPWdldFBhcmFtVmFsdWUoXCJzcGFyc2VJbmRpY2VzXCIsZSx0LGEpLGI9Z2V0UGFyYW1WYWx1ZShcIm91dHB1dFNoYXBlXCIsZSx0LGEpO3ZhciB2PWdldFBhcmFtVmFsdWUoXCJzcGFyc2VWYWx1ZXNcIixlLHQsYSksTz1nZXRQYXJhbVZhbHVlKFwiZGVmYXVsdFZhbHVlXCIsZSx0LGEpO3JldHVybltzcGFyc2VUb0RlbnNlKHMsdixiLE8pXTtkZWZhdWx0OnRocm93IFR5cGVFcnJvcihcIk5vZGUgdHlwZSBcIitlLm9wK1wiIGlzIG5vdCBpbXBsZW1lbnRlZFwiKX19LGV4ZWN1dGVPcCQxND1mdW5jdGlvbihlLHQsYSl7c3dpdGNoKGUub3Ape2Nhc2VcImNhc3RcIjpyZXR1cm5bY2FzdChnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiZHR5cGVcIixlLHQsYSkpXTtjYXNlXCJleHBhbmREaW1zXCI6dmFyIHI9Z2V0UGFyYW1WYWx1ZShcImF4aXNcIixlLHQsYSk7cmV0dXJuW2V4cGFuZERpbXMoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkscildO2Nhc2VcInNxdWVlemVcIjpyPWdldFBhcmFtVmFsdWUoXCJheGlzXCIsZSx0LGEpO3JldHVybltzcXVlZXplKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLHIpXTtjYXNlXCJyZXNoYXBlXCI6cmV0dXJuW3Jlc2hhcGUoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcInNoYXBlXCIsZSx0LGEpKV07Y2FzZVwicGFkXCI6cmV0dXJuW3BhZChnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxzcGxpdCQxKGdldFBhcmFtVmFsdWUoXCJwYWRkaW5nXCIsZSx0LGEpLDIpLGdldFBhcmFtVmFsdWUoXCJjb25zdGFudFZhbHVlXCIsZSx0LGEpKV07Y2FzZVwic3BhY2VUb0JhdGNoTkRcIjp2YXIgbj1nZXRQYXJhbVZhbHVlKFwiYmxvY2tTaGFwZVwiLGUsdCxhKSxvPXNwbGl0JDEoZ2V0UGFyYW1WYWx1ZShcInBhZGRpbmdzXCIsZSx0LGEpLDIpO3JldHVybltzcGFjZVRvQmF0Y2hORChnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxuLG8pXTtjYXNlXCJiYXRjaFRvU3BhY2VORFwiOm49Z2V0UGFyYW1WYWx1ZShcImJsb2NrU2hhcGVcIixlLHQsYSk7dmFyIHM9c3BsaXQkMShnZXRQYXJhbVZhbHVlKFwiY3JvcHNcIixlLHQsYSksMik7cmV0dXJuW2JhdGNoVG9TcGFjZU5EKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLG4scyldO2Nhc2VcImRlcHRoVG9TcGFjZVwiOnZhciBpPWdldFBhcmFtVmFsdWUoXCJibG9ja1NpemVcIixlLHQsYSkscD1nZXRQYXJhbVZhbHVlKFwiZGF0YUZvcm1hdFwiLGUsdCxhKTtyZXR1cm5bZGVwdGhUb1NwYWNlKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLGkscCldO2RlZmF1bHQ6dGhyb3cgVHlwZUVycm9yKFwiTm9kZSB0eXBlIFwiK2Uub3ArXCIgaXMgbm90IGltcGxlbWVudGVkXCIpfX07ZnVuY3Rpb24gZXhlY3V0ZU9wJDE1KGUsdCxhKXtzd2l0Y2goZS5jYXRlZ29yeSl7Y2FzZVwiYXJpdGhtZXRpY1wiOnJldHVybiBleGVjdXRlT3AoZSx0LGEpO2Nhc2VcImJhc2ljX21hdGhcIjpyZXR1cm4gZXhlY3V0ZU9wJDEoZSx0LGEpO2Nhc2VcImNvbnRyb2xcIjpyZXR1cm4gZXhlY3V0ZU9wJDIoZSx0LGEpO2Nhc2VcImNvbnZvbHV0aW9uXCI6cmV0dXJuIGV4ZWN1dGVPcCQzKGUsdCxhKTtjYXNlXCJjcmVhdGlvblwiOnJldHVybiBleGVjdXRlT3AkNChlLHQsYSk7Y2FzZVwiZHluYW1pY1wiOnJldHVybiBleGVjdXRlT3AkNShlLHQsYSk7Y2FzZVwiZXZhbHVhdGlvblwiOnJldHVybiBleGVjdXRlT3AkNihlLHQsYSk7Y2FzZVwiaW1hZ2VcIjpyZXR1cm4gZXhlY3V0ZU9wJDgoZSx0LGEpO2Nhc2VcImdyYXBoXCI6cmV0dXJuIGV4ZWN1dGVPcCQ3KGUsdCxhKTtjYXNlXCJsb2dpY2FsXCI6cmV0dXJuIGV4ZWN1dGVPcCQ5KGUsdCxhKTtjYXNlXCJtYXRyaWNlc1wiOnJldHVybiBleGVjdXRlT3AkMTAoZSx0LGEpO2Nhc2VcIm5vcm1hbGl6YXRpb25cIjpyZXR1cm4gZXhlY3V0ZU9wJDExKGUsdCxhKTtjYXNlXCJyZWR1Y3Rpb25cIjpyZXR1cm4gZXhlY3V0ZU9wJDEyKGUsdCxhKTtjYXNlXCJzbGljZV9qb2luXCI6cmV0dXJuIGV4ZWN1dGVPcCQxMyhlLHQsYSk7Y2FzZVwidHJhbnNmb3JtYXRpb25cIjpyZXR1cm4gZXhlY3V0ZU9wJDE0KGUsdCxhKTtkZWZhdWx0OnRocm93IFR5cGVFcnJvcihcIk5vZGUgdHlwZSBcIitlLm9wK1wiIGlzIG5vdCBpbXBsZW1lbnRlZFwiKX19dmFyIEV4ZWN1dGlvbkNvbnRleHQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCl7dGhpcy53ZWlnaHRNYXA9ZSx0aGlzLnRlbnNvckFycmF5TWFwPXQsdGhpcy5yb290Q29udGV4dD17aWQ6MCxmcmFtZU5hbWU6XCJcIixpdGVyYXRpb25JZDowfSx0aGlzLmNvbnRleHRzPVt0aGlzLnJvb3RDb250ZXh0XSx0aGlzLmxhc3RJZD0wLHRoaXMuZ2VuZXJhdGVDdXJyZW50Q29udGV4dElkcygpfXJldHVybiBlLnByb3RvdHlwZS5uZXdGcmFtZT1mdW5jdGlvbihlLHQpe3JldHVybntpZDplLGZyYW1lTmFtZTp0LGl0ZXJhdGlvbklkOjB9fSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5wcm90b3R5cGUsXCJjdXJyZW50Q29udGV4dFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb250ZXh0c30sc2V0OmZ1bmN0aW9uKGUpe3RoaXMuY29udGV4dHMhPT1lJiYodGhpcy5jb250ZXh0cz1lLHRoaXMuZ2VuZXJhdGVDdXJyZW50Q29udGV4dElkcygpKX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5wcm90b3R5cGUsXCJjdXJyZW50Q29udGV4dElkXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9jdXJyZW50Q29udGV4dElkc1swXX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5wcm90b3R5cGUsXCJjdXJyZW50Q29udGV4dElkc1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fY3VycmVudENvbnRleHRJZHN9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksZS5wcm90b3R5cGUuZ2VuZXJhdGVDdXJyZW50Q29udGV4dElkcz1mdW5jdGlvbigpe2Zvcih2YXIgZT1bXSx0PTA7dDx0aGlzLmNvbnRleHRzLmxlbmd0aC0xO3QrKyl7dmFyIGE9dGhpcy5jb250ZXh0cy5zbGljZSgwLHRoaXMuY29udGV4dHMubGVuZ3RoLXQpO2UucHVzaCh0aGlzLmNvbnRleHRJZGZvckNvbnRleHRzKGEpKX1lLnB1c2goXCJcIiksdGhpcy5fY3VycmVudENvbnRleHRJZHM9ZX0sZS5wcm90b3R5cGUuY29udGV4dElkZm9yQ29udGV4dHM9ZnVuY3Rpb24oZSl7cmV0dXJuIGU/ZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIDA9PT1lLmlkJiYwPT09ZS5pdGVyYXRpb25JZD9cIlwiOmUuZnJhbWVOYW1lK1wiLVwiK2UuaXRlcmF0aW9uSWR9KS5qb2luKFwiL1wiKTpcIlwifSxlLnByb3RvdHlwZS5lbnRlckZyYW1lPWZ1bmN0aW9uKGUpe3RoaXMuY29udGV4dHMmJih0aGlzLmxhc3RJZCsrLHRoaXMuY29udGV4dHM9dGhpcy5jb250ZXh0cy5zbGljZSgpLHRoaXMuY29udGV4dHMucHVzaCh0aGlzLm5ld0ZyYW1lKHRoaXMubGFzdElkLGUpKSx0aGlzLl9jdXJyZW50Q29udGV4dElkcy51bnNoaWZ0KHRoaXMuY29udGV4dElkZm9yQ29udGV4dHModGhpcy5jb250ZXh0cykpKX0sZS5wcm90b3R5cGUuZXhpdEZyYW1lPWZ1bmN0aW9uKCl7aWYoISh0aGlzLmNvbnRleHRzJiZ0aGlzLmNvbnRleHRzLmxlbmd0aD4xKSl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZXhpdCBmcmFtZSwgdGhlIGNvbnRleHQgaXMgZW1wdHlcIik7dGhpcy5jb250ZXh0cz10aGlzLmNvbnRleHRzLnNsaWNlKCksdGhpcy5jb250ZXh0cy5zcGxpY2UoLTEpLHRoaXMuY3VycmVudENvbnRleHRJZHMuc2hpZnQoKX0sZS5wcm90b3R5cGUubmV4dEl0ZXJhdGlvbj1mdW5jdGlvbigpe2lmKCEodGhpcy5jb250ZXh0cyYmdGhpcy5jb250ZXh0cy5sZW5ndGg+MCkpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGluY3JlYXNlIGZyYW1lIGl0ZXJhdGlvbiwgdGhlIGNvbnRleHQgaXMgZW1wdHlcIik7dGhpcy5jb250ZXh0cz10aGlzLmNvbnRleHRzLnNsaWNlKCksdGhpcy5sYXN0SWQrKzt2YXIgZT1PYmplY3QuYXNzaWduKHt9LHRoaXMuY29udGV4dHNbdGhpcy5jb250ZXh0cy5sZW5ndGgtMV0pO2UuaXRlcmF0aW9uSWQrPTEsZS5pZD10aGlzLmxhc3RJZCx0aGlzLmNvbnRleHRzLnNwbGljZSgtMSwxLGUpLHRoaXMuX2N1cnJlbnRDb250ZXh0SWRzLnNwbGljZSgwLDEsdGhpcy5jb250ZXh0SWRmb3JDb250ZXh0cyh0aGlzLmNvbnRleHRzKSl9LGUucHJvdG90eXBlLmdldFdlaWdodD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy53ZWlnaHRNYXBbZV19LGUucHJvdG90eXBlLmFkZFRlbnNvckFycmF5PWZ1bmN0aW9uKGUpe3RoaXMudGVuc29yQXJyYXlNYXBbZS5pZF09ZX0sZS5wcm90b3R5cGUuZ2V0VGVuc29yQXJyYXk9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudGVuc29yQXJyYXlNYXBbZV19LGV9KCksR3JhcGhFeGVjdXRvcj1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSl7dGhpcy5ncmFwaD1lLHRoaXMuY29tcGlsZWRNYXA9bmV3IE1hcCx0aGlzLl93ZWlnaHRNYXA9e30sdGhpcy5TRVBFUkFUT1I9XCIsXCIsdGhpcy5wbGFjZWhvbGRlcnM9ZS5wbGFjZWhvbGRlcnMsdGhpcy5fb3V0cHV0cz1lLm91dHB1dHMsdGhpcy5jb21waWxlKCl9cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcIndlaWdodE1hcFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fd2VpZ2h0TWFwfSxzZXQ6ZnVuY3Rpb24oZSl7dmFyIHQ9T2JqZWN0LmtleXMoZSkubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBlW3RdLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5pZH0pfSk7dGhpcy53ZWlnaHRJZHM9W10uY29uY2F0LmFwcGx5KFtdLHQpLHRoaXMuX3dlaWdodE1hcD1lfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcImlucHV0c1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wbGFjZWhvbGRlcnMubWFwKGZ1bmN0aW9uKGUpe3JldHVybntuYW1lOmUubmFtZSxzaGFwZTplLnBhcmFtcy5zaGFwZT9lLnBhcmFtcy5zaGFwZS52YWx1ZTp2b2lkIDAsZHR5cGU6ZS5wYXJhbXMuZHR5cGU/ZS5wYXJhbXMuZHR5cGUudmFsdWU6dm9pZCAwfX0pfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcIm91dHB1dHNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX291dHB1dHMubWFwKGZ1bmN0aW9uKGUpe3JldHVybntuYW1lOmUubmFtZSxzaGFwZTplLnBhcmFtcy5zaGFwZT9lLnBhcmFtcy5zaGFwZS52YWx1ZTp2b2lkIDAsZHR5cGU6ZS5wYXJhbXMuZHR5cGU/ZS5wYXJhbXMuZHR5cGUudmFsdWU6dm9pZCAwfX0pfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcImlucHV0Tm9kZXNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGxhY2Vob2xkZXJzLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5uYW1lfSl9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwib3V0cHV0Tm9kZXNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMub3V0cHV0cy5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUubmFtZX0pfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcImlzQ29udHJvbEZsb3dNb2RlbFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ncmFwaC53aXRoQ29udHJvbEZsb3d9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwiaXNEeW5hbWljU2hhcGVNb2RlbFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ncmFwaC53aXRoRHluYW1pY1NoYXBlfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLGUucHJvdG90eXBlLmNvbXBpbGU9ZnVuY3Rpb24oZSl7aWYoIXRoaXMuZ3JhcGgud2l0aENvbnRyb2xGbG93JiYhdGhpcy5ncmFwaC53aXRoRHluYW1pY1NoYXBlKXt2YXIgdD1bXSxhPWV8fHRoaXMuZ3JhcGgucGxhY2Vob2xkZXJzLHI9YS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUubmFtZX0pLnNvcnQoKS5qb2luKHRoaXMuU0VQRVJBVE9SKTtpZighdGhpcy5jb21waWxlZE1hcC5nZXQocikpe2Zvcih2YXIgbj1hLmNvbmNhdCh0aGlzLmdyYXBoLndlaWdodHMpLG89e307bi5sZW5ndGg+MDspe3ZhciBzPW4ucG9wKCk7b1tzLm5hbWVdPSEwLHQucHVzaChzKSxzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oZSl7IW9bZS5uYW1lXSYmZS5pbnB1dE5hbWVzLmV2ZXJ5KGZ1bmN0aW9uKGUpe3ZhciB0PWdldE5vZGVOYW1lQW5kSW5kZXgoZSlbMF07cmV0dXJuIG9bdF19KSYmbi5wdXNoKGUpfSl9dGhpcy5jb21waWxlZE1hcC5zZXQocix0KX19fSxlLnByb3RvdHlwZS5leGVjdXRlPWZ1bmN0aW9uKGUsdCxhKXt2YXIgcj10aGlzO3ZvaWQgMD09PXQmJih0PSEwKTt2YXIgbj1PYmplY3Qua2V5cyhlKS5zb3J0KCk7dGhpcy5jaGVja0lucHV0KGUsdCksdGhpcy5jaGVja0lucHV0U2hhcGVBbmRUeXBlKGUsdCksdGhpcy5jb21waWxlKG4ubWFwKGZ1bmN0aW9uKGUpe3JldHVybiByLmdyYXBoLm5vZGVzW2VdfSkpO3ZhciBvPXRoaXMuY2FsY3VsYXRlT3V0cHV0cyhhKTt0aGlzLmNoZWNrT3V0cHV0KHRoaXMuY29tcGlsZWRNYXAuZ2V0KG4uam9pbih0aGlzLlNFUEVSQVRPUikpLG8pO3ZhciBzPXt9O3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7Zm9yKHZhciB0PW5ldyBFeGVjdXRpb25Db250ZXh0KHIuX3dlaWdodE1hcCxzKSxhPV9fYXNzaWduKHt9LHIud2VpZ2h0TWFwLGUpLGk9ci5nZXRGcm96ZW5UZW5zb3JJZHMoYSkscD17fSxtPXIuY29tcGlsZWRNYXAuZ2V0KG4uam9pbihyLlNFUEVSQVRPUikpLHU9MDt1PG0ubGVuZ3RoO3UrKyl7dmFyIGw9bVt1XTtpZihhW2wubmFtZV18fChhW2wubmFtZV09ZXhlY3V0ZU9wJDE1KGwsYSx0KSxyLmNoZWNrVGVuc29yRm9yRGlzcG9zYWwobC5uYW1lLGwsYSx0LGkscCkpLG8uZXZlcnkoZnVuY3Rpb24oZSl7cmV0dXJuISFhW2VdfSkpYnJlYWt9cmV0dXJuIHIuZmluZE91dHB1dHMoYSx0LG8pfSl9LGUucHJvdG90eXBlLmdldEZyb3plblRlbnNvcklkcz1mdW5jdGlvbihlKXt2YXIgdD1bXS5jb25jYXQuYXBwbHkoW10sT2JqZWN0LmtleXMoZSkubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBlW3RdfSkubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5pZH0pfSkpO3JldHVybiBuZXcgU2V0KHQpfSxlLnByb3RvdHlwZS5jaGVja1RlbnNvckZvckRpc3Bvc2FsPWZ1bmN0aW9uKGUsdCxhLHIsbixvKXtcImNvbnRyb2xcIiE9PXQuY2F0ZWdvcnkmJihhW2VdLmZvckVhY2goZnVuY3Rpb24oZSl7bnVsbCE9ZSYmKG9bZS5pZF09KG9bZS5pZF18fDApK3QuY2hpbGRyZW4ubGVuZ3RoKX0pLHQuaW5wdXRzLmZvckVhY2goZnVuY3Rpb24oZSl7aWYoXCJjb250cm9sXCIhPT1lLmNhdGVnb3J5KXt2YXIgdD1nZXRUZW5zb3JzRm9yQ3VycmVudENvbnRlbnh0KGUubmFtZSxhLHIpO251bGwhPXQmJnQuZm9yRWFjaChmdW5jdGlvbihlKXtpZihlJiYhbi5oYXMoZS5pZCkpe3ZhciB0PW9bZS5pZF07MT09PXQ/KGUuZGlzcG9zZSgpLGRlbGV0ZSBvW2UuaWRdKTpudWxsIT10JiZvW2UuaWRdLS19fSl9fSkpfSxlLnByb3RvdHlwZS5leGVjdXRlQXN5bmM9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBhLHIsbixvLHMsaSxwLG09dGhpcztyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbih1KXtzd2l0Y2godS5sYWJlbCl7Y2FzZSAwOnJldHVybiB0aGlzLmNoZWNrSW5wdXQoZSwhMSksdGhpcy5jaGVja0lucHV0U2hhcGVBbmRUeXBlKGUsITEpLGE9e30scj1uZXcgRXhlY3V0aW9uQ29udGV4dCh0aGlzLl93ZWlnaHRNYXAsYSksWzQsdGhpcy5leGVjdXRlV2l0aENvbnRyb2xGbG93KGUscildO2Nhc2UgMTpyZXR1cm4gbj11LnNlbnQoKSxvPXRoaXMuZmluZE91dHB1dHMobixyLHQpLHM9T2JqZWN0LmtleXMobykubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBvW2VdLmlkfSksaT1PYmplY3Qua2V5cyhlKS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIGVbdF0ubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLmlkfSl9KSxwPVtdLmNvbmNhdC5hcHBseShbXSxpKSxPYmplY3Qua2V5cyhuKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe25bZV0uZm9yRWFjaChmdW5jdGlvbihlKXtlJiYtMT09PXMuaW5kZXhPZihlLmlkKSYmLTE9PT1wLmluZGV4T2YoZS5pZCkmJi0xPT09bS53ZWlnaHRJZHMuaW5kZXhPZihlLmlkKSYmZS5kaXNwb3NlKCl9KX0pLFsyLG9dfX0pfSl9LGUucHJvdG90eXBlLmV4ZWN1dGVXaXRoQ29udHJvbEZsb3c9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBhLHIsbixvLHMsaSxwLG0sdT10aGlzO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGwpe3N3aXRjaChsLmxhYmVsKXtjYXNlIDA6YT1PYmplY3Qua2V5cyhlKSxyPWEubWFwKGZ1bmN0aW9uKGUpe3JldHVybiB1LmdyYXBoLm5vZGVzW2VdfSksbj1yLmNvbmNhdCh0aGlzLmdyYXBoLndlaWdodHMpLm1hcChmdW5jdGlvbihlKXtyZXR1cm57bm9kZTplLGNvbnRleHRzOnQuY3VycmVudENvbnRleHR9fSksbz1fX2Fzc2lnbih7fSx0aGlzLndlaWdodE1hcCxlKSxzPXt9LGk9dGhpcy5nZXRGcm96ZW5UZW5zb3JJZHMobykscD17fSxsLmxhYmVsPTE7Y2FzZSAxOnJldHVybiBuLmxlbmd0aD4wPyhtPXRoaXMucHJvY2Vzc1N0YWNrKHIsbix0LG8scCxpLHMpLFs0LFByb21pc2UuYWxsKG0pXSk6WzMsM107Y2FzZSAyOnJldHVybiBsLnNlbnQoKSxbMywxXTtjYXNlIDM6cmV0dXJuWzIsb119fSl9KX0sZS5wcm90b3R5cGUucHJvY2Vzc1N0YWNrPWZ1bmN0aW9uKGUsdCxhLHIsbixvLHMpe2Zvcih2YXIgaT10aGlzLHA9W10sbT1mdW5jdGlvbigpe3ZhciBtPXQucG9wKCk7YS5jdXJyZW50Q29udGV4dD1tLmNvbnRleHRzO3ZhciBsPVwiXCI7aWYoXCJlbnRlclwiPT09bS5ub2RlLm9wJiZnZXRQYXJhbVZhbHVlKFwiaXNDb25zdGFudFwiLG0ubm9kZSxyLGEpJiYobD1nZXROb2RlTmFtZUFuZEluZGV4KG0ubm9kZS5uYW1lLGEpWzBdKSwtMT09PWUuaW5kZXhPZihtLm5vZGUpKXt2YXIgZD1leGVjdXRlT3AkMTUobS5ub2RlLHIsYSk7bHx8KGw9Z2V0Tm9kZU5hbWVBbmRJbmRleChtLm5vZGUubmFtZSxhKVswXSk7dmFyIGM9YS5jdXJyZW50Q29udGV4dDtkIGluc3RhbmNlb2YgUHJvbWlzZT9wLnB1c2goZC50aGVuKGZ1bmN0aW9uKGUpe3JldHVybiByW2xdPWUsYS5jdXJyZW50Q29udGV4dD1jLGkuY2hlY2tUZW5zb3JGb3JEaXNwb3NhbChsLG0ubm9kZSxyLGEsbyxzKSxpLnByb2Nlc3NDaGlsZE5vZGVzKG0ubm9kZSx0LGEscixuKSxlfSkpOihyW2xdPWQsdS5jaGVja1RlbnNvckZvckRpc3Bvc2FsKGwsbS5ub2RlLHIsYSxvLHMpLHUucHJvY2Vzc0NoaWxkTm9kZXMobS5ub2RlLHQsYSxyLG4pKX1lbHNlIHUucHJvY2Vzc0NoaWxkTm9kZXMobS5ub2RlLHQsYSxyLG4pfSx1PXRoaXM7dC5sZW5ndGg+MDspbSgpO3JldHVybiBwfSxlLnByb3RvdHlwZS5wcm9jZXNzQ2hpbGROb2Rlcz1mdW5jdGlvbihlLHQsYSxyLG4pe2UuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgbz1nZXROb2RlTmFtZUFuZEluZGV4KGUubmFtZSxhKVswXTtuW29dfHwoXCJtZXJnZVwiPT09ZS5vcD9lLmlucHV0TmFtZXMuc29tZShmdW5jdGlvbihlKXtyZXR1cm4hIWdldFRlbnNvcihlLHIsYSl9KSYmKG5bb109ITAsdC5wdXNoKHtjb250ZXh0czphLmN1cnJlbnRDb250ZXh0LG5vZGU6ZX0pKTplLmlucHV0TmFtZXMuZXZlcnkoZnVuY3Rpb24oZSl7cmV0dXJuISFnZXRUZW5zb3IoZSxyLGEpfSkmJihuW29dPSEwLHQucHVzaCh7Y29udGV4dHM6YS5jdXJyZW50Q29udGV4dCxub2RlOmV9KSkpfSl9LGUucHJvdG90eXBlLmNhbGN1bGF0ZU91dHB1dHM9ZnVuY3Rpb24oZSl7cmV0dXJuIWV8fGUgaW5zdGFuY2VvZiBBcnJheXx8KGU9W2VdKSxlfHx0aGlzLmdyYXBoLm91dHB1dHMubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLm5hbWV9KX0sZS5wcm90b3R5cGUuZmluZE91dHB1dHM9ZnVuY3Rpb24oZSx0LGEpe3JldHVybiB0aGlzLmNhbGN1bGF0ZU91dHB1dHMoYSkucmVkdWNlKGZ1bmN0aW9uKGEscil7cmV0dXJuIGFbcl09Z2V0VGVuc29yKHIsZSx0KSxhfSx7fSl9LGUucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt2YXIgZT10aGlzO09iamVjdC5rZXlzKHRoaXMud2VpZ2h0TWFwKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3JldHVybiBlLndlaWdodE1hcFt0XS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiBlLmRpc3Bvc2UoKX0pfSl9LGUucHJvdG90eXBlLmNoZWNrSW5wdXRTaGFwZUFuZFR5cGU9ZnVuY3Rpb24oZSx0KXt2b2lkIDA9PT10JiYodD0hMCksdGhpcy5wbGFjZWhvbGRlcnMuZm9yRWFjaChmdW5jdGlvbihhKXt2YXIgcj1lW2EubmFtZV07aWYodHx8cil7dmFyIG49clswXTtpZihhLnBhcmFtcy5zaGFwZSYmYS5wYXJhbXMuc2hhcGUudmFsdWUpe3ZhciBvPWEucGFyYW1zLnNoYXBlLnZhbHVlLHM9by5sZW5ndGg9PT1uLnNoYXBlLmxlbmd0aCYmbi5zaGFwZS5ldmVyeShmdW5jdGlvbihlLHQpe3JldHVybi0xPT09b1t0XXx8b1t0XT09PWV9KTt1dGlsLmFzc2VydChzLFwiVGhlIHNoYXBlIG9mIGRpY3RbJ1wiK2EubmFtZStcIiddIHByb3ZpZGVkIGluIG1vZGVsLmV4ZWN1dGUoZGljdCkgbXVzdCBiZSBbXCIrbytcIl0sIGJ1dCB3YXMgW1wiK24uc2hhcGUrXCJdXCIpfWEucGFyYW1zLmR0eXBlJiZhLnBhcmFtcy5kdHlwZS52YWx1ZSYmdXRpbC5hc3NlcnQobi5kdHlwZT09PWEucGFyYW1zLmR0eXBlLnZhbHVlLFwiVGhlIGR0eXBlIG9mIGRpY3RbJ1wiK2EubmFtZStcIiddIHByb3ZpZGVkIGluIG1vZGVsLmV4ZWN1dGUoZGljdCkgbXVzdCBiZSBcIithLnBhcmFtcy5kdHlwZS52YWx1ZStcIiwgYnV0IHdhcyBcIituLmR0eXBlKX19KX0sZS5wcm90b3R5cGUuY2hlY2tJbnB1dD1mdW5jdGlvbihlLHQpe3ZhciBhPXRoaXM7dm9pZCAwPT09dCYmKHQ9ITApO3ZhciByPU9iamVjdC5rZXlzKGUpLG49W10sbz1bXTt0aGlzLmlucHV0Tm9kZXMuZm9yRWFjaChmdW5jdGlvbihlKXstMT09PXIuaW5kZXhPZihlKSYmbi5wdXNoKGUpfSksci5mb3JFYWNoKGZ1bmN0aW9uKGUpey0xPT09YS5pbnB1dE5vZGVzLmluZGV4T2YoZSkmJm8ucHVzaChlKX0pO3ZhciBzPW8uZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiFhLmdyYXBoLm5vZGVzW2VdfSk7aWYobi5sZW5ndGg+MCYmdCl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZGljdCBwcm92aWRlZCBpbiBtb2RlbC5leGVjdXRlKGRpY3QpIGhhcyB0aGUga2V5cyBbXCIrcitcIl0sIGJ1dCBpcyBtaXNzaW5nIHRoZSByZXF1aXJlZCBrZXlzOiBbXCIrbitcIl0uXCIpO2lmKG8ubGVuZ3RoPjAmJnQpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGRpY3QgcHJvdmlkZWQgaW4gbW9kZWwuZXhlY3V0ZShkaWN0KSBoYXMgdW51c2VkIGtleXM6IFtcIitvK1wiXS4gUGxlYXNlIHByb3ZpZGUgb25seSB0aGUgZm9sbG93aW5nIGtleXM6IFtcIit0aGlzLmlucHV0Tm9kZXMrXCJdLlwiKTtpZihzLmxlbmd0aD4wKXRocm93IG5ldyBFcnJvcihcIlRoZSBkaWN0IHByb3ZpZGVkIGluIG1vZGVsLmV4ZWN1dGUoZGljdCkgaGFzIGtleXM6IFtcIitzK1wiXSBub3QgcGFydCBvZiBtb2RlbCBncmFwaC5cIil9LGUucHJvdG90eXBlLmNoZWNrT3V0cHV0PWZ1bmN0aW9uKGUsdCl7dmFyIGE9ZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUubmFtZX0pLHI9W107aWYodC5mb3JFYWNoKGZ1bmN0aW9uKGUpey0xPT09YS5pbmRleE9mKGUpJiZyLnB1c2goZSl9KSxyLmxlbmd0aD4wKXRocm93IG5ldyBFcnJvcihcIlRoZSBmb2xsb3dpbmcgb3V0cHV0cyBhcmUgbm90IGJlIGdlbmVyYXRlZCBieSB0aGUgZXhlY3V0aW9uOiBbXCIrcitcIl0uXCIpfSxlfSgpLEZyb3plbk1vZGVsPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQsYSl7dGhpcy5tb2RlbFVybD1lLHRoaXMud2VpZ2h0TWFuaWZlc3RVcmw9dCx0aGlzLnJlcXVlc3RPcHRpb249YSx0aGlzLnZlcnNpb249XCJuL2FcIn1yZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwibW9kZWxWZXJzaW9uXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnZlcnNpb259LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwiaW5wdXROb2Rlc1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5leGVjdXRvci5pbnB1dE5vZGVzfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcIm91dHB1dE5vZGVzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmV4ZWN1dG9yLm91dHB1dE5vZGVzfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcImlucHV0c1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5leGVjdXRvci5pbnB1dHN9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwib3V0cHV0c1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5leGVjdXRvci5vdXRwdXRzfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcIndlaWdodHNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZXhlY3V0b3Iud2VpZ2h0TWFwfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLGUucHJvdG90eXBlLmZpbmRJT0hhbmRsZXI9ZnVuY3Rpb24oKXt2YXIgZT1bdGhpcy5tb2RlbFVybCx0aGlzLndlaWdodE1hbmlmZXN0VXJsXTtpZih0aGlzLnJlcXVlc3RPcHRpb24pdGhpcy5oYW5kbGVyPWlvLmJyb3dzZXJIVFRQUmVxdWVzdChlLHRoaXMucmVxdWVzdE9wdGlvbik7ZWxzZXt2YXIgdD1pby5nZXRMb2FkSGFuZGxlcnMoZSk7aWYoMD09PXQubGVuZ3RoKXQucHVzaChpby5icm93c2VySFRUUFJlcXVlc3QoZSx0aGlzLnJlcXVlc3RPcHRpb24pKTtlbHNlIGlmKHQubGVuZ3RoPjEpdGhyb3cgbmV3IEVycm9yKFwiRm91bmQgbW9yZSB0aGFuIG9uZSAoXCIrdC5sZW5ndGgrXCIpIGxvYWQgaGFuZGxlcnMgZm9yIFVSTCAnXCIrW2VdK1wiJ1wiKTt0aGlzLmhhbmRsZXI9dFswXX19LGUucHJvdG90eXBlLmxvYWQ9ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBlLHQsYTtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOmlmKHRoaXMuZmluZElPSGFuZGxlcigpLG51bGw9PXRoaXMuaGFuZGxlci5sb2FkKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBwcm9jZWVkIHdpdGggbW9kZWwgbG9hZGluZyBiZWNhdXNlIHRoZSBJT0hhbmRsZXIgcHJvdmlkZWQgZG9lcyBub3QgaGF2ZSB0aGUgYGxvYWRgIG1ldGhvZCBpbXBsZW1lbnRlZC5cIik7cmV0dXJuWzQsdGhpcy5oYW5kbGVyLmxvYWQoKV07Y2FzZSAxOnJldHVybiBlPXIuc2VudCgpLHQ9Y29tcGlsZWRfYXBpXzEuR3JhcGhEZWYuZGVjb2RlKG5ldyBVaW50OEFycmF5KGUubW9kZWxUb3BvbG9neSkpLHRoaXMudmVyc2lvbj10LnZlcnNpb25zLnByb2R1Y2VyK1wiLlwiK3QudmVyc2lvbnMubWluQ29uc3VtZXIsYT1pby5kZWNvZGVXZWlnaHRzKGUud2VpZ2h0RGF0YSxlLndlaWdodFNwZWNzKSx0aGlzLmV4ZWN1dG9yPW5ldyBHcmFwaEV4ZWN1dG9yKE9wZXJhdGlvbk1hcHBlci5JbnN0YW5jZS50cmFuc2Zvcm1HcmFwaCh0KSksdGhpcy5leGVjdXRvci53ZWlnaHRNYXA9dGhpcy5jb252ZXJ0VGVuc29yTWFwVG9UZW5zb3JzTWFwKGEpLFsyLCEwXX19KX0pfSxlLnByb3RvdHlwZS5wcmVkaWN0PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuZXhlY3V0ZV8oZSwhMCx0aGlzLm91dHB1dE5vZGVzKX0sZS5wcm90b3R5cGUuY29uc3RydWN0VGVuc29yTWFwPWZ1bmN0aW9uKGUpe3ZhciB0PWUgaW5zdGFuY2VvZiBUZW5zb3I/W2VdOmU7aWYodC5sZW5ndGghPT10aGlzLmlucHV0Tm9kZXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIklucHV0IHRlbnNvciBjb3VudCBtaXNtYXRjaCx0aGUgZnJvemVuIG1vZGVsIGhhcyBcIit0aGlzLmlucHV0Tm9kZXMubGVuZ3RoK1wiIHBsYWNlaG9sZGVycywgd2hpbGUgdGhlcmUgYXJlIFwiK3QubGVuZ3RoK1wiIGlucHV0IHRlbnNvcnMuXCIpO3JldHVybiB0aGlzLmlucHV0Tm9kZXMucmVkdWNlKGZ1bmN0aW9uKGUsYSxyKXtyZXR1cm4gZVthXT10W3JdLGV9LHt9KX0sZS5wcm90b3R5cGUuZXhlY3V0ZT1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLmV4ZWN1dGVfKGUsITEsdCl9LGUucHJvdG90eXBlLmV4ZWN1dGVfPWZ1bmN0aW9uKGUsdCxhKXtpZih2b2lkIDA9PT10JiYodD0hMCksYT1hfHx0aGlzLm91dHB1dE5vZGVzLChlIGluc3RhbmNlb2YgVGVuc29yfHxBcnJheS5pc0FycmF5KGUpKSYmKGU9dGhpcy5jb25zdHJ1Y3RUZW5zb3JNYXAoZSkpLHRoaXMuZXhlY3V0b3IuaXNDb250cm9sRmxvd01vZGVsfHx0aGlzLmV4ZWN1dG9yLmlzRHluYW1pY1NoYXBlTW9kZWwpdGhyb3cgbmV3IEVycm9yKFwiVGhlIG1vZGVsIGNvbnRhaW5zIGNvbnRyb2wgZmxvdyBvciBkeW5hbWljIHNoYXBlIG9wcywgcGxlYXNlIHVzZSBleGVjdXRlQXN5bmMgbWV0aG9kXCIpO3ZhciByPXRoaXMuZXhlY3V0b3IuZXhlY3V0ZSh0aGlzLmNvbnZlcnRUZW5zb3JNYXBUb1RlbnNvcnNNYXAoZSksdCxhKSxuPU9iamVjdC5rZXlzKHIpO3JldHVybiBBcnJheS5pc0FycmF5KGEpJiZhLmxlbmd0aD4xP2EubWFwKGZ1bmN0aW9uKGUpe3JldHVybiByW2VdfSk6cltuWzBdXX0sZS5wcm90b3R5cGUuZXhlY3V0ZUFzeW5jPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgYSxyO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKG4pe3N3aXRjaChuLmxhYmVsKXtjYXNlIDA6aWYoIXRoaXMuZXhlY3V0b3IuaXNDb250cm9sRmxvd01vZGVsJiYhdGhpcy5leGVjdXRvci5pc0R5bmFtaWNTaGFwZU1vZGVsKXRocm93IG5ldyBFcnJvcihcIlRoZSBtb2RlbCBkb2VzIG5vdCBjb250YWluIGNvbnRyb2wgZmxvdyBvciBkeW5hbWljIHNoYXBlIG9wcywgcGxlYXNlIHVzZSBleGVjdXRlIG1ldGhvZCBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlLlwiKTtyZXR1cm4gdD10fHx0aGlzLm91dHB1dE5vZGVzLChlIGluc3RhbmNlb2YgVGVuc29yfHxBcnJheS5pc0FycmF5KGUpKSYmKGU9dGhpcy5jb25zdHJ1Y3RUZW5zb3JNYXAoZSkpLFs0LHRoaXMuZXhlY3V0b3IuZXhlY3V0ZUFzeW5jKHRoaXMuY29udmVydFRlbnNvck1hcFRvVGVuc29yc01hcChlKSx0KV07Y2FzZSAxOnJldHVybiBhPW4uc2VudCgpLHI9T2JqZWN0LmtleXMoYSksWzIsQXJyYXkuaXNBcnJheSh0KSYmdC5sZW5ndGg+MT90Lm1hcChmdW5jdGlvbihlKXtyZXR1cm4gYVtlXX0pOmFbclswXV1dfX0pfSl9LGUucHJvdG90eXBlLmNvbnZlcnRUZW5zb3JNYXBUb1RlbnNvcnNNYXA9ZnVuY3Rpb24oZSl7cmV0dXJuIE9iamVjdC5rZXlzKGUpLnJlZHVjZShmdW5jdGlvbih0LGEpe3JldHVybiB0W2FdPVtlW2FdXSx0fSx7fSl9LGUucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt0aGlzLmV4ZWN1dG9yLmRpc3Bvc2UoKX0sZX0oKTtmdW5jdGlvbiBsb2FkRnJvemVuTW9kZWwoZSx0LGEpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHI7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24obil7c3dpdGNoKG4ubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCwocj1uZXcgRnJvemVuTW9kZWwoZSx0LGEpKS5sb2FkKCldO2Nhc2UgMTpyZXR1cm4gbi5zZW50KCksWzIscl19fSl9KX12YXIgdmVyc2lvbj1cIjAuNi43XCI7ZXhwb3J0e0Zyb3plbk1vZGVsLGxvYWRGcm96ZW5Nb2RlbCx2ZXJzaW9uIGFzIHZlcnNpb25fY29udmVydGVyfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRmLWNvbnZlcnRlci5lc20uanMubWFwXG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgZXh0ZW5kU3RhdGljcz1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fHtfX3Byb3RvX186W119aW5zdGFuY2VvZiBBcnJheSYmZnVuY3Rpb24oZSx0KXtlLl9fcHJvdG9fXz10fXx8ZnVuY3Rpb24oZSx0KXtmb3IodmFyIHIgaW4gdCl0Lmhhc093blByb3BlcnR5KHIpJiYoZVtyXT10W3JdKX07ZnVuY3Rpb24gX19leHRlbmRzKGUsdCl7ZnVuY3Rpb24gcigpe3RoaXMuY29uc3RydWN0b3I9ZX1leHRlbmRTdGF0aWNzKGUsdCksZS5wcm90b3R5cGU9bnVsbD09PXQ/T2JqZWN0LmNyZWF0ZSh0KTooci5wcm90b3R5cGU9dC5wcm90b3R5cGUsbmV3IHIpfXZhciBfX2Fzc2lnbj1PYmplY3QuYXNzaWdufHxmdW5jdGlvbihlKXtmb3IodmFyIHQscj0xLG49YXJndW1lbnRzLmxlbmd0aDtyPG47cisrKWZvcih2YXIgbyBpbiB0PWFyZ3VtZW50c1tyXSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxvKSYmKGVbb109dFtvXSk7cmV0dXJuIGV9O2Z1bmN0aW9uIF9fYXdhaXRlcihlLHQscixuKXtyZXR1cm4gbmV3KHJ8fChyPVByb21pc2UpKShmdW5jdGlvbihvLGEpe2Z1bmN0aW9uIGkoZSl7dHJ5e3Uobi5uZXh0KGUpKX1jYXRjaChlKXthKGUpfX1mdW5jdGlvbiBzKGUpe3RyeXt1KG4udGhyb3coZSkpfWNhdGNoKGUpe2EoZSl9fWZ1bmN0aW9uIHUoZSl7ZS5kb25lP28oZS52YWx1ZSk6bmV3IHIoZnVuY3Rpb24odCl7dChlLnZhbHVlKX0pLnRoZW4oaSxzKX11KChuPW4uYXBwbHkoZSx0fHxbXSkpLm5leHQoKSl9KX1mdW5jdGlvbiBfX2dlbmVyYXRvcihlLHQpe3ZhciByLG4sbyxhLGk9e2xhYmVsOjAsc2VudDpmdW5jdGlvbigpe2lmKDEmb1swXSl0aHJvdyBvWzFdO3JldHVybiBvWzFdfSx0cnlzOltdLG9wczpbXX07cmV0dXJuIGE9e25leHQ6cygwKSx0aHJvdzpzKDEpLHJldHVybjpzKDIpfSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJihhW1N5bWJvbC5pdGVyYXRvcl09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30pLGE7ZnVuY3Rpb24gcyhhKXtyZXR1cm4gZnVuY3Rpb24ocyl7cmV0dXJuIGZ1bmN0aW9uKGEpe2lmKHIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7Zm9yKDtpOyl0cnl7aWYocj0xLG4mJihvPTImYVswXT9uLnJldHVybjphWzBdP24udGhyb3d8fCgobz1uLnJldHVybikmJm8uY2FsbChuKSwwKTpuLm5leHQpJiYhKG89by5jYWxsKG4sYVsxXSkpLmRvbmUpcmV0dXJuIG87c3dpdGNoKG49MCxvJiYoYT1bMiZhWzBdLG8udmFsdWVdKSxhWzBdKXtjYXNlIDA6Y2FzZSAxOm89YTticmVhaztjYXNlIDQ6cmV0dXJuIGkubGFiZWwrKyx7dmFsdWU6YVsxXSxkb25lOiExfTtjYXNlIDU6aS5sYWJlbCsrLG49YVsxXSxhPVswXTtjb250aW51ZTtjYXNlIDc6YT1pLm9wcy5wb3AoKSxpLnRyeXMucG9wKCk7Y29udGludWU7ZGVmYXVsdDppZighKG89KG89aS50cnlzKS5sZW5ndGg+MCYmb1tvLmxlbmd0aC0xXSkmJig2PT09YVswXXx8Mj09PWFbMF0pKXtpPTA7Y29udGludWV9aWYoMz09PWFbMF0mJighb3x8YVsxXT5vWzBdJiZhWzFdPG9bM10pKXtpLmxhYmVsPWFbMV07YnJlYWt9aWYoNj09PWFbMF0mJmkubGFiZWw8b1sxXSl7aS5sYWJlbD1vWzFdLG89YTticmVha31pZihvJiZpLmxhYmVsPG9bMl0pe2kubGFiZWw9b1syXSxpLm9wcy5wdXNoKGEpO2JyZWFrfW9bMl0mJmkub3BzLnBvcCgpLGkudHJ5cy5wb3AoKTtjb250aW51ZX1hPXQuY2FsbChlLGkpfWNhdGNoKGUpe2E9WzYsZV0sbj0wfWZpbmFsbHl7cj1vPTB9aWYoNSZhWzBdKXRocm93IGFbMV07cmV0dXJue3ZhbHVlOmFbMF0/YVsxXTp2b2lkIDAsZG9uZTohMH19KFthLHNdKX19fXZhciBjb250ZXh0cz17fSxXRUJHTF9BVFRSSUJVVEVTPXthbHBoYTohMSxhbnRpYWxpYXM6ITEscHJlbXVsdGlwbGllZEFscGhhOiExLHByZXNlcnZlRHJhd2luZ0J1ZmZlcjohMSxkZXB0aDohMSxzdGVuY2lsOiExLGZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQ6ITB9O2Z1bmN0aW9uIGdldFdlYkdMQ29udGV4dChlKXtlIGluIGNvbnRleHRzfHwoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKS5hZGRFdmVudExpc3RlbmVyKFwid2ViZ2xjb250ZXh0bG9zdFwiLGZ1bmN0aW9uKHQpe3QucHJldmVudERlZmF1bHQoKSxkZWxldGUgY29udGV4dHNbZV19LCExKSxjb250ZXh0c1tlXT1nZXRXZWJHTFJlbmRlcmluZ0NvbnRleHQoZSkpO3ZhciB0PWNvbnRleHRzW2VdO3JldHVybiB0LmlzQ29udGV4dExvc3QoKT8oZGVsZXRlIGNvbnRleHRzW2VdLGdldFdlYkdMQ29udGV4dChlKSk6KHQuZGlzYWJsZSh0LkRFUFRIX1RFU1QpLHQuZGlzYWJsZSh0LlNURU5DSUxfVEVTVCksdC5kaXNhYmxlKHQuQkxFTkQpLHQuZGlzYWJsZSh0LkRJVEhFUiksdC5kaXNhYmxlKHQuUE9MWUdPTl9PRkZTRVRfRklMTCksdC5kaXNhYmxlKHQuU0FNUExFX0NPVkVSQUdFKSx0LmVuYWJsZSh0LlNDSVNTT1JfVEVTVCksdC5lbmFibGUodC5DVUxMX0ZBQ0UpLHQuY3VsbEZhY2UodC5CQUNLKSxjb250ZXh0c1tlXSl9ZnVuY3Rpb24gZ2V0V2ViR0xSZW5kZXJpbmdDb250ZXh0KGUpe2lmKDEhPT1lJiYyIT09ZSl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IFdlYkdMIHJlbmRlcmluZyBjb250ZXh0LCBXZWJHTCBpcyBkaXNhYmxlZC5cIik7dmFyIHQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtyZXR1cm4gMT09PWU/dC5nZXRDb250ZXh0KFwid2ViZ2xcIixXRUJHTF9BVFRSSUJVVEVTKXx8dC5nZXRDb250ZXh0KFwiZXhwZXJpbWVudGFsLXdlYmdsXCIsV0VCR0xfQVRUUklCVVRFUyk6dC5nZXRDb250ZXh0KFwid2ViZ2wyXCIsV0VCR0xfQVRUUklCVVRFUyl9ZnVuY3Rpb24gaXNNb2JpbGUoKXt2YXIgZT1uYXZpZ2F0b3IudXNlckFnZW50fHxuYXZpZ2F0b3IudmVuZG9yfHx3aW5kb3cub3BlcmE7cmV0dXJuLyhhbmRyb2lkfGJiXFxkK3xtZWVnbykuK21vYmlsZXxhdmFudGdvfGJhZGFcXC98YmxhY2tiZXJyeXxibGF6ZXJ8Y29tcGFsfGVsYWluZXxmZW5uZWN8aGlwdG9wfGllbW9iaWxlfGlwKGhvbmV8b2QpfGlyaXN8a2luZGxlfGxnZSB8bWFlbW98bWlkcHxtbXB8bW9iaWxlLitmaXJlZm94fG5ldGZyb250fG9wZXJhIG0ob2J8aW4paXxwYWxtKCBvcyk/fHBob25lfHAoaXhpfHJlKVxcL3xwbHVja2VyfHBvY2tldHxwc3B8c2VyaWVzKDR8NikwfHN5bWJpYW58dHJlb3x1cFxcLihicm93c2VyfGxpbmspfHZvZGFmb25lfHdhcHx3aW5kb3dzIGNlfHhkYXx4aWluby9pLnRlc3QoZSl8fC8xMjA3fDYzMTB8NjU5MHwzZ3NvfDR0aHB8NTBbMS02XWl8Nzcwc3w4MDJzfGEgd2F8YWJhY3xhYyhlcnxvb3xzXFwtKXxhaShrb3xybil8YWwoYXZ8Y2F8Y28pfGFtb2l8YW4oZXh8bnl8eXcpfGFwdHV8YXIoY2h8Z28pfGFzKHRlfHVzKXxhdHR3fGF1KGRpfFxcLW18ciB8cyApfGF2YW58YmUoY2t8bGx8bnEpfGJpKGxifHJkKXxibChhY3xheil8YnIoZXx2KXd8YnVtYnxid1xcLShufHUpfGM1NVxcL3xjYXBpfGNjd2F8Y2RtXFwtfGNlbGx8Y2h0bXxjbGRjfGNtZFxcLXxjbyhtcHxuZCl8Y3Jhd3xkYShpdHxsbHxuZyl8ZGJ0ZXxkY1xcLXN8ZGV2aXxkaWNhfGRtb2J8ZG8oY3xwKW98ZHMoMTJ8XFwtZCl8ZWwoNDl8YWkpfGVtKGwyfHVsKXxlcihpY3xrMCl8ZXNsOHxleihbNC03XTB8b3N8d2F8emUpfGZldGN8Zmx5KFxcLXxfKXxnMSB1fGc1NjB8Z2VuZXxnZlxcLTV8Z1xcLW1vfGdvKFxcLnd8b2QpfGdyKGFkfHVuKXxoYWllfGhjaXR8aGRcXC0obXxwfHQpfGhlaVxcLXxoaShwdHx0YSl8aHAoIGl8aXApfGhzXFwtY3xodChjKFxcLXwgfF98YXxnfHB8c3x0KXx0cCl8aHUoYXd8dGMpfGlcXC0oMjB8Z298bWEpfGkyMzB8aWFjKCB8XFwtfFxcLyl8aWJyb3xpZGVhfGlnMDF8aWtvbXxpbTFrfGlubm98aXBhcXxpcmlzfGphKHR8dilhfGpicm98amVtdXxqaWdzfGtkZGl8a2VqaXxrZ3QoIHxcXC8pfGtsb258a3B0IHxrd2NcXC18a3lvKGN8ayl8bGUobm98eGkpfGxnKCBnfFxcLyhrfGx8dSl8NTB8NTR8XFwtW2Etd10pfGxpYnd8bHlueHxtMVxcLXd8bTNnYXxtNTBcXC98bWEodGV8dWl8eG8pfG1jKDAxfDIxfGNhKXxtXFwtY3J8bWUocmN8cmkpfG1pKG84fG9hfHRzKXxtbWVmfG1vKDAxfDAyfGJpfGRlfGRvfHQoXFwtfCB8b3x2KXx6eil8bXQoNTB8cDF8diApfG13YnB8bXl3YXxuMTBbMC0yXXxuMjBbMi0zXXxuMzAoMHwyKXxuNTAoMHwyfDUpfG43KDAoMHwxKXwxMCl8bmUoKGN8bSlcXC18b258dGZ8d2Z8d2d8d3QpfG5vayg2fGkpfG56cGh8bzJpbXxvcCh0aXx3dil8b3Jhbnxvd2cxfHA4MDB8cGFuKGF8ZHx0KXxwZHhnfHBnKDEzfFxcLShbMS04XXxjKSl8cGhpbHxwaXJlfHBsKGF5fHVjKXxwblxcLTJ8cG8oY2t8cnR8c2UpfHByb3h8cHNpb3xwdFxcLWd8cWFcXC1hfHFjKDA3fDEyfDIxfDMyfDYwfFxcLVsyLTddfGlcXC0pfHF0ZWt8cjM4MHxyNjAwfHJha3N8cmltOXxybyh2ZXx6byl8czU1XFwvfHNhKGdlfG1hfG1tfG1zfG55fHZhKXxzYygwMXxoXFwtfG9vfHBcXC0pfHNka1xcL3xzZShjKFxcLXwwfDEpfDQ3fG1jfG5kfHJpKXxzZ2hcXC18c2hhcnxzaWUoXFwtfG0pfHNrXFwtMHxzbCg0NXxpZCl8c20oYWx8YXJ8YjN8aXR8dDUpfHNvKGZ0fG55KXxzcCgwMXxoXFwtfHZcXC18diApfHN5KDAxfG1iKXx0MigxOHw1MCl8dDYoMDB8MTB8MTgpfHRhKGd0fGxrKXx0Y2xcXC18dGRnXFwtfHRlbChpfG0pfHRpbVxcLXx0XFwtbW98dG8ocGx8c2gpfHRzKDcwfG1cXC18bTN8bTUpfHR4XFwtOXx1cChcXC5ifGcxfHNpKXx1dHN0fHY0MDB8djc1MHx2ZXJpfHZpKHJnfHRlKXx2ayg0MHw1WzAtM118XFwtdil8dm00MHx2b2RhfHZ1bGN8dngoNTJ8NTN8NjB8NjF8NzB8ODB8ODF8ODN8ODV8OTgpfHczYyhcXC18ICl8d2ViY3x3aGl0fHdpKGcgfG5jfG53KXx3bWxifHdvbnV8eDcwMHx5YXNcXC18eW91cnx6ZXRvfHp0ZVxcLS9pLnRlc3QoZS5zdWJzdHIoMCw0KSl9ZnVuY3Rpb24gc2h1ZmZsZShlKXtmb3IodmFyIHQ9ZS5sZW5ndGgscj0wLG49MDt0PjA7KW49TWF0aC5yYW5kb20oKSp0fDAscj1lWy0tdF0sZVt0XT1lW25dLGVbbl09cn1mdW5jdGlvbiBjbGFtcChlLHQscil7cmV0dXJuIE1hdGgubWF4KGUsTWF0aC5taW4odCxyKSl9ZnVuY3Rpb24gbmVhcmVzdExhcmdlckV2ZW4oZSl7cmV0dXJuIGUlMj09MD9lOmUrMX1mdW5jdGlvbiBzdW0oZSl7Zm9yKHZhciB0PTAscj0wO3I8ZS5sZW5ndGg7cisrKXQrPWVbcl07cmV0dXJuIHR9ZnVuY3Rpb24gcmFuZFVuaWZvcm0oZSx0KXt2YXIgcj1NYXRoLnJhbmRvbSgpO3JldHVybiB0KnIrKDEtcikqZX1mdW5jdGlvbiBkaXN0U3F1YXJlZChlLHQpe2Zvcih2YXIgcj0wLG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIG89TnVtYmVyKGVbbl0pLU51bWJlcih0W25dKTtyKz1vKm99cmV0dXJuIHJ9ZnVuY3Rpb24gYXNzZXJ0KGUsdCl7aWYoIWUpdGhyb3cgbmV3IEVycm9yKFwic3RyaW5nXCI9PXR5cGVvZiB0P3Q6dCgpKX1mdW5jdGlvbiBhc3NlcnRTaGFwZXNNYXRjaChlLHQscil7dm9pZCAwPT09ciYmKHI9XCJcIiksYXNzZXJ0KGFycmF5c0VxdWFsKGUsdCkscitcIiBTaGFwZXMgXCIrZStcIiBhbmQgXCIrdCtcIiBtdXN0IG1hdGNoXCIpfWZ1bmN0aW9uIGFzc2VydE5vbk51bGwoZSl7YXNzZXJ0KG51bGwhPWUsXCJUaGUgaW5wdXQgdG8gdGhlIHRlbnNvciBjb25zdHJ1Y3RvciBtdXN0IGJlIGEgbm9uLW51bGwgdmFsdWUuXCIpfWZ1bmN0aW9uIGZsYXR0ZW4oZSx0KXtpZih2b2lkIDA9PT10JiYodD1bXSksQXJyYXkuaXNBcnJheShlKSlmb3IodmFyIHI9MDtyPGUubGVuZ3RoOysrcilmbGF0dGVuKGVbcl0sdCk7ZWxzZSB0LnB1c2goZSk7cmV0dXJuIHR9ZnVuY3Rpb24gc2l6ZUZyb21TaGFwZShlKXtpZigwPT09ZS5sZW5ndGgpcmV0dXJuIDE7Zm9yKHZhciB0PWVbMF0scj0xO3I8ZS5sZW5ndGg7cisrKXQqPWVbcl07cmV0dXJuIHR9ZnVuY3Rpb24gaXNTY2FsYXJTaGFwZShlKXtyZXR1cm4gMD09PWUubGVuZ3RofWZ1bmN0aW9uIGFycmF5c0VxdWFsKGUsdCl7aWYoZT09PXQpcmV0dXJuITA7aWYobnVsbD09ZXx8bnVsbD09dClyZXR1cm4hMTtpZihlLmxlbmd0aCE9PXQubGVuZ3RoKXJldHVybiExO2Zvcih2YXIgcj0wO3I8ZS5sZW5ndGg7cisrKWlmKGVbcl0hPT10W3JdKXJldHVybiExO3JldHVybiEwfWZ1bmN0aW9uIGlzSW50KGUpe3JldHVybiBlJTE9PTB9ZnVuY3Rpb24gdGFuaChlKXtpZihudWxsIT1NYXRoLnRhbmgpcmV0dXJuIE1hdGgudGFuaChlKTtpZihlPT09MS8wKXJldHVybiAxO2lmKGU9PT0tMS8wKXJldHVybi0xO3ZhciB0PU1hdGguZXhwKDIqZSk7cmV0dXJuKHQtMSkvKHQrMSl9ZnVuY3Rpb24gc2l6ZVRvU3F1YXJpc2hTaGFwZShlKXtmb3IodmFyIHQ9TWF0aC5mbG9vcihNYXRoLnNxcnQoZSkpO3Q+MTstLXQpaWYoZSV0PT0wKXJldHVyblt0LGUvdF07cmV0dXJuWzEsZV19ZnVuY3Rpb24gY3JlYXRlU2h1ZmZsZWRJbmRpY2VzKGUpe2Zvcih2YXIgdD1uZXcgVWludDMyQXJyYXkoZSkscj0wO3I8ZTsrK3IpdFtyXT1yO3JldHVybiBzaHVmZmxlKHQpLHR9ZnVuY3Rpb24gcmlnaHRQYWQoZSx0KXtyZXR1cm4gdDw9ZS5sZW5ndGg/ZTplK1wiIFwiLnJlcGVhdCh0LWUubGVuZ3RoKX1mdW5jdGlvbiByZXBlYXRlZFRyeShlLHQscil7cmV0dXJuIHZvaWQgMD09PXQmJih0PWZ1bmN0aW9uKGUpe3JldHVybiAwfSksbmV3IFByb21pc2UoZnVuY3Rpb24obixvKXt2YXIgYT0wLGk9ZnVuY3Rpb24oKXtpZihlKCkpbigpO2Vsc2V7dmFyIHM9dCgrK2EpO251bGwhPXImJmE+PXI/bygpOnNldFRpbWVvdXQoaSxzKX19O2koKX0pfWZ1bmN0aW9uIGluZmVyRnJvbUltcGxpY2l0U2hhcGUoZSx0KXtmb3IodmFyIHI9MSxuPS0xLG89MDtvPGUubGVuZ3RoOysrbylpZihlW29dPj0wKXIqPWVbb107ZWxzZSBpZigtMT09PWVbb10pe2lmKC0xIT09bil0aHJvdyBFcnJvcihcIlNoYXBlcyBjYW4gb25seSBoYXZlIDEgaW1wbGljaXQgc2l6ZS4gRm91bmQgLTEgYXQgZGltIFwiK24rXCIgYW5kIGRpbSBcIitvKTtuPW99ZWxzZSBpZihlW29dPDApdGhyb3cgRXJyb3IoXCJTaGFwZXMgY2FuIG5vdCBiZSA8IDAuIEZvdW5kIFwiK2Vbb10rXCIgYXQgZGltIFwiK28pO2lmKC0xPT09bil7aWYodD4wJiZ0IT09cil0aHJvdyBFcnJvcihcIlNpemUoXCIrdCtcIikgbXVzdCBtYXRjaCB0aGUgcHJvZHVjdCBvZiBzaGFwZSBcIitlKTtyZXR1cm4gZX1pZigwPT09cil0aHJvdyBFcnJvcihcIkNhbm5vdCBpbmZlciB0aGUgbWlzc2luZyBzaXplIGluIFtcIitlK1wiXSB3aGVuIHRoZXJlIGFyZSAwIGVsZW1lbnRzXCIpO2lmKHQlciE9MCl0aHJvdyBFcnJvcihcIlRoZSBpbXBsaWNpdCBzaGFwZSBjYW4ndCBiZSBhIGZyYWN0aW9uYWwgbnVtYmVyLiBHb3QgXCIrdCtcIiAvIFwiK3IpO3ZhciBhPWUuc2xpY2UoKTtyZXR1cm4gYVtuXT10L3IsYX1mdW5jdGlvbiBzcXVlZXplU2hhcGUoZSx0KXtmb3IodmFyIHI9W10sbj1bXSxvPTAsYT0wO2E8ZS5sZW5ndGg7KythKXtpZihudWxsIT10KXtpZih0W29dPT09YSYmMSE9PWVbYV0pdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3Qgc3F1ZWV6ZSBheGlzIFwiK2ErXCIgc2luY2UgaXRzIGRpbSAnXCIrZVthXStcIicgaXMgbm90IDFcIik7KG51bGw9PXRbb118fHRbb10+YSkmJjE9PT1lW2FdJiYoci5wdXNoKGVbYV0pLG4ucHVzaChhKSksdFtvXTw9YSYmbysrfTEhPT1lW2FdJiYoci5wdXNoKGVbYV0pLG4ucHVzaChhKSl9cmV0dXJue25ld1NoYXBlOnIsa2VwdERpbXM6bn19ZnVuY3Rpb24gZ2V0VHlwZWRBcnJheUZyb21EVHlwZShlLHQpe3ZhciByPW51bGw7aWYobnVsbD09ZXx8XCJmbG9hdDMyXCI9PT1lKXI9bmV3IEZsb2F0MzJBcnJheSh0KTtlbHNlIGlmKFwiaW50MzJcIj09PWUpcj1uZXcgSW50MzJBcnJheSh0KTtlbHNle2lmKFwiYm9vbFwiIT09ZSl0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRhdGEgdHlwZSBcIitlKTtyPW5ldyBVaW50OEFycmF5KHQpfXJldHVybiByfWZ1bmN0aW9uIGNoZWNrQ29tcHV0YXRpb25Gb3JOYU4oZSx0LHIpe2lmKFwiZmxvYXQzMlwiPT09dClmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKylpZihpc05hTihlW25dKSl0aHJvdyBFcnJvcihcIlRoZSByZXN1bHQgb2YgdGhlICdcIityK1wiJyBoYXMgTmFOcy5cIil9ZnVuY3Rpb24gY2hlY2tDb252ZXJzaW9uRm9yTmFOKGUsdCl7aWYoXCJmbG9hdDMyXCIhPT10KWZvcih2YXIgcj0wO3I8ZS5sZW5ndGg7cisrKWlmKGlzTmFOKGVbcl0pKXRocm93IEVycm9yKFwiTmFOIGlzIG5vdCBhIHZhbGlkIHZhbHVlIGZvciBkdHlwZTogJ1wiK3QrXCInLlwiKX1mdW5jdGlvbiBoYXNFbmNvZGluZ0xvc3MoZSx0KXtyZXR1cm5cImNvbXBsZXg2NFwiIT09dCYmKChcImZsb2F0MzJcIiE9PXR8fFwiY29tcGxleDY0XCI9PT1lKSYmKChcImludDMyXCIhPT10fHxcImZsb2F0MzJcIj09PWV8fFwiY29tcGxleDY0XCI9PT1lKSYmKFwiYm9vbFwiIT09dHx8XCJib29sXCIhPT1lKSkpfWZ1bmN0aW9uIGNvcHlUeXBlZEFycmF5KGUsdCxyKXtpZihudWxsPT10fHxcImZsb2F0MzJcIj09PXR8fFwiY29tcGxleDY0XCI9PT10KXJldHVybiBuZXcgRmxvYXQzMkFycmF5KGUpO2lmKFwiaW50MzJcIj09PXQpcmV0dXJuIHImJmNoZWNrQ29udmVyc2lvbkZvck5hTihlLHQpLG5ldyBJbnQzMkFycmF5KGUpO2lmKFwiYm9vbFwiPT09dCl7Zm9yKHZhciBuPW5ldyBVaW50OEFycmF5KGUubGVuZ3RoKSxvPTA7bzxuLmxlbmd0aDsrK28pMCE9PU1hdGgucm91bmQoZVtvXSkmJihuW29dPTEpO3JldHVybiBufXRocm93IG5ldyBFcnJvcihcIlVua25vd24gZGF0YSB0eXBlIFwiK3QpfWZ1bmN0aW9uIGlzVHlwZWRBcnJheShlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheXx8ZSBpbnN0YW5jZW9mIEludDMyQXJyYXl8fGUgaW5zdGFuY2VvZiBVaW50OEFycmF5fWZ1bmN0aW9uIGJ5dGVzUGVyRWxlbWVudChlKXtpZihcImZsb2F0MzJcIj09PWV8fFwiaW50MzJcIj09PWUpcmV0dXJuIDQ7aWYoXCJjb21wbGV4NjRcIj09PWUpcmV0dXJuIDg7aWYoXCJib29sXCI9PT1lKXJldHVybiAxO3Rocm93IG5ldyBFcnJvcihcIlVua25vd24gZHR5cGUgXCIrZSl9ZnVuY3Rpb24gaXNGdW5jdGlvbihlKXtyZXR1cm4hIShlJiZlLmNvbnN0cnVjdG9yJiZlLmNhbGwmJmUuYXBwbHkpfWZ1bmN0aW9uIG5lYXJlc3REaXZpc29yKGUsdCl7Zm9yKHZhciByPXQ7cjxlOysrcilpZihlJXI9PTApcmV0dXJuIHI7cmV0dXJuIGV9ZnVuY3Rpb24gY29tcHV0ZVN0cmlkZXMoZSl7dmFyIHQ9ZS5sZW5ndGg7aWYodDwyKXJldHVybltdO3ZhciByPW5ldyBBcnJheSh0LTEpO3JbdC0yXT1lW3QtMV07Zm9yKHZhciBuPXQtMztuPj0wOy0tbilyW25dPXJbbisxXSplW24rMV07cmV0dXJuIHJ9ZnVuY3Rpb24gdG9UeXBlZEFycmF5KGUsdCxyKXtyZXR1cm4gbm9Db252ZXJzaW9uTmVlZGVkKGUsdCk/ZTooQXJyYXkuaXNBcnJheShlKSYmKGU9ZmxhdHRlbihlKSksY29weVR5cGVkQXJyYXkoZSx0LHIpKX1mdW5jdGlvbiBub0NvbnZlcnNpb25OZWVkZWQoZSx0KXtyZXR1cm4gZSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSYmXCJmbG9hdDMyXCI9PT10fHxlIGluc3RhbmNlb2YgSW50MzJBcnJheSYmXCJpbnQzMlwiPT09dHx8ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkmJlwiYm9vbFwiPT09dH1mdW5jdGlvbiBtYWtlT25lc1R5cGVkQXJyYXkoZSx0KXtmb3IodmFyIHI9bWFrZVplcm9zVHlwZWRBcnJheShlLHQpLG49MDtuPHIubGVuZ3RoO24rKylyW25dPTE7cmV0dXJuIHJ9ZnVuY3Rpb24gbWFrZVplcm9zVHlwZWRBcnJheShlLHQpe2lmKG51bGw9PXR8fFwiZmxvYXQzMlwiPT09dHx8XCJjb21wbGV4NjRcIj09PXQpcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoZSk7aWYoXCJpbnQzMlwiPT09dClyZXR1cm4gbmV3IEludDMyQXJyYXkoZSk7aWYoXCJib29sXCI9PT10KXJldHVybiBuZXcgVWludDhBcnJheShlKTt0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRhdGEgdHlwZSBcIit0KX1mdW5jdGlvbiBub3coKXtpZihcInVuZGVmaW5lZFwiIT10eXBlb2YgcGVyZm9ybWFuY2UpcmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpO2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBwcm9jZXNzKXt2YXIgZT1wcm9jZXNzLmhydGltZSgpO3JldHVybiAxZTMqZVswXStlWzFdLzFlNn10aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgbWVhc3VyZSB0aW1lIGluIHRoaXMgZW52aXJvbm1lbnQuIFlvdSBzaG91bGQgcnVuIHRmLmpzIGluIHRoZSBicm93c2VyIG9yIGluIE5vZGUuanNcIil9dmFyIHV0aWw9T2JqZWN0LmZyZWV6ZSh7c2h1ZmZsZTpzaHVmZmxlLGNsYW1wOmNsYW1wLG5lYXJlc3RMYXJnZXJFdmVuOm5lYXJlc3RMYXJnZXJFdmVuLHN1bTpzdW0scmFuZFVuaWZvcm06cmFuZFVuaWZvcm0sZGlzdFNxdWFyZWQ6ZGlzdFNxdWFyZWQsYXNzZXJ0OmFzc2VydCxhc3NlcnRTaGFwZXNNYXRjaDphc3NlcnRTaGFwZXNNYXRjaCxhc3NlcnROb25OdWxsOmFzc2VydE5vbk51bGwsZmxhdHRlbjpmbGF0dGVuLHNpemVGcm9tU2hhcGU6c2l6ZUZyb21TaGFwZSxpc1NjYWxhclNoYXBlOmlzU2NhbGFyU2hhcGUsYXJyYXlzRXF1YWw6YXJyYXlzRXF1YWwsaXNJbnQ6aXNJbnQsdGFuaDp0YW5oLHNpemVUb1NxdWFyaXNoU2hhcGU6c2l6ZVRvU3F1YXJpc2hTaGFwZSxjcmVhdGVTaHVmZmxlZEluZGljZXM6Y3JlYXRlU2h1ZmZsZWRJbmRpY2VzLHJpZ2h0UGFkOnJpZ2h0UGFkLHJlcGVhdGVkVHJ5OnJlcGVhdGVkVHJ5LGluZmVyRnJvbUltcGxpY2l0U2hhcGU6aW5mZXJGcm9tSW1wbGljaXRTaGFwZSxzcXVlZXplU2hhcGU6c3F1ZWV6ZVNoYXBlLGdldFR5cGVkQXJyYXlGcm9tRFR5cGU6Z2V0VHlwZWRBcnJheUZyb21EVHlwZSxjaGVja0NvbXB1dGF0aW9uRm9yTmFOOmNoZWNrQ29tcHV0YXRpb25Gb3JOYU4sY2hlY2tDb252ZXJzaW9uRm9yTmFOOmNoZWNrQ29udmVyc2lvbkZvck5hTixoYXNFbmNvZGluZ0xvc3M6aGFzRW5jb2RpbmdMb3NzLGlzVHlwZWRBcnJheTppc1R5cGVkQXJyYXksYnl0ZXNQZXJFbGVtZW50OmJ5dGVzUGVyRWxlbWVudCxpc0Z1bmN0aW9uOmlzRnVuY3Rpb24sbmVhcmVzdERpdmlzb3I6bmVhcmVzdERpdmlzb3IsY29tcHV0ZVN0cmlkZXM6Y29tcHV0ZVN0cmlkZXMsdG9UeXBlZEFycmF5OnRvVHlwZWRBcnJheSxtYWtlT25lc1R5cGVkQXJyYXk6bWFrZU9uZXNUeXBlZEFycmF5LG1ha2VaZXJvc1R5cGVkQXJyYXk6bWFrZVplcm9zVHlwZWRBcnJheSxub3c6bm93fSksUHJvZmlsZXI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCl7dGhpcy5iYWNrZW5kVGltZXI9ZSx0aGlzLmxvZ2dlcj10LG51bGw9PXQmJih0aGlzLmxvZ2dlcj1uZXcgTG9nZ2VyKX1yZXR1cm4gZS5wcm90b3R5cGUucHJvZmlsZUtlcm5lbD1mdW5jdGlvbihlLHQpe3ZhciByLG49dGhpcyxvPXRoaXMuYmFja2VuZFRpbWVyLnRpbWUoZnVuY3Rpb24oKXtyPXQoKX0pO3JldHVybihBcnJheS5pc0FycmF5KHIpP3I6W3JdKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3ZhciByPXQuZGF0YVN5bmMoKTtjaGVja0NvbXB1dGF0aW9uRm9yTmFOKHIsdC5kdHlwZSxlKSxvLnRoZW4oZnVuY3Rpb24obyl7dmFyIGE9XCJcIjtudWxsIT1vLmdldEV4dHJhUHJvZmlsZUluZm8mJihhPW8uZ2V0RXh0cmFQcm9maWxlSW5mbygpKSxuLmxvZ2dlci5sb2dLZXJuZWxQcm9maWxlKGUsdCxyLG8ua2VybmVsTXMsYSl9KX0pLHJ9LGV9KCksTG9nZ2VyPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpe31yZXR1cm4gZS5wcm90b3R5cGUubG9nS2VybmVsUHJvZmlsZT1mdW5jdGlvbihlLHQscixuLG8pe3ZhciBhPXJpZ2h0UGFkKG4rXCJtc1wiLDkpLGk9cmlnaHRQYWQoZSwyNSkscz10LnJhbmssdT10LnNpemUsbD1yaWdodFBhZCh0LnNoYXBlLnRvU3RyaW5nKCksMTQpO2NvbnNvbGUubG9nKFwiJWNcIitpK1wiXFx0JWNcIithK1wiXFx0JWNcIitzK1wiRCBcIitsK1wiXFx0JWNcIit1K1wiXFx0JWNcIitvLFwiZm9udC13ZWlnaHQ6Ym9sZFwiLFwiY29sb3I6cmVkXCIsXCJjb2xvcjpibHVlXCIsXCJjb2xvcjogb3JhbmdlXCIsXCJjb2xvcjogZ3JlZW5cIil9LGV9KCksRk9STUFUX0xJTUlUX05VTV9WQUxTPTIwLEZPUk1BVF9OVU1fRklSU1RfTEFTVF9WQUxTPTMsRk9STUFUX05VTV9TSUdfRElHSVRTPTc7ZnVuY3Rpb24gdGVuc29yVG9TdHJpbmcoZSx0LHIsbil7dmFyIG89Y29tcHV0ZVN0cmlkZXModCksYT1jb21wdXRlTWF4U2l6ZVBlckNvbHVtbihlLHQscixvKSxpPXQubGVuZ3RoLHM9c3ViVGVuc29yVG9TdHJpbmcoZSx0LHIsbyxhKSx1PVtcIlRlbnNvclwiXTtyZXR1cm4gbiYmKHUucHVzaChcIiAgZHR5cGU6IFwiK3IpLHUucHVzaChcIiAgcmFuazogXCIraSksdS5wdXNoKFwiICBzaGFwZTogW1wiK3QrXCJdXCIpLHUucHVzaChcIiAgdmFsdWVzOlwiKSksdS5wdXNoKHMubWFwKGZ1bmN0aW9uKGUpe3JldHVyblwiICAgIFwiK2V9KS5qb2luKFwiXFxuXCIpKSx1LmpvaW4oXCJcXG5cIil9ZnVuY3Rpb24gY29tcHV0ZU1heFNpemVQZXJDb2x1bW4oZSx0LHIsbil7dmFyIG89c2l6ZUZyb21TaGFwZSh0KSxhPW5bbi5sZW5ndGgtMV0saT1uZXcgQXJyYXkoYSkuZmlsbCgwKSxzPXQubGVuZ3RoLHU9XCJjb21wbGV4NjRcIj09PXI/Y3JlYXRlQ29tcGxleFR1cGxlcyhlKTplO2lmKHM+MSlmb3IodmFyIGw9MDtsPG8vYTtsKyspZm9yKHZhciBjPWwqYSxwPTA7cDxhO3ArKylpW3BdPU1hdGgubWF4KGlbcF0sdmFsVG9TdHJpbmcodVtjK3BdLDApLmxlbmd0aCk7cmV0dXJuIGl9ZnVuY3Rpb24gdmFsVG9TdHJpbmcoZSx0KXtyZXR1cm4gcmlnaHRQYWQoQXJyYXkuaXNBcnJheShlKT9wYXJzZUZsb2F0KGVbMF0udG9GaXhlZChGT1JNQVRfTlVNX1NJR19ESUdJVFMpKStcIiArIFwiK3BhcnNlRmxvYXQoZVsxXS50b0ZpeGVkKEZPUk1BVF9OVU1fU0lHX0RJR0lUUykpK1wialwiOnBhcnNlRmxvYXQoZS50b0ZpeGVkKEZPUk1BVF9OVU1fU0lHX0RJR0lUUykpLnRvU3RyaW5nKCksdCl9ZnVuY3Rpb24gc3ViVGVuc29yVG9TdHJpbmcoZSx0LHIsbixvLGEpe3ZvaWQgMD09PWEmJihhPSEwKTt2YXIgaT1cImNvbXBsZXg2NFwiPT09cj8yOjEscz10WzBdLHU9dC5sZW5ndGg7aWYoMD09PXUpcmV0dXJuXCJjb21wbGV4NjRcIj09PXI/W3ZhbFRvU3RyaW5nKGNyZWF0ZUNvbXBsZXhUdXBsZXMoZSlbMF0sMCldOltlWzBdLnRvU3RyaW5nKCldO2lmKDE9PT11KXtpZihzPkZPUk1BVF9MSU1JVF9OVU1fVkFMUyl7dmFyIGw9Rk9STUFUX05VTV9GSVJTVF9MQVNUX1ZBTFMqaSxjPUFycmF5LmZyb20oZS5zdWJhcnJheSgwLGwpKSxwPUFycmF5LmZyb20oZS5zdWJhcnJheShzLUZPUk1BVF9OVU1fRklSU1RfTEFTVF9WQUxTKmkscykpO3JldHVyblwiY29tcGxleDY0XCI9PT1yJiYoYz1jcmVhdGVDb21wbGV4VHVwbGVzKGMpLHA9Y3JlYXRlQ29tcGxleFR1cGxlcyhwKSksW1wiW1wiK2MubWFwKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIHZhbFRvU3RyaW5nKGUsb1t0XSl9KS5qb2luKFwiLCBcIikrXCIsIC4uLiwgXCIrcC5tYXAoZnVuY3Rpb24oZSx0KXtyZXR1cm4gdmFsVG9TdHJpbmcoZSxvW3MtRk9STUFUX05VTV9GSVJTVF9MQVNUX1ZBTFMrdF0pfSkuam9pbihcIiwgXCIpK1wiXVwiXX1yZXR1cm5bXCJbXCIrKFwiY29tcGxleDY0XCI9PT1yP2NyZWF0ZUNvbXBsZXhUdXBsZXMoZSk6QXJyYXkuZnJvbShlKSkubWFwKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIHZhbFRvU3RyaW5nKGUsb1t0XSl9KS5qb2luKFwiLCBcIikrXCJdXCJdfXZhciBkPXQuc2xpY2UoMSksaD1uLnNsaWNlKDEpLGY9blswXSppLG09W107aWYocz5GT1JNQVRfTElNSVRfTlVNX1ZBTFMpe2Zvcih2YXIgZz0wO2c8Rk9STUFUX05VTV9GSVJTVF9MQVNUX1ZBTFM7ZysrKXt2YXIgdj0oeT1nKmYpK2Y7bS5wdXNoLmFwcGx5KG0sc3ViVGVuc29yVG9TdHJpbmcoZS5zdWJhcnJheSh5LHYpLGQscixoLG8sITEpKX1tLnB1c2goXCIuLi5cIik7Zm9yKGc9cy1GT1JNQVRfTlVNX0ZJUlNUX0xBU1RfVkFMUztnPHM7ZysrKXt2PSh5PWcqZikrZjttLnB1c2guYXBwbHkobSxzdWJUZW5zb3JUb1N0cmluZyhlLnN1YmFycmF5KHksdiksZCxyLGgsbyxnPT09cy0xKSl9fWVsc2UgZm9yKGc9MDtnPHM7ZysrKXt2YXIgeTt2PSh5PWcqZikrZjttLnB1c2guYXBwbHkobSxzdWJUZW5zb3JUb1N0cmluZyhlLnN1YmFycmF5KHksdiksZCxyLGgsbyxnPT09cy0xKSl9dmFyIHg9Mj09PXU/XCIsXCI6XCJcIjttWzBdPVwiW1wiK21bMF0reDtmb3IoZz0xO2c8bS5sZW5ndGgtMTtnKyspbVtnXT1cIiBcIittW2ddK3g7dmFyIFQ9XCIsXFxuXCI7Zm9yKGc9MjtnPHU7ZysrKVQrPVwiXFxuXCI7cmV0dXJuIG1bbS5sZW5ndGgtMV09XCIgXCIrbVttLmxlbmd0aC0xXStcIl1cIisoYT9cIlwiOlQpLG19ZnVuY3Rpb24gY3JlYXRlQ29tcGxleFR1cGxlcyhlKXtmb3IodmFyIHQ9W10scj0wO3I8ZS5sZW5ndGg7cis9Mil0LnB1c2goW2Vbcl0sZVtyKzFdXSk7cmV0dXJuIHR9dmFyIFRlbnNvckJ1ZmZlcj1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0LHIpe2lmKHRoaXMuZHR5cGU9dCx0aGlzLnNoYXBlPWUuc2xpY2UoKSx0aGlzLnNpemU9c2l6ZUZyb21TaGFwZShlKSxudWxsIT1yKXt2YXIgbj1yLmxlbmd0aDthc3NlcnQobj09PXRoaXMuc2l6ZSxcIkxlbmd0aCBvZiB2YWx1ZXMgJ1wiK24rXCInIGRvZXMgbm90IG1hdGNoIHRoZSBzaXplIGluZmVycmVkIGJ5IHRoZSBzaGFwZSAnXCIrdGhpcy5zaXplK1wiJy5cIil9aWYoXCJjb21wbGV4NjRcIj09PXQpdGhyb3cgbmV3IEVycm9yKFwiY29tcGxleDY0IGR0eXBlIFRlbnNvckJ1ZmZlcnMgYXJlIG5vdCBzdXBwb3J0ZWQuIFBsZWFzZSBjcmVhdGUgYSBUZW5zb3JCdWZmZXIgZm9yIHRoZSByZWFsIGFuZCBpbWFnaW5hcnkgcGFydHMgc2VwYXJhdGVseSBhbmQgY2FsbCB0Zi5jb21wbGV4KHJlYWwsIGltYWcpLlwiKTt0aGlzLnZhbHVlcz1yfHxnZXRUeXBlZEFycmF5RnJvbURUeXBlKHQsc2l6ZUZyb21TaGFwZSh0aGlzLnNoYXBlKSksdGhpcy5zdHJpZGVzPWNvbXB1dGVTdHJpZGVzKGUpfXJldHVybiBlLnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PVtdLHI9MTtyPGFyZ3VtZW50cy5sZW5ndGg7cisrKXRbci0xXT1hcmd1bWVudHNbcl07MD09PXQubGVuZ3RoJiYodD1bMF0pLGFzc2VydCh0Lmxlbmd0aD09PXRoaXMucmFuayxcIlRoZSBudW1iZXIgb2YgcHJvdmlkZWQgY29vcmRpbmF0ZXMgKFwiK3QubGVuZ3RoK1wiKSBtdXN0IG1hdGNoIHRoZSByYW5rIChcIit0aGlzLnJhbmsrXCIpXCIpO3ZhciBuPXRoaXMubG9jVG9JbmRleCh0KTt0aGlzLnZhbHVlc1tuXT1lfSxlLnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24oKXtmb3IodmFyIGU9W10sdD0wO3Q8YXJndW1lbnRzLmxlbmd0aDt0KyspZVt0XT1hcmd1bWVudHNbdF07MD09PWUubGVuZ3RoJiYoZT1bMF0pO2Zvcih2YXIgcj1lW2UubGVuZ3RoLTFdLG49MDtuPGUubGVuZ3RoLTE7KytuKXIrPXRoaXMuc3RyaWRlc1tuXSplW25dO3JldHVybiB0aGlzLnZhbHVlc1tyXX0sZS5wcm90b3R5cGUubG9jVG9JbmRleD1mdW5jdGlvbihlKXtpZigwPT09dGhpcy5yYW5rKXJldHVybiAwO2lmKDE9PT10aGlzLnJhbmspcmV0dXJuIGVbMF07Zm9yKHZhciB0PWVbZS5sZW5ndGgtMV0scj0wO3I8ZS5sZW5ndGgtMTsrK3IpdCs9dGhpcy5zdHJpZGVzW3JdKmVbcl07cmV0dXJuIHR9LGUucHJvdG90eXBlLmluZGV4VG9Mb2M9ZnVuY3Rpb24oZSl7aWYoMD09PXRoaXMucmFuaylyZXR1cm5bXTtpZigxPT09dGhpcy5yYW5rKXJldHVybltlXTtmb3IodmFyIHQ9bmV3IEFycmF5KHRoaXMuc2hhcGUubGVuZ3RoKSxyPTA7cjx0Lmxlbmd0aC0xOysrcil0W3JdPU1hdGguZmxvb3IoZS90aGlzLnN0cmlkZXNbcl0pLGUtPXRbcl0qdGhpcy5zdHJpZGVzW3JdO3JldHVybiB0W3QubGVuZ3RoLTFdPWUsdH0sT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwicmFua1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zaGFwZS5sZW5ndGh9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksZS5wcm90b3R5cGUudG9UZW5zb3I9ZnVuY3Rpb24oKXtyZXR1cm4gVGVuc29yLm1ha2UodGhpcy5zaGFwZSx7dmFsdWVzOnRoaXMudmFsdWVzfSx0aGlzLmR0eXBlKX0sZX0oKSx0cmFja2VyRm49bnVsbCxvcEhhbmRsZXI9bnVsbDtmdW5jdGlvbiBzZXRUZW5zb3JUcmFja2VyKGUpe3RyYWNrZXJGbj1lfWZ1bmN0aW9uIHNldE9wSGFuZGxlcihlKXtvcEhhbmRsZXI9ZX12YXIgVGVuc29yPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQscixuKXt0aGlzLmlzRGlzcG9zZWRJbnRlcm5hbD0hMSx0aGlzLnNoYXBlPWUuc2xpY2UoKSx0aGlzLmR0eXBlPXR8fFwiZmxvYXQzMlwiLHRoaXMuc2l6ZT1zaXplRnJvbVNoYXBlKGUpLG51bGwhPXImJmFzc2VydCh0aGlzLnNpemU9PT1yLmxlbmd0aCxcIkJhc2VkIG9uIHRoZSBwcm92aWRlZCBzaGFwZSwgW1wiK2UrXCJdLCBhbmQgZHR5cGUgXCIrdGhpcy5kdHlwZStcIiwgdGhlIHRlbnNvciBzaG91bGQgaGF2ZSBcIit0aGlzLnNpemUrXCIgdmFsdWVzIGJ1dCBoYXMgXCIrci5sZW5ndGgpLHRoaXMuc3RyaWRlcz1jb21wdXRlU3RyaWRlcyhlKSx0aGlzLmRhdGFJZD1udWxsIT1uP246e30sdGhpcy5pZD10cmFja2VyRm4oKS5uZXh0VGVuc29ySWQoKSx0aGlzLnJhbmtUeXBlPXRoaXMucmFuazw1P3RoaXMucmFuay50b1N0cmluZygpOlwiaGlnaGVyXCIsdHJhY2tlckZuKCkucmVnaXN0ZXJUZW5zb3IodGhpcyksbnVsbCE9ciYmdHJhY2tlckZuKCkud3JpdGUodGhpcy5kYXRhSWQscil9cmV0dXJuIGUubWFrZT1mdW5jdGlvbih0LHIsbil7cmV0dXJuIG5ldyBlKHQsbixyLnZhbHVlcyxyLmRhdGFJZCl9LGUucHJvdG90eXBlLmZsYXR0ZW49ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx0aGlzLmFzMUQoKX0sZS5wcm90b3R5cGUuYXNTY2FsYXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxhc3NlcnQoMT09PXRoaXMuc2l6ZSxcIlRoZSBhcnJheSBtdXN0IGhhdmUgb25seSAxIGVsZW1lbnQuXCIpLHRoaXMucmVzaGFwZShbXSl9LGUucHJvdG90eXBlLmFzMUQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx0aGlzLnJlc2hhcGUoW3RoaXMuc2l6ZV0pfSxlLnByb3RvdHlwZS5hczJEPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksdGhpcy5yZXNoYXBlKFtlLHRdKX0sZS5wcm90b3R5cGUuYXMzRD1mdW5jdGlvbihlLHQscil7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksdGhpcy5yZXNoYXBlKFtlLHQscl0pfSxlLnByb3RvdHlwZS5hczREPWZ1bmN0aW9uKGUsdCxyLG4pe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHRoaXMucmVzaGFwZShbZSx0LHIsbl0pfSxlLnByb3RvdHlwZS5hc1R5cGU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLmNhc3QodGhpcyxlKX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwicmFua1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zaGFwZS5sZW5ndGh9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksZS5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKCl7Zm9yKHZhciBlPVtdLHQ9MDt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKWVbdF09YXJndW1lbnRzW3RdO2Fzc2VydChlLmxlbmd0aD09PXRoaXMucmFuayxcIk51bWJlciBvZiBjb29yZGluYXRlcyBpbiBnZXQoKSBtdXN0IG1hdGNoIHRoZSByYW5rIG9mIHRoZSB0ZW5zb3JcIiksYXNzZXJ0KFwiY29tcGxleDY0XCIhPT10aGlzLmR0eXBlLFwiVGVuc29yLmdldCgpIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIGNvbXBsZXg2NCB0ZW5zb3JzIHlldC5cIiksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSwwPT09ZS5sZW5ndGgmJihlPVswXSk7Zm9yKHZhciByPWVbZS5sZW5ndGgtMV0sbj0wO248ZS5sZW5ndGgtMTsrK24pcis9dGhpcy5zdHJpZGVzW25dKmVbbl07cmV0dXJuIHRoaXMuZGF0YVN5bmMoKVtyXX0sZS5wcm90b3R5cGUuYnVmZmVyPWZ1bmN0aW9uKCl7cmV0dXJuIG9wSGFuZGxlci5idWZmZXIodGhpcy5zaGFwZSx0aGlzLmR0eXBlLHRoaXMuZGF0YVN5bmMoKSl9LGUucHJvdG90eXBlLmRhdGE9ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLFsyLHRyYWNrZXJGbigpLnJlYWQodGhpcy5kYXRhSWQpXX0pfSl9LGUucHJvdG90eXBlLmRhdGFTeW5jPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksdHJhY2tlckZuKCkucmVhZFN5bmModGhpcy5kYXRhSWQpfSxlLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7dGhpcy5pc0Rpc3Bvc2VkfHwodHJhY2tlckZuKCkuZGlzcG9zZVRlbnNvcih0aGlzKSx0aGlzLmlzRGlzcG9zZWRJbnRlcm5hbD0hMCl9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcImlzRGlzcG9zZWRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNEaXNwb3NlZEludGVybmFsfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLGUucHJvdG90eXBlLnRocm93SWZEaXNwb3NlZD1mdW5jdGlvbigpe2lmKHRoaXMuaXNEaXNwb3NlZCl0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3IgaXMgZGlzcG9zZWQuXCIpfSxlLnByb3RvdHlwZS50b0Zsb2F0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYXNUeXBlKFwiZmxvYXQzMlwiKX0sZS5wcm90b3R5cGUudG9JbnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hc1R5cGUoXCJpbnQzMlwiKX0sZS5wcm90b3R5cGUudG9Cb29sPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYXNUeXBlKFwiYm9vbFwiKX0sZS5wcm90b3R5cGUucHJpbnQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPSExKSxvcEhhbmRsZXIucHJpbnQodGhpcyxlKX0sZS5wcm90b3R5cGUucmVzaGFwZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIucmVzaGFwZSh0aGlzLGUpfSxlLnByb3RvdHlwZS5yZXNoYXBlQXM9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksdGhpcy5yZXNoYXBlKGUuc2hhcGUpfSxlLnByb3RvdHlwZS5leHBhbmREaW1zPWZ1bmN0aW9uKGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT0wKSxvcEhhbmRsZXIuZXhwYW5kRGltcyh0aGlzLGUpfSxlLnByb3RvdHlwZS5jdW1zdW09ZnVuY3Rpb24oZSx0LHIpe3JldHVybiB2b2lkIDA9PT1lJiYoZT0wKSx2b2lkIDA9PT10JiYodD0hMSksdm9pZCAwPT09ciYmKHI9ITEpLG9wSGFuZGxlci5jdW1zdW0odGhpcyxlLHQscil9LGUucHJvdG90eXBlLnNxdWVlemU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLnNxdWVlemUodGhpcyxlKX0sZS5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIuY2xvbmUodGhpcyl9LGUucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT0hMSksdGVuc29yVG9TdHJpbmcodGhpcy5kYXRhU3luYygpLHRoaXMuc2hhcGUsdGhpcy5kdHlwZSxlKX0sZS5wcm90b3R5cGUudGlsZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIudGlsZSh0aGlzLGUpfSxlLnByb3RvdHlwZS5nYXRoZXI9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9MCksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIuZ2F0aGVyKHRoaXMsZSx0KX0sZS5wcm90b3R5cGUubWF0TXVsPWZ1bmN0aW9uKGUsdCxyKXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9ITEpLHZvaWQgMD09PXImJihyPSExKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5tYXRNdWwodGhpcyxlLHQscil9LGUucHJvdG90eXBlLmRvdD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIuZG90KHRoaXMsZSl9LGUucHJvdG90eXBlLm5vcm09ZnVuY3Rpb24oZSx0LHIpe3JldHVybiB2b2lkIDA9PT1lJiYoZT1cImV1Y2xpZGVhblwiKSx2b2lkIDA9PT10JiYodD1udWxsKSx2b2lkIDA9PT1yJiYocj0hMSksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIubm9ybSh0aGlzLGUsdCxyKX0sZS5wcm90b3R5cGUuc2xpY2U9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIuc2xpY2UodGhpcyxlLHQpfSxlLnByb3RvdHlwZS5yZXZlcnNlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5yZXZlcnNlKHRoaXMsZSl9LGUucHJvdG90eXBlLmNvbmNhdD1mdW5jdGlvbihlLHQpe3JldHVybiB2b2lkIDA9PT10JiYodD0wKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5jb25jYXQoW3RoaXMsZV0sdCl9LGUucHJvdG90eXBlLnNwbGl0PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PTApLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLnNwbGl0KHRoaXMsZSx0KX0sZS5wcm90b3R5cGUuc3RhY2s9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9MCksb3BIYW5kbGVyLnN0YWNrKFt0aGlzLGVdLHQpfSxlLnByb3RvdHlwZS51bnN0YWNrPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PTApLG9wSGFuZGxlci51bnN0YWNrKHRoaXMsdCl9LGUucHJvdG90eXBlLnBhZD1mdW5jdGlvbihlLHQpe3JldHVybiB2b2lkIDA9PT10JiYodD0wKSxvcEhhbmRsZXIucGFkKHRoaXMsZSx0KX0sZS5wcm90b3R5cGUuYmF0Y2hOb3JtYWxpemF0aW9uPWZ1bmN0aW9uKGUsdCxyLG4sbyl7cmV0dXJuIHZvaWQgMD09PXImJihyPS4wMDEpLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLmJhdGNoTm9ybWFsaXphdGlvbih0aGlzLGUsdCxyLG4sbyl9LGUucHJvdG90eXBlLmFsbD1mdW5jdGlvbihlLHQpe3JldHVybiB2b2lkIDA9PT1lJiYoZT1udWxsKSx2b2lkIDA9PT10JiYodD0hMSksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIuYWxsKHRoaXMsZSx0KX0sZS5wcm90b3R5cGUuYW55PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHZvaWQgMD09PWUmJihlPW51bGwpLHZvaWQgMD09PXQmJih0PSExKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5hbnkodGhpcyxlLHQpfSxlLnByb3RvdHlwZS5sb2dTdW1FeHA9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9bnVsbCksdm9pZCAwPT09dCYmKHQ9ITEpLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLmxvZ1N1bUV4cCh0aGlzLGUsdCl9LGUucHJvdG90eXBlLnN1bT1mdW5jdGlvbihlLHQpe3JldHVybiB2b2lkIDA9PT1lJiYoZT1udWxsKSx2b2lkIDA9PT10JiYodD0hMSksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIuc3VtKHRoaXMsZSx0KX0sZS5wcm90b3R5cGUucHJvZD1mdW5jdGlvbihlLHQpe3JldHVybiB2b2lkIDA9PT1lJiYoZT1udWxsKSx2b2lkIDA9PT10JiYodD0hMSksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIucHJvZCh0aGlzLGUsdCl9LGUucHJvdG90eXBlLm1lYW49ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9bnVsbCksdm9pZCAwPT09dCYmKHQ9ITEpLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLm1lYW4odGhpcyxlLHQpfSxlLnByb3RvdHlwZS5taW49ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9bnVsbCksdm9pZCAwPT09dCYmKHQ9ITEpLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLm1pbih0aGlzLGUsdCl9LGUucHJvdG90eXBlLm1heD1mdW5jdGlvbihlLHQpe3JldHVybiB2b2lkIDA9PT1lJiYoZT1udWxsKSx2b2lkIDA9PT10JiYodD0hMSksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIubWF4KHRoaXMsZSx0KX0sZS5wcm90b3R5cGUuYXJnTWluPWZ1bmN0aW9uKGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT1udWxsKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5hcmdNaW4odGhpcyxlKX0sZS5wcm90b3R5cGUuYXJnTWF4PWZ1bmN0aW9uKGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT1udWxsKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5hcmdNYXgodGhpcyxlKX0sZS5wcm90b3R5cGUuY2FzdD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIuY2FzdCh0aGlzLGUpfSxlLnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLmFkZCh0aGlzLGUpfSxlLnByb3RvdHlwZS5hZGRTdHJpY3Q9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLmFkZFN0cmljdCh0aGlzLGUpfSxlLnByb3RvdHlwZS5hdGFuMj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIuYXRhbjIodGhpcyxlKX0sZS5wcm90b3R5cGUuc3ViPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5zdWIodGhpcyxlKX0sZS5wcm90b3R5cGUuc3ViU3RyaWN0PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5zdWJTdHJpY3QodGhpcyxlKX0sZS5wcm90b3R5cGUucG93PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5wb3codGhpcyxlKX0sZS5wcm90b3R5cGUucG93U3RyaWN0PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5wb3dTdHJpY3QodGhpcyxlKX0sZS5wcm90b3R5cGUubXVsPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5tdWwodGhpcyxlKX0sZS5wcm90b3R5cGUubXVsU3RyaWN0PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5tdWxTdHJpY3QodGhpcyxlKX0sZS5wcm90b3R5cGUuZGl2PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5kaXYodGhpcyxlKX0sZS5wcm90b3R5cGUuZmxvb3JEaXY9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLmZsb29yRGl2KHRoaXMsZSl9LGUucHJvdG90eXBlLmRpdlN0cmljdD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIuZGl2U3RyaWN0KHRoaXMsZSl9LGUucHJvdG90eXBlLm1pbmltdW09ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLm1pbmltdW0odGhpcyxlKX0sZS5wcm90b3R5cGUubWluaW11bVN0cmljdD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIubWluaW11bVN0cmljdCh0aGlzLGUpfSxlLnByb3RvdHlwZS5tYXhpbXVtPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5tYXhpbXVtKHRoaXMsZSl9LGUucHJvdG90eXBlLm1heGltdW1TdHJpY3Q9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLm1heGltdW1TdHJpY3QodGhpcyxlKX0sZS5wcm90b3R5cGUubW9kPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5tb2QodGhpcyxlKX0sZS5wcm90b3R5cGUubW9kU3RyaWN0PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5tb2RTdHJpY3QodGhpcyxlKX0sZS5wcm90b3R5cGUuc3F1YXJlZERpZmZlcmVuY2U9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLnNxdWFyZWREaWZmZXJlbmNlKHRoaXMsZSl9LGUucHJvdG90eXBlLnNxdWFyZWREaWZmZXJlbmNlU3RyaWN0PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5zcXVhcmVkRGlmZmVyZW5jZVN0cmljdCh0aGlzLGUpfSxlLnByb3RvdHlwZS50cmFuc3Bvc2U9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLnRyYW5zcG9zZSh0aGlzLGUpfSxlLnByb3RvdHlwZS5ub3RFcXVhbD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIubm90RXF1YWwodGhpcyxlKX0sZS5wcm90b3R5cGUubm90RXF1YWxTdHJpY3Q9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLm5vdEVxdWFsU3RyaWN0KHRoaXMsZSl9LGUucHJvdG90eXBlLmxlc3M9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLmxlc3ModGhpcyxlKX0sZS5wcm90b3R5cGUubGVzc1N0cmljdD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIubGVzc1N0cmljdCh0aGlzLGUpfSxlLnByb3RvdHlwZS5lcXVhbD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIuZXF1YWwodGhpcyxlKX0sZS5wcm90b3R5cGUuZXF1YWxTdHJpY3Q9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLmVxdWFsU3RyaWN0KHRoaXMsZSl9LGUucHJvdG90eXBlLmxlc3NFcXVhbD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIubGVzc0VxdWFsKHRoaXMsZSl9LGUucHJvdG90eXBlLmxlc3NFcXVhbFN0cmljdD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIubGVzc0VxdWFsU3RyaWN0KHRoaXMsZSl9LGUucHJvdG90eXBlLmdyZWF0ZXI9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLmdyZWF0ZXIodGhpcyxlKX0sZS5wcm90b3R5cGUuZ3JlYXRlclN0cmljdD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIuZ3JlYXRlclN0cmljdCh0aGlzLGUpfSxlLnByb3RvdHlwZS5ncmVhdGVyRXF1YWw9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLmdyZWF0ZXJFcXVhbCh0aGlzLGUpfSxlLnByb3RvdHlwZS5ncmVhdGVyRXF1YWxTdHJpY3Q9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLmdyZWF0ZXJFcXVhbFN0cmljdCh0aGlzLGUpfSxlLnByb3RvdHlwZS5sb2dpY2FsQW5kPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5sb2dpY2FsQW5kKHRoaXMsZSl9LGUucHJvdG90eXBlLmxvZ2ljYWxPcj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIubG9naWNhbE9yKHRoaXMsZSl9LGUucHJvdG90eXBlLmxvZ2ljYWxOb3Q9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIubG9naWNhbE5vdCh0aGlzKX0sZS5wcm90b3R5cGUubG9naWNhbFhvcj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIubG9naWNhbFhvcih0aGlzLGUpfSxlLnByb3RvdHlwZS53aGVyZT1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci53aGVyZShlLHRoaXMsdCl9LGUucHJvdG90eXBlLm5lZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5uZWcodGhpcyl9LGUucHJvdG90eXBlLmNlaWw9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIuY2VpbCh0aGlzKX0sZS5wcm90b3R5cGUuZmxvb3I9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIuZmxvb3IodGhpcyl9LGUucHJvdG90eXBlLnNpZ249ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIuc2lnbih0aGlzKX0sZS5wcm90b3R5cGUuZXhwPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLmV4cCh0aGlzKX0sZS5wcm90b3R5cGUuZXhwbTE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIuZXhwbTEodGhpcyl9LGUucHJvdG90eXBlLmxvZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5sb2codGhpcyl9LGUucHJvdG90eXBlLmxvZzFwPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLmxvZzFwKHRoaXMpfSxlLnByb3RvdHlwZS5zcXJ0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLnNxcnQodGhpcyl9LGUucHJvdG90eXBlLnJzcXJ0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLnJzcXJ0KHRoaXMpfSxlLnByb3RvdHlwZS5zcXVhcmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIuc3F1YXJlKHRoaXMpfSxlLnByb3RvdHlwZS5yZWNpcHJvY2FsPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLnJlY2lwcm9jYWwodGhpcyl9LGUucHJvdG90eXBlLmFicz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5hYnModGhpcyl9LGUucHJvdG90eXBlLmNsaXBCeVZhbHVlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLmNsaXBCeVZhbHVlKHRoaXMsZSx0KX0sZS5wcm90b3R5cGUucmVsdT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5yZWx1KHRoaXMpfSxlLnByb3RvdHlwZS5lbHU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIuZWx1KHRoaXMpfSxlLnByb3RvdHlwZS5zZWx1PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLnNlbHUodGhpcyl9LGUucHJvdG90eXBlLmxlYWt5UmVsdT1mdW5jdGlvbihlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9LjIpLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLmxlYWt5UmVsdSh0aGlzLGUpfSxlLnByb3RvdHlwZS5wcmVsdT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIucHJlbHUodGhpcyxlKX0sZS5wcm90b3R5cGUuc2lnbW9pZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5zaWdtb2lkKHRoaXMpfSxlLnByb3RvdHlwZS5sb2dTaWdtb2lkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLmxvZ1NpZ21vaWQodGhpcyl9LGUucHJvdG90eXBlLnNvZnRwbHVzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLnNvZnRwbHVzKHRoaXMpfSxlLnByb3RvdHlwZS56ZXJvc0xpa2U9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIuemVyb3NMaWtlKHRoaXMpfSxlLnByb3RvdHlwZS5vbmVzTGlrZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5vbmVzTGlrZSh0aGlzKX0sZS5wcm90b3R5cGUuc2luPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLnNpbih0aGlzKX0sZS5wcm90b3R5cGUuY29zPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLmNvcyh0aGlzKX0sZS5wcm90b3R5cGUudGFuPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLnRhbih0aGlzKX0sZS5wcm90b3R5cGUuYXNpbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5hc2luKHRoaXMpfSxlLnByb3RvdHlwZS5hY29zPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLmFjb3ModGhpcyl9LGUucHJvdG90eXBlLmF0YW49ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIuYXRhbih0aGlzKX0sZS5wcm90b3R5cGUuc2luaD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5zaW5oKHRoaXMpfSxlLnByb3RvdHlwZS5jb3NoPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLmNvc2godGhpcyl9LGUucHJvdG90eXBlLnRhbmg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIudGFuaCh0aGlzKX0sZS5wcm90b3R5cGUuYXNpbmg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIuYXNpbmgodGhpcyl9LGUucHJvdG90eXBlLmFjb3NoPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLmFjb3NoKHRoaXMpfSxlLnByb3RvdHlwZS5hdGFuaD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5hdGFuaCh0aGlzKX0sZS5wcm90b3R5cGUuZXJmPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLmVyZih0aGlzKX0sZS5wcm90b3R5cGUucm91bmQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIucm91bmQodGhpcyl9LGUucHJvdG90eXBlLnN0ZXA9ZnVuY3Rpb24oZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPTApLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLnN0ZXAodGhpcyxlKX0sZS5wcm90b3R5cGUuc29mdG1heD1mdW5jdGlvbihlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9LTEpLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLnNvZnRtYXgodGhpcyxlKX0sZS5wcm90b3R5cGUubG9nU29mdG1heD1mdW5jdGlvbihlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9LTEpLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLmxvZ1NvZnRtYXgodGhpcyxlKX0sZS5wcm90b3R5cGUucmVzaXplQmlsaW5lYXI9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9ITEpLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLmltYWdlLnJlc2l6ZUJpbGluZWFyKHRoaXMsZSx0KX0sZS5wcm90b3R5cGUucmVzaXplTmVhcmVzdE5laWdoYm9yPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PSExKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5pbWFnZS5yZXNpemVOZWFyZXN0TmVpZ2hib3IodGhpcyxlLHQpfSxlLnByb3RvdHlwZS5jb252MWQ9ZnVuY3Rpb24oZSx0LHIsbixvLGEpe3JldHVybiB2b2lkIDA9PT1uJiYobj1cIk5XQ1wiKSx2b2lkIDA9PT1vJiYobz0xKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5jb252MWQodGhpcyxlLHQscixuLG8sYSl9LGUucHJvdG90eXBlLmNvbnYyZD1mdW5jdGlvbihlLHQscixuLG8sYSl7cmV0dXJuIHZvaWQgMD09PW4mJihuPVwiTkhXQ1wiKSx2b2lkIDA9PT1vJiYobz1bMSwxXSksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIuY29udjJkKHRoaXMsZSx0LHIsbixvLGEpfSxlLnByb3RvdHlwZS5jb252MmRUcmFuc3Bvc2U9ZnVuY3Rpb24oZSx0LHIsbixvKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIuY29udjJkVHJhbnNwb3NlKHRoaXMsZSx0LHIsbixvKX0sZS5wcm90b3R5cGUuZGVwdGh3aXNlQ29udjJEPWZ1bmN0aW9uKGUsdCxyLG4sbyxhKXtyZXR1cm4gdm9pZCAwPT09biYmKG49XCJOSFdDXCIpLHZvaWQgMD09PW8mJihvPVsxLDFdKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5kZXB0aHdpc2VDb252MmQodGhpcyxlLHQscixuLG8sYSl9LGUucHJvdG90eXBlLnNlcGFyYWJsZUNvbnYyZD1mdW5jdGlvbihlLHQscixuLG8sYSl7cmV0dXJuIHZvaWQgMD09PW8mJihvPVsxLDFdKSx2b2lkIDA9PT1hJiYoYT1cIk5IV0NcIiksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIuc2VwYXJhYmxlQ29udjJkKHRoaXMsZSx0LHIsbixvLGEpfSxlLnByb3RvdHlwZS5hdmdQb29sPWZ1bmN0aW9uKGUsdCxyLG4pe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5hdmdQb29sKHRoaXMsZSx0LHIsbil9LGUucHJvdG90eXBlLm1heFBvb2w9ZnVuY3Rpb24oZSx0LHIsbil7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLm1heFBvb2wodGhpcyxlLHQscixuKX0sZS5wcm90b3R5cGUubG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb249ZnVuY3Rpb24oZSx0LHIsbil7cmV0dXJuIHZvaWQgMD09PWUmJihlPTUpLHZvaWQgMD09PXQmJih0PTEpLHZvaWQgMD09PXImJihyPTEpLHZvaWQgMD09PW4mJihuPS41KSxvcEhhbmRsZXIubG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb24odGhpcyxlLHQscixuKX0sZS5wcm90b3R5cGUucG9vbD1mdW5jdGlvbihlLHQscixuLG8pe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5wb29sKHRoaXMsZSx0LHIsbixvKX0sZS5wcm90b3R5cGUudmFyaWFibGU9ZnVuY3Rpb24oZSx0LHIpe3JldHVybiB2b2lkIDA9PT1lJiYoZT0hMCksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxWYXJpYWJsZS52YXJpYWJsZSh0aGlzLGUsdCxyKX0sZS5wcm90b3R5cGUudW5zb3J0ZWRTZWdtZW50U3VtPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLnVuc29ydGVkU2VnbWVudFN1bSh0aGlzLGUsdCl9LGUucHJvdG90eXBlLmJhdGNoVG9TcGFjZU5EPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLmJhdGNoVG9TcGFjZU5EKHRoaXMsZSx0KX0sZS5wcm90b3R5cGUuc3BhY2VUb0JhdGNoTkQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIuc3BhY2VUb0JhdGNoTkQodGhpcyxlLHQpfSxlLnByb3RvdHlwZS50b3BrPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHZvaWQgMD09PWUmJihlPTEpLHZvaWQgMD09PXQmJih0PSEwKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci50b3BrKHRoaXMsZSx0KX0sZS5wcm90b3R5cGUuc3RyaWRlZFNsaWNlPWZ1bmN0aW9uKGUsdCxyLG4sbyl7cmV0dXJuIHZvaWQgMD09PW4mJihuPTApLHZvaWQgMD09PW8mJihvPTApLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLnN0cmlkZWRTbGljZSh0aGlzLGUsdCxyLG4sbyl9LGUucHJvdG90eXBlLmRlcHRoVG9TcGFjZT1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5kZXB0aFRvU3BhY2UodGhpcyxlLHQpfSxlLnByb3RvdHlwZS5mZnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIuc3BlY3RyYWwuZmZ0KHRoaXMpfSxlLnByb3RvdHlwZS5pZmZ0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLnNwZWN0cmFsLmlmZnQodGhpcyl9LGV9KCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KFRlbnNvcixTeW1ib2wuaGFzSW5zdGFuY2Use3ZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiEhZSYmbnVsbCE9ZS5zaGFwZSYmbnVsbCE9ZS5kdHlwZX19KTt2YXIgVmFyaWFibGU9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0LHIsbil7dm9pZCAwPT09ciYmKHI9ITApO3ZhciBvPWUuY2FsbCh0aGlzLHQuc2hhcGUsdC5kdHlwZSxudWxsLHQuZGF0YUlkKXx8dGhpcztvLnRyYWluYWJsZT1yLG8ubmFtZT1uLG51bGw9PW8ubmFtZSYmKG8ubmFtZT10cmFja2VyRm4oKS5uZXh0VmFyaWFibGVJZCgpLnRvU3RyaW5nKCkpO3RyeXt0cmFja2VyRm4oKS5yZWdpc3RlclZhcmlhYmxlKG8pfWNhdGNoKGUpe3Rocm93IHRyYWNrZXJGbigpLmRpc3Bvc2VUZW5zb3IobyksZX1yZXR1cm4gb31yZXR1cm4gX19leHRlbmRzKHQsZSksdC52YXJpYWJsZT1mdW5jdGlvbihlLHIsbixvKXtyZXR1cm4gdm9pZCAwPT09ciYmKHI9ITApLG51bGwhPW8mJm8hPT1lLmR0eXBlJiYoZT1lLmFzVHlwZShvKSksbmV3IHQoZSxyLG4pfSx0LnByb3RvdHlwZS5hc3NpZ249ZnVuY3Rpb24oZSl7aWYoZS5kdHlwZSE9PXRoaXMuZHR5cGUpdGhyb3cgbmV3IEVycm9yKFwiZHR5cGUgb2YgdGhlIG5ldyB2YWx1ZSAoXCIrZS5kdHlwZStcIikgYW5kIHByZXZpb3VzIHZhbHVlIChcIit0aGlzLmR0eXBlK1wiKSBtdXN0IG1hdGNoXCIpO2lmKCFhcnJheXNFcXVhbChlLnNoYXBlLHRoaXMuc2hhcGUpKXRocm93IG5ldyBFcnJvcihcInNoYXBlIG9mIHRoZSBuZXcgdmFsdWUgKFwiK2Uuc2hhcGUrXCIpIGFuZCBwcmV2aW91cyB2YWx1ZSAoXCIrdGhpcy5zaGFwZStcIikgbXVzdCBtYXRjaFwiKTt0cmFja2VyRm4oKS5kaXNwb3NlVGVuc29yKHRoaXMpLHRoaXMuZGF0YUlkPWUuZGF0YUlkLHRyYWNrZXJGbigpLnJlZ2lzdGVyVGVuc29yKHRoaXMpfSx0fShUZW5zb3IpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShWYXJpYWJsZSxTeW1ib2wuaGFzSW5zdGFuY2Use3ZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiBlIGluc3RhbmNlb2YgVGVuc29yJiZudWxsIT1lLmFzc2lnbiYmZS5hc3NpZ24gaW5zdGFuY2VvZiBGdW5jdGlvbn19KTt2YXIgdmFyaWFibGU9VmFyaWFibGUudmFyaWFibGU7ZnVuY3Rpb24gZ2V0RmlsdGVyZWROb2Rlc1hUb1koZSx0LHIpe2Zvcih2YXIgbj17fSxvPXt9LGE9MDthPHQubGVuZ3RoO2ErKyluW3RbYV0uaWRdPSEwO2ZvcihhPTA7YTxlLmxlbmd0aDthKyspe3ZhciBpPShmPWVbYV0pLmlucHV0cztmb3IodmFyIHMgaW4gaSl7Zm9yKHZhciB1PWlbc10sbD0hMSxjPTA7Yzx0Lmxlbmd0aDtjKyspaWYoblt1LmlkXSl7Zi5vdXRwdXRzLmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIG5bZS5pZF09ITB9KSxsPSEwLG9bZi5pZF09ITA7YnJlYWt9aWYobClicmVha319dmFyIHA9e307cFtyLmlkXT0hMDt2YXIgZD17fTtmb3IoYT1lLmxlbmd0aC0xO2E+PTA7YS0tKWZvcihpPShmPWVbYV0pLmlucHV0cyxjPTA7YzxmLm91dHB1dHMubGVuZ3RoO2MrKylpZihwW2Yub3V0cHV0c1tjXS5pZF0pe2Zvcih2YXIgcyBpbiBpKXBbaVtzXS5pZF09ITAsZFtmLmlkXT0hMDticmVha312YXIgaD1bXTtmb3IoYT0wO2E8ZS5sZW5ndGg7YSsrKXt2YXIgZjtpZihvWyhmPWVbYV0pLmlkXSYmZFtmLmlkXSl7dmFyIG09e307Zm9yKHZhciBzIGluIGYuaW5wdXRzKXt2YXIgZz1mLmlucHV0c1tzXTtuW2cuaWRdJiYobVtzXT1nKX12YXIgdj1PYmplY3QuYXNzaWduKHt9LGYpO3YuaW5wdXRzPW0sdi5vdXRwdXRzPWYub3V0cHV0cyxoLnB1c2godil9fXJldHVybiBofWZ1bmN0aW9uIGJhY2twcm9wYWdhdGVHcmFkaWVudHMoZSx0KXtmb3IodmFyIHI9ZnVuY3Rpb24ocil7dmFyIG49dFtyXSxvPVtdO2lmKG4ub3V0cHV0cy5mb3JFYWNoKGZ1bmN0aW9uKHQpe3ZhciByPWVbdC5pZF07aWYobnVsbCE9cilvLnB1c2gocik7ZWxzZXt2YXIgbj1UZW5zb3IubWFrZSh0LnNoYXBlLHt2YWx1ZXM6bWFrZVplcm9zVHlwZWRBcnJheSh0LnNpemUsdC5kdHlwZSl9LHQuZHR5cGUpO28ucHVzaChuKX19KSxudWxsPT1uLmdyYWRpZW50KXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb21wdXRlIGdyYWRpZW50OiBncmFkaWVudCBmdW5jdGlvbiBub3QgZm91bmQgZm9yIFwiK24ubmFtZStcIi5cIik7dmFyIGE9bi5ncmFkaWVudCgxPT09bi5vdXRwdXRzLmxlbmd0aD9vWzBdOm8pO2Zvcih2YXIgaSBpbiBuLmlucHV0cyl7aWYoIShpIGluIGEpKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBiYWNrcHJvcCB0aHJvdWdoIGlucHV0IFwiK2krXCIuIEF2YWlsYWJsZSBncmFkaWVudHMgZm91bmQ6IFwiK09iamVjdC5rZXlzKGEpK1wiLlwiKTt2YXIgcz1hW2ldKCksdT1uLmlucHV0c1tpXTtpZighYXJyYXlzRXF1YWwocy5zaGFwZSx1LnNoYXBlKSl0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBpbiBncmFkaWVudCBmb3Igb3AgXCIrbi5uYW1lK1wiLiBUaGUgZ3JhZGllbnQgb2YgaW5wdXQgJ1wiK2krXCInIGhhcyBzaGFwZSAnXCIrcy5zaGFwZStcIicsIHdoaWNoIGRvZXMgbm90IG1hdGNoIHRoZSBzaGFwZSBvZiB0aGUgaW5wdXQgJ1wiK3Uuc2hhcGUrXCInXCIpO2lmKG51bGw9PWVbdS5pZF0pZVt1LmlkXT1zO2Vsc2V7dmFyIGw9ZVt1LmlkXTtlW3UuaWRdPWwuYWRkKHMpLGwuZGlzcG9zZSgpfX19LG49dC5sZW5ndGgtMTtuPj0wO24tLSlyKG4pfWZ1bmN0aW9uIGFzc2VydFR5cGVzTWF0Y2goZSx0KXthc3NlcnQoZS5kdHlwZT09PXQuZHR5cGUsXCJUaGUgZHR5cGVzIG9mIHRoZSBmaXJzdChcIitlLmR0eXBlK1wiKSBhbmQgc2Vjb25kKFwiK3QuZHR5cGUrXCIpIGlucHV0IG11c3QgbWF0Y2hcIil9ZnVuY3Rpb24gaXNUZW5zb3JJbkxpc3QoZSx0KXtmb3IodmFyIHI9MDtyPHQubGVuZ3RoO3IrKylpZih0W3JdLmlkPT09ZS5pZClyZXR1cm4hMDtyZXR1cm4hMX1mdW5jdGlvbiBnZXRUZW5zb3JzSW5Db250YWluZXIoZSl7dmFyIHQ9W107cmV0dXJuIHdhbGtUZW5zb3JDb250YWluZXIoZSx0LG5ldyBTZXQpLHR9ZnVuY3Rpb24gd2Fsa1RlbnNvckNvbnRhaW5lcihlLHQscil7aWYobnVsbCE9ZSlpZihlIGluc3RhbmNlb2YgVGVuc29yKXQucHVzaChlKTtlbHNlIGlmKGlzSXRlcmFibGUoZSkpe3ZhciBuPWU7Zm9yKHZhciBvIGluIG4pe3ZhciBhPW5bb107ci5oYXMoYSl8fChyLmFkZChhKSx3YWxrVGVuc29yQ29udGFpbmVyKGEsdCxyKSl9fX1mdW5jdGlvbiBpc0l0ZXJhYmxlKGUpe3JldHVybiBBcnJheS5pc0FycmF5KGUpfHxcIm9iamVjdFwiPT10eXBlb2YgZX12YXIgVHlwZSxFbmdpbmU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCxyKXt0aGlzLmJhY2tlbmQ9ZSx0aGlzLnNhZmVNb2RlPXQsdGhpcy5kZWJ1Z01vZGU9cix0aGlzLnJlZ2lzdGVyZWRWYXJpYWJsZXM9e30sdGhpcy5uZXh0VGFwZU5vZGVJZD0wLHRoaXMubnVtQnl0ZXM9MCx0aGlzLm51bVRlbnNvcnM9MCx0aGlzLm51bURhdGFCdWZmZXJzPTAsdGhpcy5wcm9maWxpbmc9ITEsdGhpcy5ncmFkaWVudFNjb3BlQ291bnQ9MCx0aGlzLmN1c3RvbUdyYWRpZW50RGVwdGg9MCx0aGlzLmtlZXBUZW5zb3JzPW5ldyBTZXQsdGhpcy50ZW5zb3JJbmZvPW5ldyBXZWFrTWFwLHRoaXMuYWN0aXZlU2NvcGU9e3RyYWNrOltdLG5hbWU6XCJkZWZhdWx0IHNjb3BlXCJ9LHRoaXMuc2NvcGVTdGFjaz1bdGhpcy5hY3RpdmVTY29wZV0sdGhpcy5wcm9maWxlcj1uZXcgUHJvZmlsZXIoZSksdGhpcy5hY3RpdmVQcm9maWxlPXtuZXdCeXRlczowLG5ld1RlbnNvcnM6MCxwZWFrQnl0ZXM6MCxrZXJuZWxzOltdLHJlc3VsdDpudWxsfX1yZXR1cm4gZS5wcm90b3R5cGUubW92ZURhdGE9ZnVuY3Rpb24oZSl7dGhpcy53cml0ZShlLHRoaXMucmVhZFN5bmMoZSkpfSxlLnByb3RvdHlwZS50aWR5PWZ1bmN0aW9uKGUsdCxyKXt2YXIgbj10aGlzO3ZvaWQgMD09PXImJihyPSExKTt2YXIgbyxhPW51bGw7aWYobnVsbD09dCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZSl0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2UgcHJvdmlkZSBhIGZ1bmN0aW9uIHRvIHRpZHkoKVwiKTt0PWV9ZWxzZXtpZihcInN0cmluZ1wiIT10eXBlb2YgZSYmIShlIGluc3RhbmNlb2YgU3RyaW5nKSl0aHJvdyBuZXcgRXJyb3IoXCJXaGVuIGNhbGxpbmcgd2l0aCB0d28gYXJndW1lbnRzLCB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGlkeSgpIG11c3QgYmUgYSBzdHJpbmdcIik7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdCl0aHJvdyBuZXcgRXJyb3IoXCJXaGVuIGNhbGxpbmcgd2l0aCB0d28gYXJndW1lbnRzLCB0aGUgMm5kIGFyZ3VtZW50IHRvIHRpZHkoKSBtdXN0IGJlIGEgZnVuY3Rpb25cIik7YT1lfXJldHVybiB0aGlzLnNjb3BlZFJ1bihmdW5jdGlvbigpe3JldHVybiBuLnN0YXJ0U2NvcGUoYSxyKX0sZnVuY3Rpb24oKXtyZXR1cm4gbi5lbmRTY29wZShvLHIpfSxmdW5jdGlvbigpe3JldHVybihvPXQoKSlpbnN0YW5jZW9mIFByb21pc2UmJmNvbnNvbGUuZXJyb3IoXCJDYW5ub3QgcmV0dXJuIGEgUHJvbWlzZSBpbnNpZGUgb2YgdGlkeS5cIiksb30pfSxlLnByb3RvdHlwZS5zY29wZWRSdW49ZnVuY3Rpb24oZSx0LHIpe2UoKTt0cnl7dmFyIG49cigpO3JldHVybiB0KCksbn1jYXRjaChlKXt0aHJvdyB0KCksZX19LGUucHJvdG90eXBlLm5leHRUZW5zb3JJZD1mdW5jdGlvbigpe3JldHVybiBlLm5leHRUZW5zb3JJZCsrfSxlLnByb3RvdHlwZS5uZXh0VmFyaWFibGVJZD1mdW5jdGlvbigpe3JldHVybiBlLm5leHRWYXJpYWJsZUlkKyt9LGUucHJvdG90eXBlLnJ1bktlcm5lbD1mdW5jdGlvbihlLHQscil7dmFyIG4sbz10aGlzLGE9W10saT1mdW5jdGlvbihlKXtyZXR1cm4gYS5wdXNoKGUpLGV9LHM9dGhpcy5hY3RpdmVTY29wZS5uYW1lLHU9dGhpcy5udW1CeXRlcyxsPXRoaXMubnVtVGVuc29ycztpZih0aGlzLnNjb3BlZFJ1bihmdW5jdGlvbigpe3JldHVybiBvLmN1c3RvbUdyYWRpZW50RGVwdGgrK30sZnVuY3Rpb24oKXtyZXR1cm4gby5jdXN0b21HcmFkaWVudERlcHRoLS19LGZ1bmN0aW9uKCl7bj1vLmRlYnVnTW9kZSgpP28ucHJvZmlsZXIucHJvZmlsZUtlcm5lbChzLGZ1bmN0aW9uKCl7cmV0dXJuIGUoby5iYWNrZW5kLGkpfSk6ZShvLmJhY2tlbmQsaSl9KSx0aGlzLnNob3VsZFJlY29yZCgpKXt2YXIgYz17aWQ6dGhpcy5uZXh0VGFwZU5vZGVJZCsrLG5hbWU6cyxpbnB1dHM6dCxvdXRwdXRzOkFycmF5LmlzQXJyYXkobik/bjpbbl19O251bGwhPXImJihjLmdyYWRpZW50PWZ1bmN0aW9uKGUpe3JldHVybiByKGUsYSl9KSx0aGlzLmFjdGl2ZVRhcGUucHVzaChjKX1yZXR1cm4gdGhpcy5wcm9maWxpbmcmJnRoaXMuYWN0aXZlUHJvZmlsZS5rZXJuZWxzLnB1c2goe25hbWU6cyxieXRlc0FkZGVkOnRoaXMubnVtQnl0ZXMtdSx0b3RhbEJ5dGVzU25hcHNob3Q6dGhpcy5udW1CeXRlcyx0ZW5zb3JzQWRkZWQ6dGhpcy5udW1UZW5zb3JzLWwsdG90YWxUZW5zb3JzU25hcHNob3Q6dGhpcy5udW1UZW5zb3JzLGlucHV0U2hhcGVzOk9iamVjdC5rZXlzKHQpLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gdFtlXS5zaGFwZX0pLG91dHB1dFNoYXBlOkFycmF5LmlzQXJyYXkobik/bi5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUuc2hhcGV9KTpuLnNoYXBlfSksbn0sZS5wcm90b3R5cGUucmVnaXN0ZXJUZW5zb3I9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy50ZW5zb3JJbmZvLmhhcyhlLmRhdGFJZCk/dGhpcy50ZW5zb3JJbmZvLmdldChlLmRhdGFJZCkucmVmQ291bnQ6MDt0aGlzLm51bVRlbnNvcnMrKywwPT09dCYmKHRoaXMubnVtRGF0YUJ1ZmZlcnMrKyxcImNvbXBsZXg2NFwiIT09ZS5kdHlwZSYmKHRoaXMubnVtQnl0ZXMrPXNpemVGcm9tU2hhcGUoZS5zaGFwZSkqYnl0ZXNQZXJFbGVtZW50KGUuZHR5cGUpKSx0aGlzLnRlbnNvckluZm8uc2V0KGUuZGF0YUlkLHtiYWNrZW5kOnRoaXMuYmFja2VuZCxkdHlwZTplLmR0eXBlLHNoYXBlOmUuc2hhcGUscmVmQ291bnQ6MH0pLHRoaXMuYmFja2VuZC5yZWdpc3RlcihlLmRhdGFJZCxlLnNoYXBlLGUuZHR5cGUpKSx0aGlzLnRlbnNvckluZm8uZ2V0KGUuZGF0YUlkKS5yZWZDb3VudCsrLGUgaW5zdGFuY2VvZiBWYXJpYWJsZXx8dGhpcy50cmFjayhlKX0sZS5wcm90b3R5cGUucmVnaXN0ZXJWYXJpYWJsZT1mdW5jdGlvbihlKXtpZihudWxsIT10aGlzLnJlZ2lzdGVyZWRWYXJpYWJsZXNbZS5uYW1lXSl0aHJvdyBuZXcgRXJyb3IoXCJWYXJpYWJsZSB3aXRoIG5hbWUgXCIrZS5uYW1lK1wiIHdhcyBhbHJlYWR5IHJlZ2lzdGVyZWRcIik7dGhpcy5yZWdpc3RlcmVkVmFyaWFibGVzW2UubmFtZV09ZX0sZS5wcm90b3R5cGUuZGlzcG9zZVRlbnNvcj1mdW5jdGlvbihlKXt0aGlzLnRlbnNvckluZm8uaGFzKGUuZGF0YUlkKSYmKHRoaXMua2VlcFRlbnNvcnMuaGFzKGUuaWQpJiZ0aGlzLmtlZXBUZW5zb3JzLmRlbGV0ZShlLmlkKSx0aGlzLm51bVRlbnNvcnMtLSx0aGlzLnRlbnNvckluZm8uZ2V0KGUuZGF0YUlkKS5yZWZDb3VudDw9MT8odGhpcy50ZW5zb3JJbmZvLmdldChlLmRhdGFJZCkuYmFja2VuZC5kaXNwb3NlRGF0YShlLmRhdGFJZCksdGhpcy5udW1EYXRhQnVmZmVycy0tLFwiY29tcGxleDY0XCIhPT1lLmR0eXBlJiYodGhpcy5udW1CeXRlcy09c2l6ZUZyb21TaGFwZShlLnNoYXBlKSpieXRlc1BlckVsZW1lbnQoZS5kdHlwZSkpLHRoaXMudGVuc29ySW5mby5kZWxldGUoZS5kYXRhSWQpKTp0aGlzLnRlbnNvckluZm8uZ2V0KGUuZGF0YUlkKS5yZWZDb3VudC0tKX0sZS5wcm90b3R5cGUuZGlzcG9zZVZhcmlhYmxlcz1mdW5jdGlvbigpe2Zvcih2YXIgZSBpbiB0aGlzLnJlZ2lzdGVyZWRWYXJpYWJsZXMpe3ZhciB0PXRoaXMucmVnaXN0ZXJlZFZhcmlhYmxlc1tlXTt0aGlzLmRpc3Bvc2VUZW5zb3IodCksZGVsZXRlIHRoaXMucmVnaXN0ZXJlZFZhcmlhYmxlc1tlXX19LGUucHJvdG90eXBlLm1lbW9yeT1mdW5jdGlvbigpe3ZhciBlPXRoaXMuYmFja2VuZC5tZW1vcnkoKTtyZXR1cm4gZS5udW1UZW5zb3JzPXRoaXMubnVtVGVuc29ycyxlLm51bURhdGFCdWZmZXJzPXRoaXMubnVtRGF0YUJ1ZmZlcnMsZS5udW1CeXRlcz10aGlzLm51bUJ5dGVzLGV9LGUucHJvdG90eXBlLnByb2ZpbGU9ZnVuY3Rpb24oZSl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgdCxyO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKG4pe3JldHVybiB0aGlzLnByb2ZpbGluZz0hMCx0PXRoaXMubnVtQnl0ZXMscj10aGlzLm51bVRlbnNvcnMsdGhpcy5hY3RpdmVQcm9maWxlLmtlcm5lbHM9W10sdGhpcy5hY3RpdmVQcm9maWxlLnJlc3VsdD1lKCksdGhpcy5wcm9maWxpbmc9ITEsdGhpcy5hY3RpdmVQcm9maWxlLnBlYWtCeXRlcz1NYXRoLm1heC5hcHBseShNYXRoLHRoaXMuYWN0aXZlUHJvZmlsZS5rZXJuZWxzLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS50b3RhbEJ5dGVzU25hcHNob3R9KSksdGhpcy5hY3RpdmVQcm9maWxlLm5ld0J5dGVzPXRoaXMubnVtQnl0ZXMtdCx0aGlzLmFjdGl2ZVByb2ZpbGUubmV3VGVuc29ycz10aGlzLm51bVRlbnNvcnMtcixbMix0aGlzLmFjdGl2ZVByb2ZpbGVdfSl9KX0sZS5wcm90b3R5cGUuc2hvdWxkUmVjb3JkPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPXRoaXMuYWN0aXZlVGFwZSYmMD09PXRoaXMuY3VzdG9tR3JhZGllbnREZXB0aH0sZS5wcm90b3R5cGUuYWRkVGFwZU5vZGU9ZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXt9O2UuZm9yRWFjaChmdW5jdGlvbihlLHQpe25bdF09ZX0pO3ZhciBvPXtpZDp0aGlzLm5leHRUYXBlTm9kZUlkKyssbmFtZTp0aGlzLmFjdGl2ZVNjb3BlLm5hbWUsaW5wdXRzOm4sb3V0cHV0czpbdF0sZ3JhZGllbnQ6ZnVuY3Rpb24oZSl7dmFyIHQ9e307cmV0dXJuIHIoZSkuZm9yRWFjaChmdW5jdGlvbihlLHIpe3Rbcl09ZnVuY3Rpb24oKXtyZXR1cm4gZX19KSx0fX07dGhpcy5hY3RpdmVUYXBlLnB1c2gobyl9LGUucHJvdG90eXBlLmtlZXA9ZnVuY3Rpb24oZSl7aWYoMT09PXRoaXMuc2NvcGVTdGFjay5sZW5ndGgmJnRoaXMuc2FmZU1vZGUpdGhyb3cgbmV3IEVycm9yKFwiU2FmZSBtb2RlIGlzIE9OLiBFbmNsb3NlIGFsbCB0ZW5zb3Igb3BlcmF0aW9ucyBpbnNpZGUgdGYudGlkeSgpOiB0Zi50aWR5KCgpID0+IHsuLi59KSB0byBhdm9pZCBtZW1vcnkgbGVha3MuXCIpO3JldHVybiB0aGlzLmtlZXBUZW5zb3JzLmFkZChlLmlkKSxlfSxlLnByb3RvdHlwZS5zdGFydFNjb3BlPWZ1bmN0aW9uKGUsdCl7dm9pZCAwPT09dCYmKHQ9ITEpLHQmJjA9PT10aGlzLmdyYWRpZW50U2NvcGVDb3VudCYmKHRoaXMuYWN0aXZlVGFwZT1bXSksdCYmdGhpcy5ncmFkaWVudFNjb3BlQ291bnQrKzt2YXIgcj17dHJhY2s6W10sbmFtZTpcInVubmFtZWQgc2NvcGVcIn07ZSYmKHIubmFtZT1lKSx0aGlzLnNjb3BlU3RhY2sucHVzaChyKSx0aGlzLmFjdGl2ZVNjb3BlPXJ9LGUucHJvdG90eXBlLmVuZFNjb3BlPWZ1bmN0aW9uKGUsdCl7dmFyIHI9dGhpczt2b2lkIDA9PT10JiYodD0hMSksdCYmKHRoaXMuZ3JhZGllbnRTY29wZUNvdW50LS0sMD09PXRoaXMuZ3JhZGllbnRTY29wZUNvdW50JiYodGhpcy5hY3RpdmVUYXBlPW51bGwpKTt2YXIgbj1uZXcgU2V0KHRoaXMua2VlcFRlbnNvcnMpLG89Z2V0VGVuc29yc0luQ29udGFpbmVyKGUpO28uZm9yRWFjaChmdW5jdGlvbihlKXtyZXR1cm4gbi5hZGQoZS5pZCl9KTtmb3IodmFyIGE9MDthPHRoaXMuYWN0aXZlU2NvcGUudHJhY2subGVuZ3RoO2ErKyl7dmFyIGk9dGhpcy5hY3RpdmVTY29wZS50cmFja1thXTtuLmhhcyhpLmlkKXx8KG51bGwhPXRoaXMuYWN0aXZlVGFwZT9vLnB1c2goaSk6aS5kaXNwb3NlKCkpfXZhciBzPXRoaXMuc2NvcGVTdGFjay5wb3AoKTt0aGlzLmFjdGl2ZVNjb3BlPTA9PT10aGlzLnNjb3BlU3RhY2subGVuZ3RoP3t0cmFjazpbXSxuYW1lOlwiZGVmYXVsdCBzY29wZVwifTp0aGlzLnNjb3BlU3RhY2tbdGhpcy5zY29wZVN0YWNrLmxlbmd0aC0xXSxvLmZvckVhY2goZnVuY3Rpb24oZSl7IXIua2VlcFRlbnNvcnMuaGFzKGUuaWQpJiZpc1RlbnNvckluTGlzdChlLHMudHJhY2spJiZyLnRyYWNrKGUpfSl9LGUucHJvdG90eXBlLmdyYWRpZW50cz1mdW5jdGlvbihlLHQscixuKXt2YXIgbz10aGlzO3JldHVybiB2b2lkIDA9PT1uJiYobj0hMSksYXNzZXJ0KHQubGVuZ3RoPjAsXCJncmFkaWVudHMoKSByZWNlaXZlZCBhbiBlbXB0eSBsaXN0IG9mIHhzLlwiKSx0aGlzLnRpZHkoXCJncmFkaWVudHNcIixmdW5jdGlvbigpe3ZhciBhPWUoKTthc3NlcnQoYSBpbnN0YW5jZW9mIFRlbnNvcixcIlRoZSByZXN1bHQgeSByZXR1cm5lZCBieSBmKCkgbXVzdCBiZSBhIHRlbnNvci5cIik7dmFyIGk9Z2V0RmlsdGVyZWROb2Rlc1hUb1koby5hY3RpdmVUYXBlLHQsYSk7aWYoIW4mJjA9PT1pLmxlbmd0aCYmdC5sZW5ndGg+MCl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29tcHV0ZSBncmFkaWVudCBvZiB5PWYoeCkgd2l0aCByZXNwZWN0IHRvIHguIE1ha2Ugc3VyZSB0aGF0IHRoZSBmIHlvdSBwYXNzZWQgZW5jbG9zZXMgYWxsIG9wZXJhdGlvbnMgdGhhdCBsZWFkIGZyb20geCB0byB5LlwiKTt2YXIgcz17fTtyZXR1cm4gc1thLmlkXT1udWxsPT1yP29uZXMoYS5zaGFwZSk6cixiYWNrcHJvcGFnYXRlR3JhZGllbnRzKHMsaSkse3ZhbHVlOmEsZ3JhZHM6dC5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIHNbZS5pZF19KX19LCEwKX0sZS5wcm90b3R5cGUuY3VzdG9tR3JhZD1mdW5jdGlvbihlKXt2YXIgdD10aGlzO3JldHVybiBhc3NlcnQoaXNGdW5jdGlvbihlKSxcIlRoZSBmIHBhc3NlZCBpbiBjdXN0b21HcmFkKGYpIG11c3QgYmUgYSBmdW5jdGlvbi5cIiksZnVuY3Rpb24oKXtmb3IodmFyIHIsbixvPVtdLGE9MDthPGFyZ3VtZW50cy5sZW5ndGg7YSsrKW9bYV09YXJndW1lbnRzW2FdO2lmKGFzc2VydChvLmV2ZXJ5KGZ1bmN0aW9uKGUpe3JldHVybiBlIGluc3RhbmNlb2YgVGVuc29yfSksXCJUaGUgYXJncyBwYXNzZWQgaW4gY3VzdG9tR3JhZChmKSh4MSwgeDIsLi4uKSBtdXN0IGFsbCBiZSB0ZW5zb3JzXCIpLHQuc2NvcGVkUnVuKGZ1bmN0aW9uKCl7cmV0dXJuIHQuY3VzdG9tR3JhZGllbnREZXB0aCsrfSxmdW5jdGlvbigpe3JldHVybiB0LmN1c3RvbUdyYWRpZW50RGVwdGgtLX0sZnVuY3Rpb24oKXtuPXQudGlkeShlLm5hbWUsZnVuY3Rpb24oKXt2YXIgdD1lLmFwcGx5KHZvaWQgMCxvKSxuPXQudmFsdWUsYT10LmdyYWRGdW5jO3JldHVybiBhc3NlcnQobiBpbnN0YW5jZW9mIFRlbnNvcixcIlRoZSBmdW5jdGlvbiBmIHBhc3NlZCBpbiBjdXN0b21HcmFkKGYpIG11c3QgcmV0dXJuIGFuIG9iamVjdCB3aGVyZSBgb2JqLnZhbHVlYCBpcyBhIHRlbnNvclwiKSxhc3NlcnQoaXNGdW5jdGlvbihhKSxcIlRoZSBmdW5jdGlvbiBmIHBhc3NlZCBpbiBjdXN0b21HcmFkKGYpIG11c3QgcmV0dXJuIGFuIG9iamVjdCB3aGVyZSBgb2JqLmdyYWRGdW5jYCBpcyBhIGZ1bmN0aW9uLlwiKSxyPWEsbn0sITApfSksdC5zaG91bGRSZWNvcmQoKSl7dC5hZGRUYXBlTm9kZShvLG4sZnVuY3Rpb24oZSl7dmFyIHQ9cihlKSxuPUFycmF5LmlzQXJyYXkodCk/dDpbdF07cmV0dXJuIGFzc2VydChuLmxlbmd0aD09PW8ubGVuZ3RoLFwiVGhlIGZ1bmN0aW9uIGYgcGFzc2VkIGluIGN1c3RvbUdyYWQoZikgbXVzdCByZXR1cm4gYW4gb2JqZWN0IHdoZXJlIGBvYmouZ3JhZEZ1bmNgIGlzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBzYW1lIG51bWJlciBvZiB0ZW5zb3JzIGFzIGlucHV0cyBwYXNzZWQgdG8gZiguLi4pLlwiKSxhc3NlcnQobi5ldmVyeShmdW5jdGlvbihlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIFRlbnNvcn0pLFwiVGhlIGZ1bmN0aW9uIGYgcGFzc2VkIGluIGN1c3RvbUdyYWQoZikgbXVzdCByZXR1cm4gYW4gb2JqZWN0IHdoZXJlIGBvYmouZ3JhZEZ1bmNgIGlzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgbGlzdCBvZiBvbmx5IHRlbnNvcnMuXCIpLG59KX1yZXR1cm4gbn19LGUucHJvdG90eXBlLndyaXRlPWZ1bmN0aW9uKGUsdCl7dmFyIHI9dGhpcy50ZW5zb3JJbmZvLmdldChlKTt0aGlzLmJhY2tlbmQhPT1yLmJhY2tlbmQmJihyLmJhY2tlbmQuZGlzcG9zZURhdGEoZSksci5iYWNrZW5kPXRoaXMuYmFja2VuZCx0aGlzLmJhY2tlbmQucmVnaXN0ZXIoZSxyLnNoYXBlLHIuZHR5cGUpKSx0aGlzLmJhY2tlbmQud3JpdGUoZSx0KX0sZS5wcm90b3R5cGUucmVhZFN5bmM9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudGVuc29ySW5mby5nZXQoZSkuYmFja2VuZC5yZWFkU3luYyhlKX0sZS5wcm90b3R5cGUucmVhZD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50ZW5zb3JJbmZvLmdldChlKS5iYWNrZW5kLnJlYWQoZSl9LGUucHJvdG90eXBlLmZyb21QaXhlbHM9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5iYWNrZW5kLmZyb21QaXhlbHMoZSx0KX0sZS5wcm90b3R5cGUudGltZT1mdW5jdGlvbihlKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciB0LHI7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24obil7c3dpdGNoKG4ubGFiZWwpe2Nhc2UgMDpyZXR1cm4gdD1ub3coKSxbNCx0aGlzLmJhY2tlbmQudGltZShlKV07Y2FzZSAxOnJldHVybihyPW4uc2VudCgpKS53YWxsTXM9bm93KCktdCxbMixyXX19KX0pfSxlLnByb3RvdHlwZS50cmFjaz1mdW5jdGlvbihlKXtpZigxPT09dGhpcy5zY29wZVN0YWNrLmxlbmd0aCYmdGhpcy5zYWZlTW9kZSl0aHJvdyBuZXcgRXJyb3IoXCJTYWZlIG1vZGUgaXMgT04uIEVuY2xvc2UgYWxsIHRlbnNvciBvcGVyYXRpb25zIGluc2lkZSB0Zi50aWR5KCk6IHRmLnRpZHkoKCkgPT4ge29wKCk7Li4ufSk7IHRvIGF2b2lkIG1lbW9yeSBsZWFrcy5cIik7cmV0dXJuIHRoaXMuYWN0aXZlU2NvcGUudHJhY2sucHVzaChlKSxlfSxlLm5leHRUZW5zb3JJZD0wLGUubmV4dFZhcmlhYmxlSWQ9MCxlfSgpO2Z1bmN0aW9uIG9uZXMoZSl7dmFyIHQ9bWFrZU9uZXNUeXBlZEFycmF5KHNpemVGcm9tU2hhcGUoZSksXCJmbG9hdDMyXCIpO3JldHVybiBUZW5zb3IubWFrZShlLHt2YWx1ZXM6dH0pfSFmdW5jdGlvbihlKXtlW2UuTlVNQkVSPTBdPVwiTlVNQkVSXCIsZVtlLkJPT0xFQU49MV09XCJCT09MRUFOXCIsZVtlLlNUUklORz0yXT1cIlNUUklOR1wifShUeXBlfHwoVHlwZT17fSkpO3ZhciBNQVhfVEVYVFVSRV9TSVpFLFVSTF9QUk9QRVJUSUVTPVt7bmFtZTpcIkRFQlVHXCIsdHlwZTpUeXBlLkJPT0xFQU59LHtuYW1lOlwiSVNfQlJPV1NFUlwiLHR5cGU6VHlwZS5CT09MRUFOfSx7bmFtZTpcIldFQkdMX0xBWklMWV9VTlBBQ0tcIix0eXBlOlR5cGUuQk9PTEVBTn0se25hbWU6XCJXRUJHTF9DUFVfRk9SV0FSRFwiLHR5cGU6VHlwZS5CT09MRUFOfSx7bmFtZTpcIldFQkdMX1BBQ0tfQkFUQ0hOT1JNQUxJWkFUSU9OXCIsdHlwZTpUeXBlLkJPT0xFQU59LHtuYW1lOlwiV0VCR0xfQ09OVl9JTTJDT0xcIix0eXBlOlR5cGUuQk9PTEVBTn0se25hbWU6XCJXRUJHTF9NQVhfVEVYVFVSRV9TSVpFXCIsdHlwZTpUeXBlLk5VTUJFUn0se25hbWU6XCJXRUJHTF9QQUdJTkdfRU5BQkxFRFwiLHR5cGU6VHlwZS5CT09MRUFOfSx7bmFtZTpcIldFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9WRVJTSU9OXCIsdHlwZTpUeXBlLk5VTUJFUn0se25hbWU6XCJXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fUkVMSUFCTEVcIix0eXBlOlR5cGUuQk9PTEVBTn0se25hbWU6XCJXRUJHTF9WRVJTSU9OXCIsdHlwZTpUeXBlLk5VTUJFUn0se25hbWU6XCJXRUJHTF9SRU5ERVJfRkxPQVQzMl9FTkFCTEVEXCIsdHlwZTpUeXBlLkJPT0xFQU59LHtuYW1lOlwiV0VCR0xfRE9XTkxPQURfRkxPQVRfRU5BQkxFRFwiLHR5cGU6VHlwZS5CT09MRUFOfSx7bmFtZTpcIldFQkdMX0ZFTkNFX0FQSV9FTkFCTEVEXCIsdHlwZTpUeXBlLkJPT0xFQU59LHtuYW1lOlwiV0VCR0xfU0laRV9VUExPQURfVU5JRk9STVwiLHR5cGU6VHlwZS5OVU1CRVJ9LHtuYW1lOlwiQkFDS0VORFwiLHR5cGU6VHlwZS5TVFJJTkd9LHtuYW1lOlwiRVBTSUxPTlwiLHR5cGU6VHlwZS5OVU1CRVJ9LHtuYW1lOlwiUFJPRFwiLHR5cGU6VHlwZS5CT09MRUFOfSx7bmFtZTpcIlRFTlNPUkxJS0VfQ0hFQ0tfU0hBUEVfQ09OU0lTVEVOQ1lcIix0eXBlOlR5cGUuQk9PTEVBTn1dO2Z1bmN0aW9uIGlzV2ViR0xWZXJzaW9uRW5hYmxlZChlKXt0cnl7aWYobnVsbCE9Z2V0V2ViR0xDb250ZXh0KGUpKXJldHVybiEwfWNhdGNoKGUpe3JldHVybiExfXJldHVybiExfWZ1bmN0aW9uIGdldFdlYkdMTWF4VGV4dHVyZVNpemUoZSl7aWYobnVsbD09TUFYX1RFWFRVUkVfU0laRSl7dmFyIHQ9Z2V0V2ViR0xDb250ZXh0KGUpO01BWF9URVhUVVJFX1NJWkU9dC5nZXRQYXJhbWV0ZXIodC5NQVhfVEVYVFVSRV9TSVpFKX1yZXR1cm4gTUFYX1RFWFRVUkVfU0laRX1mdW5jdGlvbiBnZXRXZWJHTERpc2pvaW50UXVlcnlUaW1lclZlcnNpb24oZSl7aWYoMD09PWUpcmV0dXJuIDA7dmFyIHQ9Z2V0V2ViR0xDb250ZXh0KGUpO3JldHVybiBoYXNFeHRlbnNpb24odCxcIkVYVF9kaXNqb2ludF90aW1lcl9xdWVyeV93ZWJnbDJcIikmJjI9PT1lPzI6aGFzRXh0ZW5zaW9uKHQsXCJFWFRfZGlzam9pbnRfdGltZXJfcXVlcnlcIik/MTowfWZ1bmN0aW9uIGlzUmVuZGVyVG9GbG9hdFRleHR1cmVFbmFibGVkKGUpe2lmKDA9PT1lKXJldHVybiExO3ZhciB0PWdldFdlYkdMQ29udGV4dChlKTtpZigxPT09ZSl7aWYoIWhhc0V4dGVuc2lvbih0LFwiT0VTX3RleHR1cmVfZmxvYXRcIikpcmV0dXJuITF9ZWxzZSBpZighaGFzRXh0ZW5zaW9uKHQsXCJFWFRfY29sb3JfYnVmZmVyX2Zsb2F0XCIpKXJldHVybiExO3JldHVybiBjcmVhdGVGbG9hdFRleHR1cmVBbmRCaW5kVG9GcmFtZWJ1ZmZlcih0LGUpfWZ1bmN0aW9uIGlzRG93bmxvYWRGbG9hdFRleHR1cmVFbmFibGVkKGUpe2lmKDA9PT1lKXJldHVybiExO3ZhciB0PWdldFdlYkdMQ29udGV4dChlKTtpZigxPT09ZSl7aWYoIWhhc0V4dGVuc2lvbih0LFwiT0VTX3RleHR1cmVfZmxvYXRcIikpcmV0dXJuITE7aWYoIWhhc0V4dGVuc2lvbih0LFwiV0VCR0xfY29sb3JfYnVmZmVyX2Zsb2F0XCIpKXJldHVybiExfWVsc2UgaWYoIWhhc0V4dGVuc2lvbih0LFwiRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdFwiKSlyZXR1cm4hMTtyZXR1cm4gY3JlYXRlRmxvYXRUZXh0dXJlQW5kQmluZFRvRnJhbWVidWZmZXIodCxlKX1mdW5jdGlvbiBpc1dlYkdMRmVuY2VFbmFibGVkKGUpe3JldHVybiAyPT09ZSYmbnVsbCE9Z2V0V2ViR0xDb250ZXh0KGUpLmZlbmNlU3luY31mdW5jdGlvbiBpc0Nocm9tZSgpe3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiBuYXZpZ2F0b3ImJm51bGwhPW5hdmlnYXRvciYmbnVsbCE9bmF2aWdhdG9yLnVzZXJBZ2VudCYmL0Nocm9tZS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSYmL0dvb2dsZSBJbmMvLnRlc3QobmF2aWdhdG9yLnZlbmRvcil9dmFyIFRFTlNPUkZMT1dKU19GTEFHU19QUkVGSVg9XCJ0ZmpzZmxhZ3NcIjtmdW5jdGlvbiBnZXRGZWF0dXJlc0Zyb21VUkwoKXt2YXIgZT17fTtpZihcInVuZGVmaW5lZFwiPT10eXBlb2Ygd2luZG93fHx2b2lkIDA9PT13aW5kb3cubG9jYXRpb258fHZvaWQgMD09PXdpbmRvdy5sb2NhdGlvbi5zZWFyY2gpcmV0dXJuIGU7dmFyIHQ9Z2V0UXVlcnlQYXJhbXMod2luZG93LmxvY2F0aW9uLnNlYXJjaCk7aWYoVEVOU09SRkxPV0pTX0ZMQUdTX1BSRUZJWCBpbiB0KXt2YXIgcj17fTt0W1RFTlNPUkZMT1dKU19GTEFHU19QUkVGSVhdLnNwbGl0KFwiLFwiKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciB0PWUuc3BsaXQoXCI6XCIpLG49dFswXSxvPXRbMV07cltuXT1vfSksVVJMX1BST1BFUlRJRVMuZm9yRWFjaChmdW5jdGlvbih0KXt0Lm5hbWUgaW4gciYmKGNvbnNvbGUubG9nKFwiU2V0dGluZyBmZWF0dXJlIG92ZXJyaWRlIGZyb20gVVJMIFwiK3QubmFtZStcIjogXCIrclt0Lm5hbWVdKSx0LnR5cGU9PT1UeXBlLk5VTUJFUj9lW3QubmFtZV09K3JbdC5uYW1lXTp0LnR5cGU9PT1UeXBlLkJPT0xFQU4/ZVt0Lm5hbWVdPVwidHJ1ZVwiPT09clt0Lm5hbWVdOnQudHlwZT09PVR5cGUuU1RSSU5HP2VbdC5uYW1lXT1yW3QubmFtZV06Y29uc29sZS53YXJuKFwiVW5rbm93biBVUkwgcGFyYW06IFwiK3QubmFtZStcIi5cIikpfSl9cmV0dXJuIGV9ZnVuY3Rpb24gaGFzRXh0ZW5zaW9uKGUsdCl7cmV0dXJuIG51bGwhPWUuZ2V0RXh0ZW5zaW9uKHQpfWZ1bmN0aW9uIGNyZWF0ZUZsb2F0VGV4dHVyZUFuZEJpbmRUb0ZyYW1lYnVmZmVyKGUsdCl7dmFyIHI9ZS5jcmVhdGVGcmFtZWJ1ZmZlcigpLG49ZS5jcmVhdGVUZXh0dXJlKCk7ZS5iaW5kVGV4dHVyZShlLlRFWFRVUkVfMkQsbik7dmFyIG89Mj09PXQ/ZS5SR0JBMzJGOmUuUkdCQTtlLnRleEltYWdlMkQoZS5URVhUVVJFXzJELDAsbywxLDEsMCxlLlJHQkEsZS5GTE9BVCxudWxsKSxlLmJpbmRGcmFtZWJ1ZmZlcihlLkZSQU1FQlVGRkVSLHIpLGUuZnJhbWVidWZmZXJUZXh0dXJlMkQoZS5GUkFNRUJVRkZFUixlLkNPTE9SX0FUVEFDSE1FTlQwLGUuVEVYVFVSRV8yRCxuLDApO3ZhciBhPWUuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyhlLkZSQU1FQlVGRkVSKT09PWUuRlJBTUVCVUZGRVJfQ09NUExFVEU7cmV0dXJuIGUuYmluZFRleHR1cmUoZS5URVhUVVJFXzJELG51bGwpLGUuYmluZEZyYW1lYnVmZmVyKGUuRlJBTUVCVUZGRVIsbnVsbCksZS5kZWxldGVUZXh0dXJlKG4pLGUuZGVsZXRlRnJhbWVidWZmZXIociksYX1mdW5jdGlvbiBnZXRRdWVyeVBhcmFtcyhlKXt2YXIgdD17fTtyZXR1cm4gZS5yZXBsYWNlKC9bPyZdKFtePT8mXSspKD86PShbXiZdKikpPy9nLGZ1bmN0aW9uKGUpe2Zvcih2YXIgcj1bXSxuPTE7bjxhcmd1bWVudHMubGVuZ3RoO24rKylyW24tMV09YXJndW1lbnRzW25dO3JldHVybiBkZWNvZGVQYXJhbSh0LHJbMF0sclsxXSksci5qb2luKFwiPVwiKX0pLHR9ZnVuY3Rpb24gZGVjb2RlUGFyYW0oZSx0LHIpe2VbZGVjb2RlVVJJQ29tcG9uZW50KHQpXT1kZWNvZGVVUklDb21wb25lbnQocnx8XCJcIil9dmFyIEVQU0lMT05fRkxPQVQxNj0uMDAxLFRFU1RfRVBTSUxPTl9GTE9BVDE2PS4xLEVQU0lMT05fRkxPQVQzMj0xZS03LFRFU1RfRVBTSUxPTl9GTE9BVDMyPS4wMDEsRW52aXJvbm1lbnQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUpe3RoaXMuZmVhdHVyZXM9e30sdGhpcy5yZWdpc3RyeT17fSxudWxsIT1lJiYodGhpcy5mZWF0dXJlcz1lKSx0aGlzLmdldChcIkRFQlVHXCIpJiZjb25zb2xlLndhcm4oXCJEZWJ1Z2dpbmcgbW9kZSBpcyBPTi4gVGhlIG91dHB1dCBvZiBldmVyeSBtYXRoIGNhbGwgd2lsbCBiZSBkb3dubG9hZGVkIHRvIENQVSBhbmQgY2hlY2tlZCBmb3IgTmFOcy4gVGhpcyBzaWduaWZpY2FudGx5IGltcGFjdHMgcGVyZm9ybWFuY2UuXCIpfXJldHVybiBlLnNldEJhY2tlbmQ9ZnVuY3Rpb24oZSx0KXtpZih2b2lkIDA9PT10JiYodD0hMSksIShlIGluIEVOVi5yZWdpc3RyeSkpdGhyb3cgbmV3IEVycm9yKFwiQmFja2VuZCBuYW1lICdcIitlK1wiJyBub3QgZm91bmQgaW4gcmVnaXN0cnlcIik7RU5WLmVuZ2luZS5iYWNrZW5kPUVOVi5maW5kQmFja2VuZChlKSxFTlYuYmFja2VuZE5hbWU9ZX0sZS5nZXRCYWNrZW5kPWZ1bmN0aW9uKCl7cmV0dXJuIEVOVi5pbml0RW5naW5lKCksRU5WLmJhY2tlbmROYW1lfSxlLmRpc3Bvc2VWYXJpYWJsZXM9ZnVuY3Rpb24oKXtFTlYuZW5naW5lLmRpc3Bvc2VWYXJpYWJsZXMoKX0sZS5tZW1vcnk9ZnVuY3Rpb24oKXtyZXR1cm4gRU5WLmVuZ2luZS5tZW1vcnkoKX0sZS5wcm9maWxlPWZ1bmN0aW9uKGUpe3JldHVybiBFTlYuZW5naW5lLnByb2ZpbGUoZSl9LGUudGlkeT1mdW5jdGlvbihlLHQscil7cmV0dXJuIHZvaWQgMD09PXImJihyPSExKSxFTlYuZW5naW5lLnRpZHkoZSx0LHIpfSxlLmRpc3Bvc2U9ZnVuY3Rpb24oZSl7Z2V0VGVuc29yc0luQ29udGFpbmVyKGUpLmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIGUuZGlzcG9zZSgpfSl9LGUua2VlcD1mdW5jdGlvbihlKXtyZXR1cm4gRU5WLmVuZ2luZS5rZWVwKGUpfSxlLnRpbWU9ZnVuY3Rpb24oZSl7cmV0dXJuIEVOVi5lbmdpbmUudGltZShlKX0sZS5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKGUpe3JldHVybiBlIGluIHRoaXMuZmVhdHVyZXM/dGhpcy5mZWF0dXJlc1tlXToodGhpcy5mZWF0dXJlc1tlXT10aGlzLmV2YWx1YXRlRmVhdHVyZShlKSx0aGlzLmZlYXR1cmVzW2VdKX0sZS5wcm90b3R5cGUuZ2V0RmVhdHVyZXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5mZWF0dXJlc30sZS5wcm90b3R5cGUuc2V0PWZ1bmN0aW9uKGUsdCl7dGhpcy5mZWF0dXJlc1tlXT10fSxlLnByb3RvdHlwZS5nZXRCZXN0QmFja2VuZE5hbWU9ZnVuY3Rpb24oKXt2YXIgZT10aGlzO2lmKDA9PT1PYmplY3Qua2V5cyh0aGlzLnJlZ2lzdHJ5KS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiTm8gYmFja2VuZCBmb3VuZCBpbiByZWdpc3RyeS5cIik7cmV0dXJuIE9iamVjdC5rZXlzKHRoaXMucmVnaXN0cnkpLm1hcChmdW5jdGlvbih0KXtyZXR1cm57bmFtZTp0LGVudHJ5OmUucmVnaXN0cnlbdF19fSkuc29ydChmdW5jdGlvbihlLHQpe3JldHVybiB0LmVudHJ5LnByaW9yaXR5LWUuZW50cnkucHJpb3JpdHl9KVswXS5uYW1lfSxlLnByb3RvdHlwZS5ldmFsdWF0ZUZlYXR1cmU9ZnVuY3Rpb24oZSl7aWYoXCJERUJVR1wiPT09ZSlyZXR1cm4hMTtpZihcIklTX0JST1dTRVJcIj09PWUpcmV0dXJuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdztpZihcIklTX05PREVcIj09PWUpcmV0dXJuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHByb2Nlc3MmJnZvaWQgMCE9PXByb2Nlc3MudmVyc2lvbnMubm9kZTtpZihcIklTX0NIUk9NRVwiPT09ZSlyZXR1cm4gaXNDaHJvbWUoKTtpZihcIldFQkdMX0NQVV9GT1JXQVJEXCI9PT1lKXJldHVybiEwO2lmKFwiV0VCR0xfUEFDS19CQVRDSE5PUk1BTElaQVRJT05cIj09PWUpcmV0dXJuITE7aWYoXCJXRUJHTF9MQVpJTFlfVU5QQUNLXCI9PT1lKXJldHVybiExO2lmKFwiV0VCR0xfQ09OVl9JTTJDT0xcIj09PWUpcmV0dXJuITE7aWYoXCJXRUJHTF9QQUdJTkdfRU5BQkxFRFwiPT09ZSlyZXR1cm4gdGhpcy5nZXQoXCJJU19CUk9XU0VSXCIpJiYhdGhpcy5nZXQoXCJQUk9EXCIpO2lmKFwiV0VCR0xfTUFYX1RFWFRVUkVfU0laRVwiPT09ZSlyZXR1cm4gZ2V0V2ViR0xNYXhUZXh0dXJlU2l6ZSh0aGlzLmdldChcIldFQkdMX1ZFUlNJT05cIikpO2lmKFwiSVNfVEVTVFwiPT09ZSlyZXR1cm4hMTtpZihcIkJBQ0tFTkRcIj09PWUpcmV0dXJuIHRoaXMuZ2V0QmVzdEJhY2tlbmROYW1lKCk7aWYoXCJXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fVkVSU0lPTlwiPT09ZSl7dmFyIHQ9dGhpcy5nZXQoXCJXRUJHTF9WRVJTSU9OXCIpO3JldHVybiAwPT09dD8wOmdldFdlYkdMRGlzam9pbnRRdWVyeVRpbWVyVmVyc2lvbih0KX1pZihcIldFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9SRUxJQUJMRVwiPT09ZSlyZXR1cm4gdGhpcy5nZXQoXCJXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fVkVSU0lPTlwiKT4wJiYhaXNNb2JpbGUoKTtpZihcIkhBU19XRUJHTFwiPT09ZSlyZXR1cm4gdGhpcy5nZXQoXCJXRUJHTF9WRVJTSU9OXCIpPjA7aWYoXCJXRUJHTF9WRVJTSU9OXCI9PT1lKXJldHVybiBpc1dlYkdMVmVyc2lvbkVuYWJsZWQoMik/Mjppc1dlYkdMVmVyc2lvbkVuYWJsZWQoMSk/MTowO2lmKFwiV0VCR0xfUkVOREVSX0ZMT0FUMzJfRU5BQkxFRFwiPT09ZSlyZXR1cm4gaXNSZW5kZXJUb0Zsb2F0VGV4dHVyZUVuYWJsZWQodGhpcy5nZXQoXCJXRUJHTF9WRVJTSU9OXCIpKTtpZihcIldFQkdMX0RPV05MT0FEX0ZMT0FUX0VOQUJMRURcIj09PWUpcmV0dXJuIGlzRG93bmxvYWRGbG9hdFRleHR1cmVFbmFibGVkKHRoaXMuZ2V0KFwiV0VCR0xfVkVSU0lPTlwiKSk7aWYoXCJXRUJHTF9GRU5DRV9BUElfRU5BQkxFRFwiPT09ZSlyZXR1cm4gaXNXZWJHTEZlbmNlRW5hYmxlZCh0aGlzLmdldChcIldFQkdMX1ZFUlNJT05cIikpO2lmKFwiV0VCR0xfU0laRV9VUExPQURfVU5JRk9STVwiPT09ZSlyZXR1cm4gdGhpcy5nZXQoXCJXRUJHTF9SRU5ERVJfRkxPQVQzMl9FTkFCTEVEXCIpPzQ6MDtpZihcIlRFU1RfRVBTSUxPTlwiPT09ZSlyZXR1cm4gMzI9PT10aGlzLmJhY2tlbmQuZmxvYXRQcmVjaXNpb24oKT9URVNUX0VQU0lMT05fRkxPQVQzMjpURVNUX0VQU0lMT05fRkxPQVQxNjtpZihcIkVQU0lMT05cIj09PWUpcmV0dXJuIDMyPT09dGhpcy5iYWNrZW5kLmZsb2F0UHJlY2lzaW9uKCk/RVBTSUxPTl9GTE9BVDMyOkVQU0lMT05fRkxPQVQxNjtpZihcIlBST0RcIj09PWUpcmV0dXJuITE7aWYoXCJURU5TT1JMSUtFX0NIRUNLX1NIQVBFX0NPTlNJU1RFTkNZXCI9PT1lKXJldHVybiF0aGlzLmdldChcIlBST0RcIik7dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBmZWF0dXJlIFwiK2UrXCIuXCIpfSxlLnByb3RvdHlwZS5zZXRGZWF0dXJlcz1mdW5jdGlvbihlKXt0aGlzLmZlYXR1cmVzPU9iamVjdC5hc3NpZ24oe30sZSl9LGUucHJvdG90eXBlLnJlc2V0PWZ1bmN0aW9uKCl7dGhpcy5mZWF0dXJlcz1nZXRGZWF0dXJlc0Zyb21VUkwoKSxudWxsIT10aGlzLmdsb2JhbEVuZ2luZSYmKHRoaXMuZ2xvYmFsRW5naW5lPW51bGwpfSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5wcm90b3R5cGUsXCJiYWNrZW5kXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVuZ2luZS5iYWNrZW5kfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLGUucHJvdG90eXBlLmZpbmRCYWNrZW5kPWZ1bmN0aW9uKGUpe3JldHVybiBlIGluIHRoaXMucmVnaXN0cnk/dGhpcy5yZWdpc3RyeVtlXS5iYWNrZW5kOm51bGx9LGUucHJvdG90eXBlLnJlZ2lzdGVyQmFja2VuZD1mdW5jdGlvbihlLHQscixuKXt2YXIgbz10aGlzO2lmKHZvaWQgMD09PXImJihyPTEpLGUgaW4gdGhpcy5yZWdpc3RyeSlyZXR1cm4gY29uc29sZS53YXJuKGUrXCIgYmFja2VuZCB3YXMgYWxyZWFkeSByZWdpc3RlcmVkLiBSZXVzaW5nIGV4aXN0aW5nIGJhY2tlbmRcIiksbnVsbCE9biYmbihmdW5jdGlvbigpe3JldHVybiBvLmVuZ2luZX0pLCExO3RyeXt2YXIgYT10KCk7cmV0dXJuIGEuc2V0RGF0YU1vdmVyKHttb3ZlRGF0YTpmdW5jdGlvbihlKXtyZXR1cm4gby5lbmdpbmUubW92ZURhdGEoZSl9fSksdGhpcy5yZWdpc3RyeVtlXT17YmFja2VuZDphLHByaW9yaXR5OnJ9LCEwfWNhdGNoKHQpe3JldHVybiBjb25zb2xlLndhcm4oXCJSZWdpc3RyYXRpb24gb2YgYmFja2VuZCBcIitlK1wiIGZhaWxlZFwiKSxjb25zb2xlLndhcm4odC5zdGFja3x8dC5tZXNzYWdlKSwhMX19LGUucHJvdG90eXBlLnJlbW92ZUJhY2tlbmQ9ZnVuY3Rpb24oZSl7aWYoIShlIGluIHRoaXMucmVnaXN0cnkpKXRocm93IG5ldyBFcnJvcihlK1wiIGJhY2tlbmQgbm90IGZvdW5kIGluIHJlZ2lzdHJ5XCIpO3RoaXMucmVnaXN0cnlbZV0uYmFja2VuZC5kaXNwb3NlKCksZGVsZXRlIHRoaXMucmVnaXN0cnlbZV19LE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcImVuZ2luZVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pbml0RW5naW5lKCksdGhpcy5nbG9iYWxFbmdpbmV9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksZS5wcm90b3R5cGUuaW5pdEVuZ2luZT1mdW5jdGlvbigpe3ZhciBlPXRoaXM7aWYobnVsbD09dGhpcy5nbG9iYWxFbmdpbmUpe3RoaXMuYmFja2VuZE5hbWU9dGhpcy5nZXQoXCJCQUNLRU5EXCIpO3ZhciB0PXRoaXMuZmluZEJhY2tlbmQodGhpcy5iYWNrZW5kTmFtZSk7dGhpcy5nbG9iYWxFbmdpbmU9bmV3IEVuZ2luZSh0LCExLGZ1bmN0aW9uKCl7cmV0dXJuIGUuZ2V0KFwiREVCVUdcIil9KX19LGV9KCk7ZnVuY3Rpb24gZ2V0R2xvYmFsTmFtZXNwYWNlKCl7dmFyIGU7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdyllPXdpbmRvdztlbHNle2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBwcm9jZXNzKXRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIGEgZ2xvYmFsIG9iamVjdFwiKTtlPXByb2Nlc3N9cmV0dXJuIGV9ZnVuY3Rpb24gZ2V0T3JNYWtlRW52aXJvbm1lbnQoKXt2YXIgZT1nZXRHbG9iYWxOYW1lc3BhY2UoKTtyZXR1cm4gbnVsbD09ZS5FTlYmJihlLkVOVj1uZXcgRW52aXJvbm1lbnQoZ2V0RmVhdHVyZXNGcm9tVVJMKCkpLHNldFRlbnNvclRyYWNrZXIoZnVuY3Rpb24oKXtyZXR1cm4gZS5FTlYuZW5naW5lfSkpLGUuRU5WfXZhciBFTlY9Z2V0T3JNYWtlRW52aXJvbm1lbnQoKSxlbnZpcm9ubWVudD1PYmplY3QuZnJlZXplKHtFbnZpcm9ubWVudDpFbnZpcm9ubWVudCxFTlY6RU5WfSk7ZnVuY3Rpb24gZ3JhZChlKXtyZXR1cm4gYXNzZXJ0KGlzRnVuY3Rpb24oZSksXCJUaGUgZiBwYXNzZWQgaW4gZ3JhZChmKSBtdXN0IGJlIGEgZnVuY3Rpb25cIiksZnVuY3Rpb24odCxyKXtyZXR1cm4gYXNzZXJ0KHQgaW5zdGFuY2VvZiBUZW5zb3IsXCJUaGUgeCBwYXNzZWQgaW4gZ3JhZChmKSh4KSBtdXN0IGJlIGEgdGVuc29yXCIpLGFzc2VydChudWxsPT1yfHxyIGluc3RhbmNlb2YgVGVuc29yLFwiVGhlIGR5IHBhc3NlZCBpbiBncmFkKGYpKHgsIGR5KSBtdXN0IGJlIGEgdGVuc29yXCIpLEVOVi5lbmdpbmUudGlkeShmdW5jdGlvbigpe3ZhciBuPUVOVi5lbmdpbmUuZ3JhZGllbnRzKGZ1bmN0aW9uKCl7cmV0dXJuIGUodCl9LFt0XSxyKSxvPW4udmFsdWUsYT1uLmdyYWRzO3JldHVybiBudWxsIT1yJiZhc3NlcnRTaGFwZXNNYXRjaChvLnNoYXBlLHIuc2hhcGUsXCJUaGUgc2hhcGUgb2YgZHkgcGFzc2VkIGluIGdyYWQoZikoeCwgZHkpIG11c3QgbWF0Y2ggdGhlIHNoYXBlIHJldHVybmVkIGJ5IGYoeClcIiksY2hlY2tHcmFkcyhhKSxhWzBdfSl9fWZ1bmN0aW9uIGdyYWRzKGUpe3JldHVybiBhc3NlcnQoaXNGdW5jdGlvbihlKSxcIlRoZSBmIHBhc3NlZCBpbiBncmFkcyhmKSBtdXN0IGJlIGEgZnVuY3Rpb25cIiksZnVuY3Rpb24odCxyKXtyZXR1cm4gYXNzZXJ0KEFycmF5LmlzQXJyYXkodCkmJnQuZXZlcnkoZnVuY3Rpb24oZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBUZW5zb3J9KSxcIlRoZSBhcmdzIHBhc3NlZCBpbiBncmFkcyhmKShhcmdzKSBtdXN0IGJlIGFuIGFycmF5IG9mIHRlbnNvcnNcIiksYXNzZXJ0KG51bGw9PXJ8fHIgaW5zdGFuY2VvZiBUZW5zb3IsXCJUaGUgZHkgcGFzc2VkIGluIGdyYWRzKGYpKGFyZ3MsIGR5KSBtdXN0IGJlIGEgdGVuc29yXCIpLEVOVi5lbmdpbmUudGlkeShmdW5jdGlvbigpe3ZhciBuPUVOVi5lbmdpbmUuZ3JhZGllbnRzKGZ1bmN0aW9uKCl7cmV0dXJuIGUuYXBwbHkodm9pZCAwLHQpfSx0LHIpLG89bi52YWx1ZSxhPW4uZ3JhZHM7cmV0dXJuIG51bGwhPXImJmFzc2VydFNoYXBlc01hdGNoKG8uc2hhcGUsci5zaGFwZSxcIlRoZSBzaGFwZSBvZiBkeSBwYXNzZWQgaW4gZ3JhZHMoZikoW3gxLC4uLl0sIGR5KSBtdXN0IG1hdGNoIHRoZSBzaGFwZSByZXR1cm5lZCBieSBmKFt4MSwuLi5dKVwiKSxjaGVja0dyYWRzKGEpLGF9KX19ZnVuY3Rpb24gdmFsdWVBbmRHcmFkKGUpe3JldHVybiBhc3NlcnQoaXNGdW5jdGlvbihlKSxcIlRoZSBmIHBhc3NlZCBpbiB2YWx1ZUFuZEdyYWQoZikgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpLGZ1bmN0aW9uKHQscil7YXNzZXJ0KHQgaW5zdGFuY2VvZiBUZW5zb3IsXCJUaGUgeCBwYXNzZWQgaW4gdmFsdWVBbmRHcmFkKGYpKHgpIG11c3QgYmUgYSB0ZW5zb3JcIiksYXNzZXJ0KG51bGw9PXJ8fHIgaW5zdGFuY2VvZiBUZW5zb3IsXCJUaGUgZHkgcGFzc2VkIGluIHZhbHVlQW5kR3JhZChmKSh4LCBkeSkgbXVzdCBiZSBhIHRlbnNvclwiKTt2YXIgbj1FTlYuZW5naW5lLmdyYWRpZW50cyhmdW5jdGlvbigpe3JldHVybiBlKHQpfSxbdF0sciksbz1uLmdyYWRzLGE9bi52YWx1ZTtyZXR1cm4gY2hlY2tHcmFkcyhvKSx7Z3JhZDpvWzBdLHZhbHVlOmF9fX1mdW5jdGlvbiB2YWx1ZUFuZEdyYWRzKGUpe3JldHVybiBhc3NlcnQoaXNGdW5jdGlvbihlKSxcIlRoZSBmIHBhc3NlZCBpbiB2YWx1ZUFuZEdyYWRzKGYpIG11c3QgYmUgYSBmdW5jdGlvblwiKSxmdW5jdGlvbih0LHIpe2Fzc2VydChBcnJheS5pc0FycmF5KHQpJiZ0LmV2ZXJ5KGZ1bmN0aW9uKGUpe3JldHVybiBlIGluc3RhbmNlb2YgVGVuc29yfSksXCJUaGUgYXJncyBwYXNzZWQgaW4gdmFsdWVBbmRHcmFkcyhmKShhcmdzKSBtdXN0IGJlIGFycmF5IG9mIHRlbnNvcnNcIiksYXNzZXJ0KG51bGw9PXJ8fHIgaW5zdGFuY2VvZiBUZW5zb3IsXCJUaGUgZHkgcGFzc2VkIGluIHZhbHVlQW5kR3JhZHMoZikoYXJncywgZHkpIG11c3QgYmUgYSB0ZW5zb3JcIik7dmFyIG49RU5WLmVuZ2luZS5ncmFkaWVudHMoZnVuY3Rpb24oKXtyZXR1cm4gZS5hcHBseSh2b2lkIDAsdCl9LHQscik7cmV0dXJuIG51bGwhPXImJmFzc2VydFNoYXBlc01hdGNoKG4udmFsdWUuc2hhcGUsci5zaGFwZSxcIlRoZSBzaGFwZSBvZiBkeSBwYXNzZWQgaW4gdmFsdWVBbmRHcmFkcyhmKShbeDEsLi4uXSwgZHkpIG11c3QgbWF0Y2ggdGhlIHNoYXBlIHJldHVybmVkIGJ5IGYoW3gxLC4uLl0pXCIpLGNoZWNrR3JhZHMobi5ncmFkcyksbn19ZnVuY3Rpb24gdmFyaWFibGVHcmFkcyhlLHQpe2lmKGFzc2VydChpc0Z1bmN0aW9uKGUpLFwiVGhlIGYgcGFzc2VkIGluIHZhcmlhYmxlR3JhZHMoZikgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpLGFzc2VydChudWxsPT10fHxBcnJheS5pc0FycmF5KHQpJiZ0LmV2ZXJ5KGZ1bmN0aW9uKGUpe3JldHVybiBlIGluc3RhbmNlb2YgVmFyaWFibGV9KSxcIlRoZSB2YXJMaXN0IHBhc3NlZCBpbiB2YXJpYWJsZUdyYWRzKGYsIHZhckxpc3QpIG11c3QgYmUgYW4gYXJyYXkgb2YgdmFyaWFibGVzXCIpLG51bGw9PXQpZm9yKHZhciByIGluIHQ9W10sRU5WLmVuZ2luZS5yZWdpc3RlcmVkVmFyaWFibGVzKXQucHVzaChFTlYuZW5naW5lLnJlZ2lzdGVyZWRWYXJpYWJsZXNbcl0pO3ZhciBuPXQubGVuZ3RoO2Fzc2VydCgodD10LmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4gZS50cmFpbmFibGV9KSkubGVuZ3RoPjAsXCJ2YXJpYWJsZUdyYWRzKCkgZXhwZWN0cyBhdCBsZWFzdCBvbmUgb2YgdGhlIGlucHV0IHZhcmlhYmxlcyB0byBiZSB0cmFpbmFibGUsIGJ1dCBub25lIG9mIHRoZSBcIituK1wiIHZhcmlhYmxlcyBpcyB0cmFpbmFibGUuXCIpO3ZhciBvPUVOVi5lbmdpbmUuZ3JhZGllbnRzKGUsdCxudWxsLCEwKSxhPW8udmFsdWUsaT1vLmdyYWRzO2Fzc2VydChpLnNvbWUoZnVuY3Rpb24oZSl7cmV0dXJuIG51bGwhPWV9KSxcIkNhbm5vdCBmaW5kIGEgY29ubmVjdGlvbiBiZXR3ZWVuIGFueSB2YXJpYWJsZSBhbmQgdGhlIHJlc3VsdCBvZiB0aGUgbG9zcyBmdW5jdGlvbiB5PWYoeCkuIFBsZWFzZSBtYWtlIHN1cmUgdGhlIG9wZXJhdGlvbnMgdGhhdCB1c2UgdmFyaWFibGVzIGFyZSBpbnNpZGUgdGhlIGZ1bmN0aW9uIGYgcGFzc2VkIHRvIG1pbmltaXplKCkuXCIpLGFzc2VydCgwPT09YS5yYW5rLFwiVGhlIGYgcGFzc2VkIGluIHZhcmlhYmxlR3JhZHMoZikgbXVzdCByZXR1cm4gYSBzY2FsYXIsIGJ1dCBpdCByZXR1cm5lZCBhIHJhbmstXCIrYS5yYW5rK1wiIHRlbnNvclwiKTt2YXIgcz17fTtyZXR1cm4gdC5mb3JFYWNoKGZ1bmN0aW9uKGUsdCl7bnVsbCE9aVt0XSYmKHNbZS5uYW1lXT1pW3RdKX0pLHt2YWx1ZTphLGdyYWRzOnN9fWZ1bmN0aW9uIGN1c3RvbUdyYWQoZSl7cmV0dXJuIEVOVi5lbmdpbmUuY3VzdG9tR3JhZChlKX1mdW5jdGlvbiBjaGVja0dyYWRzKGUpe2lmKGUuZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiBudWxsPT1lfSkubGVuZ3RoPjApdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbXB1dGUgZ3JhZGllbnQgb2YgeT1mKHgpIHdpdGggcmVzcGVjdCB0byB4LiBNYWtlIHN1cmUgdGhhdFxcbiAgICB0aGUgZiB5b3UgcGFzc2VkIGVuY2xvc2VzIGFsbCBvcGVyYXRpb25zIHRoYXQgbGVhZCBmcm9tIHggdG8geS5cIil9dmFyIHRpZHk9RW52aXJvbm1lbnQudGlkeSxrZWVwPUVudmlyb25tZW50LmtlZXAsZGlzcG9zZT1FbnZpcm9ubWVudC5kaXNwb3NlLHRpbWU9RW52aXJvbm1lbnQudGltZSxwcm9maWxlPUVudmlyb25tZW50LnByb2ZpbGU7ZnVuY3Rpb24gd2Fybigpe2Zvcih2YXIgZT1bXSx0PTA7dDxhcmd1bWVudHMubGVuZ3RoO3QrKyllW3RdPWFyZ3VtZW50c1t0XTtFTlYuZ2V0KFwiSVNfVEVTVFwiKXx8Y29uc29sZS53YXJuLmFwcGx5KGNvbnNvbGUsZSl9ZnVuY3Rpb24gZ2V0UmVzaGFwZWQoZSx0LHIsbil7dm9pZCAwPT09biYmKG49ITApO3ZhciBvPVtdO2lmKG4pKG89by5jb25jYXQodC5zbGljZSgwKSkpLnB1c2goZVswXS9yKSxvPW8uY29uY2F0KGUuc2xpY2UoMSkpO2Vsc2V7bz1vLmNvbmNhdChlWzBdKTtmb3IodmFyIGE9dC5sZW5ndGgsaT0wO2k8YTsrK2kpbz1vLmNvbmNhdChbZVtpKzFdL3RbaV0sdFtpXV0pO289by5jb25jYXQoZS5zbGljZShhKzEpKX1yZXR1cm4gb31mdW5jdGlvbiBnZXRQZXJtdXRlZChlLHQscil7dm9pZCAwPT09ciYmKHI9ITApO3ZhciBuPVtdO2lmKHIpe24ucHVzaCh0KTtmb3IodmFyIG89dCsxO288ZTsrK28pbzw9Mip0PyhuLnB1c2gobyksbi5wdXNoKG8tKHQrMSkpKTpuLnB1c2gobyl9ZWxzZXt2YXIgYT1bXSxpPVtdO2ZvcihvPTE7bzxlOysrbylvPj0yKnQrMXx8byUyPT0xP2kucHVzaChvKTphLnB1c2gobyk7bi5wdXNoLmFwcGx5KG4sYSksbi5wdXNoKDApLG4ucHVzaC5hcHBseShuLGkpfXJldHVybiBufWZ1bmN0aW9uIGdldFJlc2hhcGVkUGVybXV0ZWQoZSx0LHIsbil7dm9pZCAwPT09biYmKG49ITApO3ZhciBvPVtdO24/by5wdXNoKGVbMF0vcik6by5wdXNoKGVbMF0qcik7Zm9yKHZhciBhPTE7YTxlLmxlbmd0aDsrK2EpYTw9dC5sZW5ndGg/bj9vLnB1c2godFthLTFdKmVbYV0pOm8ucHVzaChlW2FdL3RbYS0xXSk6by5wdXNoKGVbYV0pO3JldHVybiBvfWZ1bmN0aW9uIGdldFNsaWNlQmVnaW5Db29yZHMoZSx0KXtmb3IodmFyIHI9WzBdLG49MDtuPHQ7KytuKXIucHVzaChlW25dWzBdKTtyZXR1cm4gcn1mdW5jdGlvbiBnZXRTbGljZVNpemUoZSx0LHIpe2Zvcih2YXIgbj1lLnNsaWNlKDAsMSksbz0wO288cjsrK28pbi5wdXNoKGVbbysxXS10W29dWzBdLXRbb11bMV0pO3JldHVybiBufWZ1bmN0aW9uIGF4ZXNBcmVJbm5lck1vc3REaW1zKGUsdCl7Zm9yKHZhciByPTA7cjxlLmxlbmd0aDsrK3IpaWYoZVtlLmxlbmd0aC1yLTFdIT09dC0xLXIpcmV0dXJuITE7cmV0dXJuITB9ZnVuY3Rpb24gY29tYmluZUxvY2F0aW9ucyhlLHQscil7Zm9yKHZhciBuPWUubGVuZ3RoK3QubGVuZ3RoLG89W10sYT0wLGk9MCxzPTA7czxuO3MrKyktMT09PXIuaW5kZXhPZihzKT9vLnB1c2goZVthKytdKTpvLnB1c2godFtpKytdKTtyZXR1cm4gb31mdW5jdGlvbiBjb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKGUsdCl7Zm9yKHZhciByPVtdLG49ZS5sZW5ndGgsbz0wO288bjtvKyspLTE9PT10LmluZGV4T2YobykmJnIucHVzaChlW29dKTtyZXR1cm5bcix0Lm1hcChmdW5jdGlvbih0KXtyZXR1cm4gZVt0XX0pXX1mdW5jdGlvbiBleHBhbmRTaGFwZVRvS2VlcERpbShlLHQpe3JldHVybiBjb21iaW5lTG9jYXRpb25zKGUsdC5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIDF9KSx0KX1mdW5jdGlvbiBwYXJzZUF4aXNQYXJhbShlLHQpe3ZhciByPXQubGVuZ3RoO3JldHVybiBhc3NlcnQoKGU9bnVsbD09ZT90Lm1hcChmdW5jdGlvbihlLHQpe3JldHVybiB0fSk6W10uY29uY2F0KGUpKS5ldmVyeShmdW5jdGlvbihlKXtyZXR1cm4gZT49LXImJmU8cn0pLFwiQWxsIHZhbHVlcyBpbiBheGlzIHBhcmFtIG11c3QgYmUgaW4gcmFuZ2UgWy1cIityK1wiLCBcIityK1wiKSBidXQgZ290IGF4aXMgXCIrZSksYXNzZXJ0KGUuZXZlcnkoZnVuY3Rpb24oZSl7cmV0dXJuIGlzSW50KGUpfSksXCJBbGwgdmFsdWVzIGluIGF4aXMgcGFyYW0gbXVzdCBiZSBpbnRlZ2VycyBidXQgZ290IGF4aXMgXCIrZSksZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGU8MD9yK2U6ZX0pfWZ1bmN0aW9uIGFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKGUsdCxyKXthc3NlcnQoYXhlc0FyZUlubmVyTW9zdERpbXModCxyKSxlK1wiIHN1cHBvcnRzIG9ubHkgaW5uZXItbW9zdCBheGVzIGZvciBub3cuIEdvdCBheGVzIFwiK3QrXCIgYW5kIHJhbmstXCIrcitcIiBpbnB1dC5cIil9ZnVuY3Rpb24gZ2V0QXhlc1Blcm11dGF0aW9uKGUsdCl7aWYoYXhlc0FyZUlubmVyTW9zdERpbXMoZSx0KSlyZXR1cm4gbnVsbDtmb3IodmFyIHI9W10sbj0wO248dDsrK24pLTE9PT1lLmluZGV4T2YobikmJnIucHVzaChuKTtyZXR1cm4gZS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiByLnB1c2goZSl9KSxyfWZ1bmN0aW9uIGdldFVuZG9BeGVzUGVybXV0YXRpb24oZSl7cmV0dXJuIGUubWFwKGZ1bmN0aW9uKGUsdCl7cmV0dXJuW3QsZV19KS5zb3J0KGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGVbMV0tdFsxXX0pLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZVswXX0pfWZ1bmN0aW9uIGdldElubmVyTW9zdEF4ZXMoZSx0KXtmb3IodmFyIHI9W10sbj10LWU7bjx0OysrbilyLnB1c2gobik7cmV0dXJuIHJ9ZnVuY3Rpb24gYXNzZXJ0UGFyYW1zQ29uc2lzdGVudChlLHQpe3ZhciByPWVbMF0ubGVuZ3RoO2UuZm9yRWFjaChmdW5jdGlvbihlLHQpe2Fzc2VydChlLmxlbmd0aD09PXIsXCJFcnJvciBpbiBjb25jYXRcIityK1wiRDogcmFuayBvZiB0ZW5zb3JzW1wiK3QrXCJdIG11c3QgYmUgdGhlIHNhbWUgYXMgdGhlIHJhbmsgb2YgdGhlIHJlc3QgKFwiK3IrXCIpXCIpfSksYXNzZXJ0KHQ+PTAmJnQ8cixcIkVycm9yIGluIGNvbmNhdFwiK3IrXCJEOiBheGlzIG11c3QgYmUgYmV0d2VlbiAwIGFuZCBcIisoci0xKStcIi5cIik7dmFyIG49ZVswXTtlLmZvckVhY2goZnVuY3Rpb24oZSxvKXtmb3IodmFyIGE9MDthPHI7YSsrKWFzc2VydChhPT09dHx8ZVthXT09PW5bYV0sXCJFcnJvciBpbiBjb25jYXRcIityK1wiRDogU2hhcGUgb2YgdGVuc29yc1tcIitvK1wiXSAoXCIrZStcIikgZG9lcyBub3QgbWF0Y2ggdGhlIHNoYXBlIG9mIHRoZSByZXN0IChcIituK1wiKSBhbG9uZyB0aGUgbm9uLWNvbmNhdGVuYXRlZCBheGlzIFwiK28rXCIuXCIpfSl9ZnVuY3Rpb24gY29tcHV0ZU91dFNoYXBlKGUsdCl7Zm9yKHZhciByPWVbMF0uc2xpY2UoKSxuPTE7bjxlLmxlbmd0aDtuKyspclt0XSs9ZVtuXVt0XTtyZXR1cm4gcn1mdW5jdGlvbiBwcmVwYXJlQW5kVmFsaWRhdGUoZSx0KXtpZihlLnJhbms8MSl0aHJvdyBuZXcgRXJyb3IoXCJ0Zi5nYXRoZXJORCgpIGV4cGVjdHMgdGhlIGlucHV0IHRvIGJlIHJhbmsgMSBvciBoaWdoZXIsIGJ1dCB0aGUgcmFuayB3YXMgXCIrZS5yYW5rK1wiLlwiKTtpZih0LnJhbms8MSl0aHJvdyBuZXcgRXJyb3IoXCJ0Zi5nYXRoZXJORCgpIGV4cGVjdHMgdGhlIGluZGljZXMgdG8gYmUgcmFuayAxIG9yIGhpZ2hlciwgYnV0IHRoZSByYW5rIHdhcyBcIit0LnJhbmsrXCIuXCIpO2lmKFwiaW50MzJcIiE9PXQuZHR5cGUpdGhyb3cgbmV3IEVycm9yKFwidGYuZ2F0aGVyTkQoKSBleHBlY3RzIHRoZSBpbmRpY2VzIHRvIGJlIGludDMyIHR5cGUsIGJ1dCB0aGUgZHR5cGUgd2FzIFwiK3QuZHR5cGUrXCIuXCIpO2lmKHQuc2hhcGVbdC5yYW5rLTFdPmUucmFuayl0aHJvdyBuZXcgRXJyb3IoXCJpbmRleCBpbm5lcm1vc3QgZGltZW5zaW9uIGxlbmd0aCBtdXN0IGJlIDw9IHRlbnNvciByYW5rOyBzYXc6IFwiK3Quc2hhcGVbdC5yYW5rLTFdK1wiIHZzLiBcIitlLnJhbmspO2lmKDA9PT1lLnNpemUpdGhyb3cgbmV3IEVycm9yKFwiUmVxdWVzdGVkIG1vcmUgdGhhbiAwIGVudHJpZXMsIGJ1dCBpbnB1dCBpcyBlbXB0eS4gSW5wdXQgc2hhcGU6IFwiK2Uuc2hhcGUrXCIuXCIpO2Zvcih2YXIgcj10LnNoYXBlLG49cltyLmxlbmd0aC0xXSxvPTEsYT0wO2E8ci5sZW5ndGgtMTsrK2Epbyo9clthXTt2YXIgaT1lLnNoYXBlLHM9ci5zbGljZSgpO3MucG9wKCk7dmFyIHU9MTtmb3IoYT1uO2E8ZS5yYW5rOysrYSl1Kj1pW2FdLHMucHVzaChpW2FdKTt2YXIgbD1jb21wdXRlU3RyaWRlcyhlLnNoYXBlKS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUvdX0pLmNvbmNhdChbMV0pLnNsaWNlKDAsbik7cmV0dXJuW3Msbyx1LGxdfXZhciBQQVJBTExFTElaRV9USFJFU0hPTEQ9MzA7ZnVuY3Rpb24gY29tcHV0ZU9wdGltYWxXaW5kb3dTaXplKGUpe3JldHVybiBlPD1QQVJBTExFTElaRV9USFJFU0hPTEQ/ZTpuZWFyZXN0RGl2aXNvcihlLE1hdGguZmxvb3IoTWF0aC5zcXJ0KGUpKSl9ZnVuY3Rpb24gdmFsaWRhdGVVcGRhdGVTaGFwZShlLHQscil7dmFyIG49dC5yYW5rPjE/dC5zaGFwZVt0LnJhbmstMV06MSxvPXQucmFuaz4xP3QucmFuay0xOjEsYT1cIk11c3QgaGF2ZSB1cGRhdGVzLnNoYXBlID0gaW5kaWNlcy5zaGFwZVs6YmF0Y2hEaW1dICsgc2hhcGVbc2xpY2VEaW06XSwgZ290IHVwZGF0ZXMuc2hhcGU6IFwiK3Iuc2hhcGUrXCIsIGluZGljZXMuc2hhcGU6IFwiK3Quc2hhcGUrXCIsIHNoYXBlOiBcIitlK1wiLCBzbGljZURpbTogXCIrbitcIiwgYW5kIGJhdGNoRGltOiBcIitvK1wiLlwiO2lmKHIucmFuazxvKXRocm93IG5ldyBFcnJvcihhK1wiIHVwZGF0ZS5yYW5rIDwgXCIrbytcIi4gXCIpO2lmKGUubGVuZ3RoPG4rKHIucmFuay1vKSl0aHJvdyBuZXcgRXJyb3IoYStcIiBPdXRwdXQgc2hhcGUgbGVuZ3RoIDwgXCIrKG4rKHIucmFuay1vKSkpO2lmKHIucmFuayE9PW8rZS5sZW5ndGgtbil0aHJvdyBuZXcgRXJyb3IoYStcIiB1cGRhdGUucmFuayAhPSBcIisobytlLmxlbmd0aC1uKSk7Zm9yKHZhciBpPTA7aTxvOysraSlpZihyLnNoYXBlW2ldIT09dC5zaGFwZVtpXSl0aHJvdyBuZXcgRXJyb3IoYStcIiB1cGRhdGVzLnNoYXBlW1wiK2krXCJdIChcIityLnNoYXBlW2ldK1wiKSAhPSBpbmRpY2VzLnNoYXBlW1wiK2krXCJdIChcIit0LnNoYXBlW2ldK1wiKS5cIik7Zm9yKGk9MDtpPHIucmFuay1vOysraSlpZihyLnNoYXBlW2krb10hPT1lW2krbl0pdGhyb3cgbmV3IEVycm9yKGErXCIgdXBkYXRlcy5zaGFwZVtcIisoaStvKStcIl0gKFwiK3Iuc2hhcGVbaStvXStcIikgIT0gc2hhcGVbXCIrKGkrbykrXCJdIChcIitlW2krb10rXCIpXCIpfWZ1bmN0aW9uIHZhbGlkYXRlSW5wdXQoZSx0LHIpe2lmKHQucmFuazwxKXRocm93IG5ldyBFcnJvcihcInRmLnNjYXR0ZXJORCgpIGV4cGVjdHMgdGhlIGluZGljZXMgdG8gYmUgcmFuayAxIG9yIGhpZ2hlciwgYnV0IHRoZSByYW5rIHdhcyBcIit0LnJhbmsrXCIuXCIpO2lmKGUucmFuazwxKXRocm93IG5ldyBFcnJvcihcInRmLnNjYXR0ZXJORCgpIGV4cGVjdHMgdGhlIHVwZGF0ZXMgdG8gYmUgcmFuayAxIG9yIGhpZ2hlciwgYnV0IHRoZSByYW5rIHdhcyBcIitlLnJhbmsrXCIuXCIpO2lmKFwiaW50MzJcIiE9PXQuZHR5cGUpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGR0eXBlIG9mICdpbmRpY2VzJyBzaG91bGQgYmUgaW50MzIsIGJ1dCBnb3QgZHR5cGU6IFwiK3QuZHR5cGUpO2lmKHIubGVuZ3RoPDEpdGhyb3cgbmV3IEVycm9yKFwiT3V0cHV0IHJhbmsgbXVzdCBiZSBncmVhdGVyIG9yIGVxdWFsIHRvIDEsIGJ1dCBnb3Qgc2hhcGU6IFwiK3IpO2lmKDA9PT1yLmxlbmd0aCl7aWYoMD09PXQuc2l6ZSl0aHJvdyBuZXcgRXJyb3IoXCJJbmRpY2VzIHNwZWNpZmllZCBmb3IgZW1wdHkgb3V0cHV0LiBpbmRpY2VzIHNoYXBlOiBcIit0LnNoYXBlKTtpZigwPT09ZS5zaXplKXRocm93IG5ldyBFcnJvcihcIlVwZGF0ZXMgc3BlY2lmaWVkIGZvciBlbXB0eSBvdXRwdXQuIHVwZGF0ZXMgc2hhcGU6IFwiK2Uuc2hhcGUpfXZhbGlkYXRlVXBkYXRlU2hhcGUocix0LGUpfWZ1bmN0aW9uIGNhbGN1bGF0ZVNoYXBlcyhlLHQscil7Zm9yKHZhciBuPXQucmFuaz4xP3Quc2hhcGVbdC5yYW5rLTFdOjEsbz1yLmxlbmd0aCxhPTEsaT1uO2k8bzsrK2kpYSo9cltpXTt2YXIgcz1uPDE/MTpuLHU9dC5zaXplL3MsbD1jb21wdXRlU3RyaWRlcyhyKS5jb25jYXQoWzFdKTtyZXR1cm57c2xpY2VSYW5rOm4sbnVtVXBkYXRlczp1LHNsaWNlU2l6ZTphLHN0cmlkZXM6bC5zbGljZShsLmxlbmd0aC1uLGwubGVuZ3RoKSxvdXRwdXRTaXplOnNpemVGcm9tU2hhcGUocil9fWZ1bmN0aW9uIHNlZ09wQ29tcHV0ZU9wdGltYWxXaW5kb3dTaXplKGUsdCl7dmFyIHIsbj0hMTtmb3IoZTw9UEFSQUxMRUxJWkVfVEhSRVNIT0xEPyhyPWUsbj0hMCk6cj1uZWFyZXN0RGl2aXNvcihlLE1hdGguZmxvb3IoTWF0aC5zcXJ0KGUpKSk7IW47KXtpZihyPnR8fHI9PT1lKXtuPSEwO2JyZWFrfXI9bmVhcmVzdERpdmlzb3IoZSxyKzEpfXJldHVybiByfWZ1bmN0aW9uIGNvbXB1dGVPdXRTaGFwZSQxKGUsdCxyKXtmb3IodmFyIG49W10sbz1lLmxlbmd0aCxhPTA7YTxvO2ErKylhIT09dD9uLnB1c2goZVthXSk6bi5wdXNoKHIpO3JldHVybiBufWZ1bmN0aW9uIGFzc2VydFBhcmFtc1ZhbGlkKGUsdCxyKXthc3NlcnQoZS5yYW5rPT09dC5sZW5ndGgsXCJFcnJvciBpbiBzbGljZVwiK2UucmFuaytcIkQ6IExlbmd0aCBvZiBiZWdpbiBcIit0K1wiIG11c3QgbWF0Y2ggdGhlIHJhbmsgb2YgdGhlIGFycmF5IChcIitlLnJhbmsrXCIpLlwiKSxhc3NlcnQoZS5yYW5rPT09ci5sZW5ndGgsXCJFcnJvciBpbiBzbGljZVwiK2UucmFuaytcIkQ6IExlbmd0aCBvZiBzaXplIFwiK3IrXCIgbXVzdCBtYXRjaCB0aGUgcmFuayBvZiB0aGUgYXJyYXkgKFwiK2UucmFuaytcIikuXCIpO2Zvcih2YXIgbj0wO248ZS5yYW5rOysrbilhc3NlcnQodFtuXStyW25dPD1lLnNoYXBlW25dLFwiRXJyb3IgaW4gc2xpY2VcIitlLnJhbmsrXCJEOiBiZWdpbltcIituK1wiXSArIHNpemVbXCIrbitcIl0gKFwiKyh0W25dK3Jbbl0pK1wiKSB3b3VsZCBvdmVyZmxvdyBpbnB1dC5zaGFwZVtcIituK1wiXSAoXCIrZS5zaGFwZVtuXStcIilcIil9ZnVuY3Rpb24gZ2V0U3RyaWRlZFNsaWNlZEluZm8oZSx0LHIsbixvLGEsaSxzLHUpe2lmKHZvaWQgMD09PW8mJihvPTApLHZvaWQgMD09PWEmJihhPTApLHZvaWQgMD09PWkmJihpPTApLHZvaWQgMD09PXMmJihzPTApLHZvaWQgMD09PXUmJih1PTApLDAhPT1pKXRocm93IG5ldyBFcnJvcihcImVsbGlwc2lzIG1hc2sgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7aWYoMCE9PXMpdGhyb3cgbmV3IEVycm9yKFwibmV3IGF4aXMgbWFzayBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTtmb3IodmFyIGw9W10sYz1bXSxwPVtdLGQ9MDtkPGUubGVuZ3RoO2QrKylsW2RdPXN0YXJ0Rm9yQXhpcyhvLHQsbixlLGQpLGNbZF09c3RvcEZvckF4aXMoYSxyLG4sZSxkKSx1JjE8PGQmJihjW2RdPWxbZF0rMSxwLnB1c2goZCkpO3ZhciBoPW5ldyBBcnJheShlLmxlbmd0aCkuZmlsbCgwKTtyZXR1cm4gaD1oLm1hcChmdW5jdGlvbihlLHQpe2Zvcih2YXIgcj0wLG89bFt0XTshKG5bdF0+MD9vPj1jW3RdOm88PWNbdF0pO28rPW5bdF0pcis9MTtyZXR1cm4gcn0pLFtsLGgscF19ZnVuY3Rpb24gc3RhcnRGb3JBeGlzKGUsdCxyLG4sbyl7dmFyIGE9dFtvXTtlJjE8PG8mJihhPXJbb10+MD9OdW1iZXIuTUlOX1NBRkVfSU5URUdFUjpOdW1iZXIuTUFYX1NBRkVfSU5URUdFUik7dmFyIGk9bltvXTtyZXR1cm4gYTwwJiYoYSs9aSksYT1jbGFtcCgwLGEsaS0xKX1mdW5jdGlvbiBzdG9wRm9yQXhpcyhlLHQscixuLG8pe3ZhciBhPXRbb107ZSYxPDxvJiYoYT1yW29dPjA/TnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI6TnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIpO3ZhciBpPW5bb107cmV0dXJuIGE8MCYmKGErPWkpLGE9cltvXT4wP2NsYW1wKDAsYSxpKTpjbGFtcCgtMSxhLGktMSl9ZnVuY3Rpb24gaW5mZXJTaGFwZShlKXt2YXIgdD1lO2lmKGlzVHlwZWRBcnJheShlKSlyZXR1cm5bZS5sZW5ndGhdO2lmKCFBcnJheS5pc0FycmF5KGUpKXJldHVybltdO2Zvcih2YXIgcj1bXTt0IGluc3RhbmNlb2YgQXJyYXk7KXIucHVzaCh0Lmxlbmd0aCksdD10WzBdO3JldHVybiBlIGluc3RhbmNlb2YgQXJyYXkmJkVOVi5nZXQoXCJURU5TT1JMSUtFX0NIRUNLX1NIQVBFX0NPTlNJU1RFTkNZXCIpJiZkZWVwQXNzZXJ0U2hhcGVDb25zaXN0ZW5jeShlLHIsW10pLHJ9ZnVuY3Rpb24gZGVlcEFzc2VydFNoYXBlQ29uc2lzdGVuY3koZSx0LHIpe2lmKHI9cnx8W10sZSBpbnN0YW5jZW9mIEFycmF5KXthc3NlcnQodC5sZW5ndGg+MCxmdW5jdGlvbigpe3JldHVyblwiRWxlbWVudCBhcnJbXCIrci5qb2luKFwiXVtcIikrXCJdIHNob3VsZCBiZSBhIHByaW1pdGl2ZSwgYnV0IGlzIGFuIGFycmF5IG9mIFwiK2UubGVuZ3RoK1wiIGVsZW1lbnRzXCJ9KSxhc3NlcnQoZS5sZW5ndGg9PT10WzBdLGZ1bmN0aW9uKCl7cmV0dXJuXCJFbGVtZW50IGFycltcIityLmpvaW4oXCJdW1wiKStcIl0gc2hvdWxkIGhhdmUgXCIrdFswXStcIiBlbGVtZW50cywgYnV0IGhhcyBcIitlLmxlbmd0aCtcIiBlbGVtZW50c1wifSk7Zm9yKHZhciBuPXQuc2xpY2UoMSksbz0wO288ZS5sZW5ndGg7KytvKWRlZXBBc3NlcnRTaGFwZUNvbnNpc3RlbmN5KGVbb10sbixyLmNvbmNhdChvKSl9ZWxzZSBhc3NlcnQoMD09PXQubGVuZ3RoLGZ1bmN0aW9uKCl7cmV0dXJuXCJFbGVtZW50IGFycltcIityLmpvaW4oXCJdW1wiKStcIl0gaXMgYSBwcmltaXRpdmUsIGJ1dCBzaG91bGQgYmUgYW4gYXJyYXkgb2YgXCIrdFswXStcIiBlbGVtZW50c1wifSl9ZnVuY3Rpb24gY29udmVydFRvVGVuc29yKGUsdCxyLG4pe2lmKHZvaWQgMD09PW4mJihuPVwiZmxvYXQzMlwiKSxuPW58fFwiZmxvYXQzMlwiLGUgaW5zdGFuY2VvZiBUZW5zb3IpcmV0dXJuIGU7aWYoIWlzVHlwZWRBcnJheShlKSYmIUFycmF5LmlzQXJyYXkoZSkmJlwibnVtYmVyXCIhPXR5cGVvZiBlJiZcImJvb2xlYW5cIiE9dHlwZW9mIGUpdGhyb3cgbmV3IEVycm9yKFwiQXJndW1lbnQgJ1wiK3QrXCInIHBhc3NlZCB0byAnXCIrcitcIicgbXVzdCBiZSBhIFRlbnNvciBvciBUZW5zb3JMaWtlLCBidXQgZ290IFwiK2UuY29uc3RydWN0b3IubmFtZSk7dmFyIG89aW5mZXJTaGFwZShlKTtyZXR1cm4gaXNUeXBlZEFycmF5KGUpfHxBcnJheS5pc0FycmF5KGUpfHwoZT1bZV0pLFRlbnNvci5tYWtlKG8se3ZhbHVlczp0b1R5cGVkQXJyYXkoZSxuLEVOVi5nZXQoXCJERUJVR1wiKSl9LG4pfWZ1bmN0aW9uIGNvbnZlcnRUb1RlbnNvckFycmF5KGUsdCxyKXtpZighQXJyYXkuaXNBcnJheShlKSl0aHJvdyBuZXcgRXJyb3IoXCJBcmd1bWVudCBcIit0K1wiIHBhc3NlZCB0byBcIityK1wiIG11c3QgYmUgYSBgVGVuc29yW11gIG9yIGBUZW5zb3JMaWtlW11gXCIpO3JldHVybiBlLm1hcChmdW5jdGlvbihlLG4pe3JldHVybiBjb252ZXJ0VG9UZW5zb3IoZSx0K1wiW1wiK24rXCJdXCIscil9KX1mdW5jdGlvbiBvcChlKXt2YXIgdD1PYmplY3Qua2V5cyhlKTtpZigxIT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiUGxlYXNlIHByb3ZpZGUgYW4gb2JqZWN0IHdpdGggYSBzaW5nbGUga2V5IChvcGVyYXRpb24gbmFtZSkgbWFwcGluZyB0byBhIGZ1bmN0aW9uLiBHb3QgYW4gb2JqZWN0IHdpdGggXCIrdC5sZW5ndGgrXCIga2V5cy5cIik7dmFyIHI9dFswXSxuPWVbcl07ci5lbmRzV2l0aChcIl9cIikmJihyPXIuc3Vic3RyaW5nKDAsci5sZW5ndGgtMSkpO3ZhciBvPWZ1bmN0aW9uKCl7Zm9yKHZhciBlPVtdLHQ9MDt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKWVbdF09YXJndW1lbnRzW3RdO0VOVi5lbmdpbmUuc3RhcnRTY29wZShyKTt0cnl7dmFyIG89bi5hcHBseSh2b2lkIDAsZSk7cmV0dXJuIG8gaW5zdGFuY2VvZiBQcm9taXNlJiZjb25zb2xlLmVycm9yKFwiQ2Fubm90IHJldHVybiBhIFByb21pc2UgaW5zaWRlIG9mIHRpZHkuXCIpLEVOVi5lbmdpbmUuZW5kU2NvcGUobyksb31jYXRjaChlKXt0aHJvdyBFTlYuZW5naW5lLmVuZFNjb3BlKG51bGwpLGV9fTtyZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sXCJuYW1lXCIse3ZhbHVlOnIsY29uZmlndXJhYmxlOiEwfSksb31mdW5jdGlvbiBzb2Z0bWF4XyhlLHQpe3ZvaWQgMD09PXQmJih0PS0xKTt2YXIgcj1jb252ZXJ0VG9UZW5zb3IoZSxcImxvZ2l0c1wiLFwic29mdG1heFwiKTtpZigtMT09PXQmJih0PXIucmFuay0xKSx0IT09ci5yYW5rLTEpdGhyb3cgRXJyb3IoXCJTb2Z0bWF4IGFsb25nIGEgbm9uLWxhc3QgZGltZW5zaW9uIGlzIG5vdCB5ZXQgc3VwcG9ydGVkLiBMb2dpdHMgd2FzIHJhbmsgXCIrci5yYW5rK1wiIGFuZCBkaW0gd2FzIFwiK3QpO3JldHVybiBjdXN0b21HcmFkKGZ1bmN0aW9uKGUpe3ZhciByPWUubG9nU3VtRXhwKFt0XSwhMCksbj1lLnRvRmxvYXQoKS5zdWIocikuZXhwKCk7cmV0dXJue3ZhbHVlOm4sZ3JhZEZ1bmM6ZnVuY3Rpb24oZSl7dmFyIHI9ZS5tdWwobik7cmV0dXJuIHIuc3ViKHIuc3VtKFt0XSwhMCkubXVsKG4pKX19fSkocil9ZnVuY3Rpb24gbG9nU29mdG1heF8oZSx0KXt2b2lkIDA9PT10JiYodD0tMSk7dmFyIHI9Y29udmVydFRvVGVuc29yKGUsXCJsb2dpdHNcIixcImxvZ1NvZnRtYXhcIik7aWYoLTE9PT10JiYodD1yLnJhbmstMSksdCE9PXIucmFuay0xKXRocm93IEVycm9yKFwiTG9nIFNvZnRtYXggYWxvbmcgYSBub24tbGFzdCBkaW1lbnNpb24gaXMgbm90IHlldCBzdXBwb3J0ZWQuIExvZ2l0cyB3YXMgcmFuayBcIityLnJhbmsrXCIgYW5kIGF4aXMgd2FzIFwiK3QpO3JldHVybiBjdXN0b21HcmFkKGZ1bmN0aW9uKGUpe3ZhciByPWUubWF4KHQsITApLG49ZS5zdWIociksbz1uLnRvRmxvYXQoKS5zdWIobi5leHAoKS5zdW0odCwhMCkubG9nKCkpO3JldHVybnt2YWx1ZTpvLGdyYWRGdW5jOmZ1bmN0aW9uKGUpe3ZhciByPW8uZXhwKCk7cmV0dXJuIGUuc3ViKGUuc3VtKHQsITApLm11bChyKSl9fX0pKHIpfXZhciBzb2Z0bWF4PW9wKHtzb2Z0bWF4Xzpzb2Z0bWF4X30pLGxvZ1NvZnRtYXg9b3Aoe2xvZ1NvZnRtYXhfOmxvZ1NvZnRtYXhffSk7ZnVuY3Rpb24gY29tcGxleF8oZSx0KXt2YXIgcj1jb252ZXJ0VG9UZW5zb3IoZSxcInJlYWxcIixcImNvbXBsZXhcIiksbj1jb252ZXJ0VG9UZW5zb3IodCxcImltYWdcIixcImNvbXBsZXhcIik7cmV0dXJuIGFzc2VydFNoYXBlc01hdGNoKHIuc2hhcGUsbi5zaGFwZSxcInJlYWwgYW5kIGltYWcgc2hhcGVzLCBcIityLnNoYXBlK1wiIGFuZCBcIituLnNoYXBlK1wiLCBtdXN0IG1hdGNoIGluIGNhbGwgdG8gdGYuY29tcGxleCgpLlwiKSxFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbihlKXtyZXR1cm4gZS5jb21wbGV4KHIsbil9LHskcmVhbDpyLCRpbWFnOm59KX1mdW5jdGlvbiByZWFsXyhlKXt2YXIgdD1jb252ZXJ0VG9UZW5zb3IoZSxcImlucHV0XCIsXCJyZWFsXCIpO3JldHVybiBFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbihlKXtyZXR1cm4gZS5yZWFsKHQpfSx7JGlucHV0OnR9KX1mdW5jdGlvbiBpbWFnXyhlKXt2YXIgdD1jb252ZXJ0VG9UZW5zb3IoZSxcImlucHV0XCIsXCJpbWFnXCIpO3JldHVybiBFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbihlKXtyZXR1cm4gZS5pbWFnKHQpfSx7JGlucHV0OnR9KX12YXIgY29tcGxleD1vcCh7Y29tcGxleF86Y29tcGxleF99KSxyZWFsPW9wKHtyZWFsXzpyZWFsX30pLGltYWc9b3Aoe2ltYWdfOmltYWdffSk7ZnVuY3Rpb24gdGVuc29yKGUsdCxyKXtpZih2b2lkIDA9PT1yJiYocj1cImZsb2F0MzJcIiksXCJjb21wbGV4NjRcIj09PXIpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbnN0cnVjdCBhIGNvbXBsZXg2NCB0ZW5zb3IgZGlyZWN0bHkuIFBsZWFzZSB1c2UgdGYuY29tcGxleChyZWFsLCBpbWFnKS5cIik7aWYoIWlzVHlwZWRBcnJheShlKSYmIUFycmF5LmlzQXJyYXkoZSkmJlwibnVtYmVyXCIhPXR5cGVvZiBlJiZcImJvb2xlYW5cIiE9dHlwZW9mIGUpdGhyb3cgbmV3IEVycm9yKFwidmFsdWVzIHBhc3NlZCB0byB0ZW5zb3IodmFsdWVzKSBtdXN0IGJlIGFuIGFycmF5IG9mIG51bWJlcnMgb3IgYm9vbGVhbnMsIG9yIGEgVHlwZWRBcnJheVwiKTt2YXIgbj1pbmZlclNoYXBlKGUpO3JldHVybiBudWxsIT10JiYxIT09bi5sZW5ndGgmJmFzc2VydFNoYXBlc01hdGNoKHQsbixcIkVycm9yIGNyZWF0aW5nIGEgbmV3IFRlbnNvci4gSW5mZXJyZWQgc2hhcGUgKFwiK24rXCIpIGRvZXMgbm90IG1hdGNoIHRoZSBwcm92aWRlZCBzaGFwZSAoXCIrdCtcIikuIFwiKSxpc1R5cGVkQXJyYXkoZSl8fEFycmF5LmlzQXJyYXkoZSl8fChlPVtlXSksdD10fHxuLFRlbnNvci5tYWtlKHQse3ZhbHVlczp0b1R5cGVkQXJyYXkoZSxyLEVOVi5nZXQoXCJERUJVR1wiKSl9LHIpfWZ1bmN0aW9uIHNjYWxhcihlLHQpe2lmKHZvaWQgMD09PXQmJih0PVwiZmxvYXQzMlwiKSwoaXNUeXBlZEFycmF5KGUpfHxBcnJheS5pc0FycmF5KGUpKSYmXCJjb21wbGV4NjRcIiE9PXQpdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgY3JlYXRpbmcgYSBuZXcgU2NhbGFyOiB2YWx1ZSBtdXN0IGJlIGEgcHJpbWl0aXZlIChudW1iZXJ8Ym9vbGVhbilcIik7cmV0dXJuIHRlbnNvcihlLFtdLHQpfWZ1bmN0aW9uIHRlbnNvcjFkKGUsdCl7dm9pZCAwPT09dCYmKHQ9XCJmbG9hdDMyXCIpLGFzc2VydE5vbk51bGwoZSk7dmFyIHI9aW5mZXJTaGFwZShlKTtpZigxIT09ci5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yMWQoKSByZXF1aXJlcyB2YWx1ZXMgdG8gYmUgYSBmbGF0L1R5cGVkQXJyYXlcIik7cmV0dXJuIHRlbnNvcihlLHIsdCl9ZnVuY3Rpb24gdGVuc29yMmQoZSx0LHIpe2lmKHZvaWQgMD09PXImJihyPVwiZmxvYXQzMlwiKSxhc3NlcnROb25OdWxsKGUpLG51bGwhPXQmJjIhPT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3IyZCgpIHJlcXVpcmVzIHNoYXBlIHRvIGhhdmUgdHdvIG51bWJlcnNcIik7dmFyIG49aW5mZXJTaGFwZShlKTtpZigyIT09bi5sZW5ndGgmJjEhPT1uLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3IyZCgpIHJlcXVpcmVzIHZhbHVlcyB0byBiZSBudW1iZXJbXVtdIG9yIGZsYXQvVHlwZWRBcnJheVwiKTtpZigxPT09bi5sZW5ndGgmJm51bGw9PXQpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yMmQoKSByZXF1aXJlcyBzaGFwZSB0byBiZSBwcm92aWRlZCB3aGVuIGB2YWx1ZXNgIGFyZSBhIGZsYXQvVHlwZWRBcnJheVwiKTtyZXR1cm4gdGVuc29yKGUsdD10fHxuLHIpfWZ1bmN0aW9uIHRlbnNvcjNkKGUsdCxyKXtpZih2b2lkIDA9PT1yJiYocj1cImZsb2F0MzJcIiksYXNzZXJ0Tm9uTnVsbChlKSxudWxsIT10JiYzIT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yM2QoKSByZXF1aXJlcyBzaGFwZSB0byBoYXZlIHRocmVlIG51bWJlcnNcIik7dmFyIG49aW5mZXJTaGFwZShlKTtpZigzIT09bi5sZW5ndGgmJjEhPT1uLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3IzZCgpIHJlcXVpcmVzIHZhbHVlcyB0byBiZSBudW1iZXJbXVtdW10gb3IgZmxhdC9UeXBlZEFycmF5XCIpO2lmKDE9PT1uLmxlbmd0aCYmbnVsbD09dCl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3IzZCgpIHJlcXVpcmVzIHNoYXBlIHRvIGJlIHByb3ZpZGVkIHdoZW4gYHZhbHVlc2AgYXJlIGEgZmxhdCBhcnJheVwiKTtyZXR1cm4gdGVuc29yKGUsdD10fHxuLHIpfWZ1bmN0aW9uIHRlbnNvcjRkKGUsdCxyKXtpZih2b2lkIDA9PT1yJiYocj1cImZsb2F0MzJcIiksYXNzZXJ0Tm9uTnVsbChlKSxudWxsIT10JiY0IT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yNGQoKSByZXF1aXJlcyBzaGFwZSB0byBoYXZlIGZvdXIgbnVtYmVyc1wiKTt2YXIgbj1pbmZlclNoYXBlKGUpO2lmKDQhPT1uLmxlbmd0aCYmMSE9PW4ubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRlbnNvcjRkKCkgcmVxdWlyZXMgdmFsdWVzIHRvIGJlIG51bWJlcltdW11bXVtdIG9yIGZsYXQvVHlwZWRBcnJheVwiKTtpZigxPT09bi5sZW5ndGgmJm51bGw9PXQpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yNGQoKSByZXF1aXJlcyBzaGFwZSB0byBiZSBwcm92aWRlZCB3aGVuIGB2YWx1ZXNgIGFyZSBhIGZsYXQgYXJyYXlcIik7cmV0dXJuIHRlbnNvcihlLHQ9dHx8bixyKX1mdW5jdGlvbiB0ZW5zb3I1ZChlLHQscil7aWYodm9pZCAwPT09ciYmKHI9XCJmbG9hdDMyXCIpLGFzc2VydE5vbk51bGwoZSksbnVsbCE9dCYmNSE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRlbnNvcjVkKCkgcmVxdWlyZXMgc2hhcGUgdG8gaGF2ZSBmaXZlIG51bWJlcnNcIik7dmFyIG49aW5mZXJTaGFwZShlKTtpZig1IT09bi5sZW5ndGgmJjEhPT1uLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3I1ZCgpIHJlcXVpcmVzIHZhbHVlcyB0byBiZSBudW1iZXJbXVtdW11bXVtdIG9yIGZsYXQvVHlwZWRBcnJheVwiKTtpZigxPT09bi5sZW5ndGgmJm51bGw9PXQpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yNWQoKSByZXF1aXJlcyBzaGFwZSB0byBiZSBwcm92aWRlZCB3aGVuIGB2YWx1ZXNgIGFyZSBhIGZsYXQgYXJyYXlcIik7cmV0dXJuIHRlbnNvcihlLHQ9dHx8bixyKX1mdW5jdGlvbiB0ZW5zb3I2ZChlLHQscil7aWYodm9pZCAwPT09ciYmKHI9XCJmbG9hdDMyXCIpLGFzc2VydE5vbk51bGwoZSksbnVsbCE9dCYmNiE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRlbnNvcjZkKCkgcmVxdWlyZXMgc2hhcGUgdG8gaGF2ZSBzaXggbnVtYmVyc1wiKTt2YXIgbj1pbmZlclNoYXBlKGUpO2lmKDYhPT1uLmxlbmd0aCYmMSE9PW4ubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRlbnNvcjZkKCkgcmVxdWlyZXMgdmFsdWVzIHRvIGJlIG51bWJlcltdW11bXVtdIG9yIGZsYXQvVHlwZWRBcnJheVwiKTtpZigxPT09bi5sZW5ndGgmJm51bGw9PXQpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yNmQoKSByZXF1aXJlcyBzaGFwZSB0byBiZSBwcm92aWRlZCB3aGVuIGB2YWx1ZXNgIGFyZSBhIGZsYXQgYXJyYXlcIik7cmV0dXJuIHRlbnNvcihlLHQ9dHx8bixyKX1mdW5jdGlvbiBvbmVzJDEoZSx0KXtpZih2b2lkIDA9PT10JiYodD1cImZsb2F0MzJcIiksXCJjb21wbGV4NjRcIj09PXQpe3ZhciByPW9uZXMkMShlLFwiZmxvYXQzMlwiKSxuPW9uZXMkMShlLFwiZmxvYXQzMlwiKTtyZXR1cm4gY29tcGxleChyLG4pfXZhciBvPW1ha2VPbmVzVHlwZWRBcnJheShzaXplRnJvbVNoYXBlKGUpLHQpO3JldHVybiBUZW5zb3IubWFrZShlLHt2YWx1ZXM6b30sdCl9ZnVuY3Rpb24gemVyb3MoZSx0KXtpZih2b2lkIDA9PT10JiYodD1cImZsb2F0MzJcIiksXCJjb21wbGV4NjRcIj09PXQpe3ZhciByPXplcm9zKGUsXCJmbG9hdDMyXCIpLG49emVyb3MoZSxcImZsb2F0MzJcIik7cmV0dXJuIGNvbXBsZXgocixuKX12YXIgbz1tYWtlWmVyb3NUeXBlZEFycmF5KHNpemVGcm9tU2hhcGUoZSksdCk7cmV0dXJuIFRlbnNvci5tYWtlKGUse3ZhbHVlczpvfSx0KX1mdW5jdGlvbiBmaWxsKGUsdCxyKXt2b2lkIDA9PT1yJiYocj1cImZsb2F0MzJcIik7dmFyIG49Z2V0VHlwZWRBcnJheUZyb21EVHlwZShyLHNpemVGcm9tU2hhcGUoZSkpO3JldHVybiBuLmZpbGwodCksVGVuc29yLm1ha2UoZSx7dmFsdWVzOm59LHIpfWZ1bmN0aW9uIG9uZXNMaWtlXyhlKXt2YXIgdD1jb252ZXJ0VG9UZW5zb3IoZSxcInhcIixcIm9uZXNMaWtlXCIpO3JldHVybiBvbmVzJDEodC5zaGFwZSx0LmR0eXBlKX1mdW5jdGlvbiB6ZXJvc0xpa2VfKGUpe3ZhciB0PWNvbnZlcnRUb1RlbnNvcihlLFwieFwiLFwiemVyb3NMaWtlXCIpO3JldHVybiB6ZXJvcyh0LnNoYXBlLHQuZHR5cGUpfWZ1bmN0aW9uIGxpbnNwYWNlKGUsdCxyKXtpZigwPT09cil0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVxdWVzdCB6ZXJvIHNhbXBsZXNcIik7dmFyIG49KHQtZSkvKHItMSksbz1tYWtlWmVyb3NUeXBlZEFycmF5KHIsXCJmbG9hdDMyXCIpO29bMF09ZTtmb3IodmFyIGE9MTthPG8ubGVuZ3RoO2ErKylvW2FdPW9bYS0xXStuO3JldHVybiB0ZW5zb3IxZChvLFwiZmxvYXQzMlwiKX1mdW5jdGlvbiByYW5nZShlLHQscixuKXtpZih2b2lkIDA9PT1yJiYocj0xKSx2b2lkIDA9PT1uJiYobj1cImZsb2F0MzJcIiksMD09PXIpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGhhdmUgYSBzdGVwIG9mIHplcm9cIik7aWYoZT09PXR8fGU8dCYmcjwwfHx0PGUmJnI+MSlyZXR1cm4gemVyb3MoWzBdLG4pO3ZhciBvPW1ha2VaZXJvc1R5cGVkQXJyYXkoTWF0aC5hYnMoTWF0aC5jZWlsKCh0LWUpL3IpKSxuKTt0PGUmJjE9PT1yJiYocj0tMSksb1swXT1lO2Zvcih2YXIgYT0xO2E8by5sZW5ndGg7YSsrKW9bYV09b1thLTFdK3I7cmV0dXJuIHRlbnNvcjFkKG8sbil9dmFyIERUeXBlLFJhbmssVXBjYXN0SW50MzJBbmRNYXAsVXBjYXN0Qm9vbEFuZE1hcCxVcGNhc3RGbG9hdDMyQW5kTWFwLFVwY2FzdENvbXBsZXg2NEFuZE1hcCxvbmVzTGlrZT1vcCh7b25lc0xpa2VfOm9uZXNMaWtlX30pLHplcm9zTGlrZT1vcCh7emVyb3NMaWtlXzp6ZXJvc0xpa2VffSk7IWZ1bmN0aW9uKGUpe2UuZmxvYXQzMj1cImZsb2F0MzJcIixlLmludDMyPVwiaW50MzJcIixlLmJvb2w9XCJib29sXCJ9KERUeXBlfHwoRFR5cGU9e30pKSxmdW5jdGlvbihlKXtlLlIwPVwiUjBcIixlLlIxPVwiUjFcIixlLlIyPVwiUjJcIixlLlIzPVwiUjNcIixlLlI0PVwiUjRcIixlLlI1PVwiUjVcIixlLlI2PVwiUjZcIn0oUmFua3x8KFJhbms9e30pKSxmdW5jdGlvbihlKXtlLmZsb2F0MzI9XCJmbG9hdDMyXCIsZS5pbnQzMj1cImludDMyXCIsZS5ib29sPVwiaW50MzJcIixlLmNvbXBsZXg2ND1cImNvbXBsZXg2NFwifShVcGNhc3RJbnQzMkFuZE1hcHx8KFVwY2FzdEludDMyQW5kTWFwPXt9KSksZnVuY3Rpb24oZSl7ZS5mbG9hdDMyPVwiZmxvYXQzMlwiLGUuaW50MzI9XCJpbnQzMlwiLGUuYm9vbD1cImJvb2xcIixlLmNvbXBsZXg2ND1cImNvbXBsZXg2NFwifShVcGNhc3RCb29sQW5kTWFwfHwoVXBjYXN0Qm9vbEFuZE1hcD17fSkpLGZ1bmN0aW9uKGUpe2UuZmxvYXQzMj1cImZsb2F0MzJcIixlLmludDMyPVwiZmxvYXQzMlwiLGUuYm9vbD1cImZsb2F0MzJcIixlLmNvbXBsZXg2ND1cImNvbXBsZXg2NFwifShVcGNhc3RGbG9hdDMyQW5kTWFwfHwoVXBjYXN0RmxvYXQzMkFuZE1hcD17fSkpLGZ1bmN0aW9uKGUpe2UuZmxvYXQzMj1cImNvbXBsZXg2NFwiLGUuaW50MzI9XCJjb21wbGV4NjRcIixlLmJvb2w9XCJjb21wbGV4NjRcIixlLmNvbXBsZXg2ND1cImNvbXBsZXg2NFwifShVcGNhc3RDb21wbGV4NjRBbmRNYXB8fChVcGNhc3RDb21wbGV4NjRBbmRNYXA9e30pKTt2YXIgdXBjYXN0VHlwZU1hcD17ZmxvYXQzMjpVcGNhc3RGbG9hdDMyQW5kTWFwLGludDMyOlVwY2FzdEludDMyQW5kTWFwLGJvb2w6VXBjYXN0Qm9vbEFuZE1hcCxjb21wbGV4NjQ6VXBjYXN0Q29tcGxleDY0QW5kTWFwfTtmdW5jdGlvbiB1cGNhc3RUeXBlKGUsdCl7cmV0dXJuIHVwY2FzdFR5cGVNYXBbZV1bdF19ZnVuY3Rpb24gc3VtT3V0VHlwZShlKXtyZXR1cm4gdXBjYXN0VHlwZShlLFwiaW50MzJcIil9dmFyIERhdGFTdG9yYWdlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlKXt0aGlzLmRhdGFNb3Zlcj1lLHRoaXMuZGF0YT1uZXcgV2Vha01hcH1yZXR1cm4gZS5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmRhdGEuaGFzKGUpfHx0aGlzLmRhdGFNb3Zlci5tb3ZlRGF0YShlKSx0aGlzLmRhdGEuZ2V0KGUpfSxlLnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24oZSx0KXt0aGlzLmRhdGEuc2V0KGUsdCl9LGUucHJvdG90eXBlLmhhcz1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5kYXRhLmhhcyhlKX0sZS5wcm90b3R5cGUuZGVsZXRlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmRhdGEuZGVsZXRlKGUpfSxlfSgpLEtlcm5lbEJhY2tlbmQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKCl7fXJldHVybiBlLnByb3RvdHlwZS50aW1lPWZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWQuXCIpfSxlLnByb3RvdHlwZS5yZWFkPWZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWQuXCIpfSxlLnByb3RvdHlwZS5yZWFkU3luYz1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkLlwiKX0sZS5wcm90b3R5cGUuZGlzcG9zZURhdGE9ZnVuY3Rpb24oZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZC5cIil9LGUucHJvdG90eXBlLndyaXRlPWZ1bmN0aW9uKGUsdCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZC5cIil9LGUucHJvdG90eXBlLmZyb21QaXhlbHM9ZnVuY3Rpb24oZSx0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkLlwiKX0sZS5wcm90b3R5cGUucmVnaXN0ZXI9ZnVuY3Rpb24oZSx0LHIpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWQuXCIpfSxlLnByb3RvdHlwZS5tZW1vcnk9ZnVuY3Rpb24oKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkLlwiKX0sZS5wcm90b3R5cGUuZmxvYXRQcmVjaXNpb249ZnVuY3Rpb24oKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSxlLnByb3RvdHlwZS5iYXRjaE1hdE11bD1mdW5jdGlvbihlLHQscixuKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSxlLnByb3RvdHlwZS5zbGljZT1mdW5jdGlvbihlLHQscil7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sZS5wcm90b3R5cGUuc3RyaWRlZFNsaWNlPWZ1bmN0aW9uKGUsdCxyLG4sbyxhLGkscyx1KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSxlLnByb3RvdHlwZS5yZXZlcnNlPWZ1bmN0aW9uKGUsdCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sZS5wcm90b3R5cGUuY29uY2F0PWZ1bmN0aW9uKGUsdCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sZS5wcm90b3R5cGUubmVnPWZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LGUucHJvdG90eXBlLmFkZD1mdW5jdGlvbihlLHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LGUucHJvdG90eXBlLmFkZE49ZnVuY3Rpb24oZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sZS5wcm90b3R5cGUuc3VidHJhY3Q9ZnVuY3Rpb24oZSx0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSxlLnByb3RvdHlwZS5tdWx0aXBseT1mdW5jdGlvbihlLHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LGUucHJvdG90eXBlLnJlYWxEaXZpZGU9ZnVuY3Rpb24oZSx0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSxlLnByb3RvdHlwZS5mbG9vckRpdj1mdW5jdGlvbihlLHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LGUucHJvdG90eXBlLnN1bT1mdW5jdGlvbihlLHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LGUucHJvdG90eXBlLnByb2Q9ZnVuY3Rpb24oZSx0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSxlLnByb3RvdHlwZS51bnNvcnRlZFNlZ21lbnRTdW09ZnVuY3Rpb24oZSx0LHIpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LGUucHJvdG90eXBlLmFyZ01pbj1mdW5jdGlvbihlLHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LGUucHJvdG90eXBlLmFyZ01heD1mdW5jdGlvbihlLHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LGUucHJvdG90eXBlLmVxdWFsPWZ1bmN0aW9uKGUsdCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sZS5wcm90b3R5cGUubm90RXF1YWw9ZnVuY3Rpb24oZSx0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSxlLnByb3RvdHlwZS5sZXNzPWZ1bmN0aW9uKGUsdCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sZS5wcm90b3R5cGUubGVzc0VxdWFsPWZ1bmN0aW9uKGUsdCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sZS5wcm90b3R5cGUuZ3JlYXRlcj1mdW5jdGlvbihlLHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LGUucHJvdG90eXBlLmdyZWF0ZXJFcXVhbD1mdW5jdGlvbihlLHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LGUucHJvdG90eXBlLmxvZ2ljYWxOb3Q9ZnVuY3Rpb24oZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sZS5wcm90b3R5cGUubG9naWNhbEFuZD1mdW5jdGlvbihlLHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LGUucHJvdG90eXBlLmxvZ2ljYWxPcj1mdW5jdGlvbihlLHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LGUucHJvdG90eXBlLndoZXJlPWZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LGUucHJvdG90eXBlLnNlbGVjdD1mdW5jdGlvbihlLHQscil7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sZS5wcm90b3R5cGUudG9waz1mdW5jdGlvbihlLHQscil7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sZS5wcm90b3R5cGUubWluPWZ1bmN0aW9uKGUsdCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sZS5wcm90b3R5cGUubWluaW11bT1mdW5jdGlvbihlLHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LGUucHJvdG90eXBlLm1vZD1mdW5jdGlvbihlLHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LGUucHJvdG90eXBlLm1heD1mdW5jdGlvbihlLHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LGUucHJvdG90eXBlLm1heGltdW09ZnVuY3Rpb24oZSx0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSxlLnByb3RvdHlwZS5hbGw9ZnVuY3Rpb24oZSx0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSxlLnByb3RvdHlwZS5hbnk9ZnVuY3Rpb24oZSx0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSxlLnByb3RvdHlwZS5zcXVhcmVkRGlmZmVyZW5jZT1mdW5jdGlvbihlLHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LGUucHJvdG90eXBlLmNlaWw9ZnVuY3Rpb24oZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sZS5wcm90b3R5cGUuZmxvb3I9ZnVuY3Rpb24oZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sZS5wcm90b3R5cGUucm91bmQ9ZnVuY3Rpb24oZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sZS5wcm90b3R5cGUuc2lnbj1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSxlLnByb3RvdHlwZS5wb3c9ZnVuY3Rpb24oZSx0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSxlLnByb3RvdHlwZS5leHA9ZnVuY3Rpb24oZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sZS5wcm90b3R5cGUuZXhwbTE9ZnVuY3Rpb24oZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sZS5wcm90b3R5cGUubG9nPWZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LGUucHJvdG90eXBlLmxvZzFwPWZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LGUucHJvdG90eXBlLnNxcnQ9ZnVuY3Rpb24oZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sZS5wcm90b3R5cGUucnNxcnQ9ZnVuY3Rpb24oZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sZS5wcm90b3R5cGUuc3F1YXJlPWZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LGUucHJvdG90eXBlLnJlY2lwcm9jYWw9ZnVuY3Rpb24oZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sZS5wcm90b3R5cGUucmVsdT1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSxlLnByb3RvdHlwZS5lbHU9ZnVuY3Rpb24oZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sZS5wcm90b3R5cGUuZWx1RGVyPWZ1bmN0aW9uKGUsdCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sZS5wcm90b3R5cGUuc2VsdT1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSxlLnByb3RvdHlwZS5pbnQ9ZnVuY3Rpb24oZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sZS5wcm90b3R5cGUuY2xpcD1mdW5jdGlvbihlLHQscil7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sZS5wcm90b3R5cGUuYWJzPWZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LGUucHJvdG90eXBlLmNvbXBsZXhBYnM9ZnVuY3Rpb24oZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sZS5wcm90b3R5cGUuc2lnbW9pZD1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSxlLnByb3RvdHlwZS5zb2Z0cGx1cz1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSxlLnByb3RvdHlwZS5zaW49ZnVuY3Rpb24oZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sZS5wcm90b3R5cGUuY29zPWZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LGUucHJvdG90eXBlLnRhbj1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSxlLnByb3RvdHlwZS5hc2luPWZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LGUucHJvdG90eXBlLmFjb3M9ZnVuY3Rpb24oZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sZS5wcm90b3R5cGUuYXRhbj1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSxlLnByb3RvdHlwZS5hdGFuMj1mdW5jdGlvbihlLHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LGUucHJvdG90eXBlLnNpbmg9ZnVuY3Rpb24oZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sZS5wcm90b3R5cGUuY29zaD1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSxlLnByb3RvdHlwZS50YW5oPWZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LGUucHJvdG90eXBlLmFzaW5oPWZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LGUucHJvdG90eXBlLmFjb3NoPWZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LGUucHJvdG90eXBlLmF0YW5oPWZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LGUucHJvdG90eXBlLmVyZj1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSxlLnByb3RvdHlwZS5zdGVwPWZ1bmN0aW9uKGUsdCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sZS5wcm90b3R5cGUuY29udjJkPWZ1bmN0aW9uKGUsdCxyKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSxlLnByb3RvdHlwZS5jb252MmREZXJJbnB1dD1mdW5jdGlvbihlLHQscil7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sZS5wcm90b3R5cGUuY29udjJkRGVyRmlsdGVyPWZ1bmN0aW9uKGUsdCxyKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSxlLnByb3RvdHlwZS5kZXB0aHdpc2VDb252MkQ9ZnVuY3Rpb24oZSx0LHIpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LGUucHJvdG90eXBlLmRlcHRod2lzZUNvbnYyRERlcklucHV0PWZ1bmN0aW9uKGUsdCxyKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSxlLnByb3RvdHlwZS5kZXB0aHdpc2VDb252MkREZXJGaWx0ZXI9ZnVuY3Rpb24oZSx0LHIpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LGUucHJvdG90eXBlLm1heFBvb2w9ZnVuY3Rpb24oZSx0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSxlLnByb3RvdHlwZS5tYXhQb29sQmFja3Byb3A9ZnVuY3Rpb24oZSx0LHIsbil7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sZS5wcm90b3R5cGUuYXZnUG9vbD1mdW5jdGlvbihlLHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LGUucHJvdG90eXBlLmF2Z1Bvb2xCYWNrcHJvcD1mdW5jdGlvbihlLHQscil7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sZS5wcm90b3R5cGUucmVzaGFwZT1mdW5jdGlvbihlLHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LGUucHJvdG90eXBlLmNhc3Q9ZnVuY3Rpb24oZSx0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSxlLnByb3RvdHlwZS50aWxlPWZ1bmN0aW9uKGUsdCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sZS5wcm90b3R5cGUucGFkPWZ1bmN0aW9uKGUsdCxyKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSxlLnByb3RvdHlwZS50cmFuc3Bvc2U9ZnVuY3Rpb24oZSx0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSxlLnByb3RvdHlwZS5nYXRoZXI9ZnVuY3Rpb24oZSx0LHIpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LGUucHJvdG90eXBlLmdhdGhlck5EPWZ1bmN0aW9uKGUsdCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sZS5wcm90b3R5cGUuc2NhdHRlck5EPWZ1bmN0aW9uKGUsdCxyKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSxlLnByb3RvdHlwZS5iYXRjaFRvU3BhY2VORD1mdW5jdGlvbihlLHQscil7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sZS5wcm90b3R5cGUuc3BhY2VUb0JhdGNoTkQ9ZnVuY3Rpb24oZSx0LHIpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LGUucHJvdG90eXBlLnJlc2l6ZUJpbGluZWFyPWZ1bmN0aW9uKGUsdCxyLG4pe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LGUucHJvdG90eXBlLnJlc2l6ZUJpbGluZWFyQmFja3Byb3A9ZnVuY3Rpb24oZSx0LHIpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LGUucHJvdG90eXBlLnJlc2l6ZU5lYXJlc3ROZWlnaGJvcj1mdW5jdGlvbihlLHQscixuKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSxlLnByb3RvdHlwZS5yZXNpemVOZWFyZXN0TmVpZ2hib3JCYWNrcHJvcD1mdW5jdGlvbihlLHQscil7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sZS5wcm90b3R5cGUuYmF0Y2hOb3JtYWxpemF0aW9uPWZ1bmN0aW9uKGUsdCxyLG4sbyxhKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSxlLnByb3RvdHlwZS5sb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbjREPWZ1bmN0aW9uKGUsdCxyLG4sbyl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sZS5wcm90b3R5cGUuTFJOR3JhZD1mdW5jdGlvbihlLHQscixuLG8sYSxpKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSxlLnByb3RvdHlwZS5tdWx0aW5vbWlhbD1mdW5jdGlvbihlLHQscixuKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSxlLnByb3RvdHlwZS5vbmVIb3Q9ZnVuY3Rpb24oZSx0LHIsbil7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sZS5wcm90b3R5cGUuY3Vtc3VtPWZ1bmN0aW9uKGUsdCxyLG4pe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LGUucHJvdG90eXBlLm5vbk1heFN1cHByZXNzaW9uPWZ1bmN0aW9uKGUsdCxyLG4sbyl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sZS5wcm90b3R5cGUuZmZ0PWZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LGUucHJvdG90eXBlLmlmZnQ9ZnVuY3Rpb24oZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sZS5wcm90b3R5cGUuY29tcGxleD1mdW5jdGlvbihlLHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LGUucHJvdG90eXBlLnJlYWw9ZnVuY3Rpb24oZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sZS5wcm90b3R5cGUuaW1hZz1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSxlLnByb3RvdHlwZS5jcm9wQW5kUmVzaXplPWZ1bmN0aW9uKGUsdCxyLG4sbyxhKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSxlLnByb3RvdHlwZS5kZXB0aFRvU3BhY2U9ZnVuY3Rpb24oZSx0LHIpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LGUucHJvdG90eXBlLnNwbGl0PWZ1bmN0aW9uKGUsdCxyKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSxlLnByb3RvdHlwZS5zcGFyc2VUb0RlbnNlPWZ1bmN0aW9uKGUsdCxyLG4pe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LGUucHJvdG90eXBlLnNldERhdGFNb3Zlcj1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSxlLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sZX0oKTtmdW5jdGlvbiBjYXN0VGVuc29yKGUsdCxyKXtpZihcImNvbXBsZXg2NFwiPT09dCl7aWYoXCJjb21wbGV4NjRcIj09PWUuZHR5cGUpcmV0dXJuIGUuY2xvbmUoKTt2YXIgbj16ZXJvcyhlLnNoYXBlKSxvPWUudG9GbG9hdCgpLGE9ci5jb21wbGV4KG8sbik7cmV0dXJuIG4uZGlzcG9zZSgpLG8uZGlzcG9zZSgpLGF9aWYoIWhhc0VuY29kaW5nTG9zcyhlLmR0eXBlLHQpKXJldHVybiBUZW5zb3IubWFrZShlLnNoYXBlLHtkYXRhSWQ6ZS5kYXRhSWR9LHQpO2lmKFwiY29tcGxleDY0XCI9PT1lLmR0eXBlKXt2YXIgaT1yLnJlYWwoZSk7YT1pLmNhc3QodCk7cmV0dXJuIGkuZGlzcG9zZSgpLGF9aWYoXCJpbnQzMlwiPT09dClyZXR1cm4gci5pbnQoZSk7aWYoXCJib29sXCI9PT10KXt2YXIgcz1zY2FsYXIoMCxlLmR0eXBlKTthPXIubm90RXF1YWwoZSxzKTtyZXR1cm4gcy5kaXNwb3NlKCksYX10aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBpbiBDYXN0OiB1bmtub3duIGR0eXBlIGFyZ3VtZW50IChcIit0K1wiKVwiKX1mdW5jdGlvbiByZXNoYXBlVGVuc29yKGUsdCl7cmV0dXJuIFRlbnNvci5tYWtlKHQse2RhdGFJZDplLmRhdGFJZH0sZS5kdHlwZSl9ZnVuY3Rpb24gbWVyZ2VSZWFsQW5kSW1hZ0FycmF5cyhlLHQpe2lmKGUubGVuZ3RoIT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IG1lcmdlIHJlYWwgYW5kIGltYWcgYXJyYXlzIG9mIGRpZmZlcmVudCBsZW5ndGhzLiByZWFsOlwiK2UubGVuZ3RoK1wiLCBpbWFnOiBcIit0Lmxlbmd0aCtcIi5cIik7Zm9yKHZhciByPW5ldyBGbG9hdDMyQXJyYXkoMiplLmxlbmd0aCksbj0wO248ci5sZW5ndGg7bis9MilyW25dPWVbbi8yXSxyW24rMV09dFtuLzJdO3JldHVybiByfWZ1bmN0aW9uIHNwbGl0UmVhbEFuZEltYWdBcnJheXMoZSl7Zm9yKHZhciB0PW5ldyBGbG9hdDMyQXJyYXkoZS5sZW5ndGgvMikscj1uZXcgRmxvYXQzMkFycmF5KGUubGVuZ3RoLzIpLG49MDtuPGUubGVuZ3RoO24rPTIpdFtuLzJdPWVbbl0scltuLzJdPWVbbisxXTtyZXR1cm57cmVhbDp0LGltYWc6cn19ZnVuY3Rpb24gY29tcGxleFdpdGhFdmVuSW5kZXgoZSl7Zm9yKHZhciB0PU1hdGguY2VpbChlLmxlbmd0aC80KSxyPW5ldyBGbG9hdDMyQXJyYXkodCksbj1uZXcgRmxvYXQzMkFycmF5KHQpLG89MDtvPGUubGVuZ3RoO28rPTQpcltNYXRoLmZsb29yKG8vNCldPWVbb10sbltNYXRoLmZsb29yKG8vNCldPWVbbysxXTtyZXR1cm57cmVhbDpyLGltYWc6bn19ZnVuY3Rpb24gY29tcGxleFdpdGhPZGRJbmRleChlKXtmb3IodmFyIHQ9TWF0aC5mbG9vcihlLmxlbmd0aC80KSxyPW5ldyBGbG9hdDMyQXJyYXkodCksbj1uZXcgRmxvYXQzMkFycmF5KHQpLG89MjtvPGUubGVuZ3RoO28rPTQpcltNYXRoLmZsb29yKG8vNCldPWVbb10sbltNYXRoLmZsb29yKG8vNCldPWVbbysxXTtyZXR1cm57cmVhbDpyLGltYWc6bn19ZnVuY3Rpb24gZ2V0Q29tcGxleFdpdGhJbmRleChlLHQpe3JldHVybntyZWFsOmVbMip0XSxpbWFnOmVbMip0KzFdfX1mdW5jdGlvbiBhc3NpZ25Ub1R5cGVkQXJyYXkoZSx0LHIsbil7ZVsyKm5dPXQsZVsyKm4rMV09cn1mdW5jdGlvbiBleHBvbmVudHMoZSx0KXtmb3IodmFyIHI9bmV3IEZsb2F0MzJBcnJheShlLzIpLG49bmV3IEZsb2F0MzJBcnJheShlLzIpLG89MDtvPE1hdGguY2VpbChlLzIpO28rKyl7dmFyIGE9KHQ/MjotMikqTWF0aC5QSSooby9lKTtyW29dPU1hdGguY29zKGEpLG5bb109TWF0aC5zaW4oYSl9cmV0dXJue3JlYWw6cixpbWFnOm59fWZ1bmN0aW9uIGV4cG9uZW50KGUsdCxyKXt2YXIgbj0ocj8yOi0yKSpNYXRoLlBJKihlL3QpO3JldHVybntyZWFsOk1hdGguY29zKG4pLGltYWc6TWF0aC5zaW4obil9fWZ1bmN0aW9uIG5vbk1heFN1cHByZXNzaW9uSW1wbChlLHQscixuLG8pe2Zvcih2YXIgYT1BcnJheS5mcm9tKHQpLm1hcChmdW5jdGlvbihlLHQpe3JldHVybntzY29yZTplLGJveEluZGV4OnR9fSkuZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiBlLnNjb3JlPm99KS5zb3J0KGZ1bmN0aW9uKGUsdCl7cmV0dXJuIHQuc2NvcmUtZS5zY29yZX0pLGk9W10scz0wO3M8YS5sZW5ndGg7cysrKXt2YXIgdT1hW3NdLGw9dS5zY29yZSxjPXUuYm94SW5kZXg7aWYobDxvKWJyZWFrO2Zvcih2YXIgcD0hMSxkPWkubGVuZ3RoLTE7ZD49MDstLWQpe2lmKGludGVyc2VjdGlvbk92ZXJVbmlvbihlLGMsaVtkXSk+PW4pe3A9ITA7YnJlYWt9fWlmKCFwJiYoaS5wdXNoKGMpLGkubGVuZ3RoPj1yKSlicmVha31yZXR1cm4gdGVuc29yMWQoaSxcImludDMyXCIpfWZ1bmN0aW9uIGludGVyc2VjdGlvbk92ZXJVbmlvbihlLHQscil7dmFyIG49ZS5zdWJhcnJheSg0KnQsNCp0KzQpLG89ZS5zdWJhcnJheSg0KnIsNCpyKzQpLGE9TWF0aC5taW4oblswXSxuWzJdKSxpPU1hdGgubWluKG5bMV0sblszXSkscz1NYXRoLm1heChuWzBdLG5bMl0pLHU9TWF0aC5tYXgoblsxXSxuWzNdKSxsPU1hdGgubWluKG9bMF0sb1syXSksYz1NYXRoLm1pbihvWzFdLG9bM10pLHA9TWF0aC5tYXgob1swXSxvWzJdKSxkPU1hdGgubWF4KG9bMV0sb1szXSksaD0ocy1hKSoodS1pKSxmPShwLWwpKihkLWMpO2lmKGg8PTB8fGY8PTApcmV0dXJuIDA7dmFyIG09TWF0aC5tYXgoYSxsKSxnPU1hdGgubWF4KGksYyksdj1NYXRoLm1pbihzLHApLHk9TWF0aC5taW4odSxkKSx4PU1hdGgubWF4KHYtbSwwKSpNYXRoLm1heCh5LWcsMCk7cmV0dXJuIHgvKGgrZi14KX1mdW5jdGlvbiBzcGxpdChlLHQscil7dmFyIG49QXJyYXkoZS5yYW5rKS5maWxsKDApLG89ZS5zaGFwZS5zbGljZSgpO3JldHVybiB0Lm1hcChmdW5jdGlvbih0KXtvW3JdPXQ7dmFyIGE9ZS5zbGljZShuLG8pO3JldHVybiBuW3JdKz10LGF9KX1mdW5jdGlvbiB0b3BrSW1wbChlLHQscixuLG8pe2Zvcih2YXIgYT10W3QubGVuZ3RoLTFdLGk9W2UubGVuZ3RoL2EsYV0scz1pWzBdLHU9aVsxXSxsPWdldFR5cGVkQXJyYXlGcm9tRFR5cGUocixzKm4pLGM9Z2V0VHlwZWRBcnJheUZyb21EVHlwZShcImludDMyXCIscypuKSxwPTA7cDxzO3ArKyl7Zm9yKHZhciBkPXAqdSxoPWUuc3ViYXJyYXkoZCxkK3UpLGY9W10sbT0wO208aC5sZW5ndGg7bSsrKWYucHVzaCh7dmFsdWU6aFttXSxpbmRleDptfSk7Zi5zb3J0KGZ1bmN0aW9uKGUsdCl7cmV0dXJuIHQudmFsdWUtZS52YWx1ZX0pO3ZhciBnPXAqbix2PWwuc3ViYXJyYXkoZyxnK24pLHk9Yy5zdWJhcnJheShnLGcrbik7Zm9yKG09MDttPG47bSsrKXZbbV09ZlttXS52YWx1ZSx5W21dPWZbbV0uaW5kZXh9dmFyIHg9dC5zbGljZSgpO3JldHVybiB4W3gubGVuZ3RoLTFdPW4sW3RlbnNvcihsLHgsciksdGVuc29yKGMseCxcImludDMyXCIpXX12YXIgQXJnTWluTWF4UHJvZ3JhbT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihlLHQscil7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl07dmFyIG49ZS53aW5kb3dTaXplLG89ZS5iYXRjaFNpemUsYT1lLmluU2l6ZSxpPU1hdGguY2VpbChhL24pO3J8fHRoaXMudmFyaWFibGVOYW1lcy5wdXNoKFwiYmVzdEluZGljZXNBXCIpLHRoaXMub3V0cHV0U2hhcGU9W28saV07dmFyIHM9XCJtYXhcIj09PXQ/XCI+XCI6XCI8XCIsdT1yP1wiaW5PZmZzZXQgKyBpO1wiOlwicm91bmQoZ2V0QmVzdEluZGljZXNBKGJhdGNoLCBpbk9mZnNldCArIGkpKTtcIjt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgb3V0SWR4ID0gY29vcmRzWzFdO1xcbiAgICAgICAgaW50IGluT2Zmc2V0ID0gb3V0SWR4ICogXCIrbitcIjtcXG5cXG4gICAgICAgIGludCBiZXN0SW5kZXggPSBpbk9mZnNldDtcXG4gICAgICAgIGZsb2F0IGJlc3RWYWx1ZSA9IGdldEEoYmF0Y2gsIGJlc3RJbmRleCk7XFxuXFxuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFwiK24rXCI7IGkrKykge1xcbiAgICAgICAgICBpbnQgaW5JZHggPSBcIit1K1wiO1xcbiAgICAgICAgICBmbG9hdCBjYW5kaWRhdGUgPSBnZXRBKGJhdGNoLCBpbklkeCk7XFxuICAgICAgICAgIGlmIChjYW5kaWRhdGUgXCIrcytcIiBiZXN0VmFsdWUpIHtcXG4gICAgICAgICAgICBiZXN0VmFsdWUgPSBjYW5kaWRhdGU7XFxuICAgICAgICAgICAgYmVzdEluZGV4ID0gaW5JZHg7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChmbG9hdChiZXN0SW5kZXgpKTtcXG4gICAgICB9XFxuICAgIFwifX0oKSxBdmdQb29sMkRCYWNrcHJvcFByb2dyYW09ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oZSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcImR5XCJdLHRoaXMub3V0cHV0U2hhcGU9ZS5pblNoYXBlO3ZhciB0PWUuZmlsdGVySGVpZ2h0LHI9ZS5maWx0ZXJXaWR0aCxuPWUuc3RyaWRlSGVpZ2h0LG89ZS5zdHJpZGVXaWR0aCxhPWUuZGlsYXRpb25IZWlnaHQsaT1lLmRpbGF0aW9uV2lkdGgscz1lLmVmZmVjdGl2ZUZpbHRlckhlaWdodCx1PWUuZWZmZWN0aXZlRmlsdGVyV2lkdGgsbD1zLTEtZS5wYWRJbmZvLnRvcCxjPXUtMS1lLnBhZEluZm8ubGVmdCxwPTEvKHQqcik7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMihcIitsK1wiLCBcIitjK1wiKTtcXG4gICAgICBjb25zdCBmbG9hdCBhdmdNdWx0aXBsaWVyID0gZmxvYXQoXCIrcCtcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYiA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBkID0gY29vcmRzWzNdO1xcblxcbiAgICAgICAgaXZlYzIgZHlSQ0Nvcm5lciA9IGNvb3Jkcy55eiAtIHBhZHM7XFxuICAgICAgICBpbnQgZHlSQ29ybmVyID0gZHlSQ0Nvcm5lci54O1xcbiAgICAgICAgaW50IGR5Q0Nvcm5lciA9IGR5UkNDb3JuZXIueTtcXG5cXG4gICAgICAgIC8vIENvbnZvbHZlIGR5KD8sID8sIGQpIHdpdGggcG9zIG1hc2soOiwgOiwgZCkgdG8gZ2V0IGR4KHhSLCB4QywgZCkuXFxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cXG4gICAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XFxuICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgXCIrcytcIjtcXG4gICAgICAgICAgICB3UiArPSBcIithK1wiKSB7XFxuICAgICAgICAgIGZsb2F0IGR5UiA9IGZsb2F0KGR5UkNvcm5lciArIHdSKSAvIFwiK24rXCIuMDtcXG5cXG4gICAgICAgICAgaWYgKGR5UiA8IDAuMCB8fCBkeVIgPj0gXCIrZS5vdXRIZWlnaHQrXCIuMCB8fCBmcmFjdChkeVIpID4gMC4wKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaW50IGlkeVIgPSBpbnQoZHlSKTtcXG5cXG4gICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8IFwiK3UrXCI7XFxuICAgICAgICAgICAgd0MrPSBcIitpK1wiKSB7XFxuICAgICAgICAgICAgZmxvYXQgZHlDID0gZmxvYXQoZHlDQ29ybmVyICsgd0MpIC8gXCIrbytcIi4wO1xcblxcbiAgICAgICAgICAgIGlmIChkeUMgPCAwLjAgfHwgZHlDID49IFwiK2Uub3V0V2lkdGgrXCIuMCB8fFxcbiAgICAgICAgICAgICAgICBmcmFjdChkeUMpID4gMC4wKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaW50IGlkeUMgPSBpbnQoZHlDKTtcXG5cXG4gICAgICAgICAgICBmbG9hdCBkeVZhbHVlID0gZ2V0RHkoYiwgaWR5UiwgaWR5QywgZCk7XFxuXFxuICAgICAgICAgICAgZG90UHJvZCArPSBkeVZhbHVlICogYXZnTXVsdGlwbGllcjtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KGRvdFByb2QpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpO2Z1bmN0aW9uIGdldEJyb2FkY2FzdERpbXMoZSx0KXtmb3IodmFyIHI9ZS5sZW5ndGgsbj1bXSxvPTA7bzxyO28rKyl7dmFyIGE9ci0xLW8saT1lW2FdfHwxOyh0W3QubGVuZ3RoLTEtb118fDEpPjEmJjE9PT1pJiZuLnVuc2hpZnQoYSl9cmV0dXJuIG59ZnVuY3Rpb24gZ2V0UmVkdWN0aW9uQXhlcyhlLHQpe2Zvcih2YXIgcj1bXSxuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciBvPWVbZS5sZW5ndGgtbi0xXSxhPXQubGVuZ3RoLW4tMSxpPXRbYV07KG51bGw9PW98fDE9PT1vJiZpPjEpJiZyLnVuc2hpZnQoYSl9cmV0dXJuIHJ9ZnVuY3Rpb24gYnJvYWRjYXN0RGltc0FyZU91dGVyKGUpe2Zvcih2YXIgdD0wO3Q8ZS5sZW5ndGg7dCsrKWlmKGVbdF0hPT10KXJldHVybiExO3JldHVybiEwfWZ1bmN0aW9uIGFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKGUsdCl7Zm9yKHZhciByPVtdLG49TWF0aC5tYXgoZS5sZW5ndGgsdC5sZW5ndGgpLG89MDtvPG47bysrKXt2YXIgYT1lW2UubGVuZ3RoLW8tMV07bnVsbD09YSYmKGE9MSk7dmFyIGk9dFt0Lmxlbmd0aC1vLTFdO2lmKG51bGw9PWkmJihpPTEpLDE9PT1hKXIudW5zaGlmdChpKTtlbHNlIGlmKDE9PT1pKXIudW5zaGlmdChhKTtlbHNle2lmKGEhPT1pKXRocm93IEVycm9yKFwiT3BlcmFuZHMgY291bGQgbm90IGJlIGJyb2FkY2FzdCB0b2dldGhlciB3aXRoIHNoYXBlcyBcIitlK1wiIGFuZCBcIit0K1wiLlwiKTtyLnVuc2hpZnQoYSl9fXJldHVybiByfXZhciBCYXRjaE5vcm1Qcm9ncmFtPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKGUsdCxyLG4sbyxhKXt0aGlzLm91dHB1dFNoYXBlPVtdLHRoaXMuc3VwcG9ydHNCcm9hZGNhc3Rpbmc9ITAsdGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIixcIm1lYW5cIixcInZhcmlhbmNlXCJdLGFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKGUsdCksYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoZSxyKTt2YXIgaT1cIjAuMFwiO251bGwhPW4mJihhc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShlLG4pLHRoaXMudmFyaWFibGVOYW1lcy5wdXNoKFwib2Zmc2V0XCIpLGk9XCJnZXRPZmZzZXRBdE91dENvb3JkcygpXCIpO3ZhciBzPVwiMS4wXCI7bnVsbCE9byYmKGFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKGUsbyksdGhpcy52YXJpYWJsZU5hbWVzLnB1c2goXCJzY2FsZVwiKSxzPVwiZ2V0U2NhbGVBdE91dENvb3JkcygpXCIpLHRoaXMub3V0cHV0U2hhcGU9ZSx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgZmxvYXQgeCA9IGdldFhBdE91dENvb3JkcygpO1xcbiAgICAgICAgZmxvYXQgbWVhbiA9IGdldE1lYW5BdE91dENvb3JkcygpO1xcbiAgICAgICAgZmxvYXQgdmFyaWFuY2UgPSBnZXRWYXJpYW5jZUF0T3V0Q29vcmRzKCk7XFxuICAgICAgICBmbG9hdCBvZmZzZXQgPSBcIitpK1wiO1xcbiAgICAgICAgZmxvYXQgc2NhbGUgPSBcIitzK1wiO1xcbiAgICAgICAgZmxvYXQgaW52ID0gc2NhbGUgKiBpbnZlcnNlc3FydCh2YXJpYW5jZSArIGZsb2F0KFwiK2ErXCIpKTtcXG4gICAgICAgIHNldE91dHB1dChkb3QodmVjMyh4LCAtbWVhbiwgb2Zmc2V0KSwgdmVjMyhpbnYsIGludiwgMSkpKTtcXG4gICAgICB9XFxuICAgIFwifX0oKSxCYXRjaE5vcm1QYWNrZWRQcm9ncmFtPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKGUsdCxyLG4sbyxhKXt0aGlzLnN1cHBvcnRzQnJvYWRjYXN0aW5nPSEwLHRoaXMudXNlc1BhY2tlZFRleHR1cmVzPSEwLHRoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCIsXCJtZWFuXCIsXCJ2YXJpYW5jZVwiXSxhc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShlLHQpLGFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKGUscik7dmFyIGk9YnJvYWRjYXN0U2FtcGxlKFwibWVhblwiLHQubGVuZ3RoKSxzPWJyb2FkY2FzdFNhbXBsZShcInZhcmlhbmNlXCIsci5sZW5ndGgpLHU9XCJ2ZWM0IG9mZnNldCA9IHZlYzQoMC4wKVwiO251bGwhPW4mJihhc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShlLG4pLHRoaXMudmFyaWFibGVOYW1lcy5wdXNoKFwib2Zmc2V0XCIpLHU9YnJvYWRjYXN0U2FtcGxlKFwib2Zmc2V0XCIsbi5sZW5ndGgpKTt2YXIgbD1cInZlYzQgc2NhbGUgPSB2ZWM0KDEuMClcIjtudWxsIT1vJiYoYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoZSxvKSx0aGlzLnZhcmlhYmxlTmFtZXMucHVzaChcInNjYWxlXCIpLGw9YnJvYWRjYXN0U2FtcGxlKFwic2NhbGVcIixvLmxlbmd0aCkpLHRoaXMub3V0cHV0U2hhcGU9ZSx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgcmMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG5cXG4gICAgICAgIFwiK3UrXCI7XFxuICAgICAgICBcIitsK1wiO1xcblxcbiAgICAgICAgdmVjNCB4ID0gZ2V0WChyYy54LCByYy55LCByYy56LCByYy53KTtcXG4gICAgICAgIFwiK2krXCI7XFxuICAgICAgICBcIitzK1wiO1xcblxcbiAgICAgICAgdmVjNCBpbnYgPSBzY2FsZSAqIGludmVyc2VzcXJ0KHZhcmlhbmNlICsgdmVjNChcIithK1wiKSk7XFxuXFxuICAgICAgICBzZXRPdXRwdXQoKHggLSBtZWFuKSAqIGludiArIG9mZnNldCk7XFxuICAgICAgfVxcbiAgICBcIn19KCk7ZnVuY3Rpb24gYnJvYWRjYXN0U2FtcGxlKGUsdCl7dmFyIHI9XCJnZXRcIitlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK2Uuc2xpY2UoMSk7cmV0dXJuIDE9PT10P1wiXFxuICAgICAgdmVjNCBcIitlK1wiU2FtcGxlID0gXCIrcitcIihyYy53KTtcXG4gICAgICB2ZWM0IFwiK2UrXCIgPSB2ZWM0KFwiK2UrXCJTYW1wbGUueHksIFwiK2UrXCJTYW1wbGUueHkpO1xcbiAgICBcIjpcInZlYzQgXCIrZStcIiA9IFwiK3IrXCIocmMueCwgcmMueSwgcmMueiwgcmMudylcIn12YXIgQ09NUExFWF9NVUxUSVBMWT17UkVBTDpcInJldHVybiBhcmVhbCAqIGJyZWFsIC0gYWltYWcgKiBiaW1hZztcIixJTUFHOlwicmV0dXJuIGFyZWFsICogYmltYWcgKyBhaW1hZyAqIGJyZWFsO1wifSxCaW5hcnlPcENvbXBsZXhQcm9ncmFtPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKGUsdCxyKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVJlYWxcIixcIkFJbWFnXCIsXCJCUmVhbFwiLFwiQkltYWdcIl0sdGhpcy5zdXBwb3J0c0Jyb2FkY2FzdGluZz0hMCx0aGlzLm91dHB1dFNoYXBlPWFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKHQsciksdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGZsb2F0IGJpbmFyeU9wQ29tcGxleChcXG4gICAgICAgICAgZmxvYXQgYXJlYWwsIGZsb2F0IGFpbWFnLCBmbG9hdCBicmVhbCwgZmxvYXQgYmltYWcpIHtcXG4gICAgICAgIFwiK2UrXCJcXG4gICAgICB9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgZmxvYXQgYXJlYWwgPSBnZXRBUmVhbEF0T3V0Q29vcmRzKCk7XFxuICAgICAgICBmbG9hdCBhaW1hZyA9IGdldEFJbWFnQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIGZsb2F0IGJyZWFsID0gZ2V0QlJlYWxBdE91dENvb3JkcygpO1xcbiAgICAgICAgZmxvYXQgYmltYWcgPSBnZXRCSW1hZ0F0T3V0Q29vcmRzKCk7XFxuICAgICAgICBzZXRPdXRwdXQoYmluYXJ5T3BDb21wbGV4KGFyZWFsLCBhaW1hZywgYnJlYWwsIGJpbWFnKSk7XFxuICAgICAgfVxcbiAgICBcIn19KCksQ0hFQ0tfTkFOX1NOSVBQRVQ9XCJcXG4gIGlmIChpc05hTihhKSkgcmV0dXJuIGE7XFxuICBpZiAoaXNOYU4oYikpIHJldHVybiBiO1xcblwiLEFERD1cInJldHVybiBhICsgYjtcIixTVUI9XCJyZXR1cm4gYSAtIGI7XCIsTVVMPVwicmV0dXJuIGEgKiBiO1wiLERJVj1cImlmIChhID09IGIpIHJldHVybiAxLjA7XFxuICByZXR1cm4gYSAvIGI7XCIsSU5UX0RJVj1cIlxcbiAgZmxvYXQgcmVzdWx0U2lnbiA9IHNpZ24oYSkgKiBzaWduKGIpO1xcbiAgaW50IGlhID0gcm91bmQoYSk7XFxuICBpbnQgaWIgPSByb3VuZChiKTtcXG4gIGludCByZXN1bHQgPSBpYSAvIGliO1xcbiAgaW50IGFtb2RiID0gaWEgLSBpYiAqIHJlc3VsdDtcXG5cXG4gIGlmIChyZXN1bHRTaWduIDwgMC4wICYmIGFtb2RiICE9IDApIHtcXG4gICAgcmVzdWx0IC09IDE7XFxuICB9XFxuICByZXR1cm4gZmxvYXQocmVzdWx0KTtcXG5cIixQT1c9XCJcXG5pZihhIDwgMC4wICYmIGZsb29yKGIpIDwgYil7XFxuICByZXR1cm4gTkFOO1xcbn1cXG5yZXR1cm4gKHJvdW5kKG1vZChiLCAyLjApKSA9PSAwIHx8IHJvdW5kKG1vZChiLCAyLjApKSA9PSAyKSA/XFxuICAgIHBvdyhhYnMoYSksIGIpIDogc2lnbihhKSAqIHBvdyhhYnMoYSksIGIpO1xcblwiLFNRVUFSRURfRElGRkVSRU5DRT1cInJldHVybiAoYSAtIGIpICogKGEgLSBiKTtcIixFUVVBTD1cInJldHVybiBmbG9hdChhID09IGIpO1wiLE5PVF9FUVVBTD1cInJldHVybiBmbG9hdChhICE9IGIpO1wiLExFU1M9XCJyZXR1cm4gZmxvYXQoYSA8IGIpO1wiLExFU1NfRVFVQUw9XCJyZXR1cm4gZmxvYXQoYSA8PSBiKTtcIixHUkVBVEVSPVwicmV0dXJuIGZsb2F0KGEgPiBiKTtcIixHUkVBVEVSX0VRVUFMPVwicmV0dXJuIGZsb2F0KGEgPj0gYik7XCIsTE9HSUNBTF9BTkQ9XCJyZXR1cm4gZmxvYXQoYSA+PSAxLjAgJiYgYiA+PSAxLjApO1wiLExPR0lDQUxfT1I9XCJyZXR1cm4gZmxvYXQoYSA+PSAxLjAgfHwgYiA+PSAxLjApO1wiLE1BWD1DSEVDS19OQU5fU05JUFBFVCtcIlxcbiAgcmV0dXJuIG1heChhLCBiKTtcXG5cIixNSU49Q0hFQ0tfTkFOX1NOSVBQRVQrXCJcXG4gIHJldHVybiBtaW4oYSwgYik7XFxuXCIsTU9EPVwiaWYgKGIgPT0gMC4wKSByZXR1cm4gTkFOO1xcbiAgcmV0dXJuIG1vZChhLCBiKTtcIixBVEFOMj1DSEVDS19OQU5fU05JUFBFVCtcIlxcbiAgcmV0dXJuIGF0YW4oYSwgYik7XFxuXCIsRUxVX0RFUj1cInJldHVybiAoYiA+PSAxLjApID8gYSA6IGEgKiAoYiArIDEuMCk7XCIsQmluYXJ5T3BQcm9ncmFtPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQscil7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIixcIkJcIl0sdGhpcy5zdXBwb3J0c0Jyb2FkY2FzdGluZz0hMCx0aGlzLm91dHB1dFNoYXBlPWFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKHQsciksdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHVuaWZvcm0gZmxvYXQgTkFOO1xcbiAgICAgIGZsb2F0IGJpbmFyeU9wZXJhdGlvbihmbG9hdCBhLCBmbG9hdCBiKSB7XFxuICAgICAgICBcIitlK1wiXFxuICAgICAgfVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGZsb2F0IGEgPSBnZXRBQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIGZsb2F0IGIgPSBnZXRCQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIHNldE91dHB1dChiaW5hcnlPcGVyYXRpb24oYSwgYikpO1xcbiAgICAgIH1cXG4gICAgXCJ9cmV0dXJuIGUucHJvdG90eXBlLmdldEN1c3RvbVNldHVwRnVuYz1mdW5jdGlvbigpe3ZhciBlPXRoaXM7cmV0dXJuIGZ1bmN0aW9uKHQscil7bnVsbD09ZS5zdGFydExvYyYmKGUuc3RhcnRMb2M9dC5nZXRVbmlmb3JtTG9jYXRpb25Ob1Rocm93KHIsXCJOQU5cIiksbnVsbD09ZS5zdGFydExvYyl8fHQuZ2wudW5pZm9ybTFmKGUuc3RhcnRMb2MsTmFOKX19LGV9KCksQ2xpcFByb2dyYW09ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oZSx0LHIpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdLHRoaXMub3V0cHV0U2hhcGU9ZSx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgZmxvYXQgdmFsdWUgPSBnZXRBQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcXG4gICAgICAgICAgc2V0T3V0cHV0KHZhbHVlKTtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgc2V0T3V0cHV0KGNsYW1wKHZhbHVlLCBmbG9hdChcIit0K1wiKSwgZmxvYXQoXCIrcitcIikpKTtcXG4gICAgICB9XFxuICAgIFwifX0oKSxDb21wbGV4QWJzUHJvZ3JhbT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihlKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wicmVhbFwiLFwiaW1hZ1wiXSx0aGlzLm91dHB1dFNoYXBlPWUsdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGZsb2F0IHJlYWwgPSBnZXRSZWFsQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIGZsb2F0IGltYWcgPSBnZXRJbWFnQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIHZlYzIgdiA9IHZlYzIocmVhbCwgaW1hZyk7XFxuXFxuICAgICAgICBzZXRPdXRwdXQoc3FydChkb3QodiwgdikpKTtcXG4gICAgICB9XFxuICAgIFwifX0oKSxDb25jYXRQcm9ncmFtPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKGUsdCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIixcIkJcIl0sdGhpcy5vdXRwdXRTaGFwZT1bXSx0aGlzLm91dHB1dFNoYXBlPWNvbXB1dGVPdXRTaGFwZShbZSx0XSwxKSx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgeVIgPSBjb29yZHMueDtcXG4gICAgICAgIGludCB5QyA9IGNvb3Jkcy55O1xcblxcbiAgICAgICAgZmxvYXQgdmFsdWUgPSAwLjA7XFxuICAgICAgICBpZiAoeUMgPCBcIitlWzFdK1wiKSB7XFxuICAgICAgICAgIHZhbHVlID0gZ2V0QSh5UiwgeUMpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgeUMgLT0gXCIrZVsxXStcIjtcXG4gICAgICAgICAgdmFsdWUgPSBnZXRCKHlSLCB5Qyk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBzZXRPdXRwdXQodmFsdWUpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLENvbnYyRERlckZpbHRlclByb2dyYW09ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oZSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIixcImR5XCJdLHRoaXMub3V0cHV0U2hhcGU9ZS5maWx0ZXJTaGFwZTt2YXIgdD1lLnN0cmlkZUhlaWdodCxyPWUuc3RyaWRlV2lkdGgsbj1lLnBhZEluZm8udG9wLG89ZS5wYWRJbmZvLmxlZnQ7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IHdSID0gY29vcmRzLng7XFxuICAgICAgICBpbnQgd0MgPSBjb29yZHMueTtcXG4gICAgICAgIGludCBkMSA9IGNvb3Jkcy56O1xcbiAgICAgICAgaW50IGQyID0gY29vcmRzLnc7XFxuXFxuICAgICAgICAvLyBDb252b2x2ZSB4KD8sID8sIGQxKSB3aXRoIGR5KDosIDosIGQyKSB0byBnZXQgZHcod1IsIHdDLCBkMSwgZDIpLlxcbiAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWQuIDogPSBhY3Jvc3MgYWxsIHZhbHVlcyBpbiB0aGF0IGF4aXMuXFxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xcblxcbiAgICAgICAgZm9yIChpbnQgYiA9IDA7IGIgPCBcIitlLmJhdGNoU2l6ZStcIjsgYisrKSB7XFxuICAgICAgICAgIGZvciAoaW50IHlSID0gMDsgeVIgPCBcIitlLm91dEhlaWdodCtcIjsgeVIrKykge1xcbiAgICAgICAgICAgIGludCB4UiA9IHdSICsgeVIgKiBcIit0K1wiIC0gXCIrbitcIjtcXG5cXG4gICAgICAgICAgICBpZiAoeFIgPCAwIHx8IHhSID49IFwiK2UuaW5IZWlnaHQrXCIpIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBmb3IgKGludCB5QyA9IDA7IHlDIDwgXCIrZS5vdXRXaWR0aCtcIjsgeUMrKykge1xcbiAgICAgICAgICAgICAgaW50IHhDID0gd0MgKyB5QyAqIFwiK3IrXCIgLSBcIitvK1wiO1xcblxcbiAgICAgICAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSBcIitlLmluV2lkdGgrXCIpIHtcXG4gICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICBmbG9hdCBkeVZhbHVlID0gZ2V0RHkoYiwgeVIsIHlDLCBkMik7XFxuICAgICAgICAgICAgICBmbG9hdCB4VmFsdWUgPSBnZXRYKGIsIHhSLCB4QywgZDEpO1xcbiAgICAgICAgICAgICAgZG90UHJvZCArPSAoeFZhbHVlICogZHlWYWx1ZSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XFxuICAgICAgfVxcbiAgICBcIn19KCksQ29udjJERGVySW5wdXRQcm9ncmFtPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKGUpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJkeVwiLFwiV1wiXSx0aGlzLm91dHB1dFNoYXBlPWUuaW5TaGFwZTt2YXIgdD1lLmZpbHRlckhlaWdodCxyPWUuZmlsdGVyV2lkdGgsbj1lLnN0cmlkZUhlaWdodCxvPWUuc3RyaWRlV2lkdGgsYT10LTEtZS5wYWRJbmZvLnRvcCxpPXItMS1lLnBhZEluZm8ubGVmdDt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgY29uc3QgaXZlYzIgcGFkcyA9IGl2ZWMyKFwiK2ErXCIsIFwiK2krXCIpO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IGQxID0gY29vcmRzWzNdO1xcblxcbiAgICAgICAgaXZlYzIgZHlDb3JuZXIgPSBjb29yZHMueXogLSBwYWRzO1xcbiAgICAgICAgaW50IGR5UkNvcm5lciA9IGR5Q29ybmVyLng7XFxuICAgICAgICBpbnQgZHlDQ29ybmVyID0gZHlDb3JuZXIueTtcXG5cXG4gICAgICAgIC8vIENvbnZvbHZlIGR5KD8sID8sIGQyKSB3aXRoIHcoOiwgOiwgZDEsIGQyKSB0byBjb21wdXRlIGR4KHhSLCB4QywgZDEpLlxcbiAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWQuIDogPSBhY3Jvc3MgYWxsIHZhbHVlcyBpbiB0aGF0IGF4aXMuXFxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xcbiAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8IFwiK3QrXCI7IHdSKyspIHtcXG4gICAgICAgICAgZmxvYXQgZHlSID0gZmxvYXQoZHlSQ29ybmVyICsgd1IpIC8gXCIrbitcIi4wO1xcblxcbiAgICAgICAgICBpZiAoZHlSIDwgMC4wIHx8IGR5UiA+PSBcIitlLm91dEhlaWdodCtcIi4wIHx8IGZyYWN0KGR5UikgPiAwLjApIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpbnQgaWR5UiA9IGludChkeVIpO1xcblxcbiAgICAgICAgICBpbnQgd1JQZXJtID0gXCIrdCtcIiAtIDEgLSB3UjtcXG5cXG4gICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8IFwiK3IrXCI7IHdDKyspIHtcXG4gICAgICAgICAgICBmbG9hdCBkeUMgPSBmbG9hdChkeUNDb3JuZXIgKyB3QykgLyBcIitvK1wiLjA7XFxuXFxuICAgICAgICAgICAgaWYgKGR5QyA8IDAuMCB8fCBkeUMgPj0gXCIrZS5vdXRXaWR0aCtcIi4wIHx8XFxuICAgICAgICAgICAgICAgIGZyYWN0KGR5QykgPiAwLjApIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpbnQgaWR5QyA9IGludChkeUMpO1xcblxcbiAgICAgICAgICAgIGludCB3Q1Blcm0gPSBcIityK1wiIC0gMSAtIHdDO1xcblxcbiAgICAgICAgICAgIGZvciAoaW50IGQyID0gMDsgZDIgPCBcIitlLm91dENoYW5uZWxzK1wiOyBkMisrKSB7XFxuICAgICAgICAgICAgICBmbG9hdCB4VmFsdWUgPSBnZXREeShiYXRjaCwgaWR5UiwgaWR5QywgZDIpO1xcbiAgICAgICAgICAgICAgZmxvYXQgd1ZhbHVlID0gZ2V0Vyh3UlBlcm0sIHdDUGVybSwgZDEsIGQyKTtcXG4gICAgICAgICAgICAgIGRvdFByb2QgKz0geFZhbHVlICogd1ZhbHVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KGRvdFByb2QpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLERlcHRod2lzZUNvbnYyRERlckZpbHRlclByb2dyYW09ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oZSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIixcImR5XCJdLHRoaXMub3V0cHV0U2hhcGU9ZS5maWx0ZXJTaGFwZTt2YXIgdD1lLnN0cmlkZUhlaWdodCxyPWUuc3RyaWRlV2lkdGgsbj1lLnBhZEluZm8udG9wLG89ZS5wYWRJbmZvLmxlZnQsYT1lLm91dENoYW5uZWxzL2UuaW5DaGFubmVsczt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgd1IgPSBjb29yZHMueDtcXG4gICAgICAgIGludCB3QyA9IGNvb3Jkcy55O1xcbiAgICAgICAgaW50IGQxID0gY29vcmRzLno7XFxuICAgICAgICBpbnQgZG0gPSBjb29yZHMudztcXG4gICAgICAgIGludCBkMiA9IGQxICogXCIrYStcIiArIGRtO1xcblxcbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcXG5cXG4gICAgICAgIC8vIFRPRE86IFZlYzQgb3ZlciB0aGUgYmF0Y2ggc2l6ZVxcbiAgICAgICAgZm9yIChpbnQgYiA9IDA7IGIgPCBcIitlLmJhdGNoU2l6ZStcIjsgYisrKSB7XFxuICAgICAgICAgIGZvciAoaW50IHlSID0gMDsgeVIgPCBcIitlLm91dEhlaWdodCtcIjsgeVIrKykge1xcbiAgICAgICAgICAgIGludCB4UiA9IHdSICsgeVIgKiBcIit0K1wiIC0gXCIrbitcIjtcXG5cXG4gICAgICAgICAgICBpZiAoeFIgPCAwIHx8IHhSID49IFwiK2UuaW5IZWlnaHQrXCIpIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBmb3IgKGludCB5QyA9IDA7IHlDIDwgXCIrZS5vdXRXaWR0aCtcIjsgeUMrKykge1xcbiAgICAgICAgICAgICAgaW50IHhDID0gd0MgKyB5QyAqIFwiK3IrXCIgLSBcIitvK1wiO1xcblxcbiAgICAgICAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSBcIitlLmluV2lkdGgrXCIpIHtcXG4gICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICBmbG9hdCBkeVZhbHVlID0gZ2V0RHkoYiwgeVIsIHlDLCBkMik7XFxuICAgICAgICAgICAgICBmbG9hdCB4VmFsdWUgPSBnZXRYKGIsIHhSLCB4QywgZDEpO1xcbiAgICAgICAgICAgICAgZG90UHJvZCArPSAoeFZhbHVlICogZHlWYWx1ZSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XFxuICAgICAgfVxcbiAgICBcIn19KCksRGVwdGh3aXNlQ29udjJERGVySW5wdXRQcm9ncmFtPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKGUpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJkeVwiLFwiV1wiXSx0aGlzLm91dHB1dFNoYXBlPWUuaW5TaGFwZTt2YXIgdD1lLmZpbHRlckhlaWdodCxyPWUuZmlsdGVyV2lkdGgsbj1lLnN0cmlkZUhlaWdodCxvPWUuc3RyaWRlV2lkdGgsYT10LTEtZS5wYWRJbmZvLnRvcCxpPXItMS1lLnBhZEluZm8ubGVmdCxzPWUub3V0Q2hhbm5lbHMvZS5pbkNoYW5uZWxzO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICBjb25zdCBpdmVjMiBwYWRzID0gaXZlYzIoXCIrYStcIiwgXCIraStcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgZDEgPSBjb29yZHNbM107XFxuICAgICAgICBpdmVjMiBkeUNvcm5lciA9IGNvb3Jkcy55eiAtIHBhZHM7XFxuICAgICAgICBpbnQgZHlSQ29ybmVyID0gZHlDb3JuZXIueDtcXG4gICAgICAgIGludCBkeUNDb3JuZXIgPSBkeUNvcm5lci55O1xcblxcbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcXG5cXG4gICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCBcIit0K1wiOyB3UisrKSB7XFxuICAgICAgICAgIGZsb2F0IGR5UiA9IGZsb2F0KGR5UkNvcm5lciArIHdSKSAvIFwiK24rXCIuMDtcXG5cXG4gICAgICAgICAgaWYgKGR5UiA8IDAuMCB8fCBkeVIgPj0gXCIrZS5vdXRIZWlnaHQrXCIuMCB8fCBmcmFjdChkeVIpID4gMC4wKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaW50IGlkeVIgPSBpbnQoZHlSKTtcXG5cXG4gICAgICAgICAgaW50IHdSUGVybSA9IFwiK3QrXCIgLSAxIC0gd1I7XFxuXFxuICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCBcIityK1wiOyB3QysrKSB7XFxuICAgICAgICAgICAgZmxvYXQgZHlDID0gZmxvYXQoZHlDQ29ybmVyICsgd0MpIC8gXCIrbytcIi4wO1xcblxcbiAgICAgICAgICAgIGlmIChkeUMgPCAwLjAgfHwgZHlDID49IFwiK2Uub3V0V2lkdGgrXCIuMCB8fFxcbiAgICAgICAgICAgICAgICBmcmFjdChkeUMpID4gMC4wKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaW50IGlkeUMgPSBpbnQoZHlDKTtcXG5cXG4gICAgICAgICAgICBpbnQgd0NQZXJtID0gXCIrcitcIiAtIDEgLSB3QztcXG5cXG4gICAgICAgICAgICAvLyBUT0RPOiBWZWM0IG92ZXIgdGhlIGNoYW5uZWxNdWxcXG4gICAgICAgICAgICBmb3IgKGludCBkbSA9IDA7IGRtIDwgXCIrcytcIjsgZG0rKykge1xcbiAgICAgICAgICAgICAgaW50IGQyID0gZDEgKiBcIitzK1wiICsgZG07XFxuICAgICAgICAgICAgICBmbG9hdCB4VmFsdWUgPSBnZXREeShiYXRjaCwgaWR5UiwgaWR5QywgZDIpO1xcbiAgICAgICAgICAgICAgZmxvYXQgd1ZhbHVlID0gZ2V0Vyh3UlBlcm0sIHdDUGVybSwgZDEsIGRtKTtcXG4gICAgICAgICAgICAgIGRvdFByb2QgKz0geFZhbHVlICogd1ZhbHVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KGRvdFByb2QpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLENvbnYyRFByb2dyYW09ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oZSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIixcIldcIl0sdGhpcy5vdXRwdXRTaGFwZT1lLm91dFNoYXBlO3ZhciB0PWUucGFkSW5mby50b3Ascj1lLnBhZEluZm8ubGVmdCxuPWUuc3RyaWRlSGVpZ2h0LG89ZS5zdHJpZGVXaWR0aCxhPWUuZGlsYXRpb25IZWlnaHQsaT1lLmRpbGF0aW9uV2lkdGgscz1lLmZpbHRlckhlaWdodCx1PWUuZmlsdGVyV2lkdGgsbD00Kk1hdGguZmxvb3IoZS5pbkNoYW5uZWxzLzQpLGM9ZS5pbkNoYW5uZWxzJTQ7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGNvbnN0IGl2ZWMyIHN0cmlkZXMgPSBpdmVjMihcIituK1wiLCBcIitvK1wiKTtcXG4gICAgICBjb25zdCBpdmVjMiBwYWRzID0gaXZlYzIoXCIrdCtcIiwgXCIrcitcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgZDIgPSBjb29yZHNbM107XFxuXFxuICAgICAgICBpdmVjMiB4UkNDb3JuZXIgPSBjb29yZHMueXogKiBzdHJpZGVzIC0gcGFkcztcXG4gICAgICAgIGludCB4UkNvcm5lciA9IHhSQ0Nvcm5lci54O1xcbiAgICAgICAgaW50IHhDQ29ybmVyID0geFJDQ29ybmVyLnk7XFxuXFxuICAgICAgICAvLyBDb252b2x2ZSB4KD8sID8sIGQxKSB3aXRoIHcoOiwgOiwgZDEsIGQyKSB0byBnZXQgeSh5UiwgeUMsIGQyKS5cXG4gICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhhdCBheGlzLlxcbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcXG4gICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCBcIitzK1wiOyB3UisrKSB7XFxuICAgICAgICAgIGludCB4UiA9IHhSQ29ybmVyICsgd1IgKiBcIithK1wiO1xcblxcbiAgICAgICAgICBpZiAoeFIgPCAwIHx8IHhSID49IFwiK2UuaW5IZWlnaHQrXCIpIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgXCIrdStcIjsgd0MrKykge1xcbiAgICAgICAgICAgIGludCB4QyA9IHhDQ29ybmVyICsgd0MgKiBcIitpK1wiO1xcblxcbiAgICAgICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0gXCIrZS5pbldpZHRoK1wiKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgZm9yIChpbnQgZDEgPSAwOyBkMSA8IFwiK2wrXCI7IGQxICs9IDQpIHtcXG4gICAgICAgICAgICAgIHZlYzQgeFZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhSLCB4QywgZDEpLFxcbiAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsIGQxICsgMSksXFxuICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhSLCB4QywgZDEgKyAyKSxcXG4gICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeFIsIHhDLCBkMSArIDMpXFxuICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgICAgdmVjNCB3VmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIGQxLCBkMiksXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBkMSArIDEsIGQyKSxcXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIGQxICsgMiwgZDIpLFxcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgZDEgKyAzLCBkMilcXG4gICAgICAgICAgICAgICk7XFxuXFxuICAgICAgICAgICAgICBkb3RQcm9kICs9IGRvdCh4VmFsdWVzLCB3VmFsdWVzKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKFwiKygxPT09YykrXCIpIHtcXG4gICAgICAgICAgICAgIGRvdFByb2QgKz1cXG4gICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeFIsIHhDLCBcIitsK1wiKSAqXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBcIitsK1wiLCBkMik7XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChcIisoMj09PWMpK1wiKSB7XFxuICAgICAgICAgICAgICB2ZWMyIHhWYWx1ZXMgPSB2ZWMyKFxcbiAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsIFwiK2wrXCIpLFxcbiAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsIFwiK2wrXCIgKyAxKVxcbiAgICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICAgIHZlYzIgd1ZhbHVlcyA9IHZlYzIoXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBcIitsK1wiLCBkMiksXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBcIitsK1wiICsgMSwgZDIpXFxuICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgICAgZG90UHJvZCArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChcIisoMz09PWMpK1wiKSB7XFxuICAgICAgICAgICAgICB2ZWMzIHhWYWx1ZXMgPSB2ZWMzKFxcbiAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsIFwiK2wrXCIpLFxcbiAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsIFwiK2wrXCIgKyAxKSxcXG4gICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeFIsIHhDLCBcIitsK1wiICsgMilcXG4gICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgICB2ZWMzIHdWYWx1ZXMgPSB2ZWMzKFxcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgXCIrbCtcIiwgZDIpLFxcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgXCIrbCtcIiArIDEsIGQyKSxcXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIFwiK2wrXCIgKyAyLCBkMilcXG4gICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgICBkb3RQcm9kICs9IGRvdCh4VmFsdWVzLCB3VmFsdWVzKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcXG4gICAgICB9XFxuICAgIFwifX0oKSxEZXB0aHdpc2VDb252MkRQcm9ncmFtPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKGUpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCIsXCJXXCJdLHRoaXMub3V0cHV0U2hhcGU9ZS5vdXRTaGFwZTt2YXIgdD1lLmluSGVpZ2h0LHI9ZS5pbldpZHRoLG49ZS5wYWRJbmZvLnRvcCxvPWUucGFkSW5mby5sZWZ0LGE9ZS5zdHJpZGVIZWlnaHQsaT1lLnN0cmlkZVdpZHRoLHM9ZS5kaWxhdGlvbkhlaWdodCx1PWUuZGlsYXRpb25XaWR0aCxsPWUuZmlsdGVySGVpZ2h0LGM9ZS5maWx0ZXJXaWR0aCxwPWUub3V0Q2hhbm5lbHMvZS5pbkNoYW5uZWxzO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICBjb25zdCBpdmVjMiBzdHJpZGVzID0gaXZlYzIoXCIrYStcIiwgXCIraStcIik7XFxuICAgICAgY29uc3QgaXZlYzIgcGFkcyA9IGl2ZWMyKFwiK24rXCIsIFwiK28rXCIpO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzLng7XFxuICAgICAgICBpdmVjMiB4UkNDb3JuZXIgPSBjb29yZHMueXogKiBzdHJpZGVzIC0gcGFkcztcXG4gICAgICAgIGludCBkMiA9IGNvb3Jkcy53O1xcbiAgICAgICAgaW50IGQxID0gZDIgLyBcIitwK1wiO1xcbiAgICAgICAgaW50IHEgPSBkMiAtIGQxICogXCIrcCtcIjtcXG5cXG4gICAgICAgIGludCB4UkNvcm5lciA9IHhSQ0Nvcm5lci54O1xcbiAgICAgICAgaW50IHhDQ29ybmVyID0geFJDQ29ybmVyLnk7XFxuXFxuICAgICAgICAvLyBDb252b2x2ZSB4KD8sID8sIGQxKSB3aXRoIHcoOiwgOiwgZDEsIHEpIHRvIGdldCB5KHlSLCB5QywgZDIpLlxcbiAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWQuIDogPSBhY3Jvc3MgYWxsIHZhbHVlcyBpbiB0aGF0IGF4aXMuXFxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xcbiAgICAgICAgLy8gVE9ETyhkc21pbGtvdik6IEZsYXR0ZW4gdGhlIHR3byBmb3IgbG9vcHMgYW5kIHZlYzQgdGhlIG9wZXJhdGlvbnMuXFxuICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgXCIrbCtcIjsgd1IrKykge1xcbiAgICAgICAgICBpbnQgeFIgPSB4UkNvcm5lciArIHdSICogXCIrcytcIjtcXG5cXG4gICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSBcIit0K1wiKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8IFwiK2MrXCI7IHdDKyspIHtcXG4gICAgICAgICAgICBpbnQgeEMgPSB4Q0Nvcm5lciArIHdDICogXCIrdStcIjtcXG5cXG4gICAgICAgICAgICBpZiAoeEMgPCAwIHx8IHhDID49IFwiK3IrXCIpIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBmbG9hdCB4VmFsID0gZ2V0WChiYXRjaCwgeFIsIHhDLCBkMSk7XFxuICAgICAgICAgICAgZmxvYXQgd1ZhbCA9IGdldFcod1IsIHdDLCBkMSwgcSk7XFxuICAgICAgICAgICAgZG90UHJvZCArPSB4VmFsICogd1ZhbDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KGRvdFByb2QpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLENyb3BBbmRSZXNpemVQcm9ncmFtPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKGUsdCxyLG4sbyl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkltYWdlXCIsXCJCb3hlc1wiLFwiQm94SW5kXCJdLHRoaXMub3V0cHV0U2hhcGU9W107dmFyIGE9ZVswXSxpPWVbMV0scz1lWzJdLHU9ZVszXSxsPXRbMF0sYz1yWzBdLHA9clsxXTt0aGlzLm91dHB1dFNoYXBlPVtsLGMscCx1XTt2YXIgZD1cImJpbGluZWFyXCI9PT1uPzE6MCxoPVtpLTErXCIuMFwiLHMtMStcIi4wXCJdLGY9aFswXSxtPWhbMV0sZz1jPjE/W1wiXCIrKGktMSkvKGMtMSksXCIoeTIteTEpICogaGVpZ2h0X3JhdGlvXCIsXCJ5MSpcIitmK1wiICsgZmxvYXQoeSkqKGhlaWdodF9zY2FsZSlcIl06W1wiMC4wXCIsXCIwLjBcIixcIjAuNSAqICh5MSt5MikgKiBcIitmXSx2PWdbMF0seT1nWzFdLHg9Z1syXSxUPXA+MT9bXCJcIisocy0xKS8ocC0xKSxcIih4Mi14MSkgKiB3aWR0aF9yYXRpb1wiLFwieDEqXCIrbStcIiArIGZsb2F0KHgpKih3aWR0aF9zY2FsZSlcIl06W1wiMC4wXCIsXCIwLjBcIixcIjAuNSAqICh4MSt4MikgKiBcIittXSxFPVRbMF0sdz1UWzFdLFM9VFsyXTt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgY29uc3QgZmxvYXQgaGVpZ2h0X3JhdGlvID0gZmxvYXQoXCIrditcIik7XFxuICAgICAgY29uc3QgZmxvYXQgd2lkdGhfcmF0aW8gPSBmbG9hdChcIitFK1wiKTtcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IHkgPSBjb29yZHNbMV07XFxuICAgICAgICBpbnQgeCA9IGNvb3Jkc1syXTtcXG4gICAgICAgIGludCBkID0gY29vcmRzWzNdO1xcblxcbiAgICAgICAgLy8gZ2V0IGJveCB2YWxzXFxuICAgICAgICBmbG9hdCB5MSA9IGdldEJveGVzKGIsMCk7XFxuICAgICAgICBmbG9hdCB4MSA9IGdldEJveGVzKGIsMSk7XFxuICAgICAgICBmbG9hdCB5MiA9IGdldEJveGVzKGIsMik7XFxuICAgICAgICBmbG9hdCB4MiA9IGdldEJveGVzKGIsMyk7XFxuXFxuICAgICAgICAvLyBnZXQgaW1hZ2UgaW4gYmF0Y2ggaW5kZXhcXG4gICAgICAgIGludCBiSW5kID0gcm91bmQoZ2V0Qm94SW5kKGIpKTtcXG4gICAgICAgIGlmKGJJbmQgPCAwIHx8IGJJbmQgPj0gXCIrYStcIikge1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICBmbG9hdCBoZWlnaHRfc2NhbGUgPSBcIit5K1wiO1xcbiAgICAgICAgZmxvYXQgd2lkdGhfc2NhbGUgPSBcIit3K1wiO1xcblxcbiAgICAgICAgZmxvYXQgaW5feSA9IFwiK3grXCI7XFxuICAgICAgICBpZiggaW5feSA8IDAuMCB8fCBpbl95ID4gXCIrZitcIiApIHtcXG4gICAgICAgICAgc2V0T3V0cHV0KGZsb2F0KFwiK28rXCIpKTtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcbiAgICAgICAgZmxvYXQgaW5feCA9IFwiK1MrXCI7XFxuICAgICAgICBpZiggaW5feCA8IDAuMCB8fCBpbl94ID4gXCIrbStcIiApIHtcXG4gICAgICAgICAgc2V0T3V0cHV0KGZsb2F0KFwiK28rXCIpKTtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdmVjMiBzb3VyY2VGcmFjSW5kZXhSQyA9IHZlYzIoaW5feSxpbl94KTtcXG4gICAgICAgIGlmKFwiK2QrXCIgPT0gMSkge1xcbiAgICAgICAgICAvLyBDb21wdXRlIHRoZSBmb3VyIGludGVnZXIgaW5kaWNlcy5cXG4gICAgICAgICAgaXZlYzIgc291cmNlRmxvb3JSQyA9IGl2ZWMyKHNvdXJjZUZyYWNJbmRleFJDKTtcXG4gICAgICAgICAgaXZlYzIgc291cmNlQ2VpbFJDID0gaXZlYzIoY2VpbChzb3VyY2VGcmFjSW5kZXhSQykpO1xcblxcbiAgICAgICAgICBmbG9hdCB0b3BMZWZ0ID0gZ2V0SW1hZ2UoYiwgc291cmNlRmxvb3JSQy54LCBzb3VyY2VGbG9vclJDLnksIGQpO1xcbiAgICAgICAgICBmbG9hdCBib3R0b21MZWZ0ID0gZ2V0SW1hZ2UoYiwgc291cmNlQ2VpbFJDLngsIHNvdXJjZUZsb29yUkMueSwgZCk7XFxuICAgICAgICAgIGZsb2F0IHRvcFJpZ2h0ID0gZ2V0SW1hZ2UoYiwgc291cmNlRmxvb3JSQy54LCBzb3VyY2VDZWlsUkMueSwgZCk7XFxuICAgICAgICAgIGZsb2F0IGJvdHRvbVJpZ2h0ID0gZ2V0SW1hZ2UoYiwgc291cmNlQ2VpbFJDLngsIHNvdXJjZUNlaWxSQy55LCBkKTtcXG5cXG4gICAgICAgICAgdmVjMiBmcmFjUkMgPSBzb3VyY2VGcmFjSW5kZXhSQyAtIHZlYzIoc291cmNlRmxvb3JSQyk7XFxuXFxuICAgICAgICAgIGZsb2F0IHRvcCA9IHRvcExlZnQgKyAodG9wUmlnaHQgLSB0b3BMZWZ0KSAqIGZyYWNSQy55O1xcbiAgICAgICAgICBmbG9hdCBib3R0b20gPSBib3R0b21MZWZ0ICsgKGJvdHRvbVJpZ2h0IC0gYm90dG9tTGVmdCkgKiBmcmFjUkMueTtcXG4gICAgICAgICAgZmxvYXQgbmV3VmFsdWUgPSB0b3AgKyAoYm90dG9tIC0gdG9wKSAqIGZyYWNSQy54O1xcbiAgICAgICAgICBzZXRPdXRwdXQobmV3VmFsdWUpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgY29vcmRpbmF0b3JzIG9mIG5lYXJlc3QgbmVpZ2hib3IgcG9pbnQuXFxuICAgICAgICAgIGl2ZWMyIHNvdXJjZU5lYXJlc3RSQyA9IGl2ZWMyKGZsb29yKFxcbiAgICAgICAgICAgIHNvdXJjZUZyYWNJbmRleFJDICsgdmVjMigwLjUsMC41KSkpO1xcbiAgICAgICAgICBmbG9hdCBuZXdWYWx1ZSA9IGdldEltYWdlKGIsIHNvdXJjZU5lYXJlc3RSQy54LCBzb3VyY2VOZWFyZXN0UkMueSwgZCk7XFxuICAgICAgICAgIHNldE91dHB1dChuZXdWYWx1ZSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICBcIn19KCk7ZnVuY3Rpb24gZ2V0TG9naWNhbENvb3JkaW5hdGVzRnJvbUZsYXRJbmRleChlLHQscil7dm9pZCAwPT09ciYmKHI9XCJpbmRleFwiKTt2YXIgbj1jb21wdXRlU3RyaWRlcyh0KTtyZXR1cm4gbi5tYXAoZnVuY3Rpb24odCxvKXtyZXR1cm5cImludCBcIitlW29dK1wiID0gXCIrcitcIiAvIFwiK3QrXCI7IFwiKyhvPT09bi5sZW5ndGgtMT9cImludCBcIitlW28rMV0rXCIgPSBcIityK1wiIC0gXCIrZVtvXStcIiAqIFwiK3Q6XCJpbmRleCAtPSBcIitlW29dK1wiICogXCIrdCkrXCI7XCJ9KS5qb2luKFwiXCIpfWZ1bmN0aW9uIGJ1aWxkVmVjKGUpe3JldHVybiAxPT09ZS5sZW5ndGg/XCJcIitlWzBdOlwidmVjXCIrZS5sZW5ndGgrXCIoXCIrZS5qb2luKFwiLFwiKStcIilcIn1mdW5jdGlvbiBkb3RpZnkoZSx0KXtpZihlLmxlbmd0aCE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlZlY3RvcnMgdG8gYmUgZG90dGVkIG11c3QgYmUgb2YgdGhlIHNhbWUgbGVuZ3RoIC1nb3QgXCIrZS5sZW5ndGgrXCIgYW5kIFwiK3QubGVuZ3RoKTtmb3IodmFyIHI9W10sbj1NYXRoLmZsb29yKGUubGVuZ3RoLzQpLG89ZS5sZW5ndGglNCxhPTA7YTxuO2ErKyl7dmFyIGk9ZS5zbGljZSg0KmEsNCphKzQpLHM9dC5zbGljZSg0KmEsNCphKzQpO3IucHVzaChidWlsZFZlYyhpKStcIiwgXCIrYnVpbGRWZWMocykpfWlmKDAhPT1vKXtpPWUuc2xpY2UoNCpuKSxzPXQuc2xpY2UoNCpuKTsxPT09aS5sZW5ndGgmJihpPWkubWFwKGZ1bmN0aW9uKGUpe3JldHVyblwiZmxvYXQoXCIrZStcIilcIn0pLHM9cy5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuXCJmbG9hdChcIitlK1wiKVwifSkpLHIucHVzaChidWlsZFZlYyhpKStcIiwgXCIrYnVpbGRWZWMocykpfXJldHVybiByLm1hcChmdW5jdGlvbihlLHQpe3JldHVyblwiZG90KFwiK2UrXCIpXCJ9KS5qb2luKFwiK1wiKX1mdW5jdGlvbiBtYWtlU2hhZGVyKGUsdCxyLG4sbyl7dmFyIGE9ZS5tYXAoZnVuY3Rpb24oZSl7dmFyIHQ9c2l6ZUZyb21TaGFwZShlLnNoYXBlSW5mby5sb2dpY2FsU2hhcGUpO3JldHVybiBlLnNoYXBlSW5mby5pc1VuaWZvcm0/XCJ1bmlmb3JtIGZsb2F0IFwiK2UubmFtZSsodD4xP1wiW1wiK3QrXCJdXCI6XCJcIikrXCI7XCI6XCJ1bmlmb3JtIHNhbXBsZXIyRCBcIitlLm5hbWUrXCI7XCJ9KTthPWEuam9pbihcIlxcblwiKTt2YXIgaSxzLHU9ZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGdldElucHV0U2FtcGxpbmdTbmlwcGV0KGUsdCxuKX0pLmpvaW4oXCJcXG5cIiksbD10LnRleFNoYXBlLGM9U0hBREVSX1BSRUZJWDtyZXR1cm4gdC5pc1BhY2tlZD8oaT1nZXRQYWNrZWRPdXRwdXRTYW1wbGluZ1NuaXBwZXQodC5sb2dpY2FsU2hhcGUsbCkscz1GTE9BVF9URVhUVVJFX1NFVF9SR0JBX1NOSVBQRVQpOihpPWdldE91dHB1dFNhbXBsaW5nU25pcHBldCh0LmxvZ2ljYWxTaGFwZSxsKSxzPUZMT0FUX1RFWFRVUkVfU0VUX1JfU05JUFBFVCksbyYmKGMrPVNIQURFUl9QQUNLRURfUFJFRklYKSxbYyxGTE9BVF9URVhUVVJFX1NBTVBMRV9TTklQUEVULHMsYSxpLHUscl0uam9pbihcIlxcblwiKX1mdW5jdGlvbiBnZXRTYW1wbGVyRnJvbUluSW5mbyhlKXt2YXIgdD1lLnNoYXBlSW5mby5sb2dpY2FsU2hhcGU7c3dpdGNoKHQubGVuZ3RoKXtjYXNlIDA6cmV0dXJuIGdldFNhbXBsZXJTY2FsYXIoZSk7Y2FzZSAxOnJldHVybiBnZXRTYW1wbGVyMUQoZSk7Y2FzZSAyOnJldHVybiBnZXRTYW1wbGVyMkQoZSk7Y2FzZSAzOnJldHVybiBnZXRTYW1wbGVyM0QoZSk7Y2FzZSA0OnJldHVybiBnZXRTYW1wbGVyNEQoZSk7Y2FzZSA1OnJldHVybiBnZXRTYW1wbGVyNUQoZSk7Y2FzZSA2OnJldHVybiBnZXRTYW1wbGVyNkQoZSk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IodC5sZW5ndGgrXCItRCBpbnB1dCBzYW1wbGluZyBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKX19ZnVuY3Rpb24gZ2V0UGFja2VkU2FtcGxlckZyb21JbkluZm8oZSl7dmFyIHQ9ZS5zaGFwZUluZm8ubG9naWNhbFNoYXBlO3N3aXRjaCh0Lmxlbmd0aCl7Y2FzZSAxOnJldHVybiBnZXRQYWNrZWRTYW1wbGVyMUQoZSk7Y2FzZSAyOnJldHVybiBnZXRQYWNrZWRTYW1wbGVyMkQoZSk7Y2FzZSAzOnJldHVybiBnZXRQYWNrZWRTYW1wbGVyM0QoZSk7Y2FzZSA0OnJldHVybiBnZXRQYWNrZWRTYW1wbGVyNEQoZSk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJQYWNrZWQgXCIrdC5sZW5ndGgrXCItRCBpbnB1dCBzYW1wbGluZyBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKX19ZnVuY3Rpb24gZ2V0SW5wdXRTYW1wbGluZ1NuaXBwZXQoZSx0LHIpe3ZhciBuPWdldFNhbXBsZXJGbGF0KGUpO3JldHVybiBlLnNoYXBlSW5mby5pc1BhY2tlZD9uKz1nZXRQYWNrZWRTYW1wbGVyRnJvbUluSW5mbyhlKTpuKz1nZXRTYW1wbGVyRnJvbUluSW5mbyhlKSwocnx8YXJyYXlzRXF1YWwoZS5zaGFwZUluZm8ubG9naWNhbFNoYXBlLHQubG9naWNhbFNoYXBlKSkmJihuKz1nZXRTYW1wbGVyQXRPdXRwdXRDb29yZHMoZSx0LHIpKSxufWZ1bmN0aW9uIGdldFBhY2tlZE91dHB1dFNhbXBsaW5nU25pcHBldChlLHQpe3N3aXRjaChlLmxlbmd0aCl7Y2FzZSAwOnJldHVybiBnZXRPdXRwdXRTY2FsYXJDb29yZHMoKTtjYXNlIDE6cmV0dXJuIGdldE91dHB1dFBhY2tlZDFEQ29vcmRzKGUsdCk7Y2FzZSAyOnJldHVybiBnZXRPdXRwdXRQYWNrZWQyRENvb3JkcyhlLHQpO2Nhc2UgMzpyZXR1cm4gZ2V0T3V0cHV0UGFja2VkM0RDb29yZHMoZSx0KTtjYXNlIDQ6cmV0dXJuIGdldE91dHB1dFBhY2tlZDREQ29vcmRzKGUsdCk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoZS5sZW5ndGgrXCItRCBwYWNrZWQgb3V0cHV0IGNvb3JkaW5hdGUgZmV0Y2hpbmcgaXMgbm90IHlldCBzdXBwb3J0ZWRcIil9fWZ1bmN0aW9uIGdldE91dHB1dFNhbXBsaW5nU25pcHBldChlLHQpe3N3aXRjaChlLmxlbmd0aCl7Y2FzZSAwOnJldHVybiBnZXRPdXRwdXRTY2FsYXJDb29yZHMoKTtjYXNlIDE6cmV0dXJuIGdldE91dHB1dDFEQ29vcmRzKGUsdCk7Y2FzZSAyOnJldHVybiBnZXRPdXRwdXQyRENvb3JkcyhlLHQpO2Nhc2UgMzpyZXR1cm4gZ2V0T3V0cHV0M0RDb29yZHMoZSx0KTtjYXNlIDQ6cmV0dXJuIGdldE91dHB1dDREQ29vcmRzKGUsdCk7Y2FzZSA1OnJldHVybiBnZXRPdXRwdXQ1RENvb3JkcyhlLHQpO2Nhc2UgNjpyZXR1cm4gZ2V0T3V0cHV0NkRDb29yZHMoZSx0KTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihlLmxlbmd0aCtcIi1EIG91dHB1dCBzYW1wbGluZyBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKX19dmFyIFNBTVBMRV8xRF9TTklQUEVUPVwiXFxudmVjMiBVVmZyb20xRChpbnQgdGV4TnVtUiwgaW50IHRleE51bUMsIGludCBpbmRleCkge1xcbiAgaW50IHRleFIgPSBpbmRleCAvIHRleE51bUM7XFxuICBpbnQgdGV4QyA9IGluZGV4IC0gdGV4UiAqIHRleE51bUM7XFxuICByZXR1cm4gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC8gdmVjMih0ZXhOdW1DLCB0ZXhOdW1SKTtcXG59XFxudmVjMiBwYWNrZWRVVmZyb20xRChpbnQgdGV4TnVtUiwgaW50IHRleE51bUMsIGludCBpbmRleCkge1xcbiAgaW50IHRleGVsSW5kZXggPSBpbmRleCAvIDI7XFxuICBpbnQgdGV4UiA9IHRleGVsSW5kZXggLyB0ZXhOdW1DO1xcbiAgaW50IHRleEMgPSB0ZXhlbEluZGV4IC0gdGV4UiAqIHRleE51bUM7XFxuICByZXR1cm4gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC8gdmVjMih0ZXhOdW1DLCB0ZXhOdW1SKTtcXG59XFxuXCIsU0FNUExFXzJEX1NOSVBQRVQ9XCJcXG52ZWMyIFVWZnJvbTJEKGludCB0ZXhOdW1SLCBpbnQgdGV4TnVtQywgaW50IG51bUMsIGludCByb3csIGludCBjb2wpIHtcXG4gIGludCBpbmRleCA9IHJvdyAqIG51bUMgKyBjb2w7XFxuICBpbnQgdGV4UiA9IGluZGV4IC8gdGV4TnVtQztcXG4gIGludCB0ZXhDID0gaW5kZXggLSB0ZXhSICogdGV4TnVtQztcXG4gIHJldHVybiAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKHRleE51bUMsIHRleE51bVIpO1xcbn1cXG52ZWMyIHBhY2tlZFVWZnJvbTJEKGludCB0ZXhlbHNJbkxvZ2ljYWxSb3csIGludCB0ZXhOdW1SLFxcbiAgaW50IHRleE51bUMsIGludCByb3csIGludCBjb2wpIHtcXG4gIGludCB0ZXhlbEluZGV4ID0gKHJvdyAvIDIpICogdGV4ZWxzSW5Mb2dpY2FsUm93ICsgKGNvbCAvIDIpO1xcbiAgaW50IHRleFIgPSB0ZXhlbEluZGV4IC8gdGV4TnVtQztcXG4gIGludCB0ZXhDID0gdGV4ZWxJbmRleCAtIHRleFIgKiB0ZXhOdW1DO1xcbiAgcmV0dXJuICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIodGV4TnVtQywgdGV4TnVtUik7XFxufVxcblwiLFNBTVBMRV8zRF9TTklQUEVUPVwiXFxudmVjMiBVVmZyb20zRChpbnQgdGV4TnVtUiwgaW50IHRleE51bUMsIGludCBzdHJpZGUwLFxcbiAgICBpbnQgc3RyaWRlMSwgaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoKSB7XFxuICAvLyBFeHBsaWNpdGx5IHVzZSBpbnRlZ2VyIG9wZXJhdGlvbnMgYXMgZG90KCkgb25seSB3b3JrcyBvbiBmbG9hdHMuXFxuICBpbnQgaW5kZXggPSByb3cgKiBzdHJpZGUwICsgY29sICogc3RyaWRlMSArIGRlcHRoO1xcbiAgaW50IHRleFIgPSBpbmRleCAvIHRleE51bUM7XFxuICBpbnQgdGV4QyA9IGluZGV4IC0gdGV4UiAqIHRleE51bUM7XFxuICByZXR1cm4gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC8gdmVjMih0ZXhOdW1DLCB0ZXhOdW1SKTtcXG59XFxudmVjMiBwYWNrZWRVVmZyb20zRChpbnQgdGV4TnVtUiwgaW50IHRleE51bUMsXFxuICAgIGludCB0ZXhlbHNJbkJhdGNoLCBpbnQgdGV4ZWxzSW5Mb2dpY2FsUm93LCBpbnQgYixcXG4gICAgaW50IHJvdywgaW50IGNvbCkge1xcbiAgaW50IGluZGV4ID0gYiAqIHRleGVsc0luQmF0Y2ggKyAocm93IC8gMikgKiB0ZXhlbHNJbkxvZ2ljYWxSb3cgKyAoY29sIC8gMik7XFxuICBpbnQgdGV4UiA9IGluZGV4IC8gdGV4TnVtQztcXG4gIGludCB0ZXhDID0gaW5kZXggLSB0ZXhSICogdGV4TnVtQztcXG4gIHJldHVybiAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKHRleE51bUMsIHRleE51bVIpO1xcbn1cXG5cIixTQU1QTEVfNERfU05JUFBFVD1cIlxcbnZlYzIgVVZmcm9tNEQoaW50IHRleE51bVIsIGludCB0ZXhOdW1DLCBpbnQgc3RyaWRlMCxcXG4gICAgaW50IHN0cmlkZTEsIGludCBzdHJpZGUyLCBpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsXFxuICAgIGludCBkZXB0aDIpIHtcXG4gIC8vIEV4cGxpY2l0bHkgdXNlIGludGVnZXIgb3BlcmF0aW9ucyBhcyBkb3QoKSBvbmx5IHdvcmtzIG9uIGZsb2F0cy5cXG4gIGludCBpbmRleCA9IHJvdyAqIHN0cmlkZTAgKyBjb2wgKiBzdHJpZGUxICsgZGVwdGggKiBzdHJpZGUyICsgZGVwdGgyO1xcbiAgaW50IHRleFIgPSBpbmRleCAvIHRleE51bUM7XFxuICBpbnQgdGV4QyA9IGluZGV4IC0gdGV4UiAqIHRleE51bUM7XFxuICByZXR1cm4gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC8gdmVjMih0ZXhOdW1DLCB0ZXhOdW1SKTtcXG59XFxudmVjMiBwYWNrZWRVVmZyb200RChpbnQgdGV4TnVtUiwgaW50IHRleE51bUMsIGludCB0ZXhlbHNJbkJhdGNoMixcXG4gICAgaW50IHRleGVsc0luQmF0Y2gsIGludCB0ZXhlbHNJbkxvZ2ljYWxSb3csIGludCBiMiwgaW50IGIsXFxuICAgIGludCByb3csIGludCBjb2wpIHtcXG4gIGludCBpbmRleCA9IGIyICogdGV4ZWxzSW5CYXRjaDIgKyBiICogdGV4ZWxzSW5CYXRjaCArXFxuICAgIChyb3cgLyAyKSAqIHRleGVsc0luTG9naWNhbFJvdyArIChjb2wgLyAyKTtcXG4gIGludCB0ZXhSID0gaW5kZXggLyB0ZXhOdW1DO1xcbiAgaW50IHRleEMgPSBpbmRleCAtIHRleFIgKiB0ZXhOdW1DO1xcbiAgcmV0dXJuICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIodGV4TnVtQywgdGV4TnVtUik7XFxufVxcblwiLFNBTVBMRV81RF9TTklQUEVUPVwiXFxudmVjMiBVVmZyb201RChpbnQgdGV4TnVtUiwgaW50IHRleE51bUMsIGludCBzdHJpZGUwLFxcbiAgICBpbnQgc3RyaWRlMSwgaW50IHN0cmlkZTIsIGludCBzdHJpZGUzLCBpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsXFxuICAgIGludCBkZXB0aDIsIGludCBkZXB0aDMpIHtcXG4gIC8vIEV4cGxpY2l0bHkgdXNlIGludGVnZXIgb3BlcmF0aW9ucyBhcyBkb3QoKSBvbmx5IHdvcmtzIG9uIGZsb2F0cy5cXG4gIGludCBpbmRleCA9IHJvdyAqIHN0cmlkZTAgKyBjb2wgKiBzdHJpZGUxICtcXG4gICAgICAgICAgICAgIGRlcHRoICogc3RyaWRlMiArIGRlcHRoMiAqIHN0cmlkZTMgKyBkZXB0aDM7XFxuICBpbnQgdGV4UiA9IGluZGV4IC8gdGV4TnVtQztcXG4gIGludCB0ZXhDID0gaW5kZXggLSB0ZXhSICogdGV4TnVtQztcXG4gIHJldHVybiAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKHRleE51bUMsIHRleE51bVIpO1xcbn1cXG5cIixTQU1QTEVfNkRfU05JUFBFVD1cIlxcbnZlYzIgVVZmcm9tNkQoaW50IHRleE51bVIsIGludCB0ZXhOdW1DLCBpbnQgc3RyaWRlMCxcXG4gICAgaW50IHN0cmlkZTEsIGludCBzdHJpZGUyLCBpbnQgc3RyaWRlMywgaW50IHN0cmlkZTQsXFxuICAgIGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMiwgaW50IGRlcHRoMywgaW50IGRlcHRoNCkge1xcbiAgLy8gRXhwbGljaXRseSB1c2UgaW50ZWdlciBvcGVyYXRpb25zIGFzIGRvdCgpIG9ubHkgd29ya3Mgb24gZmxvYXRzLlxcbiAgaW50IGluZGV4ID0gcm93ICogc3RyaWRlMCArIGNvbCAqIHN0cmlkZTEgKyBkZXB0aCAqIHN0cmlkZTIgKyBkZXB0aDIgKlxcbiAgICBzdHJpZGUzICsgZGVwdGgzICogc3RyaWRlNCArIGRlcHRoNDtcXG4gIGludCB0ZXhSID0gaW5kZXggLyB0ZXhOdW1DO1xcbiAgaW50IHRleEMgPSBpbmRleCAtIHRleFIgKiB0ZXhOdW1DO1xcbiAgcmV0dXJuICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIodGV4TnVtQywgdGV4TnVtUik7XFxufVxcblwiLEZMT0FUX1RFWFRVUkVfU0FNUExFX1NOSVBQRVQ9XCJcXG4gIGZsb2F0IHNhbXBsZVRleHR1cmUoc2FtcGxlcjJEIHRleHR1cmVTYW1wbGVyLCB2ZWMyIHV2KSB7XFxuICAgIHJldHVybiB0ZXh0dXJlMkQodGV4dHVyZVNhbXBsZXIsIHV2KS5yO1xcbiAgfVxcblwiLEZMT0FUX1RFWFRVUkVfU0VUX1JfU05JUFBFVD1cIlxcbiAgdm9pZCBzZXRPdXRwdXQoZmxvYXQgdmFsKSB7XFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQodmFsLCAwLCAwLCAwKTtcXG4gIH1cXG5cIixGTE9BVF9URVhUVVJFX1NFVF9SR0JBX1NOSVBQRVQ9XCJcXG4gIHZvaWQgc2V0T3V0cHV0KHZlYzQgdmFsKSB7XFxuICAgIGdsX0ZyYWdDb2xvciA9IHZhbDtcXG4gIH1cXG5cIixTSEFERVJfUFJFRklYPVwiXFxuICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuICBwcmVjaXNpb24gaGlnaHAgaW50O1xcbiAgdmFyeWluZyB2ZWMyIHJlc3VsdFVWO1xcbiAgY29uc3QgdmVjMiBoYWxmQ1IgPSB2ZWMyKDAuNSwgMC41KTtcXG5cXG4gIHN0cnVjdCBpdmVjNVxcbiAge1xcbiAgICBpbnQgeDtcXG4gICAgaW50IHk7XFxuICAgIGludCB6O1xcbiAgICBpbnQgdztcXG4gICAgaW50IHU7XFxuICB9O1xcblxcbiAgc3RydWN0IGl2ZWM2XFxuICB7XFxuICAgIGludCB4O1xcbiAgICBpbnQgeTtcXG4gICAgaW50IHo7XFxuICAgIGludCB3O1xcbiAgICBpbnQgdTtcXG4gICAgaW50IHY7XFxuICB9O1xcblxcbiAgYm9vbCBpc05hTihmbG9hdCB2YWwpIHtcXG4gICAgcmV0dXJuICh2YWwgPCAxLjAgfHwgMC4wIDwgdmFsIHx8IHZhbCA9PSAwLjApID8gZmFsc2UgOiB0cnVlO1xcbiAgfVxcblxcbiAgYm9vbCBoYXNOYU4odmVjNCB2YWx1ZXMpIHtcXG4gICAgdmVjNCB2MSA9IHZhbHVlcyAqIHZhbHVlcztcXG4gICAgdmVjNCB2MiA9IHZhbHVlcyAqIHZhbHVlcztcXG4gICAgcmV0dXJuIGFueShub3RFcXVhbCh2MSwgdjIpKTtcXG4gIH1cXG5cXG4gIGZsb2F0IGdldE5hTih2ZWM0IHZhbHVlcykge1xcbiAgICByZXR1cm4gZG90KHZlYzQoMSksIHZhbHVlcyk7XFxuICB9XFxuXFxuICBpbnQgcm91bmQoZmxvYXQgdmFsdWUpIHtcXG4gICAgcmV0dXJuIGludChmbG9vcih2YWx1ZSArIDAuNSkpO1xcbiAgfVxcblxcbiAgaW50IGltb2QoaW50IHgsIGludCB5KSB7XFxuICAgIHJldHVybiB4IC0geSAqICh4IC8geSk7XFxuICB9XFxuXFxuICAvL0Jhc2VkIG9uIHRoZSB3b3JrIG9mIERhdmUgSG9za2luc1xcbiAgLy9odHRwczovL3d3dy5zaGFkZXJ0b3kuY29tL3ZpZXcvNGRqU1JXXFxuICAjZGVmaW5lIEhBU0hTQ0FMRTEgNDQzLjg5NzVcXG4gIGZsb2F0IHJhbmRvbShmbG9hdCBzZWVkKXtcXG4gICAgdmVjMiBwID0gcmVzdWx0VVYgKiBzZWVkO1xcbiAgICB2ZWMzIHAzICA9IGZyYWN0KHZlYzMocC54eXgpICogSEFTSFNDQUxFMSk7XFxuICAgIHAzICs9IGRvdChwMywgcDMueXp4ICsgMTkuMTkpO1xcbiAgICByZXR1cm4gZnJhY3QoKHAzLnggKyBwMy55KSAqIHAzLnopO1xcbiAgfVxcblxcbiAgXCIrU0FNUExFXzFEX1NOSVBQRVQrXCJcXG4gIFwiK1NBTVBMRV8yRF9TTklQUEVUK1wiXFxuICBcIitTQU1QTEVfM0RfU05JUFBFVCtcIlxcbiAgXCIrU0FNUExFXzREX1NOSVBQRVQrXCJcXG4gIFwiK1NBTVBMRV81RF9TTklQUEVUK1wiXFxuICBcIitTQU1QTEVfNkRfU05JUFBFVCtcIlxcblwiLFNIQURFUl9QQUNLRURfUFJFRklYPVwiXFxuICBmbG9hdCBnZXRDaGFubmVsKHZlYzQgZnJhZywgdmVjMiBpbm5lckRpbXMpIHtcXG4gICAgdmVjMiBtb2RDb29yZCA9IG1vZChpbm5lckRpbXMsIDIuKTtcXG4gICAgcmV0dXJuIG1vZENvb3JkLnggPT0gMC4gP1xcbiAgICAgIChtb2RDb29yZC55ID09IDAuID8gZnJhZy5yIDogZnJhZy5nKSA6XFxuICAgICAgKG1vZENvb3JkLnkgPT0gMC4gPyBmcmFnLmIgOiBmcmFnLmEpO1xcbiAgfVxcbiAgZmxvYXQgZ2V0Q2hhbm5lbCh2ZWM0IGZyYWcsIGludCBkaW0pIHtcXG4gICAgZmxvYXQgbW9kQ29vcmQgPSBtb2QoZmxvYXQoZGltKSwgMi4pO1xcbiAgICByZXR1cm4gbW9kQ29vcmQgPT0gMC4gPyBmcmFnLnIgOiBmcmFnLmc7XFxuICB9XFxuXCI7ZnVuY3Rpb24gZ2V0T3V0cHV0U2NhbGFyQ29vcmRzKCl7cmV0dXJuXCJcXG4gICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICByZXR1cm4gMDtcXG4gICAgfVxcbiAgXCJ9ZnVuY3Rpb24gZ2V0T3V0cHV0UGFja2VkMURDb29yZHMoZSx0KXt2YXIgcj1bTWF0aC5jZWlsKHRbMF0vMiksTWF0aC5jZWlsKHRbMV0vMildO3JldHVybiAxPT09dFswXT9cIlxcbiAgICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICByZXR1cm4gMiAqIGludChyZXN1bHRVVi54ICogXCIrclsxXStcIi4wKTtcXG4gICAgICB9XFxuICAgIFwiOjE9PT10WzFdP1wiXFxuICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgIHJldHVybiAyICogaW50KHJlc3VsdFVWLnkgKiBcIityWzBdK1wiLjApO1xcbiAgICAgIH1cXG4gICAgXCI6XCJcXG4gICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoXCIrclswXStcIiwgXCIrclsxXStcIikpO1xcbiAgICAgIHJldHVybiByZXNUZXhSQy54ICogXCIrclsxXStcIiArIHJlc1RleFJDLnk7XFxuICAgIH1cXG4gIFwifWZ1bmN0aW9uIGdldE91dHB1dDFEQ29vcmRzKGUsdCl7cmV0dXJuIDE9PT10WzBdP1wiXFxuICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgIHJldHVybiBpbnQocmVzdWx0VVYueCAqIFwiK3RbMV0rXCIuMCk7XFxuICAgICAgfVxcbiAgICBcIjoxPT09dFsxXT9cIlxcbiAgICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICByZXR1cm4gaW50KHJlc3VsdFVWLnkgKiBcIit0WzBdK1wiLjApO1xcbiAgICAgIH1cXG4gICAgXCI6XCJcXG4gICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoXCIrdFswXStcIiwgXCIrdFsxXStcIikpO1xcbiAgICAgIHJldHVybiByZXNUZXhSQy54ICogXCIrdFsxXStcIiArIHJlc1RleFJDLnk7XFxuICAgIH1cXG4gIFwifWZ1bmN0aW9uIGdldE91dHB1dFBhY2tlZDNEQ29vcmRzKGUsdCl7dmFyIHI9W01hdGguY2VpbCh0WzBdLzIpLE1hdGguY2VpbCh0WzFdLzIpXSxuPU1hdGguY2VpbChlWzJdLzIpLG89bipNYXRoLmNlaWwoZVsxXS8yKTtyZXR1cm5cIlxcbiAgICBpdmVjMyBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKFwiK3JbMF0rXCIsIFwiK3JbMV0rXCIpKTtcXG4gICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogXCIrclsxXStcIiArIHJlc1RleFJDLnk7XFxuXFxuICAgICAgaW50IGIgPSBpbmRleCAvIFwiK28rXCI7XFxuICAgICAgaW5kZXggLT0gYiAqIFwiK28rXCI7XFxuXFxuICAgICAgaW50IHIgPSAyICogKGluZGV4IC8gXCIrbitcIik7XFxuICAgICAgaW50IGMgPSBpbW9kKGluZGV4LCBcIituK1wiKSAqIDI7XFxuXFxuICAgICAgcmV0dXJuIGl2ZWMzKGIsIHIsIGMpO1xcbiAgICB9XFxuICBcIn1mdW5jdGlvbiBnZXRPdXRwdXQzRENvb3JkcyhlLHQpe3ZhciByPWdldExvZ2ljYWxDb29yZGluYXRlc0Zyb21GbGF0SW5kZXgoW1wiclwiLFwiY1wiLFwiZFwiXSxlKTtyZXR1cm5cIlxcbiAgICBpdmVjMyBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKFwiK3RbMF0rXCIsIFwiK3RbMV0rXCIpKTtcXG4gICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogXCIrdFsxXStcIiArIHJlc1RleFJDLnk7XFxuICAgICAgXCIrcitcIlxcbiAgICAgIHJldHVybiBpdmVjMyhyLCBjLCBkKTtcXG4gICAgfVxcbiAgXCJ9ZnVuY3Rpb24gZ2V0T3V0cHV0UGFja2VkNERDb29yZHMoZSx0KXt2YXIgcj1bTWF0aC5jZWlsKHRbMF0vMiksTWF0aC5jZWlsKHRbMV0vMildLG49TWF0aC5jZWlsKGVbM10vMiksbz1uKk1hdGguY2VpbChlWzJdLzIpLGE9byplWzFdO3JldHVyblwiXFxuICAgIGl2ZWM0IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoXCIrclswXStcIiwgXCIrclsxXStcIikpO1xcbiAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnggKiBcIityWzFdK1wiICsgcmVzVGV4UkMueTtcXG5cXG4gICAgICBpbnQgYjIgPSBpbmRleCAvIFwiK2ErXCI7XFxuICAgICAgaW5kZXggLT0gYjIgKiBcIithK1wiO1xcblxcbiAgICAgIGludCBiID0gaW5kZXggLyBcIitvK1wiO1xcbiAgICAgIGluZGV4IC09IGIgKiBcIitvK1wiO1xcblxcbiAgICAgIGludCByID0gMiAqIChpbmRleCAvIFwiK24rXCIpO1xcbiAgICAgIGludCBjID0gaW1vZChpbmRleCwgXCIrbitcIikgKiAyO1xcblxcbiAgICAgIHJldHVybiBpdmVjNChiMiwgYiwgciwgYyk7XFxuICAgIH1cXG4gIFwifWZ1bmN0aW9uIGdldE91dHB1dDREQ29vcmRzKGUsdCl7dmFyIHI9Z2V0TG9naWNhbENvb3JkaW5hdGVzRnJvbUZsYXRJbmRleChbXCJyXCIsXCJjXCIsXCJkXCIsXCJkMlwiXSxlKTtyZXR1cm5cIlxcbiAgICBpdmVjNCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICB2ZWMyKFwiK3RbMF0rXCIsIFwiK3RbMV0rXCIpKTtcXG4gICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogXCIrdFsxXStcIiArIHJlc1RleFJDLnk7XFxuICAgICAgXCIrcitcIlxcbiAgICAgIHJldHVybiBpdmVjNChyLCBjLCBkLCBkMik7XFxuICAgIH1cXG4gIFwifWZ1bmN0aW9uIGdldE91dHB1dDVEQ29vcmRzKGUsdCl7dmFyIHI9Z2V0TG9naWNhbENvb3JkaW5hdGVzRnJvbUZsYXRJbmRleChbXCJyXCIsXCJjXCIsXCJkXCIsXCJkMlwiLFwiZDNcIl0sZSk7cmV0dXJuXCJcXG4gICAgaXZlYzUgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKiB2ZWMyKFwiK3RbMF0rXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIit0WzFdK1wiKSk7XFxuXFxuICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqIFwiK3RbMV0rXCIgKyByZXNUZXhSQy55O1xcblxcbiAgICAgIFwiK3IrXCJcXG5cXG4gICAgICBpdmVjNSBvdXRTaGFwZSA9IGl2ZWM1KHIsIGMsIGQsIGQyLCBkMyk7XFxuICAgICAgcmV0dXJuIG91dFNoYXBlO1xcbiAgICB9XFxuICBcIn1mdW5jdGlvbiBnZXRPdXRwdXQ2RENvb3JkcyhlLHQpe3ZhciByPWdldExvZ2ljYWxDb29yZGluYXRlc0Zyb21GbGF0SW5kZXgoW1wiclwiLFwiY1wiLFwiZFwiLFwiZDJcIixcImQzXCIsXCJkNFwiXSxlKTtyZXR1cm5cIlxcbiAgICBpdmVjNiBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICB2ZWMyKFwiK3RbMF0rXCIsIFwiK3RbMV0rXCIpKTtcXG4gICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogXCIrdFsxXStcIiArIHJlc1RleFJDLnk7XFxuXFxuICAgICAgXCIrcitcIlxcblxcbiAgICAgIGl2ZWM2IHJlc3VsdCA9IGl2ZWM2KHIsIGMsIGQsIGQyLCBkMywgZDQpO1xcbiAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgIH1cXG4gIFwifWZ1bmN0aW9uIGdldE91dHB1dFBhY2tlZDJEQ29vcmRzKGUsdCl7dmFyIHI9W01hdGguY2VpbCh0WzBdLzIpLE1hdGguY2VpbCh0WzFdLzIpXTtpZihhcnJheXNFcXVhbChlLHQpKXJldHVyblwiXFxuICAgICAgaXZlYzIgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgcmV0dXJuIDIgKiBpdmVjMihyZXN1bHRVVi55eCAqIHZlYzIoXCIrclswXStcIiwgXCIrclsxXStcIikpO1xcbiAgICAgIH1cXG4gICAgXCI7dmFyIG49TWF0aC5jZWlsKGVbMV0vMik7cmV0dXJuXCJcXG4gICAgaXZlYzIgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMihcIityWzBdK1wiLCBcIityWzFdK1wiKSk7XFxuXFxuICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqIFwiK3JbMV0rXCIgKyByZXNUZXhSQy55O1xcbiAgICAgIGludCByID0gMiAqIChpbmRleCAvIFwiK24rXCIpO1xcbiAgICAgIGludCBjID0gaW1vZChpbmRleCwgXCIrbitcIikgKiAyO1xcblxcbiAgICAgIHJldHVybiBpdmVjMihyLCBjKTtcXG4gICAgfVxcbiAgXCJ9ZnVuY3Rpb24gZ2V0T3V0cHV0MkRDb29yZHMoZSx0KXtyZXR1cm4gYXJyYXlzRXF1YWwoZSx0KT9cIlxcbiAgICAgIGl2ZWMyIGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgIHJldHVybiBpdmVjMihyZXN1bHRVVi55eCAqIHZlYzIoXCIrdFswXStcIiwgXCIrdFsxXStcIikpO1xcbiAgICAgIH1cXG4gICAgXCI6MT09PWVbMV0/XCJcXG4gICAgICBpdmVjMiBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMihcIit0WzBdK1wiLCBcIit0WzFdK1wiKSk7XFxuICAgICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogXCIrdFsxXStcIiArIHJlc1RleFJDLnk7XFxuICAgICAgICByZXR1cm4gaXZlYzIoaW5kZXgsIDApO1xcbiAgICAgIH1cXG4gICAgXCI6MT09PWVbMF0/XCJcXG4gICAgICBpdmVjMiBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMihcIit0WzBdK1wiLCBcIit0WzFdK1wiKSk7XFxuICAgICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogXCIrdFsxXStcIiArIHJlc1RleFJDLnk7XFxuICAgICAgICByZXR1cm4gaXZlYzIoMCwgaW5kZXgpO1xcbiAgICAgIH1cXG4gICAgXCI6XCJcXG4gICAgaXZlYzIgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMihcIit0WzBdK1wiLCBcIit0WzFdK1wiKSk7XFxuICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqIFwiK3RbMV0rXCIgKyByZXNUZXhSQy55O1xcbiAgICAgIGludCByID0gaW5kZXggLyBcIitlWzFdK1wiO1xcbiAgICAgIGludCBjID0gaW5kZXggLSByICogXCIrZVsxXStcIjtcXG4gICAgICByZXR1cm4gaXZlYzIociwgYyk7XFxuICAgIH1cXG4gIFwifWZ1bmN0aW9uIGdldFNhbXBsZXJTY2FsYXIoZSl7dmFyIHQ9ZS5uYW1lLHI9XCJnZXRcIit0LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK3Quc2xpY2UoMSk7cmV0dXJuIGUuc2hhcGVJbmZvLmlzVW5pZm9ybT9cImZsb2F0IFwiK3IrXCIoKSB7cmV0dXJuIFwiK3QrXCI7fVwiOlwiXFxuICAgIGZsb2F0IFwiK3IrXCIoKSB7XFxuICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrdCtcIiwgaGFsZkNSKTtcXG4gICAgfVxcbiAgXCJ9ZnVuY3Rpb24gZ2V0UGFja2VkU2FtcGxlcjFEKGUpe3ZhciB0PWUubmFtZSxyPVwiZ2V0XCIrdC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSt0LnNsaWNlKDEpLG49ZS5zaGFwZUluZm8udGV4U2hhcGUsbz1bTWF0aC5jZWlsKG5bMF0vMiksTWF0aC5jZWlsKG5bMV0vMildO3JldHVyblwiXFxuICAgIHZlYzQgXCIrcitcIihpbnQgaW5kZXgpIHtcXG4gICAgICB2ZWMyIHV2ID0gcGFja2VkVVZmcm9tMUQoXFxuICAgICAgICBcIitvWzBdK1wiLCBcIitvWzFdK1wiLCBpbmRleCk7XFxuICAgICAgcmV0dXJuIHRleHR1cmUyRChcIit0K1wiLCB1dik7XFxuICAgIH1cXG4gIFwifWZ1bmN0aW9uIGdldFNhbXBsZXIxRChlKXt2YXIgdD1lLm5hbWUscj1cImdldFwiK3QuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrdC5zbGljZSgxKTtyZXR1cm5cIlxcbiAgICBmbG9hdCBcIityK1wiKGludCBpbmRleCkge1xcbiAgICAgIHJldHVybiBcIityK1wiRmxhdChpbmRleCk7XFxuICAgIH1cXG4gIFwifWZ1bmN0aW9uIGdldFBhY2tlZFNhbXBsZXIyRChlKXt2YXIgdD1lLnNoYXBlSW5mby5sb2dpY2FsU2hhcGUscj1lLm5hbWUsbj1cImdldFwiK3IuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrci5zbGljZSgxKSxvPWUuc2hhcGVJbmZvLnRleFNoYXBlLGE9b1swXSxpPW9bMV07aWYobnVsbCE9byYmYXJyYXlzRXF1YWwodCxvKSlyZXR1cm5cIlxcbiAgICAgIHZlYzQgXCIrbitcIihpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgICB2ZWMyIHV2ID0gKHZlYzIoY29sLCByb3cpICsgaGFsZkNSKSAvIHZlYzIoXCIraStcIi4wLCBcIithK1wiLjApO1xcblxcbiAgICAgICAgcmV0dXJuIHRleHR1cmUyRChcIityK1wiLCB1dik7XFxuICAgICAgfVxcbiAgICBcIjt2YXIgcz1bTWF0aC5jZWlsKG9bMF0vMiksTWF0aC5jZWlsKG9bMV0vMildO3JldHVyblwiXFxuICAgIHZlYzQgXCIrbitcIihpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgdmVjMiB1diA9IHBhY2tlZFVWZnJvbTJEKFwiK01hdGguY2VpbCh0WzFdLzIpK1wiLCBcIitzWzBdK1wiLCBcIitzWzFdK1wiLCByb3csIGNvbCk7XFxuICAgICAgcmV0dXJuIHRleHR1cmUyRChcIityK1wiLCB1dik7XFxuICAgIH1cXG4gIFwifWZ1bmN0aW9uIGdldFNhbXBsZXIyRChlKXt2YXIgdD1lLnNoYXBlSW5mby5sb2dpY2FsU2hhcGUscj1lLm5hbWUsbj1cImdldFwiK3IuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrci5zbGljZSgxKSxvPWUuc2hhcGVJbmZvLnRleFNoYXBlO2lmKG51bGwhPW8mJmFycmF5c0VxdWFsKHQsbykpe3ZhciBhPW9bMF07cmV0dXJuXCJcXG4gICAgZmxvYXQgXCIrbitcIihpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgdmVjMiB1diA9ICh2ZWMyKGNvbCwgcm93KSArIGhhbGZDUikgLyB2ZWMyKFwiK29bMV0rXCIuMCwgXCIrYStcIi4wKTtcXG4gICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIityK1wiLCB1dik7XFxuICAgIH1cXG4gIFwifXZhciBpPXNxdWVlemVTaGFwZSh0KSxzPWkubmV3U2hhcGUsdT1pLmtlcHREaW1zLGw9cztpZihsLmxlbmd0aDx0Lmxlbmd0aCl7cmV0dXJuXCJcXG4gICAgICBcIitnZXRTYW1wbGVyRnJvbUluSW5mbyhzcXVlZXplSW5wdXRJbmZvKGUsbCkpK1wiXFxuICAgICAgZmxvYXQgXCIrbitcIihpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgICByZXR1cm4gXCIrbitcIihcIitnZXRTcXVlZXplZFBhcmFtcyhbXCJyb3dcIixcImNvbFwiXSx1KStcIik7XFxuICAgICAgfVxcbiAgICBcIn1pZihlLnNoYXBlSW5mby5pc1VuaWZvcm0pcmV0dXJuXCJcXG4gICAgICBmbG9hdCBcIituK1wiKGludCByb3csIGludCBjb2wpIHtcXG4gICAgICAgIGZsb2F0IGluZGV4ID0gZG90KHZlYzIocm93LCBjb2wpLCB2ZWMyKFwiK3RbMV0rXCIsIDEpKTtcXG4gICAgICAgIHJldHVybiBcIituK1wiRmxhdChyb3VuZChpbmRleCkpO1xcbiAgICAgIH1cXG4gICAgXCI7dmFyIGM9b1swXSxwPW9bMV07cmV0dXJuIDE9PT1wP1wiXFxuICAgIGZsb2F0IFwiK24rXCIoaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgIGZsb2F0IGluZGV4ID0gZG90KHZlYzIocm93LCBjb2wpLCB2ZWMyKFwiK3RbMV0rXCIsIDEpKTtcXG4gICAgICB2ZWMyIHV2ID0gdmVjMigwLjUsIChpbmRleCArIDAuNSkgLyBcIitjK1wiLjApO1xcbiAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK3IrXCIsIHV2KTtcXG4gICAgfVxcbiAgXCI6MT09PWM/XCJcXG4gICAgZmxvYXQgXCIrbitcIihpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgZmxvYXQgaW5kZXggPSBkb3QodmVjMihyb3csIGNvbCksIHZlYzIoXCIrdFsxXStcIiwgMSkpO1xcbiAgICAgIHZlYzIgdXYgPSB2ZWMyKChpbmRleCArIDAuNSkgLyBcIitwK1wiLjAsIDAuNSk7XFxuICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrcitcIiwgdXYpO1xcbiAgICB9XFxuICBcIjpcIlxcbiAgZmxvYXQgXCIrbitcIihpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgIHZlYzIgdXYgPSBVVmZyb20yRChcIitjK1wiLCBcIitwK1wiLCBcIit0WzFdK1wiLCByb3csIGNvbCk7XFxuICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK3IrXCIsIHV2KTtcXG4gIH1cXG5cIn1mdW5jdGlvbiBnZXRQYWNrZWRTYW1wbGVyM0QoZSl7dmFyIHQ9ZS5zaGFwZUluZm8ubG9naWNhbFNoYXBlLHI9ZS5uYW1lLG49XCJnZXRcIityLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK3Iuc2xpY2UoMSksbz1lLnNoYXBlSW5mby50ZXhTaGFwZSxhPVtNYXRoLmNlaWwob1swXS8yKSxNYXRoLmNlaWwob1sxXS8yKV07aWYoMT09PXRbMF0pe3JldHVyblwiXFxuICAgICAgICBcIitnZXRQYWNrZWRTYW1wbGVyRnJvbUluSW5mbyhzcXVlZXplSW5wdXRJbmZvKGUsdC5zbGljZSgxKSkpK1wiXFxuICAgICAgICB2ZWM0IFwiK24rXCIoaW50IGIsIGludCByb3csIGludCBjb2wpIHtcXG4gICAgICAgICAgcmV0dXJuIFwiK24rXCIoXCIrZ2V0U3F1ZWV6ZWRQYXJhbXMoW1wiYlwiLFwicm93XCIsXCJjb2xcIl0sWzEsMl0pK1wiKTtcXG4gICAgICAgIH1cXG4gICAgICBcIn12YXIgaT1hWzBdLHM9YVsxXSx1PU1hdGguY2VpbCh0WzJdLzIpO3JldHVyblwiXFxuICAgIHZlYzQgXCIrbitcIihpbnQgYiwgaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgIHZlYzIgdXYgPSBwYWNrZWRVVmZyb20zRChcXG4gICAgICAgIFwiK2krXCIsIFwiK3MrXCIsIFwiK3UqTWF0aC5jZWlsKHRbMV0vMikrXCIsIFwiK3UrXCIsIGIsIHJvdywgY29sKTtcXG4gICAgICByZXR1cm4gdGV4dHVyZTJEKFwiK3IrXCIsIHV2KTtcXG4gICAgfVxcbiAgXCJ9ZnVuY3Rpb24gZ2V0U2FtcGxlcjNEKGUpe3ZhciB0PWUuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSxyPWUubmFtZSxuPVwiZ2V0XCIrci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStyLnNsaWNlKDEpLG89dFsxXSp0WzJdLGE9dFsyXSxpPXNxdWVlemVTaGFwZSh0KSxzPWkubmV3U2hhcGUsdT1pLmtlcHREaW1zLGw9cztpZihsLmxlbmd0aDx0Lmxlbmd0aCl7cmV0dXJuXCJcXG4gICAgICAgIFwiK2dldFNhbXBsZXJGcm9tSW5JbmZvKHNxdWVlemVJbnB1dEluZm8oZSxsKSkrXCJcXG4gICAgICAgIGZsb2F0IFwiK24rXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoKSB7XFxuICAgICAgICAgIHJldHVybiBcIituK1wiKFwiK2dldFNxdWVlemVkUGFyYW1zKFtcInJvd1wiLFwiY29sXCIsXCJkZXB0aFwiXSx1KStcIik7XFxuICAgICAgICB9XFxuICAgICAgXCJ9aWYoZS5zaGFwZUluZm8uaXNVbmlmb3JtKXJldHVyblwiXFxuICAgICAgZmxvYXQgXCIrbitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgpIHtcXG4gICAgICAgIGZsb2F0IGluZGV4ID0gZG90KHZlYzMocm93LCBjb2wsIGRlcHRoKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzMoXCIrbytcIiwgXCIrYStcIiwgMSkpO1xcbiAgICAgICAgcmV0dXJuIFwiK24rXCJGbGF0KHJvdW5kKGluZGV4KSk7XFxuICAgICAgfVxcbiAgICBcIjt2YXIgYz1lLnNoYXBlSW5mby50ZXhTaGFwZSxwPWNbMF0sZD1jWzFdO3JldHVybiBkPT09bz9cIlxcbiAgICAgICAgZmxvYXQgXCIrbitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgpIHtcXG4gICAgICAgICAgZmxvYXQgdGV4UiA9IGZsb2F0KHJvdyk7XFxuICAgICAgICAgIGZsb2F0IHRleEMgPSBkb3QodmVjMihjb2wsIGRlcHRoKSwgdmVjMihcIithK1wiLCAxKSk7XFxuICAgICAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgL1xcbiAgICAgICAgICAgICAgICAgICAgIHZlYzIoXCIrZCtcIi4wLCBcIitwK1wiLjApO1xcbiAgICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIityK1wiLCB1dik7XFxuICAgICAgICB9XFxuICAgICAgXCI6ZD09PWE/XCJcXG4gICAgZmxvYXQgXCIrbitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgpIHtcXG4gICAgICBmbG9hdCB0ZXhSID0gZG90KHZlYzIocm93LCBjb2wpLCB2ZWMyKFwiK3RbMV0rXCIsIDEpKTtcXG4gICAgICBmbG9hdCB0ZXhDID0gZmxvYXQoZGVwdGgpO1xcbiAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKFwiK2QrXCIuMCwgXCIrcCtcIi4wKTtcXG4gICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIityK1wiLCB1dik7XFxuICAgIH1cXG4gIFwiOlwiXFxuICAgICAgZmxvYXQgXCIrbitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgpIHtcXG4gICAgICAgIHZlYzIgdXYgPSBVVmZyb20zRChcXG4gICAgICAgICAgICBcIitwK1wiLCBcIitkK1wiLCBcIitvK1wiLCBcIithK1wiLCByb3csIGNvbCwgZGVwdGgpO1xcbiAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrcitcIiwgdXYpO1xcbiAgICAgIH1cXG4gIFwifWZ1bmN0aW9uIGdldFBhY2tlZFNhbXBsZXI0RChlKXt2YXIgdD1lLnNoYXBlSW5mby5sb2dpY2FsU2hhcGUscj1lLm5hbWUsbj1cImdldFwiK3IuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrci5zbGljZSgxKSxvPWUuc2hhcGVJbmZvLnRleFNoYXBlLGE9W01hdGguY2VpbChvWzBdLzIpLE1hdGguY2VpbChvWzFdLzIpXSxpPWFbMF0scz1hWzFdLHU9TWF0aC5jZWlsKHRbM10vMiksbD11Kk1hdGguY2VpbCh0WzJdLzIpO3JldHVyblwiXFxuICAgIHZlYzQgXCIrbitcIihpbnQgYjIsIGludCBiLCBpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgdmVjMiB1diA9IHBhY2tlZFVWZnJvbTREKFxcbiAgICAgICAgXCIraStcIiwgXCIrcytcIiwgXCIrbCp0WzFdK1wiLFxcbiAgICAgICAgXCIrbCtcIiwgXCIrdStcIiwgYjIsIGIsIHJvdywgY29sKTtcXG4gICAgICByZXR1cm4gdGV4dHVyZTJEKFwiK3IrXCIsIHV2KTtcXG4gICAgfVxcbiAgXCJ9ZnVuY3Rpb24gZ2V0U2FtcGxlcjREKGUpe3ZhciB0PWUuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSxyPWUubmFtZSxuPVwiZ2V0XCIrci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStyLnNsaWNlKDEpLG89dFszXSxhPXRbMl0qbyxpPXRbMV0qYSxzPXNxdWVlemVTaGFwZSh0KSx1PXMubmV3U2hhcGUsbD1zLmtlcHREaW1zO2lmKHUubGVuZ3RoPHQubGVuZ3RoKXtyZXR1cm5cIlxcbiAgICAgIFwiK2dldFNhbXBsZXJGcm9tSW5JbmZvKHNxdWVlemVJbnB1dEluZm8oZSx1KSkrXCJcXG4gICAgICBmbG9hdCBcIituK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMikge1xcbiAgICAgICAgcmV0dXJuIFwiK24rXCIoXCIrZ2V0U3F1ZWV6ZWRQYXJhbXMoW1wicm93XCIsXCJjb2xcIixcImRlcHRoXCIsXCJkZXB0aDJcIl0sbCkrXCIpO1xcbiAgICAgIH1cXG4gICAgXCJ9aWYoZS5zaGFwZUluZm8uaXNVbmlmb3JtKXJldHVyblwiXFxuICAgICAgZmxvYXQgXCIrbitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIpIHtcXG4gICAgICAgIGZsb2F0IGluZGV4ID0gZG90KHZlYzQocm93LCBjb2wsIGRlcHRoLCBkZXB0aDIpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjNChcIitpK1wiLCBcIithK1wiLCBcIitvK1wiLCAxKSk7XFxuICAgICAgICByZXR1cm4gXCIrbitcIkZsYXQocm91bmQoaW5kZXgpKTtcXG4gICAgICB9XFxuICAgIFwiO3ZhciBjPWUuc2hhcGVJbmZvLnRleFNoYXBlLHA9Y1swXSxkPWNbMV07cmV0dXJuIGQ9PT1pP1wiXFxuICAgICAgZmxvYXQgXCIrbitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIpIHtcXG4gICAgICAgIGZsb2F0IHRleFIgPSBmbG9hdChyb3cpO1xcbiAgICAgICAgZmxvYXQgdGV4QyA9XFxuICAgICAgICAgICAgZG90KHZlYzMoY29sLCBkZXB0aCwgZGVwdGgyKSwgdmVjMyhcIithK1wiLCBcIitvK1wiLCAxKSk7XFxuICAgICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC9cXG4gICAgICAgICAgICAgICAgICAgdmVjMihcIitkK1wiLjAsIFwiK3ArXCIuMCk7XFxuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIityK1wiLCB1dik7XFxuICAgICAgfVxcbiAgICBcIjpkPT09bz9cIlxcbiAgICAgIGZsb2F0IFwiK24rXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyKSB7XFxuICAgICAgICBmbG9hdCB0ZXhSID0gZG90KHZlYzMocm93LCBjb2wsIGRlcHRoKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgdmVjMyhcIit0WzFdKnRbMl0rXCIsIFwiK3RbMl0rXCIsIDEpKTtcXG4gICAgICAgIGZsb2F0IHRleEMgPSBmbG9hdChkZXB0aDIpO1xcbiAgICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvXFxuICAgICAgICAgICAgICAgICAgdmVjMihcIitkK1wiLjAsIFwiK3ArXCIuMCk7XFxuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIityK1wiLCB1dik7XFxuICAgICAgfVxcbiAgICBcIjpcIlxcbiAgICBmbG9hdCBcIituK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMikge1xcbiAgICAgIHZlYzIgdXYgPSBVVmZyb200RChcIitwK1wiLCBcIitkK1wiLCBcIitpK1wiLCBcIithK1wiLFxcbiAgICAgICAgICBcIitvK1wiLCByb3csIGNvbCwgZGVwdGgsIGRlcHRoMik7XFxuICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrcitcIiwgdXYpO1xcbiAgICB9XFxuICBcIn1mdW5jdGlvbiBnZXRTYW1wbGVyNUQoZSl7dmFyIHQ9ZS5zaGFwZUluZm8ubG9naWNhbFNoYXBlLHI9ZS5uYW1lLG49XCJnZXRcIityLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK3Iuc2xpY2UoMSksbz10WzRdLGE9dFszXSpvLGk9dFsyXSphLHM9dFsxXSppLHU9c3F1ZWV6ZVNoYXBlKHQpLGw9dS5uZXdTaGFwZSxjPXUua2VwdERpbXM7aWYobC5sZW5ndGg8dC5sZW5ndGgpe3JldHVyblwiXFxuICAgICAgXCIrZ2V0U2FtcGxlckZyb21JbkluZm8oc3F1ZWV6ZUlucHV0SW5mbyhlLGwpKStcIlxcbiAgICAgIGZsb2F0IFwiK24rXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzKSB7XFxuICAgICAgICByZXR1cm4gXCIrbitcIihcIitnZXRTcXVlZXplZFBhcmFtcyhbXCJyb3dcIixcImNvbFwiLFwiZGVwdGhcIixcImRlcHRoMlwiLFwiZGVwdGgzXCJdLGMpK1wiKTtcXG4gICAgICB9XFxuICAgIFwifWlmKGUuc2hhcGVJbmZvLmlzVW5pZm9ybSlyZXR1cm5cIlxcbiAgICAgIGZsb2F0IFwiK24rXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzKSB7XFxuICAgICAgICBmbG9hdCBpbmRleCA9IGRvdChcXG4gICAgICAgICAgdmVjNChyb3csIGNvbCwgZGVwdGgsIGRlcHRoMiksXFxuICAgICAgICAgIHZlYzQoXCIrcytcIiwgXCIraStcIiwgXCIrYStcIiwgXCIrbytcIikpICtcXG4gICAgICAgICAgZGVwdGgzO1xcbiAgICAgICAgcmV0dXJuIFwiK24rXCJGbGF0KGluZGV4KTtcXG4gICAgICB9XFxuICAgIFwiO3ZhciBwPWUuc2hhcGVJbmZvLnRleFNoYXBlLGQ9cFswXSxoPXBbMV07cmV0dXJuIGg9PT1zP1wiXFxuICAgICAgZmxvYXQgXCIrbitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIsIGludCBkZXB0aDMpIHtcXG4gICAgICAgIGludCB0ZXhSID0gcm93O1xcbiAgICAgICAgZmxvYXQgdGV4QyA9IGRvdChcXG4gICAgICAgICAgdmVjNChjb2wsIGRlcHRoLCBkZXB0aDIsIGRlcHRoMyksXFxuICAgICAgICAgIHZlYzQoXCIraStcIiwgXCIrYStcIiwgXCIrbytcIiwgMSkpO1xcbiAgICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvXFxuICAgICAgICAgICAgICAgICAgIHZlYzIoXCIraCtcIi4wLCBcIitkK1wiLjApO1xcbiAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrcitcIiwgdXYpO1xcbiAgICAgIH1cXG4gICAgXCI6aD09PW8/XCJcXG4gICAgICBmbG9hdCBcIituK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMiwgaW50IGRlcHRoMykge1xcbiAgICAgICAgZmxvYXQgdGV4UiA9IGRvdChcXG4gICAgICAgICAgdmVjNChyb3csIGNvbCwgZGVwdGgsIGRlcHRoMiksXFxuICAgICAgICAgIHZlYzQoXCIrdFsxXSp0WzJdKnRbM10rXCIsIFwiK3RbMl0qdFszXStcIixcXG4gICAgICAgICAgICBcIit0WzNdK1wiLCAxKSk7XFxuICAgICAgICBpbnQgdGV4QyA9IGRlcHRoMztcXG4gICAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgL1xcbiAgICAgICAgICAgICAgICAgIHZlYzIoXCIraCtcIi4wLCBcIitkK1wiLjApO1xcbiAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrcitcIiwgdXYpO1xcbiAgICAgIH1cXG4gICAgXCI6XCJcXG4gICAgZmxvYXQgXCIrbitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIsIGludCBkZXB0aDMpIHtcXG4gICAgICB2ZWMyIHV2ID0gVVZmcm9tNUQoXCIrZCtcIiwgXCIraCtcIiwgXCIrcytcIiwgXCIraStcIixcXG4gICAgICAgICAgXCIrYStcIiwgXCIrbytcIiwgcm93LCBjb2wsIGRlcHRoLCBkZXB0aDIsIGRlcHRoMyk7XFxuICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrcitcIiwgdXYpO1xcbiAgICB9XFxuICBcIn1mdW5jdGlvbiBnZXRTYW1wbGVyNkQoZSl7dmFyIHQ9ZS5zaGFwZUluZm8ubG9naWNhbFNoYXBlLHI9ZS5uYW1lLG49XCJnZXRcIityLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK3Iuc2xpY2UoMSksbz10WzVdLGE9dFs0XSpvLGk9dFszXSphLHM9dFsyXSppLHU9dFsxXSpzLGw9c3F1ZWV6ZVNoYXBlKHQpLGM9bC5uZXdTaGFwZSxwPWwua2VwdERpbXM7aWYoYy5sZW5ndGg8dC5sZW5ndGgpe3JldHVyblwiXFxuICAgICAgXCIrZ2V0U2FtcGxlckZyb21JbkluZm8oc3F1ZWV6ZUlucHV0SW5mbyhlLGMpKStcIlxcbiAgICAgIGZsb2F0IFwiK24rXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLFxcbiAgICAgICAgICAgICAgICAgICAgaW50IGRlcHRoMiwgaW50IGRlcHRoMywgaW50IGRlcHRoNCkge1xcbiAgICAgICAgcmV0dXJuIFwiK24rXCIoXCIrZ2V0U3F1ZWV6ZWRQYXJhbXMoW1wicm93XCIsXCJjb2xcIixcImRlcHRoXCIsXCJkZXB0aDJcIixcImRlcHRoM1wiLFwiZGVwdGg0XCJdLHApK1wiKTtcXG4gICAgICB9XFxuICAgIFwifWlmKGUuc2hhcGVJbmZvLmlzVW5pZm9ybSlyZXR1cm5cIlxcbiAgICAgIGZsb2F0IFwiK24rXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLFxcbiAgICAgICAgICAgICAgICAgIGludCBkZXB0aDIsIGludCBkZXB0aDMsIGludCBkZXB0aDQpIHtcXG4gICAgICAgIGZsb2F0IGluZGV4ID0gZG90KFxcbiAgICAgICAgICB2ZWM0KHJvdywgY29sLCBkZXB0aCwgZGVwdGgyKSxcXG4gICAgICAgICAgdmVjNChcIit1K1wiLCBcIitzK1wiLCBcIitpK1wiLCBcIithK1wiKSkgK1xcbiAgICAgICAgICBkb3QoXFxuICAgICAgICAgICAgdmVjMihkZXB0aDMsIGRlcHRoNCksXFxuICAgICAgICAgICAgdmVjMihcIitvK1wiLCAxKSk7XFxuICAgICAgICByZXR1cm4gXCIrbitcIkZsYXQoaW5kZXgpO1xcbiAgICAgIH1cXG4gICAgXCI7dmFyIGQ9ZS5zaGFwZUluZm8udGV4U2hhcGUsaD1kWzBdLGY9ZFsxXTtyZXR1cm4gZj09PXU/XCJcXG4gICAgICBmbG9hdCBcIituK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCxcXG4gICAgICAgICAgICAgICAgICAgIGludCBkZXB0aDIsIGludCBkZXB0aDMsIGludCBkZXB0aDQpIHtcXG4gICAgICAgIGludCB0ZXhSID0gcm93O1xcbiAgICAgICAgZmxvYXQgdGV4QyA9IGRvdChcXG4gICAgICAgICAgdmVjNChjb2wsIGRlcHRoLCBkZXB0aDIsIGRlcHRoMyksXFxuICAgICAgICAgIHZlYzQoXCIrcytcIiwgXCIraStcIiwgXCIrYStcIiwgXCIrbytcIikpICsgZGVwdGg0O1xcbiAgICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvXFxuICAgICAgICAgICAgICAgICAgIHZlYzIoXCIrZitcIi4wLCBcIitoK1wiLjApO1xcbiAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrcitcIiwgdXYpO1xcbiAgICAgIH1cXG4gICAgXCI6Zj09PW8/XCJcXG4gICAgICBmbG9hdCBcIituK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCxcXG4gICAgICAgICAgICAgICAgICAgIGludCBkZXB0aDIsIGludCBkZXB0aDMsIGludCBkZXB0aDQpIHtcXG4gICAgICAgIGZsb2F0IHRleFIgPSBkb3QoXFxuICAgICAgICAgIHZlYzQocm93LCBjb2wsIGRlcHRoLCBkZXB0aDIpLFxcbiAgICAgICAgICB2ZWM0KFwiK3RbMV0qdFsyXSp0WzNdKnRbNF0rXCIsXFxuICAgICAgICAgICAgICAgXCIrdFsyXSp0WzNdKnRbNF0rXCIsXFxuICAgICAgICAgICAgICAgXCIrdFszXSp0WzRdK1wiLFxcbiAgICAgICAgICAgICAgIFwiK3RbNF0rXCIpKSArIGRlcHRoMztcXG4gICAgICAgIGludCB0ZXhDID0gZGVwdGg0O1xcbiAgICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvXFxuICAgICAgICAgICAgICAgICAgdmVjMihcIitmK1wiLjAsIFwiK2grXCIuMCk7XFxuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIityK1wiLCB1dik7XFxuICAgICAgfVxcbiAgICBcIjpcIlxcbiAgICBmbG9hdCBcIituK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCxcXG4gICAgICAgICAgICAgICAgICBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzLCBpbnQgZGVwdGg0KSB7XFxuICAgICAgdmVjMiB1diA9IFVWZnJvbTZEKFwiK2grXCIsIFwiK2YrXCIsIFwiK3UrXCIsIFwiK3MrXCIsXFxuICAgICAgICAgIFwiK2krXCIsIFwiK2ErXCIsIFwiK28rXCJcXG4gICAgICAgICAgLHJvdywgY29sLCBkZXB0aCwgZGVwdGgyLCBkZXB0aDMsIGRlcHRoNCk7XFxuICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrcitcIiwgdXYpO1xcbiAgICB9XFxuICBcIn1mdW5jdGlvbiBnZXRTYW1wbGVyRmxhdChlKXt2YXIgdD1lLm5hbWUscj1cImdldFwiK3QuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrdC5zbGljZSgxKStcIkZsYXRcIixuPXNpemVGcm9tU2hhcGUoZS5zaGFwZUluZm8ubG9naWNhbFNoYXBlKTtpZihlLnNoYXBlSW5mby5pc1VuaWZvcm0pcmV0dXJuIDE9PT1uP1wiZmxvYXQgXCIrcitcIihpbnQgaW5kZXgpIHtyZXR1cm4gXCIrdCtcIjt9XCI6XCJcXG4gICAgICBmbG9hdCBcIityK1wiKGludCBpbmRleCkge1xcbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBcIituK1wiOyBpKyspIHtcXG4gICAgICAgICAgaWYgKGkgPT0gaW5kZXgpIHtcXG4gICAgICAgICAgICByZXR1cm4gXCIrdCtcIltpXTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgXCI7dmFyIG89ZS5zaGFwZUluZm8udGV4U2hhcGUsYT1vWzBdLGk9b1sxXTtyZXR1cm4gMT09PWkmJjE9PT1hP1wiXFxuICAgICAgZmxvYXQgXCIrcitcIihpbnQgaW5kZXgpIHtcXG4gICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK3QrXCIsIGhhbGZDUik7XFxuICAgICAgfVxcbiAgICBcIjoxPT09aT9cIlxcbiAgICAgIGZsb2F0IFwiK3IrXCIoaW50IGluZGV4KSB7XFxuICAgICAgICB2ZWMyIHV2ID0gdmVjMigwLjUsIChmbG9hdChpbmRleCkgKyAwLjUpIC8gXCIrYStcIi4wKTtcXG4gICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK3QrXCIsIHV2KTtcXG4gICAgICB9XFxuICAgIFwiOjE9PT1hP1wiXFxuICAgICAgZmxvYXQgXCIrcitcIihpbnQgaW5kZXgpIHtcXG4gICAgICAgIHZlYzIgdXYgPSB2ZWMyKChmbG9hdChpbmRleCkgKyAwLjUpIC8gXCIraStcIi4wLCAwLjUpO1xcbiAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrdCtcIiwgdXYpO1xcbiAgICAgIH1cXG4gICAgXCI6XCJcXG4gICAgZmxvYXQgXCIrcitcIihpbnQgaW5kZXgpIHtcXG4gICAgICB2ZWMyIHV2ID0gVVZmcm9tMUQoXCIrYStcIiwgXCIraStcIiwgaW5kZXgpO1xcbiAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK3QrXCIsIHV2KTtcXG4gICAgfVxcbiAgXCJ9ZnVuY3Rpb24gZ2V0QnJvYWRjYXN0T3V0cHV0Q29vcmRzU2FtcGxlcihlLHQscixuKXt2YXIgbz1lLnNoYXBlSW5mby5sb2dpY2FsU2hhcGUubGVuZ3RoLGE9dC5sb2dpY2FsU2hhcGUubGVuZ3RoLGk9XCJpbnRcIjsyPT09YT9pPVwiaXZlYzJcIjozPT09YT9pPVwiaXZlYzNcIjo0PT09YSYmKGk9XCJpdmVjNFwiKTt2YXIgcz1nZXRCcm9hZGNhc3REaW1zKGUuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSx0LmxvZ2ljYWxTaGFwZSksdT1hLW87cmV0dXJuXCJcXG4gICAgZmxvYXQgXCIrbitcIigpIHtcXG4gICAgICBcIitpK1wiIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgIFwiKygwPT09bz9cIlwiOmE8MiYmcy5sZW5ndGg+PTE/XCJjb29yZHMgPSAwO1wiOnMubWFwKGZ1bmN0aW9uKGUpe3JldHVyblwiY29vcmRzW1wiKyhlK3UpK1wiXSA9IDA7XCJ9KS5qb2luKFwiXFxuXCIpKStcIlxcbiAgICAgIHJldHVybiBnZXRcIityK1wiKFwiKyhhPDImJm8+MD9cImNvb3Jkc1wiOmUuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZS5tYXAoZnVuY3Rpb24oZSx0KXtyZXR1cm5cImNvb3Jkc1tcIisodCt1KStcIl1cIn0pLmpvaW4oXCIsIFwiKSkrXCIpO1xcbiAgICB9XFxuICBcIn1mdW5jdGlvbiBnZXRTYW1wbGVyQXRPdXRwdXRDb29yZHMoZSx0LHIpe3ZhciBuPWUubmFtZSxvPW4uY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrbi5zbGljZSgxKSxhPVwiZ2V0XCIrbytcIkF0T3V0Q29vcmRzXCIsaT1nZXRCcm9hZGNhc3REaW1zKGUuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSx0LmxvZ2ljYWxTaGFwZSkscz1lLnNoYXBlSW5mby5sb2dpY2FsU2hhcGUubGVuZ3RoLHU9dC5sb2dpY2FsU2hhcGUubGVuZ3RoLGw9ciYmKHU+c3x8aS5sZW5ndGg+MCksYz1icm9hZGNhc3REaW1zQXJlT3V0ZXIoaSkscD1lLnNoYXBlSW5mby5pc1VuaWZvcm07aWYobCYmIWMpcmV0dXJuIGdldEJyb2FkY2FzdE91dHB1dENvb3Jkc1NhbXBsZXIoZSx0LG8sYSk7dmFyIGQ9c2l6ZUZyb21TaGFwZShlLnNoYXBlSW5mby5sb2dpY2FsU2hhcGUpLGg9XCJcIjtsJiZjJiYoaD1cIlxcbiAgICAgICAgaW50IG1haW5QYXJ0ID0gaW5kZXggLyBcIitkK1wiO1xcbiAgICAgICAgaW5kZXggLT0gbWFpblBhcnQgKiBcIitkK1wiO1xcbiAgICAgIFwiKTt2YXIgZj10LnRleFNoYXBlO2lmKHApcmV0dXJuIDE9PT1kP1wiZmxvYXQgXCIrYStcIigpIHtyZXR1cm4gXCIrbitcIjt9XCI6XCJcXG4gICAgICBmbG9hdCBcIithK1wiKCkge1xcbiAgICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMihcIitmWzBdK1wiLCBcIitmWzFdK1wiKSk7XFxuICAgICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogXCIrZlsxXStcIiArIHJlc1RleFJDLnk7XFxuICAgICAgICBcIitoK1wiXFxuICAgICAgICByZXR1cm4gZ2V0XCIrbytcIkZsYXQoaW5kZXgpO1xcbiAgICAgIH1cXG4gICAgXCI7dmFyIG09ZS5zaGFwZUluZm8udGV4U2hhcGU7cmV0dXJuIGFycmF5c0VxdWFsKG0sZik/XCJcXG4gICAgICBmbG9hdCBcIithK1wiKCkge1xcbiAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrbitcIiwgcmVzdWx0VVYpO1xcbiAgICAgIH1cXG4gICAgXCI6XCJcXG4gICAgZmxvYXQgXCIrYStcIigpIHtcXG4gICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoXCIrZlswXStcIiwgXCIrZlsxXStcIikpO1xcbiAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnggKiBcIitmWzFdK1wiICsgcmVzVGV4UkMueTtcXG4gICAgICBcIitoK1wiXFxuICAgICAgaW50IHRleFIgPSBpbmRleCAvIFwiK21bMV0rXCI7XFxuICAgICAgaW50IHRleEMgPSBpbmRleCAtIHRleFIgKiBcIittWzFdK1wiO1xcbiAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgL1xcbiAgICAgICAgICAgICAgICAgdmVjMihcIittWzFdK1wiLjAsIFwiK21bMF0rXCIuMCk7XFxuXFxuICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrbitcIiwgdXYpO1xcbiAgICB9XFxuICBcIn1mdW5jdGlvbiBnZXRDb29yZHNEYXRhVHlwZShlKXtpZihlPD0xKXJldHVyblwiaW50XCI7aWYoMj09PWUpcmV0dXJuXCJpdmVjMlwiO2lmKDM9PT1lKXJldHVyblwiaXZlYzNcIjtpZig0PT09ZSlyZXR1cm5cIml2ZWM0XCI7aWYoNT09PWUpcmV0dXJuXCJpdmVjNVwiO2lmKDY9PT1lKXJldHVyblwiaXZlYzZcIjt0aHJvdyBFcnJvcihcIkdQVSBmb3IgcmFuayBcIitlK1wiIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpfWZ1bmN0aW9uIHNxdWVlemVJbnB1dEluZm8oZSx0KXt2YXIgcj1KU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGUpKTtyZXR1cm4gci5zaGFwZUluZm8ubG9naWNhbFNoYXBlPXQscn1mdW5jdGlvbiBnZXRTcXVlZXplZFBhcmFtcyhlLHQpe3JldHVybiB0Lm1hcChmdW5jdGlvbih0KXtyZXR1cm4gZVt0XX0pLmpvaW4oXCIsIFwiKX12YXIgQ3VtU3VtUHJvZ3JhbT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihlLHQscil7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIl0sdGhpcy5vdXRwdXRTaGFwZT1lO3ZhciBuPWUubGVuZ3RoLG89ZVtlLmxlbmd0aC0xXSxhPXI/XCI8XCI6XCI+XCI7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGludCBnZXRJbmRleChpbnQgaSkge1xcbiAgICAgICAgXCIrKHI/XCJyZXR1cm4gXCIrbytcIiAtaSAtIDE7XCI6XCJyZXR1cm4gaTtcIikrXCJcXG4gICAgICB9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgXCIrZ2V0Q29vcmRzRGF0YVR5cGUobikrXCIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgZW5kID0gXCIrZ2V0RmluYWxDb29yZChuLFwiY29vcmRzXCIpK1wiO1xcbiAgICAgICAgZmxvYXQgdmFsID0gMC4wO1xcbiAgICAgICAgZm9yIChpbnQgaSA9IFwiK28rXCIgLSAxOyBpID49IDA7IGkgLT0gMSkge1xcbiAgICAgICAgICBpbnQgaWR4ID0gZ2V0SW5kZXgoaSk7XFxuICAgICAgICAgIGlmIChpZHggXCIrYStcIiBlbmQpIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpZiAoaWR4ID09IGVuZCAmJiBcIit0K1wiKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgXCIrZ2V0RmluYWxDb29yZChuLFwiY29vcmRzXCIpK1wiID0gaWR4O1xcbiAgICAgICAgICB2YWwgKz0gZ2V0WChcIitnZXRDb29yZHMobixcImNvb3Jkc1wiKStcIik7XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQodmFsKTtcXG4gICAgICB9XFxuICAgIFwifX0oKTtmdW5jdGlvbiBnZXRDb29yZHMoZSx0KXtpZigxPT09ZSlyZXR1cm5cIlwiK3Q7aWYoMj09PWUpcmV0dXJuIHQrXCIueCwgXCIrdCtcIi55XCI7aWYoMz09PWUpcmV0dXJuIHQrXCIueCwgXCIrdCtcIi55LCBcIit0K1wiLnpcIjtpZig0PT09ZSlyZXR1cm4gdCtcIi54LCBcIit0K1wiLnksIFwiK3QrXCIueiwgXCIrdCtcIi53XCI7dGhyb3cgRXJyb3IoXCJDdW11bGF0aXZlIHN1bSBmb3IgcmFuayBcIitlK1wiIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpfWZ1bmN0aW9uIGdldEZpbmFsQ29vcmQoZSx0KXtpZigxPT09ZSlyZXR1cm5cIlwiK3Q7aWYoMj09PWUpcmV0dXJuIHQrXCIueVwiO2lmKDM9PT1lKXJldHVybiB0K1wiLnpcIjtpZig0PT09ZSlyZXR1cm4gdCtcIi53XCI7dGhyb3cgRXJyb3IoXCJDdW11bGF0aXZlIHN1bSBmb3IgcmFuayBcIitlK1wiIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpfXZhciBEZXB0aFRvU3BhY2VQcm9ncmFtPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQscil7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIl0sdGhpcy5vdXRwdXRTaGFwZT1bXSx0aGlzLm91dHB1dFNoYXBlPWUsdGhpcy5ibG9ja1NpemU9dCx0aGlzLmRhdGFGb3JtYXQ9cix0aGlzLnVzZXJDb2RlPVwiXFxuICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICBpbnQgYiA9IGNvb3Jkc1swXTtcXG4gICAgICBpbnQgaCA9IFwiK3RoaXMuZ2V0SGVpZ2h0Q29vcmRTdHJpbmcoKStcIjtcXG4gICAgICBpbnQgdyA9IFwiK3RoaXMuZ2V0V2lkdGhDb29yZFN0cmluZygpK1wiO1xcbiAgICAgIGludCBkID0gXCIrdGhpcy5nZXREZXB0aENvb3JkU3RyaW5nKCkrXCI7XFxuXFxuICAgICAgaW50IGluX2ggPSBoIC8gXCIrdCtcIjtcXG4gICAgICBpbnQgb2Zmc2V0X2ggPSBpbW9kKGgsIFwiK3QrXCIpO1xcbiAgICAgIGludCBpbl93ID0gdyAvIFwiK3QrXCI7XFxuICAgICAgaW50IG9mZnNldF93ID0gaW1vZCh3LCBcIit0K1wiKTtcXG4gICAgICBpbnQgb2Zmc2V0X2QgPSAob2Zmc2V0X2ggKiBcIit0K1wiICsgb2Zmc2V0X3cpICpcXG4gICAgICAgIFwiK3RoaXMuZ2V0T3V0cHV0RGVwdGhTaXplKCkrXCI7XFxuICAgICAgaW50IGluX2QgPSBkICsgb2Zmc2V0X2Q7XFxuXFxuICAgICAgZmxvYXQgcmVzdWx0ID0gXCIrdGhpcy5nZXRJbnB1dFNhbXBsaW5nU3RyaW5nKCkrXCI7XFxuICAgICAgc2V0T3V0cHV0KHJlc3VsdCk7XFxuICAgIH1cXG4gIFwifXJldHVybiBlLnByb3RvdHlwZS5nZXRIZWlnaHRDb29yZFN0cmluZz1mdW5jdGlvbigpe3JldHVyblwiTkhXQ1wiPT09dGhpcy5kYXRhRm9ybWF0P1wiY29vcmRzWzFdXCI6XCJjb29yZHNbMl1cIn0sZS5wcm90b3R5cGUuZ2V0V2lkdGhDb29yZFN0cmluZz1mdW5jdGlvbigpe3JldHVyblwiTkhXQ1wiPT09dGhpcy5kYXRhRm9ybWF0P1wiY29vcmRzWzJdXCI6XCJjb29yZHNbM11cIn0sZS5wcm90b3R5cGUuZ2V0RGVwdGhDb29yZFN0cmluZz1mdW5jdGlvbigpe3JldHVyblwiTkhXQ1wiPT09dGhpcy5kYXRhRm9ybWF0P1wiY29vcmRzWzNdXCI6XCJjb29yZHNbMV1cIn0sZS5wcm90b3R5cGUuZ2V0T3V0cHV0RGVwdGhTaXplPWZ1bmN0aW9uKCl7cmV0dXJuXCJOSFdDXCI9PT10aGlzLmRhdGFGb3JtYXQ/dGhpcy5vdXRwdXRTaGFwZVszXTp0aGlzLm91dHB1dFNoYXBlWzFdfSxlLnByb3RvdHlwZS5nZXRJbnB1dFNhbXBsaW5nU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCJOSFdDXCI9PT10aGlzLmRhdGFGb3JtYXQ/XCJnZXRYKGIsIGluX2gsIGluX3csIGluX2QpXCI6XCJnZXRYKGIsIGluX2QsIGluX2gsIGluX3cpXCJ9LGV9KCksRW5jb2RlRmxvYXRQcm9ncmFtPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKGUpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdLHRoaXMub3V0cHV0U2hhcGU9ZSx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgY29uc3QgZmxvYXQgRkxPQVRfTUFYID0gMS43MDE0MTE4NGUzODtcXG4gICAgICBjb25zdCBmbG9hdCBGTE9BVF9NSU4gPSAxLjE3NTQ5NDM1ZS0zODtcXG5cXG4gICAgICBsb3dwIHZlYzQgZW5jb2RlX2Zsb2F0KGhpZ2hwIGZsb2F0IHYpIHtcXG4gICAgICAgIGlmIChpc05hTih2KSkge1xcbiAgICAgICAgICByZXR1cm4gdmVjNCgyNTUsIDI1NSwgMjU1LCAyNTUpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaGlnaHAgZmxvYXQgYXYgPSBhYnModik7XFxuXFxuICAgICAgICBpZihhdiA8IEZMT0FUX01JTikge1xcbiAgICAgICAgICByZXR1cm4gdmVjNCgwLjAsIDAuMCwgMC4wLCAwLjApO1xcbiAgICAgICAgfSBlbHNlIGlmKHYgPiBGTE9BVF9NQVgpIHtcXG4gICAgICAgICAgcmV0dXJuIHZlYzQoMC4wLCAwLjAsIDEyOC4wLCAxMjcuMCkgLyAyNTUuMDtcXG4gICAgICAgIH0gZWxzZSBpZih2IDwgLUZMT0FUX01BWCkge1xcbiAgICAgICAgICByZXR1cm4gdmVjNCgwLjAsIDAuMCwgIDEyOC4wLCAyNTUuMCkgLyAyNTUuMDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGhpZ2hwIHZlYzQgYyA9IHZlYzQoMCwwLDAsMCk7XFxuXFxuICAgICAgICBoaWdocCBmbG9hdCBlID0gZmxvb3IobG9nMihhdikpO1xcbiAgICAgICAgaGlnaHAgZmxvYXQgbSA9IGV4cDIoZnJhY3QobG9nMihhdikpKSAtIDEuMDtcXG5cXG4gICAgICAgIGNbMl0gPSBmbG9vcigxMjguMCAqIG0pO1xcbiAgICAgICAgbSAtPSBjWzJdIC8gMTI4LjA7XFxuICAgICAgICBjWzFdID0gZmxvb3IoMzI3NjguMCAqIG0pO1xcbiAgICAgICAgbSAtPSBjWzFdIC8gMzI3NjguMDtcXG4gICAgICAgIGNbMF0gPSBmbG9vcig4Mzg4NjA4LjAgKiBtKTtcXG5cXG4gICAgICAgIGhpZ2hwIGZsb2F0IGViaWFzID0gZSArIDEyNy4wO1xcbiAgICAgICAgY1szXSA9IGZsb29yKGViaWFzIC8gMi4wKTtcXG4gICAgICAgIGViaWFzIC09IGNbM10gKiAyLjA7XFxuICAgICAgICBjWzJdICs9IGZsb29yKGViaWFzKSAqIDEyOC4wO1xcblxcbiAgICAgICAgY1szXSArPSAxMjguMCAqIHN0ZXAoMC4wLCAtdik7XFxuXFxuICAgICAgICByZXR1cm4gYyAvIDI1NS4wO1xcbiAgICAgIH1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBmbG9hdCB4ID0gZ2V0QUF0T3V0Q29vcmRzKCk7XFxuICAgICAgICBnbF9GcmFnQ29sb3IgPSBlbmNvZGVfZmxvYXQoeCk7XFxuICAgICAgfVxcbiAgICBcIn19KCksQ09NUExFWF9GRlQ9e1JFQUw6XCJyZXR1cm4gcmVhbCAqIGV4cFIgLSBpbWFnICogZXhwSTtcIixJTUFHOlwicmV0dXJuIHJlYWwgKiBleHBJICsgaW1hZyAqIGV4cFI7XCJ9LEZGVFByb2dyYW09ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oZSx0LHIpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJyZWFsXCIsXCJpbWFnXCJdO3ZhciBuPXRbMV07dGhpcy5vdXRwdXRTaGFwZT10O3ZhciBvPXI/XCIyLjAgKiBcIitNYXRoLlBJOlwiLTIuMCAqIFwiK01hdGguUEksYT1yP24rXCIuMFwiOlwiMS4wXCI7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGNvbnN0IGZsb2F0IGV4cG9uZW50TXVsdGlwbGllciA9IFwiK28rXCI7XFxuXFxuICAgICAgZmxvYXQgdW5hcnlPcENvbXBsZXgoZmxvYXQgcmVhbCwgZmxvYXQgZXhwUiwgZmxvYXQgaW1hZywgZmxvYXQgZXhwSSkge1xcbiAgICAgICAgXCIrZStcIlxcbiAgICAgIH1cXG5cXG4gICAgICBmbG9hdCBtdWxNYXRERlQoaW50IGJhdGNoLCBpbnQgaW5kZXgpIHtcXG4gICAgICAgIGZsb2F0IGluZGV4UmF0aW8gPSBmbG9hdChpbmRleCkgLyBmbG9hdChcIituK1wiKTtcXG4gICAgICAgIGZsb2F0IGV4cG9uZW50TXVsdGlwbGllclRpbWVzSW5kZXhSYXRpbyA9XFxuICAgICAgICAgICAgZXhwb25lbnRNdWx0aXBsaWVyICogaW5kZXhSYXRpbztcXG5cXG4gICAgICAgIGZsb2F0IHJlc3VsdCA9IDAuMDtcXG5cXG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgXCIrbitcIjsgaSsrKSB7XFxuICAgICAgICAgIC8vIHggPSAoLTJ8MiAqIFBJIC8gTikgKiBpbmRleCAqIGk7XFxuICAgICAgICAgIGZsb2F0IHggPSBleHBvbmVudE11bHRpcGxpZXJUaW1lc0luZGV4UmF0aW8gKiBmbG9hdChpKTtcXG4gICAgICAgICAgZmxvYXQgZXhwUiA9IGNvcyh4KTtcXG4gICAgICAgICAgZmxvYXQgZXhwSSA9IHNpbih4KTtcXG4gICAgICAgICAgZmxvYXQgcmVhbCA9IGdldFJlYWwoYmF0Y2gsIGkpO1xcbiAgICAgICAgICBmbG9hdCBpbWFnID0gZ2V0SW1hZyhiYXRjaCwgaSk7XFxuXFxuICAgICAgICAgIHJlc3VsdCArPVxcbiAgICAgICAgICAgICAgdW5hcnlPcENvbXBsZXgocmVhbCwgZXhwUiwgaW1hZywgZXhwSSkgLyBcIithK1wiO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgICB9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBzZXRPdXRwdXQobXVsTWF0REZUKGNvb3Jkc1swXSwgY29vcmRzWzFdKSk7XFxuICAgICAgfVxcbiAgICBcIn19KCksRnJvbVBpeGVsc1Byb2dyYW09ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oZSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl07dmFyIHQ9ZVswXSxyPWVbMV07dGhpcy5vdXRwdXRTaGFwZT1lLHRoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjMyBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCB0ZXhSID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IHRleEMgPSBjb29yZHNbMV07XFxuICAgICAgICBpbnQgZGVwdGggPSBjb29yZHNbMl07XFxuICAgICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC8gdmVjMihcIityK1wiLjAsIFwiK3QrXCIuMCk7XFxuXFxuICAgICAgICB2ZWM0IHZhbHVlcyA9IHRleHR1cmUyRChBLCB1dik7XFxuICAgICAgICBmbG9hdCB2YWx1ZTtcXG4gICAgICAgIGlmIChkZXB0aCA9PSAwKSB7XFxuICAgICAgICAgIHZhbHVlID0gdmFsdWVzLnI7XFxuICAgICAgICB9IGVsc2UgaWYgKGRlcHRoID09IDEpIHtcXG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZXMuZztcXG4gICAgICAgIH0gZWxzZSBpZiAoZGVwdGggPT0gMikge1xcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlcy5iO1xcbiAgICAgICAgfSBlbHNlIGlmIChkZXB0aCA9PSAzKSB7XFxuICAgICAgICAgIHZhbHVlID0gdmFsdWVzLmE7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBzZXRPdXRwdXQoZmxvb3IodmFsdWUgKiAyNTUuMCArIDAuNSkpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLEdhdGhlclByb2dyYW09ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oZSx0LHIpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCIsXCJpbmRpY2VzXCJdO3ZhciBuPWUuc2xpY2UoKTtuW3JdPXQsdGhpcy5vdXRwdXRTaGFwZT1uLHRoaXMucmFuaz1uLmxlbmd0aDt2YXIgbz1nZXRDb29yZHNEYXRhVHlwZSh0aGlzLnJhbmspLGE9Z2V0U291cmNlQ29vcmRzKGUscik7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIFwiK28rXCIgcmVzUkMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIHNldE91dHB1dChnZXRBKFwiK2ErXCIpKTtcXG4gICAgICB9XFxuICAgIFwifX0oKTtmdW5jdGlvbiBnZXRTb3VyY2VDb29yZHMoZSx0KXt2YXIgcj1lLmxlbmd0aDtpZihyPjQpdGhyb3cgRXJyb3IoXCJHYXRoZXIgZm9yIHJhbmsgXCIrcitcIiBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTtpZigxPT09cilyZXR1cm5cImludChnZXRJbmRpY2VzKHJlc1JDKSlcIjtmb3IodmFyIG49W1wicmVzUkMueFwiLFwicmVzUkMueVwiLFwicmVzUkMuelwiLFwicmVzUkMud1wiXSxvPVtdLGE9MDthPGUubGVuZ3RoO2ErKylhPT09dD9vLnB1c2goXCJpbnQoZ2V0SW5kaWNlcyhcIituW2FdK1wiKSlcIik6by5wdXNoKFwiXCIrblthXSk7cmV0dXJuIG8uam9pbigpfXZhciBUZXh0dXJlVXNhZ2UsUGh5c2ljYWxUZXh0dXJlVHlwZSxHYXRoZXJORFByb2dyYW09ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oZSx0LHIpe3RoaXMuc2xpY2VEaW09ZSx0aGlzLnN0cmlkZXM9dCx0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiLFwiaW5kaWNlc1wiXSx0aGlzLm91dHB1dFNoYXBlPXI7dmFyIG49Z2V0Q29vcmRzRGF0YVR5cGUodC5sZW5ndGgpLG89Z2V0Q29vcmRzRGF0YVR5cGUoci5sZW5ndGgpLGE9dGhpcy5zbGljZURpbT4xP1wic3RyaWRlc1tqXVwiOlwic3RyaWRlc1wiO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICAgIFwiK24rXCIgc3RyaWRlcyA9IFwiK24rXCIoXCIrdGhpcy5zdHJpZGVzK1wiKTtcXG4gICAgICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgIFwiK28rXCIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICAgIGludCBmbGF0dGVuSW5kZXggPSAwO1xcbiAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8IFwiK3RoaXMuc2xpY2VEaW0rXCI7IGorKykge1xcbiAgICAgICAgICAgIGludCBpbmRleCA9IHJvdW5kKGdldEluZGljZXMoY29vcmRzWzBdLCBqKSk7XFxuICAgICAgICAgICAgZmxhdHRlbkluZGV4ICs9IGluZGV4ICogXCIrYStcIjtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBzZXRPdXRwdXQoZ2V0WChmbGF0dGVuSW5kZXgsIGNvb3Jkc1sxXSkpO1xcbiAgICAgICAgfVxcbiAgICAgIFwifX0oKTtmdW5jdGlvbiBnZXRVbnBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KGUsdCl7cmV0dXJuW3QsZV19ZnVuY3Rpb24gZ2V0VW5wYWNrZWRBcnJheVNpemVGcm9tTWF0cml4U2l6ZShlLHQpe3JldHVybiBlKnR9ZnVuY3Rpb24gZ2V0TWF0cml4U2l6ZUZyb21VbnBhY2tlZEFycmF5U2l6ZShlLHQpe2lmKGUldCE9MCl0aHJvdyBuZXcgRXJyb3IoXCJ1bnBhY2tlZFNpemUgKFwiK2UrXCIpIG11c3QgYmUgYSBtdWx0aXBsZSBvZiBcIit0KTtyZXR1cm4gZS90fWZ1bmN0aW9uIGVuY29kZU1hdHJpeFRvVW5wYWNrZWRBcnJheShlLHQscil7dmFyIG49Z2V0VW5wYWNrZWRBcnJheVNpemVGcm9tTWF0cml4U2l6ZShlLmxlbmd0aCxyKTtpZih0Lmxlbmd0aDxuKXRocm93IG5ldyBFcnJvcihcInVucGFja2VkQXJyYXkgbGVuZ3RoIChcIit0Lmxlbmd0aCtcIikgbXVzdCBiZSA+PSBcIituKTtmb3IodmFyIG89MCxhPTA7YTxlLmxlbmd0aDsrK2EpdFtvXT1lW2FdLG8rPXJ9ZnVuY3Rpb24gZGVjb2RlTWF0cml4RnJvbVVucGFja2VkQXJyYXkoZSx0LHIpe3ZhciBuPWdldE1hdHJpeFNpemVGcm9tVW5wYWNrZWRBcnJheVNpemUoZS5sZW5ndGgscik7aWYodC5sZW5ndGg8bil0aHJvdyBuZXcgRXJyb3IoXCJtYXRyaXggbGVuZ3RoIChcIit0Lmxlbmd0aCtcIikgbXVzdCBiZSA+PSBcIituKTtmb3IodmFyIG89MCxhPTA7YTxlLmxlbmd0aDthKz1yKXRbbysrXT1lW2FdfWZ1bmN0aW9uIGdldFBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KGUsdCl7cmV0dXJuW01hdGguY2VpbCh0LzIpLE1hdGguY2VpbChlLzIpXX1mdW5jdGlvbiBnZXRQYWNrZWRSR0JBQXJyYXlTaXplRnJvbU1hdHJpeFNoYXBlKGUsdCl7dmFyIHI9Z2V0UGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQoZSx0KTtyZXR1cm4gclswXSpyWzFdKjR9ZnVuY3Rpb24gZW5jb2RlTWF0cml4VG9QYWNrZWRSR0JBKGUsdCxyLG4sbyl7dmFyIGE9Z2V0UGFja2VkUkdCQUFycmF5U2l6ZUZyb21NYXRyaXhTaGFwZShyLG4pO2lmKG8ubGVuZ3RoPGEpdGhyb3cgbmV3IEVycm9yKFwicGFja2VkUkdCQSBsZW5ndGggKFwiK28ubGVuZ3RoK1wiKSBtdXN0IGJlID49XFxuICAgICAgICBcIithKTtmb3IodmFyIGk9biUyPT0xLHM9ciUyPT0xLHU9TWF0aC5mbG9vcihuLzIpLGw9TWF0aC5mbG9vcihyLzIpLGM9TWF0aC5jZWlsKG4vMikscD1jKk1hdGguY2VpbChyLzIpLGQ9bmVhcmVzdExhcmdlckV2ZW4ocikqbmVhcmVzdExhcmdlckV2ZW4obiksaD0wO2g8dDtoKyspe2Zvcih2YXIgZj1oKnIqbixtPWgqZCxnPWk/NDowLHY9bix5PW0seD0wO3g8bDsrK3gpe2Zvcih2YXIgVD0yKngqbixFPTA7RTx1OysrRSl7dmFyIHc9ZitUKzIqRTtvW3ldPWVbd10sb1t5KzFdPWVbdysxXSxvW3krMl09ZVt3K3ZdLG9beSszXT1lW3crdisxXSx5Kz00fXkrPWd9aWYoaSl7dz1mK24tMSx5PW0rNCooYy0xKTt2YXIgUz0yKm47Zm9yKGc9NCpjLHg9MDt4PGw7Kyt4KW9beV09ZVt3XSxvW3krMl09ZVt3K25dLHcrPVMseSs9Z31pZihzKXtmb3Iodz1mKyhyLTEpKm4seT1tKzQqKHAtYyksRT0wO0U8dTsrK0Upb1t5KytdPWVbdysrXSxvW3krK109ZVt3KytdLHkrPTI7aSYmcyYmKG9bbStkLTRdPWVbd10pfX1yZXR1cm4gb31mdW5jdGlvbiBkZWNvZGVNYXRyaXhGcm9tUGFja2VkUkdCQShlLHQscixuLG8pe3ZhciBhPXIqbjtpZihvLmxlbmd0aDxhKXRocm93IG5ldyBFcnJvcihcIm1hdHJpeCBsZW5ndGggKFwiK28ubGVuZ3RoK1wiKSBtdXN0IGJlID49IFwiK2EpO2Zvcih2YXIgaT1uJTI9PTEscz1yJTI9PTEsdT1NYXRoLmZsb29yKG4vMiksbD1NYXRoLmZsb29yKHIvMiksYz1NYXRoLmNlaWwobi8yKSxwPWMqTWF0aC5jZWlsKHIvMiksZD1uZWFyZXN0TGFyZ2VyRXZlbihyKSpuZWFyZXN0TGFyZ2VyRXZlbihuKSxoPTA7aDx0O2grKyl7Zm9yKHZhciBmPWgqcipuLG09aCpkLGc9aT80OjAsdj1uKyhpPzE6MCkseT1tLHg9ZixUPWYrbixFPTA7RTxsOysrRSl7Zm9yKHZhciB3PTA7dzx1OysrdylvW3grK109ZVt5KytdLG9beCsrXT1lW3krK10sb1tUKytdPWVbeSsrXSxvW1QrK109ZVt5KytdO3krPWcseCs9dixUKz12fWlmKGkpe3k9bSs0KihjLTEpO3ZhciBTPWYrbi0xO2ZvcihnPTQqYyx2PTIqbixFPTA7RTxsOysrRSlvW1NdPWVbeV0sb1tTK25dPWVbeSsyXSx5Kz1nLFMrPXZ9aWYocyl7Zm9yKHk9bSs0KihwLWMpLFM9Zisoci0xKSpuLHc9MDt3PHU7Kyt3KW9bUysrXT1lW3krK10sb1tTKytdPWVbeSsrXSx5Kz0yO2kmJihvW2YrcipuLTFdPWVbeV0pfX1yZXR1cm4gb31mdW5jdGlvbiBjYWxsQW5kQ2hlY2soZSx0KXt2YXIgcj10KCk7cmV0dXJuIGNoZWNrV2ViR0xFcnJvcihlKSxyfSFmdW5jdGlvbihlKXtlW2UuUkVOREVSPTBdPVwiUkVOREVSXCIsZVtlLlVQTE9BRD0xXT1cIlVQTE9BRFwiLGVbZS5QSVhFTFM9Ml09XCJQSVhFTFNcIixlW2UuRE9XTkxPQUQ9M109XCJET1dOTE9BRFwifShUZXh0dXJlVXNhZ2V8fChUZXh0dXJlVXNhZ2U9e30pKSxmdW5jdGlvbihlKXtlW2UuVU5QQUNLRURfRkxPQVQxNj0wXT1cIlVOUEFDS0VEX0ZMT0FUMTZcIixlW2UuVU5QQUNLRURfRkxPQVQzMj0xXT1cIlVOUEFDS0VEX0ZMT0FUMzJcIixlW2UuUEFDS0VEXzRYMV9VTlNJR05FRF9CWVRFPTJdPVwiUEFDS0VEXzRYMV9VTlNJR05FRF9CWVRFXCIsZVtlLlBBQ0tFRF8yWDJfRkxPQVQzMj0zXT1cIlBBQ0tFRF8yWDJfRkxPQVQzMlwiLGVbZS5QQUNLRURfMlgyX0ZMT0FUMTY9NF09XCJQQUNLRURfMlgyX0ZMT0FUMTZcIn0oUGh5c2ljYWxUZXh0dXJlVHlwZXx8KFBoeXNpY2FsVGV4dHVyZVR5cGU9e30pKTt2YXIgd2ViR0xEZWJ1Z0Vycm9yQ2hlY2tpbmdFbmFibGVkPSExO2Z1bmN0aW9uIGVuYWJsZURlYnVnV2ViR0xFcnJvckNoZWNraW5nKGUpe3dlYkdMRGVidWdFcnJvckNoZWNraW5nRW5hYmxlZD1lfWZ1bmN0aW9uIGNoZWNrV2ViR0xFcnJvcihlKXtpZih3ZWJHTERlYnVnRXJyb3JDaGVja2luZ0VuYWJsZWQpe3ZhciB0PWUuZ2V0RXJyb3IoKTtpZih0IT09ZS5OT19FUlJPUil0aHJvdyBuZXcgRXJyb3IoXCJXZWJHTCBFcnJvcjogXCIrZ2V0V2ViR0xFcnJvck1lc3NhZ2UoZSx0KSl9fWZ1bmN0aW9uIGdldFdlYkdMRXJyb3JNZXNzYWdlKGUsdCl7c3dpdGNoKHQpe2Nhc2UgZS5OT19FUlJPUjpyZXR1cm5cIk5PX0VSUk9SXCI7Y2FzZSBlLklOVkFMSURfRU5VTTpyZXR1cm5cIklOVkFMSURfRU5VTVwiO2Nhc2UgZS5JTlZBTElEX1ZBTFVFOnJldHVyblwiSU5WQUxJRF9WQUxVRVwiO2Nhc2UgZS5JTlZBTElEX09QRVJBVElPTjpyZXR1cm5cIklOVkFMSURfT1BFUkFUSU9OXCI7Y2FzZSBlLklOVkFMSURfRlJBTUVCVUZGRVJfT1BFUkFUSU9OOnJldHVyblwiSU5WQUxJRF9GUkFNRUJVRkZFUl9PUEVSQVRJT05cIjtjYXNlIGUuT1VUX09GX01FTU9SWTpyZXR1cm5cIk9VVF9PRl9NRU1PUllcIjtjYXNlIGUuQ09OVEVYVF9MT1NUX1dFQkdMOnJldHVyblwiQ09OVEVYVF9MT1NUX1dFQkdMXCI7ZGVmYXVsdDpyZXR1cm5cIlVua25vd24gZXJyb3IgY29kZSBcIit0fX1mdW5jdGlvbiBnZXRFeHRlbnNpb25PclRocm93KGUsdCl7cmV0dXJuIHRocm93SWZOdWxsKGUsZnVuY3Rpb24oKXtyZXR1cm4gZS5nZXRFeHRlbnNpb24odCl9LCdFeHRlbnNpb24gXCInK3QrJ1wiIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBicm93c2VyLicpfWZ1bmN0aW9uIGNyZWF0ZVZlcnRleFNoYWRlcihlLHQpe3ZhciByPXRocm93SWZOdWxsKGUsZnVuY3Rpb24oKXtyZXR1cm4gZS5jcmVhdGVTaGFkZXIoZS5WRVJURVhfU0hBREVSKX0sXCJVbmFibGUgdG8gY3JlYXRlIHZlcnRleCBXZWJHTFNoYWRlci5cIik7aWYoY2FsbEFuZENoZWNrKGUsZnVuY3Rpb24oKXtyZXR1cm4gZS5zaGFkZXJTb3VyY2Uocix0KX0pLGNhbGxBbmRDaGVjayhlLGZ1bmN0aW9uKCl7cmV0dXJuIGUuY29tcGlsZVNoYWRlcihyKX0pLCExPT09ZS5nZXRTaGFkZXJQYXJhbWV0ZXIocixlLkNPTVBJTEVfU1RBVFVTKSl0aHJvdyBjb25zb2xlLmxvZyhlLmdldFNoYWRlckluZm9Mb2cocikpLG5ldyBFcnJvcihcIkZhaWxlZCB0byBjb21waWxlIHZlcnRleCBzaGFkZXIuXCIpO3JldHVybiByfWZ1bmN0aW9uIGNyZWF0ZUZyYWdtZW50U2hhZGVyKGUsdCl7dmFyIHI9dGhyb3dJZk51bGwoZSxmdW5jdGlvbigpe3JldHVybiBlLmNyZWF0ZVNoYWRlcihlLkZSQUdNRU5UX1NIQURFUil9LFwiVW5hYmxlIHRvIGNyZWF0ZSBmcmFnbWVudCBXZWJHTFNoYWRlci5cIik7aWYoY2FsbEFuZENoZWNrKGUsZnVuY3Rpb24oKXtyZXR1cm4gZS5zaGFkZXJTb3VyY2Uocix0KX0pLGNhbGxBbmRDaGVjayhlLGZ1bmN0aW9uKCl7cmV0dXJuIGUuY29tcGlsZVNoYWRlcihyKX0pLCExPT09ZS5nZXRTaGFkZXJQYXJhbWV0ZXIocixlLkNPTVBJTEVfU1RBVFVTKSl0aHJvdyBsb2dTaGFkZXJTb3VyY2VBbmRJbmZvTG9nKHQsZS5nZXRTaGFkZXJJbmZvTG9nKHIpKSxuZXcgRXJyb3IoXCJGYWlsZWQgdG8gY29tcGlsZSBmcmFnbWVudCBzaGFkZXIuXCIpO3JldHVybiByfXZhciBsaW5lTnVtYmVyUmVnZXg9L0VSUk9SOiBbMC05XSs6KFswLTldKyk6L2c7ZnVuY3Rpb24gbG9nU2hhZGVyU291cmNlQW5kSW5mb0xvZyhlLHQpe3ZhciByPWxpbmVOdW1iZXJSZWdleC5leGVjKHQpO2lmKG51bGw9PXIpcmV0dXJuIGNvbnNvbGUubG9nKFwiQ291bGRuJ3QgcGFyc2UgbGluZSBudW1iZXIgaW4gZXJyb3I6IFwiK3QpLHZvaWQgY29uc29sZS5sb2coZSk7Zm9yKHZhciBuPStyWzFdLG89ZS5zcGxpdChcIlxcblwiKSxhPW8ubGVuZ3RoLnRvU3RyaW5nKCkubGVuZ3RoKzIsaT1vLm1hcChmdW5jdGlvbihlLHQpe3JldHVybiByaWdodFBhZCgodCsxKS50b1N0cmluZygpLGEpK2V9KSxzPTAsdT0wO3U8aS5sZW5ndGg7dSsrKXM9TWF0aC5tYXgoaVt1XS5sZW5ndGgscyk7dmFyIGw9aS5zbGljZSgwLG4tMSksYz1pLnNsaWNlKG4tMSxuKSxwPWkuc2xpY2Uobik7Y29uc29sZS5sb2cobC5qb2luKFwiXFxuXCIpKSxjb25zb2xlLmxvZyh0LnNwbGl0KFwiXFxuXCIpWzBdKSxjb25zb2xlLmxvZyhcIiVjIFwiK3JpZ2h0UGFkKGNbMF0scyksXCJib3JkZXI6MXB4IHNvbGlkIHJlZDsgYmFja2dyb3VuZC1jb2xvcjojZTNkMmQyOyBjb2xvcjojYTYxNzE3XCIpLGNvbnNvbGUubG9nKHAuam9pbihcIlxcblwiKSl9ZnVuY3Rpb24gY3JlYXRlUHJvZ3JhbShlKXtyZXR1cm4gdGhyb3dJZk51bGwoZSxmdW5jdGlvbigpe3JldHVybiBlLmNyZWF0ZVByb2dyYW0oKX0sXCJVbmFibGUgdG8gY3JlYXRlIFdlYkdMUHJvZ3JhbS5cIil9ZnVuY3Rpb24gbGlua1Byb2dyYW0oZSx0KXtpZihjYWxsQW5kQ2hlY2soZSxmdW5jdGlvbigpe3JldHVybiBlLmxpbmtQcm9ncmFtKHQpfSksITE9PT1lLmdldFByb2dyYW1QYXJhbWV0ZXIodCxlLkxJTktfU1RBVFVTKSl0aHJvdyBjb25zb2xlLmxvZyhlLmdldFByb2dyYW1JbmZvTG9nKHQpKSxuZXcgRXJyb3IoXCJGYWlsZWQgdG8gbGluayB2ZXJ0ZXggYW5kIGZyYWdtZW50IHNoYWRlcnMuXCIpfWZ1bmN0aW9uIHZhbGlkYXRlUHJvZ3JhbShlLHQpe2lmKGNhbGxBbmRDaGVjayhlLGZ1bmN0aW9uKCl7cmV0dXJuIGUudmFsaWRhdGVQcm9ncmFtKHQpfSksITE9PT1lLmdldFByb2dyYW1QYXJhbWV0ZXIodCxlLlZBTElEQVRFX1NUQVRVUykpdGhyb3cgY29uc29sZS5sb2coZS5nZXRQcm9ncmFtSW5mb0xvZyh0KSksbmV3IEVycm9yKFwiU2hhZGVyIHByb2dyYW0gdmFsaWRhdGlvbiBmYWlsZWQuXCIpfWZ1bmN0aW9uIGNyZWF0ZVN0YXRpY1ZlcnRleEJ1ZmZlcihlLHQpe3ZhciByPXRocm93SWZOdWxsKGUsZnVuY3Rpb24oKXtyZXR1cm4gZS5jcmVhdGVCdWZmZXIoKX0sXCJVbmFibGUgdG8gY3JlYXRlIFdlYkdMQnVmZmVyXCIpO3JldHVybiBjYWxsQW5kQ2hlY2soZSxmdW5jdGlvbigpe3JldHVybiBlLmJpbmRCdWZmZXIoZS5BUlJBWV9CVUZGRVIscil9KSxjYWxsQW5kQ2hlY2soZSxmdW5jdGlvbigpe3JldHVybiBlLmJ1ZmZlckRhdGEoZS5BUlJBWV9CVUZGRVIsdCxlLlNUQVRJQ19EUkFXKX0pLHJ9ZnVuY3Rpb24gY3JlYXRlU3RhdGljSW5kZXhCdWZmZXIoZSx0KXt2YXIgcj10aHJvd0lmTnVsbChlLGZ1bmN0aW9uKCl7cmV0dXJuIGUuY3JlYXRlQnVmZmVyKCl9LFwiVW5hYmxlIHRvIGNyZWF0ZSBXZWJHTEJ1ZmZlclwiKTtyZXR1cm4gY2FsbEFuZENoZWNrKGUsZnVuY3Rpb24oKXtyZXR1cm4gZS5iaW5kQnVmZmVyKGUuRUxFTUVOVF9BUlJBWV9CVUZGRVIscil9KSxjYWxsQW5kQ2hlY2soZSxmdW5jdGlvbigpe3JldHVybiBlLmJ1ZmZlckRhdGEoZS5FTEVNRU5UX0FSUkFZX0JVRkZFUix0LGUuU1RBVElDX0RSQVcpfSkscn1mdW5jdGlvbiBnZXROdW1DaGFubmVscygpe3JldHVybiAyPT09RU5WLmdldChcIldFQkdMX1ZFUlNJT05cIik/MTo0fWZ1bmN0aW9uIGNyZWF0ZVRleHR1cmUoZSl7cmV0dXJuIHRocm93SWZOdWxsKGUsZnVuY3Rpb24oKXtyZXR1cm4gZS5jcmVhdGVUZXh0dXJlKCl9LFwiVW5hYmxlIHRvIGNyZWF0ZSBXZWJHTFRleHR1cmUuXCIpfWZ1bmN0aW9uIHZhbGlkYXRlVGV4dHVyZVNpemUoZSx0KXt2YXIgcj1FTlYuZ2V0KFwiV0VCR0xfTUFYX1RFWFRVUkVfU0laRVwiKTtpZihlPD0wfHx0PD0wKXt2YXIgbj1cIltcIitlK1wieFwiK3QrXCJdXCI7dGhyb3cgbmV3IEVycm9yKFwiUmVxdWVzdGVkIHRleHR1cmUgc2l6ZSBcIituK1wiIGlzIGludmFsaWQuXCIpfWlmKGU+cnx8dD5yKXtuPVwiW1wiK2UrXCJ4XCIrdCtcIl1cIjt0aHJvdyBuZXcgRXJyb3IoXCJSZXF1ZXN0ZWQgdGV4dHVyZSBzaXplIFwiK24rXCIgZ3JlYXRlciB0aGFuIFdlYkdMIG1heGltdW0gb24gdGhpcyBicm93c2VyIC8gR1BVIFwiKyhcIltcIityK1wieFwiK3IrXCJdXCIpK1wiLlwiKX19ZnVuY3Rpb24gY3JlYXRlRnJhbWVidWZmZXIoZSl7cmV0dXJuIHRocm93SWZOdWxsKGUsZnVuY3Rpb24oKXtyZXR1cm4gZS5jcmVhdGVGcmFtZWJ1ZmZlcigpfSxcIlVuYWJsZSB0byBjcmVhdGUgV2ViR0xGcmFtZWJ1ZmZlci5cIil9ZnVuY3Rpb24gYmluZFZlcnRleEJ1ZmZlclRvUHJvZ3JhbUF0dHJpYnV0ZShlLHQscixuLG8sYSxpKXt2YXIgcz1lLmdldEF0dHJpYkxvY2F0aW9uKHQscik7cmV0dXJuLTEhPT1zJiYoY2FsbEFuZENoZWNrKGUsZnVuY3Rpb24oKXtyZXR1cm4gZS5iaW5kQnVmZmVyKGUuQVJSQVlfQlVGRkVSLG4pfSksY2FsbEFuZENoZWNrKGUsZnVuY3Rpb24oKXtyZXR1cm4gZS52ZXJ0ZXhBdHRyaWJQb2ludGVyKHMsbyxlLkZMT0FULCExLGEsaSl9KSxjYWxsQW5kQ2hlY2soZSxmdW5jdGlvbigpe3JldHVybiBlLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHMpfSksITApfWZ1bmN0aW9uIGJpbmRUZXh0dXJlVW5pdChlLHQscil7dmFsaWRhdGVUZXh0dXJlVW5pdChlLHIpLGNhbGxBbmRDaGVjayhlLGZ1bmN0aW9uKCl7cmV0dXJuIGUuYWN0aXZlVGV4dHVyZShlLlRFWFRVUkUwK3IpfSksY2FsbEFuZENoZWNrKGUsZnVuY3Rpb24oKXtyZXR1cm4gZS5iaW5kVGV4dHVyZShlLlRFWFRVUkVfMkQsdCl9KX1mdW5jdGlvbiB1bmJpbmRUZXh0dXJlVW5pdChlLHQpe3ZhbGlkYXRlVGV4dHVyZVVuaXQoZSx0KSxjYWxsQW5kQ2hlY2soZSxmdW5jdGlvbigpe3JldHVybiBlLmFjdGl2ZVRleHR1cmUoZS5URVhUVVJFMCt0KX0pLGNhbGxBbmRDaGVjayhlLGZ1bmN0aW9uKCl7cmV0dXJuIGUuYmluZFRleHR1cmUoZS5URVhUVVJFXzJELG51bGwpfSl9ZnVuY3Rpb24gZ2V0UHJvZ3JhbVVuaWZvcm1Mb2NhdGlvbk9yVGhyb3coZSx0LHIpe3JldHVybiB0aHJvd0lmTnVsbChlLGZ1bmN0aW9uKCl7cmV0dXJuIGUuZ2V0VW5pZm9ybUxvY2F0aW9uKHQscil9LCd1bmlmb3JtIFwiJytyKydcIiBub3QgcHJlc2VudCBpbiBwcm9ncmFtLicpfWZ1bmN0aW9uIGdldFByb2dyYW1Vbmlmb3JtTG9jYXRpb24oZSx0LHIpe3JldHVybiBlLmdldFVuaWZvcm1Mb2NhdGlvbih0LHIpfWZ1bmN0aW9uIGJpbmRUZXh0dXJlVG9Qcm9ncmFtVW5pZm9ybVNhbXBsZXIoZSx0LHIsbixvKXtjYWxsQW5kQ2hlY2soZSxmdW5jdGlvbigpe3JldHVybiBiaW5kVGV4dHVyZVVuaXQoZSxyLG8pfSksY2FsbEFuZENoZWNrKGUsZnVuY3Rpb24oKXtyZXR1cm4gZS51bmlmb3JtMWkobixvKX0pfWZ1bmN0aW9uIGJpbmRDYW52YXNUb0ZyYW1lYnVmZmVyKGUpe2NhbGxBbmRDaGVjayhlLGZ1bmN0aW9uKCl7cmV0dXJuIGUuYmluZEZyYW1lYnVmZmVyKGUuRlJBTUVCVUZGRVIsbnVsbCl9KSxjYWxsQW5kQ2hlY2soZSxmdW5jdGlvbigpe3JldHVybiBlLnZpZXdwb3J0KDAsMCxlLmNhbnZhcy53aWR0aCxlLmNhbnZhcy5oZWlnaHQpfSksY2FsbEFuZENoZWNrKGUsZnVuY3Rpb24oKXtyZXR1cm4gZS5zY2lzc29yKDAsMCxlLmNhbnZhcy53aWR0aCxlLmNhbnZhcy5oZWlnaHQpfSl9ZnVuY3Rpb24gYmluZENvbG9yVGV4dHVyZVRvRnJhbWVidWZmZXIoZSx0LHIpe2NhbGxBbmRDaGVjayhlLGZ1bmN0aW9uKCl7cmV0dXJuIGUuYmluZEZyYW1lYnVmZmVyKGUuRlJBTUVCVUZGRVIscil9KSxjYWxsQW5kQ2hlY2soZSxmdW5jdGlvbigpe3JldHVybiBlLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGUuRlJBTUVCVUZGRVIsZS5DT0xPUl9BVFRBQ0hNRU5UMCxlLlRFWFRVUkVfMkQsdCwwKX0pfWZ1bmN0aW9uIHVuYmluZENvbG9yVGV4dHVyZUZyb21GcmFtZWJ1ZmZlcihlLHQpe2NhbGxBbmRDaGVjayhlLGZ1bmN0aW9uKCl7cmV0dXJuIGUuYmluZEZyYW1lYnVmZmVyKGUuRlJBTUVCVUZGRVIsdCl9KSxjYWxsQW5kQ2hlY2soZSxmdW5jdGlvbigpe3JldHVybiBlLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGUuRlJBTUVCVUZGRVIsZS5DT0xPUl9BVFRBQ0hNRU5UMCxlLlRFWFRVUkVfMkQsbnVsbCwwKX0pfWZ1bmN0aW9uIHZhbGlkYXRlRnJhbWVidWZmZXIoZSl7dmFyIHQ9ZS5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKGUuRlJBTUVCVUZGRVIpO2lmKHQhPT1lLkZSQU1FQlVGRkVSX0NPTVBMRVRFKXRocm93IG5ldyBFcnJvcihcIkVycm9yIGJpbmRpbmcgZnJhbWVidWZmZXI6IFwiK2dldEZyYW1lYnVmZmVyRXJyb3JNZXNzYWdlKGUsdCkpfWZ1bmN0aW9uIGdldEZyYW1lYnVmZmVyRXJyb3JNZXNzYWdlKGUsdCl7c3dpdGNoKHQpe2Nhc2UgZS5GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0FUVEFDSE1FTlQ6cmV0dXJuXCJGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0FUVEFDSE1FTlRcIjtjYXNlIGUuRlJBTUVCVUZGRVJfSU5DT01QTEVURV9NSVNTSU5HX0FUVEFDSE1FTlQ6cmV0dXJuXCJGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX01JU1NJTkdfQVRUQUNITUVOVFwiO2Nhc2UgZS5GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0RJTUVOU0lPTlM6cmV0dXJuXCJGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0RJTUVOU0lPTlNcIjtjYXNlIGUuRlJBTUVCVUZGRVJfVU5TVVBQT1JURUQ6cmV0dXJuXCJGUkFNRUJVRkZFUl9VTlNVUFBPUlRFRFwiO2RlZmF1bHQ6cmV0dXJuXCJ1bmtub3duIGVycm9yIFwiK3R9fWZ1bmN0aW9uIHRocm93SWZOdWxsKGUsdCxyKXt2YXIgbj1jYWxsQW5kQ2hlY2soZSxmdW5jdGlvbigpe3JldHVybiB0KCl9KTtpZihudWxsPT1uKXRocm93IG5ldyBFcnJvcihyKTtyZXR1cm4gbn1mdW5jdGlvbiB2YWxpZGF0ZVRleHR1cmVVbml0KGUsdCl7dmFyIHI9ZS5NQVhfQ09NQklORURfVEVYVFVSRV9JTUFHRV9VTklUUy0xLG49dCtlLlRFWFRVUkUwO2lmKG48ZS5URVhUVVJFMHx8bj5yKXRocm93IG5ldyBFcnJvcihcInRleHR1cmVVbml0IG11c3QgYmUgaW4gXCIrKFwiW2dsLlRFWFRVUkUwLCBnbC5URVhUVVJFXCIrcitcIl1cIikrXCIuXCIpfWZ1bmN0aW9uIGdldFRleHR1cmVTaGFwZUZyb21Mb2dpY2FsU2hhcGUoZSx0KXt2b2lkIDA9PT10JiYodD0hMSk7dmFyIHI9RU5WLmdldChcIldFQkdMX01BWF9URVhUVVJFX1NJWkVcIik7aWYodCYmKHIqPTIsZT1lLm1hcChmdW5jdGlvbih0LHIpe3JldHVybiByPj1lLmxlbmd0aC0yP25lYXJlc3RMYXJnZXJFdmVuKGVbcl0pOmVbcl19KSksMiE9PWUubGVuZ3RoKXt2YXIgbj1zcXVlZXplU2hhcGUoZSk7ZT1uLm5ld1NoYXBlfXZhciBvPXNpemVGcm9tU2hhcGUoZSk7cmV0dXJuIGUubGVuZ3RoPD0xJiZvPD1yP1tvLDFdOjI9PT1lLmxlbmd0aCYmZVswXTw9ciYmZVsxXTw9cj9lOjM9PT1lLmxlbmd0aCYmZVswXSplWzFdPD1yJiZlWzJdPD1yP1tlWzBdKmVbMV0sZVsyXV06Mz09PWUubGVuZ3RoJiZlWzBdPD1yJiZlWzFdKmVbMl08PXI/W2VbMF0sZVsxXSplWzJdXTo0PT09ZS5sZW5ndGgmJmVbMF0qZVsxXSplWzJdPD1yJiZlWzNdPD1yP1tlWzBdKmVbMV0qZVsyXSxlWzNdXTo0PT09ZS5sZW5ndGgmJmVbMF08PXImJmVbMV0qZVsyXSplWzNdPD1yP1tlWzBdLGVbMV0qZVsyXSplWzNdXTpzaXplVG9TcXVhcmlzaFNoYXBlKG8pfWZ1bmN0aW9uIGlzRXZlbihlKXtyZXR1cm4gZSUyPT0wfWZ1bmN0aW9uIGlzUmVzaGFwZUZyZWUoZSx0KXtpZihhcnJheXNFcXVhbChlPWUuc2xpY2UoLTIpLHQ9dC5zbGljZSgtMikpKXJldHVybiEwO2lmKCFlLmxlbmd0aHx8IXQubGVuZ3RoKXJldHVybiEwO2lmKDA9PT1lWzBdfHwwPT09ZVsxXXx8MD09PXRbMF18fDA9PT10WzFdKXJldHVybiEwO2lmKGUubGVuZ3RoIT09dC5sZW5ndGgpe2lmKGFycmF5c0VxdWFsKHNxdWVlemVTaGFwZShlKS5uZXdTaGFwZSxzcXVlZXplU2hhcGUodCkubmV3U2hhcGUpKXJldHVybiEwfWVsc2UgaWYoaXNFdmVuKGVbMF0pJiZpc0V2ZW4odFswXSkpe2lmKGlzRXZlbihlWzFdKSYmaXNFdmVuKHRbMV0pKXJldHVybiEwO2lmKGVbMV09PT10WzFdKXJldHVybiEwfXJldHVybiExfXZhciB3ZWJnbF91dGlsPU9iamVjdC5mcmVlemUoe2NhbGxBbmRDaGVjazpjYWxsQW5kQ2hlY2ssZW5hYmxlRGVidWdXZWJHTEVycm9yQ2hlY2tpbmc6ZW5hYmxlRGVidWdXZWJHTEVycm9yQ2hlY2tpbmcsY2hlY2tXZWJHTEVycm9yOmNoZWNrV2ViR0xFcnJvcixnZXRXZWJHTEVycm9yTWVzc2FnZTpnZXRXZWJHTEVycm9yTWVzc2FnZSxnZXRFeHRlbnNpb25PclRocm93OmdldEV4dGVuc2lvbk9yVGhyb3csY3JlYXRlVmVydGV4U2hhZGVyOmNyZWF0ZVZlcnRleFNoYWRlcixjcmVhdGVGcmFnbWVudFNoYWRlcjpjcmVhdGVGcmFnbWVudFNoYWRlcixjcmVhdGVQcm9ncmFtOmNyZWF0ZVByb2dyYW0sbGlua1Byb2dyYW06bGlua1Byb2dyYW0sdmFsaWRhdGVQcm9ncmFtOnZhbGlkYXRlUHJvZ3JhbSxjcmVhdGVTdGF0aWNWZXJ0ZXhCdWZmZXI6Y3JlYXRlU3RhdGljVmVydGV4QnVmZmVyLGNyZWF0ZVN0YXRpY0luZGV4QnVmZmVyOmNyZWF0ZVN0YXRpY0luZGV4QnVmZmVyLGdldE51bUNoYW5uZWxzOmdldE51bUNoYW5uZWxzLGNyZWF0ZVRleHR1cmU6Y3JlYXRlVGV4dHVyZSx2YWxpZGF0ZVRleHR1cmVTaXplOnZhbGlkYXRlVGV4dHVyZVNpemUsY3JlYXRlRnJhbWVidWZmZXI6Y3JlYXRlRnJhbWVidWZmZXIsYmluZFZlcnRleEJ1ZmZlclRvUHJvZ3JhbUF0dHJpYnV0ZTpiaW5kVmVydGV4QnVmZmVyVG9Qcm9ncmFtQXR0cmlidXRlLGJpbmRUZXh0dXJlVW5pdDpiaW5kVGV4dHVyZVVuaXQsdW5iaW5kVGV4dHVyZVVuaXQ6dW5iaW5kVGV4dHVyZVVuaXQsZ2V0UHJvZ3JhbVVuaWZvcm1Mb2NhdGlvbk9yVGhyb3c6Z2V0UHJvZ3JhbVVuaWZvcm1Mb2NhdGlvbk9yVGhyb3csZ2V0UHJvZ3JhbVVuaWZvcm1Mb2NhdGlvbjpnZXRQcm9ncmFtVW5pZm9ybUxvY2F0aW9uLGJpbmRUZXh0dXJlVG9Qcm9ncmFtVW5pZm9ybVNhbXBsZXI6YmluZFRleHR1cmVUb1Byb2dyYW1Vbmlmb3JtU2FtcGxlcixiaW5kQ2FudmFzVG9GcmFtZWJ1ZmZlcjpiaW5kQ2FudmFzVG9GcmFtZWJ1ZmZlcixiaW5kQ29sb3JUZXh0dXJlVG9GcmFtZWJ1ZmZlcjpiaW5kQ29sb3JUZXh0dXJlVG9GcmFtZWJ1ZmZlcix1bmJpbmRDb2xvclRleHR1cmVGcm9tRnJhbWVidWZmZXI6dW5iaW5kQ29sb3JUZXh0dXJlRnJvbUZyYW1lYnVmZmVyLHZhbGlkYXRlRnJhbWVidWZmZXI6dmFsaWRhdGVGcmFtZWJ1ZmZlcixnZXRGcmFtZWJ1ZmZlckVycm9yTWVzc2FnZTpnZXRGcmFtZWJ1ZmZlckVycm9yTWVzc2FnZSxnZXRUZXh0dXJlU2hhcGVGcm9tTG9naWNhbFNoYXBlOmdldFRleHR1cmVTaGFwZUZyb21Mb2dpY2FsU2hhcGUsaXNSZXNoYXBlRnJlZTppc1Jlc2hhcGVGcmVlfSk7ZnVuY3Rpb24gY3JlYXRlVmVydGV4U2hhZGVyJDEoZSl7cmV0dXJuIGNyZWF0ZVZlcnRleFNoYWRlcihlLFwiXFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4gICAgYXR0cmlidXRlIHZlYzMgY2xpcFNwYWNlUG9zO1xcbiAgICBhdHRyaWJ1dGUgdmVjMiB1djtcXG4gICAgdmFyeWluZyB2ZWMyIHJlc3VsdFVWO1xcblxcbiAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KGNsaXBTcGFjZVBvcywgMSk7XFxuICAgICAgcmVzdWx0VVYgPSB1djtcXG4gICAgfVwiKX1mdW5jdGlvbiBjcmVhdGVWZXJ0ZXhCdWZmZXIoZSl7cmV0dXJuIGNyZWF0ZVN0YXRpY1ZlcnRleEJ1ZmZlcihlLG5ldyBGbG9hdDMyQXJyYXkoWy0xLDEsMCwwLDEsLTEsLTEsMCwwLDAsMSwxLDAsMSwxLDEsLTEsMCwxLDBdKSl9ZnVuY3Rpb24gY3JlYXRlSW5kZXhCdWZmZXIoZSl7cmV0dXJuIGNyZWF0ZVN0YXRpY0luZGV4QnVmZmVyKGUsbmV3IFVpbnQxNkFycmF5KFswLDEsMiwyLDEsM10pKX1mdW5jdGlvbiBnZXRUZXh0dXJlQ29uZmlnKGUsdCl7dmFyIHIsbixvLGEsaSxzLHUsbD1lO3JldHVybiAyPT09RU5WLmdldChcIldFQkdMX1ZFUlNJT05cIik/KHI9bC5SMzJGLG49bC5SMTZGLG89bC5SR0JBMzJGLGE9bC5SRUQsaT00LHM9MSx1PWwuSEFMRl9GTE9BVCk6KHI9ZS5SR0JBLG49ZS5SR0JBLG89bC5SR0JBLGE9ZS5SR0JBLGk9NCxzPTQsdT1udWxsIT10P3QuSEFMRl9GTE9BVF9PRVM6bnVsbCkse2ludGVybmFsRm9ybWF0RmxvYXQ6cixpbnRlcm5hbEZvcm1hdEhhbGZGbG9hdDpuLGludGVybmFsRm9ybWF0UGFja2VkRmxvYXQ6byx0ZXh0dXJlRm9ybWF0RmxvYXQ6YSxkb3dubG9hZFRleHR1cmVGb3JtYXQ6ZS5SR0JBLGRvd25sb2FkVW5wYWNrTnVtQ2hhbm5lbHM6aSxkZWZhdWx0TnVtQ2hhbm5lbHM6cyx0ZXh0dXJlVHlwZUhhbGZGbG9hdDp1fX1mdW5jdGlvbiBjcmVhdGVBbmRDb25maWd1cmVUZXh0dXJlKGUsdCxyLG4sbyxhKXt2YWxpZGF0ZVRleHR1cmVTaXplKHQscik7dmFyIGk9Y3JlYXRlVGV4dHVyZShlKSxzPWUuVEVYVFVSRV8yRDtyZXR1cm4gY2FsbEFuZENoZWNrKGUsZnVuY3Rpb24oKXtyZXR1cm4gZS5iaW5kVGV4dHVyZShzLGkpfSksY2FsbEFuZENoZWNrKGUsZnVuY3Rpb24oKXtyZXR1cm4gZS50ZXhQYXJhbWV0ZXJpKHMsZS5URVhUVVJFX1dSQVBfUyxlLkNMQU1QX1RPX0VER0UpfSksY2FsbEFuZENoZWNrKGUsZnVuY3Rpb24oKXtyZXR1cm4gZS50ZXhQYXJhbWV0ZXJpKHMsZS5URVhUVVJFX1dSQVBfVCxlLkNMQU1QX1RPX0VER0UpfSksY2FsbEFuZENoZWNrKGUsZnVuY3Rpb24oKXtyZXR1cm4gZS50ZXhQYXJhbWV0ZXJpKHMsZS5URVhUVVJFX01JTl9GSUxURVIsZS5ORUFSRVNUKX0pLGNhbGxBbmRDaGVjayhlLGZ1bmN0aW9uKCl7cmV0dXJuIGUudGV4UGFyYW1ldGVyaShzLGUuVEVYVFVSRV9NQUdfRklMVEVSLGUuTkVBUkVTVCl9KSxjYWxsQW5kQ2hlY2soZSxmdW5jdGlvbigpe3JldHVybiBlLnRleEltYWdlMkQocywwLG4sdCxyLDAsbyxhLG51bGwpfSksY2FsbEFuZENoZWNrKGUsZnVuY3Rpb24oKXtyZXR1cm4gZS5iaW5kVGV4dHVyZShlLlRFWFRVUkVfMkQsbnVsbCl9KSxpfWZ1bmN0aW9uIGNyZWF0ZUZsb2F0MzJNYXRyaXhUZXh0dXJlKGUsdCxyLG4pe3ZhciBvPWdldFVucGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQodCxyKTtyZXR1cm4gY3JlYXRlQW5kQ29uZmlndXJlVGV4dHVyZShlLG9bMF0sb1sxXSxuLmludGVybmFsRm9ybWF0RmxvYXQsbi50ZXh0dXJlRm9ybWF0RmxvYXQsZS5GTE9BVCl9ZnVuY3Rpb24gY3JlYXRlRmxvYXQxNk1hdHJpeFRleHR1cmUoZSx0LHIsbil7dmFyIG89Z2V0VW5wYWNrZWRNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodCh0LHIpO3JldHVybiBjcmVhdGVBbmRDb25maWd1cmVUZXh0dXJlKGUsb1swXSxvWzFdLG4uaW50ZXJuYWxGb3JtYXRGbG9hdCxuLnRleHR1cmVGb3JtYXRGbG9hdCxuLnRleHR1cmVUeXBlSGFsZkZsb2F0KX1mdW5jdGlvbiBjcmVhdGVVbnNpZ25lZEJ5dGVzTWF0cml4VGV4dHVyZShlLHQscixuKXt2YXIgbz1nZXRVbnBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KHQscik7cmV0dXJuIGNyZWF0ZUFuZENvbmZpZ3VyZVRleHR1cmUoZSxvWzBdLG9bMV0sZS5SR0JBLGUuUkdCQSxlLlVOU0lHTkVEX0JZVEUpfWZ1bmN0aW9uIGNyZWF0ZVBhY2tlZE1hdHJpeFRleHR1cmUoZSx0LHIsbil7dmFyIG89Z2V0UGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQodCxyKTtyZXR1cm4gY3JlYXRlQW5kQ29uZmlndXJlVGV4dHVyZShlLG9bMF0sb1sxXSxuLmludGVybmFsRm9ybWF0UGFja2VkRmxvYXQsZS5SR0JBLGUuRkxPQVQpfWZ1bmN0aW9uIGNyZWF0ZUZsb2F0MTZQYWNrZWRNYXRyaXhUZXh0dXJlKGUsdCxyLG4pe3ZhciBvPWdldFBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KHQscik7cmV0dXJuIGNyZWF0ZUFuZENvbmZpZ3VyZVRleHR1cmUoZSxvWzBdLG9bMV0sbi5pbnRlcm5hbEZvcm1hdEhhbGZGbG9hdCxlLlJHQkEsbi50ZXh0dXJlVHlwZUhhbGZGbG9hdCl9ZnVuY3Rpb24gYmluZFZlcnRleFByb2dyYW1BdHRyaWJ1dGVTdHJlYW1zKGUsdCxyKXtyZXR1cm4gY2FsbEFuZENoZWNrKGUsZnVuY3Rpb24oKXtyZXR1cm4gZS5iaW5kQnVmZmVyKGUuQVJSQVlfQlVGRkVSLHIpfSksYmluZFZlcnRleEJ1ZmZlclRvUHJvZ3JhbUF0dHJpYnV0ZShlLHQsXCJjbGlwU3BhY2VQb3NcIixyLDMsMjAsMCkmJmJpbmRWZXJ0ZXhCdWZmZXJUb1Byb2dyYW1BdHRyaWJ1dGUoZSx0LFwidXZcIixyLDIsMjAsMTIpfWZ1bmN0aW9uIHVwbG9hZFBpeGVsRGF0YVRvVGV4dHVyZShlLHQscil7Y2FsbEFuZENoZWNrKGUsZnVuY3Rpb24oKXtyZXR1cm4gZS5iaW5kVGV4dHVyZShlLlRFWFRVUkVfMkQsdCl9KSxjYWxsQW5kQ2hlY2soZSxmdW5jdGlvbigpe3JldHVybiBlLnRleEltYWdlMkQoZS5URVhUVVJFXzJELDAsZS5SR0JBLGUuUkdCQSxlLlVOU0lHTkVEX0JZVEUscil9KSxjYWxsQW5kQ2hlY2soZSxmdW5jdGlvbigpe3JldHVybiBlLmJpbmRUZXh0dXJlKGUuVEVYVFVSRV8yRCxudWxsKX0pfWZ1bmN0aW9uIHVwbG9hZERhdGFUb1RleHR1cmUoZSx0LHIsbixvLGEpe3ZhbGlkYXRlVGV4dHVyZVNpemUocixuKSxjYWxsQW5kQ2hlY2soZSxmdW5jdGlvbigpe3JldHVybiBlLmJpbmRUZXh0dXJlKGUuVEVYVFVSRV8yRCx0KX0pLGNhbGxBbmRDaGVjayhlLGZ1bmN0aW9uKCl7cmV0dXJuIGUudGV4U3ViSW1hZ2UyRChlLlRFWFRVUkVfMkQsMCwwLDAscixuLGEsZS5GTE9BVCxvKX0pLGNhbGxBbmRDaGVjayhlLGZ1bmN0aW9uKCl7cmV0dXJuIGUuYmluZFRleHR1cmUoZS5URVhUVVJFXzJELG51bGwpfSl9ZnVuY3Rpb24gdXBsb2FkTWF0cml4VG9UZXh0dXJlKGUsdCxyLG4sbyxhLGkpe3ZhciBzLHU9Z2V0VW5wYWNrZWRNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodChyLG4pLGw9dVswXSxjPXVbMV07MT09PWkuZGVmYXVsdE51bUNoYW5uZWxzP3M9bzplbmNvZGVNYXRyaXhUb1VucGFja2VkQXJyYXkobyxzPW5ldyBGbG9hdDMyQXJyYXkoZ2V0VW5wYWNrZWRBcnJheVNpemVGcm9tTWF0cml4U2l6ZShvLmxlbmd0aCxhKSksYSksdXBsb2FkRGF0YVRvVGV4dHVyZShlLHQsbCxjLHMsaS50ZXh0dXJlRm9ybWF0RmxvYXQpfWZ1bmN0aW9uIHVwbG9hZE1hdHJpeFRvUGFja2VkVGV4dHVyZShlLHQscixuLG8sYSxpKXt2YXIgcz1nZXRQYWNrZWRNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodChuLG8pLHU9c1swXSxsPXNbMV0sYz1uZXcgRmxvYXQzMkFycmF5KGdldFBhY2tlZFJHQkFBcnJheVNpemVGcm9tTWF0cml4U2hhcGUobixvKSk7ZW5jb2RlTWF0cml4VG9QYWNrZWRSR0JBKGEscixuLG8sYyksdXBsb2FkRGF0YVRvVGV4dHVyZShlLHQsdSxsLGMsZS5SR0JBKX1mdW5jdGlvbiBtYXliZUNyZWF0ZUJ1ZmZlckZyb21PdXRwdXRUZXh0dXJlKGUsdCxyLG4sbyl7dmFyIGE9dDtpZigyPT09RU5WLmdldChcIldFQkdMX1ZFUlNJT05cIikpe3ZhciBpPWUscz1pLmNyZWF0ZUJ1ZmZlcigpO2NhbGxBbmRDaGVjayhlLGZ1bmN0aW9uKCl7cmV0dXJuIGUuYmluZEJ1ZmZlcihpLlBJWEVMX1BBQ0tfQlVGRkVSLHMpfSk7dmFyIHU9NCpnZXRVbnBhY2tlZEFycmF5U2l6ZUZyb21NYXRyaXhTaXplKHIqbixvLmRvd25sb2FkVW5wYWNrTnVtQ2hhbm5lbHMpO2NhbGxBbmRDaGVjayhlLGZ1bmN0aW9uKCl7cmV0dXJuIGUuYnVmZmVyRGF0YShpLlBJWEVMX1BBQ0tfQlVGRkVSLHUsZS5TVEFUSUNfRFJBVyl9KSxjYWxsQW5kQ2hlY2soZSxmdW5jdGlvbigpe3JldHVybiBpLnJlYWRQaXhlbHMoMCwwLG4scixlLlJHQkEsZS5GTE9BVCwwKX0pLGNhbGxBbmRDaGVjayhlLGZ1bmN0aW9uKCl7cmV0dXJuIGUuYmluZEJ1ZmZlcihpLlBJWEVMX1BBQ0tfQlVGRkVSLG51bGwpfSksYT1zfXJldHVybiBhfWZ1bmN0aW9uIGRvd25sb2FkRmxvYXQzMk1hdHJpeEZyb21CdWZmZXIoZSx0LHIsbixvKXt2YXIgYT1lLGk9bmV3IEZsb2F0MzJBcnJheShnZXRVbnBhY2tlZEFycmF5U2l6ZUZyb21NYXRyaXhTaXplKHIqbixvLmRvd25sb2FkVW5wYWNrTnVtQ2hhbm5lbHMpKTthLmJpbmRCdWZmZXIoZS5BUlJBWV9CVUZGRVIsdCksYS5nZXRCdWZmZXJTdWJEYXRhKGUuQVJSQVlfQlVGRkVSLDAsaSksYS5iaW5kQnVmZmVyKGUuQVJSQVlfQlVGRkVSLG51bGwpO3ZhciBzPW5ldyBGbG9hdDMyQXJyYXkocipuKTtyZXR1cm4gZGVjb2RlTWF0cml4RnJvbVVucGFja2VkQXJyYXkoaSxzLG8uZG93bmxvYWRVbnBhY2tOdW1DaGFubmVscyksc31mdW5jdGlvbiBkb3dubG9hZEZsb2F0MzJNYXRyaXhGcm9tT3V0cHV0VGV4dHVyZShlLHQscixuKXt2YXIgbz1nZXRVbnBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KHQsciksYT1vWzBdLGk9b1sxXSxzPW5ldyBGbG9hdDMyQXJyYXkoZ2V0VW5wYWNrZWRBcnJheVNpemVGcm9tTWF0cml4U2l6ZSh0KnIsbi5kb3dubG9hZFVucGFja051bUNoYW5uZWxzKSk7Y2FsbEFuZENoZWNrKGUsZnVuY3Rpb24oKXtyZXR1cm4gZS5yZWFkUGl4ZWxzKDAsMCxhLGksbi5kb3dubG9hZFRleHR1cmVGb3JtYXQsZS5GTE9BVCxzKX0pO3ZhciB1PW5ldyBGbG9hdDMyQXJyYXkodCpyKTtyZXR1cm4gZGVjb2RlTWF0cml4RnJvbVVucGFja2VkQXJyYXkocyx1LG4uZG93bmxvYWRVbnBhY2tOdW1DaGFubmVscyksdX1mdW5jdGlvbiBkb3dubG9hZEJ5dGVFbmNvZGVkRmxvYXRNYXRyaXhGcm9tT3V0cHV0VGV4dHVyZShlLHQscixuKXt2YXIgbz1nZXRVbnBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KHQsciksYT1vWzBdLGk9b1sxXSxzPW5ldyBVaW50OEFycmF5KGdldFVucGFja2VkQXJyYXlTaXplRnJvbU1hdHJpeFNpemUodCpyLDQpKTtyZXR1cm4gY2FsbEFuZENoZWNrKGUsZnVuY3Rpb24oKXtyZXR1cm4gZS5yZWFkUGl4ZWxzKDAsMCxhLGksbi5kb3dubG9hZFRleHR1cmVGb3JtYXQsZS5VTlNJR05FRF9CWVRFLHMpfSksbmV3IEZsb2F0MzJBcnJheShzLmJ1ZmZlcil9ZnVuY3Rpb24gZG93bmxvYWRNYXRyaXhGcm9tUGFja2VkT3V0cHV0VGV4dHVyZShlLHQscixuLG8sYSxpKXt2YXIgcz1nZXRQYWNrZWRNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodChvLGEpLHU9c1swXSxsPXNbMV0sYz1uZXcgRmxvYXQzMkFycmF5KGdldFBhY2tlZFJHQkFBcnJheVNpemVGcm9tTWF0cml4U2hhcGUobyxhKSk7Y2FsbEFuZENoZWNrKGUsZnVuY3Rpb24oKXtyZXR1cm4gZS5yZWFkUGl4ZWxzKDAsMCx1LGwsZS5SR0JBLGUuRkxPQVQsYyl9KTt2YXIgcD1uZXcgRmxvYXQzMkFycmF5KHNpemVGcm9tU2hhcGUoW3QscixuXSkpO3JldHVybiBkZWNvZGVNYXRyaXhGcm9tUGFja2VkUkdCQShjLHQscixuLHApfXZhciBncGdwdV91dGlsPU9iamVjdC5mcmVlemUoe2NyZWF0ZVZlcnRleFNoYWRlcjpjcmVhdGVWZXJ0ZXhTaGFkZXIkMSxjcmVhdGVWZXJ0ZXhCdWZmZXI6Y3JlYXRlVmVydGV4QnVmZmVyLGNyZWF0ZUluZGV4QnVmZmVyOmNyZWF0ZUluZGV4QnVmZmVyLGdldFRleHR1cmVDb25maWc6Z2V0VGV4dHVyZUNvbmZpZyxjcmVhdGVGbG9hdDMyTWF0cml4VGV4dHVyZTpjcmVhdGVGbG9hdDMyTWF0cml4VGV4dHVyZSxjcmVhdGVGbG9hdDE2TWF0cml4VGV4dHVyZTpjcmVhdGVGbG9hdDE2TWF0cml4VGV4dHVyZSxjcmVhdGVVbnNpZ25lZEJ5dGVzTWF0cml4VGV4dHVyZTpjcmVhdGVVbnNpZ25lZEJ5dGVzTWF0cml4VGV4dHVyZSxjcmVhdGVQYWNrZWRNYXRyaXhUZXh0dXJlOmNyZWF0ZVBhY2tlZE1hdHJpeFRleHR1cmUsY3JlYXRlRmxvYXQxNlBhY2tlZE1hdHJpeFRleHR1cmU6Y3JlYXRlRmxvYXQxNlBhY2tlZE1hdHJpeFRleHR1cmUsYmluZFZlcnRleFByb2dyYW1BdHRyaWJ1dGVTdHJlYW1zOmJpbmRWZXJ0ZXhQcm9ncmFtQXR0cmlidXRlU3RyZWFtcyx1cGxvYWRQaXhlbERhdGFUb1RleHR1cmU6dXBsb2FkUGl4ZWxEYXRhVG9UZXh0dXJlLHVwbG9hZE1hdHJpeFRvVGV4dHVyZTp1cGxvYWRNYXRyaXhUb1RleHR1cmUsdXBsb2FkTWF0cml4VG9QYWNrZWRUZXh0dXJlOnVwbG9hZE1hdHJpeFRvUGFja2VkVGV4dHVyZSxtYXliZUNyZWF0ZUJ1ZmZlckZyb21PdXRwdXRUZXh0dXJlOm1heWJlQ3JlYXRlQnVmZmVyRnJvbU91dHB1dFRleHR1cmUsZG93bmxvYWRGbG9hdDMyTWF0cml4RnJvbUJ1ZmZlcjpkb3dubG9hZEZsb2F0MzJNYXRyaXhGcm9tQnVmZmVyLGRvd25sb2FkRmxvYXQzMk1hdHJpeEZyb21PdXRwdXRUZXh0dXJlOmRvd25sb2FkRmxvYXQzMk1hdHJpeEZyb21PdXRwdXRUZXh0dXJlLGRvd25sb2FkQnl0ZUVuY29kZWRGbG9hdE1hdHJpeEZyb21PdXRwdXRUZXh0dXJlOmRvd25sb2FkQnl0ZUVuY29kZWRGbG9hdE1hdHJpeEZyb21PdXRwdXRUZXh0dXJlLGRvd25sb2FkTWF0cml4RnJvbVBhY2tlZE91dHB1dFRleHR1cmU6ZG93bmxvYWRNYXRyaXhGcm9tUGFja2VkT3V0cHV0VGV4dHVyZX0pLEdQR1BVQ29udGV4dD1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSl7dGhpcy5vdXRwdXRUZXh0dXJlPW51bGwsdGhpcy5wcm9ncmFtPW51bGwsdGhpcy5kaXNwb3NlZD0hMSx0aGlzLmF1dG9EZWJ1Z1ZhbGlkYXRlPSExLHRoaXMudmVydGV4QXR0cnNBcmVCb3VuZD0hMSx0aGlzLml0ZW1zVG9Qb2xsPVtdLHRoaXMuZ2w9bnVsbCE9ZT9lOmdldFdlYkdMQ29udGV4dChFTlYuZ2V0KFwiV0VCR0xfVkVSU0lPTlwiKSksMT09PUVOVi5nZXQoXCJXRUJHTF9WRVJTSU9OXCIpPyh0aGlzLnRleHR1cmVGbG9hdEV4dGVuc2lvbj1nZXRFeHRlbnNpb25PclRocm93KHRoaXMuZ2wsXCJPRVNfdGV4dHVyZV9mbG9hdFwiKSx0aGlzLmNvbG9yQnVmZmVyRmxvYXRFeHRlbnNpb249dGhpcy5nbC5nZXRFeHRlbnNpb24oXCJXRUJHTF9jb2xvcl9idWZmZXJfZmxvYXRcIiksRU5WLmdldChcIldFQkdMX1JFTkRFUl9GTE9BVDMyX0VOQUJMRURcIil8fCh0aGlzLnRleHR1cmVIYWxmRmxvYXRFeHRlbnNpb249Z2V0RXh0ZW5zaW9uT3JUaHJvdyh0aGlzLmdsLFwiT0VTX3RleHR1cmVfaGFsZl9mbG9hdFwiKSx0aGlzLmNvbG9yQnVmZmVySGFsZkZsb2F0RXh0ZW5zaW9uPXRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKFwiRVhUX2NvbG9yX2J1ZmZlcl9oYWxmX2Zsb2F0XCIpKSk6dGhpcy5jb2xvckJ1ZmZlckZsb2F0RXh0ZW5zaW9uPWdldEV4dGVuc2lvbk9yVGhyb3codGhpcy5nbCxcIkVYVF9jb2xvcl9idWZmZXJfZmxvYXRcIiksdGhpcy52ZXJ0ZXhCdWZmZXI9Y3JlYXRlVmVydGV4QnVmZmVyKHRoaXMuZ2wpLHRoaXMuaW5kZXhCdWZmZXI9Y3JlYXRlSW5kZXhCdWZmZXIodGhpcy5nbCksdGhpcy5mcmFtZWJ1ZmZlcj1jcmVhdGVGcmFtZWJ1ZmZlcih0aGlzLmdsKSx0aGlzLnRleHR1cmVDb25maWc9Z2V0VGV4dHVyZUNvbmZpZyh0aGlzLmdsLHRoaXMudGV4dHVyZUhhbGZGbG9hdEV4dGVuc2lvbil9cmV0dXJuIGUucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt2YXIgZT10aGlzO2lmKCF0aGlzLmRpc3Bvc2VkKXtudWxsIT10aGlzLnByb2dyYW0mJmNvbnNvbGUud2FybihcIkRpc3Bvc2luZyBhIEdQR1BVQ29udGV4dCB0aGF0IHN0aWxsIGhhcyBhIGJvdW5kIFdlYkdMUHJvZ3JhbS4gVGhpcyBpcyBwcm9iYWJseSBhIHJlc291cmNlIGxlYWssIGRlbGV0ZSB0aGUgcHJvZ3JhbSB3aXRoIEdQR1BVQ29udGV4dC5kZWxldGVQcm9ncmFtIGJlZm9yZSBkaXNwb3NpbmcuXCIpLG51bGwhPXRoaXMub3V0cHV0VGV4dHVyZSYmY29uc29sZS53YXJuKFwiRGlzcG9zaW5nIGEgR1BHUFVDb250ZXh0IHRoYXQgc3RpbGwgaGFzIGEgYm91bmQgb3V0cHV0IG1hdHJpeCB0ZXh0dXJlLiAgVGhpcyBpcyBwcm9iYWJseSBhIHJlc291cmNlIGxlYWssIGRlbGV0ZSB0aGUgb3V0cHV0IG1hdHJpeCB0ZXh0dXJlIHdpdGggR1BHUFVDb250ZXh0LmRlbGV0ZU1hdHJpeFRleHR1cmUgYmVmb3JlIGRpc3Bvc2luZy5cIik7dmFyIHQ9dGhpcy5nbDtjYWxsQW5kQ2hlY2sodCxmdW5jdGlvbigpe3JldHVybiB0LmZpbmlzaCgpfSksY2FsbEFuZENoZWNrKHQsZnVuY3Rpb24oKXtyZXR1cm4gdC5iaW5kRnJhbWVidWZmZXIodC5GUkFNRUJVRkZFUixudWxsKX0pLGNhbGxBbmRDaGVjayh0LGZ1bmN0aW9uKCl7cmV0dXJuIHQuZGVsZXRlRnJhbWVidWZmZXIoZS5mcmFtZWJ1ZmZlcil9KSxjYWxsQW5kQ2hlY2sodCxmdW5jdGlvbigpe3JldHVybiB0LmJpbmRCdWZmZXIodC5BUlJBWV9CVUZGRVIsbnVsbCl9KSxjYWxsQW5kQ2hlY2sodCxmdW5jdGlvbigpe3JldHVybiB0LmJpbmRCdWZmZXIodC5FTEVNRU5UX0FSUkFZX0JVRkZFUixudWxsKX0pLGNhbGxBbmRDaGVjayh0LGZ1bmN0aW9uKCl7cmV0dXJuIHQuZGVsZXRlQnVmZmVyKGUuaW5kZXhCdWZmZXIpfSksdGhpcy5kaXNwb3NlZD0hMH19LGUucHJvdG90eXBlLmVuYWJsZUF1dG9tYXRpY0RlYnVnVmFsaWRhdGlvbj1mdW5jdGlvbihlKXt0aGlzLmF1dG9EZWJ1Z1ZhbGlkYXRlPWUsZW5hYmxlRGVidWdXZWJHTEVycm9yQ2hlY2tpbmcoZSl9LGUucHJvdG90eXBlLmNyZWF0ZUZsb2F0MzJNYXRyaXhUZXh0dXJlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksY3JlYXRlRmxvYXQzMk1hdHJpeFRleHR1cmUodGhpcy5nbCxlLHQsdGhpcy50ZXh0dXJlQ29uZmlnKX0sZS5wcm90b3R5cGUuY3JlYXRlRmxvYXQxNk1hdHJpeFRleHR1cmU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxjcmVhdGVGbG9hdDE2TWF0cml4VGV4dHVyZSh0aGlzLmdsLGUsdCx0aGlzLnRleHR1cmVDb25maWcpfSxlLnByb3RvdHlwZS5jcmVhdGVVbnNpZ25lZEJ5dGVzTWF0cml4VGV4dHVyZT1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGNyZWF0ZVVuc2lnbmVkQnl0ZXNNYXRyaXhUZXh0dXJlKHRoaXMuZ2wsZSx0LHRoaXMudGV4dHVyZUNvbmZpZyl9LGUucHJvdG90eXBlLnVwbG9hZFBpeGVsRGF0YVRvVGV4dHVyZT1mdW5jdGlvbihlLHQpe3RoaXMudGhyb3dJZkRpc3Bvc2VkKCksdXBsb2FkUGl4ZWxEYXRhVG9UZXh0dXJlKHRoaXMuZ2wsZSx0KX0sZS5wcm90b3R5cGUuY3JlYXRlRmxvYXQxNlBhY2tlZE1hdHJpeFRleHR1cmU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxjcmVhdGVGbG9hdDE2UGFja2VkTWF0cml4VGV4dHVyZSh0aGlzLmdsLGUsdCx0aGlzLnRleHR1cmVDb25maWcpfSxlLnByb3RvdHlwZS5jcmVhdGVQYWNrZWRNYXRyaXhUZXh0dXJlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksY3JlYXRlUGFja2VkTWF0cml4VGV4dHVyZSh0aGlzLmdsLGUsdCx0aGlzLnRleHR1cmVDb25maWcpfSxlLnByb3RvdHlwZS5kZWxldGVNYXRyaXhUZXh0dXJlPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7dGhpcy50aHJvd0lmRGlzcG9zZWQoKSx0aGlzLm91dHB1dFRleHR1cmU9PT1lJiYodW5iaW5kQ29sb3JUZXh0dXJlRnJvbUZyYW1lYnVmZmVyKHRoaXMuZ2wsdGhpcy5mcmFtZWJ1ZmZlciksdGhpcy5vdXRwdXRUZXh0dXJlPW51bGwpLGNhbGxBbmRDaGVjayh0aGlzLmdsLGZ1bmN0aW9uKCl7cmV0dXJuIHQuZ2wuZGVsZXRlVGV4dHVyZShlKX0pfSxlLnByb3RvdHlwZS51cGxvYWRNYXRyaXhUb1RleHR1cmU9ZnVuY3Rpb24oZSx0LHIsbil7dGhpcy50aHJvd0lmRGlzcG9zZWQoKTt2YXIgbz1nZXROdW1DaGFubmVscygpO3JldHVybiB1cGxvYWRNYXRyaXhUb1RleHR1cmUodGhpcy5nbCxlLHQscixuLG8sdGhpcy50ZXh0dXJlQ29uZmlnKX0sZS5wcm90b3R5cGUudXBsb2FkTWF0cml4VG9QYWNrZWRUZXh0dXJlPWZ1bmN0aW9uKGUsdCxyLG4sbyl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksdXBsb2FkTWF0cml4VG9QYWNrZWRUZXh0dXJlKHRoaXMuZ2wsZSx0LHIsbixvLHRoaXMudGV4dHVyZUNvbmZpZyl9LGUucHJvdG90eXBlLmRvd25sb2FkRmxvYXQzMk1hdHJpeEZyb21PdXRwdXRUZXh0dXJlPWZ1bmN0aW9uKGUsdCxyKXt2YXIgbj10aGlzO3JldHVybiB0aGlzLmRvd25sb2FkTWF0cml4RHJpdmVyKGUsZnVuY3Rpb24oKXtyZXR1cm4gZG93bmxvYWRGbG9hdDMyTWF0cml4RnJvbU91dHB1dFRleHR1cmUobi5nbCx0LHIsbi50ZXh0dXJlQ29uZmlnKX0pfSxlLnByb3RvdHlwZS5kb3dubG9hZEJ5dGVFbmNvZGVkRmxvYXRNYXRyaXhGcm9tT3V0cHV0VGV4dHVyZT1mdW5jdGlvbihlLHQscil7dmFyIG49dGhpcztyZXR1cm4gdGhpcy5kb3dubG9hZE1hdHJpeERyaXZlcihlLGZ1bmN0aW9uKCl7cmV0dXJuIGRvd25sb2FkQnl0ZUVuY29kZWRGbG9hdE1hdHJpeEZyb21PdXRwdXRUZXh0dXJlKG4uZ2wsdCxyLG4udGV4dHVyZUNvbmZpZyl9KX0sZS5wcm90b3R5cGUuZG93bmxvYWRGbG9hdDMyTWF0cml4RnJvbUJ1ZmZlcj1mdW5jdGlvbihlLHQscil7cmV0dXJuIGRvd25sb2FkRmxvYXQzMk1hdHJpeEZyb21CdWZmZXIodGhpcy5nbCxlLHQscix0aGlzLnRleHR1cmVDb25maWcpfSxlLnByb3RvdHlwZS5tYXliZUNyZWF0ZUJ1ZmZlckZyb21UZXh0dXJlPWZ1bmN0aW9uKGUsdCxyKXt0aGlzLmJpbmRUZXh0dXJlVG9GcmFtZUJ1ZmZlcihlKTt2YXIgbj1tYXliZUNyZWF0ZUJ1ZmZlckZyb21PdXRwdXRUZXh0dXJlKHRoaXMuZ2wsZSx0LHIsdGhpcy50ZXh0dXJlQ29uZmlnKTtyZXR1cm4gdGhpcy51bmJpbmRUZXh0dXJlVG9GcmFtZUJ1ZmZlcigpLG59LGUucHJvdG90eXBlLmNyZWF0ZUFuZFdhaXRGb3JGZW5jZT1mdW5jdGlvbigpe3ZhciBlPXRoaXMuY3JlYXRlRmVuY2UodGhpcy5nbCk7cmV0dXJuIHRoaXMucG9sbEZlbmNlKGUpfSxlLnByb3RvdHlwZS5jcmVhdGVGZW5jZT1mdW5jdGlvbihlKXt2YXIgdCxyLG49dGhpcztpZihFTlYuZ2V0KFwiV0VCR0xfRkVOQ0VfQVBJX0VOQUJMRURcIikpe3ZhciBvPWUsYT1vLmZlbmNlU3luYyhvLlNZTkNfR1BVX0NPTU1BTkRTX0NPTVBMRVRFLDApO2UuZmx1c2goKSxyPWZ1bmN0aW9uKCl7dmFyIGU9by5jbGllbnRXYWl0U3luYyhhLDAsMCk7cmV0dXJuIGU9PT1vLkFMUkVBRFlfU0lHTkFMRUR8fGU9PT1vLkNPTkRJVElPTl9TQVRJU0ZJRUR9LHQ9YX1lbHNlIEVOVi5nZXQoXCJXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fVkVSU0lPTlwiKT4wPyh0PXRoaXMuYmVnaW5RdWVyeSgpLHRoaXMuZW5kUXVlcnkoKSxyPWZ1bmN0aW9uKCl7cmV0dXJuIG4uaXNRdWVyeUF2YWlsYWJsZSh0LEVOVi5nZXQoXCJXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fVkVSU0lPTlwiKSl9KTpyPWZ1bmN0aW9uKCl7cmV0dXJuITB9O3JldHVybntxdWVyeTp0LGlzRmVuY2VQYXNzZWQ6cn19LGUucHJvdG90eXBlLmRvd25sb2FkTWF0cml4RnJvbVBhY2tlZFRleHR1cmU9ZnVuY3Rpb24oZSx0LHIsbixvLGEpe3ZhciBpPXRoaXM7cmV0dXJuIHRoaXMuZG93bmxvYWRNYXRyaXhEcml2ZXIoZSxmdW5jdGlvbigpe3JldHVybiBkb3dubG9hZE1hdHJpeEZyb21QYWNrZWRPdXRwdXRUZXh0dXJlKGkuZ2wsdCxyLG4sbyxhLGkudGV4dHVyZUNvbmZpZyl9KX0sZS5wcm90b3R5cGUuY3JlYXRlUHJvZ3JhbT1mdW5jdGlvbihlKXt0aGlzLnRocm93SWZEaXNwb3NlZCgpO3ZhciB0PXRoaXMuZ2wscj1jcmVhdGVGcmFnbWVudFNoYWRlcih0LGUpLG49Y3JlYXRlVmVydGV4U2hhZGVyJDEodCksbz1jcmVhdGVQcm9ncmFtKHQpO3JldHVybiBjYWxsQW5kQ2hlY2sodCxmdW5jdGlvbigpe3JldHVybiB0LmF0dGFjaFNoYWRlcihvLG4pfSksY2FsbEFuZENoZWNrKHQsZnVuY3Rpb24oKXtyZXR1cm4gdC5hdHRhY2hTaGFkZXIobyxyKX0pLGxpbmtQcm9ncmFtKHQsbyksdGhpcy5hdXRvRGVidWdWYWxpZGF0ZSYmdmFsaWRhdGVQcm9ncmFtKHQsbyksdGhpcy52ZXJ0ZXhBdHRyc0FyZUJvdW5kfHwodGhpcy5zZXRQcm9ncmFtKG8pLHRoaXMudmVydGV4QXR0cnNBcmVCb3VuZD1iaW5kVmVydGV4UHJvZ3JhbUF0dHJpYnV0ZVN0cmVhbXModCx0aGlzLnByb2dyYW0sdGhpcy52ZXJ0ZXhCdWZmZXIpKSxvfSxlLnByb3RvdHlwZS5kZWxldGVQcm9ncmFtPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7dGhpcy50aHJvd0lmRGlzcG9zZWQoKSxlPT09dGhpcy5wcm9ncmFtJiYodGhpcy5wcm9ncmFtPW51bGwpLG51bGwhPWUmJmNhbGxBbmRDaGVjayh0aGlzLmdsLGZ1bmN0aW9uKCl7cmV0dXJuIHQuZ2wuZGVsZXRlUHJvZ3JhbShlKX0pfSxlLnByb3RvdHlwZS5zZXRQcm9ncmFtPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7dGhpcy50aHJvd0lmRGlzcG9zZWQoKSx0aGlzLnByb2dyYW09ZSxudWxsIT10aGlzLnByb2dyYW0mJnRoaXMuYXV0b0RlYnVnVmFsaWRhdGUmJnZhbGlkYXRlUHJvZ3JhbSh0aGlzLmdsLHRoaXMucHJvZ3JhbSksY2FsbEFuZENoZWNrKHRoaXMuZ2wsZnVuY3Rpb24oKXtyZXR1cm4gdC5nbC51c2VQcm9ncmFtKGUpfSl9LGUucHJvdG90eXBlLmdldFVuaWZvcm1Mb2NhdGlvbj1mdW5jdGlvbihlLHQscil7cmV0dXJuIHZvaWQgMD09PXImJihyPSEwKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLHI/Z2V0UHJvZ3JhbVVuaWZvcm1Mb2NhdGlvbk9yVGhyb3codGhpcy5nbCxlLHQpOmdldFByb2dyYW1Vbmlmb3JtTG9jYXRpb24odGhpcy5nbCxlLHQpfSxlLnByb3RvdHlwZS5nZXRBdHRyaWJ1dGVMb2NhdGlvbj1mdW5jdGlvbihlLHQpe3ZhciByPXRoaXM7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksY2FsbEFuZENoZWNrKHRoaXMuZ2wsZnVuY3Rpb24oKXtyZXR1cm4gci5nbC5nZXRBdHRyaWJMb2NhdGlvbihlLHQpfSl9LGUucHJvdG90eXBlLmdldFVuaWZvcm1Mb2NhdGlvbk5vVGhyb3c9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx0aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbihlLHQpfSxlLnByb3RvdHlwZS5zZXRJbnB1dE1hdHJpeFRleHR1cmU9ZnVuY3Rpb24oZSx0LHIpe3RoaXMudGhyb3dJZkRpc3Bvc2VkKCksdGhpcy50aHJvd0lmTm9Qcm9ncmFtKCksYmluZFRleHR1cmVUb1Byb2dyYW1Vbmlmb3JtU2FtcGxlcih0aGlzLmdsLHRoaXMucHJvZ3JhbSxlLHQscil9LGUucHJvdG90eXBlLnNldE91dHB1dE1hdHJpeFRleHR1cmU9ZnVuY3Rpb24oZSx0LHIpe3RoaXMuc2V0T3V0cHV0TWF0cml4VGV4dHVyZURyaXZlcihlLHIsdCl9LGUucHJvdG90eXBlLnNldE91dHB1dFBhY2tlZE1hdHJpeFRleHR1cmU9ZnVuY3Rpb24oZSx0LHIpe3RoaXMudGhyb3dJZkRpc3Bvc2VkKCk7dmFyIG49Z2V0UGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQodCxyKSxvPW5bMF0sYT1uWzFdO3RoaXMuc2V0T3V0cHV0TWF0cml4VGV4dHVyZURyaXZlcihlLG8sYSl9LGUucHJvdG90eXBlLnNldE91dHB1dE1hdHJpeFdyaXRlUmVnaW9uPWZ1bmN0aW9uKGUsdCxyLG4pe3RoaXMuc2V0T3V0cHV0TWF0cml4V3JpdGVSZWdpb25Ecml2ZXIocixlLG4sdCl9LGUucHJvdG90eXBlLnNldE91dHB1dFBhY2tlZE1hdHJpeFdyaXRlUmVnaW9uPWZ1bmN0aW9uKGUsdCxyLG4pe3Rocm93IG5ldyBFcnJvcihcInNldE91dHB1dFBhY2tlZE1hdHJpeFdyaXRlUmVnaW9uIG5vdCBpbXBsZW1lbnRlZC5cIil9LGUucHJvdG90eXBlLmRlYnVnVmFsaWRhdGU9ZnVuY3Rpb24oKXtudWxsIT10aGlzLnByb2dyYW0mJnZhbGlkYXRlUHJvZ3JhbSh0aGlzLmdsLHRoaXMucHJvZ3JhbSksdmFsaWRhdGVGcmFtZWJ1ZmZlcih0aGlzLmdsKX0sZS5wcm90b3R5cGUuZXhlY3V0ZVByb2dyYW09ZnVuY3Rpb24oKXt0aGlzLnRocm93SWZEaXNwb3NlZCgpLHRoaXMudGhyb3dJZk5vUHJvZ3JhbSgpO3ZhciBlPXRoaXMuZ2w7dGhpcy5hdXRvRGVidWdWYWxpZGF0ZSYmdGhpcy5kZWJ1Z1ZhbGlkYXRlKCksY2FsbEFuZENoZWNrKGUsZnVuY3Rpb24oKXtyZXR1cm4gZS5kcmF3RWxlbWVudHMoZS5UUklBTkdMRVMsNixlLlVOU0lHTkVEX1NIT1JULDApfSl9LGUucHJvdG90eXBlLmJsb2NrVW50aWxBbGxQcm9ncmFtc0NvbXBsZXRlZD1mdW5jdGlvbigpe3ZhciBlPXRoaXM7dGhpcy50aHJvd0lmRGlzcG9zZWQoKSxjYWxsQW5kQ2hlY2sodGhpcy5nbCxmdW5jdGlvbigpe3JldHVybiBlLmdsLmZpbmlzaCgpfSl9LGUucHJvdG90eXBlLmdldFF1ZXJ5VGltZXJFeHRlbnNpb249ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09dGhpcy5kaXNqb2ludFF1ZXJ5VGltZXJFeHRlbnNpb24mJih0aGlzLmRpc2pvaW50UXVlcnlUaW1lckV4dGVuc2lvbj1nZXRFeHRlbnNpb25PclRocm93KHRoaXMuZ2wsMj09PUVOVi5nZXQoXCJXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fVkVSU0lPTlwiKT9cIkVYVF9kaXNqb2ludF90aW1lcl9xdWVyeV93ZWJnbDJcIjpcIkVYVF9kaXNqb2ludF90aW1lcl9xdWVyeVwiKSksdGhpcy5kaXNqb2ludFF1ZXJ5VGltZXJFeHRlbnNpb259LGUucHJvdG90eXBlLmdldFF1ZXJ5VGltZXJFeHRlbnNpb25XZWJHTDI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRRdWVyeVRpbWVyRXh0ZW5zaW9uKCl9LGUucHJvdG90eXBlLmdldFF1ZXJ5VGltZXJFeHRlbnNpb25XZWJHTDE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRRdWVyeVRpbWVyRXh0ZW5zaW9uKCl9LGUucHJvdG90eXBlLmJlZ2luUXVlcnk9ZnVuY3Rpb24oKXtpZigyPT09RU5WLmdldChcIldFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9WRVJTSU9OXCIpKXt2YXIgZT10aGlzLmdsLHQ9dGhpcy5nZXRRdWVyeVRpbWVyRXh0ZW5zaW9uV2ViR0wyKCkscj1lLmNyZWF0ZVF1ZXJ5KCk7cmV0dXJuIGUuYmVnaW5RdWVyeSh0LlRJTUVfRUxBUFNFRF9FWFQscikscn12YXIgbj10aGlzLmdldFF1ZXJ5VGltZXJFeHRlbnNpb25XZWJHTDEoKSxvPW4uY3JlYXRlUXVlcnlFWFQoKTtyZXR1cm4gbi5iZWdpblF1ZXJ5RVhUKG4uVElNRV9FTEFQU0VEX0VYVCxvKSxvfSxlLnByb3RvdHlwZS5lbmRRdWVyeT1mdW5jdGlvbigpe2lmKDIhPT1FTlYuZ2V0KFwiV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1ZFUlNJT05cIikpe3ZhciBlPXRoaXMuZ2V0UXVlcnlUaW1lckV4dGVuc2lvbldlYkdMMSgpO2UuZW5kUXVlcnlFWFQoZS5USU1FX0VMQVBTRURfRVhUKX1lbHNle3ZhciB0PXRoaXMuZ2wscj10aGlzLmdldFF1ZXJ5VGltZXJFeHRlbnNpb25XZWJHTDIoKTt0LmVuZFF1ZXJ5KHIuVElNRV9FTEFQU0VEX0VYVCl9fSxlLnByb3RvdHlwZS53YWl0Rm9yUXVlcnlBbmRHZXRUaW1lPWZ1bmN0aW9uKGUpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOnJldHVybls0LHJlcGVhdGVkVHJ5KGZ1bmN0aW9uKCl7cmV0dXJuIHQuZGlzcG9zZWR8fHQuaXNRdWVyeUF2YWlsYWJsZShlLEVOVi5nZXQoXCJXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fVkVSU0lPTlwiKSl9KV07Y2FzZSAxOnJldHVybiByLnNlbnQoKSxbMix0aGlzLmdldFF1ZXJ5VGltZShlLEVOVi5nZXQoXCJXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fVkVSU0lPTlwiKSldfX0pfSl9LGUucHJvdG90eXBlLmdldFF1ZXJ5VGltZT1mdW5jdGlvbihlLHQpe2lmKDA9PT10KXJldHVybiBudWxsO2lmKDI9PT10KXt2YXIgcj10aGlzLmdsO3JldHVybiByLmdldFF1ZXJ5UGFyYW1ldGVyKGUsci5RVUVSWV9SRVNVTFQpLzFlNn12YXIgbj10aGlzLmdldFF1ZXJ5VGltZXJFeHRlbnNpb25XZWJHTDEoKTtyZXR1cm4gbi5nZXRRdWVyeU9iamVjdEVYVChlLG4uUVVFUllfUkVTVUxUX0VYVCkvMWU2fSxlLnByb3RvdHlwZS5pc1F1ZXJ5QXZhaWxhYmxlPWZ1bmN0aW9uKGUsdCl7aWYoMD09PXQpcmV0dXJuITA7aWYoMj09PXQpe3ZhciByPXRoaXMuZ2wsbj10aGlzLmdldFF1ZXJ5VGltZXJFeHRlbnNpb25XZWJHTDIoKSxvPXIuZ2V0UXVlcnlQYXJhbWV0ZXIoZSxyLlFVRVJZX1JFU1VMVF9BVkFJTEFCTEUpO3JldHVybiBudWxsPT10aGlzLmRpc2pvaW50JiYodGhpcy5kaXNqb2ludD10aGlzLmdsLmdldFBhcmFtZXRlcihuLkdQVV9ESVNKT0lOVF9FWFQpKSxvJiYhdGhpcy5kaXNqb2ludH1vPShuPXRoaXMuZ2V0UXVlcnlUaW1lckV4dGVuc2lvbldlYkdMMSgpKS5nZXRRdWVyeU9iamVjdEVYVChlLG4uUVVFUllfUkVTVUxUX0FWQUlMQUJMRV9FWFQpO3JldHVybiBudWxsPT10aGlzLmRpc2pvaW50JiYodGhpcy5kaXNqb2ludD10aGlzLmdsLmdldFBhcmFtZXRlcihuLkdQVV9ESVNKT0lOVF9FWFQpKSxvJiYhdGhpcy5kaXNqb2ludH0sZS5wcm90b3R5cGUucG9sbEZlbmNlPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHIpe3QuYWRkSXRlbVRvUG9sbChmdW5jdGlvbigpe3JldHVybiBlLmlzRmVuY2VQYXNzZWQoKX0sZnVuY3Rpb24oKXtyZXR1cm4gcigpfSl9KX0sZS5wcm90b3R5cGUucG9sbEl0ZW1zPWZ1bmN0aW9uKCl7Zm9yKHZhciBlPWJpblNlYXJjaExhc3RUcnVlKHRoaXMuaXRlbXNUb1BvbGwubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLmlzRG9uZUZufSkpLHQ9MDt0PD1lOysrdCl7KDAsdGhpcy5pdGVtc1RvUG9sbFt0XS5yZXNvbHZlRm4pKCl9dGhpcy5pdGVtc1RvUG9sbD10aGlzLml0ZW1zVG9Qb2xsLnNsaWNlKGUrMSl9LGUucHJvdG90eXBlLmFkZEl0ZW1Ub1BvbGw9ZnVuY3Rpb24oZSx0KXt2YXIgcj10aGlzO3RoaXMuaXRlbXNUb1BvbGwucHVzaCh7aXNEb25lRm46ZSxyZXNvbHZlRm46dH0pLHRoaXMuaXRlbXNUb1BvbGwubGVuZ3RoPjF8fHJlcGVhdGVkVHJ5KGZ1bmN0aW9uKCl7cmV0dXJuIHIucG9sbEl0ZW1zKCksMD09PXIuaXRlbXNUb1BvbGwubGVuZ3RofSl9LGUucHJvdG90eXBlLmJpbmRUZXh0dXJlVG9GcmFtZUJ1ZmZlcj1mdW5jdGlvbihlKXt0aGlzLnRocm93SWZEaXNwb3NlZCgpLGJpbmRDb2xvclRleHR1cmVUb0ZyYW1lYnVmZmVyKHRoaXMuZ2wsZSx0aGlzLmZyYW1lYnVmZmVyKSx0aGlzLmF1dG9EZWJ1Z1ZhbGlkYXRlJiZ2YWxpZGF0ZUZyYW1lYnVmZmVyKHRoaXMuZ2wpfSxlLnByb3RvdHlwZS51bmJpbmRUZXh0dXJlVG9GcmFtZUJ1ZmZlcj1mdW5jdGlvbigpe251bGwhPXRoaXMub3V0cHV0VGV4dHVyZT8oYmluZENvbG9yVGV4dHVyZVRvRnJhbWVidWZmZXIodGhpcy5nbCx0aGlzLm91dHB1dFRleHR1cmUsdGhpcy5mcmFtZWJ1ZmZlciksdGhpcy5hdXRvRGVidWdWYWxpZGF0ZSYmdmFsaWRhdGVGcmFtZWJ1ZmZlcih0aGlzLmdsKSk6dW5iaW5kQ29sb3JUZXh0dXJlRnJvbUZyYW1lYnVmZmVyKHRoaXMuZ2wsdGhpcy5mcmFtZWJ1ZmZlcil9LGUucHJvdG90eXBlLmRvd25sb2FkTWF0cml4RHJpdmVyPWZ1bmN0aW9uKGUsdCl7dGhpcy5iaW5kVGV4dHVyZVRvRnJhbWVCdWZmZXIoZSk7dmFyIHI9dCgpO3JldHVybiB0aGlzLnVuYmluZFRleHR1cmVUb0ZyYW1lQnVmZmVyKCkscn0sZS5wcm90b3R5cGUuc2V0T3V0cHV0TWF0cml4VGV4dHVyZURyaXZlcj1mdW5jdGlvbihlLHQscil7dGhpcy50aHJvd0lmRGlzcG9zZWQoKTt2YXIgbj10aGlzLmdsO2JpbmRDb2xvclRleHR1cmVUb0ZyYW1lYnVmZmVyKG4sZSx0aGlzLmZyYW1lYnVmZmVyKSx0aGlzLmF1dG9EZWJ1Z1ZhbGlkYXRlJiZ2YWxpZGF0ZUZyYW1lYnVmZmVyKG4pLHRoaXMub3V0cHV0VGV4dHVyZT1lLGNhbGxBbmRDaGVjayhuLGZ1bmN0aW9uKCl7cmV0dXJuIG4udmlld3BvcnQoMCwwLHQscil9KSxjYWxsQW5kQ2hlY2sobixmdW5jdGlvbigpe3JldHVybiBuLnNjaXNzb3IoMCwwLHQscil9KX0sZS5wcm90b3R5cGUuc2V0T3V0cHV0TWF0cml4V3JpdGVSZWdpb25Ecml2ZXI9ZnVuY3Rpb24oZSx0LHIsbil7dmFyIG89dGhpczt0aGlzLnRocm93SWZEaXNwb3NlZCgpLGNhbGxBbmRDaGVjayh0aGlzLmdsLGZ1bmN0aW9uKCl7cmV0dXJuIG8uZ2wuc2Npc3NvcihlLHQscixuKX0pfSxlLnByb3RvdHlwZS50aHJvd0lmRGlzcG9zZWQ9ZnVuY3Rpb24oKXtpZih0aGlzLmRpc3Bvc2VkKXRocm93IG5ldyBFcnJvcihcIkF0dGVtcHRlZCB0byB1c2UgZGlzcG9zZWQgR1BHUFVDb250ZXh0LlwiKX0sZS5wcm90b3R5cGUudGhyb3dJZk5vUHJvZ3JhbT1mdW5jdGlvbigpe2lmKG51bGw9PXRoaXMucHJvZ3JhbSl0aHJvdyBuZXcgRXJyb3IoXCJObyBHUFUgcHJvZ3JhbSBpcyBjdXJyZW50bHkgc2V0LlwiKX0sZX0oKTtmdW5jdGlvbiBiaW5TZWFyY2hMYXN0VHJ1ZShlKXtmb3IodmFyIHQ9MCxyPWUubGVuZ3RoLTEsbj0tMTt0PD1yOyl7dmFyIG89dCtyPj4xO2Vbb10oKT8obj1vLHQ9bysxKTpyPW8tMX1yZXR1cm4gbn1mdW5jdGlvbiBjb21waWxlUHJvZ3JhbShlLHQscixuKXtmb3IodmFyIG89dC51c2VyQ29kZSxhPXIubWFwKGZ1bmN0aW9uKGUscil7dmFyIG49e2xvZ2ljYWxTaGFwZTplLnNoYXBlLHRleFNoYXBlOmUuaXNVbmlmb3JtP251bGw6ZS50ZXhEYXRhLnRleFNoYXBlLGlzVW5pZm9ybTplLmlzVW5pZm9ybSxpc1BhY2tlZDohZS5pc1VuaWZvcm0mJmUudGV4RGF0YS5pc1BhY2tlZH07cmV0dXJue25hbWU6dC52YXJpYWJsZU5hbWVzW3JdLHNoYXBlSW5mbzpufX0pLGk9YS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUuc2hhcGVJbmZvfSkscz17bG9naWNhbFNoYXBlOm4uc2hhcGUsdGV4U2hhcGU6bi50ZXhEYXRhLnRleFNoYXBlLGlzVW5pZm9ybTohMSxpc1BhY2tlZDpuLnRleERhdGEuaXNQYWNrZWR9LHU9bWFrZVNoYWRlcihhLHMsbywhMD09PXQuc3VwcG9ydHNCcm9hZGNhc3RpbmcsdC51c2VzUGFja2VkVGV4dHVyZXMpLGw9ZS5jcmVhdGVQcm9ncmFtKHUpLGM9e30scD0wO3A8dC52YXJpYWJsZU5hbWVzLmxlbmd0aDtwKyspe3ZhciBkPXQudmFyaWFibGVOYW1lc1twXTtjW2RdPWUuZ2V0VW5pZm9ybUxvY2F0aW9uKGwsZCwhMSl9cmV0dXJue3Byb2dyYW06dCxzb3VyY2U6dSx3ZWJHTFByb2dyYW06bCx1bmlmb3JtTG9jYXRpb25zOmMsZ3BncHU6ZSxpblNoYXBlSW5mb3M6aSxvdXRTaGFwZUluZm86c319ZnVuY3Rpb24gdmFsaWRhdGVCaW5hcnlBbmRQcm9ncmFtKGUsdCl7aWYoZS5sZW5ndGghPT10Lmxlbmd0aCl0aHJvdyBFcnJvcihcIkJpbmFyeSB3YXMgY29tcGlsZWQgd2l0aCBcIitlLmxlbmd0aCtcIiBpbnB1dHMsIGJ1dCB3YXMgZXhlY3V0ZWQgd2l0aCBcIit0Lmxlbmd0aCtcIiBpbnB1dHNcIik7ZS5mb3JFYWNoKGZ1bmN0aW9uKGUscil7dmFyIG49ZS5sb2dpY2FsU2hhcGUsbz10W3JdLGE9by5zaGFwZTtpZighYXJyYXlzRXF1YWwobixhKSl0aHJvdyBFcnJvcihcIkJpbmFyeSB3YXMgY29tcGlsZWQgd2l0aCBkaWZmZXJlbnQgc2hhcGVzIHRoYW4gdGhlIGN1cnJlbnQgYXJncy4gU2hhcGVzIFwiK24rXCIgYW5kIFwiK2ErXCIgbXVzdCBtYXRjaFwiKTtpZighZS5pc1VuaWZvcm18fCFvLmlzVW5pZm9ybSl7dmFyIGk9ZS50ZXhTaGFwZSxzPW8uaXNVbmlmb3JtP251bGw6by50ZXhEYXRhLnRleFNoYXBlO2lmKCFhcnJheXNFcXVhbChpLHMpKXRocm93IEVycm9yKFwiQmluYXJ5IHdhcyBjb21waWxlZCB3aXRoIGRpZmZlcmVudCB0ZXh0dXJlIHNoYXBlcyB0aGFuIHRoZSBjdXJyZW50IGFyZ3MuIFNoYXBlIFwiK2krXCIgYW5kIFwiK3MrXCIgbXVzdCBtYXRjaFwiKX19KX1mdW5jdGlvbiBydW5Qcm9ncmFtKGUsdCxyLG4pe3ZhbGlkYXRlQmluYXJ5QW5kUHJvZ3JhbShlLmluU2hhcGVJbmZvcyx0KSx2YWxpZGF0ZUJpbmFyeUFuZFByb2dyYW0oW2Uub3V0U2hhcGVJbmZvXSxbcl0pO3ZhciBvPXIudGV4RGF0YS50ZXh0dXJlLGE9ci50ZXhEYXRhLnRleFNoYXBlLGk9ZS5ncGdwdTtyLnRleERhdGEuaXNQYWNrZWQ/aS5zZXRPdXRwdXRQYWNrZWRNYXRyaXhUZXh0dXJlKG8sYVswXSxhWzFdKTppLnNldE91dHB1dE1hdHJpeFRleHR1cmUobyxhWzBdLGFbMV0pLGkuc2V0UHJvZ3JhbShlLndlYkdMUHJvZ3JhbSksdC5mb3JFYWNoKGZ1bmN0aW9uKHQscil7dmFyIG49ZS5wcm9ncmFtLnZhcmlhYmxlTmFtZXNbcl0sbz1lLnVuaWZvcm1Mb2NhdGlvbnNbbl07aWYobnVsbCE9byl7aWYodC5pc1VuaWZvcm0pe2lmKDE9PT1zaXplRnJvbVNoYXBlKHQuc2hhcGUpKWkuZ2wudW5pZm9ybTFmKG8sdC51bmlmb3JtVmFsdWVzWzBdKTtlbHNle3ZhciBhPXQudW5pZm9ybVZhbHVlczthIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5fHwoYT1uZXcgRmxvYXQzMkFycmF5KGEpKSxpLmdsLnVuaWZvcm0xZnYobyxhKX1yZXR1cm59dmFyIHM9dC50ZXhEYXRhLnRleHR1cmU7aS5zZXRJbnB1dE1hdHJpeFRleHR1cmUocyxvLHIpfX0pLG51bGwhPW4mJm4oaSxlLndlYkdMUHJvZ3JhbSksaS5leGVjdXRlUHJvZ3JhbSgpfWZ1bmN0aW9uIG1ha2VTaGFkZXJLZXkoZSx0LHIpe3ZhciBuPVwiXCI7dC5jb25jYXQocikuZm9yRWFjaChmdW5jdGlvbihlKXtuKz1lLnNoYXBlK1wiX1wiKyhlLmlzVW5pZm9ybT9cInVuaWZvcm1cIjplLnRleERhdGEudGV4U2hhcGUpfSk7dmFyIG89ZS51c2VyQ29kZSxhPSghMD09PWUuc3VwcG9ydHNCcm9hZGNhc3RpbmcpLnRvU3RyaW5nKCksaT1lLmNvbnN0cnVjdG9yLm5hbWU7cmV0dXJuIGkrPVwiX1wiK2ErXCJfXCIrbitcIl9cIitvfXZhciBJbTJDb2xQcm9ncmFtPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKGUsdCxyKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXSx0aGlzLm91dHB1dFNoYXBlPWU7dmFyIG49ci5maWx0ZXJXaWR0aCxvPXIuaW5DaGFubmVscyxhPXIuc3RyaWRlV2lkdGgsaT1yLnN0cmlkZUhlaWdodCxzPXIucGFkSW5mbyx1PXIub3V0V2lkdGgsbD1yLmRpbGF0aW9uV2lkdGgsYz1yLmRpbGF0aW9uSGVpZ2h0LHA9cy5sZWZ0LGQ9cy50b3AsaD1vKm47dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMyIHJjID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuXFxuICAgICAgICB2ZWM0IHJlc3VsdCA9IHZlYzQoMCk7XFxuXFxuICAgICAgICBmb3IoaW50IHJvdz0wOyByb3c8PTE7IHJvdysrKSB7XFxuICAgICAgICAgIGZvcihpbnQgY29sPTA7IGNvbDw9MTsgY29sKyspIHtcXG4gICAgICAgICAgICBpbnQgYmxvY2tJbmRleCA9IHJjLnkgKyBjb2w7XFxuICAgICAgICAgICAgaW50IHBvcyA9IHJjLnggKyByb3c7XFxuXFxuICAgICAgICAgICAgaWYoYmxvY2tJbmRleCA+PSBcIitlWzFdK1wiIHx8IHBvcyA+PSBcIitlWzBdK1wiKSBjb250aW51ZTtcXG5cXG4gICAgICAgICAgICBpbnQgb2Zmc2V0WSA9IGludChibG9ja0luZGV4IC8gKFwiK3UrXCIpKSAqIFwiK2krXCIgLSBcIitkK1wiO1xcbiAgICAgICAgICAgIGludCBkMCA9IG9mZnNldFkgKyBcIitjK1wiICogKHBvcyAvIFwiK2grXCIpO1xcblxcbiAgICAgICAgICAgIGlmKGQwID49IFwiK3RbMF0rXCIgfHwgZDAgPCAwKSBjb250aW51ZTtcXG5cXG4gICAgICAgICAgICBpbnQgb2Zmc2V0WCA9IGludChtb2QoZmxvYXQoYmxvY2tJbmRleCksIFwiK3UrXCIuKSAqIFwiK2ErXCIuIC0gXCIrcCtcIi4pO1xcbiAgICAgICAgICAgIGludCBkMSA9IG9mZnNldFggKyBcIitsK1wiICogKGludChtb2QoZmxvYXQocG9zKSwgXCIraCtcIi4pIC8gXCIrbytcIi4pKTtcXG5cXG4gICAgICAgICAgICBpZihkMSA+PSBcIit0WzFdK1wiIHx8IGQxIDwgMCkgY29udGludWU7XFxuXFxuICAgICAgICAgICAgcmVzdWx0W3JvdyAqIDIgKyBjb2xdID0gZ2V0QShkMCwgZDEsIGludChtb2QoZmxvYXQocG9zKSwgXCIrbytcIi4pKSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHJlc3VsdDtcXG4gICAgICB9XFxuICAgIFwifX0oKSxMUk5Qcm9ncmFtPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKGUsdCxyLG4sbyl7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIl0sdGhpcy5vdXRwdXRTaGFwZT1bXTt2YXIgYSxpPXQscz1lWzNdLTE7dGhpcy5vdXRwdXRTaGFwZT1lO3ZhciB1PVwiZmxvYXQoXCIrcitcIikgKyBmbG9hdChcIituK1wiKSAqIHN1bVwiO2E9LjU9PT1vP1wiaW52ZXJzZXNxcnQoXCIrdStcIilcIjoxPT09bz9cIjEuMC8oXCIrdStcIilcIjpcImV4cChsb2coXCIrdStcIikgKiBmbG9hdCgtXCIrbytcIikpO1wiLHRoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IHIgPSBjb29yZHNbMV07XFxuICAgICAgICBpbnQgYyA9IGNvb3Jkc1syXTtcXG4gICAgICAgIGludCBkID0gY29vcmRzWzNdO1xcbiAgICAgICAgZmxvYXQgeCA9IGdldFgoYiwgciwgYywgZCk7XFxuICAgICAgICBmbG9hdCBzdW0gPSAwLjA7XFxuICAgICAgICBmb3IgKGludCBqID0gLVwiK2krXCI7IGogPD0gXCIraStcIjsgaisrKSB7XFxuICAgICAgICAgIGludCBpZHggPSBkICsgajtcXG4gICAgICAgICAgaWYgKGlkeCA+PSAwICYmIGlkeCA8PSAgXCIrcytcIikge1xcbiAgICAgICAgICAgIGZsb2F0IHogPSBnZXRYKGIsIHIsIGMsIGlkeCk7XFxuICAgICAgICAgICAgc3VtICs9IHogKiB6O1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBmbG9hdCB2YWwgPSB4ICogXCIrYStcIjtcXG4gICAgICAgIHNldE91dHB1dCh2YWwpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLExSTkdyYWRQcm9ncmFtPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKGUsdCxyLG4sbyl7dGhpcy52YXJpYWJsZU5hbWVzPVtcImlucHV0SW1hZ2VcIixcIm91dHB1dEltYWdlXCIsXCJkeVwiXSx0aGlzLm91dHB1dFNoYXBlPVtdLHRoaXMub3V0cHV0U2hhcGU9ZSx0aGlzLmRlcHRoPWVbM10sdGhpcy5kZXB0aFJhZGl1cz10LHRoaXMuYmlhcz1yLHRoaXMuYWxwaGE9bix0aGlzLmJldGE9byx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYiA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCByID0gY29vcmRzWzFdO1xcbiAgICAgICAgaW50IGMgPSBjb29yZHNbMl07XFxuXFxuICAgICAgICBmbG9hdCByZXN1bHQgPSAwLjA7XFxuICAgICAgICBmb3IgKGludCBkID0gMDsgZCA8IFwiK3RoaXMuZGVwdGgrXCI7ICsrZCkge1xcbiAgICAgICAgICBpbnQgZGVwdGhCZWdpbiA9IGludChtYXgoMC4wLCBmbG9hdChkIC0gXCIrdCtcIikpKTtcXG4gICAgICAgICAgaW50IGRlcHRoRW5kID0gaW50KG1pbihmbG9hdChcIit0aGlzLmRlcHRoK1wiKSxcXG4gICAgICAgICAgICAgIGZsb2F0KGQgKyBcIit0K1wiICsgMSkpKTtcXG5cXG4gICAgICAgICAgY29uc3QgaW50IE1JTl9ERVBUSF9CRUdJTiA9IDA7XFxuICAgICAgICAgIGNvbnN0IGludCBNQVhfREVQVEhfRU5EID0gXCIrdGhpcy5kZXB0aCtcIjtcXG5cXG4gICAgICAgICAgZmxvYXQgbm9ybSA9IDAuMDtcXG4gICAgICAgICAgZm9yIChpbnQgayA9IE1JTl9ERVBUSF9CRUdJTjsgayA8IE1BWF9ERVBUSF9FTkQ7ICsraykge1xcbiAgICAgICAgICAgIGlmIChrIDwgZGVwdGhCZWdpbil7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZWxzZSBpZiAoayA+PSBkZXB0aEJlZ2luICYmIGsgPCBkZXB0aEVuZCkge1xcbiAgICAgICAgICAgICAgbm9ybSArPSBnZXRJbnB1dEltYWdlKGIsIHIsIGMsIGspICogZ2V0SW5wdXRJbWFnZShiLCByLCBjLCBrKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgbm9ybSA9IGZsb2F0KFwiK24rXCIpICogbm9ybSArIGZsb2F0KFwiK3IrXCIpO1xcblxcbiAgICAgICAgICBmb3IoaW50IGsgPSBNSU5fREVQVEhfQkVHSU47IGsgPCBNQVhfREVQVEhfRU5EOyArK2spe1xcbiAgICAgICAgICAgIGlmIChrIDwgZGVwdGhCZWdpbil7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZWxzZSBpZiAoayA+PSBkZXB0aEJlZ2luICYmIGsgPCBkZXB0aEVuZCl7XFxuICAgICAgICAgICAgICBmbG9hdCBkeWkgPSAtMi4wICogZmxvYXQoXCIrbitcIilcXG4gICAgICAgICAgICAgICAgKiBmbG9hdChcIitvK1wiKVxcbiAgICAgICAgICAgICAgICAqIGdldElucHV0SW1hZ2UoYiAsciAsYywgaykgKiBnZXRPdXRwdXRJbWFnZShiLCByLCBjLCBkKVxcbiAgICAgICAgICAgICAgICAvIG5vcm07XFxuICAgICAgICAgICAgICBpZiAoayA9PSBkKSB7XFxuICAgICAgICAgICAgICAgIGR5aSArPSBwb3cobm9ybSwgLTEuMCAqIFwiK28rXCIpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgaWYgKGsgPT0gY29vcmRzWzNdKSB7XFxuICAgICAgICAgICAgICAgIGR5aSAqPSBnZXREeShiLCByLCBjLCBkKTtcXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGR5aTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgc2V0T3V0cHV0KHJlc3VsdCk7XFxuICAgICAgfVxcbiAgICBcIn19KCksTWF4UG9vbDJEQmFja3Byb3BQcm9ncmFtPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKGUpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJkeVwiLFwibWF4UG9zXCJdLHRoaXMub3V0cHV0U2hhcGU9ZS5pblNoYXBlO3ZhciB0PWUuc3RyaWRlSGVpZ2h0LHI9ZS5zdHJpZGVXaWR0aCxuPWUuZGlsYXRpb25IZWlnaHQsbz1lLmVmZmVjdGl2ZUZpbHRlckhlaWdodCxhPWUuZWZmZWN0aXZlRmlsdGVyV2lkdGgsaT1vLTEtZS5wYWRJbmZvLnRvcCxzPWEtMS1lLnBhZEluZm8ubGVmdCx1PW8qYS0xO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICBjb25zdCBpdmVjMiBwYWRzID0gaXZlYzIoXCIraStcIiwgXCIrcytcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYiA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBkID0gY29vcmRzWzNdO1xcblxcbiAgICAgICAgaXZlYzIgZHlSQ0Nvcm5lciA9IGNvb3Jkcy55eiAtIHBhZHM7XFxuICAgICAgICBpbnQgZHlSQ29ybmVyID0gZHlSQ0Nvcm5lci54O1xcbiAgICAgICAgaW50IGR5Q0Nvcm5lciA9IGR5UkNDb3JuZXIueTtcXG5cXG4gICAgICAgIC8vIENvbnZvbHZlIGR5KD8sID8sIGQpIHdpdGggcG9zIG1hc2soOiwgOiwgZCkgdG8gZ2V0IGR4KHhSLCB4QywgZCkuXFxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cXG4gICAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XFxuICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgXCIrbytcIjtcXG4gICAgICAgICAgd1IgKz0gXCIrbitcIikge1xcbiAgICAgICAgICBmbG9hdCBkeVIgPSBmbG9hdChkeVJDb3JuZXIgKyB3UikgLyBcIit0K1wiLjA7XFxuXFxuICAgICAgICAgIGlmIChkeVIgPCAwLjAgfHwgZHlSID49IFwiK2Uub3V0SGVpZ2h0K1wiLjAgfHwgZnJhY3QoZHlSKSA+IDAuMCkge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGludCBpZHlSID0gaW50KGR5Uik7XFxuXFxuICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCBcIithK1wiOyB3QysrKSB7XFxuICAgICAgICAgICAgZmxvYXQgZHlDID0gZmxvYXQoZHlDQ29ybmVyICsgd0MpIC8gXCIrcitcIi4wO1xcblxcbiAgICAgICAgICAgIGlmIChkeUMgPCAwLjAgfHwgZHlDID49IFwiK2Uub3V0V2lkdGgrXCIuMCB8fFxcbiAgICAgICAgICAgICAgICBmcmFjdChkeUMpID4gMC4wKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaW50IGlkeUMgPSBpbnQoZHlDKTtcXG5cXG4gICAgICAgICAgICBmbG9hdCBkeVZhbHVlID0gZ2V0RHkoYiwgaWR5UiwgaWR5QywgZCk7XFxuICAgICAgICAgICAgaW50IG1heFBvc1ZhbHVlID0gXCIrdStcIiAtIGludChnZXRNYXhQb3MoYiwgaWR5UiwgaWR5QywgZCkpO1xcblxcbiAgICAgICAgICAgIC8vIEdldCB0aGUgY3VycmVudCB2YWx1ZSwgY2hlY2sgaXQgYWdhaW5zdCB0aGUgdmFsdWUgZnJvbSB0aGVcXG4gICAgICAgICAgICAvLyBwb3NpdGlvbiBtYXRyaXguXFxuICAgICAgICAgICAgaW50IGN1clBvc1ZhbHVlID0gd1IgKiBcIithK1wiICsgd0M7XFxuICAgICAgICAgICAgZmxvYXQgbWFzayA9IGZsb2F0KG1heFBvc1ZhbHVlID09IGN1clBvc1ZhbHVlID8gMS4wIDogMC4wKTtcXG5cXG4gICAgICAgICAgICBkb3RQcm9kICs9IGR5VmFsdWUgKiBtYXNrO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XFxuICAgICAgfVxcbiAgICBcIn19KCksTWF0TXVsUHJvZ3JhbT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihlLHQscixuKXt2b2lkIDA9PT1yJiYocj0hMSksdm9pZCAwPT09biYmKG49ITEpLHRoaXMudmFyaWFibGVOYW1lcz1bXCJtYXRyaXhBXCIsXCJtYXRyaXhCXCJdO3ZhciBvPWVbMF0sYT1yP2VbMl06ZVsxXSxpPW4/dFsxXTp0WzJdLHM9cj9lWzFdOmVbMl07dGhpcy5vdXRwdXRTaGFwZT1bbyxhLGldO3ZhciB1PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHI/XCJiYXRjaCwgXCIrdCtcIiArIFwiK2UrXCIsIGFSb3dcIjpcImJhdGNoLCBhUm93LCBcIit0K1wiICsgXCIrZX0sbD1mdW5jdGlvbihlLHQpe3JldHVybiBuP1wiYmF0Y2gsIGJDb2wsIFwiK3QrXCIgKyBcIitlOlwiYmF0Y2gsIFwiK3QrXCIgKyBcIitlK1wiLCBiQ29sXCJ9LGM9NCpNYXRoLmZsb29yKHMvNCkscD1zJTQ7dGhpcy51c2VyQ29kZT1cIiBmbG9hdCBkb3RBUm93QkNvbChpbnQgYmF0Y2gsIGludCBhUm93LCBpbnQgYkNvbCkge1xcbiAgICAgIGZsb2F0IHJlc3VsdCA9IDAuMDtcXG4gICAgICBmb3IgKGludCBpID0gMDsgaSA8IFwiK2MrXCI7IGkgKz0gNCkge1xcbiAgICAgICAgdmVjNCBhID0gdmVjNChcXG4gICAgICAgICAgZ2V0TWF0cml4QShcIit1KDAsXCJpXCIpK1wiKSxcXG4gICAgICAgICAgZ2V0TWF0cml4QShcIit1KDEsXCJpXCIpK1wiKSxcXG4gICAgICAgICAgZ2V0TWF0cml4QShcIit1KDIsXCJpXCIpK1wiKSxcXG4gICAgICAgICAgZ2V0TWF0cml4QShcIit1KDMsXCJpXCIpK1wiKVxcbiAgICAgICAgKTtcXG4gICAgICAgIHZlYzQgYiA9IHZlYzQoXFxuICAgICAgICAgIGdldE1hdHJpeEIoXCIrbCgwLFwiaVwiKStcIiksXFxuICAgICAgICAgIGdldE1hdHJpeEIoXCIrbCgxLFwiaVwiKStcIiksXFxuICAgICAgICAgIGdldE1hdHJpeEIoXCIrbCgyLFwiaVwiKStcIiksXFxuICAgICAgICAgIGdldE1hdHJpeEIoXCIrbCgzLFwiaVwiKStcIilcXG4gICAgICAgICk7XFxuXFxuICAgICAgICByZXN1bHQgKz0gZG90KGEsIGIpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoXCIrKDE9PT1wKStcIikge1xcbiAgICAgICAgcmVzdWx0ICs9IGdldE1hdHJpeEEoXCIrdSgwLGMpK1wiKSAqXFxuICAgICAgICAgIGdldE1hdHJpeEIoXCIrbCgwLGMpK1wiKTtcXG4gICAgICB9IGVsc2UgaWYgKFwiKygyPT09cCkrXCIpIHtcXG4gICAgICAgIHZlYzIgYSA9IHZlYzIoXFxuICAgICAgICAgIGdldE1hdHJpeEEoXCIrdSgwLGMpK1wiKSxcXG4gICAgICAgICAgZ2V0TWF0cml4QShcIit1KDEsYykrXCIpXFxuICAgICAgICApO1xcbiAgICAgICAgdmVjMiBiID0gdmVjMihcXG4gICAgICAgICAgZ2V0TWF0cml4QihcIitsKDAsYykrXCIpLFxcbiAgICAgICAgICBnZXRNYXRyaXhCKFwiK2woMSxjKStcIilcXG4gICAgICAgICk7XFxuICAgICAgICByZXN1bHQgKz0gZG90KGEsIGIpO1xcbiAgICAgIH0gZWxzZSBpZiAoXCIrKDM9PT1wKStcIikge1xcbiAgICAgICAgdmVjMyBhID0gdmVjMyhcXG4gICAgICAgICAgZ2V0TWF0cml4QShcIit1KDAsYykrXCIpLFxcbiAgICAgICAgICBnZXRNYXRyaXhBKFwiK3UoMSxjKStcIiksXFxuICAgICAgICAgIGdldE1hdHJpeEEoXCIrdSgyLGMpK1wiKVxcbiAgICAgICAgKTtcXG4gICAgICAgIHZlYzMgYiA9IHZlYzMoXFxuICAgICAgICAgIGdldE1hdHJpeEIoXCIrbCgwLGMpK1wiKSxcXG4gICAgICAgICAgZ2V0TWF0cml4QihcIitsKDEsYykrXCIpLFxcbiAgICAgICAgICBnZXRNYXRyaXhCKFwiK2woMixjKStcIilcXG4gICAgICAgICk7XFxuICAgICAgICByZXN1bHQgKz0gZG90KGEsIGIpO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICB9XFxuXFxuICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICBpdmVjMyByZXNCUkMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICBzZXRPdXRwdXQoZG90QVJvd0JDb2wocmVzQlJDLngsIHJlc0JSQy55LCByZXNCUkMueikpO1xcbiAgICB9XFxuICAgIFwifX0oKSxNYXRNdWxQYWNrZWRQcm9ncmFtPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKGUsdCxyLG4sbyl7dm9pZCAwPT09biYmKG49ITEpLHZvaWQgMD09PW8mJihvPSExKSx0aGlzLnZhcmlhYmxlTmFtZXM9W1wibWF0cml4QVwiLFwibWF0cml4QlwiXSx0aGlzLnVzZXNQYWNrZWRUZXh0dXJlcz0hMCx0aGlzLm91dHB1dFNoYXBlPXI7dmFyIGE9bj9lWzBdOmVbMV0saT1NYXRoLmNlaWwoYS8yKSxzPW4/XCJpICogMiwgcmMueFwiOlwicmMueCwgaSAqIDJcIix1PW8/XCJyYy55LCBpICogMlwiOlwiaSAqIDIsIHJjLnlcIixsPW4/W1wiYS54eHl5XCIsXCJhLnp6d3dcIl06W1wiYS54eHp6XCIsXCJhLnl5d3dcIl0sYz1vP1tcImIueHp4elwiLFwiYi55d3l3XCJdOltcImIueHl4eVwiLFwiYi56d3p3XCJdO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICBjb25zdCBmbG9hdCBzaGFyZWREaW1lbnNpb24gPSBcIitpK1wiLjA7XFxuXFxuICAgICAgdmVjNCBkb3QyeDJBUm93QkNvbChpdmVjMiByYykge1xcbiAgICAgICAgdmVjNCByZXN1bHQgPSB2ZWM0KDApO1xcbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBcIitpK1wiOyBpKyspIHtcXG4gICAgICAgICAgdmVjNCBhID0gZ2V0TWF0cml4QShcIitzK1wiKTtcXG4gICAgICAgICAgdmVjNCBiID0gZ2V0TWF0cml4QihcIit1K1wiKTtcXG5cXG4gICAgICAgICAgcmVzdWx0ICs9IChcIitsWzBdK1wiICogXCIrY1swXStcIikgKyAoXCIrbFsxXStcIiAqIFwiK2NbMV0rXCIpO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgICB9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzIgcmMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIHNldE91dHB1dChkb3QyeDJBUm93QkNvbChyYykpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLE11bHRpbm9taWFsUHJvZ3JhbT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0LHIpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJwcm9ic1wiXSx0aGlzLm91dHB1dFNoYXBlPVtlLHJdLHRoaXMudXNlckNvZGU9XCJcXG4gICAgICB1bmlmb3JtIGZsb2F0IHNlZWQ7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHNbMF07XFxuXFxuICAgICAgICBmbG9hdCByID0gcmFuZG9tKHNlZWQpO1xcbiAgICAgICAgZmxvYXQgY2RmID0gMC4wO1xcblxcbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBcIisodC0xKStcIjsgaSsrKSB7XFxuICAgICAgICAgIGNkZiArPSBnZXRQcm9icyhiYXRjaCwgaSk7XFxuXFxuICAgICAgICAgIGlmIChyIDwgY2RmKSB7XFxuICAgICAgICAgICAgc2V0T3V0cHV0KGZsb2F0KGkpKTtcXG4gICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC8vIElmIG5vIG90aGVyIGV2ZW50IGhhcHBlbmVkLCBsYXN0IGV2ZW50IGhhcHBlbmVkLlxcbiAgICAgICAgc2V0T3V0cHV0KGZsb2F0KFwiKyh0LTEpK1wiKSk7XFxuICAgICAgfVxcbiAgICBcIn1yZXR1cm4gZS5wcm90b3R5cGUuZ2V0Q3VzdG9tU2V0dXBGdW5jPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7cmV0dXJuIGZ1bmN0aW9uKHIsbil7bnVsbD09dC5zZWVkTG9jJiYodC5zZWVkTG9jPXIuZ2V0VW5pZm9ybUxvY2F0aW9uKG4sXCJzZWVkXCIpKSxyLmdsLnVuaWZvcm0xZih0LnNlZWRMb2MsZSl9fSxlfSgpLE9uZUhvdFByb2dyYW09ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oZSx0LHIsbil7dGhpcy52YXJpYWJsZU5hbWVzPVtcImluZGljZXNcIl0sdGhpcy5vdXRwdXRTaGFwZT1bZSx0XSx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgaW5kZXggPSByb3VuZChnZXRJbmRpY2VzKGNvb3Jkcy54KSk7XFxuICAgICAgICBzZXRPdXRwdXQobWl4KGZsb2F0KFwiK24rXCIpLCBmbG9hdChcIityK1wiKSxcXG4gICAgICAgICAgICAgICAgICAgICAgZmxvYXQoaW5kZXggPT0gY29vcmRzLnkpKSk7XFxuICAgICAgfVxcbiAgICBcIn19KCk7ZnVuY3Rpb24gZ2V0VmVjQ2hhbm5lbHMoZSx0KXtyZXR1cm5bXCJ4XCIsXCJ5XCIsXCJ6XCIsXCJ3XCIsXCJ1XCIsXCJ2XCJdLnNsaWNlKDAsdCkubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBlK1wiLlwiK3R9KX1mdW5jdGlvbiBnZXRDaGFubmVscyhlLHQpe3JldHVybiAxPT09dD9bZV06Z2V0VmVjQ2hhbm5lbHMoZSx0KX1mdW5jdGlvbiBnZXRTb3VyY2VDb29yZHMkMShlLHQpe2lmKDE9PT1lKXJldHVyblwicmNcIjtmb3IodmFyIHI9XCJcIixuPTA7bjxlO24rKylyKz10W25dLG48ZS0xJiYocis9XCIsXCIpO3JldHVybiByfXZhciBQYWNrUHJvZ3JhbT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihlKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXSx0aGlzLm91dHB1dFNoYXBlPWU7dmFyIHQ9ZS5sZW5ndGgscj1nZXRDaGFubmVscyhcInJjXCIsdCksbj1nZXRDb29yZHNEYXRhVHlwZSh0KSxvPWdldE91dE9mQm91bmRzQ29uZGl0aW9uKHQsZSxyKSxhPWdldFNldHVwKHQsZVtlLmxlbmd0aC0xXSxlW2UubGVuZ3RoLTJdLHIpLGk9Z2V0T3V0cHV0KGUscik7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIFwiK24rXCIgcmMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG5cXG4gICAgICAgIGlmKFwiK28rXCIpIHtcXG4gICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIFwiK2ErXCJcXG5cXG4gICAgICAgICAgc2V0T3V0cHV0KHZlYzQoXCIraStcIikpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgXCJ9fSgpO2Z1bmN0aW9uIGdldFNvdXJjZUNvb3Jkc0FycihlLHQpe2Zvcih2YXIgcj1bXSxuPTA7bjw9MTtuKyspZm9yKHZhciBvPTA7bzw9MTtvKyspe2Zvcih2YXIgYT0oMD09PW4/XCJyXCI6XCJycDFcIikrXCIsIFwiKygwPT09bz9cImNcIjpcImNwMVwiKSxpPTI7aTxlO2krKylhPXRbdC5sZW5ndGgtMS1pXStcIixcIithO3IucHVzaChhKX1yZXR1cm4gcn1mdW5jdGlvbiBnZXRPdXRPZkJvdW5kc0NvbmRpdGlvbihlLHQscil7aWYoMT09PWUpcmV0dXJuXCJyYyA+IFwiK3RbMF07Zm9yKHZhciBuPVwiXCIsbz1lLTI7bzxlO28rKyluKz1yW29dK1wiID49IFwiK3Rbb10sbzxlLTEmJihuKz1cInx8XCIpO3JldHVybiBufWZ1bmN0aW9uIGdldFNldHVwKGUsdCxyLG4pe2lmKDE9PT1lKXJldHVyblwiXCI7dmFyIG89bi5zbGljZSgtMik7cmV0dXJuXCJcXG4gICAgaW50IHIgPSBcIitvWzBdK1wiO1xcbiAgICBpbnQgYyA9IFwiK29bMV0rXCI7XFxuICAgIGludCBycDEgPSByICsgMTtcXG4gICAgaW50IGNwMSA9IGMgKyAxO1xcblxcbiAgICBib29sIGNFZGdlID0gY3AxID49IFwiK3QrXCI7XFxuICAgIGJvb2wgckVkZ2UgPSBycDEgPj0gXCIrcitcIjtcXG4gIFwifWZ1bmN0aW9uIGdldE91dHB1dChlLHQpe3ZhciByPWUubGVuZ3RoLG49Z2V0U291cmNlQ29vcmRzQXJyKHIsdCk7cmV0dXJuIDE9PT1yP1wiZ2V0QShyYyksXFxuICAgICAgICAgICAgcmMgKyAxID49IFwiK2VbMF0rXCIgPyAwLiA6IGdldEEocmMgKyAxKSxcXG4gICAgICAgICAgICAwLCAwXCI6XCJnZXRBKFwiK25bMF0rXCIpLFxcbiAgICAgICAgICBjRWRnZSA/IDAuIDogZ2V0QShcIituWzFdK1wiKSxcXG4gICAgICAgICAgckVkZ2UgPyAwLiA6IGdldEEoXCIrblsyXStcIiksXFxuICAgICAgICAgIHJFZGdlIHx8IGNFZGdlID8gMC4gOiBnZXRBKFwiK25bM10rXCIpXCJ9dmFyIFBhZFByb2dyYW09ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oZSx0LHIpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCJdLHRoaXMub3V0cHV0U2hhcGU9dC5tYXAoZnVuY3Rpb24odCxyKXtyZXR1cm4gdFswXStlW3JdK3RbMV19KTt2YXIgbj1lLmxlbmd0aCxvPWdldENvb3Jkc0RhdGFUeXBlKG4pLGE9dC5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGVbMF19KS5qb2luKFwiLFwiKSxpPXQubWFwKGZ1bmN0aW9uKHQscil7cmV0dXJuIHRbMF0rZVtyXX0pLmpvaW4oXCIsXCIpLHM9W1wiY29vcmRzWzBdXCIsXCJjb29yZHNbMV1cIixcImNvb3Jkc1syXVwiLFwiY29vcmRzWzNdXCJdLnNsaWNlKDAsbik7dGhpcy51c2VyQ29kZT0xIT09bj9cIlxcbiAgICAgIFwiK28rXCIgc3RhcnQgPSBcIitvK1wiKFwiK2ErXCIpO1xcbiAgICAgIFwiK28rXCIgZW5kID0gXCIrbytcIihcIitpK1wiKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBcIitvK1wiIG91dEMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGlmIChhbnkobGVzc1RoYW4ob3V0Qywgc3RhcnQpKSB8fCBhbnkoZ3JlYXRlclRoYW5FcXVhbChvdXRDLCBlbmQpKSkge1xcbiAgICAgICAgICBzZXRPdXRwdXQoZmxvYXQoXCIrcitcIikpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgXCIrbytcIiBjb29yZHMgPSBvdXRDIC0gc3RhcnQ7XFxuICAgICAgICAgIHNldE91dHB1dChnZXRYKFwiK3MrXCIpKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIFwiOlwiXFxuICAgICAgICBpbnQgc3RhcnQgPSBcIithK1wiO1xcbiAgICAgICAgaW50IGVuZCA9IFwiK2krXCI7XFxuXFxuICAgICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgIGludCBvdXRDID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICAgIGlmIChvdXRDIDwgc3RhcnQgfHwgb3V0QyA+PSBlbmQpIHtcXG4gICAgICAgICAgICBzZXRPdXRwdXQoZmxvYXQoXCIrcitcIikpO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHNldE91dHB1dChnZXRYKG91dEMgLSBzdGFydCkpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgXCJ9fSgpLFBvb2wyRFByb2dyYW09ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oZSx0LHIpe2lmKHRoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCJdLFwiYXZnXCI9PT10JiZyKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb21wdXRlIHBvc2l0aW9ucyBmb3IgYXZlcmFnZSBwb29sLlwiKTt2YXIgbj1lLmZpbHRlcldpZHRoLG89ZS5zdHJpZGVIZWlnaHQsYT1lLnN0cmlkZVdpZHRoLGk9ZS5kaWxhdGlvbkhlaWdodCxzPWUuZGlsYXRpb25XaWR0aCx1PWUuZWZmZWN0aXZlRmlsdGVySGVpZ2h0LGw9ZS5lZmZlY3RpdmVGaWx0ZXJXaWR0aCxjPWUucGFkSW5mby50b3AscD1lLnBhZEluZm8ubGVmdDt0aGlzLm91dHB1dFNoYXBlPWUub3V0U2hhcGU7dmFyIGQ9XCJhdmdcIj09PXQsaD1cIjAuMFwiO2lmKGR8fChoPVwiLTEuMCAvIDAuMFwiKSxyKXRoaXMudXNlckNvZGU9XCJcXG4gICAgICAgIGNvbnN0IGl2ZWMyIHN0cmlkZXMgPSBpdmVjMihcIitvK1wiLCBcIithK1wiKTtcXG4gICAgICAgIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMihcIitjK1wiLCBcIitwK1wiKTtcXG5cXG4gICAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICAgIGludCBiYXRjaCA9IGNvb3Jkc1swXTtcXG4gICAgICAgICAgaW50IGQgPSBjb29yZHNbM107XFxuXFxuICAgICAgICAgIGl2ZWMyIHhSQ0Nvcm5lciA9IGNvb3Jkcy55eiAqIHN0cmlkZXMgLSBwYWRzO1xcbiAgICAgICAgICBpbnQgeFJDb3JuZXIgPSB4UkNDb3JuZXIueDtcXG4gICAgICAgICAgaW50IHhDQ29ybmVyID0geFJDQ29ybmVyLnk7XFxuXFxuICAgICAgICAgIC8vIG1heC9taW4geCg/LCA/LCBkKSB0byBnZXQgeSh5UiwgeUMsIGQpLlxcbiAgICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZFxcbiAgICAgICAgICBmbG9hdCBtaW5NYXhWYWx1ZSA9IDAuMDtcXG4gICAgICAgICAgZmxvYXQgbWluTWF4VmFsdWVGb3VuZCA9IDAuMDtcXG4gICAgICAgICAgaW50IG1pbk1heFBvc2l0aW9uID0gMDtcXG4gICAgICAgICAgZmxvYXQgYXZnVmFsdWUgPSAwLjA7XFxuXFxuICAgICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCBcIit1K1wiO1xcbiAgICAgICAgICAgICAgd1IgKz0gXCIraStcIikge1xcbiAgICAgICAgICAgIGludCB4UiA9IHhSQ29ybmVyICsgd1I7XFxuXFxuICAgICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSBcIitlLmluSGVpZ2h0K1wiKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8IFwiK2wrXCI7XFxuICAgICAgICAgICAgICAgIHdDICs9IFwiK3MrXCIpIHtcXG4gICAgICAgICAgICAgIGludCB4QyA9IHhDQ29ybmVyICsgd0M7XFxuXFxuICAgICAgICAgICAgICBpZiAoeEMgPCAwIHx8IHhDID49IFwiK2UuaW5XaWR0aCtcIikge1xcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgIGZsb2F0IHZhbHVlID0gZ2V0WChiYXRjaCwgeFIsIHhDLCBkKTtcXG5cXG4gICAgICAgICAgICAgIC8vIElmIGEgbWluIC8gbWF4IHZhbHVlIGhhcyBhbHJlYWR5IGJlZW4gZm91bmQsIHVzZSBpdC4gSWYgbm90LFxcbiAgICAgICAgICAgICAgLy8gdXNlIHRoZSBjdXJyZW50IHZhbHVlLlxcbiAgICAgICAgICAgICAgZmxvYXQgY3Vyck1pbk1heFZhbHVlID0gbWl4KFxcbiAgICAgICAgICAgICAgICAgIHZhbHVlLCBtaW5NYXhWYWx1ZSwgbWluTWF4VmFsdWVGb3VuZCk7XFxuICAgICAgICAgICAgICBpZiAodmFsdWUgPj0gY3Vyck1pbk1heFZhbHVlKSB7XFxuICAgICAgICAgICAgICAgIG1pbk1heFZhbHVlID0gdmFsdWU7XFxuICAgICAgICAgICAgICAgIG1pbk1heFZhbHVlRm91bmQgPSAxLjA7XFxuICAgICAgICAgICAgICAgIG1pbk1heFBvc2l0aW9uID0gd1IgKiBcIitsK1wiICsgd0M7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICAgIHNldE91dHB1dChmbG9hdChtaW5NYXhQb3NpdGlvbikpO1xcbiAgICAgICAgfVxcbiAgICAgIFwiO2Vsc2V7dmFyIGY9dCtcIihcIit0K1wiKFwiK3QrXCIobWluTWF4VmFsdWVbMF0sIG1pbk1heFZhbHVlWzFdKSwgbWluTWF4VmFsdWVbMl0pLCBtaW5NYXhWYWx1ZVszXSlcIjtcImF2Z1wiPT09dCYmKGY9XCJhdmdWYWx1ZSAvIGNvdW50XCIpO3ZhciBtPTQqTWF0aC5mbG9vcihuLzQpLGc9biU0LHY9XCJcXG4gICAgICBpZiAoXCIrZCtcIikge1xcbiAgICAgICAgYXZnVmFsdWUgKz0gZG90KHZhbHVlcywgb25lcyk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIG1pbk1heFZhbHVlID0gbWF4KHZhbHVlcywgbWluTWF4VmFsdWUpO1xcbiAgICAgIH1cXG4gICAgXCI7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGNvbnN0IGl2ZWMyIHN0cmlkZXMgPSBpdmVjMihcIitvK1wiLCBcIithK1wiKTtcXG4gICAgICBjb25zdCBpdmVjMiBwYWRzID0gaXZlYzIoXCIrYytcIiwgXCIrcCtcIik7XFxuICAgICAgY29uc3QgZmxvYXQgaW5pdGlhbGl6YXRpb25WYWx1ZSA9IFwiK2grXCI7XFxuICAgICAgY29uc3QgdmVjNCBvbmVzID0gdmVjNCgxLjAsIDEuMCwgMS4wLCAxLjApO1xcblxcbiAgICAgIGZsb2F0IGNvdW50ID0gMC4wO1xcblxcbiAgICAgIGZsb2F0IGdldFZhbHVlKGludCBiYXRjaCwgaW50IHhSLCBpbnQgeEMsIGludCBkKSB7XFxuICAgICAgICBpZiAoeEMgPCAwIHx8IHhDID49IFwiK2UuaW5XaWR0aCtcIikge1xcbiAgICAgICAgICByZXR1cm4gaW5pdGlhbGl6YXRpb25WYWx1ZTtcXG4gICAgICAgIH1cXG4gICAgICAgIGNvdW50ICs9IDEuMDtcXG4gICAgICAgIHJldHVybiBnZXRYKGJhdGNoLCB4UiwgeEMsIGQpO1xcbiAgICAgIH1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBkID0gY29vcmRzWzNdO1xcblxcbiAgICAgICAgaXZlYzIgeFJDQ29ybmVyID0gY29vcmRzLnl6ICogc3RyaWRlcyAtIHBhZHM7XFxuICAgICAgICBpbnQgeFJDb3JuZXIgPSB4UkNDb3JuZXIueDtcXG4gICAgICAgIGludCB4Q0Nvcm5lciA9IHhSQ0Nvcm5lci55O1xcblxcbiAgICAgICAgLy8gbWF4L21pbiB4KD8sID8sIGQpIHRvIGdldCB5KHlSLCB5QywgZCkuXFxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZFxcbiAgICAgICAgdmVjNCBtaW5NYXhWYWx1ZSA9IHZlYzQoXCIraCtcIik7XFxuICAgICAgICBmbG9hdCBhdmdWYWx1ZSA9IDAuMDtcXG4gICAgICAgIGNvdW50ID0gMC4wO1xcblxcbiAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8IFwiK3UrXCI7XFxuICAgICAgICAgICAgd1IgKz0gXCIraStcIikge1xcbiAgICAgICAgICBpbnQgeFIgPSB4UkNvcm5lciArIHdSO1xcblxcbiAgICAgICAgICBpZiAoeFIgPCAwIHx8IHhSID49IFwiK2UuaW5IZWlnaHQrXCIpIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgXCIrbStcIjsgd0MgKz0gNCkge1xcbiAgICAgICAgICAgIGludCB4QyA9IHhDQ29ybmVyICsgd0MgKiBcIitzK1wiO1xcblxcbiAgICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4UiwgeEMsIGQpLFxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhSLCB4QyArIFwiK3MrXCIsIGQpLFxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhSLCB4QyArIDIgKiBcIitzK1wiLCBkKSxcXG4gICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4UiwgeEMgKyAzICogXCIrcytcIiwgZClcXG4gICAgICAgICAgICApO1xcblxcbiAgICAgICAgICAgIFwiK3YrXCJcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpbnQgeEMgPSB4Q0Nvcm5lciArIFwiK20rXCI7XFxuICAgICAgICAgIGlmIChcIisoMT09PWcpK1wiKSB7XFxuICAgICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhSLCB4QywgZCksXFxuICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlLFxcbiAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcXG4gICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcXG4gICAgICAgICAgICApO1xcblxcbiAgICAgICAgICAgIFwiK3YrXCJcXG4gICAgICAgICAgfSBlbHNlIGlmIChcIisoMj09PWcpK1wiKSB7XFxuICAgICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhSLCB4QywgZCksXFxuICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeFIsIHhDICsgXCIrcytcIiwgZCksXFxuICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlLFxcbiAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxcbiAgICAgICAgICAgICk7XFxuXFxuICAgICAgICAgICAgXCIrditcIlxcbiAgICAgICAgICB9IGVsc2UgaWYgKFwiKygzPT09ZykrXCIpIHtcXG4gICAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeFIsIHhDLCBkKSxcXG4gICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4UiwgeEMgKyBcIitzK1wiLCBkKSxcXG4gICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4UiwgeEMgKyAyICogXCIrcytcIiwgZCksXFxuICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlXFxuICAgICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgICBcIit2K1wiXFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChcIitmK1wiKTtcXG4gICAgICB9XFxuICAgIFwifX19KCksUmVkdWNlUHJvZ3JhbT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihlLHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCJdO3ZhciByPWUud2luZG93U2l6ZSxuPWUuYmF0Y2hTaXplLG89ZS5pblNpemUsYT1NYXRoLmNlaWwoby9yKTt0aGlzLm91dHB1dFNoYXBlPVtuLGFdO3ZhciBpPVwiMC4wXCIscz1cIlwiO1wicHJvZFwiPT09dD9pPVwiMS4wXCI6XCJtaW5cIj09PXQ/KGk9XCIxLjAgLyAwLjBcIixzPVwibWluXCIpOlwibWF4XCI9PT10JiYoaT1cIi0xLjAgLyAwLjBcIixzPVwibWF4XCIpO3ZhciB1PXQrXCIoXCIrdCtcIihcIit0K1wiKG1pbk1heFZhbHVlWzBdLCBtaW5NYXhWYWx1ZVsxXSksIG1pbk1heFZhbHVlWzJdKSwgbWluTWF4VmFsdWVbM10pXCI7XCJzdW1cIj09PXQ/dT1cInN1bVZhbHVlXCI6XCJwcm9kXCI9PT10P3U9XCJwcm9kVmFsdWVcIjpcImFsbFwiPT09dD91PVwiYWxsVmFsdWVcIjpcImFueVwiPT09dCYmKHU9XCJhbnlWYWx1ZVwiKTt2YXIgbD00Kk1hdGguZmxvb3Ioci80KSxjPXIlNCxwPVwiXFxuICAgICAgaWYgKFwiKyhcInN1bVwiPT09dCkrXCIpIHtcXG4gICAgICAgIHN1bVZhbHVlICs9IGRvdCh2YWx1ZXMsIG9uZXMpO1xcbiAgICAgIH0gZWxzZSBpZiAoXCIrKFwicHJvZFwiPT09dCkrXCIpIHtcXG4gICAgICAgIHZlYzIgdG1wID0gdmVjMih2YWx1ZXNbMF0sIHZhbHVlc1sxXSkgKiB2ZWMyKHZhbHVlc1syXSwgdmFsdWVzWzNdKTtcXG4gICAgICAgIHByb2RWYWx1ZSAqPSB0bXBbMF0gKiB0bXBbMV07XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIG1pbk1heFZhbHVlID0gXCIrcytcIih2YWx1ZXMsIG1pbk1heFZhbHVlKTtcXG4gICAgICB9XFxuICAgIFwiLGQ9XCJ2ZWM0XCI7XCJhbGxcIj09PXQ/KGk9XCIxLjBcIixwPVwiXFxuICAgICAgICBib29sIHJlZHVjZWRBbGxWYWx1ZSA9IGFsbCh2YWx1ZXMpO1xcbiAgICAgICAgZmxvYXQgZmxvYXRlZFJlZHVjZWRBbGxWYWx1ZSA9IGZsb2F0KHJlZHVjZWRBbGxWYWx1ZSk7XFxuICAgICAgICBhbGxWYWx1ZSA9IGZsb2F0KGFsbFZhbHVlID49IDEuMCAmJiBmbG9hdGVkUmVkdWNlZEFsbFZhbHVlID49IDEuMCk7XFxuICAgICAgXCIsZD1cImJ2ZWM0XCIpOlwiYW55XCI9PT10JiYoaT1cIjAuMFwiLHA9XCJcXG4gICAgICAgIGJvb2wgcmVkdWNlZEFueVZhbHVlID0gYW55KHZhbHVlcyk7XFxuICAgICAgICBmbG9hdCBmbG9hdGVkUmVkdWNlZEFueVZhbHVlID0gZmxvYXQocmVkdWNlZEFueVZhbHVlKTtcXG4gICAgICAgIGFueVZhbHVlID0gZmxvYXQoYW55VmFsdWUgPj0gMS4wIHx8IGZsb2F0ZWRSZWR1Y2VkQW55VmFsdWUgPj0gMS4wKTtcXG4gICAgICBcIixkPVwiYnZlYzRcIik7dmFyIGg9XCJcIjtvJXI+MCYmKGg9XCJcXG4gICAgICAgIGlmIChpbklkeCA8IDAgfHwgaW5JZHggPj0gXCIrbytcIikge1xcbiAgICAgICAgICByZXR1cm4gaW5pdGlhbGl6YXRpb25WYWx1ZTtcXG4gICAgICAgIH1cXG4gICAgICBcIiksdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGNvbnN0IGZsb2F0IGluaXRpYWxpemF0aW9uVmFsdWUgPSBcIitpK1wiO1xcbiAgICAgIGNvbnN0IHZlYzQgb25lcyA9IHZlYzQoMS4wLCAxLjAsIDEuMCwgMS4wKTtcXG5cXG4gICAgICBmbG9hdCBnZXRWYWx1ZShpbnQgYmF0Y2gsIGludCBpbklkeCkge1xcbiAgICAgICAgXCIraCtcIlxcbiAgICAgICAgcmV0dXJuIGdldFgoYmF0Y2gsIGluSWR4KTtcXG4gICAgICB9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgb3V0SWR4ID0gY29vcmRzWzFdO1xcbiAgICAgICAgaW50IGluT2Zmc2V0ID0gb3V0SWR4ICogXCIrcitcIjtcXG5cXG4gICAgICAgIHZlYzQgbWluTWF4VmFsdWUgPSB2ZWM0KFwiK2krXCIpO1xcbiAgICAgICAgZmxvYXQgcHJvZFZhbHVlID0gMS4wO1xcbiAgICAgICAgZmxvYXQgc3VtVmFsdWUgPSAwLjA7XFxuICAgICAgICBmbG9hdCBhbGxWYWx1ZSA9IDEuMDtcXG4gICAgICAgIGZsb2F0IGFueVZhbHVlID0gMC4wO1xcblxcbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBcIitsK1wiOyBpICs9IDQpIHtcXG4gICAgICAgICAgaW50IGluSWR4ID0gaW5PZmZzZXQgKyBpO1xcbiAgICAgICAgICBcIitkK1wiIHZhbHVlcyA9IFwiK2QrXCIoXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4KSxcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAxKSxcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAyKSxcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAzKVxcbiAgICAgICAgICApO1xcblxcbiAgICAgICAgICBcIitwK1wiXFxuICAgICAgICB9XFxuXFxuICAgICAgICBpbnQgaW5JZHggPSBpbk9mZnNldCArIFwiK2wrXCI7XFxuICAgICAgICBpZiAoXCIrKDE9PT1jKStcIikge1xcbiAgICAgICAgICBcIitkK1wiIHZhbHVlcyA9IFwiK2QrXCIoXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4KSxcXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlLFxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUsXFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxcbiAgICAgICAgICApO1xcblxcbiAgICAgICAgICBcIitwK1wiXFxuICAgICAgICB9IGVsc2UgaWYgKFwiKygyPT09YykrXCIpIHtcXG4gICAgICAgICAgXCIrZCtcIiB2YWx1ZXMgPSBcIitkK1wiKFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCksXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4ICsgMSksXFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlXFxuICAgICAgICAgICk7XFxuXFxuICAgICAgICAgIFwiK3ArXCJcXG4gICAgICAgIH0gZWxzZSBpZiAoXCIrKDM9PT1jKStcIikge1xcbiAgICAgICAgICBcIitkK1wiIHZhbHVlcyA9IFwiK2QrXCIoXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4KSxcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAxKSxcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAyKSxcXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlXFxuICAgICAgICAgICk7XFxuXFxuICAgICAgICAgIFwiK3ArXCJcXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChcIit1K1wiKTtcXG4gICAgICB9XFxuICAgIFwifX0oKSxSZXNoYXBlUGFja2VkUHJvZ3JhbT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihlLHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdLHRoaXMudXNlc1BhY2tlZFRleHR1cmVzPSEwLHRoaXMub3V0cHV0U2hhcGU9ZTtmb3IodmFyIHI9XCJcIixuPTA7bjw0O24rKyl7dmFyIG89XCJ0aGlzUkMgPSByYztcIjtuJTI9PTEmJihvKz1cInRoaXNSQy56ICs9IDE7XCIpLG4+MSYmKG8rPVwidGhpc1JDLnkgKz0gMTtcIikscis9XCJcXG4gICAgICAgIFwiK28rXCJcXG4gICAgICAgIFwiKyhuPjA/XCJpZih0aGlzUkMueSA8IHJvd3MgJiYgdGhpc1JDLnogPCBjb2xzKXtcIjpcIlwiKStcIlxcbiAgICAgICAgICBpbnQgZmxhdEluZGV4ID0gZ2V0RmxhdEluZGV4KHRoaXNSQyk7XFxuXFxuICAgICAgICAgIGl2ZWMzIGlucHV0UkMgPSBpbnB1dENvb3Jkc0Zyb21SZXNoYXBlZE91dENvb3JkcyhmbGF0SW5kZXgpO1xcbiAgICAgICAgICB2ZWMyIGlucHV0UkNJbm5lckRpbXMgPSB2ZWMyKGZsb2F0KGlucHV0UkMueSksZmxvYXQoaW5wdXRSQy56KSk7XFxuXFxuICAgICAgICAgIHJlc3VsdFtcIituK1wiXSA9XFxuICAgICAgICAgICAgZ2V0Q2hhbm5lbChnZXRBKGlucHV0UkMueCwgaW5wdXRSQy55LCBpbnB1dFJDLnopLCBpbnB1dFJDSW5uZXJEaW1zKTtcXG4gICAgICAgIFwiKyhuPjA/XCJ9XCI6XCJcIikrXCJcXG4gICAgICBcIn10aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgXCIrZ2V0UmVzaGFwZWRJbnB1dENvb3Jkcyh0KStcIlxcbiAgICAgIFwiK2dldEZsYXRJbmRleChlKStcIlxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMzIHJjID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuXFxuICAgICAgICB2ZWM0IHJlc3VsdCA9IHZlYzQoMC4pO1xcblxcbiAgICAgICAgaXZlYzMgdGhpc1JDO1xcbiAgICAgICAgaW50IHJvd3MgPSBcIitlWzFdK1wiO1xcbiAgICAgICAgaW50IGNvbHMgPSBcIitlWzJdK1wiO1xcblxcbiAgICAgICAgXCIrcitcIlxcblxcbiAgICAgICAgc2V0T3V0cHV0KHJlc3VsdCk7XFxuICAgICAgfVxcbiAgICBcIn19KCk7ZnVuY3Rpb24gZ2V0RmxhdEluZGV4KGUpe3JldHVyblwiXFxuICAgIGludCBnZXRGbGF0SW5kZXgoaXZlYzMgY29vcmRzKSB7XFxuICAgICAgcmV0dXJuIHJvdW5kKFwiK2RvdGlmeShbXCJjb29yZHMueFwiLFwiY29vcmRzLnlcIixcImNvb3Jkcy56XCJdLGNvbXB1dGVTdHJpZGVzKGUpLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS50b1N0cmluZygpfSkuY29uY2F0KFtcIjEuXCJdKSkrXCIpO1xcbiAgICB9XFxuICBcIn1mdW5jdGlvbiBnZXRSZXNoYXBlZElucHV0Q29vcmRzKGUpe3JldHVyblwiXFxuICAgIGl2ZWMzIGlucHV0Q29vcmRzRnJvbVJlc2hhcGVkT3V0Q29vcmRzKGludCBpbmRleCkge1xcbiAgICAgIFwiK2dldExvZ2ljYWxDb29yZGluYXRlc0Zyb21GbGF0SW5kZXgoW1wiclwiLFwiY1wiLFwiZFwiXSxlKStcIlxcbiAgICAgIHJldHVybiBpdmVjMyhyLCBjLCBkKTtcXG4gICAgfVxcbiAgXCJ9dmFyIFJlc2l6ZUJpbGluZWFyQmFja3Byb3BQcm9ncmFtPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKGUsdCxyKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiZHlcIl0sdGhpcy5vdXRwdXRTaGFwZT1bXSx0aGlzLm91dHB1dFNoYXBlPXQuc2hhcGU7dmFyIG49dC5zaGFwZSxvPW5bMV0sYT1uWzJdLGk9ZS5zaGFwZSxzPWlbMV0sdT1pWzJdLGw9W3ImJnM+MT9vLTE6byxyJiZ1PjE/YS0xOmFdLGM9W3ImJnM+MT9zLTE6cyxyJiZ1PjE/dS0xOnVdLHA9bFswXS9jWzBdLGQ9bFsxXS9jWzFdLGg9MS9wLGY9MS9kLG09MipNYXRoLmNlaWwoaCkrMixnPTIqTWF0aC5jZWlsKGYpKzI7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGIgPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgZCA9IGNvb3Jkc1szXTtcXG4gICAgICAgIGludCByID0gY29vcmRzWzFdO1xcbiAgICAgICAgaW50IGMgPSBjb29yZHNbMl07XFxuXFxuICAgICAgICBmbG9hdCBhY2N1bXVsYXRvciA9IDAuMDtcXG5cXG4gICAgICAgIGNvbnN0IGZsb2F0IGhlaWdodFNjYWxlID0gZmxvYXQoXCIrcCtcIik7XFxuICAgICAgICBjb25zdCBmbG9hdCB3aWR0aFNjYWxlID0gZmxvYXQoXCIrZCtcIik7XFxuXFxuICAgICAgICBjb25zdCBmbG9hdCBpbnZIZWlnaHRTY2FsZSA9IGZsb2F0KFwiK2grXCIpO1xcbiAgICAgICAgY29uc3QgZmxvYXQgaW52V2lkdGhTY2FsZSA9IGZsb2F0KFwiK2YrXCIpO1xcblxcbiAgICAgICAgY29uc3QgaW50IHdpbkhlaWdodCA9IGludChcIittK1wiKTtcXG4gICAgICAgIGNvbnN0IGludCB3aW5XaWR0aCA9IGludChcIitnK1wiKTtcXG5cXG4gICAgICAgIC8vIENvbXB1dGUgYm91bmRzIGZvciB3aGVyZSBpbiBkeSB3ZSB3aWxsIGxvb2tcXG4gICAgICAgIGZsb2F0IHN0YXJ0UkxlcnAgPSBmbG9vcihmbG9hdChyKSAqIGludkhlaWdodFNjYWxlKTtcXG4gICAgICAgIGludCBzdGFydER5UiA9IGludChzdGFydFJMZXJwIC0gZmxvYXQod2luSGVpZ2h0IC8gMikpO1xcblxcbiAgICAgICAgZmxvYXQgc3RhcnRDTGVycCA9IGZsb29yKGZsb2F0KGMpICogaW52V2lkdGhTY2FsZSk7XFxuICAgICAgICBpbnQgc3RhcnREeUMgPSBpbnQoc3RhcnRDTGVycCAtIGZsb2F0KHdpbldpZHRoIC8gMikpO1xcblxcbiAgICAgICAgLy8gTG9vcCBvdmVyIGR5XFxuICAgICAgICBmb3IgKGludCBkeVJPZmZzZXQgPSAwOyBkeVJPZmZzZXQgPCB3aW5IZWlnaHQ7IGR5Uk9mZnNldCsrKSB7XFxuICAgICAgICAgIGludCBkeVIgPSBkeVJPZmZzZXQgKyBzdGFydER5UjtcXG5cXG4gICAgICAgICAgLy8gR3VhcmQgYWdhaW5zdCB0aGUgd2luZG93IGV4Y2VlZGluZyB0aGUgYm91bmRzIG9mIGR5XFxuICAgICAgICAgIGlmIChkeVIgPCAwIHx8IGR5UiA+PSBcIitzK1wiKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZm9yIChpbnQgZHlDT2Zmc2V0ID0gMDsgZHlDT2Zmc2V0IDwgd2luV2lkdGg7IGR5Q09mZnNldCsrKSB7XFxuICAgICAgICAgICAgaW50IGR5QyA9IGR5Q09mZnNldCArIHN0YXJ0RHlDO1xcblxcbiAgICAgICAgICAgIC8vIEd1YXJkIGFnYWluc3QgdGhlIHdpbmRvdyBleGNlZWRpbmcgdGhlIGJvdW5kcyBvZiBkeVxcbiAgICAgICAgICAgIGlmIChkeUMgPCAwIHx8IGR5QyA+PSBcIit1K1wiKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgZmxvYXQgZHhSID0gZmxvYXQoZHlSKSAqIGhlaWdodFNjYWxlO1xcbiAgICAgICAgICAgIGludCB0b3BEeFJJbmRleCA9IGludChmbG9vcihkeFIpKTtcXG4gICAgICAgICAgICBpbnQgYm90dG9tRHhSSW5kZXggPSBpbnQobWluKGNlaWwoZHhSKSwgXCIrKG8tMSkrXCIuMCkpO1xcbiAgICAgICAgICAgIGZsb2F0IGR4UkxlcnAgPSBkeFIgLSBmbG9hdCh0b3BEeFJJbmRleCk7XFxuICAgICAgICAgICAgZmxvYXQgaW52ZXJzZUR4UkxlcnAgPSAxLjAgLSBkeFJMZXJwO1xcblxcbiAgICAgICAgICAgIGZsb2F0IGR4QyA9IGZsb2F0KGR5QykgKiB3aWR0aFNjYWxlO1xcbiAgICAgICAgICAgIGludCBsZWZ0RHhDSW5kZXggPSBpbnQoZmxvb3IoZHhDKSk7XFxuICAgICAgICAgICAgaW50IHJpZ2h0RHhDSW5kZXggPSBpbnQobWluKGNlaWwoZHhDKSwgXCIrKGEtMSkrXCIuMCkpO1xcbiAgICAgICAgICAgIGZsb2F0IGR4Q0xlcnAgPSBkeEMgLSBmbG9hdChsZWZ0RHhDSW5kZXgpO1xcbiAgICAgICAgICAgIGZsb2F0IGludmVyc2VEeENMZXJwID0gMS4wIC0gZHhDTGVycDtcXG5cXG4gICAgICAgICAgICBpZiAociA9PSB0b3BEeFJJbmRleCAmJiBjID09IGxlZnREeENJbmRleCkge1xcbiAgICAgICAgICAgICAgLy8gdG9wTGVmdFxcbiAgICAgICAgICAgICAgYWNjdW11bGF0b3IgKz1cXG4gICAgICAgICAgICAgICAgZ2V0RHkoYiwgZHlSLCBkeUMsIGQpICogaW52ZXJzZUR4UkxlcnAgKiBpbnZlcnNlRHhDTGVycDtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKHIgPT0gdG9wRHhSSW5kZXggJiYgYyA9PSByaWdodER4Q0luZGV4KSB7XFxuICAgICAgICAgICAgICAvLyB0b3BSaWdodFxcbiAgICAgICAgICAgICAgYWNjdW11bGF0b3IgKz0gZ2V0RHkoYiwgZHlSLCBkeUMsIGQpICogaW52ZXJzZUR4UkxlcnAgKiBkeENMZXJwO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAociA9PSBib3R0b21EeFJJbmRleCAmJiBjID09IGxlZnREeENJbmRleCkge1xcbiAgICAgICAgICAgICAgLy8gYm90dG9tTGVmdFxcbiAgICAgICAgICAgICAgYWNjdW11bGF0b3IgKz0gZ2V0RHkoYiwgZHlSLCBkeUMsIGQpICogZHhSTGVycCAqIGludmVyc2VEeENMZXJwO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAociA9PSBib3R0b21EeFJJbmRleCAmJiBjID09IHJpZ2h0RHhDSW5kZXgpIHtcXG4gICAgICAgICAgICAgIC8vIGJvdHRvbVJpZ2h0XFxuICAgICAgICAgICAgICBhY2N1bXVsYXRvciArPSBnZXREeShiLCBkeVIsIGR5QywgZCkgKiBkeFJMZXJwICogZHhDTGVycDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIC8vIEVuZCBsb29wIG92ZXIgZHlcXG5cXG4gICAgICAgIHNldE91dHB1dChhY2N1bXVsYXRvcik7XFxuICAgICAgfVxcbiAgICBcIn19KCksUmVzaXplQmlsaW5lYXJQcm9ncmFtPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKGUsdCxyLG4pe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdLHRoaXMub3V0cHV0U2hhcGU9W107dmFyIG89ZVswXSxhPWVbMV0saT1lWzJdLHM9ZVszXTt0aGlzLm91dHB1dFNoYXBlPVtvLHQscixzXTt2YXIgdT1bbiYmdD4xP2EtMTphLG4mJnI+MT9pLTE6aV0sbD1bbiYmdD4xP3QtMTp0LG4mJnI+MT9yLTE6cl07dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGNvbnN0IHZlYzIgZWZmZWN0aXZlSW5wdXRPdmVyT3V0cHV0UmF0aW9SQyA9IHZlYzIoXFxuICAgICAgICAgIFwiK3VbMF0vbFswXStcIixcXG4gICAgICAgICAgXCIrdVsxXS9sWzFdK1wiKTtcXG4gICAgICBjb25zdCB2ZWMyIGlucHV0U2hhcGVSQyA9IHZlYzIoXCIrYStcIi4wLCBcIitpK1wiLjApO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGIgPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgZCA9IGNvb3Jkc1szXTtcXG4gICAgICAgIGl2ZWMyIHlSQyA9IGNvb3Jkcy55ejtcXG5cXG4gICAgICAgIC8vIEZyYWN0aW9uYWwgc291cmNlIGluZGV4LlxcbiAgICAgICAgdmVjMiBzb3VyY2VGcmFjSW5kZXhSQyA9IHZlYzIoeVJDKSAqIGVmZmVjdGl2ZUlucHV0T3Zlck91dHB1dFJhdGlvUkM7XFxuXFxuICAgICAgICAvLyBDb21wdXRlIHRoZSBmb3VyIGludGVnZXIgaW5kaWNlcy5cXG4gICAgICAgIGl2ZWMyIHNvdXJjZUZsb29yUkMgPSBpdmVjMihzb3VyY2VGcmFjSW5kZXhSQyk7XFxuICAgICAgICBpdmVjMiBzb3VyY2VDZWlsUkMgPSBpdmVjMihcXG4gICAgICAgICAgbWluKGlucHV0U2hhcGVSQyAtIDEuMCwgY2VpbChzb3VyY2VGcmFjSW5kZXhSQykpKTtcXG5cXG4gICAgICAgIGZsb2F0IHRvcExlZnQgPSBnZXRBKGIsIHNvdXJjZUZsb29yUkMueCwgc291cmNlRmxvb3JSQy55LCBkKTtcXG4gICAgICAgIGZsb2F0IGJvdHRvbUxlZnQgPSBnZXRBKGIsIHNvdXJjZUNlaWxSQy54LCBzb3VyY2VGbG9vclJDLnksIGQpO1xcbiAgICAgICAgZmxvYXQgdG9wUmlnaHQgPSBnZXRBKGIsIHNvdXJjZUZsb29yUkMueCwgc291cmNlQ2VpbFJDLnksIGQpO1xcbiAgICAgICAgZmxvYXQgYm90dG9tUmlnaHQgPSBnZXRBKGIsIHNvdXJjZUNlaWxSQy54LCBzb3VyY2VDZWlsUkMueSwgZCk7XFxuXFxuICAgICAgICB2ZWMyIGZyYWNSQyA9IHNvdXJjZUZyYWNJbmRleFJDIC0gdmVjMihzb3VyY2VGbG9vclJDKTtcXG5cXG4gICAgICAgIGZsb2F0IHRvcCA9IHRvcExlZnQgKyAodG9wUmlnaHQgLSB0b3BMZWZ0KSAqIGZyYWNSQy55O1xcbiAgICAgICAgZmxvYXQgYm90dG9tID0gYm90dG9tTGVmdCArIChib3R0b21SaWdodCAtIGJvdHRvbUxlZnQpICogZnJhY1JDLnk7XFxuICAgICAgICBmbG9hdCBuZXdWYWx1ZSA9IHRvcCArIChib3R0b20gLSB0b3ApICogZnJhY1JDLng7XFxuXFxuICAgICAgICBzZXRPdXRwdXQobmV3VmFsdWUpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLFJlc2l6ZU5lYXJlc3ROZWlnYm9yQmFja3Byb3BQcm9ncmFtPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKGUsdCxyKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiZHlcIl0sdGhpcy5vdXRwdXRTaGFwZT1bXSx0aGlzLm91dHB1dFNoYXBlPXQuc2hhcGU7dmFyIG49dC5zaGFwZSxvPW5bMV0sYT1uWzJdLGk9ZS5zaGFwZSxzPWlbMV0sdT1pWzJdLGw9W3ImJnM+MT9vLTE6byxyJiZ1PjE/YS0xOmFdLGM9W3ImJnM+MT9zLTE6cyxyJiZ1PjE/dS0xOnVdLHA9bFswXS9jWzBdLGQ9bFsxXS9jWzFdLGg9MS9wLGY9MS9kLG09MipNYXRoLmNlaWwoaCkrMixnPTIqTWF0aC5jZWlsKGYpKzI7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGIgPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgZCA9IGNvb3Jkc1szXTtcXG4gICAgICAgIGludCByID0gY29vcmRzWzFdO1xcbiAgICAgICAgaW50IGMgPSBjb29yZHNbMl07XFxuXFxuICAgICAgICBmbG9hdCBhY2N1bXVsYXRvciA9IDAuMDtcXG5cXG4gICAgICAgIGNvbnN0IGZsb2F0IGhlaWdodFNjYWxlID0gZmxvYXQoXCIrcCtcIik7XFxuICAgICAgICBjb25zdCBmbG9hdCB3aWR0aFNjYWxlID0gZmxvYXQoXCIrZCtcIik7XFxuXFxuICAgICAgICBjb25zdCBmbG9hdCBpbnZIZWlnaHRTY2FsZSA9IGZsb2F0KFwiK2grXCIpO1xcbiAgICAgICAgY29uc3QgZmxvYXQgaW52V2lkdGhTY2FsZSA9IGZsb2F0KFwiK2YrXCIpO1xcblxcbiAgICAgICAgY29uc3QgaW50IHdpbkhlaWdodCA9IGludChcIittK1wiKTtcXG4gICAgICAgIGNvbnN0IGludCB3aW5XaWR0aCA9IGludChcIitnK1wiKTtcXG5cXG4gICAgICAgIC8vIENvbXB1dGUgYm91bmRzIGZvciB3aGVyZSBpbiBkeSB3ZSB3aWxsIGxvb2tcXG4gICAgICAgIGZsb2F0IHN0YXJ0UkxlcnAgPSBmbG9vcihmbG9hdChyKSAqIGludkhlaWdodFNjYWxlKTtcXG4gICAgICAgIGludCBzdGFydER5UiA9IGludChmbG9vcihzdGFydFJMZXJwIC0gZmxvYXQod2luSGVpZ2h0IC8gMikpKTtcXG5cXG4gICAgICAgIGZsb2F0IHN0YXJ0Q0xlcnAgPSBmbG9vcihmbG9hdChjKSAqIGludldpZHRoU2NhbGUpO1xcbiAgICAgICAgaW50IHN0YXJ0RHlDID0gaW50KGZsb29yKHN0YXJ0Q0xlcnAgLSBmbG9hdCh3aW5XaWR0aCAvIDIpKSk7XFxuXFxuICAgICAgICAvLyBMb29wIG92ZXIgZHlcXG4gICAgICAgIGZvciAoaW50IGR5Uk9mZnNldCA9IDA7IGR5Uk9mZnNldCA8IHdpbkhlaWdodDsgZHlST2Zmc2V0KyspIHtcXG4gICAgICAgICAgaW50IGR5UiA9IGR5Uk9mZnNldCArIHN0YXJ0RHlSO1xcblxcbiAgICAgICAgICAvLyBHdWFyZCBhZ2FpbnN0IHRoZSB3aW5kb3cgZXhjZWVkaW5nIHRoZSBib3VuZHMgb2YgZHlcXG4gICAgICAgICAgaWYgKGR5UiA8IDAgfHwgZHlSID49IFwiK3MrXCIpIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBmb3IgKGludCBkeUNPZmZzZXQgPSAwOyBkeUNPZmZzZXQgPCB3aW5XaWR0aDsgZHlDT2Zmc2V0KyspIHtcXG4gICAgICAgICAgICBpbnQgZHlDID0gZHlDT2Zmc2V0ICsgc3RhcnREeUM7XFxuXFxuICAgICAgICAgICAgLy8gR3VhcmQgYWdhaW5zdCB0aGUgd2luZG93IGV4Y2VlZGluZyB0aGUgYm91bmRzIG9mIGR5XFxuICAgICAgICAgICAgaWYgKGR5QyA8IDAgfHwgZHlDID49IFwiK3UrXCIpIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBmbG9hdCBzb3VyY2VGcmFjUm93ID1cXG4gICAgICAgICAgICAgIGZsb2F0KFwiK2xbMF0rXCIpICpcXG4gICAgICAgICAgICAgICAgKGZsb2F0KGR5UikgLyBmbG9hdChcIitjWzBdK1wiKSk7XFxuXFxuICAgICAgICAgICAgZmxvYXQgc291cmNlRnJhY0NvbCA9XFxuICAgICAgICAgICAgICAgIGZsb2F0KFwiK2xbMV0rXCIpICpcXG4gICAgICAgICAgICAgICAgICAoZmxvYXQoZHlDKSAvIGZsb2F0KFwiK2NbMV0rXCIpKTtcXG5cXG4gICAgICAgICAgICBpbnQgc291cmNlTmVhcmVzdFJvdyA9IGludChtaW4oXFxuICAgICAgICAgICAgICAgIGZsb2F0KGludChcIitvK1wiKSAtIDEpLFxcbiAgICAgICAgICAgICAgICBcIityK1wiID8gZmxvYXQocm91bmQoc291cmNlRnJhY1JvdykpIDpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQoZmxvb3Ioc291cmNlRnJhY1JvdykpKSk7XFxuXFxuICAgICAgICAgICAgaW50IHNvdXJjZU5lYXJlc3RDb2wgPSBpbnQobWluKFxcbiAgICAgICAgICAgICAgICBmbG9hdChpbnQoXCIrYStcIikgLSAxKSxcXG4gICAgICAgICAgICAgICAgXCIrcitcIiA/IGZsb2F0KHJvdW5kKHNvdXJjZUZyYWNDb2wpKSA6XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0KGZsb29yKHNvdXJjZUZyYWNDb2wpKSkpO1xcblxcbiAgICAgICAgICAgIGlmIChyID09IHNvdXJjZU5lYXJlc3RSb3cgJiYgYyA9PSBzb3VyY2VOZWFyZXN0Q29sKSB7XFxuICAgICAgICAgICAgICBhY2N1bXVsYXRvciArPSBnZXREeShiLCBkeVIsIGR5QywgZCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICAvLyBFbmQgbG9vcCBvdmVyIGR5XFxuXFxuICAgICAgICBzZXRPdXRwdXQoYWNjdW11bGF0b3IpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLFJlc2l6ZU5lYXJlc3ROZWlnaGJvclByb2dyYW09ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oZSx0LHIsbil7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl0sdGhpcy5vdXRwdXRTaGFwZT1bXTt2YXIgbz1lWzBdLGE9ZVsxXSxpPWVbMl0scz1lWzNdO3RoaXMub3V0cHV0U2hhcGU9W28sdCxyLHNdO3ZhciB1PVtuJiZ0PjE/YS0xOmEsbiYmcj4xP2ktMTppXSxsPVtuJiZ0PjE/dC0xOnQsbiYmcj4xP3ItMTpyXSxjPW4/XCIwLjVcIjpcIjAuMFwiO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICBjb25zdCB2ZWMyIGVmZmVjdGl2ZUlucHV0T3Zlck91dHB1dFJhdGlvUkMgPSB2ZWMyKFxcbiAgICAgICAgICBcIit1WzBdL2xbMF0rXCIsXFxuICAgICAgICAgIFwiK3VbMV0vbFsxXStcIik7XFxuICAgICAgY29uc3QgdmVjMiBpbnB1dFNoYXBlUkMgPSB2ZWMyKFwiK2ErXCIuMCwgXCIraStcIi4wKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IGQgPSBjb29yZHNbM107XFxuICAgICAgICBpdmVjMiB5UkMgPSBjb29yZHMueXo7XFxuXFxuICAgICAgICAvLyBGcmFjdGlvbmFsIHNvdXJjZSBpbmRleC5cXG4gICAgICAgIHZlYzIgc291cmNlRnJhY0luZGV4UkMgPSB2ZWMyKHlSQykgKiBlZmZlY3RpdmVJbnB1dE92ZXJPdXRwdXRSYXRpb1JDO1xcblxcbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgY29vcmRpbmF0b3JzIG9mIG5lYXJlc3QgbmVpZ2hib3IgcG9pbnQuXFxuICAgICAgICBpdmVjMiBzb3VyY2VOZWFyZXN0UkMgPSBpdmVjMihcXG4gICAgICAgICAgbWluKGlucHV0U2hhcGVSQyAtIDEuMCwgZmxvb3Ioc291cmNlRnJhY0luZGV4UkMgKyBcIitjK1wiKSkpO1xcblxcbiAgICAgICAgZmxvYXQgbmV3VmFsdWUgPSBnZXRBKGIsIHNvdXJjZU5lYXJlc3RSQy54LCBzb3VyY2VOZWFyZXN0UkMueSwgZCk7XFxuXFxuICAgICAgICBzZXRPdXRwdXQobmV3VmFsdWUpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLFJldmVyc2VQcm9ncmFtPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKGUsdCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIl07dmFyIHI9ZS5sZW5ndGg7aWYocj40KXRocm93IG5ldyBFcnJvcihcIldlYkdMIGJhY2tlbmQ6IFJldmVyc2Ugb2YgcmFuay1cIityK1wiIHRlbnNvciBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTtpZih0aGlzLm91dHB1dFNoYXBlPWUsMSE9PXIpe3ZhciBuPWUubWFwKGZ1bmN0aW9uKHIsbil7cmV0dXJuIGZ1bmN0aW9uKHIpe3JldHVybi0xIT09dC5pbmRleE9mKHIpJiYxIT09ZVtyXT9lW3JdK1wiIC0gY29vcmRzW1wiK3IrXCJdIC0gMVwiOlwiY29vcmRzW1wiK3IrXCJdXCJ9KG4pfSkuam9pbihcIixcIiksbz1nZXRDb29yZHNEYXRhVHlwZShyKTt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgXCIrbytcIiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIHNldE91dHB1dChnZXRYKFwiK24rXCIpKTtcXG4gICAgICB9XFxuICAgIFwifWVsc2UgdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICBpbnQgY29vcmQgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgICAgc2V0T3V0cHV0KGdldFgoXCIrZVswXStcIiAtIGNvb3JkIC0gMSkpO1xcbiAgICAgICAgfVxcbiAgICAgIFwifX0oKSxTY2F0dGVyUHJvZ3JhbT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihlLHQscixuLG8sYSxpKXt2b2lkIDA9PT1pJiYoaT0hMCksdGhpcy52YXJpYWJsZU5hbWVzPVtcInVwZGF0ZXNcIixcImluZGljZXNcIixcImRlZmF1bHRWYWx1ZVwiXSx0aGlzLm91dHB1dFNoYXBlPWE7dmFyIHM9Z2V0Q29vcmRzRGF0YVR5cGUoby5sZW5ndGgpLHU9Z2V0Q29vcmRzRGF0YVR5cGUoYS5sZW5ndGgpLGw9XCJcIjsxPT09cj9sPVwiaVwiOjI9PT1yJiYobD1cImksIGpcIik7dmFyIGM9XCJnZXRJbmRpY2VzKFwiK2wrXCIpXCIscD1cIlwiOzE9PT1uP3A9XCJpXCI6Mj09PW4mJihwPVwiaSwgY29vcmRzWzFdXCIpO3ZhciBkPVwiZ2V0VXBkYXRlcyhcIitwK1wiKVwiLGg9dD4xP1wic3RyaWRlc1tqXVwiOlwic3RyaWRlc1wiO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICAgIFwiK3MrXCIgc3RyaWRlcyA9IFwiK3MrXCIoXCIrbytcIik7XFxuXFxuICAgICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgIFwiK3UrXCIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICAgIGZsb2F0IHN1bSA9IDAuMDtcXG4gICAgICAgICAgYm9vbCBmb3VuZCA9IGZhbHNlO1xcbiAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFwiK2UrXCI7IGkrKykge1xcbiAgICAgICAgICAgIGludCBmbGF0dGVuZWRJbmRleCA9IDA7XFxuICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBcIit0K1wiOyBqKyspIHtcXG4gICAgICAgICAgICAgIGludCBpbmRleCA9IHJvdW5kKFwiK2MrXCIpO1xcbiAgICAgICAgICAgICAgZmxhdHRlbmVkSW5kZXggKz0gaW5kZXggKiBcIitoK1wiO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAoZmxhdHRlbmVkSW5kZXggPT0gY29vcmRzWzBdKSB7XFxuICAgICAgICAgICAgICBzdW0gKz0gXCIrZCtcIjtcXG4gICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgc2V0T3V0cHV0KG1peChnZXREZWZhdWx0VmFsdWUoKSwgc3VtLCBmbG9hdChmb3VuZCkpKTtcXG4gICAgICAgIH1cXG4gICAgICBcIn19KCksU2VnbWVudE9wUHJvZ3JhbT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihlLHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCIsXCJzZWdtZW50SWRzXCJdO3ZhciByPWUud2luZG93U2l6ZSxuPWUuYmF0Y2hTaXplLG89ZS5pblNpemUsYT1lLm51bVNlZ21lbnRzLGk9YSpNYXRoLmNlaWwoby9yKTt0aGlzLm91dHB1dFNoYXBlPVtuLGldO3ZhciBzPTQqTWF0aC5mbG9vcihyLzQpLHU9ciU0LGw9XCJcXG4gICAgICAgIHN1bVZhbHVlICs9IGRvdCh2YWx1ZXMsIGZpbHRlcik7XFxuICAgIFwiLGM9XCJcIjtvJXI+MCYmKGM9XCJcXG4gICAgICAgIGlmIChpbklkeCA8IDAgfHwgaW5JZHggPj0gXCIrbytcIikge1xcbiAgICAgICAgICByZXR1cm4gaW5pdGlhbGl6YXRpb25WYWx1ZTtcXG4gICAgICAgIH1cXG4gICAgICBcIik7dmFyIHA9XCJcIjtvJXI+MCYmKHA9XCJcXG4gICAgICAgIGlmIChpbklkeCA8IDAgfHwgaW5JZHggPj0gXCIrbytcIikge1xcbiAgICAgICAgICByZXR1cm4gLTEuMDtcXG4gICAgICAgIH1cXG4gICAgICBcIiksdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGNvbnN0IGZsb2F0IGluaXRpYWxpemF0aW9uVmFsdWUgPSAwLjA7XFxuXFxuICAgICAgZmxvYXQgZ2V0VmFsdWUoaW50IGJhdGNoLCBpbnQgaW5JZHgpIHtcXG4gICAgICAgIFwiK2MrXCJcXG4gICAgICAgIHJldHVybiBnZXRYKGJhdGNoLCBpbklkeCk7XFxuICAgICAgfVxcblxcbiAgICAgIGZsb2F0IGdldFNlZ21lbnRJZEF0SW5kZXgoaW50IGluSWR4KSB7XFxuICAgICAgICBcIitwK1wiXFxuICAgICAgICByZXR1cm4gZ2V0U2VnbWVudElkcyhpbklkeCk7XFxuICAgICAgfVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMyIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IG91dElkeCA9IGNvb3Jkc1sxXTtcXG4gICAgICAgIGludCBpbk9mZnNldCA9IGludChmbG9vcihmbG9hdChvdXRJZHgpIC8gZmxvYXQoXFxuICAgICAgICAgIFwiK2ErXCIpKSAqIGZsb2F0KFwiK3IrXCIpKTtcXG4gICAgICAgIGludCBjdXJyZW50U2VnID0gaW50KG1vZChmbG9hdChvdXRJZHgpLCBmbG9hdChcIithK1wiKSkpO1xcblxcbiAgICAgICAgZmxvYXQgc3VtVmFsdWUgPSAwLjA7XFxuXFxuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFwiK3MrXCI7IGkgKz0gNCkge1xcbiAgICAgICAgICBpbnQgaW5JZHggPSBpbk9mZnNldCArIGk7XFxuICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHgpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDEpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDIpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDMpXFxuICAgICAgICAgICk7XFxuXFxuICAgICAgICAgIHZlYzQgZmlsdGVyID0gdmVjNChcXG4gICAgICAgICAgICBpbnQoZ2V0U2VnbWVudElkQXRJbmRleChpbklkeCkpID09IGN1cnJlbnRTZWcgPyAxIDogMCxcXG4gICAgICAgICAgICBpbnQoZ2V0U2VnbWVudElkQXRJbmRleChpbklkeCArIDEpKSA9PSBjdXJyZW50U2VnID8gMSA6IDAsXFxuICAgICAgICAgICAgaW50KGdldFNlZ21lbnRJZEF0SW5kZXgoaW5JZHggKyAyKSkgPT0gY3VycmVudFNlZyA/IDEgOiAwLFxcbiAgICAgICAgICAgIGludChnZXRTZWdtZW50SWRBdEluZGV4KGluSWR4ICsgMykpID09IGN1cnJlbnRTZWcgPyAxIDogMFxcbiAgICAgICAgICApO1xcblxcbiAgICAgICAgICBcIitsK1wiXFxuICAgICAgICB9XFxuXFxuICAgICAgICBpbnQgaW5JZHggPSBpbk9mZnNldCArIFwiK3MrXCI7XFxuICAgICAgICBpZiAoXCIrKDE9PT11KStcIikge1xcbiAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4KSxcXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlLFxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUsXFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxcbiAgICAgICAgICApO1xcblxcbiAgICAgICAgICBpbnQgaW5JZHhTZWcgPSBpbnQoZ2V0U2VnbWVudElkQXRJbmRleChpbklkeCkpO1xcblxcbiAgICAgICAgICB2ZWM0IGZpbHRlciA9IHZlYzQoXFxuICAgICAgICAgICAgaW50KGdldFNlZ21lbnRJZEF0SW5kZXgoaW5JZHgpKSA9PSBjdXJyZW50U2VnID8gMSA6IDAsXFxuICAgICAgICAgICAgMCxcXG4gICAgICAgICAgICAwLFxcbiAgICAgICAgICAgIDBcXG4gICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgXCIrbCtcIlxcbiAgICAgICAgfSBlbHNlIGlmIChcIisoMj09PXUpK1wiKSB7XFxuICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHgpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDEpLFxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUsXFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxcbiAgICAgICAgICApO1xcblxcbiAgICAgICAgICB2ZWM0IGZpbHRlciA9IHZlYzQoXFxuICAgICAgICAgICAgaW50KGdldFNlZ21lbnRJZEF0SW5kZXgoaW5JZHgpKSA9PSBjdXJyZW50U2VnID8gMSA6IDAsXFxuICAgICAgICAgICAgaW50KGdldFNlZ21lbnRJZEF0SW5kZXgoaW5JZHggKyAxKSkgPT0gY3VycmVudFNlZyA/IDEgOiAwLFxcbiAgICAgICAgICAgICAgMCxcXG4gICAgICAgICAgICAgIDBcXG4gICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgXCIrbCtcIlxcbiAgICAgICAgfSBlbHNlIGlmIChcIisoMz09PXUpK1wiKSB7XFxuICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHgpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDEpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDIpLFxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcXG4gICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgdmVjNCBmaWx0ZXIgPSB2ZWM0KFxcbiAgICAgICAgICAgIGludChnZXRTZWdtZW50SWRBdEluZGV4KGluSWR4KSkgPT0gY3VycmVudFNlZyA/IDEgOiAwLFxcbiAgICAgICAgICAgIGludChnZXRTZWdtZW50SWRBdEluZGV4KGluSWR4ICsgMSkpID09IGN1cnJlbnRTZWcgPyAxIDogMCxcXG4gICAgICAgICAgICBpbnQoZ2V0U2VnbWVudElkQXRJbmRleChpbklkeCArIDIpKSA9PSBjdXJyZW50U2VnID8gMSA6IDAsXFxuICAgICAgICAgICAgMFxcbiAgICAgICAgICApO1xcblxcbiAgICAgICAgICBcIitsK1wiXFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoc3VtVmFsdWUpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLFNlbGVjdFByb2dyYW09ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oZSx0LHIpe3ZhciBuLG87aWYodGhpcy52YXJpYWJsZU5hbWVzPVtcImNcIixcImFcIixcImJcIl0sdGhpcy5vdXRwdXRTaGFwZT10LHI+NCl0aHJvdyBFcnJvcihcIldoZXJlIGZvciByYW5rIFwiK3IrXCIgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7aWYoMT09PXIpbz1cInJlc1JDXCIsbj1cInJlc1JDXCI7ZWxzZXtmb3IodmFyIGE9W1wicmVzUkMueFwiLFwicmVzUkMueVwiLFwicmVzUkMuelwiLFwicmVzUkMud1wiXSxpPVtdLHM9W10sdT0wO3U8dC5sZW5ndGg7dSsrKXMucHVzaChcIlwiK2FbdV0pLHU8ZSYmaS5wdXNoKFwiXCIrYVt1XSk7bj1pLmpvaW4oKSxvPXMuam9pbigpfXZhciBsPWdldENvb3Jkc0RhdGFUeXBlKHIpO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBcIitsK1wiIHJlc1JDID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBmbG9hdCBjVmFsID0gZ2V0QyhcIituK1wiKTtcXG4gICAgICAgIGlmIChjVmFsID49IDEuMCkge1xcbiAgICAgICAgICBzZXRPdXRwdXQoZ2V0QShcIitvK1wiKSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBzZXRPdXRwdXQoZ2V0QihcIitvK1wiKSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICBcIn19KCksU2xpY2VQcm9ncmFtPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wic291cmNlXCJdLHRoaXMub3V0cHV0U2hhcGU9ZSx0aGlzLnJhbms9ZS5sZW5ndGg7dmFyIHQ9Z2V0Q29vcmRzRGF0YVR5cGUodGhpcy5yYW5rKSxyPWdldENvb3JkcyQxKHRoaXMucmFuayk7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHVuaWZvcm0gXCIrdCtcIiBzdGFydDtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBcIit0K1wiIHNvdXJjZUxvYyA9IHN0YXJ0ICsgZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBzZXRPdXRwdXQoZ2V0U291cmNlKFwiK3IrXCIpKTtcXG4gICAgICB9XFxuICAgIFwifXJldHVybiBlLnByb3RvdHlwZS5nZXRDdXN0b21TZXR1cEZ1bmM9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztpZihlLmxlbmd0aCE9PXRoaXMucmFuayl0aHJvdyBFcnJvcihcIlRoZSByYW5rIChcIit0aGlzLnJhbmsrXCIpIG9mIHRoZSBwcm9ncmFtIG11c3QgbWF0Y2ggdGhlIGxlbmd0aCBvZiBzdGFydCAoXCIrZS5sZW5ndGgrXCIpXCIpO3JldHVybiBmdW5jdGlvbihyLG4pe2lmKG51bGwhPXQuc3RhcnRMb2N8fCh0LnN0YXJ0TG9jPXIuZ2V0VW5pZm9ybUxvY2F0aW9uTm9UaHJvdyhuLFwic3RhcnRcIiksbnVsbCE9dC5zdGFydExvYykpaWYoMT09PXQucmFuaylyLmdsLnVuaWZvcm0xaSh0LnN0YXJ0TG9jLGVbMF0pO2Vsc2UgaWYoMj09PXQucmFuaylyLmdsLnVuaWZvcm0yaSh0LnN0YXJ0TG9jLGVbMF0sZVsxXSk7ZWxzZSBpZigzPT09dC5yYW5rKXIuZ2wudW5pZm9ybTNpKHQuc3RhcnRMb2MsZVswXSxlWzFdLGVbMl0pO2Vsc2V7aWYoNCE9PXQucmFuayl0aHJvdyBFcnJvcihcIlNsaWNpbmcgZm9yIHJhbmsgXCIrdC5yYW5rK1wiIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpO3IuZ2wudW5pZm9ybTRpKHQuc3RhcnRMb2MsZVswXSxlWzFdLGVbMl0sZVszXSl9fX0sZX0oKTtmdW5jdGlvbiBnZXRDb29yZHMkMShlKXtpZigxPT09ZSlyZXR1cm5cInNvdXJjZUxvY1wiO2lmKDI9PT1lKXJldHVyblwic291cmNlTG9jLngsIHNvdXJjZUxvYy55XCI7aWYoMz09PWUpcmV0dXJuXCJzb3VyY2VMb2MueCwgc291cmNlTG9jLnksIHNvdXJjZUxvYy56XCI7aWYoND09PWUpcmV0dXJuXCJzb3VyY2VMb2MueCwgc291cmNlTG9jLnksIHNvdXJjZUxvYy56LCBzb3VyY2VMb2Mud1wiO3Rocm93IEVycm9yKFwiU2xpY2luZyBmb3IgcmFuayBcIitlK1wiIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpfXZhciBTdHJpZGVkU2xpY2VQcm9ncmFtPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKGUsdCxyLG4pe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCJdO3ZhciBvPXIuZmlsdGVyKGZ1bmN0aW9uKGUsdCl7cmV0dXJuLTE9PT1uLmluZGV4T2YodCl9KTt0aGlzLm91dHB1dFNoYXBlPW87dmFyIGE9ci5sZW5ndGgsaT1nZXRDb29yZHNEYXRhVHlwZShyLmxlbmd0aCkscz1nZXRDb29yZHNEYXRhVHlwZShvLmxlbmd0aCksdT1cIlwiO2lmKDE9PT1hKXU9XCJjb29yZHMgKiBzdHJpZGVzICsgYmVnaW5cIjtlbHNle3ZhciBsPTA7dT1yLm1hcChmdW5jdGlvbihlLHQpe3JldHVybi0xPT09bi5pbmRleE9mKHQpPyhsKyssMT09PW8ubGVuZ3RoP1wiY29vcmRzICogc3RyaWRlc1tcIit0K1wiXSArIGJlZ2luW1wiK3QrXCJdXCI6XCJjb29yZHNbXCIrKGwtMSkrXCJdICogc3RyaWRlc1tcIit0K1wiXSArIGJlZ2luW1wiK3QrXCJdXCIpOlwiYmVnaW5bXCIrdCtcIl1cIn0pLmpvaW4oXCIsXCIpfXRoaXMudXNlckNvZGU9XCJcXG4gICAgICBcIitpK1wiIGJlZ2luID0gXCIraStcIihcIitlK1wiKTtcXG4gICAgICBcIitpK1wiIHN0cmlkZXMgPSBcIitpK1wiKFwiK3QrXCIpO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIFwiK3MrXCIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBzZXRPdXRwdXQoZ2V0WChcIit1K1wiKSk7XFxuICAgICAgfVxcbiAgICBcIn19KCksVGV4dHVyZU1hbmFnZXI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUpe3RoaXMuZ3BncHU9ZSx0aGlzLm51bVVzZWRUZXh0dXJlcz0wLHRoaXMubnVtRnJlZVRleHR1cmVzPTAsdGhpcy5mcmVlVGV4dHVyZXM9e30sdGhpcy5sb2dFbmFibGVkPSExLHRoaXMudXNlZFRleHR1cmVzPXt9fXJldHVybiBlLnByb3RvdHlwZS5hY3F1aXJlVGV4dHVyZT1mdW5jdGlvbihlLHQscil7dmFyIG4sbz1nZXRQaHlzaWNhbEZyb21Mb2dpY2FsVGV4dHVyZVR5cGUodCxyKSxhPWdldEtleUZyb21UZXh0dXJlU2hhcGUoZSxvLHIpO2lmKGEgaW4gdGhpcy5mcmVlVGV4dHVyZXN8fCh0aGlzLmZyZWVUZXh0dXJlc1thXT1bXSksYSBpbiB0aGlzLnVzZWRUZXh0dXJlc3x8KHRoaXMudXNlZFRleHR1cmVzW2FdPVtdKSx0aGlzLmZyZWVUZXh0dXJlc1thXS5sZW5ndGg+MCl7dGhpcy5udW1GcmVlVGV4dHVyZXMtLSx0aGlzLm51bVVzZWRUZXh0dXJlcysrLHRoaXMubG9nKCk7dmFyIGk9dGhpcy5mcmVlVGV4dHVyZXNbYV0uc2hpZnQoKTtyZXR1cm4gdGhpcy51c2VkVGV4dHVyZXNbYV0ucHVzaChpKSxpfXJldHVybiB0aGlzLm51bVVzZWRUZXh0dXJlcysrLHRoaXMubG9nKCksbz09PVBoeXNpY2FsVGV4dHVyZVR5cGUuUEFDS0VEXzJYMl9GTE9BVDMyP249dGhpcy5ncGdwdS5jcmVhdGVQYWNrZWRNYXRyaXhUZXh0dXJlKGVbMF0sZVsxXSk6bz09PVBoeXNpY2FsVGV4dHVyZVR5cGUuUEFDS0VEXzJYMl9GTE9BVDE2P249dGhpcy5ncGdwdS5jcmVhdGVGbG9hdDE2UGFja2VkTWF0cml4VGV4dHVyZShlWzBdLGVbMV0pOm89PT1QaHlzaWNhbFRleHR1cmVUeXBlLlVOUEFDS0VEX0ZMT0FUMzI/bj10aGlzLmdwZ3B1LmNyZWF0ZUZsb2F0MzJNYXRyaXhUZXh0dXJlKGVbMF0sZVsxXSk6bz09PVBoeXNpY2FsVGV4dHVyZVR5cGUuVU5QQUNLRURfRkxPQVQxNj9uPXRoaXMuZ3BncHUuY3JlYXRlRmxvYXQxNk1hdHJpeFRleHR1cmUoZVswXSxlWzFdKTpvPT09UGh5c2ljYWxUZXh0dXJlVHlwZS5QQUNLRURfNFgxX1VOU0lHTkVEX0JZVEUmJihuPXRoaXMuZ3BncHUuY3JlYXRlVW5zaWduZWRCeXRlc01hdHJpeFRleHR1cmUoZVswXSxlWzFdKSksdGhpcy51c2VkVGV4dHVyZXNbYV0ucHVzaChuKSxufSxlLnByb3RvdHlwZS5yZWxlYXNlVGV4dHVyZT1mdW5jdGlvbihlLHQscixuKXtpZihudWxsIT10aGlzLmZyZWVUZXh0dXJlcyl7dmFyIG89Z2V0S2V5RnJvbVRleHR1cmVTaGFwZSh0LGdldFBoeXNpY2FsRnJvbUxvZ2ljYWxUZXh0dXJlVHlwZShyLG4pLG4pO28gaW4gdGhpcy5mcmVlVGV4dHVyZXN8fCh0aGlzLmZyZWVUZXh0dXJlc1tvXT1bXSksdGhpcy5mcmVlVGV4dHVyZXNbb10ucHVzaChlKSx0aGlzLm51bUZyZWVUZXh0dXJlcysrLHRoaXMubnVtVXNlZFRleHR1cmVzLS07dmFyIGE9dGhpcy51c2VkVGV4dHVyZXNbb10saT1hLmluZGV4T2YoZSk7aWYoaTwwKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZWxlYXNlIGEgdGV4dHVyZSB0aGF0IHdhcyBuZXZlciBwcm92aWRlZCBieSB0aGlzIHRleHR1cmUgbWFuYWdlclwiKTthLnNwbGljZShpLDEpLHRoaXMubG9nKCl9fSxlLnByb3RvdHlwZS5sb2c9ZnVuY3Rpb24oKXtpZih0aGlzLmxvZ0VuYWJsZWQpe3ZhciBlPXRoaXMubnVtRnJlZVRleHR1cmVzK3RoaXMubnVtVXNlZFRleHR1cmVzO2NvbnNvbGUubG9nKFwiRnJlZS9Vc2VkXCIsdGhpcy5udW1GcmVlVGV4dHVyZXMrXCIgLyBcIit0aGlzLm51bVVzZWRUZXh0dXJlcyxcIihcIitlK1wiKVwiKX19LGUucHJvdG90eXBlLmdldE51bVVzZWRUZXh0dXJlcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLm51bVVzZWRUZXh0dXJlc30sZS5wcm90b3R5cGUuZ2V0TnVtRnJlZVRleHR1cmVzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubnVtRnJlZVRleHR1cmVzfSxlLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcztpZihudWxsIT10aGlzLmZyZWVUZXh0dXJlcyl7Zm9yKHZhciB0IGluIHRoaXMuZnJlZVRleHR1cmVzKXRoaXMuZnJlZVRleHR1cmVzW3RdLmZvckVhY2goZnVuY3Rpb24odCl7ZS5ncGdwdS5kZWxldGVNYXRyaXhUZXh0dXJlKHQpfSk7Zm9yKHZhciB0IGluIHRoaXMudXNlZFRleHR1cmVzKXRoaXMudXNlZFRleHR1cmVzW3RdLmZvckVhY2goZnVuY3Rpb24odCl7ZS5ncGdwdS5kZWxldGVNYXRyaXhUZXh0dXJlKHQpfSk7dGhpcy5mcmVlVGV4dHVyZXM9bnVsbCx0aGlzLnVzZWRUZXh0dXJlcz1udWxsLHRoaXMubnVtVXNlZFRleHR1cmVzPTAsdGhpcy5udW1GcmVlVGV4dHVyZXM9MH19LGV9KCk7ZnVuY3Rpb24gZ2V0UGh5c2ljYWxGcm9tTG9naWNhbFRleHR1cmVUeXBlKGUsdCl7aWYodClyZXR1cm4gRU5WLmdldChcIldFQkdMX1JFTkRFUl9GTE9BVDMyX0VOQUJMRURcIik/UGh5c2ljYWxUZXh0dXJlVHlwZS5QQUNLRURfMlgyX0ZMT0FUMzI6UGh5c2ljYWxUZXh0dXJlVHlwZS5QQUNLRURfMlgyX0ZMT0FUMTY7aWYoZT09PVRleHR1cmVVc2FnZS5ET1dOTE9BRHx8ZT09PVRleHR1cmVVc2FnZS5QSVhFTFMpcmV0dXJuIFBoeXNpY2FsVGV4dHVyZVR5cGUuUEFDS0VEXzRYMV9VTlNJR05FRF9CWVRFO2lmKGU9PT1UZXh0dXJlVXNhZ2UuVVBMT0FEKXJldHVybiBQaHlzaWNhbFRleHR1cmVUeXBlLlVOUEFDS0VEX0ZMT0FUMzI7aWYoZT09PVRleHR1cmVVc2FnZS5SRU5ERVIpcmV0dXJuIEVOVi5nZXQoXCJXRUJHTF9SRU5ERVJfRkxPQVQzMl9FTkFCTEVEXCIpP1BoeXNpY2FsVGV4dHVyZVR5cGUuVU5QQUNLRURfRkxPQVQzMjpQaHlzaWNhbFRleHR1cmVUeXBlLlVOUEFDS0VEX0ZMT0FUMTY7dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBsb2dpY2FsIHRleHR1cmUgdHlwZSBcIitlKX1mdW5jdGlvbiBnZXRLZXlGcm9tVGV4dHVyZVNoYXBlKGUsdCxyKXtyZXR1cm4gZVswXStcIl9cIitlWzFdK1wiX1wiK3QrXCJfXCIrcn12YXIgVGlsZVByb2dyYW09ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oZSx0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXTtmb3IodmFyIHI9bmV3IEFycmF5KGUubGVuZ3RoKSxuPTA7bjxyLmxlbmd0aDtuKyspcltuXT1lW25dKnRbbl07dGhpcy5vdXRwdXRTaGFwZT1yLHRoaXMucmFuaz1yLmxlbmd0aDt2YXIgbz1nZXRDb29yZHNEYXRhVHlwZSh0aGlzLnJhbmspLGE9Z2V0U291cmNlQ29vcmRzJDIoZSk7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIFwiK28rXCIgcmVzUkMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIHNldE91dHB1dChnZXRBKFwiK2ErXCIpKTtcXG4gICAgICB9XFxuICAgIFwifX0oKTtmdW5jdGlvbiBnZXRTb3VyY2VDb29yZHMkMihlKXt2YXIgdD1lLmxlbmd0aDtpZih0PjUpdGhyb3cgRXJyb3IoXCJUaWxlIGZvciByYW5rIFwiK3QrXCIgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7aWYoMT09PXQpcmV0dXJuXCJpbW9kKHJlc1JDLCBcIitlWzBdK1wiKVwiO2Zvcih2YXIgcj1bXCJyZXNSQy54XCIsXCJyZXNSQy55XCIsXCJyZXNSQy56XCIsXCJyZXNSQy53XCIsXCJyZXNSQy51XCJdLG49W10sbz0wO288ZS5sZW5ndGg7bysrKW4ucHVzaChcImltb2QoXCIrcltvXStcIiwgXCIrZVtvXStcIilcIik7cmV0dXJuIG4uam9pbigpfXZhciBUcmFuc3Bvc2VQcm9ncmFtPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKGUsdCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl07Zm9yKHZhciByPW5ldyBBcnJheShlLmxlbmd0aCksbj0wO248ci5sZW5ndGg7bisrKXJbbl09ZVt0W25dXTt0aGlzLm91dHB1dFNoYXBlPXIsdGhpcy5yYW5rPXIubGVuZ3RoO3ZhciBvPWdldENvb3Jkc0RhdGFUeXBlKHRoaXMucmFuayksYT1nZXRTd2l0Y2hlZENvb3Jkcyh0KTt0aGlzLnVzZXJDb2RlPVwiXFxuICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICBcIitvK1wiIHJlc1JDID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgc2V0T3V0cHV0KGdldEEoXCIrYStcIikpO1xcbiAgICB9XFxuICAgIFwifX0oKTtmdW5jdGlvbiBnZXRTd2l0Y2hlZENvb3JkcyhlKXt2YXIgdD1lLmxlbmd0aDtpZih0PjYpdGhyb3cgRXJyb3IoXCJUcmFuc3Bvc2UgZm9yIHJhbmsgXCIrdCtcIiBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTtmb3IodmFyIHI9W1wicmVzUkMueFwiLFwicmVzUkMueVwiLFwicmVzUkMuelwiLFwicmVzUkMud1wiLFwicmVzUkMudVwiLFwicmVzUkMudlwiXSxuPW5ldyBBcnJheSh0KSxvPTA7bzxlLmxlbmd0aDtvKyspbltlW29dXT1yW29dO3JldHVybiBuLmpvaW4oKX12YXIgRVJGX1A9LjMyNzU5MTEsRVJGX0ExPS4yNTQ4Mjk1OTIsRVJGX0EyPS0uMjg0NDk2NzM2LEVSRl9BMz0xLjQyMTQxMzc0MSxFUkZfQTQ9LTEuNDUzMTUyMDI3LEVSRl9BNT0xLjA2MTQwNTQyOSxTRUxVX1NDQUxFQUxQSEE9MS43NTgwOTkzNDA4NDczNzY4LFNFTFVfU0NBTEU9MS4wNTA3MDA5ODczNTU0ODA1LFVuYXJ5T3BQcm9ncmFtPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdLHRoaXMub3V0cHV0U2hhcGU9ZSx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdW5pZm9ybSBmbG9hdCBOQU47XFxuICAgICAgZmxvYXQgdW5hcnlPcGVyYXRpb24oZmxvYXQgeCkge1xcbiAgICAgICAgXCIrdCtcIlxcbiAgICAgIH1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBmbG9hdCB4ID0gZ2V0QUF0T3V0Q29vcmRzKCk7XFxuICAgICAgICBmbG9hdCB5ID0gdW5hcnlPcGVyYXRpb24oeCk7XFxuXFxuICAgICAgICBzZXRPdXRwdXQoeSk7XFxuICAgICAgfVxcbiAgICBcIn1yZXR1cm4gZS5wcm90b3R5cGUuZ2V0Q3VzdG9tU2V0dXBGdW5jPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcztyZXR1cm4gZnVuY3Rpb24odCxyKXtudWxsPT1lLnN0YXJ0TG9jJiYoZS5zdGFydExvYz10LmdldFVuaWZvcm1Mb2NhdGlvbk5vVGhyb3cocixcIk5BTlwiKSxudWxsPT1lLnN0YXJ0TG9jKXx8dC5nbC51bmlmb3JtMWYoZS5zdGFydExvYyxOYU4pfX0sZX0oKSxDSEVDS19OQU5fU05JUFBFVCQxPVwiaWYgKGlzTmFOKHgpKSByZXR1cm4geDtcIixBQlM9XCJyZXR1cm4gYWJzKHgpO1wiLFJFTFU9Q0hFQ0tfTkFOX1NOSVBQRVQkMStcIlxcbiAgcmV0dXJuICh4IDwgMC4wKSA/IDAuMCA6IHg7XFxuXCIsRUxVPVwicmV0dXJuICh4ID49IDAuMCkgPyB4IDogKGV4cCh4KSAtIDEuMCk7XCIsU0VMVT1cIlxcbiAgLy8gU3RhYmxlIGFuZCBBdHRyYWN0aW5nIEZpeGVkIFBvaW50ICgwLCAxKSBmb3IgTm9ybWFsaXplZCBXZWlnaHRzLlxcbiAgLy8gc2VlOiBodHRwczovL2FyeGl2Lm9yZy9hYnMvMTcwNi4wMjUxNVxcbiAgZmxvYXQgc2NhbGVBbHBoYSA9IFwiK1NFTFVfU0NBTEVBTFBIQStcIjtcXG4gIGZsb2F0IHNjYWxlID0gXCIrU0VMVV9TQ0FMRStcIjtcXG4gIHJldHVybiAoeCA+PSAwLjApID8gc2NhbGUgKiB4IDogc2NhbGVBbHBoYSAqIChleHAoeCkgLSAxLjApO1xcblwiO2Z1bmN0aW9uIFNURVAoZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPTApLENIRUNLX05BTl9TTklQUEVUJDErXCJcXG4gICAgcmV0dXJuIHggPiAwLjAgPyAxLjAgOiBmbG9hdChcIitlK1wiKTtcXG4gIFwifXZhciBORUc9XCJyZXR1cm4gLXg7XCIsQ0VJTD1cInJldHVybiBjZWlsKHgpO1wiLEZMT09SPVwicmV0dXJuIGZsb29yKHgpO1wiLFNJR049XCJcXG4gIGlmIChpc05hTih4KSkgeyByZXR1cm4gMC4wOyB9XFxuICByZXR1cm4gc2lnbih4KTtcXG5cIixST1VORD1cIlxcbiAgLy8gT3BlbkdMIEVTIGRvZXMgbm90IHN1cHBvcnQgcm91bmQgZnVuY3Rpb24uXFxuICAvLyBUaGUgYWxnb3JpdGhtIGlzIGJhc2VkIG9uIGJhbmtlcidzIHJvdW5kaW5nLlxcbiAgZmxvYXQgYmFzZSA9IGZsb29yKHgpO1xcbiAgaWYgKCh4IC0gYmFzZSkgPCAwLjUpIHtcXG4gICAgcmV0dXJuIGZsb29yKHgpO1xcbiAgfSBlbHNlIGlmICgoeCAtIGJhc2UpID4gMC41KSB7XFxuICAgIHJldHVybiBjZWlsKHgpO1xcbiAgfSBlbHNlIHtcXG4gICAgaWYgKG1vZChiYXNlLCAyLjApID09IDAuMCkge1xcbiAgICAgIHJldHVybiBiYXNlO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHJldHVybiBiYXNlICsgMS4wO1xcbiAgICB9XFxuICB9XFxuXCIsRVhQPVwicmV0dXJuIGV4cCh4KTtcIixFWFBNMT1cInJldHVybiBleHAoeCkgLSAxLjA7XCIsTE9HPVwiaWYgKHggPCAwLjApIHJldHVybiBOQU47XFxuICByZXR1cm4gbG9nKHgpO1wiLExPRzFQPVwicmV0dXJuIGxvZygxLjAgKyB4KTtcIixTUVJUPVwicmV0dXJuIHNxcnQoeCk7XCIsUlNRUlQ9XCJyZXR1cm4gaW52ZXJzZXNxcnQoeCk7XCIsU0lHTU9JRD1cInJldHVybiAxLjAgLyAoMS4wICsgZXhwKC0xLjAgKiB4KSk7XCIsU09GVFBMVVM9XCJcXG4gIGZsb2F0IGVwc2lsb24gPSAxLjE5MjA5Mjg5NTUwNzgxMjVlLTc7XFxuICBmbG9hdCB0aHJlc2hvbGQgPSBsb2coZXBzaWxvbikgKyAyLjA7XFxuXFxuICBib29sIHRvb19sYXJnZSA9IHggPiAtdGhyZXNob2xkO1xcbiAgYm9vbCB0b29fc21hbGwgPSB4IDwgdGhyZXNob2xkO1xcblxcbiAgZmxvYXQgcmVzdWx0O1xcbiAgZmxvYXQgZXhwX3ggPSBleHAoeCk7XFxuXFxuICBpZiAodG9vX2xhcmdlKXtcXG4gICAgcmVzdWx0ID0geDtcXG4gIH1cXG4gIGVsc2UgaWYgKHRvb19zbWFsbCl7XFxuICAgIHJlc3VsdCA9IGV4cF94O1xcbiAgfVxcbiAgZWxzZXtcXG4gICAgcmVzdWx0ID0gbG9nKGV4cF94ICsgMS4wKTtcXG4gIH1cXG4gIHJldHVybiByZXN1bHQ7XFxuXCIsU0lOPUNIRUNLX05BTl9TTklQUEVUJDErXCJcXG4gIHJldHVybiBzaW4oeCk7XFxuXCIsQ09TPUNIRUNLX05BTl9TTklQUEVUJDErXCJcXG4gIHJldHVybiBjb3MoeCk7XFxuXCIsVEFOPVwicmV0dXJuIHRhbih4KTtcIixBU0lOPVwicmV0dXJuIGFzaW4oeCk7XCIsQUNPUz1cInJldHVybiBhY29zKHgpO1wiLEFUQU49Q0hFQ0tfTkFOX1NOSVBQRVQkMStcIlxcbiAgcmV0dXJuIGF0YW4oeCk7XFxuXCIsU0lOSD1cIlxcbiAgZmxvYXQgZTJ4ID0gZXhwKHgpO1xcbiAgcmV0dXJuIChlMnggLSAxLjAgLyBlMngpIC8gMi4wO1xcblwiLENPU0g9XCJcXG4gIGZsb2F0IGUyeCA9IGV4cCgteCk7XFxuICByZXR1cm4gKGUyeCArIDEuMCAvIGUyeCkgLyAyLjA7XFxuXCIsVEFOSD1cIlxcbiAgZmxvYXQgZTJ4ID0gZXhwKC0yLjAgKiBhYnMoeCkpO1xcbiAgcmV0dXJuIHNpZ24oeCkgKiAoMS4wIC0gZTJ4KSAvICgxLjAgKyBlMngpO1xcblwiLEFTSU5IPVwicmV0dXJuIGxvZyh4ICsgc3FydCh4ICogeCArIDEuMCkpO1wiLEFDT1NIPUNIRUNLX05BTl9TTklQUEVUJDErXCJcXG4gIGlmICh4IDwgMS4wKSByZXR1cm4gTkFOO1xcbiAgcmV0dXJuIGxvZyh4ICsgc3FydCh4ICogeCAtIDEuMCkpO1wiLEFUQU5IPUNIRUNLX05BTl9TTklQUEVUJDErXCJcXG4gIGlmICgoeCA8IC0xLjApIHx8ICh4ID4gMS4wKSkgcmV0dXJuIE5BTjtcXG4gIHJldHVybiAobG9nKDEuMCArIHgpIC0gbG9nKDEuMCAtIHgpKSAvIDIuMDtcIixFUkY9J1xcbiAgLy8gRXJyb3IgZnVuY3Rpb24gaXMgY2FsY3VsYXRlZCBhcHByb3hpbWF0ZWx5IHdpdGggZWxlbWVudGFyeSBmdW5jdGlvbi5cXG4gIC8vIFNlZSBcIkhhbmRib29rIG9mIE1hdGhlbWF0aWNhbCBGdW5jdGlvbnMgd2l0aCBGb3JtdWxhcyxcXG4gIC8vIEdyYXBocywgYW5kIE1hdGhlbWF0aWNhbCBUYWJsZXNcIiwgQWJyYW1vd2l0eiBhbmQgU3RlZ3VuLlxcbiAgZmxvYXQgcCA9ICcrRVJGX1ArXCI7XFxuICBmbG9hdCBhMSA9IFwiK0VSRl9BMStcIjtcXG4gIGZsb2F0IGEyID0gXCIrRVJGX0EyK1wiO1xcbiAgZmxvYXQgYTMgPSBcIitFUkZfQTMrXCI7XFxuICBmbG9hdCBhNCA9IFwiK0VSRl9BNCtcIjtcXG4gIGZsb2F0IGE1ID0gXCIrRVJGX0E1K1wiO1xcblxcbiAgZmxvYXQgdCA9IDEuMCAvICgxLjAgKyBwICogeCk7XFxuICByZXR1cm4gMS4wIC0gKCgoKChhNSp0ICsgYTQpKnQpICsgYTMpKnQgKyBhMikqdCArIGExKSp0KmV4cCgteCp4KTtcXG5cIixTUVVBUkU9XCJyZXR1cm4geCAqIHg7XCIsUkVDSVBST0NBTD1cInJldHVybiAxLjAgLyB4O1wiLExPR0lDQUxfTk9UPVwicmV0dXJuIGZsb2F0KCEoeCA+PSAxLjApKTtcIixUT19JTlQ9XCJyZXR1cm4gZmxvYXQoaW50KHgpKTtcIixVbnBhY2tQcm9ncmFtPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKGUpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdLHRoaXMudXNlc1BhY2tlZFRleHR1cmVzPSEwLHRoaXMub3V0cHV0U2hhcGU9ZTt2YXIgdD1lLmxlbmd0aCxyPWdldENoYW5uZWxzKFwicmNcIix0KSxuPWdldENvb3Jkc0RhdGFUeXBlKHQpLG89Z2V0U291cmNlQ29vcmRzJDEodCxyKSxhPXIuc2xpY2UoLTIpLGk9MT09PXQ/XCJyY1wiOlwidmVjMihcIithLmpvaW4oXCIsXCIpK1wiKVwiO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBcIituK1wiIHJjID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICB2ZWM0IHBhY2tlZElucHV0ID0gZ2V0QShcIitvK1wiKTtcXG5cXG4gICAgICAgIHNldE91dHB1dChnZXRDaGFubmVsKHBhY2tlZElucHV0LCBcIitpK1wiKSk7XFxuICAgICAgfVxcbiAgICBcIn19KCk7ZnVuY3Rpb24gY29uY2F0MWRfKGUpe3JldHVybiBjb25jYXQoZSwwKX1mdW5jdGlvbiBjb25jYXQyZF8oZSx0KXtyZXR1cm4gY29uY2F0KGUsdCl9ZnVuY3Rpb24gY29uY2F0M2RfKGUsdCl7cmV0dXJuIGNvbmNhdChlLHQpfWZ1bmN0aW9uIGNvbmNhdDRkXyhlLHQpe3JldHVybiBjb25jYXQoZSx0KX1mdW5jdGlvbiBjb25jYXRfKGUsdCl7dm9pZCAwPT09dCYmKHQ9MCksYXNzZXJ0KGUubGVuZ3RoPj0xLFwiUGFzcyBhdCBsZWFzdCBvbmUgdGVuc29yIHRvIGNvbmNhdFwiKTt2YXIgcj1jb252ZXJ0VG9UZW5zb3JBcnJheShlLFwidGVuc29yc1wiLFwiY29uY2F0XCIpO3Q9cGFyc2VBeGlzUGFyYW0odCxyWzBdLnNoYXBlKVswXTt2YXIgbj1jb21wdXRlT3V0U2hhcGUoci5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUuc2hhcGV9KSx0KTtpZigwPT09c2l6ZUZyb21TaGFwZShuKSlyZXR1cm4gdGVuc29yKFtdLG4pO2lmKDE9PT0ocj1yLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4gZS5zaXplPjB9KSkubGVuZ3RoKXJldHVybiByWzBdO3ZhciBvPXIubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLnNoYXBlfSk7YXNzZXJ0UGFyYW1zQ29uc2lzdGVudChvLHQpO3ZhciBhPXI7cmV0dXJuIEVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKGUpe3JldHVybiBlLmNvbmNhdChyLHQpfSxhLGZ1bmN0aW9uKGUpe3ZhciByPW8ubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlW3RdfSk7cmV0dXJuIHNwbGl0JDEoZSxyLHQpLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gZX19KX0pfWZ1bmN0aW9uIHNwbGl0XyhlLHQscil7dm9pZCAwPT09ciYmKHI9MCk7dmFyIG4sbz1jb252ZXJ0VG9UZW5zb3IoZSxcInhcIixcInNwbGl0XCIpO3I9cGFyc2VBeGlzUGFyYW0ocixvLnNoYXBlKVswXSxcIm51bWJlclwiPT10eXBlb2YgdD8oYXNzZXJ0KG8uc2hhcGVbcl0ldD09MCxcIk51bWJlciBvZiBzcGxpdHMgbXVzdCBldmVubHkgZGl2aWRlIHRoZSBheGlzLlwiKSxuPUFycmF5KHQpLmZpbGwoby5zaGFwZVtyXS90KSk6KGFzc2VydChvLnNoYXBlW3JdPT09dC5yZWR1Y2UoZnVuY3Rpb24oZSx0KXtyZXR1cm4gZSt0fSksXCJUaGUgc3VtIG9mIHNpemVzIG11c3QgbWF0Y2ggdGhlIHNpemUgb2YgdGhlIGF4aXMgZGltZW5zaW9uLlwiKSxuPXQpO3JldHVybiBFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbihlKXtyZXR1cm4gZS5zcGxpdChvLG4scil9LHskeDpvfSxmdW5jdGlvbihlKXtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gY29uY2F0KGUscil9fX0pfXZhciBjb25jYXQ9b3Aoe2NvbmNhdF86Y29uY2F0X30pLGNvbmNhdDFkPW9wKHtjb25jYXQxZF86Y29uY2F0MWRffSksY29uY2F0MmQ9b3Aoe2NvbmNhdDJkXzpjb25jYXQyZF99KSxjb25jYXQzZD1vcCh7Y29uY2F0M2RfOmNvbmNhdDNkX30pLGNvbmNhdDRkPW9wKHtjb25jYXQ0ZF86Y29uY2F0NGRffSksc3BsaXQkMT1vcCh7c3BsaXRfOnNwbGl0X30pLGNvbW1vbmpzR2xvYmFsPVwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/d2luZG93OlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Z2xvYmFsOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmP3NlbGY6e307ZnVuY3Rpb24gY3JlYXRlQ29tbW9uanNNb2R1bGUoZSx0KXtyZXR1cm4gZSh0PXtleHBvcnRzOnt9fSx0LmV4cG9ydHMpLHQuZXhwb3J0c312YXIgYWxlYT1jcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbihlKXshZnVuY3Rpb24oZSx0LHIpe2Z1bmN0aW9uIG4oZSx0KXtyZXR1cm4gdC5jPWUuYyx0LnMwPWUuczAsdC5zMT1lLnMxLHQuczI9ZS5zMix0fWZ1bmN0aW9uIG8oZSx0KXt2YXIgcj1uZXcgZnVuY3Rpb24oZSl7dmFyIHQscj10aGlzLG49KHQ9NDAyMjg3MTE5NyxmdW5jdGlvbihlKXtlPWUudG9TdHJpbmcoKTtmb3IodmFyIHI9MDtyPGUubGVuZ3RoO3IrKyl7dmFyIG49LjAyNTE5NjAzMjgyNDE2OTM4Kih0Kz1lLmNoYXJDb2RlQXQocikpO24tPXQ9bj4+PjAsdD0obio9dCk+Pj4wLHQrPTQyOTQ5NjcyOTYqKG4tPXQpfXJldHVybiAyLjMyODMwNjQzNjUzODY5NjNlLTEwKih0Pj4+MCl9KTtyLm5leHQ9ZnVuY3Rpb24oKXt2YXIgZT0yMDkxNjM5KnIuczArMi4zMjgzMDY0MzY1Mzg2OTYzZS0xMCpyLmM7cmV0dXJuIHIuczA9ci5zMSxyLnMxPXIuczIsci5zMj1lLShyLmM9MHxlKX0sci5jPTEsci5zMD1uKFwiIFwiKSxyLnMxPW4oXCIgXCIpLHIuczI9bihcIiBcIiksci5zMC09bihlKSxyLnMwPDAmJihyLnMwKz0xKSxyLnMxLT1uKGUpLHIuczE8MCYmKHIuczErPTEpLHIuczItPW4oZSksci5zMjwwJiYoci5zMis9MSksbj1udWxsfShlKSxvPXQmJnQuc3RhdGUsYT1yLm5leHQ7cmV0dXJuIGEuaW50MzI9ZnVuY3Rpb24oKXtyZXR1cm4gNDI5NDk2NzI5NipyLm5leHQoKXwwfSxhLmRvdWJsZT1mdW5jdGlvbigpe3JldHVybiBhKCkrMS4xMTAyMjMwMjQ2MjUxNTY1ZS0xNiooMjA5NzE1MiphKCl8MCl9LGEucXVpY2s9YSxvJiYoXCJvYmplY3RcIj09dHlwZW9mIG8mJm4obyxyKSxhLnN0YXRlPWZ1bmN0aW9uKCl7cmV0dXJuIG4ocix7fSl9KSxhfXQmJnQuZXhwb3J0cz90LmV4cG9ydHM9bzpyJiZyLmFtZD9yKGZ1bmN0aW9uKCl7cmV0dXJuIG99KTp0aGlzLmFsZWE9b30oMCxlLCExKX0pLHhvcjEyOD1jcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbihlKXshZnVuY3Rpb24oZSx0LHIpe2Z1bmN0aW9uIG4oZSx0KXtyZXR1cm4gdC54PWUueCx0Lnk9ZS55LHQuej1lLnosdC53PWUudyx0fWZ1bmN0aW9uIG8oZSx0KXt2YXIgcj1uZXcgZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcyxyPVwiXCI7dC54PTAsdC55PTAsdC56PTAsdC53PTAsdC5uZXh0PWZ1bmN0aW9uKCl7dmFyIGU9dC54XnQueDw8MTE7cmV0dXJuIHQueD10LnksdC55PXQueix0Lno9dC53LHQud149dC53Pj4+MTleZV5lPj4+OH0sZT09PSgwfGUpP3QueD1lOnIrPWU7Zm9yKHZhciBuPTA7bjxyLmxlbmd0aCs2NDtuKyspdC54Xj0wfHIuY2hhckNvZGVBdChuKSx0Lm5leHQoKX0oZSksbz10JiZ0LnN0YXRlLGE9ZnVuY3Rpb24oKXtyZXR1cm4oci5uZXh0KCk+Pj4wKS80Mjk0OTY3Mjk2fTtyZXR1cm4gYS5kb3VibGU9ZnVuY3Rpb24oKXtkb3t2YXIgZT0oKHIubmV4dCgpPj4+MTEpKyhyLm5leHQoKT4+PjApLzQyOTQ5NjcyOTYpLygxPDwyMSl9d2hpbGUoMD09PWUpO3JldHVybiBlfSxhLmludDMyPXIubmV4dCxhLnF1aWNrPWEsbyYmKFwib2JqZWN0XCI9PXR5cGVvZiBvJiZuKG8sciksYS5zdGF0ZT1mdW5jdGlvbigpe3JldHVybiBuKHIse30pfSksYX10JiZ0LmV4cG9ydHM/dC5leHBvcnRzPW86ciYmci5hbWQ/cihmdW5jdGlvbigpe3JldHVybiBvfSk6dGhpcy54b3IxMjg9b30oMCxlLCExKX0pLHhvcndvdz1jcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbihlKXshZnVuY3Rpb24oZSx0LHIpe2Z1bmN0aW9uIG4oZSx0KXtyZXR1cm4gdC54PWUueCx0Lnk9ZS55LHQuej1lLnosdC53PWUudyx0LnY9ZS52LHQuZD1lLmQsdH1mdW5jdGlvbiBvKGUsdCl7dmFyIHI9bmV3IGZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMscj1cIlwiO3QubmV4dD1mdW5jdGlvbigpe3ZhciBlPXQueF50Lng+Pj4yO3JldHVybiB0Lng9dC55LHQueT10LnosdC56PXQudyx0Lnc9dC52LCh0LmQ9dC5kKzM2MjQzN3wwKSsodC52PXQudl50LnY8PDReZV5lPDwxKXwwfSx0Lng9MCx0Lnk9MCx0Lno9MCx0Lnc9MCx0LnY9MCxlPT09KDB8ZSk/dC54PWU6cis9ZTtmb3IodmFyIG49MDtuPHIubGVuZ3RoKzY0O24rKyl0LnhePTB8ci5jaGFyQ29kZUF0KG4pLG49PXIubGVuZ3RoJiYodC5kPXQueDw8MTBedC54Pj4+NCksdC5uZXh0KCl9KGUpLG89dCYmdC5zdGF0ZSxhPWZ1bmN0aW9uKCl7cmV0dXJuKHIubmV4dCgpPj4+MCkvNDI5NDk2NzI5Nn07cmV0dXJuIGEuZG91YmxlPWZ1bmN0aW9uKCl7ZG97dmFyIGU9KChyLm5leHQoKT4+PjExKSsoci5uZXh0KCk+Pj4wKS80Mjk0OTY3Mjk2KS8oMTw8MjEpfXdoaWxlKDA9PT1lKTtyZXR1cm4gZX0sYS5pbnQzMj1yLm5leHQsYS5xdWljaz1hLG8mJihcIm9iamVjdFwiPT10eXBlb2YgbyYmbihvLHIpLGEuc3RhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gbihyLHt9KX0pLGF9dCYmdC5leHBvcnRzP3QuZXhwb3J0cz1vOnImJnIuYW1kP3IoZnVuY3Rpb24oKXtyZXR1cm4gb30pOnRoaXMueG9yd293PW99KDAsZSwhMSl9KSx4b3JzaGlmdDc9Y3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKGUsdCxyKXtmdW5jdGlvbiBuKGUsdCl7cmV0dXJuIHQueD1lLnguc2xpY2UoKSx0Lmk9ZS5pLHR9ZnVuY3Rpb24gbyhlLHQpe251bGw9PWUmJihlPStuZXcgRGF0ZSk7dmFyIHI9bmV3IGZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7dC5uZXh0PWZ1bmN0aW9uKCl7dmFyIGUscixuPXQueCxvPXQuaTtyZXR1cm4gZT1uW29dLHI9KGVePWU+Pj43KV5lPDwyNCxyXj0oZT1uW28rMSY3XSleZT4+PjEwLHJePShlPW5bbyszJjddKV5lPj4+MyxyXj0oZT1uW28rNCY3XSleZTw8NyxlPW5bbys3JjddLHJePShlXj1lPDwxMyleZTw8OSxuW29dPXIsdC5pPW8rMSY3LHJ9LGZ1bmN0aW9uKGUsdCl7dmFyIHIsbj1bXTtpZih0PT09KDB8dCkpblswXT10O2Vsc2UgZm9yKHQ9XCJcIit0LHI9MDtyPHQubGVuZ3RoOysrciluWzcmcl09bls3JnJdPDwxNV50LmNoYXJDb2RlQXQocikrbltyKzEmN108PDEzO2Zvcig7bi5sZW5ndGg8ODspbi5wdXNoKDApO2ZvcihyPTA7cjw4JiYwPT09bltyXTsrK3IpO2Zvcig4PT1yP25bN109LTE6bltyXSxlLng9bixlLmk9MCxyPTI1NjtyPjA7LS1yKWUubmV4dCgpfSh0LGUpfShlKSxvPXQmJnQuc3RhdGUsYT1mdW5jdGlvbigpe3JldHVybihyLm5leHQoKT4+PjApLzQyOTQ5NjcyOTZ9O3JldHVybiBhLmRvdWJsZT1mdW5jdGlvbigpe2Rve3ZhciBlPSgoci5uZXh0KCk+Pj4xMSkrKHIubmV4dCgpPj4+MCkvNDI5NDk2NzI5NikvKDE8PDIxKX13aGlsZSgwPT09ZSk7cmV0dXJuIGV9LGEuaW50MzI9ci5uZXh0LGEucXVpY2s9YSxvJiYoby54JiZuKG8sciksYS5zdGF0ZT1mdW5jdGlvbigpe3JldHVybiBuKHIse30pfSksYX10JiZ0LmV4cG9ydHM/dC5leHBvcnRzPW86ciYmci5hbWQ/cihmdW5jdGlvbigpe3JldHVybiBvfSk6dGhpcy54b3JzaGlmdDc9b30oMCxlLCExKX0pLHhvcjQwOTY9Y3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKGUsdCxyKXtmdW5jdGlvbiBuKGUsdCl7cmV0dXJuIHQuaT1lLmksdC53PWUudyx0Llg9ZS5YLnNsaWNlKCksdH1mdW5jdGlvbiBvKGUsdCl7bnVsbD09ZSYmKGU9K25ldyBEYXRlKTt2YXIgcj1uZXcgZnVuY3Rpb24oZSl7dmFyIHQ9dGhpczt0Lm5leHQ9ZnVuY3Rpb24oKXt2YXIgZSxyLG49dC53LG89dC5YLGE9dC5pO3JldHVybiB0Lnc9bj1uKzE2NDA1MzE1Mjd8MCxyPW9bYSszNCYxMjddLGU9b1thPWErMSYxMjddLHJePXI8PDEzLGVePWU8PDE3LHJePXI+Pj4xNSxlXj1lPj4+MTIscj1vW2FdPXJeZSx0Lmk9YSxyKyhuXm4+Pj4xNil8MH0sZnVuY3Rpb24oZSx0KXt2YXIgcixuLG8sYSxpLHM9W10sdT0xMjg7Zm9yKHQ9PT0oMHx0KT8obj10LHQ9bnVsbCk6KHQrPVwiXFwwXCIsbj0wLHU9TWF0aC5tYXgodSx0Lmxlbmd0aCkpLG89MCxhPS0zMjthPHU7KythKXQmJihuXj10LmNoYXJDb2RlQXQoKGErMzIpJXQubGVuZ3RoKSksMD09PWEmJihpPW4pLG5ePW48PDEwLG5ePW4+Pj4xNSxuXj1uPDw0LG5ePW4+Pj4xMyxhPj0wJiYoaT1pKzE2NDA1MzE1Mjd8MCxvPTA9PShyPXNbMTI3JmFdXj1uK2kpP28rMTowKTtmb3Iobz49MTI4JiYoc1sxMjcmKHQmJnQubGVuZ3RofHwwKV09LTEpLG89MTI3LGE9NTEyO2E+MDstLWEpbj1zW28rMzQmMTI3XSxyPXNbbz1vKzEmMTI3XSxuXj1uPDwxMyxyXj1yPDwxNyxuXj1uPj4+MTUscl49cj4+PjEyLHNbb109bl5yO2Uudz1pLGUuWD1zLGUuaT1vfSh0LGUpfShlKSxvPXQmJnQuc3RhdGUsYT1mdW5jdGlvbigpe3JldHVybihyLm5leHQoKT4+PjApLzQyOTQ5NjcyOTZ9O3JldHVybiBhLmRvdWJsZT1mdW5jdGlvbigpe2Rve3ZhciBlPSgoci5uZXh0KCk+Pj4xMSkrKHIubmV4dCgpPj4+MCkvNDI5NDk2NzI5NikvKDE8PDIxKX13aGlsZSgwPT09ZSk7cmV0dXJuIGV9LGEuaW50MzI9ci5uZXh0LGEucXVpY2s9YSxvJiYoby5YJiZuKG8sciksYS5zdGF0ZT1mdW5jdGlvbigpe3JldHVybiBuKHIse30pfSksYX10JiZ0LmV4cG9ydHM/dC5leHBvcnRzPW86ciYmci5hbWQ/cihmdW5jdGlvbigpe3JldHVybiBvfSk6dGhpcy54b3I0MDk2PW99KDAsZSwhMSl9KSx0eWNoZWk9Y3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKGUsdCxyKXtmdW5jdGlvbiBuKGUsdCl7cmV0dXJuIHQuYT1lLmEsdC5iPWUuYix0LmM9ZS5jLHQuZD1lLmQsdH1mdW5jdGlvbiBvKGUsdCl7dmFyIHI9bmV3IGZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMscj1cIlwiO3QubmV4dD1mdW5jdGlvbigpe3ZhciBlPXQuYixyPXQuYyxuPXQuZCxvPXQuYTtyZXR1cm4gZT1lPDwyNV5lPj4+N15yLHI9ci1ufDAsbj1uPDwyNF5uPj4+OF5vLG89by1lfDAsdC5iPWU9ZTw8MjBeZT4+PjEyXnIsdC5jPXI9ci1ufDAsdC5kPW48PDE2XnI+Pj4xNl5vLHQuYT1vLWV8MH0sdC5hPTAsdC5iPTAsdC5jPS0xNjQwNTMxNTI3LHQuZD0xMzY3MTMwNTUxLGU9PT1NYXRoLmZsb29yKGUpPyh0LmE9ZS80Mjk0OTY3Mjk2fDAsdC5iPTB8ZSk6cis9ZTtmb3IodmFyIG49MDtuPHIubGVuZ3RoKzIwO24rKyl0LmJePTB8ci5jaGFyQ29kZUF0KG4pLHQubmV4dCgpfShlKSxvPXQmJnQuc3RhdGUsYT1mdW5jdGlvbigpe3JldHVybihyLm5leHQoKT4+PjApLzQyOTQ5NjcyOTZ9O3JldHVybiBhLmRvdWJsZT1mdW5jdGlvbigpe2Rve3ZhciBlPSgoci5uZXh0KCk+Pj4xMSkrKHIubmV4dCgpPj4+MCkvNDI5NDk2NzI5NikvKDE8PDIxKX13aGlsZSgwPT09ZSk7cmV0dXJuIGV9LGEuaW50MzI9ci5uZXh0LGEucXVpY2s9YSxvJiYoXCJvYmplY3RcIj09dHlwZW9mIG8mJm4obyxyKSxhLnN0YXRlPWZ1bmN0aW9uKCl7cmV0dXJuIG4ocix7fSl9KSxhfXQmJnQuZXhwb3J0cz90LmV4cG9ydHM9bzpyJiZyLmFtZD9yKGZ1bmN0aW9uKCl7cmV0dXJuIG99KTp0aGlzLnR5Y2hlaT1vfSgwLGUsITEpfSksc2VlZHJhbmRvbT1jcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbihlKXshZnVuY3Rpb24odCxyKXt2YXIgbixvPXRoaXMsYT0yNTYsaT02LHM9XCJyYW5kb21cIix1PXIucG93KGEsaSksbD1yLnBvdygyLDUyKSxjPTIqbCxwPWEtMTtmdW5jdGlvbiBkKGUsZCxnKXt2YXIgdj1bXSx5PWYoZnVuY3Rpb24gZSh0LHIpe3ZhciBuLG89W10sYT10eXBlb2YgdDtpZihyJiZcIm9iamVjdFwiPT1hKWZvcihuIGluIHQpdHJ5e28ucHVzaChlKHRbbl0sci0xKSl9Y2F0Y2goZSl7fXJldHVybiBvLmxlbmd0aD9vOlwic3RyaW5nXCI9PWE/dDp0K1wiXFwwXCJ9KChkPTE9PWQ/e2VudHJvcHk6ITB9OmR8fHt9KS5lbnRyb3B5P1tlLG0odCldOm51bGw9PWU/ZnVuY3Rpb24oKXt0cnl7dmFyIGU7cmV0dXJuIG4mJihlPW4ucmFuZG9tQnl0ZXMpP2U9ZShhKTooZT1uZXcgVWludDhBcnJheShhKSwoby5jcnlwdG98fG8ubXNDcnlwdG8pLmdldFJhbmRvbVZhbHVlcyhlKSksbShlKX1jYXRjaChlKXt2YXIgcj1vLm5hdmlnYXRvcixpPXImJnIucGx1Z2lucztyZXR1cm5bK25ldyBEYXRlLG8saSxvLnNjcmVlbixtKHQpXX19KCk6ZSwzKSx2KSx4PW5ldyBmdW5jdGlvbihlKXt2YXIgdCxyPWUubGVuZ3RoLG49dGhpcyxvPTAsaT1uLmk9bi5qPTAscz1uLlM9W107cnx8KGU9W3IrK10pO2Zvcig7bzxhOylzW29dPW8rKztmb3Iobz0wO288YTtvKyspc1tvXT1zW2k9cCZpK2VbbyVyXSsodD1zW29dKV0sc1tpXT10OyhuLmc9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0LHI9MCxvPW4uaSxpPW4uaixzPW4uUztlLS07KXQ9c1tvPXAmbysxXSxyPXIqYStzW3AmKHNbb109c1tpPXAmaSt0XSkrKHNbaV09dCldO3JldHVybiBuLmk9byxuLmo9aSxyfSkoYSl9KHYpLFQ9ZnVuY3Rpb24oKXtmb3IodmFyIGU9eC5nKGkpLHQ9dSxyPTA7ZTxsOyllPShlK3IpKmEsdCo9YSxyPXguZygxKTtmb3IoO2U+PWM7KWUvPTIsdC89MixyPj4+PTE7cmV0dXJuKGUrcikvdH07cmV0dXJuIFQuaW50MzI9ZnVuY3Rpb24oKXtyZXR1cm4gMHx4LmcoNCl9LFQucXVpY2s9ZnVuY3Rpb24oKXtyZXR1cm4geC5nKDQpLzQyOTQ5NjcyOTZ9LFQuZG91YmxlPVQsZihtKHguUyksdCksKGQucGFzc3x8Z3x8ZnVuY3Rpb24oZSx0LG4sbyl7cmV0dXJuIG8mJihvLlMmJmgobyx4KSxlLnN0YXRlPWZ1bmN0aW9uKCl7cmV0dXJuIGgoeCx7fSl9KSxuPyhyW3NdPWUsdCk6ZX0pKFQseSxcImdsb2JhbFwiaW4gZD9kLmdsb2JhbDp0aGlzPT1yLGQuc3RhdGUpfWZ1bmN0aW9uIGgoZSx0KXtyZXR1cm4gdC5pPWUuaSx0Lmo9ZS5qLHQuUz1lLlMuc2xpY2UoKSx0fWZ1bmN0aW9uIGYoZSx0KXtmb3IodmFyIHIsbj1lK1wiXCIsbz0wO288bi5sZW5ndGg7KXRbcCZvXT1wJihyXj0xOSp0W3Amb10pK24uY2hhckNvZGVBdChvKyspO3JldHVybiBtKHQpfWZ1bmN0aW9uIG0oZSl7cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoMCxlKX1pZihyW1wic2VlZFwiK3NdPWQsZihyLnJhbmRvbSgpLHQpLGUuZXhwb3J0cyl7ZS5leHBvcnRzPWQ7dHJ5e249cmVxdWlyZShcImNyeXB0b1wiKX1jYXRjaChlKXt9fWVsc2UgMH0oW10sTWF0aCl9KTtzZWVkcmFuZG9tLmFsZWE9YWxlYSxzZWVkcmFuZG9tLnhvcjEyOD14b3IxMjgsc2VlZHJhbmRvbS54b3J3b3c9eG9yd293LHNlZWRyYW5kb20ueG9yc2hpZnQ3PXhvcnNoaWZ0NyxzZWVkcmFuZG9tLnhvcjQwOTY9eG9yNDA5NixzZWVkcmFuZG9tLnR5Y2hlaT10eWNoZWk7dmFyIHNlZWRyYW5kb20kMT1zZWVkcmFuZG9tLHNlZWRyYW5kb21fMT1zZWVkcmFuZG9tJDEuYWxlYSxNUFJhbmRHYXVzcz1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0LHIsbixvKXt0aGlzLm1lYW49ZSx0aGlzLnN0ZERldj10LHRoaXMuZHR5cGU9cix0aGlzLm5leHRWYWw9TmFOLHRoaXMudHJ1bmNhdGVkPW4sdGhpcy50cnVuY2F0ZWQmJih0aGlzLnVwcGVyPXRoaXMubWVhbisyKnRoaXMuc3RkRGV2LHRoaXMubG93ZXI9dGhpcy5tZWFuLTIqdGhpcy5zdGREZXYpO3ZhciBhPW98fE1hdGgucmFuZG9tKCk7dGhpcy5yYW5kb209c2VlZHJhbmRvbV8xKGEudG9TdHJpbmcoKSl9cmV0dXJuIGUucHJvdG90eXBlLm5leHRWYWx1ZT1mdW5jdGlvbigpe2lmKCFpc05hTih0aGlzLm5leHRWYWwpKXt2YXIgZT10aGlzLm5leHRWYWw7cmV0dXJuIHRoaXMubmV4dFZhbD1OYU4sZX1mb3IodmFyIHQscixuPSExOyFuOyl7dmFyIG89dm9pZCAwLGE9dm9pZCAwLGk9dm9pZCAwO2Rve2k9KG89Mip0aGlzLnJhbmRvbSgpLTEpKm8rKGE9Mip0aGlzLnJhbmRvbSgpLTEpKmF9d2hpbGUoaT49MXx8MD09PWkpO3ZhciBzPU1hdGguc3FydCgtMipNYXRoLmxvZyhpKS9pKTt0PXRoaXMubWVhbit0aGlzLnN0ZERldipvKnMscj10aGlzLm1lYW4rdGhpcy5zdGREZXYqYSpzLHRoaXMudHJ1bmNhdGVkJiYhdGhpcy5pc1ZhbGlkVHJ1bmNhdGVkKHQpfHwobj0hMCl9cmV0dXJuIHRoaXMudHJ1bmNhdGVkJiYhdGhpcy5pc1ZhbGlkVHJ1bmNhdGVkKHIpfHwodGhpcy5uZXh0VmFsPXRoaXMuY29udmVydFZhbHVlKHIpKSx0aGlzLmNvbnZlcnRWYWx1ZSh0KX0sZS5wcm90b3R5cGUuY29udmVydFZhbHVlPWZ1bmN0aW9uKGUpe3JldHVybiBudWxsPT10aGlzLmR0eXBlfHxcImZsb2F0MzJcIj09PXRoaXMuZHR5cGU/ZTpNYXRoLnJvdW5kKGUpfSxlLnByb3RvdHlwZS5pc1ZhbGlkVHJ1bmNhdGVkPWZ1bmN0aW9uKGUpe3JldHVybiBlPD10aGlzLnVwcGVyJiZlPj10aGlzLmxvd2VyfSxlfSgpO2Z1bmN0aW9uIGNsb25lXyhlKXt2YXIgdD1jb252ZXJ0VG9UZW5zb3IoZSxcInhcIixcImNsb25lXCIpO3JldHVybiBFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbihlKXtyZXR1cm4gVGVuc29yLm1ha2UodC5zaGFwZSx7ZGF0YUlkOnQuZGF0YUlkfSx0LmR0eXBlKX0seyR4OnR9LGZ1bmN0aW9uKGUpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBlLnRvRmxvYXQoKX19fSl9ZnVuY3Rpb24gZXllXyhlLHQscixuKXt2b2lkIDA9PT1uJiYobj1cImZsb2F0MzJcIiksbnVsbD09dCYmKHQ9ZSk7Zm9yKHZhciBvPWJ1ZmZlcihbZSx0XSxuKSxhPWU8PXQ/ZTp0LGk9MDtpPGE7KytpKW8uc2V0KDEsaSxpKTt2YXIgcz1vLnRvVGVuc29yKCkuYXMyRChlLHQpO2lmKG51bGw9PXIpcmV0dXJuIHM7aWYoMT09PXIubGVuZ3RoKXJldHVybiB0aWxlKGV4cGFuZERpbXMocywwKSxbclswXSwxLDFdKTtpZigyPT09ci5sZW5ndGgpcmV0dXJuIHRpbGUoZXhwYW5kRGltcyhleHBhbmREaW1zKHMsMCksMCksW3JbMF0sclsxXSwxLDFdKTtpZigzPT09ci5sZW5ndGgpcmV0dXJuIHRpbGUoZXhwYW5kRGltcyhleHBhbmREaW1zKGV4cGFuZERpbXMocywwKSwwKSwwKSxbclswXSxyWzFdLHJbMl0sMSwxXSk7dGhyb3cgbmV3IEVycm9yKFwiZXllKCkgY3VycmVudGx5IHN1cHBvcnRzIG9ubHkgMUQgYW5kIDJEIGJhdGNoU2hhcGVzLCBidXQgcmVjZWl2ZWQgXCIrci5sZW5ndGgrXCJELlwiKX1mdW5jdGlvbiByYW5kb21Ob3JtYWxfKGUsdCxyLG4sbyl7aWYodm9pZCAwPT09dCYmKHQ9MCksdm9pZCAwPT09ciYmKHI9MSksbnVsbCE9biYmXCJib29sXCI9PT1uKXRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGRhdGEgdHlwZSBcIituKTtmb3IodmFyIGE9bmV3IE1QUmFuZEdhdXNzKHQscixuLCExLG8pLGk9YnVmZmVyKGUsbikscz0wO3M8aS52YWx1ZXMubGVuZ3RoO3MrKylpLnZhbHVlc1tzXT1hLm5leHRWYWx1ZSgpO3JldHVybiBpLnRvVGVuc29yKCl9ZnVuY3Rpb24gdHJ1bmNhdGVkTm9ybWFsXyhlLHQscixuLG8pe2lmKHZvaWQgMD09PXQmJih0PTApLHZvaWQgMD09PXImJihyPTEpLG51bGwhPW4mJlwiYm9vbFwiPT09bil0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBkYXRhIHR5cGUgXCIrbik7Zm9yKHZhciBhPW5ldyBNUFJhbmRHYXVzcyh0LHIsbiwhMCxvKSxpPWJ1ZmZlcihlLG4pLHM9MDtzPGkudmFsdWVzLmxlbmd0aDtzKyspaS52YWx1ZXNbc109YS5uZXh0VmFsdWUoKTtyZXR1cm4gaS50b1RlbnNvcigpfWZ1bmN0aW9uIHJhbmRvbVVuaWZvcm1fKGUsdCxyLG4pe3ZvaWQgMD09PXQmJih0PTApLHZvaWQgMD09PXImJihyPTEpLHZvaWQgMD09PW4mJihuPVwiZmxvYXQzMlwiKTtmb3IodmFyIG89YnVmZmVyKGUsbiksYT0wO2E8by52YWx1ZXMubGVuZ3RoO2ErKylvLnZhbHVlc1thXT1yYW5kVW5pZm9ybSh0LHIpO3JldHVybiBvLnRvVGVuc29yKCl9ZnVuY3Rpb24gcmFuZF8oZSx0LHIpe3ZhciBuPXNpemVGcm9tU2hhcGUoZSksbz1udWxsO2lmKG51bGw9PXJ8fFwiZmxvYXQzMlwiPT09cilvPW5ldyBGbG9hdDMyQXJyYXkobik7ZWxzZSBpZihcImludDMyXCI9PT1yKW89bmV3IEludDMyQXJyYXkobik7ZWxzZXtpZihcImJvb2xcIiE9PXIpdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkYXRhIHR5cGUgXCIrcik7bz1uZXcgVWludDhBcnJheShuKX1mb3IodmFyIGE9MDthPG47YSsrKW9bYV09dCgpO3JldHVybiBUZW5zb3IubWFrZShlLHt2YWx1ZXM6b30scil9ZnVuY3Rpb24gbXVsdGlub21pYWxfKGUsdCxyLG4pe3ZvaWQgMD09PW4mJihuPSExKTt2YXIgbz1jb252ZXJ0VG9UZW5zb3IoZSxcImxvZ2l0c1wiLFwibXVsdGlub21pYWxcIiksYT1vLnNpemUsaT1vLnJhbms7aWYoYTwyKXRocm93IG5ldyBFcnJvcihcIkVycm9yIGluIG11bHRpbm9taWFsOiB5b3UgbmVlZCBhdCBsZWFzdCAyIG91dGNvbWVzLCBidXQgZ290IFwiK2ErXCIuXCIpO2lmKGk+Mil0aHJvdyBuZXcgRXJyb3IoXCJSYW5rIG9mIHByb2JhYmlsaXRpZXMgbXVzdCBiZSAxIG9yIDIsIGJ1dCBpcyBcIitpKTtyPXJ8fE1hdGgucmFuZG9tKCk7dmFyIHM9MT09PWk/by5hczJEKDEsLTEpOm8sdT1FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbihlKXtyZXR1cm4gZS5tdWx0aW5vbWlhbChzLG4sdCxyKX0se2xvZ2l0czJEOnN9KTtyZXR1cm4gMT09PWk/dS5hczFEKCk6dX1mdW5jdGlvbiBvbmVIb3RfKGUsdCxyLG4pe3ZvaWQgMD09PXImJihyPTEpLHZvaWQgMD09PW4mJihuPTApO3ZhciBvPWNvbnZlcnRUb1RlbnNvcihlLFwiaW5kaWNlc1wiLFwib25lSG90XCIsXCJpbnQzMlwiKTtpZihhc3NlcnQoXCJpbnQzMlwiPT09by5kdHlwZSxcIkluZGljZXMgbXVzdCBiZSBvZiBkdHlwZSBgaW50MzJgXCIpLHQ8Mil0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBpbiBvbmVIb3Q6IGRlcHRoIG11c3QgYmUgPj0yLCBidXQgaXQgaXMgXCIrdCk7cmV0dXJuIEVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKGUpe3JldHVybiBlLm9uZUhvdChvLHQscixuKX0seyRpbmRpY2VzOm99LGZ1bmN0aW9uKGUpe3JldHVybnskaW5kaWNlczpmdW5jdGlvbigpe3JldHVybiB6ZXJvc0xpa2Uobyl9fX0pfWZ1bmN0aW9uIGZyb21QaXhlbHNfKGUsdCl7aWYodm9pZCAwPT09dCYmKHQ9MyksdD40KXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb25zdHJ1Y3QgVGVuc29yIHdpdGggbW9yZSB0aGFuIDQgY2hhbm5lbHMgZnJvbSBwaXhlbHMuXCIpO3JldHVybiBFTlYuZW5naW5lLmZyb21QaXhlbHMoZSx0KX1mdW5jdGlvbiB0b1BpeGVscyhlLHQpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHIsbixvLGEsaSxzLHUsbCxjLHAsZCxoLGYsbSxnLHYseSx4LFQsRTtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbih3KXtzd2l0Y2gody5sYWJlbCl7Y2FzZSAwOmlmKDIhPT0ocj1jb252ZXJ0VG9UZW5zb3IoZSxcImltZ1wiLFwidG9QaXhlbHNcIixcImludDMyXCIpKS5yYW5rJiYzIT09ci5yYW5rKXRocm93IG5ldyBFcnJvcihcInRvUGl4ZWxzIG9ubHkgc3VwcG9ydHMgcmFuayAyIG9yIDMgdGVuc29ycywgZ290IHJhbmsgXCIrci5yYW5rK1wiLlwiKTtpZihuPXIuc2hhcGUuc2xpY2UoMCwyKSxvPW5bMF0sYT1uWzFdLChpPTI9PT1yLnJhbms/MTpyLnNoYXBlWzJdKT40fHwyPT09aSl0aHJvdyBuZXcgRXJyb3IoXCJ0b1BpeGVscyBvbmx5IHN1cHBvcnRzIGRlcHRoIG9mIHNpemUgMSwgMyBvciA0IGJ1dCBnb3QgXCIraSk7cmV0dXJuIHM9ci5taW4oKSx1PXIubWF4KCksWzQscy5kYXRhKCldO2Nhc2UgMTpyZXR1cm4gbD13LnNlbnQoKVswXSxbNCx1LmRhdGEoKV07Y2FzZSAyOmlmKGM9dy5zZW50KClbMF0scy5kaXNwb3NlKCksdS5kaXNwb3NlKCksXCJmbG9hdDMyXCI9PT1yLmR0eXBlKXtpZihsPDB8fGM+MSl0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3IgdmFsdWVzIGZvciBhIGZsb2F0MzIgVGVuc29yIG11c3QgYmUgaW4gdGhlIHJhbmdlIFswIC0gMV0gYnV0IGdvdCByYW5nZSBbXCIrbCtcIiAtIFwiK2MrXCJdLlwiKX1lbHNle2lmKFwiaW50MzJcIiE9PXIuZHR5cGUpdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgdHlwZSBmb3IgdG9QaXhlbHM6IFwiK3IuZHR5cGUrXCIuIFBsZWFzZSB1c2UgZmxvYXQzMiBvciBpbnQzMiB0ZW5zb3JzLlwiKTtpZihsPDB8fGM+MjU1KXRocm93IG5ldyBFcnJvcihcIlRlbnNvciB2YWx1ZXMgZm9yIGEgaW50MzIgVGVuc29yIG11c3QgYmUgaW4gdGhlIHJhbmdlIFswIC0gMjU1XSBidXQgZ290IHJhbmdlIFtcIitsK1wiIC0gXCIrYytcIl0uXCIpfXJldHVybls0LHIuZGF0YSgpXTtjYXNlIDM6Zm9yKHA9dy5zZW50KCksZD1cImZsb2F0MzJcIj09PXIuZHR5cGU/MjU1OjEsaD1uZXcgVWludDhDbGFtcGVkQXJyYXkoYSpvKjQpLGY9MDtmPG8qYTsrK2YpbT12b2lkIDAsZz12b2lkIDAsdj12b2lkIDAseT12b2lkIDAsMT09PWk/KG09cFtmXSpkLGc9cFtmXSpkLHY9cFtmXSpkLHk9MjU1KTozPT09aT8obT1wWzMqZl0qZCxnPXBbMypmKzFdKmQsdj1wWzMqZisyXSpkLHk9MjU1KTo0PT09aSYmKG09cFs0KmZdKmQsZz1wWzQqZisxXSpkLHY9cFs0KmYrMl0qZCx5PXBbNCpmKzNdKmQpLGhbKHg9NCpmKSswXT1NYXRoLnJvdW5kKG0pLGhbeCsxXT1NYXRoLnJvdW5kKGcpLGhbeCsyXT1NYXRoLnJvdW5kKHYpLGhbeCszXT1NYXRoLnJvdW5kKHkpO3JldHVybiBudWxsIT10JiYodC53aWR0aD1hLHQuaGVpZ2h0PW8sVD10LmdldENvbnRleHQoXCIyZFwiKSxFPW5ldyBJbWFnZURhdGEoaCxhLG8pLFQucHV0SW1hZ2VEYXRhKEUsMCwwKSksciE9PWUmJnIuZGlzcG9zZSgpLFsyLGhdfX0pfSl9ZnVuY3Rpb24gcmVzaGFwZV8oZSx0KXt2YXIgcj1jb252ZXJ0VG9UZW5zb3IoZSxcInhcIixcInJlc2hhcGVcIik7dD1pbmZlckZyb21JbXBsaWNpdFNoYXBlKHQsci5zaXplKSxhc3NlcnQoci5zaXplPT09c2l6ZUZyb21TaGFwZSh0KSxcIm5ldyBzaGFwZSBhbmQgb2xkIHNoYXBlIG11c3QgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgZWxlbWVudHMuXCIpO3JldHVybiBFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbihlKXtyZXR1cm4gZS5yZXNoYXBlKHIsdCl9LHskeDpyfSxmdW5jdGlvbihlKXtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gZS5yZXNoYXBlKHIuc2hhcGUpfX19KX1mdW5jdGlvbiBzcXVlZXplXyhlLHQpe3ZhciByPWNvbnZlcnRUb1RlbnNvcihlLFwieFwiLFwic3F1ZWV6ZVwiKTtyZXR1cm4gcmVzaGFwZShyLHNxdWVlemVTaGFwZShyLnNoYXBlLHQpLm5ld1NoYXBlKX1mdW5jdGlvbiBjYXN0XyhlLHQpe3ZhciByPWNvbnZlcnRUb1RlbnNvcihlLFwieFwiLFwiY2FzdFwiKTtyZXR1cm4gRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24oZSl7cmV0dXJuIGUuY2FzdChyLHQpfSx7JHg6cn0sZnVuY3Rpb24oZSl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIGUuY2xvbmUoKX19fSl9ZnVuY3Rpb24gdGlsZV8oZSx0KXt2YXIgcj1jb252ZXJ0VG9UZW5zb3IoZSxcInhcIixcInRpbGVcIik7YXNzZXJ0KHIucmFuaz09PXQubGVuZ3RoLFwiRXJyb3IgaW4gdHJhbnNwb3NlOiByYW5rIG9mIGlucHV0IFwiK3IucmFuaytcIiBtdXN0IG1hdGNoIGxlbmd0aCBvZiByZXBzIFwiK3QrXCIuXCIpO3JldHVybiBFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbihlKXtyZXR1cm4gZS50aWxlKHIsdCl9LHskeDpyfSxmdW5jdGlvbihlKXtyZXR1cm57JHg6ZnVuY3Rpb24oKXt2YXIgbj16ZXJvc0xpa2Uocik7aWYoMT09PXIucmFuaylmb3IodmFyIG89MDtvPHRbMF07KytvKW49bi5hZGQoZS5zbGljZShbbypyLnNoYXBlWzBdXSxbci5zaGFwZVswXV0pKTtlbHNlIGlmKDI9PT1yLnJhbmspZm9yKG89MDtvPHRbMF07KytvKWZvcih2YXIgYT0wO2E8dFsxXTsrK2Epbj1uLmFkZChlLnNsaWNlKFtvKnIuc2hhcGVbMF0sYSpyLnNoYXBlWzFdXSxbci5zaGFwZVswXSxyLnNoYXBlWzFdXSkpO2Vsc2UgaWYoMz09PXIucmFuaylmb3Iobz0wO288dFswXTsrK28pZm9yKGE9MDthPHRbMV07KythKWZvcih2YXIgaT0wO2k8dFsyXTsrK2kpbj1uLmFkZChlLnNsaWNlKFtvKnIuc2hhcGVbMF0sYSpyLnNoYXBlWzFdLGkqci5zaGFwZVsyXV0sW3Iuc2hhcGVbMF0sci5zaGFwZVsxXSxyLnNoYXBlWzJdXSkpO2Vsc2V7aWYoNCE9PXIucmFuayl0aHJvdyBuZXcgRXJyb3IoXCJHcmFkaWVudCBmb3IgdGlsZSBvcGVyYXRpb24gaXMgbm90IGltcGxlbWVudGVkIGZvciByYW5rLVwiK3IucmFuaytcIiB0ZW5zb3JzIHlldC5cIik7Zm9yKG89MDtvPHRbMF07KytvKWZvcihhPTA7YTx0WzFdOysrYSlmb3IoaT0wO2k8dFsyXTsrK2kpZm9yKHZhciBzPTA7czx0WzNdOysrcyluPW4uYWRkKGUuc2xpY2UoW28qci5zaGFwZVswXSxhKnIuc2hhcGVbMV0saSpyLnNoYXBlWzJdLHMqci5zaGFwZVszXV0sW3Iuc2hhcGVbMF0sci5zaGFwZVsxXSxyLnNoYXBlWzJdLHIuc2hhcGVbM11dKSl9cmV0dXJuIG59fX0pfWZ1bmN0aW9uIHBhZDFkXyhlLHQscil7cmV0dXJuIHZvaWQgMD09PXImJihyPTApLGFzc2VydCgyPT09dC5sZW5ndGgsXCJJbnZhbGlkIG51bWJlciBvZiBwYWRkaW5ncy4gTXVzdCBiZSBsZW5ndGggb2YgMi5cIikscGFkKGUsW3RdLHIpfWZ1bmN0aW9uIHBhZDJkXyhlLHQscil7cmV0dXJuIHZvaWQgMD09PXImJihyPTApLGFzc2VydCgyPT09dC5sZW5ndGgmJjI9PT10WzBdLmxlbmd0aCYmMj09PXRbMV0ubGVuZ3RoLFwiSW52YWxpZCBudW1iZXIgb2YgcGFkZGluZ3MuIE11c3QgYmUgbGVuZ3RoIG9mIDIgZWFjaC5cIikscGFkKGUsdCxyKX1mdW5jdGlvbiBwYWQzZF8oZSx0LHIpe3JldHVybiB2b2lkIDA9PT1yJiYocj0wKSxhc3NlcnQoMz09PXQubGVuZ3RoJiYyPT09dFswXS5sZW5ndGgmJjI9PT10WzFdLmxlbmd0aCYmMj09PXRbMl0ubGVuZ3RoLFwiSW52YWxpZCBudW1iZXIgb2YgcGFkZGluZ3MuIE11c3QgYmUgbGVuZ3RoIG9mIDIgZWFjaC5cIikscGFkKGUsdCxyKX1mdW5jdGlvbiBwYWQ0ZF8oZSx0LHIpe3JldHVybiB2b2lkIDA9PT1yJiYocj0wKSxhc3NlcnQoND09PXQubGVuZ3RoJiYyPT09dFswXS5sZW5ndGgmJjI9PT10WzFdLmxlbmd0aCYmMj09PXRbMl0ubGVuZ3RoJiYyPT09dFszXS5sZW5ndGgsXCJJbnZhbGlkIG51bWJlciBvZiBwYWRkaW5ncy4gTXVzdCBiZSBsZW5ndGggb2YgMiBlYWNoLlwiKSxwYWQoZSx0LHIpfWZ1bmN0aW9uIHBhZF8oZSx0LHIpe3ZvaWQgMD09PXImJihyPTApO3ZhciBuPWNvbnZlcnRUb1RlbnNvcihlLFwieFwiLFwicGFkXCIpO2lmKDA9PT1uLnJhbmspdGhyb3cgbmV3IEVycm9yKFwicGFkKHNjYWxhcikgaXMgbm90IGRlZmluZWQuIFBhc3Mgbm9uLXNjYWxhciB0byBwYWRcIik7dmFyIG89dC5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGVbMF19KTtyZXR1cm4gRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24oZSl7cmV0dXJuIGUucGFkKG4sdCxyKX0seyR4Om59LGZ1bmN0aW9uKGUpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBlLnNsaWNlKG8sbi5zaGFwZSl9fX0pfWZ1bmN0aW9uIHN0YWNrXyhlLHQpe3ZvaWQgMD09PXQmJih0PTApO3ZhciByPWNvbnZlcnRUb1RlbnNvckFycmF5KGUsXCJ0ZW5zb3JzXCIsXCJzdGFja1wiKTtpZihhc3NlcnQoci5sZW5ndGg+PTEsXCJQYXNzIGF0IGxlYXN0IG9uZSB0ZW5zb3IgdG8gdGYuc3RhY2tcIiksMT09PXIubGVuZ3RoKXJldHVybiByWzBdLmV4cGFuZERpbXModCk7dmFyIG49clswXS5yYW5rLG89clswXS5zaGFwZSxhPXJbMF0uZHR5cGU7YXNzZXJ0KHQ8PW4sXCJBeGlzIG11c3QgYmUgPD0gcmFuayBvZiB0aGUgdGVuc29yXCIpLHIuZm9yRWFjaChmdW5jdGlvbihlKXthc3NlcnRTaGFwZXNNYXRjaChvLGUuc2hhcGUsXCJBbGwgdGVuc29ycyBwYXNzZWQgdG8gc3RhY2sgbXVzdCBoYXZlIG1hdGNoaW5nIHNoYXBlc1wiKX0pLHIuZm9yRWFjaChmdW5jdGlvbihlKXthc3NlcnQoYT09PWUuZHR5cGUsXCJBbGwgdGVuc29ycyBwYXNzZWQgdG8gc3RhY2sgbXVzdCBoYXZlIG1hdGNoaW5nIGR0eXBlc1wiKX0pO3ZhciBpPXIubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLmV4cGFuZERpbXModCl9KTtyZXR1cm4gY29uY2F0KGksdCl9ZnVuY3Rpb24gYmF0Y2hUb1NwYWNlTkRfKGUsdCxyKXt2YXIgbj1jb252ZXJ0VG9UZW5zb3IoZSxcInhcIixcImJhdGNoVG9TcGFjZU5EXCIpLG89dC5yZWR1Y2UoZnVuY3Rpb24oZSx0KXtyZXR1cm4gZSp0fSk7YXNzZXJ0KG4ucmFuaz49MSt0Lmxlbmd0aCxcImlucHV0IHJhbmsgaXMgXCIrbi5yYW5rK1wiIGJ1dCBzaG91bGQgYmUgPiB0aGFuIGJsb2NrU2hhcGUubGVuZ3RoIFwiK3QubGVuZ3RoKSxhc3NlcnQoci5sZW5ndGg9PT10Lmxlbmd0aCxcImNyb3BzLmxlbmd0aCBpcyBcIityLmxlbmd0aCtcIiBidXQgc2hvdWxkIGJlIGVxdWFsIHRvIGJsb2NrU2hhcGUubGVuZ3RoICBcIit0Lmxlbmd0aCksYXNzZXJ0KG4uc2hhcGVbMF0lbz09MCxcImlucHV0IHRlbnNvciBiYXRjaCBpcyBcIituLnNoYXBlWzBdK1wiIGJ1dCBpcyBub3QgZGl2aXNpYmxlIGJ5IHRoZSBwcm9kdWN0IG9mIHRoZSBlbGVtZW50cyBvZiBibG9ja1NoYXBlIFwiK3Quam9pbihcIiAqIFwiKStcIiA9PT0gXCIrbyk7cmV0dXJuIEVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKGUpe3JldHVybiBlLmJhdGNoVG9TcGFjZU5EKG4sdCxyKX0seyR4Om59LGZ1bmN0aW9uKGUpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBlLnNwYWNlVG9CYXRjaE5EKHQscil9fX0pfWZ1bmN0aW9uIHNwYWNlVG9CYXRjaE5EXyhlLHQscil7dmFyIG49Y29udmVydFRvVGVuc29yKGUsXCJ4XCIsXCJzcGFjZVRvQmF0Y2hORFwiKTthc3NlcnQobi5yYW5rPj0xK3QubGVuZ3RoLFwiaW5wdXQgcmFuayBcIituLnJhbmsrXCIgc2hvdWxkIGJlID4gdGhhbiBbYmxvY2tTaGFwZV0gXCIrdC5sZW5ndGgpLGFzc2VydChyLmxlbmd0aD09PXQubGVuZ3RoLFwicGFkZGluZ3Muc2hhcGVbMF0gXCIrci5sZW5ndGgrXCIgbXVzdCBiZSBlcXVhbCB0byBbYmxvY2tTaGFwZV0gXCIrdC5sZW5ndGgpLGFzc2VydChuLnNoYXBlLnJlZHVjZShmdW5jdGlvbihlLG4sbyl7cmV0dXJuIG8+MCYmbzw9dC5sZW5ndGg/ZSYmKG4rcltvLTFdWzBdK3Jbby0xXVsxXSkldFtvLTFdPT0wOmV9LCEwKSxcImlucHV0IHNwYXRpYWwgZGltZW5zaW9ucyBcIituLnNoYXBlLnNsaWNlKDEpK1wiIHdpdGggcGFkZGluZ3MgXCIrci50b1N0cmluZygpK1wiIG11c3QgYmUgZGl2aXNpYmxlIGJ5IGJsb2NrU2hhcGVzIFwiK3QudG9TdHJpbmcoKSk7cmV0dXJuIEVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKGUpe3JldHVybiBlLnNwYWNlVG9CYXRjaE5EKG4sdCxyKX0seyR4Om59LGZ1bmN0aW9uKGUpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBlLmJhdGNoVG9TcGFjZU5EKHQscil9fX0pfWZ1bmN0aW9uIHVuc3RhY2tfKGUsdCl7dm9pZCAwPT09dCYmKHQ9MCk7Zm9yKHZhciByLG49Y29udmVydFRvVGVuc29yKGUsXCJ4XCIsXCJ1bnN0YWNrXCIpLG89bi5zaGFwZVt0XSxhPUFycmF5KG4ucmFuay0xKS5maWxsKDApLGk9MCxzPTA7czxuLnJhbms7cysrKXMhPT10JiYoYVtpXT1uLnNoYXBlW3NdLGkrKyk7cj1BcnJheShvKS5maWxsKDEpO3ZhciB1PUFycmF5KG4ucmFuaykuZmlsbCgwKSxsPW4uc2hhcGUuc2xpY2UoKTtyZXR1cm4gci5tYXAoZnVuY3Rpb24oZSl7bFt0XT1lO3ZhciByPW4uc2xpY2UodSxsKTtyZXR1cm4gdVt0XSs9ZSxyLnJlc2hhcGUoYSl9KX1mdW5jdGlvbiBjdW1zdW1fKGUsdCxyLG4pe3ZvaWQgMD09PXQmJih0PTApLHZvaWQgMD09PXImJihyPSExKSx2b2lkIDA9PT1uJiYobj0hMSk7dmFyIG89Y29udmVydFRvVGVuc29yKGUsXCJ4XCIsXCJjdW1zdW1cIiksYT1nZXRBeGVzUGVybXV0YXRpb24oW3R8PTBdLG8ucmFuayksaT1vO251bGwhPWEmJihpPW8udHJhbnNwb3NlKGEpKTt2YXIgcz1nZXRJbm5lck1vc3RBeGVzKDEsby5yYW5rKVswXSx1PUVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKGUpe3JldHVybiBlLmN1bXN1bShpLHMscixuKX0se3Blcm11dGVkWDppfSxmdW5jdGlvbihlKXtyZXR1cm57cGVybXV0ZWRYOmZ1bmN0aW9uKCl7cmV0dXJuIGUuY3Vtc3VtKHQsciwhbil9fX0pO3JldHVybiBudWxsIT1hJiYodT11LnRyYW5zcG9zZShhKSksdX1mdW5jdGlvbiBleHBhbmREaW1zXyhlLHQpe3ZvaWQgMD09PXQmJih0PTApO3ZhciByPWNvbnZlcnRUb1RlbnNvcihlLFwieFwiLFwiZXhwYW5kRGltc1wiKTthc3NlcnQodDw9ci5yYW5rLFwiQXhpcyBtdXN0IGJlIDw9IHJhbmsgb2YgdGhlIHRlbnNvclwiKTt2YXIgbj1yLnNoYXBlLnNsaWNlKCk7cmV0dXJuIHQ8MCYmKGFzc2VydCgtKHIucmFuaysxKTw9dCxcIkF4aXMgbXVzdCBiZSBpbiB0aGUgaW50ZXJ2YWwgW1wiKy0oci5yYW5rKzEpK1wiLCBcIityLnJhbmsrXCJdXCIpLHQ9ci5yYW5rK3QrMSksbi5zcGxpY2UodCwwLDEpLHJlc2hhcGUocixuKX1mdW5jdGlvbiBkZXB0aFRvU3BhY2VfKGUsdCxyKXt2b2lkIDA9PT1yJiYocj1cIk5IV0NcIik7dmFyIG49Y29udmVydFRvVGVuc29yKGUsXCJ4XCIsXCJkZXB0aFRvU3BhY2VcIiksbz1cIk5IV0NcIj09PXI/bi5zaGFwZVsxXTpuLnNoYXBlWzJdLGE9XCJOSFdDXCI9PT1yP24uc2hhcGVbMl06bi5zaGFwZVszXSxpPVwiTkhXQ1wiPT09cj9uLnNoYXBlWzNdOm4uc2hhcGVbMV07cmV0dXJuIGFzc2VydChvKnQ+PTAsXCJOZWdhdGl2ZSBkaW1lbnNpb24gc2l6ZSBjYXVzZWQgYnkgb3ZlcmZsb3cgd2hlbiBtdWx0aXBseWluZ1xcbiAgICAgIFwiK28rXCIgYW5kIFwiK3QrXCIgIGZvciBkZXB0aFRvU3BhY2Ugd2l0aCBpbnB1dCBzaGFwZVxcbiAgICAgIFwiK24uc2hhcGUpLGFzc2VydChhKnQ+PTAsXCJOZWdhdGl2ZSBkaW1lbnNpb24gc2l6ZSBjYXVzZWQgYnkgb3ZlcmZsb3cgd2hlbiBtdWx0aXBseWluZ1xcbiAgICAgIFwiK2ErXCIgYW5kIFwiK3QrXCIgZm9yIGRlcHRoVG9TcGFjZSB3aXRoIGlucHV0IHNoYXBlXFxuICAgICAgICAgIFwiK24uc2hhcGUpLGFzc2VydChpJSh0KnQpPT0wLFwiRGltZW5zaW9uIHNpemUgbXVzdCBiZSBldmVubHkgZGl2aXNpYmxlIGJ5IFwiK3QqdCtcIiBidXQgaXMgXCIraStcIiBmb3IgZGVwdGhUb1NwYWNlIHdpdGggaW5wdXQgc2hhcGUgXCIrbi5zaGFwZSksRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24oZSl7cmV0dXJuIGUuZGVwdGhUb1NwYWNlKG4sdCxyKX0seyR4Om59KX1mdW5jdGlvbiBzZXRkaWZmMWRBc3luY18oZSx0KXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciByLG4sbyxhLGkscyx1LGwsYyxwO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGQpe3N3aXRjaChkLmxhYmVsKXtjYXNlIDA6cmV0dXJuIHI9Y29udmVydFRvVGVuc29yKGUsXCJ4XCIsXCJzZXRkaWZmMWRcIiksbj1jb252ZXJ0VG9UZW5zb3IodCxcInlcIixcInNldGRpZmYxZFwiKSxhc3NlcnQoci5kdHlwZT09PW4uZHR5cGUsXCJ4IGFuZCB5IHNob3VsZCBoYXZlIHRoZSBzYW1lIGR0eXBlLCBidXQgZ290IHggKFwiK3IuZHR5cGUrXCIpIGFuZCB5IChcIituLmR0eXBlK1wiKS5cIiksYXNzZXJ0KDE9PT1yLnJhbmssXCJ4IHNob3VsZCBiZSAxRCB0ZW5zb3IsIGJ1dCBnb3QgeCAoXCIrci5zaGFwZStcIikuXCIpLGFzc2VydCgxPT09bi5yYW5rLFwieSBzaG91bGQgYmUgMUQgdGVuc29yLCBidXQgZ290IHkgKFwiK24uc2hhcGUrXCIpLlwiKSxbNCxyLmRhdGEoKV07Y2FzZSAxOnJldHVybiBvPWQuc2VudCgpLFs0LG4uZGF0YSgpXTtjYXNlIDI6Zm9yKGE9ZC5zZW50KCksaT1uZXcgU2V0KGEpLHM9MCxjPTA7YzxvLmxlbmd0aDtjKyspaS5oYXMob1tjXSl8fHMrKztmb3IodT1uZXcgVGVuc29yQnVmZmVyKFtzXSxyLmR0eXBlKSxsPW5ldyBUZW5zb3JCdWZmZXIoW3NdLFwiaW50MzJcIiksYz0wLHA9MDtjPG8ubGVuZ3RoO2MrKylpLmhhcyhvW2NdKXx8KHUudmFsdWVzW3BdPW9bY10sbC52YWx1ZXNbcF09YyxwKyspO3JldHVyblsyLFt1LnRvVGVuc29yKCksbC50b1RlbnNvcigpXV19fSl9KX1mdW5jdGlvbiBidWZmZXIoZSx0LHIpe3JldHVybiB2b2lkIDA9PT10JiYodD1cImZsb2F0MzJcIiksbmV3IFRlbnNvckJ1ZmZlcihlLHQscil9ZnVuY3Rpb24gcHJpbnQoZSx0KXt2b2lkIDA9PT10JiYodD0hMSksY29uc29sZS5sb2coZS50b1N0cmluZyh0KSl9dmFyIGJhdGNoVG9TcGFjZU5EPW9wKHtiYXRjaFRvU3BhY2VORF86YmF0Y2hUb1NwYWNlTkRffSksY2FzdD1vcCh7Y2FzdF86Y2FzdF99KSxjbG9uZT1vcCh7Y2xvbmVfOmNsb25lX30pLGN1bXN1bT1vcCh7Y3Vtc3VtXzpjdW1zdW1ffSksZGVwdGhUb1NwYWNlPW9wKHtkZXB0aFRvU3BhY2VfOmRlcHRoVG9TcGFjZV99KSxleHBhbmREaW1zPW9wKHtleHBhbmREaW1zXzpleHBhbmREaW1zX30pLGV5ZT1vcCh7ZXllXzpleWVffSksZnJvbVBpeGVscz1vcCh7ZnJvbVBpeGVsc186ZnJvbVBpeGVsc199KSxtdWx0aW5vbWlhbD1vcCh7bXVsdGlub21pYWxfOm11bHRpbm9taWFsX30pLG9uZUhvdD1vcCh7b25lSG90XzpvbmVIb3RffSkscGFkPW9wKHtwYWRfOnBhZF99KSxwYWQxZD1vcCh7cGFkMWRfOnBhZDFkX30pLHBhZDJkPW9wKHtwYWQyZF86cGFkMmRffSkscGFkM2Q9b3Aoe3BhZDNkXzpwYWQzZF99KSxwYWQ0ZD1vcCh7cGFkNGRfOnBhZDRkX30pLHJhbmQ9b3Aoe3JhbmRfOnJhbmRffSkscmFuZG9tTm9ybWFsPW9wKHtyYW5kb21Ob3JtYWxfOnJhbmRvbU5vcm1hbF99KSxyYW5kb21Vbmlmb3JtPW9wKHtyYW5kb21Vbmlmb3JtXzpyYW5kb21Vbmlmb3JtX30pLHJlc2hhcGU9b3Aoe3Jlc2hhcGVfOnJlc2hhcGVffSksc3BhY2VUb0JhdGNoTkQ9b3Aoe3NwYWNlVG9CYXRjaE5EXzpzcGFjZVRvQmF0Y2hORF99KSxzcXVlZXplPW9wKHtzcXVlZXplXzpzcXVlZXplX30pLHN0YWNrPW9wKHtzdGFja186c3RhY2tffSksdGlsZT1vcCh7dGlsZV86dGlsZV99KSx0cnVuY2F0ZWROb3JtYWw9b3Aoe3RydW5jYXRlZE5vcm1hbF86dHJ1bmNhdGVkTm9ybWFsX30pLHVuc3RhY2s9b3Aoe3Vuc3RhY2tfOnVuc3RhY2tffSksc2V0ZGlmZjFkQXN5bmM9c2V0ZGlmZjFkQXN5bmNfO2Z1bmN0aW9uIHdoZXJlSW1wbChlLHQpe2Zvcih2YXIgcj1bXSxuPTA7bjx0Lmxlbmd0aDtuKyspdFtuXSYmci5wdXNoKG4pO3ZhciBvPWJ1ZmZlcihlLFwiaW50MzJcIiksYT1idWZmZXIoW3IubGVuZ3RoLGUubGVuZ3RoXSxcImludDMyXCIpO2ZvcihuPTA7bjxyLmxlbmd0aDtuKyspe3ZhciBpPW8uaW5kZXhUb0xvYyhyW25dKSxzPW4qZS5sZW5ndGg7YS52YWx1ZXMuc2V0KGkscyl9cmV0dXJuIGEudG9UZW5zb3IoKX12YXIgQ1BVX0hBTkRPRkZfU0laRV9USFJFU0hPTEQ9MTAsQkVGT1JFX1BBR0lOR19DT05TVEFOVD0zMDAsTUFUTVVMX1NIQVJFRF9ESU1fVEhSRVNIT0xEPTFlMyxNYXRoQmFja2VuZFdlYkdMPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQpe2lmKHZvaWQgMD09PXQmJih0PSEwKSx0aGlzLmdwZ3B1PWUsdGhpcy5kZWxheWVkU3RvcmFnZT10LHRoaXMucGVuZGluZ1JlYWQ9bmV3IFdlYWtNYXAsdGhpcy5wZW5kaW5nRGlzcG9zYWw9bmV3IFdlYWtTZXQsdGhpcy5scnVEYXRhR1BVPVtdLHRoaXMubnVtQnl0ZXNJbkdQVT0wLHRoaXMudXBsb2FkV2FpdE1zPTAsdGhpcy5kb3dubG9hZFdhaXRNcz0wLHRoaXMuYmluYXJ5Q2FjaGU9e30sdGhpcy5kaXNwb3NlZD0hMSxFTlYuZ2V0KFwiV0VCR0xfVkVSU0lPTlwiKTwxKXRocm93IG5ldyBFcnJvcihcIldlYkdMIGlzIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBkZXZpY2VcIik7aWYobnVsbD09ZSl7dmFyIHI9Z2V0V2ViR0xDb250ZXh0KEVOVi5nZXQoXCJXRUJHTF9WRVJTSU9OXCIpKTt0aGlzLmdwZ3B1PW5ldyBHUEdQVUNvbnRleHQociksdGhpcy5jYW52YXM9ci5jYW52YXMsdGhpcy5ncGdwdUNyZWF0ZWRMb2NhbGx5PSEwfWVsc2UgdGhpcy5ncGdwdUNyZWF0ZWRMb2NhbGx5PSExLHRoaXMuY2FudmFzPWUuZ2wuY2FudmFzO0VOVi5nZXQoXCJXRUJHTF9QQUdJTkdfRU5BQkxFRFwiKSYmKHRoaXMuTlVNX0JZVEVTX0JFRk9SRV9QQUdJTkc9d2luZG93LnNjcmVlbi5oZWlnaHQqd2luZG93LnNjcmVlbi53aWR0aCp3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbypCRUZPUkVfUEFHSU5HX0NPTlNUQU5UKSx0aGlzLnRleHR1cmVNYW5hZ2VyPW5ldyBUZXh0dXJlTWFuYWdlcih0aGlzLmdwZ3B1KX1yZXR1cm4gZS5wcm90b3R5cGUucmVnaXN0ZXI9ZnVuY3Rpb24oZSx0LHIpe2lmKHRoaXMudGV4RGF0YS5oYXMoZSkpdGhyb3cgbmV3IEVycm9yKFwiRGF0YSBidWZmZXIgaXMgYWxyZWFkeSByZWdpc3RlcmVkXCIpO3RoaXMudGV4RGF0YS5zZXQoZSx7c2hhcGU6dCxkdHlwZTpyLHZhbHVlczpudWxsLHRleHR1cmU6bnVsbCxjb21wbGV4VGVuc29yczpudWxsLHRleFNoYXBlOm51bGwsdXNhZ2U6VGV4dHVyZVVzYWdlLlJFTkRFUixpc1BhY2tlZDohMX0pfSxlLnByb3RvdHlwZS5zZXREYXRhTW92ZXI9ZnVuY3Rpb24oZSl7dGhpcy50ZXhEYXRhPW5ldyBEYXRhU3RvcmFnZShlKX0sZS5wcm90b3R5cGUuZnJvbVBpeGVscz1mdW5jdGlvbihlLHQpe2lmKG51bGw9PWUpdGhyb3cgbmV3IEVycm9yKFwicGl4ZWxzIHBhc3NlZCB0byB0Zi5mcm9tUGl4ZWxzKCkgY2FuIG5vdCBiZSBudWxsXCIpO3ZhciByPVtlLmhlaWdodCxlLndpZHRoXSxuPVtlLmhlaWdodCxlLndpZHRoLHRdO2lmKCEoZSBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnR8fGUgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50fHxlIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnR8fGUgaW5zdGFuY2VvZiBJbWFnZURhdGEpKXRocm93IG5ldyBFcnJvcihcInBpeGVscyBwYXNzZWQgdG8gdGYuZnJvbVBpeGVscygpIG11c3QgYmUgZWl0aGVyIGFuIEhUTUxWaWRlb0VsZW1lbnQsIEhUTUxJbWFnZUVsZW1lbnQsIEhUTUxDYW52YXNFbGVtZW50IG9yIEltYWdlRGF0YSwgYnV0IHdhcyBcIitlLmNvbnN0cnVjdG9yLm5hbWUpO2lmKGUgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50KXtpZihudWxsPT10aGlzLmZyb21QaXhlbHMyRENvbnRleHQpe2lmKCFFTlYuZ2V0KFwiSVNfQlJPV1NFUlwiKSl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCByZWFkIHBpeGVscyBmcm9tIEhUTUxJbWFnZUVsZW1lbnQgb3V0c2lkZSB0aGUgYnJvd3Nlci5cIik7aWYoXCJjb21wbGV0ZVwiIT09ZG9jdW1lbnQucmVhZHlTdGF0ZSl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgRE9NIGlzIG5vdCByZWFkeSB5ZXQuIFBsZWFzZSBjYWxsIHRmLmZyb21QaXhlbHMoKSBvbmNlIHRoZSBET00gaXMgcmVhZHkuIE9uZSB3YXkgdG8gZG8gdGhhdCBpcyB0byBhZGQgYW4gZXZlbnQgbGlzdGVuZXIgZm9yIGBET01Db250ZW50TG9hZGVkYCBvbiB0aGUgZG9jdW1lbnQgb2JqZWN0XCIpO3RoaXMuZnJvbVBpeGVsczJEQ29udGV4dD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLmdldENvbnRleHQoXCIyZFwiKX10aGlzLmZyb21QaXhlbHMyRENvbnRleHQuY2FudmFzLndpZHRoPWUud2lkdGgsdGhpcy5mcm9tUGl4ZWxzMkRDb250ZXh0LmNhbnZhcy5oZWlnaHQ9ZS5oZWlnaHQsdGhpcy5mcm9tUGl4ZWxzMkRDb250ZXh0LmRyYXdJbWFnZShlLDAsMCxlLndpZHRoLGUuaGVpZ2h0KSxlPXRoaXMuZnJvbVBpeGVsczJEQ29udGV4dC5jYW52YXN9dmFyIG89dGhpcy5tYWtlVGVuc29ySGFuZGxlKHIsXCJpbnQzMlwiKTt0aGlzLnRleERhdGEuZ2V0KG8uZGF0YUlkKS51c2FnZT1UZXh0dXJlVXNhZ2UuUElYRUxTLHRoaXMuZ3BncHUudXBsb2FkUGl4ZWxEYXRhVG9UZXh0dXJlKHRoaXMuZ2V0VGV4dHVyZShvLmRhdGFJZCksZSk7dmFyIGE9bmV3IEZyb21QaXhlbHNQcm9ncmFtKG4pLGk9dGhpcy5jb21waWxlQW5kUnVuKGEsW29dKTtyZXR1cm4gdGhpcy5kaXNwb3NlRGF0YShvLmRhdGFJZCksaX0sZS5wcm90b3R5cGUubWFrZVRlbnNvckhhbmRsZT1mdW5jdGlvbihlLHQpe3ZhciByPXt9O3JldHVybiB0aGlzLnJlZ2lzdGVyKHIsZSx0KSx7ZGF0YUlkOnIsc2hhcGU6ZSxkdHlwZTp0fX0sZS5wcm90b3R5cGUud3JpdGU9ZnVuY3Rpb24oZSx0KXtpZihudWxsPT10KXRocm93IG5ldyBFcnJvcihcIk1hdGhCYWNrZW5kV2ViR0wud3JpdGUoKTogdmFsdWVzIGNhbiBub3QgYmUgbnVsbFwiKTt2YXIgcj10aGlzLnRleERhdGEuZ2V0KGUpLG49ci50ZXh0dXJlLG89ci50ZXhTaGFwZSxhPXIudXNhZ2UsaT1yLmR0eXBlLHM9ci5pc1BhY2tlZDtpZihcImNvbXBsZXg2NFwiPT09aSl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgd3JpdGUgdG8gYSBjb21wbGV4NjQgZHR5cGUuIFBsZWFzZSB1c2UgdGYuY29tcGxleChyZWFsLCBpbWFnKS5cIik7bnVsbCE9biYmKHRoaXMucmVsZWFzZVRleHR1cmUoZSxuLG8sYSxzKSxyLnRleHR1cmU9bnVsbCxyLnRleFNoYXBlPW51bGwpLHIudXNhZ2U9VGV4dHVyZVVzYWdlLlVQTE9BRCxyLnZhbHVlcz10LHRoaXMuZGVsYXllZFN0b3JhZ2V8fHRoaXMudXBsb2FkVG9HUFUoZSl9LGUucHJvdG90eXBlLnJlYWRTeW5jPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMudGV4RGF0YS5nZXQoZSkscj10LnZhbHVlcyxuPXQuZHR5cGUsbz10LmNvbXBsZXhUZW5zb3JzO2lmKG51bGwhPXIpcmV0dXJuIHRoaXMuY29udmVydEFuZENhY2hlT25DUFUoZSk7dmFyIGEsaSxzPW51bGwhPXRoaXMuYWN0aXZlVGltZXJzOyhzJiYoYT1wZXJmb3JtYW5jZS5ub3coKSksXCJjb21wbGV4NjRcIj09PW4pP2k9bWVyZ2VSZWFsQW5kSW1hZ0FycmF5cyhvLnJlYWwuZGF0YVN5bmMoKSxvLmltYWcuZGF0YVN5bmMoKSk6aT10aGlzLmdldFZhbHVlc0Zyb21UZXh0dXJlKGUpO3JldHVybiBzJiYodGhpcy5kb3dubG9hZFdhaXRNcys9cGVyZm9ybWFuY2Uubm93KCktYSksdGhpcy5jb252ZXJ0QW5kQ2FjaGVPbkNQVShlLGkpfSxlLnByb3RvdHlwZS5yZWFkPWZ1bmN0aW9uKGUpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQscixuLG8sYSxpLHMsdSxsO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGMpe3N3aXRjaChjLmxhYmVsKXtjYXNlIDA6aWYodGhpcy5wZW5kaW5nUmVhZC5oYXMoZSkpcmV0dXJuIHQ9dGhpcy5wZW5kaW5nUmVhZC5nZXQoZSksWzIsbmV3IFByb21pc2UoZnVuY3Rpb24oZSl7cmV0dXJuIHQucHVzaChlKX0pXTtpZihyPXRoaXMudGV4RGF0YS5nZXQoZSksbj1yLnRleHR1cmUsbz1yLnZhbHVlcyxhPXIudGV4U2hhcGUsbnVsbCE9bylyZXR1cm5bMix0aGlzLmNvbnZlcnRBbmRDYWNoZU9uQ1BVKGUpXTtpZih0aGlzLnBlbmRpbmdSZWFkLnNldChlLFtdKSwhRU5WLmdldChcIldFQkdMX0RPV05MT0FEX0ZMT0FUX0VOQUJMRURcIikmJjI9PT1FTlYuZ2V0KFwiV0VCR0xfVkVSU0lPTlwiKSl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3IuZGF0YSgpIHdpdGggV0VCR0xfRE9XTkxPQURfRkxPQVRfRU5BQkxFRD1mYWxzZSBhbmQgV0VCR0xfVkVSU0lPTj0yIG5vdCB5ZXQgc3VwcG9ydGVkLlwiKTtyZXR1cm4gaT10aGlzLmdwZ3B1Lm1heWJlQ3JlYXRlQnVmZmVyRnJvbVRleHR1cmUobixhWzBdLGFbMV0pLFs0LHRoaXMuZ3BncHUuY3JlYXRlQW5kV2FpdEZvckZlbmNlKCldO2Nhc2UgMTpyZXR1cm4gYy5zZW50KCkscz1pIGluc3RhbmNlb2YgV2ViR0xUZXh0dXJlP3RoaXMuZ2V0VmFsdWVzRnJvbVRleHR1cmUoZSk6dGhpcy5ncGdwdS5kb3dubG9hZEZsb2F0MzJNYXRyaXhGcm9tQnVmZmVyKGksYVswXSxhWzFdKSx1PXRoaXMuY29udmVydEFuZENhY2hlT25DUFUoZSxzKSxsPXRoaXMucGVuZGluZ1JlYWQuZ2V0KGUpLHRoaXMucGVuZGluZ1JlYWQuZGVsZXRlKGUpLGwuZm9yRWFjaChmdW5jdGlvbihlKXtyZXR1cm4gZSh1KX0pLHRoaXMucGVuZGluZ0Rpc3Bvc2FsLmhhcyhlKSYmKHRoaXMucGVuZGluZ0Rpc3Bvc2FsLmRlbGV0ZShlKSx0aGlzLmRpc3Bvc2VEYXRhKGUpKSxbMix1XX19KX0pfSxlLnByb3RvdHlwZS5nZXRWYWx1ZXNGcm9tVGV4dHVyZT1mdW5jdGlvbihlKXt2YXIgdD10aGlzLnRleERhdGEuZ2V0KGUpLHI9dC5zaGFwZSxuPXQuZHR5cGUsbz10LnRleHR1cmUsYT10LnRleFNoYXBlO2lmKEVOVi5nZXQoXCJXRUJHTF9ET1dOTE9BRF9GTE9BVF9FTkFCTEVEXCIpKXtpZih0aGlzLnRleERhdGEuZ2V0KGUpLmlzUGFja2VkKXt2YXIgaT1zaXplRnJvbVNoYXBlKHIuc2xpY2UoMCxyLmxlbmd0aC0yKSkscz1yLmxlbmd0aD4xP3Jbci5sZW5ndGgtMl06MSx1PXJbci5sZW5ndGgtMV07cmV0dXJuIHRoaXMuZ3BncHUuZG93bmxvYWRNYXRyaXhGcm9tUGFja2VkVGV4dHVyZShvLGkscyx1LGFbMF0sYVsxXSl9cmV0dXJuIHRoaXMuZ3BncHUuZG93bmxvYWRGbG9hdDMyTWF0cml4RnJvbU91dHB1dFRleHR1cmUobyxhWzBdLGFbMV0pfXZhciBsPXRoaXMubWFrZVRlbnNvckhhbmRsZShyLFwiZmxvYXQzMlwiKTtsLnNpemU9c2l6ZUZyb21TaGFwZShyKSx0aGlzLnRleERhdGEuZ2V0KGwuZGF0YUlkKS51c2FnZT1UZXh0dXJlVXNhZ2UuRE9XTkxPQUQ7dmFyIGM9bmV3IEVuY29kZUZsb2F0UHJvZ3JhbShyKTt0aGlzLmNvbXBpbGVBbmRSdW4oYyxbe3NoYXBlOnIsZHR5cGU6bixkYXRhSWQ6ZX1dLGwsbnVsbCwhMSk7dmFyIHA9dGhpcy50ZXhEYXRhLmdldChsLmRhdGFJZCksZD10aGlzLmdwZ3B1LmRvd25sb2FkQnl0ZUVuY29kZWRGbG9hdE1hdHJpeEZyb21PdXRwdXRUZXh0dXJlKHAudGV4dHVyZSxwLnRleFNoYXBlWzBdLHAudGV4U2hhcGVbMV0pO3JldHVybiB0aGlzLmRpc3Bvc2VEYXRhKGwuZGF0YUlkKSxkfSxlLnByb3RvdHlwZS50aW1lPWZ1bmN0aW9uKGUpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQscixuLG8sYSxpLHM7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24odSl7c3dpdGNoKHUubGFiZWwpe2Nhc2UgMDpyZXR1cm4gdD10aGlzLmFjdGl2ZVRpbWVycyxyPVtdLG49ITEsbnVsbD09dGhpcy5wcm9ncmFtVGltZXJzU3RhY2s/KHRoaXMucHJvZ3JhbVRpbWVyc1N0YWNrPXIsbj0hMCk6dGhpcy5hY3RpdmVUaW1lcnMucHVzaChyKSx0aGlzLmFjdGl2ZVRpbWVycz1yLGUoKSxvPWZsYXR0ZW4odGhpcy5hY3RpdmVUaW1lcnMubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLnF1ZXJ5fSkpLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4gbnVsbCE9ZX0pLGE9ZmxhdHRlbih0aGlzLmFjdGl2ZVRpbWVycy5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUubmFtZX0pKS5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIG51bGwhPWV9KSx0aGlzLmFjdGl2ZVRpbWVycz10LG4mJih0aGlzLnByb2dyYW1UaW1lcnNTdGFjaz1udWxsKSxbNCxQcm9taXNlLmFsbChvKV07Y2FzZSAxOnJldHVybiBpPXUuc2VudCgpLHM9e3VwbG9hZFdhaXRNczp0aGlzLnVwbG9hZFdhaXRNcyxkb3dubG9hZFdhaXRNczp0aGlzLmRvd25sb2FkV2FpdE1zLGtlcm5lbE1zOnN1bShpKSxnZXRFeHRyYVByb2ZpbGVJbmZvOmZ1bmN0aW9uKCl7cmV0dXJuIGkubWFwKGZ1bmN0aW9uKGUsdCl7cmV0dXJue25hbWU6YVt0XSxtczplfX0pLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5uYW1lK1wiOiBcIitlLm1zfSkuam9pbihcIiwgXCIpfSx3YWxsTXM6bnVsbH0sdGhpcy51cGxvYWRXYWl0TXM9MCx0aGlzLmRvd25sb2FkV2FpdE1zPTAsWzIsc119fSl9KX0sZS5wcm90b3R5cGUubWVtb3J5PWZ1bmN0aW9uKCl7cmV0dXJue3VucmVsaWFibGU6ITEsbnVtQnl0ZXNJbkdQVTp0aGlzLm51bUJ5dGVzSW5HUFV9fSxlLnByb3RvdHlwZS5zdGFydFRpbWVyPWZ1bmN0aW9uKCl7cmV0dXJuIEVOVi5nZXQoXCJXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fVkVSU0lPTlwiKT4wP3RoaXMuZ3BncHUuYmVnaW5RdWVyeSgpOntzdGFydE1zOnBlcmZvcm1hbmNlLm5vdygpLGVuZE1zOm51bGx9fSxlLnByb3RvdHlwZS5lbmRUaW1lcj1mdW5jdGlvbihlKXtyZXR1cm4gRU5WLmdldChcIldFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9WRVJTSU9OXCIpPjA/KHRoaXMuZ3BncHUuZW5kUXVlcnkoKSxlKTooZS5lbmRNcz1wZXJmb3JtYW5jZS5ub3coKSxlKX0sZS5wcm90b3R5cGUuZ2V0UXVlcnlUaW1lPWZ1bmN0aW9uKGUpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQ7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24ocil7cmV0dXJuIEVOVi5nZXQoXCJXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fVkVSU0lPTlwiKT4wP1syLHRoaXMuZ3BncHUud2FpdEZvclF1ZXJ5QW5kR2V0VGltZShlKV06WzIsKHQ9ZSkuZW5kTXMtdC5zdGFydE1zXX0pfSl9LGUucHJvdG90eXBlLmRpc3Bvc2VEYXRhPWZ1bmN0aW9uKGUpe2lmKCF0aGlzLnBlbmRpbmdEaXNwb3NhbC5oYXMoZSkpaWYodGhpcy5wZW5kaW5nUmVhZC5oYXMoZSkpdGhpcy5wZW5kaW5nRGlzcG9zYWwuYWRkKGUpO2Vsc2UgaWYodGhpcy50ZXhEYXRhLmhhcyhlKSl7dmFyIHQ9dGhpcy50ZXhEYXRhLmdldChlKSxyPXQudGV4dHVyZSxuPXQudGV4U2hhcGUsbz10LnVzYWdlLGE9dC5jb21wbGV4VGVuc29ycyxpPXQuaXNQYWNrZWQ7bnVsbCE9ciYmdGhpcy5yZWxlYXNlVGV4dHVyZShlLHIsbixvLGkpLG51bGwhPWEmJihhLnJlYWwuZGlzcG9zZSgpLGEuaW1hZy5kaXNwb3NlKCkpLHRoaXMudGV4RGF0YS5kZWxldGUoZSl9fSxlLnByb3RvdHlwZS5nZXRUZXh0dXJlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnVwbG9hZFRvR1BVKGUpLHRoaXMudGV4RGF0YS5nZXQoZSkudGV4dHVyZX0sZS5wcm90b3R5cGUuZ2V0Q1BVQmFja2VuZD1mdW5jdGlvbigpe3JldHVybiBFTlYuZ2V0KFwiV0VCR0xfQ1BVX0ZPUldBUkRcIik/KG51bGw9PXRoaXMuY3B1QmFja2VuZCYmKHRoaXMuY3B1QmFja2VuZD1FTlYuZmluZEJhY2tlbmQoXCJjcHVcIikpLHRoaXMuY3B1QmFja2VuZCk6bnVsbH0sZS5wcm90b3R5cGUuc2hvdWxkRXhlY3V0ZU9uQ1BVPWZ1bmN0aW9uKGUsdCl7dmFyIHI9dGhpcztyZXR1cm4gdm9pZCAwPT09dCYmKHQ9Q1BVX0hBTkRPRkZfU0laRV9USFJFU0hPTEQpLG51bGwhPXRoaXMuZ2V0Q1BVQmFja2VuZCgpJiZlLmV2ZXJ5KGZ1bmN0aW9uKGUpe3JldHVybiBudWxsPT1yLnRleERhdGEuZ2V0KGUuZGF0YUlkKS50ZXh0dXJlJiZlLnNpemU8dH0pfSxlLnByb3RvdHlwZS5nZXRHUEdQVUNvbnRleHQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ncGdwdX0sZS5wcm90b3R5cGUuZ2V0Q2FudmFzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2FudmFzfSxlLnByb3RvdHlwZS5jb21wbGV4PWZ1bmN0aW9uKGUsdCl7dmFyIHI9dGhpcy5tYWtlT3V0cHV0QXJyYXkoZS5zaGFwZSxcImNvbXBsZXg2NFwiKTtyZXR1cm4gdGhpcy50ZXhEYXRhLmdldChyLmRhdGFJZCkuY29tcGxleFRlbnNvcnM9e3JlYWw6RU5WLmVuZ2luZS5rZWVwKGUuY2xvbmUoKSksaW1hZzpFTlYuZW5naW5lLmtlZXAodC5jbG9uZSgpKX0scn0sZS5wcm90b3R5cGUucmVhbD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50ZXhEYXRhLmdldChlLmRhdGFJZCkuY29tcGxleFRlbnNvcnMucmVhbC5jbG9uZSgpfSxlLnByb3RvdHlwZS5pbWFnPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnRleERhdGEuZ2V0KGUuZGF0YUlkKS5jb21wbGV4VGVuc29ycy5pbWFnLmNsb25lKCl9LGUucHJvdG90eXBlLnNsaWNlPWZ1bmN0aW9uKGUsdCxyKXtpZih0aGlzLnNob3VsZEV4ZWN1dGVPbkNQVShbZV0pKXJldHVybiB0aGlzLmNwdUJhY2tlbmQuc2xpY2UoZSx0LHIpO3ZhciBuPW5ldyBTbGljZVByb2dyYW0ociksbz1uLmdldEN1c3RvbVNldHVwRnVuYyh0KTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4sW2VdLG51bGwsbyl9LGUucHJvdG90eXBlLnN0cmlkZWRTbGljZT1mdW5jdGlvbihlLHQscixuLG8sYSxpLHMsdSl7aWYodGhpcy5zaG91bGRFeGVjdXRlT25DUFUoW2VdKSlyZXR1cm4gdGhpcy5jcHVCYWNrZW5kLnN0cmlkZWRTbGljZShlLHQscixuLG8sYSxpLHMsdSk7dmFyIGw9Z2V0U3RyaWRlZFNsaWNlZEluZm8oZS5zaGFwZSx0LHIsbixvLGEsaSxzLHUpLGM9bFswXSxwPWxbMV0sZD1sWzJdLGg9cC5maWx0ZXIoZnVuY3Rpb24oZSx0KXtyZXR1cm4tMT09PWQuaW5kZXhPZih0KX0pO2lmKGguc29tZShmdW5jdGlvbihlKXtyZXR1cm4gMD09PWV9KSlyZXR1cm4gdGVuc29yKFtdLGgpO3ZhciBmPW5ldyBTdHJpZGVkU2xpY2VQcm9ncmFtKGMsbixwLGQpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZixbZV0pfSxlLnByb3RvdHlwZS5yZXZlcnNlPWZ1bmN0aW9uKGUsdCl7dmFyIHI9bmV3IFJldmVyc2VQcm9ncmFtKGUuc2hhcGUsdCk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihyLFtlXSl9LGUucHJvdG90eXBlLmNvbmNhdDJUZW5zb3JzPWZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1jb21wdXRlT3V0U2hhcGUoW2Uuc2hhcGUsdC5zaGFwZV0sciksbz1lLmFzMkQoLTEsc2l6ZUZyb21TaGFwZShlLnNoYXBlLnNsaWNlKHIpKSksYT10LmFzMkQoLTEsc2l6ZUZyb21TaGFwZSh0LnNoYXBlLnNsaWNlKHIpKSksaT1uZXcgQ29uY2F0UHJvZ3JhbShvLnNoYXBlLGEuc2hhcGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oaSxbbyxhXSkucmVzaGFwZShuKX0sZS5wcm90b3R5cGUuY29uY2F0PWZ1bmN0aW9uKGUsdCl7aWYodGhpcy5zaG91bGRFeGVjdXRlT25DUFUoZSkpcmV0dXJuIHRoaXMuY3B1QmFja2VuZC5jb25jYXQoZSx0KTtpZigxPT09ZS5sZW5ndGgpcmV0dXJuIGVbMF07Zm9yKHZhciByPWVbMF0sbj0xO248ZS5sZW5ndGg7KytuKXI9dGhpcy5jb25jYXQyVGVuc29ycyhyLGVbbl0sdCk7cmV0dXJuIHJ9LGUucHJvdG90eXBlLm5lZz1mdW5jdGlvbihlKXt2YXIgdD1uZXcgVW5hcnlPcFByb2dyYW0oZS5zaGFwZSxORUcpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4odCxbZV0pfSxlLnByb3RvdHlwZS5iYXRjaE1hdE11bD1mdW5jdGlvbihlLHQscixuKXt2YXIgbz1yP2Uuc2hhcGVbMl06ZS5zaGFwZVsxXSxhPW4/dC5zaGFwZVsxXTp0LnNoYXBlWzJdLGk9cj9lLnNoYXBlWzFdOmUuc2hhcGVbMl0scz1lLnNoYXBlWzBdO2lmKCgxPT09b3x8MT09PWEpJiZpPk1BVE1VTF9TSEFSRURfRElNX1RIUkVTSE9MRCl7ciYmKGU9ZS50cmFuc3Bvc2UoWzAsMiwxXSkpLG4mJih0PXQudHJhbnNwb3NlKFswLDIsMV0pKTt2YXIgdT0xPT09YT9lOmUuYXMzRChzLGksMSksbD0xPT09YT8yOjEsYz0xPT09YT90LmFzM0QocywxLGkpOnQ7cmV0dXJuIHRoaXMubXVsdGlwbHkodSxjKS5zdW0obCwhMCl9aWYoMT09PXMpe3ZhciBwPWUuYXMyRChlLnNoYXBlWzFdLGUuc2hhcGVbMl0pLGQ9dC5hczJEKHQuc2hhcGVbMV0sdC5zaGFwZVsyXSksaD1uZXcgTWF0TXVsUGFja2VkUHJvZ3JhbShwLnNoYXBlLGQuc2hhcGUsW28sYV0scixuKSxmPXRoaXMuY29tcGlsZUFuZFJ1bihoLFtwLGRdLHRoaXMubWFrZVBhY2tlZFRlbnNvcihoLm91dHB1dFNoYXBlKSk7cmV0dXJuITE9PT1FTlYuZ2V0KFwiV0VCR0xfTEFaSUxZX1VOUEFDS1wiKSYmKGY9dGhpcy51bnBhY2tUZW5zb3IoZikpLGYucmVzaGFwZShbMSxmLnNoYXBlWzBdLGYuc2hhcGVbMV1dKX1yZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG5ldyBNYXRNdWxQcm9ncmFtKGUuc2hhcGUsdC5zaGFwZSxyLG4pLFtlLHRdKX0sZS5wcm90b3R5cGUubXVsdGlwbHk9ZnVuY3Rpb24oZSx0KXtpZihcImNvbXBsZXg2NFwiPT09ZS5kdHlwZSl7dmFyIHI9dGhpcy50ZXhEYXRhLmdldChlLmRhdGFJZCksbj10aGlzLnRleERhdGEuZ2V0KHQuZGF0YUlkKSxvPW5ldyBCaW5hcnlPcENvbXBsZXhQcm9ncmFtKENPTVBMRVhfTVVMVElQTFkuUkVBTCxlLnNoYXBlLHQuc2hhcGUpLGE9bmV3IEJpbmFyeU9wQ29tcGxleFByb2dyYW0oQ09NUExFWF9NVUxUSVBMWS5JTUFHLGUuc2hhcGUsdC5zaGFwZSksaT1bdGhpcy5tYWtlQ29tcGxleENvbXBvbmVudFRlbnNvckhhbmRsZShlLHIuY29tcGxleFRlbnNvcnMucmVhbCksdGhpcy5tYWtlQ29tcGxleENvbXBvbmVudFRlbnNvckhhbmRsZShlLHIuY29tcGxleFRlbnNvcnMuaW1hZyksdGhpcy5tYWtlQ29tcGxleENvbXBvbmVudFRlbnNvckhhbmRsZSh0LG4uY29tcGxleFRlbnNvcnMucmVhbCksdGhpcy5tYWtlQ29tcGxleENvbXBvbmVudFRlbnNvckhhbmRsZSh0LG4uY29tcGxleFRlbnNvcnMuaW1hZyldLHM9dGhpcy5jb21waWxlQW5kUnVuKG8saSksdT10aGlzLmNvbXBpbGVBbmRSdW4oYSxpKSxsPXRoaXMuY29tcGxleChzLHUpO3JldHVybiBzLmRpc3Bvc2UoKSx1LmRpc3Bvc2UoKSxsfWlmKHRoaXMuc2hvdWxkRXhlY3V0ZU9uQ1BVKFtlLHRdKSlyZXR1cm4gdGhpcy5jcHVCYWNrZW5kLm11bHRpcGx5KGUsdCk7dmFyIGM9bmV3IEJpbmFyeU9wUHJvZ3JhbShNVUwsZS5zaGFwZSx0LnNoYXBlKSxwPXRoaXMubWFrZU91dHB1dEFycmF5KGMub3V0cHV0U2hhcGUsZS5kdHlwZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihjLFtlLHRdLHApfSxlLnByb3RvdHlwZS5iYXRjaE5vcm1hbGl6YXRpb249ZnVuY3Rpb24oZSx0LHIsbixvLGEpe3ZhciBpPVtlLHQscl0scz1udWxsO251bGwhPWEmJihzPWEuc2hhcGUsaS5wdXNoKGEpKTt2YXIgdT1udWxsO251bGwhPW8mJih1PW8uc2hhcGUsaS5wdXNoKG8pKTt2YXIgbD1udWxsLGM9QmF0Y2hOb3JtUHJvZ3JhbTtFTlYuZ2V0KFwiV0VCR0xfUEFDS19CQVRDSE5PUk1BTElaQVRJT05cIikmJihsPXRoaXMubWFrZVBhY2tlZFRlbnNvcihlLnNoYXBlKSxjPUJhdGNoTm9ybVBhY2tlZFByb2dyYW0pO3ZhciBwPW5ldyBjKGUuc2hhcGUsdC5zaGFwZSxyLnNoYXBlLHMsdSxuKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHAsaSxsKX0sZS5wcm90b3R5cGUubG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb240RD1mdW5jdGlvbihlLHQscixuLG8pe3ZhciBhPW5ldyBMUk5Qcm9ncmFtKGUuc2hhcGUsdCxyLG4sbyk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihhLFtlXSl9LGUucHJvdG90eXBlLkxSTkdyYWQ9ZnVuY3Rpb24oZSx0LHIsbixvLGEsaSl7dmFyIHM9bmV3IExSTkdyYWRQcm9ncmFtKHQuc2hhcGUsbixvLGEsaSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihzLFt0LHIsZV0pfSxlLnByb3RvdHlwZS50aWxlPWZ1bmN0aW9uKGUsdCl7dmFyIHI9bmV3IFRpbGVQcm9ncmFtKGUuc2hhcGUsdCk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihyLFtlXSl9LGUucHJvdG90eXBlLnBhZD1mdW5jdGlvbihlLHQscil7dmFyIG49bmV3IFBhZFByb2dyYW0oZS5zaGFwZSx0LHIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbZV0pfSxlLnByb3RvdHlwZS50cmFuc3Bvc2U9ZnVuY3Rpb24oZSx0KXt2YXIgcj1uZXcgVHJhbnNwb3NlUHJvZ3JhbShlLnNoYXBlLHQpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocixbZV0pfSxlLnByb3RvdHlwZS5nYXRoZXI9ZnVuY3Rpb24oZSx0LHIpe3ZhciBuPW5ldyBHYXRoZXJQcm9ncmFtKGUuc2hhcGUsdC5zaXplLHIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbZSx0XSl9LGUucHJvdG90eXBlLmJhdGNoVG9TcGFjZU5EPWZ1bmN0aW9uKGUsdCxyKXthc3NlcnQoZS5yYW5rPD00LFwiYmF0Y2hUb1NwYWNlTkQgZm9yIHJhbmsgPiA0IHdpdGggYSBXZWJHTCBiYWNrZW5kIG5vdCBpbXBsZW1lbnRlZCB5ZXRcIik7dmFyIG49dC5yZWR1Y2UoZnVuY3Rpb24oZSx0KXtyZXR1cm4gZSp0fSksbz1nZXRSZXNoYXBlZChlLnNoYXBlLHQsbiksYT1nZXRQZXJtdXRlZChvLmxlbmd0aCx0Lmxlbmd0aCksaT1nZXRSZXNoYXBlZFBlcm11dGVkKGUuc2hhcGUsdCxuKSxzPWdldFNsaWNlQmVnaW5Db29yZHMocix0Lmxlbmd0aCksdT1nZXRTbGljZVNpemUoaSxyLHQubGVuZ3RoKTtyZXR1cm4gZS5yZXNoYXBlKG8pLnRyYW5zcG9zZShhKS5yZXNoYXBlKGkpLnNsaWNlKHMsdSl9LGUucHJvdG90eXBlLnNwYWNlVG9CYXRjaE5EPWZ1bmN0aW9uKGUsdCxyKXthc3NlcnQoZS5yYW5rPD00LFwic3BhY2VUb0JhdGNoTkQgZm9yIHJhbmsgPiA0IHdpdGggYSBXZWJHTCBiYWNrZW5kIG5vdCBpbXBsZW1lbnRlZCB5ZXRcIik7dmFyIG49dC5yZWR1Y2UoZnVuY3Rpb24oZSx0KXtyZXR1cm4gZSp0fSksbz1bWzAsMF1dO28ucHVzaC5hcHBseShvLHIpO2Zvcih2YXIgYT0xK3QubGVuZ3RoO2E8ZS5zaGFwZS5sZW5ndGg7KythKW8ucHVzaChbMCwwXSk7dmFyIGk9ZS5wYWQobykscz1nZXRSZXNoYXBlZChpLnNoYXBlLHQsbiwhMSksdT1nZXRQZXJtdXRlZChzLmxlbmd0aCx0Lmxlbmd0aCwhMSksbD1nZXRSZXNoYXBlZFBlcm11dGVkKGkuc2hhcGUsdCxuLCExKTtyZXR1cm4gaS5yZXNoYXBlKHMpLnRyYW5zcG9zZSh1KS5yZXNoYXBlKGwpfSxlLnByb3RvdHlwZS5yZWR1Y2U9ZnVuY3Rpb24oZSx0LHIpe3ZhciBuPWUuc2hhcGVbMF0sbz1lLnNoYXBlWzFdLGE9Y29tcHV0ZU9wdGltYWxXaW5kb3dTaXplKG8pLGk9bmV3IFJlZHVjZVByb2dyYW0oe3dpbmRvd1NpemU6YSxpblNpemU6byxiYXRjaFNpemU6bn0sdCkscz1pLm91dHB1dFNoYXBlLHU9c1swXSxsPXNbMV0sYz10aGlzLm1ha2VPdXRwdXRBcnJheShbdSxsXSxyKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGksW2VdLGMpLDE9PT1jLnNoYXBlWzFdP2M6dGhpcy5yZWR1Y2UoYyx0LHIpfSxlLnByb3RvdHlwZS5hcmdSZWR1Y2U9ZnVuY3Rpb24oZSx0LHIpe3ZvaWQgMD09PXImJihyPW51bGwpO3ZhciBuPWUuc2hhcGVbMF0sbz1lLnNoYXBlWzFdO251bGwhPXImJihuPXIuc2hhcGVbMF0sbz1yLnNoYXBlWzFdKTt2YXIgYT1jb21wdXRlT3B0aW1hbFdpbmRvd1NpemUobyksaT1uZXcgQXJnTWluTWF4UHJvZ3JhbSh7d2luZG93U2l6ZTphLGluU2l6ZTpvLGJhdGNoU2l6ZTpufSx0LG51bGw9PXIpLHM9aS5vdXRwdXRTaGFwZSx1PXNbMF0sbD1zWzFdLGM9dGhpcy5tYWtlT3V0cHV0QXJyYXkoW3UsbF0sXCJpbnQzMlwiKSxwPVtlXTtyZXR1cm4gbnVsbCE9ciYmcC5wdXNoKHIpLHRoaXMuY29tcGlsZUFuZFJ1bihpLHAsYyksMT09PWMuc2hhcGVbMV0/Yzp0aGlzLmFyZ1JlZHVjZShlLHQsYyl9LGUucHJvdG90eXBlLnN1bT1mdW5jdGlvbihlLHQpe2Fzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKFwic3VtXCIsdCxlLnJhbmspO3ZhciByPWNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMoZS5zaGFwZSx0KSxuPXJbMF0sbz1zaXplRnJvbVNoYXBlKHJbMV0pLGE9ZS5hczJEKC0xLG8pLGk9c3VtT3V0VHlwZShlLmR0eXBlKTtyZXR1cm4gdGhpcy5yZWR1Y2UoYSxcInN1bVwiLGkpLnJlc2hhcGUobil9LGUucHJvdG90eXBlLnByb2Q9ZnVuY3Rpb24oZSx0KXt2YXIgcj1jb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKGUuc2hhcGUsdCksbj1yWzBdLG89c2l6ZUZyb21TaGFwZShyWzFdKSxhPWUuYXMyRCgtMSxvKSxpPXN1bU91dFR5cGUoZS5kdHlwZSk7cmV0dXJuIHRoaXMucmVkdWNlKGEsXCJwcm9kXCIsaSkucmVzaGFwZShuKX0sZS5wcm90b3R5cGUudW5zb3J0ZWRTZWdtZW50U3VtPWZ1bmN0aW9uKGUsdCxyKXt2YXIgbj0wLG89Z2V0QXhlc1Blcm11dGF0aW9uKFtuXSxlLnJhbmspLGE9ZTtudWxsIT1vJiYoYT1lLnRyYW5zcG9zZShvKSxuPWdldElubmVyTW9zdEF4ZXMoMSxlLnJhbmspWzBdKTt2YXIgaT1jb21wdXRlT3V0U2hhcGUkMShhLnNoYXBlLG4scikscz1zaXplRnJvbVNoYXBlKFthLnNoYXBlW25dXSksdT1hLmFzMkQoLTEscyksbD1zdW1PdXRUeXBlKGUuZHR5cGUpLGM9dGhpcy5zZWdPcENvbXB1dGUodSxcInVuc29ydGVkU2VnbWVudFN1bVwiLHQsbCxyKS5yZXNoYXBlKGkpO3JldHVybiBudWxsIT1vJiYoYz1jLnRyYW5zcG9zZShnZXRVbmRvQXhlc1Blcm11dGF0aW9uKG8pKSksY30sZS5wcm90b3R5cGUuc2VnT3BDb21wdXRlPWZ1bmN0aW9uKGUsdCxyLG4sbyl7dmFyIGE9ZS5zaGFwZVswXSxpPWUuc2hhcGVbMV0scz1zZWdPcENvbXB1dGVPcHRpbWFsV2luZG93U2l6ZShpLG8pLHU9bmV3IFNlZ21lbnRPcFByb2dyYW0oe3dpbmRvd1NpemU6cyxpblNpemU6aSxiYXRjaFNpemU6YSxudW1TZWdtZW50czpvfSx0KSxsPXUub3V0cHV0U2hhcGUsYz1sWzBdLHA9bFsxXSxkPXRoaXMubWFrZU91dHB1dEFycmF5KFtjLHBdLG4pO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4odSxbZSxyXSxkKSxkLnNoYXBlWzFdPT09bz9kOihyPXJhbmdlKDAsbykudGlsZShbaS9zXSksdGhpcy5zZWdPcENvbXB1dGUoZCx0LHIsbixvKSl9LGUucHJvdG90eXBlLmFyZ01pbj1mdW5jdGlvbihlLHQpe3ZhciByPVt0XTthc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcyhcImFyZ01pblwiLHIsZS5yYW5rKTt2YXIgbj1jb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKGUuc2hhcGUsciksbz1uWzBdLGE9c2l6ZUZyb21TaGFwZShuWzFdKSxpPWUuYXMyRCgtMSxhKTtyZXR1cm4gdGhpcy5hcmdSZWR1Y2UoaSxcIm1pblwiKS5yZXNoYXBlKG8pfSxlLnByb3RvdHlwZS5hcmdNYXg9ZnVuY3Rpb24oZSx0KXt2YXIgcj1bdF07YXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXMoXCJhcmdNYXhcIixyLGUucmFuayk7dmFyIG49Y29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyhlLnNoYXBlLHIpLG89blswXSxhPXNpemVGcm9tU2hhcGUoblsxXSksaT1lLmFzMkQoLTEsYSk7cmV0dXJuIHRoaXMuYXJnUmVkdWNlKGksXCJtYXhcIikucmVzaGFwZShvKX0sZS5wcm90b3R5cGUuY3Vtc3VtPWZ1bmN0aW9uKGUsdCxyLG4pe2lmKHQhPT1lLnJhbmstMSl0aHJvdyBuZXcgRXJyb3IoXCJXZWJHTCBjdW1zdW0gc2hhZGVyIGV4cGVjdHMgYW4gaW5uZXItbW9zdCBheGlzPVwiKyhlLnJhbmstMSkrXCIgYnV0IGdvdCBheGlzPVwiK3QpO3ZhciBvPW5ldyBDdW1TdW1Qcm9ncmFtKGUuc2hhcGUscixuKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG8sW2VdKX0sZS5wcm90b3R5cGUuZXF1YWw9ZnVuY3Rpb24oZSx0KXt2YXIgcj1uZXcgQmluYXJ5T3BQcm9ncmFtKEVRVUFMLGUuc2hhcGUsdC5zaGFwZSksbj10aGlzLm1ha2VPdXRwdXRBcnJheShyLm91dHB1dFNoYXBlLFwiYm9vbFwiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHIsW2UsdF0sbil9LGUucHJvdG90eXBlLm5vdEVxdWFsPWZ1bmN0aW9uKGUsdCl7dmFyIHI9bmV3IEJpbmFyeU9wUHJvZ3JhbShOT1RfRVFVQUwsZS5zaGFwZSx0LnNoYXBlKSxuPXRoaXMubWFrZU91dHB1dEFycmF5KHIub3V0cHV0U2hhcGUsXCJib29sXCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocixbZSx0XSxuKX0sZS5wcm90b3R5cGUubGVzcz1mdW5jdGlvbihlLHQpe2lmKHRoaXMuc2hvdWxkRXhlY3V0ZU9uQ1BVKFtlLHRdKSlyZXR1cm4gdGhpcy5jcHVCYWNrZW5kLmxlc3MoZSx0KTt2YXIgcj1uZXcgQmluYXJ5T3BQcm9ncmFtKExFU1MsZS5zaGFwZSx0LnNoYXBlKSxuPXRoaXMubWFrZU91dHB1dEFycmF5KHIub3V0cHV0U2hhcGUsXCJib29sXCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocixbZSx0XSxuKX0sZS5wcm90b3R5cGUubGVzc0VxdWFsPWZ1bmN0aW9uKGUsdCl7dmFyIHI9bmV3IEJpbmFyeU9wUHJvZ3JhbShMRVNTX0VRVUFMLGUuc2hhcGUsdC5zaGFwZSksbj10aGlzLm1ha2VPdXRwdXRBcnJheShyLm91dHB1dFNoYXBlLFwiYm9vbFwiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHIsW2UsdF0sbil9LGUucHJvdG90eXBlLmdyZWF0ZXI9ZnVuY3Rpb24oZSx0KXtpZih0aGlzLnNob3VsZEV4ZWN1dGVPbkNQVShbZSx0XSkpcmV0dXJuIHRoaXMuY3B1QmFja2VuZC5ncmVhdGVyKGUsdCk7dmFyIHI9bmV3IEJpbmFyeU9wUHJvZ3JhbShHUkVBVEVSLGUuc2hhcGUsdC5zaGFwZSksbj10aGlzLm1ha2VPdXRwdXRBcnJheShyLm91dHB1dFNoYXBlLFwiYm9vbFwiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHIsW2UsdF0sbil9LGUucHJvdG90eXBlLmdyZWF0ZXJFcXVhbD1mdW5jdGlvbihlLHQpe3ZhciByPW5ldyBCaW5hcnlPcFByb2dyYW0oR1JFQVRFUl9FUVVBTCxlLnNoYXBlLHQuc2hhcGUpLG49dGhpcy5tYWtlT3V0cHV0QXJyYXkoci5vdXRwdXRTaGFwZSxcImJvb2xcIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihyLFtlLHRdLG4pfSxlLnByb3RvdHlwZS5sb2dpY2FsTm90PWZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBVbmFyeU9wUHJvZ3JhbShlLnNoYXBlLExPR0lDQUxfTk9UKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHQsW2VdKX0sZS5wcm90b3R5cGUubG9naWNhbEFuZD1mdW5jdGlvbihlLHQpe3ZhciByPW5ldyBCaW5hcnlPcFByb2dyYW0oTE9HSUNBTF9BTkQsZS5zaGFwZSx0LnNoYXBlKSxuPXRoaXMubWFrZU91dHB1dEFycmF5KHIub3V0cHV0U2hhcGUsXCJib29sXCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocixbZSx0XSxuKX0sZS5wcm90b3R5cGUubG9naWNhbE9yPWZ1bmN0aW9uKGUsdCl7dmFyIHI9bmV3IEJpbmFyeU9wUHJvZ3JhbShMT0dJQ0FMX09SLGUuc2hhcGUsdC5zaGFwZSksbj10aGlzLm1ha2VPdXRwdXRBcnJheShyLm91dHB1dFNoYXBlLFwiYm9vbFwiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHIsW2UsdF0sbil9LGUucHJvdG90eXBlLnNlbGVjdD1mdW5jdGlvbihlLHQscil7dmFyIG49bmV3IFNlbGVjdFByb2dyYW0oZS5yYW5rLHQuc2hhcGUsdC5yYW5rKSxvPXRoaXMubWFrZU91dHB1dEFycmF5KG4ub3V0cHV0U2hhcGUsdXBjYXN0VHlwZSh0LmR0eXBlLHIuZHR5cGUpKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4sW2UsdCxyXSxvKX0sZS5wcm90b3R5cGUud2hlcmU9ZnVuY3Rpb24oZSl7d2FybihcInRmLndoZXJlKCkgaW4gd2ViZ2wgbG9ja3MgdGhlIFVJIHRocmVhZC4gQ2FsbCB0Zi53aGVyZUFzeW5jKCkgaW5zdGVhZFwiKTt2YXIgdD1lLmRhdGFTeW5jKCk7cmV0dXJuIHdoZXJlSW1wbChlLnNoYXBlLHQpfSxlLnByb3RvdHlwZS50b3BrPWZ1bmN0aW9uKGUsdCxyKXtyZXR1cm4gdG9wa0ltcGwoZS5kYXRhU3luYygpLGUuc2hhcGUsZS5kdHlwZSx0LHIpfSxlLnByb3RvdHlwZS5taW49ZnVuY3Rpb24oZSx0KXthc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcyhcIm1pblwiLHQsZS5yYW5rKTt2YXIgcj1jb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKGUuc2hhcGUsdCksbj1yWzBdLG89c2l6ZUZyb21TaGFwZShyWzFdKSxhPWUuYXMyRCgtMSxvKTtyZXR1cm4gdGhpcy5yZWR1Y2UoYSxcIm1pblwiLGEuZHR5cGUpLnJlc2hhcGUobil9LGUucHJvdG90eXBlLm1pbmltdW09ZnVuY3Rpb24oZSx0KXtpZih0aGlzLnNob3VsZEV4ZWN1dGVPbkNQVShbZSx0XSkpcmV0dXJuIHRoaXMuY3B1QmFja2VuZC5taW5pbXVtKGUsdCk7dmFyIHI9bmV3IEJpbmFyeU9wUHJvZ3JhbShNSU4sZS5zaGFwZSx0LnNoYXBlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHIsW2UsdF0pfSxlLnByb3RvdHlwZS5tb2Q9ZnVuY3Rpb24oZSx0KXt2YXIgcj1uZXcgQmluYXJ5T3BQcm9ncmFtKE1PRCxlLnNoYXBlLHQuc2hhcGUpLG49ci5nZXRDdXN0b21TZXR1cEZ1bmMoKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHIsW2UsdF0sbnVsbCxuKX0sZS5wcm90b3R5cGUubWF4PWZ1bmN0aW9uKGUsdCl7YXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXMoXCJtYXhcIix0LGUucmFuayk7dmFyIHI9Y29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyhlLnNoYXBlLHQpLG49clswXSxvPXNpemVGcm9tU2hhcGUoclsxXSksYT1lLmFzMkQoLTEsbyk7cmV0dXJuIHRoaXMucmVkdWNlKGEsXCJtYXhcIixhLmR0eXBlKS5yZXNoYXBlKG4pfSxlLnByb3RvdHlwZS5tYXhpbXVtPWZ1bmN0aW9uKGUsdCl7aWYodGhpcy5zaG91bGRFeGVjdXRlT25DUFUoW2UsdF0pKXJldHVybiB0aGlzLmNwdUJhY2tlbmQubWF4aW11bShlLHQpO3ZhciByPW5ldyBCaW5hcnlPcFByb2dyYW0oTUFYLGUuc2hhcGUsdC5zaGFwZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihyLFtlLHRdKX0sZS5wcm90b3R5cGUuYWxsPWZ1bmN0aW9uKGUsdCl7YXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXMoXCJhbGxcIix0LGUucmFuayk7dmFyIHI9Y29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyhlLnNoYXBlLHQpLG49clswXSxvPXNpemVGcm9tU2hhcGUoclsxXSksYT1lLmFzMkQoLTEsbyk7cmV0dXJuIHRoaXMucmVkdWNlKGEsXCJhbGxcIixhLmR0eXBlKS5yZXNoYXBlKG4pfSxlLnByb3RvdHlwZS5hbnk9ZnVuY3Rpb24oZSx0KXthc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcyhcImFueVwiLHQsZS5yYW5rKTt2YXIgcj1jb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKGUuc2hhcGUsdCksbj1yWzBdLG89c2l6ZUZyb21TaGFwZShyWzFdKSxhPWUuYXMyRCgtMSxvKTtyZXR1cm4gdGhpcy5yZWR1Y2UoYSxcImFueVwiLGEuZHR5cGUpLnJlc2hhcGUobil9LGUucHJvdG90eXBlLnNxdWFyZWREaWZmZXJlbmNlPWZ1bmN0aW9uKGUsdCl7dmFyIHI9bmV3IEJpbmFyeU9wUHJvZ3JhbShTUVVBUkVEX0RJRkZFUkVOQ0UsZS5zaGFwZSx0LnNoYXBlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHIsW2UsdF0pfSxlLnByb3RvdHlwZS5yZWFsRGl2aWRlPWZ1bmN0aW9uKGUsdCl7dmFyIHI9bmV3IEJpbmFyeU9wUHJvZ3JhbShESVYsZS5zaGFwZSx0LnNoYXBlKSxuPXRoaXMubWFrZU91dHB1dEFycmF5KHIub3V0cHV0U2hhcGUsXCJmbG9hdDMyXCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocixbZSx0XSxuKX0sZS5wcm90b3R5cGUuZmxvb3JEaXY9ZnVuY3Rpb24oZSx0KXt2YXIgcj1uZXcgQmluYXJ5T3BQcm9ncmFtKElOVF9ESVYsZS5zaGFwZSx0LnNoYXBlKSxuPXRoaXMubWFrZU91dHB1dEFycmF5KHIub3V0cHV0U2hhcGUsXCJpbnQzMlwiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHIsW2UsdF0sbil9LGUucHJvdG90eXBlLmFkZD1mdW5jdGlvbihlLHQpe2lmKFwiY29tcGxleDY0XCI9PT1lLmR0eXBlJiZcImNvbXBsZXg2NFwiPT09dC5kdHlwZSlyZXR1cm4gdGhpcy5jb21wbGV4U2VwYXJhYmxlQmluYXJ5T3AoZSx0LEFERCk7dmFyIHI9bmV3IEJpbmFyeU9wUHJvZ3JhbShBREQsZS5zaGFwZSx0LnNoYXBlKSxuPXRoaXMubWFrZU91dHB1dEFycmF5KHIub3V0cHV0U2hhcGUsdXBjYXN0VHlwZShlLmR0eXBlLHQuZHR5cGUpKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHIsW2UsdF0sbil9LGUucHJvdG90eXBlLmNvbXBsZXhTZXBhcmFibGVCaW5hcnlPcD1mdW5jdGlvbihlLHQscil7dmFyIG49dGhpcyxvPXRoaXMudGV4RGF0YS5nZXQoZS5kYXRhSWQpLGE9dGhpcy50ZXhEYXRhLmdldCh0LmRhdGFJZCksaT1bW28uY29tcGxleFRlbnNvcnMucmVhbCxhLmNvbXBsZXhUZW5zb3JzLnJlYWxdLFtvLmNvbXBsZXhUZW5zb3JzLmltYWcsYS5jb21wbGV4VGVuc29ycy5pbWFnXV0ubWFwKGZ1bmN0aW9uKG8pe3ZhciBhPW9bMF0saT1vWzFdLHM9bmV3IEJpbmFyeU9wUHJvZ3JhbShyLGUuc2hhcGUsdC5zaGFwZSksdT1uLm1ha2VPdXRwdXRBcnJheShzLm91dHB1dFNoYXBlLHVwY2FzdFR5cGUoYS5kdHlwZSxpLmR0eXBlKSksbD1uLm1ha2VDb21wbGV4Q29tcG9uZW50VGVuc29ySGFuZGxlKGUsYSksYz1uLm1ha2VDb21wbGV4Q29tcG9uZW50VGVuc29ySGFuZGxlKHQsaSk7cmV0dXJuIG4uY29tcGlsZUFuZFJ1bihzLFtsLGNdLHUpfSkscz1pWzBdLHU9aVsxXSxsPXRoaXMuY29tcGxleChzLHUpO3JldHVybiBzLmRpc3Bvc2UoKSx1LmRpc3Bvc2UoKSxsfSxlLnByb3RvdHlwZS5tYWtlQ29tcGxleENvbXBvbmVudFRlbnNvckhhbmRsZT1mdW5jdGlvbihlLHQpe3JldHVybntkYXRhSWQ6dC5kYXRhSWQsZHR5cGU6dC5kdHlwZSxzaGFwZTplLnNoYXBlfX0sZS5wcm90b3R5cGUuYWRkTj1mdW5jdGlvbihlKXtmb3IodmFyIHQ9ZVswXSxyPTE7cjxlLmxlbmd0aDtyKyspdD10aGlzLmFkZCh0LGVbcl0pO3JldHVybiB0fSxlLnByb3RvdHlwZS5zdWJ0cmFjdD1mdW5jdGlvbihlLHQpe2lmKFwiY29tcGxleDY0XCI9PT1lLmR0eXBlJiZcImNvbXBsZXg2NFwiPT09dC5kdHlwZSlyZXR1cm4gdGhpcy5jb21wbGV4U2VwYXJhYmxlQmluYXJ5T3AoZSx0LFNVQik7aWYodGhpcy5zaG91bGRFeGVjdXRlT25DUFUoW2UsdF0pKXJldHVybiB0aGlzLmNwdUJhY2tlbmQuc3VidHJhY3QoZSx0KTt2YXIgcj1uZXcgQmluYXJ5T3BQcm9ncmFtKFNVQixlLnNoYXBlLHQuc2hhcGUpLG49dGhpcy5tYWtlT3V0cHV0QXJyYXkoci5vdXRwdXRTaGFwZSx1cGNhc3RUeXBlKGUuZHR5cGUsdC5kdHlwZSkpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocixbZSx0XSxuKX0sZS5wcm90b3R5cGUucG93PWZ1bmN0aW9uKGUsdCl7dmFyIHI9bmV3IEJpbmFyeU9wUHJvZ3JhbShQT1csZS5zaGFwZSx0LnNoYXBlKSxuPXIuZ2V0Q3VzdG9tU2V0dXBGdW5jKCksbz10aGlzLm1ha2VPdXRwdXRBcnJheShyLm91dHB1dFNoYXBlLHVwY2FzdFR5cGUoZS5kdHlwZSx0LmR0eXBlKSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihyLFtlLHRdLG8sbil9LGUucHJvdG90eXBlLmNlaWw9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IFVuYXJ5T3BQcm9ncmFtKGUuc2hhcGUsQ0VJTCk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bih0LFtlXSl9LGUucHJvdG90eXBlLmZsb29yPWZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBVbmFyeU9wUHJvZ3JhbShlLnNoYXBlLEZMT09SKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHQsW2VdKX0sZS5wcm90b3R5cGUuc2lnbj1mdW5jdGlvbihlKXt2YXIgdD1uZXcgVW5hcnlPcFByb2dyYW0oZS5zaGFwZSxTSUdOKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHQsW2VdKX0sZS5wcm90b3R5cGUucm91bmQ9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IFVuYXJ5T3BQcm9ncmFtKGUuc2hhcGUsUk9VTkQpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4odCxbZV0pfSxlLnByb3RvdHlwZS5leHA9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IFVuYXJ5T3BQcm9ncmFtKGUuc2hhcGUsRVhQKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHQsW2VdKX0sZS5wcm90b3R5cGUuZXhwbTE9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IFVuYXJ5T3BQcm9ncmFtKGUuc2hhcGUsRVhQTTEpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4odCxbZV0pfSxlLnByb3RvdHlwZS5sb2c9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IFVuYXJ5T3BQcm9ncmFtKGUuc2hhcGUsTE9HKSxyPXQuZ2V0Q3VzdG9tU2V0dXBGdW5jKCk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bih0LFtlXSxudWxsLHIpfSxlLnByb3RvdHlwZS5sb2cxcD1mdW5jdGlvbihlKXt2YXIgdD1uZXcgVW5hcnlPcFByb2dyYW0oZS5zaGFwZSxMT0cxUCk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bih0LFtlXSl9LGUucHJvdG90eXBlLnNxcnQ9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IFVuYXJ5T3BQcm9ncmFtKGUuc2hhcGUsU1FSVCk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bih0LFtlXSl9LGUucHJvdG90eXBlLnJzcXJ0PWZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBVbmFyeU9wUHJvZ3JhbShlLnNoYXBlLFJTUVJUKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHQsW2VdKX0sZS5wcm90b3R5cGUuc3F1YXJlPWZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBVbmFyeU9wUHJvZ3JhbShlLnNoYXBlLFNRVUFSRSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bih0LFtlXSl9LGUucHJvdG90eXBlLnJlY2lwcm9jYWw9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IFVuYXJ5T3BQcm9ncmFtKGUuc2hhcGUsUkVDSVBST0NBTCk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bih0LFtlXSl9LGUucHJvdG90eXBlLnJlbHU9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IFVuYXJ5T3BQcm9ncmFtKGUuc2hhcGUsUkVMVSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bih0LFtlXSl9LGUucHJvdG90eXBlLmVsdT1mdW5jdGlvbihlKXt2YXIgdD1uZXcgVW5hcnlPcFByb2dyYW0oZS5zaGFwZSxFTFUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4odCxbZV0pfSxlLnByb3RvdHlwZS5lbHVEZXI9ZnVuY3Rpb24oZSx0KXt2YXIgcj1uZXcgQmluYXJ5T3BQcm9ncmFtKEVMVV9ERVIsZS5zaGFwZSx0LnNoYXBlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHIsW2UsdF0pfSxlLnByb3RvdHlwZS5zZWx1PWZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBVbmFyeU9wUHJvZ3JhbShlLnNoYXBlLFNFTFUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4odCxbZV0pfSxlLnByb3RvdHlwZS5pbnQ9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IFVuYXJ5T3BQcm9ncmFtKGUuc2hhcGUsVE9fSU5UKSxyPXRoaXMubWFrZU91dHB1dEFycmF5KHQub3V0cHV0U2hhcGUsXCJpbnQzMlwiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHQsW2VdLHIpfSxlLnByb3RvdHlwZS5jbGlwPWZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1uZXcgQ2xpcFByb2dyYW0oZS5zaGFwZSx0LHIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbZV0pfSxlLnByb3RvdHlwZS5hYnM9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IFVuYXJ5T3BQcm9ncmFtKGUuc2hhcGUsQUJTKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHQsW2VdKX0sZS5wcm90b3R5cGUuY29tcGxleEFicz1mdW5jdGlvbihlKXt2YXIgdD10aGlzLnRleERhdGEuZ2V0KGUuZGF0YUlkKSxyPW5ldyBDb21wbGV4QWJzUHJvZ3JhbShlLnNoYXBlKSxuPVt0aGlzLm1ha2VDb21wbGV4Q29tcG9uZW50VGVuc29ySGFuZGxlKGUsdC5jb21wbGV4VGVuc29ycy5yZWFsKSx0aGlzLm1ha2VDb21wbGV4Q29tcG9uZW50VGVuc29ySGFuZGxlKGUsdC5jb21wbGV4VGVuc29ycy5pbWFnKV07cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihyLG4pfSxlLnByb3RvdHlwZS5zaWdtb2lkPWZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBVbmFyeU9wUHJvZ3JhbShlLnNoYXBlLFNJR01PSUQpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4odCxbZV0pfSxlLnByb3RvdHlwZS5zb2Z0cGx1cz1mdW5jdGlvbihlKXt2YXIgdD1uZXcgVW5hcnlPcFByb2dyYW0oZS5zaGFwZSxTT0ZUUExVUyk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bih0LFtlXSl9LGUucHJvdG90eXBlLnNpbj1mdW5jdGlvbihlKXt2YXIgdD1uZXcgVW5hcnlPcFByb2dyYW0oZS5zaGFwZSxTSU4pO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4odCxbZV0pfSxlLnByb3RvdHlwZS5jb3M9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IFVuYXJ5T3BQcm9ncmFtKGUuc2hhcGUsQ09TKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHQsW2VdKX0sZS5wcm90b3R5cGUudGFuPWZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBVbmFyeU9wUHJvZ3JhbShlLnNoYXBlLFRBTik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bih0LFtlXSl9LGUucHJvdG90eXBlLmFzaW49ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IFVuYXJ5T3BQcm9ncmFtKGUuc2hhcGUsQVNJTik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bih0LFtlXSl9LGUucHJvdG90eXBlLmFjb3M9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IFVuYXJ5T3BQcm9ncmFtKGUuc2hhcGUsQUNPUyk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bih0LFtlXSl9LGUucHJvdG90eXBlLmF0YW49ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IFVuYXJ5T3BQcm9ncmFtKGUuc2hhcGUsQVRBTik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bih0LFtlXSl9LGUucHJvdG90eXBlLmF0YW4yPWZ1bmN0aW9uKGUsdCl7dmFyIHI9bmV3IEJpbmFyeU9wUHJvZ3JhbShBVEFOMixlLnNoYXBlLHQuc2hhcGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocixbZSx0XSl9LGUucHJvdG90eXBlLnNpbmg9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IFVuYXJ5T3BQcm9ncmFtKGUuc2hhcGUsU0lOSCk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bih0LFtlXSl9LGUucHJvdG90eXBlLmNvc2g9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IFVuYXJ5T3BQcm9ncmFtKGUuc2hhcGUsQ09TSCk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bih0LFtlXSl9LGUucHJvdG90eXBlLnRhbmg9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IFVuYXJ5T3BQcm9ncmFtKGUuc2hhcGUsVEFOSCk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bih0LFtlXSl9LGUucHJvdG90eXBlLmFzaW5oPWZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBVbmFyeU9wUHJvZ3JhbShlLnNoYXBlLEFTSU5IKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHQsW2VdKX0sZS5wcm90b3R5cGUuYWNvc2g9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IFVuYXJ5T3BQcm9ncmFtKGUuc2hhcGUsQUNPU0gpLHI9dC5nZXRDdXN0b21TZXR1cEZ1bmMoKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHQsW2VdLG51bGwscil9LGUucHJvdG90eXBlLmF0YW5oPWZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBVbmFyeU9wUHJvZ3JhbShlLnNoYXBlLEFUQU5IKSxyPXQuZ2V0Q3VzdG9tU2V0dXBGdW5jKCk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bih0LFtlXSxudWxsLHIpfSxlLnByb3RvdHlwZS5lcmY9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IFVuYXJ5T3BQcm9ncmFtKGUuc2hhcGUsRVJGKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHQsW2VdKX0sZS5wcm90b3R5cGUuc3RlcD1mdW5jdGlvbihlLHQpe3ZhciByPW5ldyBVbmFyeU9wUHJvZ3JhbShlLnNoYXBlLFNURVAodCkpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocixbZV0pfSxlLnByb3RvdHlwZS5jb252MmRXaXRoSW0yUm93PWZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1yLmZpbHRlcldpZHRoLG89ci5maWx0ZXJIZWlnaHQsYT1yLmluQ2hhbm5lbHMsaT1yLm91dFdpZHRoLHM9ci5vdXRIZWlnaHQsdT1uKm8qYSxsPXMqaSxjPVt1LGxdLHA9ZS5zcXVlZXplKFswXSksZD10LnJlc2hhcGUoW3UsLTFdKSxoPW5ldyBJbTJDb2xQcm9ncmFtKGMscC5zaGFwZSxyKSxmPXRoaXMuY29tcGlsZUFuZFJ1bihoLFtwXSx0aGlzLm1ha2VQYWNrZWRUZW5zb3IoYykpLG09bmV3IE1hdE11bFBhY2tlZFByb2dyYW0oZi5zaGFwZSxkLnNoYXBlLFtsLHIub3V0Q2hhbm5lbHNdLCEwLCExKSxnPXRoaXMuY29tcGlsZUFuZFJ1bihtLFtmLGRdLHRoaXMubWFrZVBhY2tlZFRlbnNvcihtLm91dHB1dFNoYXBlKSk7cmV0dXJuITE9PT1FTlYuZ2V0KFwiV0VCR0xfTEFaSUxZX1VOUEFDS1wiKSYmKGc9dGhpcy51bnBhY2tUZW5zb3IoZykpLGcucmVzaGFwZShbMSxzLGksci5vdXRDaGFubmVsc10pfSxlLnByb3RvdHlwZS5jb252MmQ9ZnVuY3Rpb24oZSx0LHIpe2lmKEVOVi5nZXQoXCJXRUJHTF9DT05WX0lNMkNPTFwiKSYmMT09PWUuc2hhcGVbMF0pcmV0dXJuIHRoaXMuY29udjJkV2l0aEltMlJvdyhlLHQscik7dmFyIG49bmV3IENvbnYyRFByb2dyYW0ocik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihuLFtlLHRdKX0sZS5wcm90b3R5cGUuY29udjJkRGVySW5wdXQ9ZnVuY3Rpb24oZSx0LHIpe3ZhciBuPW5ldyBDb252MkREZXJJbnB1dFByb2dyYW0ocik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihuLFtlLHRdKX0sZS5wcm90b3R5cGUuY29udjJkRGVyRmlsdGVyPWZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1uZXcgQ29udjJERGVyRmlsdGVyUHJvZ3JhbShyKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4sW2UsdF0pfSxlLnByb3RvdHlwZS5kZXB0aHdpc2VDb252MkQ9ZnVuY3Rpb24oZSx0LHIpe3ZhciBuPW5ldyBEZXB0aHdpc2VDb252MkRQcm9ncmFtKHIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbZSx0XSl9LGUucHJvdG90eXBlLmRlcHRod2lzZUNvbnYyRERlcklucHV0PWZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1uZXcgRGVwdGh3aXNlQ29udjJERGVySW5wdXRQcm9ncmFtKHIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbZSx0XSl9LGUucHJvdG90eXBlLmRlcHRod2lzZUNvbnYyRERlckZpbHRlcj1mdW5jdGlvbihlLHQscil7dmFyIG49bmV3IERlcHRod2lzZUNvbnYyRERlckZpbHRlclByb2dyYW0ocik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihuLFtlLHRdKX0sZS5wcm90b3R5cGUubWF4UG9vbD1mdW5jdGlvbihlLHQpe3ZhciByPW5ldyBQb29sMkRQcm9ncmFtKHQsXCJtYXhcIiwhMSksbj10aGlzLm1ha2VPdXRwdXRBcnJheShyLm91dHB1dFNoYXBlLGUuZHR5cGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocixbZV0sbil9LGUucHJvdG90eXBlLmF2Z1Bvb2w9ZnVuY3Rpb24oZSx0KXt2YXIgcj1uZXcgUG9vbDJEUHJvZ3JhbSh0LFwiYXZnXCIsITEpLG49dGhpcy5tYWtlT3V0cHV0QXJyYXkoci5vdXRwdXRTaGFwZSxcImZsb2F0MzJcIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihyLFtlXSxuKX0sZS5wcm90b3R5cGUubWF4UG9vbEJhY2twcm9wPWZ1bmN0aW9uKGUsdCxyLG4pe3ZhciBvPW5ldyBQb29sMkRQcm9ncmFtKG4sXCJtYXhcIiwhMCksYT10aGlzLmNvbXBpbGVBbmRSdW4obyxbdF0pLGk9bmV3IE1heFBvb2wyREJhY2twcm9wUHJvZ3JhbShuKSxzPXRoaXMubWFrZU91dHB1dEFycmF5KGkub3V0cHV0U2hhcGUsdC5kdHlwZSksdT10aGlzLmNvbXBpbGVBbmRSdW4oaSxbZSxhXSxzKTtyZXR1cm4gYS5kaXNwb3NlKCksdX0sZS5wcm90b3R5cGUuYXZnUG9vbEJhY2twcm9wPWZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1uZXcgQXZnUG9vbDJEQmFja3Byb3BQcm9ncmFtKHIpLG89dGhpcy5tYWtlT3V0cHV0QXJyYXkobi5vdXRwdXRTaGFwZSx0LmR0eXBlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4sW2VdLG8pfSxlLnByb3RvdHlwZS5jYXN0PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGNhc3RUZW5zb3IoZSx0LHRoaXMpfSxlLnByb3RvdHlwZS5yZXNoYXBlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMudGV4RGF0YS5nZXQoZS5kYXRhSWQpLmlzUGFja2VkJiYhaXNSZXNoYXBlRnJlZShlLnNoYXBlLHQpP3RoaXMucGFja2VkUmVzaGFwZShlLHQpOnJlc2hhcGVUZW5zb3IoZSx0KX0sZS5wcm90b3R5cGUucmVzaXplQmlsaW5lYXI9ZnVuY3Rpb24oZSx0LHIsbil7dmFyIG89bmV3IFJlc2l6ZUJpbGluZWFyUHJvZ3JhbShlLnNoYXBlLHQscixuKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG8sW2VdKX0sZS5wcm90b3R5cGUucmVzaXplQmlsaW5lYXJCYWNrcHJvcD1mdW5jdGlvbihlLHQscil7dmFyIG49bmV3IFJlc2l6ZUJpbGluZWFyQmFja3Byb3BQcm9ncmFtKGUsdCxyKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4sW2VdKX0sZS5wcm90b3R5cGUucmVzaXplTmVhcmVzdE5laWdoYm9yPWZ1bmN0aW9uKGUsdCxyLG4pe3ZhciBvPW5ldyBSZXNpemVOZWFyZXN0TmVpZ2hib3JQcm9ncmFtKGUuc2hhcGUsdCxyLG4pO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obyxbZV0pfSxlLnByb3RvdHlwZS5yZXNpemVOZWFyZXN0TmVpZ2hib3JCYWNrcHJvcD1mdW5jdGlvbihlLHQscil7dmFyIG49bmV3IFJlc2l6ZU5lYXJlc3ROZWlnYm9yQmFja3Byb3BQcm9ncmFtKGUsdCxyKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4sW2VdKX0sZS5wcm90b3R5cGUubXVsdGlub21pYWw9ZnVuY3Rpb24oZSx0LHIsbil7dmFyIG89dD9lOnNvZnRtYXgoZSksYT1vLnNoYXBlWzBdLGk9by5zaGFwZVsxXSxzPW5ldyBNdWx0aW5vbWlhbFByb2dyYW0oYSxpLHIpLHU9dGhpcy5tYWtlT3V0cHV0QXJyYXkocy5vdXRwdXRTaGFwZSxcImludDMyXCIpLGw9cy5nZXRDdXN0b21TZXR1cEZ1bmMobik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihzLFtvXSx1LGwpfSxlLnByb3RvdHlwZS5vbmVIb3Q9ZnVuY3Rpb24oZSx0LHIsbil7dmFyIG89bmV3IE9uZUhvdFByb2dyYW0oZS5zaXplLHQscixuKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG8sW2VdKX0sZS5wcm90b3R5cGUubm9uTWF4U3VwcHJlc3Npb249ZnVuY3Rpb24oZSx0LHIsbixvKXtyZXR1cm4gd2FybihcInRmLm5vbk1heFN1cHByZXNzaW9uKCkgaW4gd2ViZ2wgbG9ja3MgdGhlIFVJIHRocmVhZC4gQ2FsbCB0Zi5ub25NYXhTdXBwcmVzc2lvbkFzeW5jKCkgaW5zdGVhZFwiKSxub25NYXhTdXBwcmVzc2lvbkltcGwoZS5kYXRhU3luYygpLHQuZGF0YVN5bmMoKSxyLG4sbyl9LGUucHJvdG90eXBlLmNyb3BBbmRSZXNpemU9ZnVuY3Rpb24oZSx0LHIsbixvLGEpe3ZhciBpPW5ldyBDcm9wQW5kUmVzaXplUHJvZ3JhbShlLnNoYXBlLHQuc2hhcGUsbixvLGEpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oaSxbZSx0LHJdKX0sZS5wcm90b3R5cGUuZGVwdGhUb1NwYWNlPWZ1bmN0aW9uKGUsdCxyKXthc3NlcnQodD4xLFwiYmxvY2tTaXplIHNob3VsZCBiZSA+IDEgZm9yIGRlcHRoVG9TcGFjZSwgYnV0IHdhczogXCIrdCk7dmFyIG49ZS5zaGFwZVswXSxvPShcIk5IV0NcIj09PXI/ZS5zaGFwZVsxXTplLnNoYXBlWzJdKSp0LGE9KFwiTkhXQ1wiPT09cj9lLnNoYXBlWzJdOmUuc2hhcGVbM10pKnQsaT0oXCJOSFdDXCI9PT1yP2Uuc2hhcGVbM106ZS5zaGFwZVsxXSkvKHQqdCkscz1uZXcgRGVwdGhUb1NwYWNlUHJvZ3JhbShcIk5IV0NcIj09PXI/W24sbyxhLGldOltuLGksbyxhXSx0LHIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocyxbZV0pfSxlLnByb3RvdHlwZS5zcGxpdD1mdW5jdGlvbihlLHQscil7cmV0dXJuIHNwbGl0KGUsdCxyKX0sZS5wcm90b3R5cGUuc2NhdHRlck5EPWZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1jYWxjdWxhdGVTaGFwZXModCxlLHIpLG89bi5zbGljZVJhbmssYT1uLm51bVVwZGF0ZXMsaT1uLnNsaWNlU2l6ZSxzPW4uc3RyaWRlcyx1PW4ub3V0cHV0U2l6ZSxsPVt1L2ksaV0sYz1lLnJlc2hhcGUoW2Esb10pLHA9dC5yZXNoYXBlKFthLGldKTtpZigwPT09dSlyZXR1cm4gcmVzaGFwZVRlbnNvcih0ZW5zb3IoW10pLHIpO3ZhciBkPXNjYWxhcigwKSxoPW5ldyBTY2F0dGVyUHJvZ3JhbShhLG8sYy5yYW5rLHAucmFuayxzLGwpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oaCxbcCxjLGRdKS5yZXNoYXBlKHIpfSxlLnByb3RvdHlwZS5zcGFyc2VUb0RlbnNlPWZ1bmN0aW9uKGUsdCxyLG4pe3ZhciBvPWNhbGN1bGF0ZVNoYXBlcyh0LGUsciksYT1vLnNsaWNlUmFuayxpPW8ubnVtVXBkYXRlcyxzPW8uc3RyaWRlcyx1PW8ub3V0cHV0U2l6ZSxsPW5ldyBTY2F0dGVyUHJvZ3JhbShpLGEsZS5yYW5rLHQucmFuayxzLFt1LDFdLCExKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGwsW3QsZSxuXSkucmVzaGFwZShyKX0sZS5wcm90b3R5cGUuZmZ0PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmZmdEltcGwoZSwhMSl9LGUucHJvdG90eXBlLmlmZnQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuZmZ0SW1wbChlLCEwKX0sZS5wcm90b3R5cGUuZmZ0SW1wbD1mdW5jdGlvbihlLHQpe3ZhciByPXRoaXMudGV4RGF0YS5nZXQoZS5kYXRhSWQpLG49bmV3IEZGVFByb2dyYW0oQ09NUExFWF9GRlQuUkVBTCxlLnNoYXBlLHQpLG89bmV3IEZGVFByb2dyYW0oQ09NUExFWF9GRlQuSU1BRyxlLnNoYXBlLHQpLGE9W3RoaXMubWFrZUNvbXBsZXhDb21wb25lbnRUZW5zb3JIYW5kbGUoZSxyLmNvbXBsZXhUZW5zb3JzLnJlYWwpLHRoaXMubWFrZUNvbXBsZXhDb21wb25lbnRUZW5zb3JIYW5kbGUoZSxyLmNvbXBsZXhUZW5zb3JzLmltYWcpXSxpPXRoaXMuY29tcGlsZUFuZFJ1bihuLGEpLHM9dGhpcy5jb21waWxlQW5kUnVuKG8sYSksdT10aGlzLmNvbXBsZXgoaSxzKS5hczJEKGUuc2hhcGVbMF0sZS5zaGFwZVsxXSk7cmV0dXJuIGkuZGlzcG9zZSgpLHMuZGlzcG9zZSgpLHV9LGUucHJvdG90eXBlLmdhdGhlck5EPWZ1bmN0aW9uKGUsdCl7dmFyIHI9dC5zaGFwZSxuPXJbci5sZW5ndGgtMV0sbz1wcmVwYXJlQW5kVmFsaWRhdGUoZSx0KSxhPW9bMF0saT1vWzFdLHM9b1syXSx1PW9bM10sbD10LnJlc2hhcGUoW2ksbl0pLGM9ZS5yZXNoYXBlKFtlLnNpemUvcyxzXSkscD1uZXcgR2F0aGVyTkRQcm9ncmFtKG4sdSxbaSxzXSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwLFtjLGxdKS5yZXNoYXBlKGEpfSxlLnByb3RvdHlwZS5tYWtlT3V0cHV0QXJyYXk9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gVGVuc29yLm1ha2UoZSx7fSx0KX0sZS5wcm90b3R5cGUubWFrZVBhY2tlZFRlbnNvcj1mdW5jdGlvbihlKXt2YXIgdD1UZW5zb3IubWFrZShlLHt9KTtyZXR1cm4gdGhpcy50ZXhEYXRhLmdldCh0LmRhdGFJZCkuaXNQYWNrZWQ9ITAsdH0sZS5wcm90b3R5cGUudW5wYWNrVGVuc29yPWZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBVbnBhY2tQcm9ncmFtKGUuc2hhcGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4odCxbZV0pfSxlLnByb3RvdHlwZS5nZXRCYXRjaERpbT1mdW5jdGlvbihlLHQpe3JldHVybiB2b2lkIDA9PT10JiYodD0yKSxzaXplRnJvbVNoYXBlKGUuc2xpY2UoMCxlLmxlbmd0aC10KSl9LGUucHJvdG90eXBlLmdldFJvd3NDb2xzPWZ1bmN0aW9uKGUpe2lmKDA9PT1lLmxlbmd0aCl0aHJvdyBFcnJvcihcIkNhbm5vdCBnZXQgcm93cyBhbmQgY29sdW1ucyBvZiBhbiBlbXB0eSBzaGFwZSBhcnJheS5cIik7cmV0dXJuW2UubGVuZ3RoPjE/ZVtlLmxlbmd0aC0yXToxLGVbZS5sZW5ndGgtMV1dfSxlLnByb3RvdHlwZS5wYWNrZWRSZXNoYXBlPWZ1bmN0aW9uKGUsdCl7dmFyIHI9ZS5yZXNoYXBlKFt0aGlzLmdldEJhdGNoRGltKGUuc2hhcGUpXS5jb25jYXQodGhpcy5nZXRSb3dzQ29scyhlLnNoYXBlKSkpLG49W3RoaXMuZ2V0QmF0Y2hEaW0odCldLmNvbmNhdCh0aGlzLmdldFJvd3NDb2xzKHQpKSxvPW5ldyBSZXNoYXBlUGFja2VkUHJvZ3JhbShuLHIuc2hhcGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obyxbcl0sdGhpcy5tYWtlUGFja2VkVGVuc29yKG4pKS5yZXNoYXBlKHQpfSxlLnByb3RvdHlwZS5jb21waWxlQW5kUnVuPWZ1bmN0aW9uKGUsdCxyLG4sbyl7dmFyIGE9dGhpcztpZih2b2lkIDA9PT1vJiYobz0hMCksbnVsbD09ciYmKHI9dGhpcy5tYWtlT3V0cHV0QXJyYXkoZS5vdXRwdXRTaGFwZSx0WzBdLmR0eXBlKSksMD09PXIuc2l6ZSlyZXR1cm4gdGhpcy50ZXhEYXRhLmdldChyLmRhdGFJZCkudmFsdWVzPWdldFR5cGVkQXJyYXlGcm9tRFR5cGUoci5kdHlwZSwwKSxyO3ZhciBpPXQubWFwKGZ1bmN0aW9uKHQpe2lmKFwiY29tcGxleDY0XCI9PT10LmR0eXBlKXRocm93IG5ldyBFcnJvcihcIkdQR1BVUHJvZ3JhbSBkb2VzIG5vdCBzdXBwb3J0IGNvbXBsZXg2NCBpbnB1dC4gRm9yIGNvbXBsZXg2NCBkdHlwZXMsIHBsZWFzZSBzZXBhcmF0ZSB0aGUgcHJvZ3JhbSBpbnRvIHJlYWwgYW5kIGltYWdpbmFyeSBwYXJ0cy5cIik7dmFyIHI9YS50ZXhEYXRhLmdldCh0LmRhdGFJZCk7aWYobnVsbD09ci50ZXh0dXJlJiYoci5pc1BhY2tlZHx8IWUudXNlc1BhY2tlZFRleHR1cmVzKSYmc2l6ZUZyb21TaGFwZSh0LnNoYXBlKTw9RU5WLmdldChcIldFQkdMX1NJWkVfVVBMT0FEX1VOSUZPUk1cIikpcmV0dXJue3NoYXBlOnQuc2hhcGUsdGV4RGF0YTpudWxsLGlzVW5pZm9ybTohMCx1bmlmb3JtVmFsdWVzOmEucmVhZFN5bmModC5kYXRhSWQpfTtpZihyLmlzUGFja2VkIT09ISFlLnVzZXNQYWNrZWRUZXh0dXJlcyl7dmFyIG49dm9pZCAwLG89dm9pZCAwO3IuaXNQYWNrZWQ/KG49bmV3IFVucGFja1Byb2dyYW0odC5zaGFwZSksbz1hLmNvbXBpbGVBbmRSdW4obixbdF0pKToobj1uZXcgUGFja1Byb2dyYW0odC5zaGFwZSksbz1hLmNvbXBpbGVBbmRSdW4obixbdF0sYS5tYWtlUGFja2VkVGVuc29yKHQuc2hhcGUpKSkscj1hLnRleERhdGEuZ2V0KG8uZGF0YUlkKSx0PW99cmV0dXJuIGEudXBsb2FkVG9HUFUodC5kYXRhSWQpLHtzaGFwZTp0LnNoYXBlLHRleERhdGE6cixpc1VuaWZvcm06ITF9fSk7dGhpcy51cGxvYWRUb0dQVShyLmRhdGFJZCk7dmFyIHMsdT17c2hhcGU6ci5zaGFwZSx0ZXhEYXRhOnRoaXMudGV4RGF0YS5nZXQoci5kYXRhSWQpLGlzVW5pZm9ybTohMX0sbD1tYWtlU2hhZGVyS2V5KGUsaSx1KSxjPXRoaXMuZ2V0QW5kU2F2ZUJpbmFyeShsLGZ1bmN0aW9uKCl7cmV0dXJuIGNvbXBpbGVQcm9ncmFtKGEuZ3BncHUsZSxpLHUpfSkscD1udWxsIT10aGlzLmFjdGl2ZVRpbWVycztpZihwJiYocz10aGlzLnN0YXJ0VGltZXIoKSkscnVuUHJvZ3JhbShjLGksdSxuKSxFTlYuZ2V0KFwiV0VCR0xfUEFHSU5HX0VOQUJMRURcIikmJm8mJnRoaXMubnVtQnl0ZXNJbkdQVT50aGlzLk5VTV9CWVRFU19CRUZPUkVfUEFHSU5HKWZvcih2YXIgZD10aGlzLm51bUJ5dGVzSW5HUFUtdGhpcy5OVU1fQllURVNfQkVGT1JFX1BBR0lORztkPjAmJnRoaXMubHJ1RGF0YUdQVS5sZW5ndGg+MDspe3ZhciBoPXRoaXMubHJ1RGF0YUdQVS5zaGlmdCgpLGY9dGhpcy50ZXhEYXRhLmdldChoKSxtPWYuc2hhcGUsZz1mLmR0eXBlO2QtPXRoaXMuY29tcHV0ZUJ5dGVzKG0sZyksdGhpcy5yZWFkKGgpfXJldHVybiBwJiYocz10aGlzLmVuZFRpbWVyKHMpLHRoaXMuYWN0aXZlVGltZXJzLnB1c2goe25hbWU6ZS5jb25zdHJ1Y3Rvci5uYW1lLHF1ZXJ5OnRoaXMuZ2V0UXVlcnlUaW1lKHMpfSkpLHJ9LGUucHJvdG90eXBlLmdldEFuZFNhdmVCaW5hcnk9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZSBpbiB0aGlzLmJpbmFyeUNhY2hlfHwodGhpcy5iaW5hcnlDYWNoZVtlXT10KCkpLHRoaXMuYmluYXJ5Q2FjaGVbZV19LGUucHJvdG90eXBlLmdldFRleHR1cmVNYW5hZ2VyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGV4dHVyZU1hbmFnZXJ9LGUucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXtpZighdGhpcy5kaXNwb3NlZCl7Zm9yKHZhciBlIGluIHRoaXMuYmluYXJ5Q2FjaGUpdGhpcy5ncGdwdS5kZWxldGVQcm9ncmFtKHRoaXMuYmluYXJ5Q2FjaGVbZV0ud2ViR0xQcm9ncmFtKTt0aGlzLnRleHR1cmVNYW5hZ2VyLmRpc3Bvc2UoKSx0aGlzLmNhbnZhcy5yZW1vdmUoKSxudWxsIT10aGlzLmZyb21QaXhlbHMyRENvbnRleHQmJnRoaXMuZnJvbVBpeGVsczJEQ29udGV4dC5jYW52YXMucmVtb3ZlKCksdGhpcy5ncGdwdUNyZWF0ZWRMb2NhbGx5JiZ0aGlzLmdwZ3B1LmRpc3Bvc2UoKSx0aGlzLmRpc3Bvc2VkPSEwfX0sZS5wcm90b3R5cGUuZmxvYXRQcmVjaXNpb249ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7cmV0dXJuIGUuYWJzKHNjYWxhcigxZS04KSkuZ2V0KCk+MD8zMjoxNn0pfSxlLnByb3RvdHlwZS51cGxvYWRUb0dQVT1mdW5jdGlvbihlKXt2YXIgdD10aGlzLnRleERhdGEuZ2V0KGUpLHI9dC5zaGFwZSxuPXQudmFsdWVzLG89dC50ZXh0dXJlLGE9dC5kdHlwZSxpPXQudXNhZ2Uscz10LmlzUGFja2VkO2lmKG51bGw9PW8pe3ZhciB1LGw9bnVsbCE9dGhpcy5hY3RpdmVUaW1lcnM7bCYmKHU9cGVyZm9ybWFuY2Uubm93KCkpO3ZhciBjPWdldFRleHR1cmVTaGFwZUZyb21Mb2dpY2FsU2hhcGUocixzKTt0LnRleFNoYXBlPWM7dmFyIHA9dGhpcy5hY3F1aXJlVGV4dHVyZShlLGMsaSxzKTtpZih0LnRleHR1cmU9cCxudWxsIT1uKXtpZihzKXt2YXIgZD1zaXplRnJvbVNoYXBlKHIuc2xpY2UoMCxyLmxlbmd0aC0yKSksaD1yLmxlbmd0aD4xP3Jbci5sZW5ndGgtMl06MSxmPXJbci5sZW5ndGgtMV07dGhpcy5ncGdwdS51cGxvYWRNYXRyaXhUb1BhY2tlZFRleHR1cmUocCxkLGgsZix0eXBlZEFycmF5VG9GbG9hdDMyKG4sYSkpfWVsc2UgdGhpcy5ncGdwdS51cGxvYWRNYXRyaXhUb1RleHR1cmUocCxjWzBdLGNbMV0sdHlwZWRBcnJheVRvRmxvYXQzMihuLGEpKTt0LnZhbHVlcz1udWxsLGwmJih0aGlzLnVwbG9hZFdhaXRNcys9cGVyZm9ybWFuY2Uubm93KCktdSl9fWVsc2V7RU5WLmdldChcIldFQkdMX1BBR0lOR19FTkFCTEVEXCIpJiZ0aGlzLmxydURhdGFHUFUuaW5kZXhPZihlKT49MCYmKHRoaXMubHJ1RGF0YUdQVS5zcGxpY2UodGhpcy5scnVEYXRhR1BVLmluZGV4T2YoZSksMSksdGhpcy5scnVEYXRhR1BVLnB1c2goZSkpfX0sZS5wcm90b3R5cGUuY29udmVydEFuZENhY2hlT25DUFU9ZnVuY3Rpb24oZSx0KXt2YXIgcj10aGlzLmRlbGF5ZWRTdG9yYWdlLG49dGhpcy50ZXhEYXRhLmdldChlKSxvPW4udGV4dHVyZSxhPW4udGV4U2hhcGUsaT1uLmR0eXBlLHM9bi51c2FnZSx1PW4uaXNQYWNrZWQ7cmV0dXJuIHImJm51bGwhPW8mJih0aGlzLnJlbGVhc2VUZXh0dXJlKGUsbyxhLHMsdSksbi50ZXh0dXJlPW51bGwsbi50ZXhTaGFwZT1udWxsKSxuLnVzYWdlPVRleHR1cmVVc2FnZS5VUExPQUQsbnVsbCE9dCYmKG4udmFsdWVzPWZsb2F0MzJUb1R5cGVkQXJyYXkodCxpKSksbi52YWx1ZXN9LGUucHJvdG90eXBlLnJlbGVhc2VUZXh0dXJlPWZ1bmN0aW9uKGUsdCxyLG4sbyl7dmFyIGE9dGhpcy50ZXhEYXRhLmdldChlKSxpPWEuc2hhcGUscz1hLmR0eXBlO2lmKEVOVi5nZXQoXCJXRUJHTF9QQUdJTkdfRU5BQkxFRFwiKSl7dmFyIHU9dGhpcy5scnVEYXRhR1BVLmluZGV4T2YoZSk7dT49MCYmdGhpcy5scnVEYXRhR1BVLnNwbGljZSh1LDEpfXRoaXMubnVtQnl0ZXNJbkdQVS09dGhpcy5jb21wdXRlQnl0ZXMoaSxzKSx0aGlzLnRleHR1cmVNYW5hZ2VyLnJlbGVhc2VUZXh0dXJlKHQscixuLG8pfSxlLnByb3RvdHlwZS5hY3F1aXJlVGV4dHVyZT1mdW5jdGlvbihlLHQscixuKXt2YXIgbz10aGlzLnRleERhdGEuZ2V0KGUpLGE9by5zaGFwZSxpPW8uZHR5cGU7cmV0dXJuIEVOVi5nZXQoXCJXRUJHTF9QQUdJTkdfRU5BQkxFRFwiKSYmdGhpcy5scnVEYXRhR1BVLnB1c2goZSksdGhpcy5udW1CeXRlc0luR1BVKz10aGlzLmNvbXB1dGVCeXRlcyhhLGkpLHRoaXMudGV4dHVyZU1hbmFnZXIuYWNxdWlyZVRleHR1cmUodCxyLG4pfSxlLnByb3RvdHlwZS5jb21wdXRlQnl0ZXM9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gc2l6ZUZyb21TaGFwZShlKSpieXRlc1BlckVsZW1lbnQodCl9LGV9KCk7ZnVuY3Rpb24gZmxvYXQzMlRvVHlwZWRBcnJheShlLHQpe2lmKFwiZmxvYXQzMlwiPT09dHx8XCJjb21wbGV4NjRcIj09PXQpcmV0dXJuIGU7aWYoXCJpbnQzMlwiPT09dHx8XCJib29sXCI9PT10KXtmb3IodmFyIHI9XCJpbnQzMlwiPT09dD9uZXcgSW50MzJBcnJheShlLmxlbmd0aCk6bmV3IFVpbnQ4QXJyYXkoZS5sZW5ndGgpLG49MDtuPHIubGVuZ3RoOysrbilyW25dPU1hdGgucm91bmQoZVtuXSk7cmV0dXJuIHJ9dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkdHlwZSBcIit0KX1mdW5jdGlvbiB0eXBlZEFycmF5VG9GbG9hdDMyKGUsdCl7cmV0dXJuIGUgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXk/ZTpuZXcgRmxvYXQzMkFycmF5KGUpfWZ1bmN0aW9uIG5lZ18oZSl7dmFyIHQ9Y29udmVydFRvVGVuc29yKGUsXCJ4XCIsXCJuZWdcIik7cmV0dXJuIEVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKGUpe3JldHVybiBlLm5lZyh0KX0seyR4OnR9LGZ1bmN0aW9uKGUpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBlLm5lZygpfX19KX1mdW5jdGlvbiBjZWlsXyhlKXt2YXIgdD1jb252ZXJ0VG9UZW5zb3IoZSxcInhcIixcImNlaWxcIik7cmV0dXJuIEVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKGUpe3JldHVybiBlLmNlaWwodCl9LHskeDp0fSxmdW5jdGlvbihlKXtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gemVyb3NMaWtlKGUpfX19KX1mdW5jdGlvbiBmbG9vcl8oZSl7dmFyIHQ9Y29udmVydFRvVGVuc29yKGUsXCJ4XCIsXCJmbG9vclwiKTtyZXR1cm4gRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24oZSl7cmV0dXJuIGUuZmxvb3IodCl9LHskeDp0fSxmdW5jdGlvbihlKXtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gemVyb3NMaWtlKGUpfX19KX1mdW5jdGlvbiBzaWduXyhlKXt2YXIgdD1jb252ZXJ0VG9UZW5zb3IoZSxcInhcIixcInNpZ25cIik7cmV0dXJuIEVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKGUpe3JldHVybiBlLnNpZ24odCl9LHskeDp0fSxmdW5jdGlvbihlKXtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gemVyb3NMaWtlKGUpfX19KX1mdW5jdGlvbiByb3VuZF8oZSl7dmFyIHQ9Y29udmVydFRvVGVuc29yKGUsXCJ4XCIsXCJyb3VuZFwiKTtyZXR1cm4gRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24oZSl7cmV0dXJuIGUucm91bmQodCl9LHskeDp0fSxmdW5jdGlvbihlKXtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gemVyb3NMaWtlKGUpfX19KX1mdW5jdGlvbiBleHBfKGUpe3ZhciB0PWNvbnZlcnRUb1RlbnNvcihlLFwieFwiLFwiZXhwXCIpO3JldHVybiBFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbihlLHIpe3JldHVybiByKGUuZXhwKHQpKX0seyR4OnR9LGZ1bmN0aW9uKGUsdCl7dmFyIHI9dFswXTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gZS5tdWxTdHJpY3Qocil9fX0pfWZ1bmN0aW9uIGV4cG0xXyhlKXt2YXIgdD1jb252ZXJ0VG9UZW5zb3IoZSxcInhcIixcImV4cG0xXCIpO3JldHVybiBFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbihlKXtyZXR1cm4gZS5leHBtMSh0KX0seyR4OnR9LGZ1bmN0aW9uKGUpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBlLm11bFN0cmljdCh0LmV4cCgpKX19fSl9ZnVuY3Rpb24gbG9nXyhlKXt2YXIgdD1jb252ZXJ0VG9UZW5zb3IoZSxcInhcIixcImxvZ1wiKTtyZXR1cm4gRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24oZSl7cmV0dXJuIGUubG9nKHQpfSx7JHg6dH0sZnVuY3Rpb24oZSl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIGUuZGl2U3RyaWN0KHQudG9GbG9hdCgpKX19fSl9ZnVuY3Rpb24gbG9nMXBfKGUpe3ZhciB0PWNvbnZlcnRUb1RlbnNvcihlLFwieFwiLFwibG9nMXBcIik7cmV0dXJuIEVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKGUpe3JldHVybiBlLmxvZzFwKHQpfSx7JHg6dH0sZnVuY3Rpb24oZSl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIGUuZGl2U3RyaWN0KHQuYWRkKHNjYWxhcigxKSkpfX19KX1mdW5jdGlvbiBzcXJ0XyhlKXt2YXIgdD1jb252ZXJ0VG9UZW5zb3IoZSxcInhcIixcInNxcnRcIik7cmV0dXJuIEVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKGUpe3JldHVybiBlLnNxcnQodCl9LHskeDp0fSxmdW5jdGlvbihlKXtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gZS5kaXZTdHJpY3QodC50b0Zsb2F0KCkuc3FydCgpLm11bChzY2FsYXIoMikpKX19fSl9ZnVuY3Rpb24gcnNxcnRfKGUpe3ZhciB0PWNvbnZlcnRUb1RlbnNvcihlLFwieFwiLFwicnNxcnRcIik7cmV0dXJuIEVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKGUpe3JldHVybiBlLnJzcXJ0KHQpfSx7JHg6dH0sZnVuY3Rpb24oZSl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIGUuZGl2U3RyaWN0KHQucG93KHNjYWxhcigxLjUpKS5tdWwoc2NhbGFyKDIpKSkubmVnKCl9fX0pfWZ1bmN0aW9uIHNxdWFyZV8oZSl7dmFyIHQ9Y29udmVydFRvVGVuc29yKGUsXCJ4XCIsXCJzcXVhcmVcIik7cmV0dXJuIEVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKGUpe3JldHVybiBlLnNxdWFyZSh0KX0seyR4OnR9LGZ1bmN0aW9uKGUpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBlLm11bFN0cmljdCh0LnRvRmxvYXQoKS5tdWwoc2NhbGFyKDIpKSl9fX0pfWZ1bmN0aW9uIHJlY2lwcm9jYWxfKGUpe3ZhciB0PWNvbnZlcnRUb1RlbnNvcihlLFwieFwiLFwicmVjaXByb2NhbFwiKTtyZXR1cm4gRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24oZSl7cmV0dXJuIGUucmVjaXByb2NhbCh0KX0seyR4OnR9LGZ1bmN0aW9uKGUpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBlLmRpdlN0cmljdCh0LnNxdWFyZSgpLm5lZygpKX19fSl9ZnVuY3Rpb24gYWJzXyhlKXt2YXIgdD1jb252ZXJ0VG9UZW5zb3IoZSxcInhcIixcImFic1wiKTtpZihcImNvbXBsZXg2NFwiPT09dC5kdHlwZSlyZXR1cm4gRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24oZSl7cmV0dXJuIGUuY29tcGxleEFicyh0KX0seyR4OnR9KTtyZXR1cm4gRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24oZSl7cmV0dXJuIGUuYWJzKHQpfSx7JHg6dH0sZnVuY3Rpb24oZSl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIGUubXVsU3RyaWN0KHQudG9GbG9hdCgpLnN0ZXAoLTEpKX19fSl9ZnVuY3Rpb24gY2xpcEJ5VmFsdWVfKGUsdCxyKXt2YXIgbj1jb252ZXJ0VG9UZW5zb3IoZSxcInhcIixcImNsaXBCeVZhbHVlXCIpO2Fzc2VydCh0PD1yLFwiRXJyb3IgaW4gY2xpcDogbWluIChcIit0K1wiKSBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byBtYXggKFwiK3IrXCIpLlwiKTtyZXR1cm4gRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24oZSl7cmV0dXJuIGUuY2xpcChuLHQscil9LHskeDpufSxmdW5jdGlvbihlKXtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gZS53aGVyZShuLmdyZWF0ZXJFcXVhbChzY2FsYXIodCkpLmxvZ2ljYWxBbmQobi5sZXNzRXF1YWwoc2NhbGFyKHIpKSksemVyb3NMaWtlKGUpKX19fSl9ZnVuY3Rpb24gc2lnbW9pZF8oZSl7dmFyIHQ9Y29udmVydFRvVGVuc29yKGUsXCJ4XCIsXCJzaWdtb2lkXCIpO3JldHVybiBFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbihlLHIpe3JldHVybiByKGUuc2lnbW9pZCh0KSl9LHskeDp0fSxmdW5jdGlvbihlLHQpe3ZhciByPXRbMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIGUubXVsU3RyaWN0KHIubXVsKHNjYWxhcigxKS5zdWIocikpKX19fSl9ZnVuY3Rpb24gbG9nU2lnbW9pZF8oZSl7dmFyIHQ9Y29udmVydFRvVGVuc29yKGUsXCJ4XCIsXCJsb2dTaWdtb2lkXCIpO3JldHVybiBFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbihlKXtyZXR1cm4gZS5zb2Z0cGx1cyh0Lm5lZygpKS5uZWcoKX0seyR4OnR9LGZ1bmN0aW9uKGUpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBlLm11bFN0cmljdCh0Lm5lZygpLnNpZ21vaWQoKSl9fX0pfWZ1bmN0aW9uIHNvZnRwbHVzXyhlKXt2YXIgdD1jb252ZXJ0VG9UZW5zb3IoZSxcInhcIixcInNvZnRwbHVzXCIpO3JldHVybiBFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbihlKXtyZXR1cm4gZS5zb2Z0cGx1cyh0KX0seyR4OnR9LGZ1bmN0aW9uKGUpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBlLm11bFN0cmljdCh0LnNpZ21vaWQoKSl9fX0pfWZ1bmN0aW9uIHNpbl8oZSl7dmFyIHQ9Y29udmVydFRvVGVuc29yKGUsXCJ4XCIsXCJzaW5cIik7cmV0dXJuIEVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKGUpe3JldHVybiBlLnNpbih0KX0seyR4OnR9LGZ1bmN0aW9uKGUpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0LnRvRmxvYXQoKS5jb3MoKS5tdWxTdHJpY3QoZSl9fX0pfWZ1bmN0aW9uIGNvc18oZSl7dmFyIHQ9Y29udmVydFRvVGVuc29yKGUsXCJ4XCIsXCJjb3NcIik7cmV0dXJuIEVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKGUpe3JldHVybiBlLmNvcyh0KX0seyR4OnR9LGZ1bmN0aW9uKGUpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0LnRvRmxvYXQoKS5zaW4oKS5uZWcoKS5tdWxTdHJpY3QoZSl9fX0pfWZ1bmN0aW9uIHRhbl8oZSl7dmFyIHQ9Y29udmVydFRvVGVuc29yKGUsXCJ4XCIsXCJ0YW5cIik7cmV0dXJuIEVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKGUpe3JldHVybiBlLnRhbih0KX0seyR4OnR9LGZ1bmN0aW9uKGUpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBlLmRpdlN0cmljdCh0LmNvcygpLnNxdWFyZSgpKX19fSl9ZnVuY3Rpb24gYXNpbl8oZSl7dmFyIHQ9Y29udmVydFRvVGVuc29yKGUsXCJ4XCIsXCJhc2luXCIpO3JldHVybiBFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbihlKXtyZXR1cm4gZS5hc2luKHQpfSx7JHg6dH0sZnVuY3Rpb24oZSl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIGUuZGl2U3RyaWN0KHNjYWxhcigxKS5zdWIodC50b0Zsb2F0KCkuc3F1YXJlKCkpLnNxcnQoKSl9fX0pfWZ1bmN0aW9uIGFjb3NfKGUpe3ZhciB0PWNvbnZlcnRUb1RlbnNvcihlLFwieFwiLFwiYWNvc1wiKTtyZXR1cm4gRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24oZSl7cmV0dXJuIGUuYWNvcyh0KX0seyR4OnR9LGZ1bmN0aW9uKGUpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBlLmRpdlN0cmljdChzY2FsYXIoMSkuc3ViKHQudG9GbG9hdCgpLnNxdWFyZSgpKS5zcXJ0KCkpLm5lZygpfX19KX1mdW5jdGlvbiBhdGFuXyhlKXt2YXIgdD1jb252ZXJ0VG9UZW5zb3IoZSxcInhcIixcImF0YW5cIik7cmV0dXJuIEVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKGUpe3JldHVybiBlLmF0YW4odCl9LHskeDp0fSxmdW5jdGlvbihlKXtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gZS5kaXZTdHJpY3Qoc2NhbGFyKDEpLmFkZCh0LnRvRmxvYXQoKS5zcXVhcmUoKSkpfX19KX1mdW5jdGlvbiBzaW5oXyhlKXt2YXIgdD1jb252ZXJ0VG9UZW5zb3IoZSxcInhcIixcInNpbmhcIik7cmV0dXJuIEVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKGUpe3JldHVybiBlLnNpbmgodCl9LHskeDp0fSxmdW5jdGlvbihlKXtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC50b0Zsb2F0KCkuY29zaCgpLm11bFN0cmljdChlKX19fSl9ZnVuY3Rpb24gY29zaF8oZSl7dmFyIHQ9Y29udmVydFRvVGVuc29yKGUsXCJ4XCIsXCJjb3NoXCIpO3JldHVybiBFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbihlKXtyZXR1cm4gZS5jb3NoKHQpfSx7JHg6dH0sZnVuY3Rpb24oZSl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQudG9GbG9hdCgpLnNpbmgoKS5tdWxTdHJpY3QoZSl9fX0pfWZ1bmN0aW9uIHRhbmhfKGUpe3ZhciB0PWNvbnZlcnRUb1RlbnNvcihlLFwieFwiLFwidGFuaFwiKTtyZXR1cm4gRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24oZSxyKXtyZXR1cm4gcihlLnRhbmgodCkpfSx7JHg6dH0sZnVuY3Rpb24oZSx0KXt2YXIgcj10WzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBzY2FsYXIoMSkuc3ViKHIuc3F1YXJlKCkpLm11bFN0cmljdChlKX19fSl9ZnVuY3Rpb24gYXNpbmhfKGUpe3ZhciB0PWNvbnZlcnRUb1RlbnNvcihlLFwieFwiLFwiYXNpbmhcIik7cmV0dXJuIEVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKGUpe3JldHVybiBlLmFzaW5oKHQpfSx7JHg6dH0sZnVuY3Rpb24oZSl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIGUuZGl2U3RyaWN0KHNjYWxhcigxKS5hZGQodC50b0Zsb2F0KCkuc3F1YXJlKCkpLnNxcnQoKSl9fX0pfWZ1bmN0aW9uIGFjb3NoXyhlKXt2YXIgdD1jb252ZXJ0VG9UZW5zb3IoZSxcInhcIixcImFjb3NoXCIpO3JldHVybiBFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbihlKXtyZXR1cm4gZS5hY29zaCh0KX0seyR4OnR9LGZ1bmN0aW9uKGUpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBlLmRpdlN0cmljdCh0LnRvRmxvYXQoKS5zcXVhcmUoKS5zdWIoc2NhbGFyKDEpKS5zcXJ0KCkpfX19KX1mdW5jdGlvbiBhdGFuaF8oZSl7dmFyIHQ9Y29udmVydFRvVGVuc29yKGUsXCJ4XCIsXCJhdGFuaFwiKTtyZXR1cm4gRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24oZSl7cmV0dXJuIGUuYXRhbmgodCl9LHskeDp0fSxmdW5jdGlvbihlKXtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gZS5kaXZTdHJpY3Qoc2NhbGFyKDEpLnN1Yih0LnRvRmxvYXQoKS5zcXVhcmUoKSkpfX19KX1mdW5jdGlvbiBlcmZfKGUpe3ZhciB0PWNvbnZlcnRUb1RlbnNvcihlLFwieFwiLFwiZXJmXCIpO2Fzc2VydChcImludDMyXCI9PT10LmR0eXBlfHxcImZsb2F0MzJcIj09PXQuZHR5cGUsXCJJbnB1dCBkdHlwZSBtdXN0IGJlIGBpbnQzMmAgb3IgYGZsb2F0MzJgLlwiKSxcImludDMyXCI9PT10LmR0eXBlJiYodD10LnRvRmxvYXQoKSk7cmV0dXJuIEVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKGUpe3JldHVybiBlLmVyZih0KX0seyR4OnR9LGZ1bmN0aW9uKGUpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBlLm11bFN0cmljdChzY2FsYXIoMi9NYXRoLnNxcnQoTWF0aC5QSSkpLm11bCh0LnNxdWFyZSgpLm5lZygpLmV4cCgpKSl9fX0pfWZ1bmN0aW9uIHN0ZXBfKGUsdCl7dm9pZCAwPT09dCYmKHQ9MCk7dmFyIHI9Y29udmVydFRvVGVuc29yKGUsXCJ4XCIsXCJzdGVwXCIpO3JldHVybiBFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbihlKXtyZXR1cm4gZS5zdGVwKHIsdCl9LHskeDpyfSxmdW5jdGlvbihlKXtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gemVyb3NMaWtlKGUpfX19KX1FTlYuZ2V0KFwiSVNfQlJPV1NFUlwiKSYmRU5WLnJlZ2lzdGVyQmFja2VuZChcIndlYmdsXCIsZnVuY3Rpb24oKXtyZXR1cm4gbmV3IE1hdGhCYWNrZW5kV2ViR0x9LDIsc2V0VGVuc29yVHJhY2tlcik7dmFyIGFicz1vcCh7YWJzXzphYnNffSksYWNvcz1vcCh7YWNvc186YWNvc199KSxhY29zaD1vcCh7YWNvc2hfOmFjb3NoX30pLGFzaW49b3Aoe2FzaW5fOmFzaW5ffSksYXNpbmg9b3Aoe2FzaW5oXzphc2luaF99KSxhdGFuPW9wKHthdGFuXzphdGFuX30pLGF0YW5oPW9wKHthdGFuaF86YXRhbmhffSksY2VpbD1vcCh7Y2VpbF86Y2VpbF99KSxjbGlwQnlWYWx1ZT1vcCh7Y2xpcEJ5VmFsdWVfOmNsaXBCeVZhbHVlX30pLGNvcz1vcCh7Y29zXzpjb3NffSksY29zaD1vcCh7Y29zaF86Y29zaF99KSxlcmY9b3Aoe2VyZl86ZXJmX30pLGV4cD1vcCh7ZXhwXzpleHBffSksZXhwbTE9b3Aoe2V4cG0xXzpleHBtMV99KSxmbG9vcj1vcCh7Zmxvb3JfOmZsb29yX30pLGxvZyQxPW9wKHtsb2dfOmxvZ199KSxsb2cxcD1vcCh7bG9nMXBfOmxvZzFwX30pLGxvZ1NpZ21vaWQ9b3Aoe2xvZ1NpZ21vaWRfOmxvZ1NpZ21vaWRffSksbmVnPW9wKHtuZWdfOm5lZ199KSxyZWNpcHJvY2FsPW9wKHtyZWNpcHJvY2FsXzpyZWNpcHJvY2FsX30pLHJvdW5kPW9wKHtyb3VuZF86cm91bmRffSkscnNxcnQ9b3Aoe3JzcXJ0Xzpyc3FydF99KSxzaWdtb2lkPW9wKHtzaWdtb2lkXzpzaWdtb2lkX30pLHNpZ249b3Aoe3NpZ25fOnNpZ25ffSksc2luPW9wKHtzaW5fOnNpbl99KSxzaW5oPW9wKHtzaW5oXzpzaW5oX30pLHNvZnRwbHVzPW9wKHtzb2Z0cGx1c186c29mdHBsdXNffSksc3FydD1vcCh7c3FydF86c3FydF99KSxzcXVhcmU9b3Aoe3NxdWFyZV86c3F1YXJlX30pLHN0ZXA9b3Aoe3N0ZXBfOnN0ZXBffSksdGFuPW9wKHt0YW5fOnRhbl99KSx0YW5oJDE9b3Aoe3RhbmhfOnRhbmhffSk7ZnVuY3Rpb24gYmF0Y2hOb3JtYWxpemF0aW9uMmRfKGUsdCxyLG4sbyxhKXt2b2lkIDA9PT1uJiYobj0uMDAxKTt2YXIgaSxzLHU9Y29udmVydFRvVGVuc29yKGUsXCJ4XCIsXCJiYXRjaE5vcm1hbGl6YXRpb25cIiksbD1jb252ZXJ0VG9UZW5zb3IodCxcIm1lYW5cIixcImJhdGNoTm9ybWFsaXphdGlvblwiKSxjPWNvbnZlcnRUb1RlbnNvcihyLFwidmFyaWFuY2VcIixcImJhdGNoTm9ybWFsaXphdGlvblwiKTtyZXR1cm4gbnVsbCE9byYmKGk9Y29udmVydFRvVGVuc29yKG8sXCJzY2FsZVwiLFwiYmF0Y2hOb3JtYWxpemF0aW9uXCIpKSxudWxsIT1hJiYocz1jb252ZXJ0VG9UZW5zb3IoYSxcIm9mZnNldFwiLFwiYmF0Y2hOb3JtYWxpemF0aW9uXCIpKSxhc3NlcnQoMj09PXUucmFuayxcIkVycm9yIGluIGJhdGNoTm9ybWFsaXphdGlvbjNEOiB4IG11c3QgYmUgcmFuayAzIGJ1dCBnb3QgcmFuayBcIit1LnJhbmsrXCIuXCIpLGFzc2VydCgyPT09bC5yYW5rfHwxPT09bC5yYW5rLFwiRXJyb3IgaW4gYmF0Y2hOb3JtYWxpemF0aW9uMkQ6IG1lYW4gbXVzdCBiZSByYW5rIDIgb3IgcmFuayAxIGJ1dCBnb3QgcmFuayBcIitsLnJhbmsrXCIuXCIpLGFzc2VydCgyPT09Yy5yYW5rfHwxPT09Yy5yYW5rLFwiRXJyb3IgaW4gYmF0Y2hOb3JtYWxpemF0aW9uMkQ6IHZhcmlhbmNlIG11c3QgYmUgcmFuayAyIG9yIHJhbmsgMSBidXQgZ290IHJhbmsgXCIrYy5yYW5rK1wiLlwiKSxudWxsIT1pJiZhc3NlcnQoMj09PWkucmFua3x8MT09PWkucmFuayxcIkVycm9yIGluIGJhdGNoTm9ybWFsaXphdGlvbjJEOiBzY2FsZSBtdXN0IGJlIHJhbmsgMiBvciByYW5rIDEgYnV0IGdvdCByYW5rIFwiK2kucmFuaytcIi5cIiksbnVsbCE9cyYmYXNzZXJ0KDI9PT1zLnJhbmt8fDE9PT1zLnJhbmssXCJFcnJvciBpbiBiYXRjaE5vcm1hbGl6YXRpb24yRDogb2Zmc2V0IG11c3QgYmUgcmFuayAyIG9yIHJhbmsgMSBidXQgZ290IHJhbmsgXCIrcy5yYW5rK1wiLlwiKSxiYXRjaE5vcm1hbGl6YXRpb24odSxsLGMsbixpLHMpfWZ1bmN0aW9uIGJhdGNoTm9ybWFsaXphdGlvbjNkXyhlLHQscixuLG8sYSl7dm9pZCAwPT09biYmKG49LjAwMSk7dmFyIGkscyx1PWNvbnZlcnRUb1RlbnNvcihlLFwieFwiLFwiYmF0Y2hOb3JtYWxpemF0aW9uXCIpLGw9Y29udmVydFRvVGVuc29yKHQsXCJtZWFuXCIsXCJiYXRjaE5vcm1hbGl6YXRpb25cIiksYz1jb252ZXJ0VG9UZW5zb3IocixcInZhcmlhbmNlXCIsXCJiYXRjaE5vcm1hbGl6YXRpb25cIik7cmV0dXJuIG51bGwhPW8mJihpPWNvbnZlcnRUb1RlbnNvcihvLFwic2NhbGVcIixcImJhdGNoTm9ybWFsaXphdGlvblwiKSksbnVsbCE9YSYmKHM9Y29udmVydFRvVGVuc29yKGEsXCJvZmZzZXRcIixcImJhdGNoTm9ybWFsaXphdGlvblwiKSksYXNzZXJ0KDM9PT11LnJhbmssXCJFcnJvciBpbiBiYXRjaE5vcm1hbGl6YXRpb24zRDogeCBtdXN0IGJlIHJhbmsgMyBidXQgZ290IHJhbmsgXCIrdS5yYW5rK1wiLlwiKSxhc3NlcnQoMz09PWwucmFua3x8MT09PWwucmFuayxcIkVycm9yIGluIGJhdGNoTm9ybWFsaXphdGlvbjNEOiBtZWFuIG11c3QgYmUgcmFuayAzIG9yIHJhbmsgMSBidXQgZ290IHJhbmsgXCIrbC5yYW5rK1wiLlwiKSxhc3NlcnQoMz09PWMucmFua3x8MT09PWMucmFuayxcIkVycm9yIGluIGJhdGNoTm9ybWFsaXphdGlvbjNEOiB2YXJpYW5jZSBtdXN0IGJlIHJhbmsgMyBvciByYW5rIDEgYnV0IGdvdCByYW5rIFwiK2MucmFuaytcIi5cIiksbnVsbCE9aSYmYXNzZXJ0KDM9PT1pLnJhbmt8fDE9PT1pLnJhbmssXCJFcnJvciBpbiBiYXRjaE5vcm1hbGl6YXRpb24zRDogc2NhbGUgbXVzdCBiZSByYW5rIDMgb3IgcmFuayAxIGJ1dCBnb3QgcmFuayBcIitpLnJhbmsrXCIuXCIpLG51bGwhPXMmJmFzc2VydCgzPT09cy5yYW5rfHwxPT09cy5yYW5rLFwiRXJyb3IgaW4gYmF0Y2hOb3JtYWxpemF0aW9uM0Q6IG9mZnNldCBtdXN0IGJlIHJhbmsgMyBvciByYW5rIDEgYnV0IGdvdCByYW5rIFwiK3MucmFuaytcIi5cIiksYmF0Y2hOb3JtYWxpemF0aW9uKHUsbCxjLG4saSxzKX1mdW5jdGlvbiBiYXRjaE5vcm1hbGl6YXRpb240ZF8oZSx0LHIsbixvLGEpe3ZvaWQgMD09PW4mJihuPS4wMDEpO3ZhciBpLHMsdT1jb252ZXJ0VG9UZW5zb3IoZSxcInhcIixcImJhdGNoTm9ybWFsaXphdGlvblwiKSxsPWNvbnZlcnRUb1RlbnNvcih0LFwibWVhblwiLFwiYmF0Y2hOb3JtYWxpemF0aW9uXCIpLGM9Y29udmVydFRvVGVuc29yKHIsXCJ2YXJpYW5jZVwiLFwiYmF0Y2hOb3JtYWxpemF0aW9uXCIpO3JldHVybiBudWxsIT1vJiYoaT1jb252ZXJ0VG9UZW5zb3IobyxcInNjYWxlXCIsXCJiYXRjaE5vcm1hbGl6YXRpb25cIikpLG51bGwhPWEmJihzPWNvbnZlcnRUb1RlbnNvcihhLFwib2Zmc2V0XCIsXCJiYXRjaE5vcm1hbGl6YXRpb25cIikpLGFzc2VydCg0PT09dS5yYW5rLFwiRXJyb3IgaW4gYmF0Y2hOb3JtYWxpemF0aW9uNEQ6IHggbXVzdCBiZSByYW5rIDQgYnV0IGdvdCByYW5rIFwiK3UucmFuaytcIi5cIiksYXNzZXJ0KDQ9PT1sLnJhbmt8fDE9PT1sLnJhbmssXCJFcnJvciBpbiBiYXRjaE5vcm1hbGl6YXRpb240RDogbWVhbiBtdXN0IGJlIHJhbmsgNCBvciByYW5rIDEgYnV0IGdvdCByYW5rIFwiK2wucmFuaytcIi5cIiksYXNzZXJ0KDQ9PT1jLnJhbmt8fDE9PT1jLnJhbmssXCJFcnJvciBpbiBiYXRjaE5vcm1hbGl6YXRpb240RDogdmFyaWFuY2UgbXVzdCBiZSByYW5rIDQgb3IgcmFuayAxIGJ1dCBnb3QgcmFuayBcIitjLnJhbmsrXCIuXCIpLG51bGwhPWkmJmFzc2VydCg0PT09aS5yYW5rfHwxPT09aS5yYW5rLFwiRXJyb3IgaW4gYmF0Y2hOb3JtYWxpemF0aW9uNEQ6IHNjYWxlIG11c3QgYmUgcmFuayA0IG9yIHJhbmsgMSBidXQgZ290IHJhbmsgXCIraS5yYW5rK1wiLlwiKSxudWxsIT1zJiZhc3NlcnQoND09PXMucmFua3x8MT09PXMucmFuayxcIkVycm9yIGluIGJhdGNoTm9ybWFsaXphdGlvbjREOiBvZmZzZXQgbXVzdCBiZSByYW5rIDQgb3IgcmFuayAxIGJ1dCBnb3QgcmFuayBcIitzLnJhbmsrXCIuXCIpLGJhdGNoTm9ybWFsaXphdGlvbih1LGwsYyxuLGkscyl9ZnVuY3Rpb24gYmF0Y2hOb3JtYWxpemF0aW9uXyhlLHQscixuLG8sYSl7dm9pZCAwPT09biYmKG49LjAwMSk7dmFyIGkscyx1LGw9Y29udmVydFRvVGVuc29yKGUsXCJ4XCIsXCJiYXRjaE5vcm1hbGl6YXRpb25cIiksYz1jb252ZXJ0VG9UZW5zb3IodCxcIm1lYW5cIixcImJhdGNoTm9ybWFsaXphdGlvblwiKSxwPWNvbnZlcnRUb1RlbnNvcihyLFwidmFyaWFuY2VcIixcImJhdGNoTm9ybWFsaXphdGlvblwiKTtudWxsIT1vJiYoaT1jb252ZXJ0VG9UZW5zb3IobyxcInNjYWxlXCIsXCJiYXRjaE5vcm1hbGl6YXRpb25cIikpLG51bGwhPWEmJihzPWNvbnZlcnRUb1RlbnNvcihhLFwib2Zmc2V0XCIsXCJiYXRjaE5vcm1hbGl6YXRpb25cIikpLGFzc2VydChjLnJhbms9PT1wLnJhbmssXCJCYXRjaCBub3JtYWxpemF0aW9uIGdyYWRpZW50IHJlcXVpcmVzIG1lYW4gYW5kIHZhcmlhbmNlIHRvIGhhdmUgZXF1YWwgcmFua3MuXCIpLGFzc2VydChudWxsPT1zfHxjLnJhbms9PT1zLnJhbmssXCJCYXRjaCBub3JtYWxpemF0aW9uIGdyYWRpZW50IHJlcXVpcmVzIG1lYW4gYW5kIG9mZnNldCB0byBoYXZlIGVxdWFsIHJhbmtzLlwiKSxhc3NlcnQobnVsbD09aXx8Yy5yYW5rPT09aS5yYW5rLFwiQmF0Y2ggbm9ybWFsaXphdGlvbiBncmFkaWVudCByZXF1aXJlcyBtZWFuIGFuZCBzY2FsZSB0byBoYXZlIGVxdWFsIHJhbmtzLlwiKSx1PTA9PT1sLnJhbmt8fDE9PT1sLnJhbms/bC5hczREKDEsMSwxLGwuc2l6ZSk6Mj09PWwucmFuaz9sLmFzNEQoMSwxLGwuc2hhcGVbMF0sbC5zaGFwZVsxXSk6Mz09PWwucmFuaz9sLmFzNEQoMSxsLnNoYXBlWzBdLGwuc2hhcGVbMV0sbC5zaGFwZVsyXSk6bDtyZXR1cm4gRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24oZSl7cmV0dXJuIGUuYmF0Y2hOb3JtYWxpemF0aW9uKHUsYmF0Y2hub3JtUmVzaGFwZTREKGMpLGJhdGNobm9ybVJlc2hhcGU0RChwKSxuLGJhdGNobm9ybVJlc2hhcGU0RChpKSxiYXRjaG5vcm1SZXNoYXBlNEQocykpfSx7JHg6bCwkbWVhbjpjLCR2YXJpYW5jZTpwLCRzY2FsZTppLCRvZmZzZXQ6c30sZnVuY3Rpb24oZSl7dmFyIHQ9bnVsbD09aT9zY2FsYXIoMSk6aSxyPWdldFJlZHVjdGlvbkF4ZXMoYy5zaGFwZSx1LnNoYXBlKSxvPVtdO2lmKDE9PT1jLnJhbmspe2Zvcih2YXIgYT0wO2E8dS5zaGFwZS5sZW5ndGgtMTsrK2Epby5wdXNoKHUuc2hhcGVbYV0pO28ucHVzaCgxKX12YXIgcz1sLnN1YihjKSxkPWUubXVsKHQpLGg9cnNxcnQocC5hZGQoc2NhbGFyKG4pKSksZj1oLm11bChoKS5tdWwoaCkubXVsKHNjYWxhcigtLjUpKTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gMT09PWMucmFuaz9lLm11bCh0aWxlKGguYXM0RCgxLDEsMSxjLnNoYXBlWzBdKSxvKSkubXVsKHQpLnJlc2hhcGUobC5zaGFwZSk6ZS5tdWwoaCkubXVsKHQpLnJlc2hhcGUobC5zaGFwZSl9LCRtZWFuOmZ1bmN0aW9uKCl7dmFyIGU9aC5tdWwoc2NhbGFyKC0xKSkubXVsKGQpO3JldHVybiAxPT09Yy5yYW5rJiYoZT1lLnN1bShyKSksZS5yZXNoYXBlKGMuc2hhcGUpfSwkdmFyaWFuY2U6ZnVuY3Rpb24oKXt2YXIgZT1mLm11bChzKS5tdWwoZCk7cmV0dXJuIDE9PT1jLnJhbmsmJihlPWUuc3VtKHIpKSxlLnJlc2hhcGUoYy5zaGFwZSl9LCRzY2FsZTpmdW5jdGlvbigpe3ZhciB0PXMubXVsKGgpLG49ZS5tdWwodCk7cmV0dXJuIDE9PT1jLnJhbmsmJihuPW4uc3VtKHIpKSxuLnJlc2hhcGUoYy5zaGFwZSl9LCRvZmZzZXQ6ZnVuY3Rpb24oKXt2YXIgdD1lO3JldHVybiAxPT09Yy5yYW5rJiYodD10LnN1bShyKSksdC5yZXNoYXBlKGMuc2hhcGUpfX19KS5yZXNoYXBlKGwuc2hhcGUpfWZ1bmN0aW9uIGJhdGNobm9ybVJlc2hhcGU0RChlKXtyZXR1cm4gbnVsbD09ZT9udWxsOjA9PT1lLnJhbms/ZS5hczFEKCk6MT09PWUucmFuaz9lOjI9PT1lLnJhbms/ZS5hczREKDEsMSxlLnNoYXBlWzBdLGUuc2hhcGVbMV0pOjM9PT1lLnJhbms/ZS5hczREKDEsZS5zaGFwZVswXSxlLnNoYXBlWzFdLGUuc2hhcGVbMl0pOmV9dmFyIGJhdGNoTm9ybWFsaXphdGlvbjJkPW9wKHtiYXRjaE5vcm1hbGl6YXRpb24yZF86YmF0Y2hOb3JtYWxpemF0aW9uMmRffSksYmF0Y2hOb3JtYWxpemF0aW9uM2Q9b3Aoe2JhdGNoTm9ybWFsaXphdGlvbjNkXzpiYXRjaE5vcm1hbGl6YXRpb24zZF99KSxiYXRjaE5vcm1hbGl6YXRpb240ZD1vcCh7YmF0Y2hOb3JtYWxpemF0aW9uNGRfOmJhdGNoTm9ybWFsaXphdGlvbjRkX30pLGJhdGNoTm9ybWFsaXphdGlvbj1vcCh7YmF0Y2hOb3JtYWxpemF0aW9uXzpiYXRjaE5vcm1hbGl6YXRpb25ffSk7ZnVuY3Rpb24gY29tcHV0ZVBvb2wyREluZm8oZSx0LHIsbixvLGEsaSl7dm9pZCAwPT09aSYmKGk9XCJjaGFubmVsc0xhc3RcIik7dmFyIHMsdT1wYXJzZVR1cGxlUGFyYW0odCksbD11WzBdLGM9dVsxXTtpZihcImNoYW5uZWxzTGFzdFwiPT09aSlzPVtsLGMsZVszXSxlWzNdXTtlbHNle2lmKFwiY2hhbm5lbHNGaXJzdFwiIT09aSl0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRhdGFGb3JtYXQgXCIraSk7cz1bbCxjLGVbMV0sZVsxXV19cmV0dXJuIGNvbXB1dGVDb252MkRJbmZvKGUscyxyLG4sbyxhLCExLGkpfWZ1bmN0aW9uIGNvbXB1dGVDb252MkRJbmZvKGUsdCxyLG4sbyxhLGkscyl7dm9pZCAwPT09aSYmKGk9ITEpLHZvaWQgMD09PXMmJihzPVwiY2hhbm5lbHNMYXN0XCIpO3ZhciB1PVstMSwtMSwtMSwtMV0sbD11WzBdLGM9dVsxXSxwPXVbMl0sZD11WzNdO2lmKFwiY2hhbm5lbHNMYXN0XCI9PT1zKWw9ZVswXSxjPWVbMV0scD1lWzJdLGQ9ZVszXTtlbHNle2lmKFwiY2hhbm5lbHNGaXJzdFwiIT09cyl0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRhdGFGb3JtYXQgXCIrcyk7bD1lWzBdLGQ9ZVsxXSxjPWVbMl0scD1lWzNdfXZhciBoLGY9dFswXSxtPXRbMV0sZz10WzNdLHY9cGFyc2VUdXBsZVBhcmFtKHIpLHk9dlswXSx4PXZbMV0sVD1wYXJzZVR1cGxlUGFyYW0obiksRT1UWzBdLHc9VFsxXSxTPWdldEVmZmVjdGl2ZUZpbHRlclNpemUoZixFKSxiPWdldEVmZmVjdGl2ZUZpbHRlclNpemUobSx3KSxDPWdldFBhZEFuZE91dEluZm8obyxjLHAseSx4LFMsYixhKSxfPUMucGFkSW5mbyxBPUMub3V0SGVpZ2h0LE49Qy5vdXRXaWR0aCxSPWk/ZypkOmc7cmV0dXJuXCJjaGFubmVsc0ZpcnN0XCI9PT1zP2g9W2wsUixBLE5dOlwiY2hhbm5lbHNMYXN0XCI9PT1zJiYoaD1bbCxBLE4sUl0pLHtiYXRjaFNpemU6bCxkYXRhRm9ybWF0OnMsaW5IZWlnaHQ6YyxpbldpZHRoOnAsaW5DaGFubmVsczpkLG91dEhlaWdodDpBLG91dFdpZHRoOk4sb3V0Q2hhbm5lbHM6UixwYWRJbmZvOl8sc3RyaWRlSGVpZ2h0Onksc3RyaWRlV2lkdGg6eCxmaWx0ZXJIZWlnaHQ6ZixmaWx0ZXJXaWR0aDptLGVmZmVjdGl2ZUZpbHRlckhlaWdodDpTLGVmZmVjdGl2ZUZpbHRlcldpZHRoOmIsZGlsYXRpb25IZWlnaHQ6RSxkaWxhdGlvbldpZHRoOncsaW5TaGFwZTplLG91dFNoYXBlOmgsZmlsdGVyU2hhcGU6dH19ZnVuY3Rpb24gY29tcHV0ZU91dHB1dFNoYXBlM0QoZSx0LHIsbixvLGEpe251bGw9PW8mJihvPWNvbXB1dGVEZWZhdWx0UGFkKGUsdCxuKSk7dmFyIGk9ZVswXSxzPWVbMV0sdT1jb25kaXRpb25hbFJvdW5kKChpLXQrMipvKS9uKzEsYSk7YXNzZXJ0KGlzSW50KHUpLFwiVGhlIG91dHB1dCAjIG9mIHJvd3MgKFwiK3UrXCIpIG11c3QgYmUgYW4gaW50ZWdlci4gQ2hhbmdlIHRoZSBzdHJpZGUgYW5kL29yIHplcm8gcGFkIHBhcmFtZXRlcnNcIik7dmFyIGw9Y29uZGl0aW9uYWxSb3VuZCgocy10KzIqbykvbisxLGEpO3JldHVybiBhc3NlcnQoaXNJbnQobCksXCJUaGUgb3V0cHV0ICMgb2YgY29sdW1ucyAoXCIrbCtcIikgbXVzdCBiZSBhbiBpbnRlZ2VyLiBDaGFuZ2UgdGhlIHN0cmlkZSBhbmQvb3IgemVybyBwYWQgcGFyYW1ldGVyc1wiKSxbdSxsLHJdfWZ1bmN0aW9uIGNvbXB1dGVEZWZhdWx0UGFkKGUsdCxyLG4pe3ZvaWQgMD09PW4mJihuPTEpO3ZhciBvPWdldEVmZmVjdGl2ZUZpbHRlclNpemUodCxuKTtyZXR1cm4gTWF0aC5mbG9vcigoZVswXSooci0xKS1yK28pLzIpfWZ1bmN0aW9uIHBhcnNlVHVwbGVQYXJhbShlKXtyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgZT9bZSxlXTplfWZ1bmN0aW9uIGdldEVmZmVjdGl2ZUZpbHRlclNpemUoZSx0KXtyZXR1cm4gdDw9MT9lOmUrKGUtMSkqKHQtMSl9ZnVuY3Rpb24gZ2V0UGFkQW5kT3V0SW5mbyhlLHQscixuLG8sYSxpLHMpe3ZhciB1LGwsYztpZihcIm51bWJlclwiPT10eXBlb2YgZSl7dT17dG9wOmUsYm90dG9tOmUsbGVmdDplLHJpZ2h0OmUsdHlwZTowPT09ZT9cIlZBTElEXCI6XCJOVU1CRVJcIn07dmFyIHA9Y29tcHV0ZU91dHB1dFNoYXBlM0QoW3QsciwxXSxhLDEsbixlLHMpO2w9cFswXSxjPXBbMV19ZWxzZSBpZihcInNhbWVcIj09PWUpe3ZhciBkPSgobD1NYXRoLmNlaWwodC9uKSktMSkqbithLXQsaD0oKGM9TWF0aC5jZWlsKHIvbykpLTEpKm8raS1yLGY9TWF0aC5mbG9vcihkLzIpLG09ZC1mLGc9TWF0aC5mbG9vcihoLzIpO3U9e3RvcDpmLGJvdHRvbTptLGxlZnQ6ZyxyaWdodDpoLWcsdHlwZTpcIlNBTUVcIn19ZWxzZXtpZihcInZhbGlkXCIhPT1lKXRocm93IEVycm9yKFwiVW5rbm93biBwYWRkaW5nIHBhcmFtZXRlcjogXCIrZSk7dT17dG9wOjAsYm90dG9tOjAsbGVmdDowLHJpZ2h0OjAsdHlwZTpcIlZBTElEXCJ9LGw9TWF0aC5jZWlsKCh0LWErMSkvbiksYz1NYXRoLmNlaWwoKHItaSsxKS9vKX1yZXR1cm57cGFkSW5mbzp1LG91dEhlaWdodDpsLG91dFdpZHRoOmN9fWZ1bmN0aW9uIGNvbmRpdGlvbmFsUm91bmQoZSx0KXtpZighdClyZXR1cm4gZTtzd2l0Y2godCl7Y2FzZVwicm91bmRcIjpyZXR1cm4gTWF0aC5yb3VuZChlKTtjYXNlXCJjZWlsXCI6cmV0dXJuIE1hdGguY2VpbChlKTtjYXNlXCJmbG9vclwiOnJldHVybiBNYXRoLmZsb29yKGUpO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biByb3VuZGluZ01vZGUgXCIrdCl9fWZ1bmN0aW9uIHR1cGxlVmFsdWVzQXJlT25lKGUpe3ZhciB0PXBhcnNlVHVwbGVQYXJhbShlKSxyPXRbMF0sbj10WzFdO3JldHVybiAxPT09ciYmMT09PW59ZnVuY3Rpb24gZWl0aGVyU3RyaWRlc09yRGlsYXRpb25zQXJlT25lKGUsdCl7cmV0dXJuIHR1cGxlVmFsdWVzQXJlT25lKGUpfHx0dXBsZVZhbHVlc0FyZU9uZSh0KX1mdW5jdGlvbiBtYXRNdWxfKGUsdCxyLG4pe3ZvaWQgMD09PXImJihyPSExKSx2b2lkIDA9PT1uJiYobj0hMSk7dmFyIG89Y29udmVydFRvVGVuc29yKGUsXCJhXCIsXCJtYXRNdWxcIiksYT1jb252ZXJ0VG9UZW5zb3IodCxcImJcIixcIm1hdE11bFwiKSxpPXI/by5zaGFwZVtvLnJhbmstMl06by5zaGFwZVtvLnJhbmstMV0scz1uP2Euc2hhcGVbYS5yYW5rLTFdOmEuc2hhcGVbYS5yYW5rLTJdLHU9cj9vLnNoYXBlW28ucmFuay0xXTpvLnNoYXBlW28ucmFuay0yXSxsPW4/YS5zaGFwZVthLnJhbmstMl06YS5zaGFwZVthLnJhbmstMV0sYz1vLnNoYXBlLnNsaWNlKDAsLTIpLHA9YS5zaGFwZS5zbGljZSgwLC0yKSxkPXNpemVGcm9tU2hhcGUoYyksaD1zaXplRnJvbVNoYXBlKHApO2Fzc2VydChvLnJhbms+PTImJmEucmFuaz49MiYmby5yYW5rPT09YS5yYW5rLFwiRXJyb3IgaW4gbWF0TXVsOiBpbnB1dHMgbXVzdCBoYXZlIHRoZSBzYW1lIHJhbmsgb2YgYXQgbGVhc3QgMiwgZ290IHJhbmtzIFwiK28ucmFuaytcIiBhbmQgXCIrYS5yYW5rK1wiLlwiKSxhc3NlcnQoYXJyYXlzRXF1YWwoYyxwKSxcIkVycm9yIGluIG1hdE11bDogb3V0ZXIgZGltZW5zaW9ucyAoXCIrYytcIikgYW5kIChcIitwK1wiKSBvZiBUZW5zb3JzIHdpdGggc2hhcGVzIFwiK28uc2hhcGUrXCIgYW5kIFwiK2Euc2hhcGUrXCIgbXVzdCBtYXRjaC5cIiksYXNzZXJ0KGk9PT1zLFwiRXJyb3IgaW4gbWF0TXVsOiBpbm5lciBzaGFwZXMgKFwiK2krXCIpIGFuZCAoXCIrcytcIikgb2YgVGVuc29ycyB3aXRoIHNoYXBlcyBcIitvLnNoYXBlK1wiIGFuZCBcIithLnNoYXBlK1wiIGFuZCB0cmFuc3Bvc2VBPVwiK3IrXCIgYW5kIHRyYW5zcG9zZUI9XCIrbitcIiBtdXN0IG1hdGNoLlwiKTt2YXIgZj1vLnNoYXBlLnNsaWNlKDAsLTIpLmNvbmNhdChbdSxsXSksbT1yP28uYXMzRChkLGksdSk6by5hczNEKGQsdSxpKSxnPW4/YS5hczNEKGgsbCxzKTphLmFzM0QoaCxzLGwpO3JldHVybiBFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbihlKXtyZXR1cm4gZS5iYXRjaE1hdE11bChtLGcscixuKX0seyRhOm0sJGI6Z30sZnVuY3Rpb24oZSl7cmV0dXJuIHJ8fG4/IXImJm4/eyRhOmZ1bmN0aW9uKCl7cmV0dXJuIGUubWF0TXVsKGcudG9GbG9hdCgpLCExLCExKX0sJGI6ZnVuY3Rpb24oKXtyZXR1cm4gZS5tYXRNdWwobS50b0Zsb2F0KCksITAsITEpfX06ciYmIW4/eyRhOmZ1bmN0aW9uKCl7cmV0dXJuIGcudG9GbG9hdCgpLm1hdE11bChlLCExLCEwKX0sJGI6ZnVuY3Rpb24oKXtyZXR1cm4gbS50b0Zsb2F0KCkubWF0TXVsKGUsITEsITEpfX06eyRhOmZ1bmN0aW9uKCl7cmV0dXJuIGcudG9GbG9hdCgpLm1hdE11bChlLCEwLCEwKX0sJGI6ZnVuY3Rpb24oKXtyZXR1cm4gZS5tYXRNdWwobS50b0Zsb2F0KCksITAsITApfX06eyRhOmZ1bmN0aW9uKCl7cmV0dXJuIGUubWF0TXVsKGcudG9GbG9hdCgpLCExLCEwKX0sJGI6ZnVuY3Rpb24oKXtyZXR1cm4gbS50b0Zsb2F0KCkubWF0TXVsKGUsITAsITEpfX19KS5yZXNoYXBlKGYpfWZ1bmN0aW9uIG91dGVyUHJvZHVjdF8oZSx0KXt2YXIgcj1jb252ZXJ0VG9UZW5zb3IoZSxcInYxXCIsXCJvdXRlclByb2R1Y3RcIiksbj1jb252ZXJ0VG9UZW5zb3IodCxcInYyXCIsXCJvdXRlclByb2R1Y3RcIik7cmV0dXJuIGFzc2VydCgxPT09ci5yYW5rJiYxPT09bi5yYW5rLFwiRXJyb3IgaW4gb3V0ZXJQcm9kdWN0OiBpbnB1dHMgbXVzdCBiZSByYW5rIDEsIGJ1dCBnb3QgcmFua3MgXCIrci5yYW5rK1wiIGFuZCBcIituLnJhbmsrXCIuXCIpLHIuYXMyRCgtMSwxKS5tYXRNdWwobi5hczJEKDEsLTEpKX1mdW5jdGlvbiBkb3RfKGUsdCl7dmFyIHI9Y29udmVydFRvVGVuc29yKGUsXCJ0MVwiLFwiZG90XCIpLG49Y29udmVydFRvVGVuc29yKHQsXCJ0MlwiLFwiZG90XCIpO2Fzc2VydCghKDEhPT1yLnJhbmsmJjIhPT1yLnJhbmt8fDEhPT1uLnJhbmsmJjIhPT1uLnJhbmspLFwiRXJyb3IgaW4gZG90OiBpbnB1dHMgbXVzdCBhbGwgYmUgcmFuayAxIG9yIDIsIGJ1dCBnb3QgcmFua3MgXCIrci5yYW5rK1wiIGFuZCBcIituLnJhbmsrXCIuXCIpO3ZhciBvPTE9PT1yLnJhbms/ci5zaXplOnIuc2hhcGVbMV0sYT0xPT09bi5yYW5rP24uc2l6ZTpuLnNoYXBlWzBdO3JldHVybiBhc3NlcnQobz09PWEsXCJFcnJvciBpbiBkb3Q6IGlubmVyIGRpbWVuc2lvbnMgb2YgaW5wdXRzIG11c3QgbWF0Y2gsIGJ1dCBnb3QgXCIrbytcIiBhbmQgXCIrYStcIi5cIiksMT09PXIucmFuayYmMT09PW4ucmFuaz9yLmFzMkQoMSwtMSkubWF0TXVsKG4uYXMyRCgtMSwxKSkuYXNTY2FsYXIoKToxPT09ci5yYW5rJiYyPT09bi5yYW5rP3IuYXMyRCgxLC0xKS5tYXRNdWwobi5hczJEKG4uc2hhcGVbMF0sbi5zaGFwZVsxXSkpLmFzMUQoKToyPT09ci5yYW5rJiYxPT09bi5yYW5rP3IubWF0TXVsKG4uYXMyRCgtMSwxKSkuYXMxRCgpOnIubWF0TXVsKG4uYXMyRChuLnNoYXBlWzBdLG4uc2hhcGVbMV0pKX12YXIgbWF0TXVsPW9wKHttYXRNdWxfOm1hdE11bF99KSxkb3Q9b3Aoe2RvdF86ZG90X30pLG91dGVyUHJvZHVjdD1vcCh7b3V0ZXJQcm9kdWN0XzpvdXRlclByb2R1Y3RffSk7ZnVuY3Rpb24gY29udjFkXyhlLHQscixuLG8sYSxpKXt2b2lkIDA9PT1vJiYobz1cIk5XQ1wiKSx2b2lkIDA9PT1hJiYoYT0xKTt2YXIgcz1jb252ZXJ0VG9UZW5zb3IoZSxcInhcIixcImNvbnYxZFwiKSx1PWNvbnZlcnRUb1RlbnNvcih0LFwiZmlsdGVyXCIsXCJjb252MWRcIiksbD1zLGM9ITE7Mj09PXMucmFuayYmKGM9ITAsbD1zLmFzM0QoMSxzLnNoYXBlWzBdLHMuc2hhcGVbMV0pKSxhc3NlcnQoMz09PWwucmFuayxcIkVycm9yIGluIGNvbnYxZDogaW5wdXQgbXVzdCBiZSByYW5rIDMsIGJ1dCBnb3QgcmFuayBcIitsLnJhbmsrXCIuXCIpLGFzc2VydCgzPT09dS5yYW5rLFwiRXJyb3IgaW4gY29udjFkOiBmaWx0ZXIgbXVzdCBiZSByYW5rIDMsIGJ1dCBnb3QgcmFuayBcIit1LnJhbmsrXCIuXCIpLG51bGwhPWkmJmFzc2VydChpc0ludChuKSxcIkVycm9yIGluIGNvbnYxZDogcGFkIG11c3QgYmUgYW4gaW50ZWdlciB3aGVuIHVzaW5nLCBkaW1Sb3VuZGluZ01vZGUgXCIraStcIiBidXQgZ290IHBhZCBcIituK1wiLlwiKSxhc3NlcnQobC5zaGFwZVsyXT09PXUuc2hhcGVbMV0sXCJFcnJvciBpbiBjb252MWQ6IGRlcHRoIG9mIGlucHV0IChcIitsLnNoYXBlWzJdK1wiKSBtdXN0IG1hdGNoIGlucHV0IGRlcHRoIGZvciBmaWx0ZXIgXCIrdS5zaGFwZVsxXStcIi5cIiksYXNzZXJ0KGVpdGhlclN0cmlkZXNPckRpbGF0aW9uc0FyZU9uZShyLGEpLFwiRXJyb3IgaW4gY29udjFEOiBFaXRoZXIgc3RyaWRlIG9yIGRpbGF0aW9uIG11c3QgYmUgMS4gR290IHN0cmlkZSBcIityK1wiIGFuZCBkaWxhdGlvbiAnXCIrYStcIidcIiksYXNzZXJ0KFwiTldDXCI9PT1vLFwiRXJyb3IgaW4gY29udjFkOiBnb3QgZGF0YUZvcm1hdCBvZiBcIitvK1wiIGJ1dCBvbmx5IE5XQyBpcyBjdXJyZW50bHkgc3VwcG9ydGVkLlwiKTt2YXIgcD11LmFzNEQoMSx1LnNoYXBlWzBdLHUuc2hhcGVbMV0sdS5zaGFwZVsyXSksZD1sLmFzNEQobC5zaGFwZVswXSwxLGwuc2hhcGVbMV0sbC5zaGFwZVsyXSksaD1jb252MmQoZCxwLFsxLHJdLG4sXCJOSFdDXCIsWzEsYV0saSk7cmV0dXJuIGM/aC5hczJEKGguc2hhcGVbMl0saC5zaGFwZVszXSk6aC5hczNEKGguc2hhcGVbMF0saC5zaGFwZVsyXSxoLnNoYXBlWzNdKX1mdW5jdGlvbiBjb252MmRfKGUsdCxyLG4sbyxhLGkpe3ZvaWQgMD09PW8mJihvPVwiTkhXQ1wiKSx2b2lkIDA9PT1hJiYoYT1bMSwxXSk7dmFyIHM9Y29udmVydFRvVGVuc29yKGUsXCJ4XCIsXCJjb252MmRcIiksdT1jb252ZXJ0VG9UZW5zb3IodCxcImZpbHRlclwiLFwiY29udjJkXCIpLGw9cyxjPSExOzM9PT1zLnJhbmsmJihjPSEwLGw9cy5hczREKDEscy5zaGFwZVswXSxzLnNoYXBlWzFdLHMuc2hhcGVbMl0pKSxhc3NlcnQoND09PWwucmFuayxcIkVycm9yIGluIGNvbnYyZDogaW5wdXQgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgcmFuayBcIitsLnJhbmsrXCIuXCIpLGFzc2VydCg0PT09dS5yYW5rLFwiRXJyb3IgaW4gY29udjJkOiBmaWx0ZXIgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgcmFuayBcIit1LnJhbmsrXCIuXCIpLG51bGwhPWkmJmFzc2VydChpc0ludChuKSxcIkVycm9yIGluIGNvbnYyZDogcGFkIG11c3QgYmUgYW4gaW50ZWdlciB3aGVuIHVzaW5nLCBkaW1Sb3VuZGluZ01vZGUgXCIraStcIiBidXQgZ290IHBhZCBcIituK1wiLlwiKSxhc3NlcnQobC5zaGFwZVszXT09PXUuc2hhcGVbMl0sXCJFcnJvciBpbiBjb252MmQ6IGRlcHRoIG9mIGlucHV0IChcIitsLnNoYXBlWzNdK1wiKSBtdXN0IG1hdGNoIGlucHV0IGRlcHRoIGZvciBmaWx0ZXIgXCIrdS5zaGFwZVsyXStcIi5cIiksYXNzZXJ0KGVpdGhlclN0cmlkZXNPckRpbGF0aW9uc0FyZU9uZShyLGEpLFwiRXJyb3IgaW4gY29udjJEOiBFaXRoZXIgc3RyaWRlcyBvciBkaWxhdGlvbnMgbXVzdCBiZSAxLiBHb3Qgc3RyaWRlcyBcIityK1wiIGFuZCBkaWxhdGlvbnMgJ1wiK2ErXCInXCIpLGFzc2VydChcIk5IV0NcIj09PW8sXCJFcnJvciBpbiBjb252MmQ6IGdvdCBkYXRhRm9ybWF0IG9mIFwiK28rXCIgYnV0IG9ubHkgTkhXQyBpcyBjdXJyZW50bHkgc3VwcG9ydGVkLlwiKTt2YXIgcCxkPWNvbXB1dGVDb252MkRJbmZvKGwuc2hhcGUsdS5zaGFwZSxyLGEsbixpKTtpZigxIT09ZC5maWx0ZXJIZWlnaHR8fDEhPT1kLmZpbHRlcldpZHRofHwxIT09ZC5kaWxhdGlvbkhlaWdodHx8MSE9PWQuZGlsYXRpb25XaWR0aHx8MSE9PWQuc3RyaWRlSGVpZ2h0fHwxIT09ZC5zdHJpZGVXaWR0aHx8XCJTQU1FXCIhPT1kLnBhZEluZm8udHlwZSYmXCJWQUxJRFwiIT09ZC5wYWRJbmZvLnR5cGUpe3A9RU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24oZSl7cmV0dXJuIGUuY29udjJkKGwsdSxkKX0se3g6bCwkZmlsdGVyOnV9LGZ1bmN0aW9uKGUpe3JldHVybiBhc3NlcnQodHVwbGVWYWx1ZXNBcmVPbmUoYSksXCJFcnJvciBpbiBncmFkaWVudCBvZiBjb252MkQ6IGRpbGF0aW9uIHJhdGVzIGdyZWF0ZXIgdGhhbiAxIGFyZSBub3R5ZXQgc3VwcG9ydGVkIGluIGdyYWRpZW50cy4gR290IGRpbGF0aW9ucyAnXCIrYStcIidcIikse3g6ZnVuY3Rpb24oKXtyZXR1cm4gY29udjJkRGVySW5wdXRfKGwuc2hhcGUsZSx1LHIsbil9LCRmaWx0ZXI6ZnVuY3Rpb24oKXtyZXR1cm4gY29udjJkRGVyRmlsdGVyXyhsLGUsdS5zaGFwZSxyLG4pfX19KX1lbHNle3ZhciBoPWwucmVzaGFwZShbLTEsZC5pbkNoYW5uZWxzXSksZj11LnJlc2hhcGUoW2QuaW5DaGFubmVscyxkLm91dENoYW5uZWxzXSk7cD1tYXRNdWwoaCxmKS5yZXNoYXBlKGQub3V0U2hhcGUpfXJldHVybiBjP3AuYXMzRChwLnNoYXBlWzFdLHAuc2hhcGVbMl0scC5zaGFwZVszXSk6cH1mdW5jdGlvbiBjb252MmREZXJJbnB1dF8oZSx0LHIsbixvLGEpe2Fzc2VydChlLmxlbmd0aD09PXQucmFuayxcIkxlbmd0aCBvZiBpblNoYXBlIChcIitlLmxlbmd0aCtcIikgYW5kIHJhbmsgb2YgZHkgKFwiK3QucmFuaytcIikgbXVzdCBtYXRjaFwiKTt2YXIgaT1lLHM9dCx1PSExOzM9PT10LnJhbmsmJih1PSEwLHM9dC5hczREKDEsdC5zaGFwZVswXSx0LnNoYXBlWzFdLHQuc2hhcGVbMl0pLGk9WzEsZVswXSxlWzFdLGVbMl1dKTt2YXIgbD1pWzNdLGM9cy5zaGFwZVszXTthc3NlcnQoND09PWkubGVuZ3RoLFwiRXJyb3IgaW4gY29udjJkRGVySW5wdXQ6IGluU2hhcGUgbXVzdCBiZSBsZW5ndGggNCwgYnV0IGdvdCBsZW5ndGggXCIraS5sZW5ndGgrXCIuXCIpLGFzc2VydCg0PT09cy5yYW5rLFwiRXJyb3IgaW4gY29udjJkRGVySW5wdXQ6IGR5IG11c3QgYmUgcmFuayA0LCBidXQgZ290IHJhbmsgXCIrcy5yYW5rKSxhc3NlcnQoND09PXIucmFuayxcIkVycm9yIGluIGNvbnYyZERlcklucHV0OiBmaWx0ZXIgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgcmFuayBcIityLnJhbmspLGFzc2VydChsPT09ci5zaGFwZVsyXSxcIkVycm9yIGluIGNvbnYyZERlcklucHV0OiBkZXB0aCBvZiBpbnB1dCAoXCIrbCtcIikgbXVzdCBtYXRjaCBpbnB1dCBkZXB0aCBmb3IgZmlsdGVyIFwiK3Iuc2hhcGVbMl0rXCIuXCIpLGFzc2VydChjPT09ci5zaGFwZVszXSxcIkVycm9yIGluIGNvbnYyZERlcklucHV0OiBkZXB0aCBvZiBvdXRwdXQgKFwiK2MrXCIpIG11c3QgbWF0Y2ggb3V0cHV0IGRlcHRoIGZvciBmaWx0ZXIgXCIrci5zaGFwZVszXStcIi5cIiksbnVsbCE9YSYmYXNzZXJ0KGlzSW50KG8pLFwiRXJyb3IgaW4gY29udjJkRGVySW5wdXQ6IHBhZCBtdXN0IGJlIGFuIGludGVnZXIgd2hlbiB1c2luZywgZGltUm91bmRpbmdNb2RlIFwiK2ErXCIgYnV0IGdvdCBwYWQgXCIrbytcIi5cIik7dmFyIHA9Y29tcHV0ZUNvbnYyREluZm8oaSxyLnNoYXBlLG4sMSxvLGEpLGQ9RU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24oZSl7cmV0dXJuIGUuY29udjJkRGVySW5wdXQocyxyLHApfSx7ZHk0RDpzLGZpbHRlcjpyfSxmdW5jdGlvbihlKXtyZXR1cm57ZHk0RDpmdW5jdGlvbigpe3JldHVybiBjb252MmQoZSxyLG4sbyxcIk5IV0NcIiwxLGEpfSxmaWx0ZXI6ZnVuY3Rpb24oKXtyZXR1cm4gY29udjJkRGVyRmlsdGVyKGUscyxyLnNoYXBlLG4sbyxhKX19fSk7cmV0dXJuIHU/ZC5hczNEKGQuc2hhcGVbMV0sZC5zaGFwZVsyXSxkLnNoYXBlWzNdKTpkfWZ1bmN0aW9uIGNvbnYyZERlckZpbHRlcl8oZSx0LHIsbixvLGEpe3ZhciBpPWU7Mz09PWUucmFuayYmKGk9ZS5hczREKDEsZS5zaGFwZVswXSxlLnNoYXBlWzFdLGUuc2hhcGVbMl0pKTt2YXIgcz10OzM9PT1zLnJhbmsmJihzPXQuYXM0RCgxLHQuc2hhcGVbMF0sdC5zaGFwZVsxXSx0LnNoYXBlWzJdKSksYXNzZXJ0KDQ9PT1pLnJhbmssXCJFcnJvciBpbiBjb252MmREZXJGaWx0ZXI6IGlucHV0IG11c3QgYmUgcmFuayA0LCBidXQgZ290IHNoYXBlIFwiK2kuc2hhcGUrXCIuXCIpLGFzc2VydCg0PT09cy5yYW5rLFwiRXJyb3IgaW4gY29udjJkRGVyRmlsdGVyOiBkeSBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCBzaGFwZSBcIitzLnNoYXBlK1wiLlwiKSxhc3NlcnQoND09PXIubGVuZ3RoLFwiRXJyb3IgaW4gY29udjJkRGVyRmlsdGVyOiBmaWx0ZXJTaGFwZSBtdXN0IGJlIGxlbmd0aCA0LCBidXQgZ290IFwiK3IrXCIuXCIpLGFzc2VydChpLnNoYXBlWzNdPT09clsyXSxcIkVycm9yIGluIGNvbnYyZERlckZpbHRlcjogZGVwdGggb2YgaW5wdXQgXCIraS5zaGFwZVszXStcIikgbXVzdCBtYXRjaCBpbnB1dCBkZXB0aCBpbiBmaWx0ZXIgKFwiK3JbMl0rXCIuXCIpLGFzc2VydChzLnNoYXBlWzNdPT09clszXSxcIkVycm9yIGluIGNvbnYyZERlckZpbHRlcjogZGVwdGggb2YgZHkgKFwiK3Muc2hhcGVbM10rXCIpIG11c3QgbWF0Y2ggb3V0cHV0IGRlcHRoIGZvciBmaWx0ZXIgKFwiK3JbM10rXCIpLlwiKSxudWxsIT1hJiZhc3NlcnQoaXNJbnQobyksXCJFcnJvciBpbiBjb252MmREZXJGaWx0ZXI6IHBhZCBtdXN0IGJlIGFuIGludGVnZXIgd2hlbiB1c2luZywgZGltUm91bmRpbmdNb2RlIFwiK2ErXCIgYnV0IGdvdCBwYWQgXCIrbytcIi5cIik7dmFyIHU9Y29tcHV0ZUNvbnYyREluZm8oaS5zaGFwZSxyLG4sMSxvLGEpO3JldHVybiBFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbihlKXtyZXR1cm4gZS5jb252MmREZXJGaWx0ZXIoaSxzLHUpfSx7eDREOmksZHk0RDpzfSl9ZnVuY3Rpb24gY29udjJkVHJhbnNwb3NlXyhlLHQscixuLG8sYSl7cmV0dXJuIGNvbnYyZERlcklucHV0XyhyLGNvbnZlcnRUb1RlbnNvcihlLFwieFwiLFwiY29udjJkVHJhbnNwb3NlXCIpLGNvbnZlcnRUb1RlbnNvcih0LFwiZmlsdGVyXCIsXCJjb252MmRUcmFuc3Bvc2VcIiksbixvLGEpfWZ1bmN0aW9uIGRlcHRod2lzZUNvbnYyZF8oZSx0LHIsbixvLGEsaSl7dm9pZCAwPT09byYmKG89XCJOSFdDXCIpLHZvaWQgMD09PWEmJihhPVsxLDFdKTt2YXIgcz1jb252ZXJ0VG9UZW5zb3IoZSxcInhcIixcImRlcHRod2lzZUNvbnYyZFwiKSx1PWNvbnZlcnRUb1RlbnNvcih0LFwiZmlsdGVyXCIsXCJkZXB0aHdpc2VDb252MmRcIiksbD1zLGM9ITE7Mz09PXMucmFuayYmKGM9ITAsbD1zLmFzNEQoMSxzLnNoYXBlWzBdLHMuc2hhcGVbMV0scy5zaGFwZVsyXSkpLGFzc2VydCg0PT09bC5yYW5rLFwiRXJyb3IgaW4gZGVwdGh3aXNlQ29udjJkOiBpbnB1dCBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCByYW5rIFwiK2wucmFuaytcIi5cIiksYXNzZXJ0KDQ9PT11LnJhbmssXCJFcnJvciBpbiBkZXB0aHdpc2VDb252MmQ6IGZpbHRlciBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCByYW5rIFwiK3UucmFuaytcIi5cIiksYXNzZXJ0KGwuc2hhcGVbM109PT11LnNoYXBlWzJdLFwiRXJyb3IgaW4gZGVwdGh3aXNlQ29udjJkOiBudW1iZXIgb2YgaW5wdXQgY2hhbm5lbHMgKFwiK2wuc2hhcGVbM10rXCIpIG11c3QgbWF0Y2ggdGhlIGluQ2hhbm5lbHMgZGltZW5zaW9uIGluIGZpbHRlciBcIit1LnNoYXBlWzJdK1wiLlwiKSxudWxsPT1hJiYoYT1bMSwxXSksYXNzZXJ0KGVpdGhlclN0cmlkZXNPckRpbGF0aW9uc0FyZU9uZShyLGEpLFwiRXJyb3IgaW4gZGVwdGh3aXNlQ29udjJkOiBFaXRoZXIgc3RyaWRlcyBvciBkaWxhdGlvbnMgbXVzdCBiZSAxLiBHb3Qgc3RyaWRlcyBcIityK1wiIGFuZCBkaWxhdGlvbnMgJ1wiK2ErXCInXCIpLG51bGwhPWkmJmFzc2VydChpc0ludChuKSxcIkVycm9yIGluIGRlcHRod2lzZUNvbnYyZDogcGFkIG11c3QgYmUgYW4gaW50ZWdlciB3aGVuIHVzaW5nLCBkaW1Sb3VuZGluZ01vZGUgXCIraStcIiBidXQgZ290IHBhZCBcIituK1wiLlwiKTt2YXIgcD1jb21wdXRlQ29udjJESW5mbyhsLnNoYXBlLHUuc2hhcGUscixhLG4saSwhMCksZD1FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbihlKXtyZXR1cm4gZS5kZXB0aHdpc2VDb252MkQobCx1LHApfSx7eDpsLCRmaWx0ZXI6dX0sZnVuY3Rpb24oZSl7cmV0dXJuIGFzc2VydCh0dXBsZVZhbHVlc0FyZU9uZShhKSxcIkVycm9yIGluIGdyYWRpZW50IG9mIGRlcHRod2lzZUNvbnYyZDogZGlsYXRpb24gcmF0ZXMgZ3JlYXRlciB0aGFuIDEgYXJlIG5vdCB5ZXQgc3VwcG9ydGVkLiBHb3QgZGlsYXRpb25zICdcIithK1wiJ1wiKSx7eDpmdW5jdGlvbigpe3JldHVybiBkZXB0aHdpc2VDb252MmREZXJJbnB1dChsLnNoYXBlLGUsdSxwKX0sJGZpbHRlcjpmdW5jdGlvbigpe3JldHVybiBkZXB0aHdpc2VDb252MmREZXJGaWx0ZXIobCxlLHUuc2hhcGUscCl9fX0pO3JldHVybiBjP2QuYXMzRChkLnNoYXBlWzFdLGQuc2hhcGVbMl0sZC5zaGFwZVszXSk6ZH1mdW5jdGlvbiBzZXBhcmFibGVDb252MmRfKGUsdCxyLG4sbyxhLGkpe3ZvaWQgMD09PWEmJihhPVsxLDFdKSx2b2lkIDA9PT1pJiYoaT1cIk5IV0NcIik7dmFyIHM9Y29udmVydFRvVGVuc29yKGUsXCJ4XCIsXCJzZXBhcmFibGVDb252MmRcIiksdT1jb252ZXJ0VG9UZW5zb3IodCxcImRlcHRod2lzZUZpbHRlclwiLFwic2VwYXJhYmxlQ29udjJkXCIpLGw9Y29udmVydFRvVGVuc29yKHIsXCJwb2ludHdpc2VGaWx0ZXJcIixcInNlcGFyYWJsZUNvbnYyZFwiKSxjPXMscD0hMTtpZigzPT09cy5yYW5rJiYocD0hMCxjPXMuYXM0RCgxLHMuc2hhcGVbMF0scy5zaGFwZVsxXSxzLnNoYXBlWzJdKSksXCJOQ0hXXCI9PT1pKXRocm93IG5ldyBFcnJvcihcInNlcGFyYWJsZUNvbnYyZCBjdXJyZW50bHkgZG9lcyBub3Qgc3VwcG9ydCBkYXRhRm9ybWF0IE5DSFc7IG9ubHkgTkhXQyBpcyBzdXBwb3J0ZWRcIik7YXNzZXJ0KDQ9PT1jLnJhbmssXCJFcnJvciBpbiBzZXBhcmFibGVDb252MmQ6IGlucHV0IG11c3QgYmUgcmFuayA0LCBidXQgZ290IHJhbmsgXCIrYy5yYW5rK1wiLlwiKSxhc3NlcnQoND09PXUucmFuayxcIkVycm9yIGluIHNlcGFyYWJsZUNvbnYyZDogZGVwdGh3aXNlIGZpbHRlciBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCByYW5rIFwiK3UucmFuaytcIi5cIiksYXNzZXJ0KDQ9PT1sLnJhbmssXCJFcnJvciBpbiBzZXBhcmFibGVDb252MmQ6IHBvaW50d2lzZSBmaWx0ZXIgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgcmFuayBcIit1LnJhbmsrXCIuXCIpLGFzc2VydCgxPT09bC5zaGFwZVswXSxcIkVycm9yIGluIHNlcGFyYWJsZUNvbnYyZDogdGhlIGZpcnN0IGRpbWVuc2lvbiBvZiBwb2ludHdpc2UgZmlsdGVyICBtdXN0IGJlIDEsIGJ1dCBnb3QgXCIrbC5zaGFwZVswXStcIi5cIiksYXNzZXJ0KDE9PT1sLnNoYXBlWzFdLFwiRXJyb3IgaW4gc2VwYXJhYmxlQ29udjJkOiB0aGUgc2Vjb25kIGRpbWVuc2lvbiBvZiBwb2ludHdpc2UgZmlsdGVyICBtdXN0IGJlIDEsIGJ1dCBnb3QgXCIrbC5zaGFwZVsxXStcIi5cIik7dmFyIGQ9dS5zaGFwZVsyXSxoPXUuc2hhcGVbM107YXNzZXJ0KGwuc2hhcGVbMl09PT1kKmgsXCJFcnJvciBpbiBzZXBhcmFibGVDb252MmQ6IHRoZSB0aGlyZCBkaW1lbnNpb24gb2YgcG9pbnR3aXNlIGZpbHRlciBtdXN0IGJlIFwiK2QqaCtcIiwgYnV0IGdvdCBcIitsLnNoYXBlWzJdK1wiLlwiKTt2YXIgZj1kZXB0aHdpc2VDb252MmQoYyx1LG4sbyxpLGEpLG09Y29udjJkKGYsbCwxLFwidmFsaWRcIixpKTtyZXR1cm4gcD9tLmFzM0QobS5zaGFwZVsxXSxtLnNoYXBlWzJdLG0uc2hhcGVbM10pOm19ZnVuY3Rpb24gZGVwdGh3aXNlQ29udjJkRGVySW5wdXQoZSx0LHIsbil7dmFyIG89dCxhPSExOzM9PT10LnJhbmsmJihhPSEwLG89dC5hczREKDEsdC5zaGFwZVswXSx0LnNoYXBlWzFdLHQuc2hhcGVbMl0pKTt2YXIgaT1FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbihlKXtyZXR1cm4gZS5kZXB0aHdpc2VDb252MkREZXJJbnB1dChvLHIsbil9LHtkeTREOm99KTtyZXR1cm4gYT9pLmFzM0QoaS5zaGFwZVsxXSxpLnNoYXBlWzJdLGkuc2hhcGVbM10pOml9ZnVuY3Rpb24gZGVwdGh3aXNlQ29udjJkRGVyRmlsdGVyKGUsdCxyLG4pe3ZhciBvPWU7Mz09PWUucmFuayYmKG89ZS5hczREKDEsZS5zaGFwZVswXSxlLnNoYXBlWzFdLGUuc2hhcGVbMl0pKTt2YXIgYT10O3JldHVybiAzPT09YS5yYW5rJiYoYT10LmFzNEQoMSx0LnNoYXBlWzBdLHQuc2hhcGVbMV0sdC5zaGFwZVsyXSkpLEVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKGUpe3JldHVybiBlLmRlcHRod2lzZUNvbnYyRERlckZpbHRlcihvLGEsbil9LHt4NEQ6byxkeTREOmF9KX12YXIgY29udjFkPW9wKHtjb252MWRfOmNvbnYxZF99KSxjb252MmQ9b3Aoe2NvbnYyZF86Y29udjJkX30pLGNvbnYyZERlckZpbHRlcj1vcCh7Y29udjJkRGVyRmlsdGVyXzpjb252MmREZXJGaWx0ZXJffSksZGVwdGh3aXNlQ29udjJkPW9wKHtkZXB0aHdpc2VDb252MmRfOmRlcHRod2lzZUNvbnYyZF99KSxzZXBhcmFibGVDb252MmQ9b3Aoe3NlcGFyYWJsZUNvbnYyZF86c2VwYXJhYmxlQ29udjJkX30pLGNvbnYyZFRyYW5zcG9zZT1vcCh7Y29udjJkVHJhbnNwb3NlXzpjb252MmRUcmFuc3Bvc2VffSk7ZnVuY3Rpb24gcmV2ZXJzZTFkXyhlKXt2YXIgdD1jb252ZXJ0VG9UZW5zb3IoZSxcInhcIixcInJldmVyc2VcIik7cmV0dXJuIGFzc2VydCgxPT09dC5yYW5rLFwiRXJyb3IgaW4gcmV2ZXJzZTFEOiB4IG11c3QgYmUgcmFuayAxIGJ1dCBnb3RcXG4gICAgICAgICAgICAgcmFuayBcIit0LnJhbmsrXCIuXCIpLHJldmVyc2UodCwwKX1mdW5jdGlvbiByZXZlcnNlMmRfKGUsdCl7dmFyIHI9Y29udmVydFRvVGVuc29yKGUsXCJ4XCIsXCJyZXZlcnNlXCIpO3JldHVybiBhc3NlcnQoMj09PXIucmFuayxcIkVycm9yIGluIHJldmVyc2UyRDogeCBtdXN0IGJlIHJhbmsgMiBidXQgZ290XFxuICAgICAgICAgICAgIHJhbmsgXCIrci5yYW5rK1wiLlwiKSxyZXZlcnNlKHIsdCl9ZnVuY3Rpb24gcmV2ZXJzZTNkXyhlLHQpe3ZhciByPWNvbnZlcnRUb1RlbnNvcihlLFwieFwiLFwicmV2ZXJzZVwiKTtyZXR1cm4gYXNzZXJ0KDM9PT1yLnJhbmssXCJFcnJvciBpbiByZXZlcnNlM0Q6IHggbXVzdCBiZSByYW5rIDMgYnV0IGdvdFxcbiAgICAgICAgICAgICByYW5rIFwiK3IucmFuaytcIi5cIikscmV2ZXJzZShyLHQpfWZ1bmN0aW9uIHJldmVyc2U0ZF8oZSx0KXt2YXIgcj1jb252ZXJ0VG9UZW5zb3IoZSxcInhcIixcInJldmVyc2VcIik7cmV0dXJuIGFzc2VydCg0PT09ci5yYW5rLFwiRXJyb3IgaW4gcmV2ZXJzZTREOiB4IG11c3QgYmUgcmFuayA0IGJ1dCBnb3RcXG4gICAgICAgICAgICAgcmFuayBcIityLnJhbmsrXCIuXCIpLHJldmVyc2Uocix0KX1mdW5jdGlvbiByZXZlcnNlXyhlLHQpe3ZhciByPWNvbnZlcnRUb1RlbnNvcihlLFwieFwiLFwicmV2ZXJzZVwiKTtpZigwPT09ci5yYW5rKXJldHVybiByLmNsb25lKCk7dmFyIG49cGFyc2VBeGlzUGFyYW0odCxyLnNoYXBlKTtyZXR1cm4gRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24oZSl7cmV0dXJuIGUucmV2ZXJzZShyLG4pfSx7JHg6cn0sZnVuY3Rpb24oZSl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIGUucmV2ZXJzZShuKX19fSkucmVzaGFwZUFzKHIpfXZhciByZXZlcnNlPW9wKHtyZXZlcnNlXzpyZXZlcnNlX30pLHJldmVyc2UxZD1vcCh7cmV2ZXJzZTFkXzpyZXZlcnNlMWRffSkscmV2ZXJzZTJkPW9wKHtyZXZlcnNlMmRfOnJldmVyc2UyZF99KSxyZXZlcnNlM2Q9b3Aoe3JldmVyc2UzZF86cmV2ZXJzZTNkX30pLHJldmVyc2U0ZD1vcCh7cmV2ZXJzZTRkXzpyZXZlcnNlNGRffSk7ZnVuY3Rpb24gbWF4UG9vbEltcGxfKGUsdCxyLG4sbyxhKXt2YXIgaT1jb252ZXJ0VG9UZW5zb3IoZSxcInhcIixcIm1heFBvb2xcIikscz1pLHU9ITE7Mz09PWkucmFuayYmKHU9ITAscz1pLmFzNEQoMSxpLnNoYXBlWzBdLGkuc2hhcGVbMV0saS5zaGFwZVsyXSkpLG51bGw9PW4mJihuPVsxLDFdKSxhc3NlcnQoND09PXMucmFuayxcIkVycm9yIGluIG1heFBvb2w6IGlucHV0IG11c3QgYmUgcmFuayA0IGJ1dCBnb3QgcmFuayBcIitzLnJhbmsrXCIuXCIpLGFzc2VydChlaXRoZXJTdHJpZGVzT3JEaWxhdGlvbnNBcmVPbmUocixuKSxcIkVycm9yIGluIG1heFBvb2w6IEVpdGhlciBzdHJpZGVzIG9yIGRpbGF0aW9ucyBtdXN0IGJlIDEuIEdvdCBzdHJpZGVzIFwiK3IrXCIgYW5kIGRpbGF0aW9ucyAnXCIrbitcIidcIiksbnVsbCE9YSYmYXNzZXJ0KGlzSW50KG8pLFwiRXJyb3IgaW4gbWF4UG9vbDogcGFkIG11c3QgYmUgYW4gaW50ZWdlciB3aGVuIHVzaW5nLCBkaW1Sb3VuZGluZ01vZGUgXCIrYStcIiBidXQgZ290IHBhZCBcIitvK1wiLlwiKTt2YXIgbD1jb21wdXRlUG9vbDJESW5mbyhzLnNoYXBlLHQscixuLG8sYSksYz1FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbihlLHQpe3JldHVybiB0KGUubWF4UG9vbChzLGwpKX0se3g6c30sZnVuY3Rpb24oZSxhKXt2YXIgaT1hWzBdO3JldHVybnt4OmZ1bmN0aW9uKCl7cmV0dXJuIG1heFBvb2xCYWNrcHJvcChlLHMsaSx0LHIsbixvKX19fSk7cmV0dXJuIHU/Yy5hczNEKGMuc2hhcGVbMV0sYy5zaGFwZVsyXSxjLnNoYXBlWzNdKTpjfWZ1bmN0aW9uIG1heFBvb2xfKGUsdCxyLG4sbyl7cmV0dXJuIG1heFBvb2xJbXBsXyhlLHQsciwxLG4sbyl9ZnVuY3Rpb24gYXZnUG9vbEltcGxfKGUsdCxyLG4sbyxhKXt2YXIgaT1jb252ZXJ0VG9UZW5zb3IoZSxcInhcIixcImF2Z1Bvb2xcIik7YXNzZXJ0KFwiZmxvYXQzMlwiPT09aS5kdHlwZSxcIlRoZSBpbnB1dCBkdHlwZSB0byBhdmdQb29sIG11c3QgYmUgZmxvYXQzMlwiKSxudWxsPT1uJiYobj1bMSwxXSksYXNzZXJ0KGVpdGhlclN0cmlkZXNPckRpbGF0aW9uc0FyZU9uZShyLG4pLFwiRXJyb3IgaW4gYXZnUG9vbDogRWl0aGVyIHN0cmlkZXMgb3IgZGlsYXRpb25zIG11c3QgYmUgMS4gR290IHN0cmlkZXMgXCIrcitcIiBhbmQgZGlsYXRpb25zICdcIituK1wiJ1wiKTt2YXIgcz1pLHU9ITE7Mz09PWkucmFuayYmKHU9ITAscz1pLmFzNEQoMSxpLnNoYXBlWzBdLGkuc2hhcGVbMV0saS5zaGFwZVsyXSkpLGFzc2VydCg0PT09cy5yYW5rLFwiRXJyb3IgaW4gYXZnUG9vbDogeCBtdXN0IGJlIHJhbmsgNCBidXQgZ290IHJhbmsgXCIrcy5yYW5rK1wiLlwiKSxudWxsIT1hJiZhc3NlcnQoaXNJbnQobyksXCJFcnJvciBpbiBhdmdQb29sOiBwYWQgbXVzdCBiZSBhbiBpbnRlZ2VyIHdoZW4gdXNpbmcsIGRpbVJvdW5kaW5nTW9kZSBcIithK1wiIGJ1dCBnb3QgcGFkIFwiK28rXCIuXCIpO3ZhciBsPWNvbXB1dGVQb29sMkRJbmZvKHMuc2hhcGUsdCxyLG4sbyksYz1FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbihlKXtyZXR1cm4gZS5hdmdQb29sKHMsbCl9LHt4OnN9LGZ1bmN0aW9uKGUpe3JldHVybnt4OmZ1bmN0aW9uKCl7cmV0dXJuIGF2Z1Bvb2xCYWNrcHJvcChlLHMsdCxyLG4sbyl9fX0pO3JldHVybiBjPWMuY2FzdChpLmR0eXBlKSx1P2MuYXMzRChjLnNoYXBlWzFdLGMuc2hhcGVbMl0sYy5zaGFwZVszXSk6Y31mdW5jdGlvbiBhdmdQb29sXyhlLHQscixuLG8pe3JldHVybiBhdmdQb29sSW1wbF8oZSx0LHIsMSxuLG8pfWZ1bmN0aW9uIHBvb2xfKGUsdCxyLG4sbyxhKXtudWxsPT1vJiYobz1bMSwxXSksbnVsbD09YSYmKGE9MSksMD09PW4mJihuPVwidmFsaWRcIik7dmFyIGk9Y29udmVydFRvVGVuc29yKGUsXCJ4XCIsXCJtYXhQb29sXCIpLHM9aSx1PSExOzM9PT1pLnJhbmsmJih1PSEwLHM9aS5hczREKDEsaS5zaGFwZVswXSxpLnNoYXBlWzFdLGkuc2hhcGVbMl0pKSxhc3NlcnQoZWl0aGVyU3RyaWRlc09yRGlsYXRpb25zQXJlT25lKGEsbyksXCJFcnJvciBpbiBwb29sOiBFaXRoZXIgc3RyaWRlcyBvciBkaWxhdGlvbnMgbXVzdCBiZSAxLiBHb3Qgc3RyaWRlcyBcIithK1wiIGFuZCBkaWxhdGlvbnMgJ1wiK28rXCInXCIpO3ZhciBsLGM9Y29tcHV0ZVBvb2wyREluZm8ocy5zaGFwZSx0LGEsbyxuKSxwPVtjLmRpbGF0aW9uSGVpZ2h0LGMuZGlsYXRpb25XaWR0aF07bD1cInNhbWVcIj09PW4/d2l0aFNwYWNlVG9CYXRjaEJhc2VQYWRkaW5ncyhbYy5maWx0ZXJIZWlnaHQsYy5maWx0ZXJXaWR0aF0scCk6W1swLDBdLFswLDBdXTt2YXIgZD0xPT09cFswXSYmMT09PXBbMV0saD1yZXF1aXJlZFNwYWNlVG9CYXRjaFBhZGRpbmdzKFtjLmluSGVpZ2h0LGMuaW5XaWR0aF0scCxsKSxmPWhbMF0sbT1oWzFdLGc9ZD9uOlwidmFsaWRcIix2PWQ/czpzcGFjZVRvQmF0Y2hORChzLHAsZikseT0oXCJhdmdcIj09PXI/ZnVuY3Rpb24oKXtyZXR1cm4gYXZnUG9vbEltcGxfKHYsdCxhLDEsZyl9OmZ1bmN0aW9uKCl7cmV0dXJuIG1heFBvb2xJbXBsXyh2LHQsYSwxLGcpfSkoKSx4PWQ/eTpiYXRjaFRvU3BhY2VORCh5LHAsbSk7cmV0dXJuIHU/eC5hczNEKHguc2hhcGVbMV0seC5zaGFwZVsyXSx4LnNoYXBlWzNdKTp4fWZ1bmN0aW9uIG1heFBvb2xCYWNrcHJvcChlLHQscixuLG8sYSxpLHMpe3ZhciB1PWNvbnZlcnRUb1RlbnNvcihlLFwiZHlcIixcIm1heFBvb2xCYWNrcHJvcFwiKSxsPWNvbnZlcnRUb1RlbnNvcih0LFwiaW5wdXRcIixcIm1heFBvb2xCYWNrcHJvcFwiKSxjPWNvbnZlcnRUb1RlbnNvcihyLFwib3V0cHV0XCIsXCJtYXhQb29sQmFja3Byb3BcIik7YXNzZXJ0KGwucmFuaz09PXUucmFuayxcIlJhbmsgb2YgaW5wdXQgKFwiK2wucmFuaytcIikgZG9lcyBub3QgbWF0Y2ggcmFuayBvZiBkeSAoXCIrdS5yYW5rK1wiKVwiKSxudWxsPT1hJiYoYT1bMSwxXSksYXNzZXJ0KGVpdGhlclN0cmlkZXNPckRpbGF0aW9uc0FyZU9uZShvLGEpLFwiRXJyb3IgaW4gbWF4UG9vbEJhY2tQcm9wOiBFaXRoZXIgc3RyaWRlcyBvciBkaWxhdGlvbnMgbXVzdCBiZSAxLiBHb3Qgc3RyaWRlcyBcIitvK1wiIGFuZCBkaWxhdGlvbnMgJ1wiK2ErXCInXCIpLGFzc2VydCg0PT09dS5yYW5rLFwiRXJyb3IgaW4gbWF4UG9vbEJhY2twcm9wOiBkeSBtdXN0IGJlIHJhbmsgNCBidXQgZ290IHJhbmsgXCIrdS5yYW5rK1wiLlwiKSxhc3NlcnQoND09PWwucmFuayxcIkVycm9yIGluIG1heFBvb2xCYWNrcHJvcDogaW5wdXQgbXVzdCBiZSByYW5rIDQgYnV0IGdvdCByYW5rIFwiK2wucmFuaytcIi5cIiksbnVsbCE9cyYmYXNzZXJ0KGlzSW50KGkpLFwiRXJyb3IgaW4gbWF4UG9vbEJhY2twcm9wOiBwYWQgbXVzdCBiZSBhbiBpbnRlZ2VyIHdoZW4gdXNpbmcsIGRpbVJvdW5kaW5nTW9kZSBcIitzK1wiIGJ1dCBnb3QgcGFkIFwiK2krXCIuXCIpO3ZhciBwPWNvbXB1dGVQb29sMkRJbmZvKGwuc2hhcGUsbixvLGEsaSxzKTtyZXR1cm4gRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24oZSl7cmV0dXJuIGUubWF4UG9vbEJhY2twcm9wKHUsbCxjLHApfSx7JGR5OnUsJGlucHV0Omx9KX1mdW5jdGlvbiBhdmdQb29sQmFja3Byb3AoZSx0LHIsbixvLGEpe3ZhciBpPWNvbnZlcnRUb1RlbnNvcihlLFwiZHlcIixcImF2Z1Bvb2xCYWNrcHJvcFwiKSxzPWNvbnZlcnRUb1RlbnNvcih0LFwiaW5wdXRcIixcImF2Z1Bvb2xCYWNrcHJvcFwiKTthc3NlcnQocy5yYW5rPT09aS5yYW5rLFwiUmFuayBvZiBpbnB1dCAoXCIrcy5yYW5rK1wiKSBkb2VzIG5vdCBtYXRjaCByYW5rIG9mIGR5IChcIitpLnJhbmsrXCIpXCIpLG51bGw9PW8mJihvPVsxLDFdKSxhc3NlcnQoZWl0aGVyU3RyaWRlc09yRGlsYXRpb25zQXJlT25lKG4sbyksXCJFcnJvciBpbiBhdmdQb29sQmFja3Byb3A6IEVpdGhlciBzdHJpZGVzIG9yIGRpbGF0aW9ucyBtdXN0IGJlIDEuIEdvdCBzdHJpZGVzIFwiK24rXCIgYW5kIGRpbGF0aW9ucyAnXCIrbytcIidcIik7dmFyIHU9cyxsPWksYz0hMTszPT09cy5yYW5rJiYoYz0hMCx1PXMuYXM0RCgxLHMuc2hhcGVbMF0scy5zaGFwZVsxXSxzLnNoYXBlWzJdKSxsPWkuYXM0RCgxLGkuc2hhcGVbMF0saS5zaGFwZVsxXSxpLnNoYXBlWzJdKSksYXNzZXJ0KDQ9PT1sLnJhbmssXCJFcnJvciBpbiBhdmdQb29sQmFja3Byb3A6IGR5IG11c3QgYmUgcmFuayA0IGJ1dCBnb3QgcmFuayBcIitsLnJhbmsrXCIuXCIpLGFzc2VydCg0PT09dS5yYW5rLFwiRXJyb3IgaW4gYXZnUG9vbEJhY2twcm9wOiBpbnB1dCBtdXN0IGJlIHJhbmsgNCBidXQgZ290IHJhbmsgXCIrdS5yYW5rK1wiLlwiKTt2YXIgcD1jb21wdXRlUG9vbDJESW5mbyh1LnNoYXBlLHIsbixvLGEpLGQ9RU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24oZSl7cmV0dXJuIGUuYXZnUG9vbEJhY2twcm9wKGwsdSxwKX0se2R5NEQ6bCxpbnB1dDREOnV9KTtyZXR1cm4gYz9kLmFzM0QoZC5zaGFwZVsxXSxkLnNoYXBlWzJdLGQuc2hhcGVbM10pOmR9ZnVuY3Rpb24gcmVxdWlyZWRTcGFjZVRvQmF0Y2hQYWRkaW5ncyhlLHQscil7dmFyIG49ci5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGVbMF19KSxvPXIubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlWzFdfSksYT1lLmNvbmNhdChuLG8pLGk9dC5tYXAoZnVuY3Rpb24oZSx0KXtyZXR1cm4oZS1hW3RdJWUpJWV9KSxzPW8ubWFwKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUraVt0XX0pO3JldHVyblt0Lm1hcChmdW5jdGlvbihlLHQpe3JldHVybltuW3RdLHNbdF1dfSksdC5tYXAoZnVuY3Rpb24oZSx0KXtyZXR1cm5bMCxpW3RdXX0pXX1mdW5jdGlvbiB3aXRoU3BhY2VUb0JhdGNoQmFzZVBhZGRpbmdzKGUsdCl7dmFyIHI9ZS5tYXAoZnVuY3Rpb24oZSxyKXtyZXR1cm4gZSsoZS0xKSoodFtyXS0xKX0pLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS0xfSksbj1yLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gTWF0aC5mbG9vcihlLzIpfSksbz1yLm1hcChmdW5jdGlvbihlLHQpe3JldHVybiBlLW5bdF19KTtyZXR1cm4gci5tYXAoZnVuY3Rpb24oZSx0KXtyZXR1cm5bblt0XSxvW3RdXX0pfXZhciBtYXhQb29sPW9wKHttYXhQb29sXzptYXhQb29sX30pLGF2Z1Bvb2w9b3Aoe2F2Z1Bvb2xfOmF2Z1Bvb2xffSkscG9vbD1vcCh7cG9vbF86cG9vbF99KTtmdW5jdGlvbiBzbGljZTFkXyhlLHQscil7dmFyIG49Y29udmVydFRvVGVuc29yKGUsXCJ4XCIsXCJzbGljZTFkXCIpO3JldHVybiBhc3NlcnQoMT09PW4ucmFuayxcInNsaWNlMWQgZXhwZWN0cyBhIHJhbmstMSB0ZW5zb3IsIGJ1dCBnb3QgYSByYW5rLVwiK24ucmFuaytcIiB0ZW5zb3JcIiksc2xpY2UobixbdF0sW3JdKX1mdW5jdGlvbiBzbGljZTJkXyhlLHQscil7dmFyIG49Y29udmVydFRvVGVuc29yKGUsXCJ4XCIsXCJzbGljZTJkXCIpO3JldHVybiBhc3NlcnQoMj09PW4ucmFuayxcInNsaWNlMmQgZXhwZWN0cyBhIHJhbmstMiB0ZW5zb3IsIGJ1dCBnb3QgYSByYW5rLVwiK24ucmFuaytcIiB0ZW5zb3JcIiksc2xpY2Uobix0LHIpfWZ1bmN0aW9uIHNsaWNlM2RfKGUsdCxyKXt2YXIgbj1jb252ZXJ0VG9UZW5zb3IoZSxcInhcIixcInNsaWNlM2RcIik7cmV0dXJuIGFzc2VydCgzPT09bi5yYW5rLFwic2xpY2UzZCBleHBlY3RzIGEgcmFuay0zIHRlbnNvciwgYnV0IGdvdCBhIHJhbmstXCIrbi5yYW5rK1wiIHRlbnNvclwiKSxzbGljZShuLHQscil9ZnVuY3Rpb24gc2xpY2U0ZF8oZSx0LHIpe3ZhciBuPWNvbnZlcnRUb1RlbnNvcihlLFwieFwiLFwic2xpY2U0ZFwiKTtyZXR1cm4gYXNzZXJ0KDQ9PT1uLnJhbmssXCJzbGljZTRkIGV4cGVjdHMgYSByYW5rLTQgdGVuc29yLCBidXQgZ290IGEgcmFuay1cIituLnJhbmsrXCIgdGVuc29yXCIpLHNsaWNlKG4sdCxyKX1mdW5jdGlvbiBzbGljZV8oZSx0LHIpe3ZhciBuLG8sYT1jb252ZXJ0VG9UZW5zb3IoZSxcInhcIixcInNsaWNlXCIpO2lmKDA9PT1hLnJhbmspdGhyb3cgbmV3IEVycm9yKFwiU2xpY2luZyBzY2FsYXIgaXMgbm90IHBvc3NpYmxlXCIpO249XCJudW1iZXJcIj09dHlwZW9mIHQ/W3RdLmNvbmNhdChuZXcgQXJyYXkoYS5yYW5rLTEpLmZpbGwoMCkpOnQubGVuZ3RoPGEucmFuaz90LmNvbmNhdChuZXcgQXJyYXkoYS5yYW5rLXQubGVuZ3RoKS5maWxsKDApKTp0LnNsaWNlKCksbz0obz1udWxsPT1yP25ldyBBcnJheShhLnJhbmspLmZpbGwoLTEpOlwibnVtYmVyXCI9PXR5cGVvZiByP1tyXS5jb25jYXQobmV3IEFycmF5KGEucmFuay0xKS5maWxsKC0xKSk6ci5sZW5ndGg8YS5yYW5rP3IuY29uY2F0KG5ldyBBcnJheShhLnJhbmstci5sZW5ndGgpLmZpbGwoLTEpKTpyKS5tYXAoZnVuY3Rpb24oZSx0KXtyZXR1cm4gZT49MD9lOihhc3NlcnQoLTE9PT1lLFwiQmFkIHZhbHVlIGluIHNpemVcIiksYS5zaGFwZVt0XS1uW3RdKX0pLGFzc2VydFBhcmFtc1ZhbGlkKGEsbixvKTt2YXIgaT1hLnNoYXBlO3JldHVybiBFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbihlKXtyZXR1cm4gZS5zbGljZShhLG4sbyl9LHskeDphfSxmdW5jdGlvbihlKXtmb3IodmFyIHQ9W10scj0wO3I8ZS5yYW5rO3IrKyl0LnB1c2goW25bcl0saVtyXS1uW3JdLW9bcl1dKTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gZS5wYWQodCl9fX0pfXZhciBzbGljZT1vcCh7c2xpY2VfOnNsaWNlX30pLHNsaWNlMWQ9b3Aoe3NsaWNlMWRfOnNsaWNlMWRffSksc2xpY2UyZD1vcCh7c2xpY2UyZF86c2xpY2UyZF99KSxzbGljZTNkPW9wKHtzbGljZTNkXzpzbGljZTNkX30pLHNsaWNlNGQ9b3Aoe3NsaWNlNGRfOnNsaWNlNGRffSk7ZnVuY3Rpb24gbG9nU3VtRXhwXyhlLHQscil7dm9pZCAwPT09dCYmKHQ9bnVsbCksdm9pZCAwPT09ciYmKHI9ITEpO3ZhciBuPWNvbnZlcnRUb1RlbnNvcihlLFwieFwiLFwibG9nU3VtRXhwXCIpLG89cGFyc2VBeGlzUGFyYW0odCxuLnNoYXBlKSxhPW4ubWF4KG8sITApLGk9bi5zdWIoYSkuZXhwKCkuc3VtKG8pLmxvZygpLHM9YS5yZXNoYXBlKGkuc2hhcGUpLmFkZChpKTtpZihyKXt2YXIgdT1leHBhbmRTaGFwZVRvS2VlcERpbShzLnNoYXBlLG8pO3JldHVybiBzLnJlc2hhcGUodSl9cmV0dXJuIHN9ZnVuY3Rpb24gc3VtXyhlLHQscil7dm9pZCAwPT09dCYmKHQ9bnVsbCksdm9pZCAwPT09ciYmKHI9ITEpO3ZhciBuPWNvbnZlcnRUb1RlbnNvcihlLFwieFwiLFwic3VtXCIpO1wiYm9vbFwiPT09bi5kdHlwZSYmKG49bi50b0ludCgpKTt2YXIgbz1wYXJzZUF4aXNQYXJhbSh0LG4uc2hhcGUpO3JldHVybiBjdXN0b21HcmFkKGZ1bmN0aW9uKGUpe3ZhciB0PWdldEF4ZXNQZXJtdXRhdGlvbihvLGUucmFuayksbj1vLGE9ZTtudWxsIT10JiYoYT1lLnRyYW5zcG9zZSh0KSxuPWdldElubmVyTW9zdEF4ZXMobi5sZW5ndGgsZS5yYW5rKSk7dmFyIGk9RU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24oZSl7cmV0dXJuIGUuc3VtKGEsbil9LHtwZXJtdXRlZFg6YX0pO2lmKHIpe3ZhciBzPWV4cGFuZFNoYXBlVG9LZWVwRGltKGkuc2hhcGUsbyk7aT1pLnJlc2hhcGUocyl9cmV0dXJue3ZhbHVlOmksZ3JhZEZ1bmM6ZnVuY3Rpb24odCl7dmFyIHI9ZS5zaGFwZS5zbGljZSgpO3JldHVybiBvLmZvckVhY2goZnVuY3Rpb24oZSl7cltlXT0xfSksdC5yZXNoYXBlKHIpLm11bChvbmVzJDEoZS5zaGFwZSxcImZsb2F0MzJcIikpfX19KShuKX1mdW5jdGlvbiBwcm9kXyhlLHQscil7dm9pZCAwPT09dCYmKHQ9bnVsbCksdm9pZCAwPT09ciYmKHI9ITEpO3ZhciBuPWNvbnZlcnRUb1RlbnNvcihlLFwieFwiLFwicHJvZFwiKTtcImJvb2xcIj09PW4uZHR5cGUmJihuPW4udG9JbnQoKSk7dmFyIG89cGFyc2VBeGlzUGFyYW0odCxuLnNoYXBlKSxhPWdldEF4ZXNQZXJtdXRhdGlvbihvLG4ucmFuayksaT1vLHM9bjtudWxsIT1hJiYocz1uLnRyYW5zcG9zZShhKSxpPWdldElubmVyTW9zdEF4ZXMoaS5sZW5ndGgsbi5yYW5rKSk7dmFyIHU9RU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24oZSl7cmV0dXJuIGUucHJvZChzLGkpfSx7cGVybXV0ZWRYOnN9KTtpZihyKXt2YXIgbD1leHBhbmRTaGFwZVRvS2VlcERpbSh1LnNoYXBlLG8pO3U9dS5yZXNoYXBlKGwpfXJldHVybiB1fWZ1bmN0aW9uIG1lYW5fKGUsdCxyKXt2b2lkIDA9PT10JiYodD1udWxsKSx2b2lkIDA9PT1yJiYocj0hMSk7dmFyIG49Y29udmVydFRvVGVuc29yKGUsXCJ4XCIsXCJtZWFuXCIpLG89cGFyc2VBeGlzUGFyYW0odCxuLnNoYXBlKSxhPXNpemVGcm9tU2hhcGUoY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyhuLnNoYXBlLG8pWzFdKTtyZXR1cm4gY3VzdG9tR3JhZChmdW5jdGlvbihlKXt2YXIgbj1zY2FsYXIoYSk7cmV0dXJue3ZhbHVlOihuLmR0eXBlPT09ZS5kdHlwZT9lOmUuY2FzdChuLmR0eXBlKSkuZGl2KG4pLnN1bSh0LHIpLGdyYWRGdW5jOmZ1bmN0aW9uKHQpe3ZhciByPWUuc2hhcGUuc2xpY2UoKTtyZXR1cm4gby5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JbZV09MX0pLHQucmVzaGFwZShyKS5tdWwob25lcyQxKGUuc2hhcGUsXCJmbG9hdDMyXCIpKS5kaXYobil9fX0pKG4pfWZ1bmN0aW9uIGdyYWRGb3JNaW5BbmRNYXgoZSx0LHIsbixvKXt2YXIgYT10WzBdO3JldHVybiBhLnJhbms8ci5yYW5rJiYoYT1hLnJlc2hhcGUoZXhwYW5kU2hhcGVUb0tlZXBEaW0oYS5zaGFwZSxuKSkpLGUucmFuazxyLnJhbmsmJihlPWUucmVzaGFwZShleHBhbmRTaGFwZVRvS2VlcERpbShlLnNoYXBlLG4pKSkseyR4OmZ1bmN0aW9uKCl7dmFyIHQ9ZS5tdWwoci5lcXVhbChhKS5jYXN0KGUuZHR5cGUpKTtyZXR1cm4gbnVsbD09bz90OnQudHJhbnNwb3NlKG8pfX19ZnVuY3Rpb24gbWluXyhlLHQscil7dm9pZCAwPT09dCYmKHQ9bnVsbCksdm9pZCAwPT09ciYmKHI9ITEpO3ZhciBuPWNvbnZlcnRUb1RlbnNvcihlLFwieFwiLFwibWluXCIpLG89bixhPXBhcnNlQXhpc1BhcmFtKHQsbi5zaGFwZSksaT1hLHM9Z2V0QXhlc1Blcm11dGF0aW9uKGksbi5yYW5rKTtudWxsIT1zJiYobj1uLnRyYW5zcG9zZShzKSxpPWdldElubmVyTW9zdEF4ZXMoaS5sZW5ndGgsbi5yYW5rKSk7dmFyIHU9RU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24oZSx0KXtyZXR1cm4gdChlLm1pbihuLGkpKX0seyR4Om59LGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGdyYWRGb3JNaW5BbmRNYXgoZSx0LG8sYSxzKX0pO2lmKHIpe3ZhciBsPWV4cGFuZFNoYXBlVG9LZWVwRGltKHUuc2hhcGUsYSk7dT11LnJlc2hhcGUobCl9cmV0dXJuIHV9ZnVuY3Rpb24gbWF4XyhlLHQscil7dm9pZCAwPT09dCYmKHQ9bnVsbCksdm9pZCAwPT09ciYmKHI9ITEpO3ZhciBuPWNvbnZlcnRUb1RlbnNvcihlLFwieFwiLFwibWF4XCIpLG89bixhPXBhcnNlQXhpc1BhcmFtKHQsbi5zaGFwZSksaT1hLHM9Z2V0QXhlc1Blcm11dGF0aW9uKGksbi5yYW5rKTtudWxsIT1zJiYobj1uLnRyYW5zcG9zZShzKSxpPWdldElubmVyTW9zdEF4ZXMoaS5sZW5ndGgsbi5yYW5rKSk7dmFyIHU9RU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24oZSx0KXtyZXR1cm4gdChlLm1heChuLGkpKX0seyR4Om59LGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGdyYWRGb3JNaW5BbmRNYXgoZSx0LG8sYSxzKX0pO2lmKHIpe3ZhciBsPWV4cGFuZFNoYXBlVG9LZWVwRGltKHUuc2hhcGUsYSk7dT11LnJlc2hhcGUobCl9cmV0dXJuIHV9ZnVuY3Rpb24gYXJnTWluXyhlLHQpe3ZvaWQgMD09PXQmJih0PTApO3ZhciByPWNvbnZlcnRUb1RlbnNvcihlLFwieFwiLFwiYXJnTWluXCIpO251bGw9PXQmJih0PTApO3ZhciBuPXBhcnNlQXhpc1BhcmFtKHQsci5zaGFwZSksbz1nZXRBeGVzUGVybXV0YXRpb24obixyLnJhbmspO251bGwhPW8mJihyPXIudHJhbnNwb3NlKG8pLG49Z2V0SW5uZXJNb3N0QXhlcyhuLmxlbmd0aCxyLnJhbmspKTtyZXR1cm4gRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24oZSl7cmV0dXJuIGUuYXJnTWluKHIsblswXSl9LHskeDpyfSxmdW5jdGlvbihlKXtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gemVyb3NMaWtlKHIpfX19KX1mdW5jdGlvbiBhcmdNYXhfKGUsdCl7dm9pZCAwPT09dCYmKHQ9MCk7dmFyIHI9Y29udmVydFRvVGVuc29yKGUsXCJ4XCIsXCJhcmdNYXhcIik7bnVsbD09dCYmKHQ9MCk7dmFyIG49cGFyc2VBeGlzUGFyYW0odCxyLnNoYXBlKSxvPWdldEF4ZXNQZXJtdXRhdGlvbihuLHIucmFuayk7bnVsbCE9byYmKHI9ci50cmFuc3Bvc2Uobyksbj1nZXRJbm5lck1vc3RBeGVzKG4ubGVuZ3RoLHIucmFuaykpO3JldHVybiBFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbihlKXtyZXR1cm4gZS5hcmdNYXgocixuWzBdKX0seyR4OnJ9LGZ1bmN0aW9uKGUpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB6ZXJvc0xpa2Uocil9fX0pfWZ1bmN0aW9uIGFsbF8oZSx0LHIpe3ZvaWQgMD09PXQmJih0PW51bGwpLHZvaWQgMD09PXImJihyPSExKTt2YXIgbj1jb252ZXJ0VG9UZW5zb3IoZSxcInhcIixcImFsbFwiLFwiYm9vbFwiKTthc3NlcnQoXCJib29sXCI9PT1uLmR0eXBlLFwiRXJyb3IgVGVuc29yIG11c3QgYmUgb2YgdHlwZSBib29sLiBHb3Q6IFwiK24uZHR5cGUpO3ZhciBvPXBhcnNlQXhpc1BhcmFtKHQsbi5zaGFwZSksYT1vLGk9Z2V0QXhlc1Blcm11dGF0aW9uKGEsbi5yYW5rKTtudWxsIT1pJiYobj1uLnRyYW5zcG9zZShpKSxhPWdldElubmVyTW9zdEF4ZXMoYS5sZW5ndGgsbi5yYW5rKSk7dmFyIHM9RU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24oZSl7cmV0dXJuIGUuYWxsKG4sYSl9LHskeDpufSk7aWYocil7dmFyIHU9ZXhwYW5kU2hhcGVUb0tlZXBEaW0ocy5zaGFwZSxvKTtyZXR1cm4gcy5yZXNoYXBlKHUpfXJldHVybiBzfWZ1bmN0aW9uIGFueV8oZSx0LHIpe3ZvaWQgMD09PXQmJih0PW51bGwpLHZvaWQgMD09PXImJihyPSExKTt2YXIgbj1jb252ZXJ0VG9UZW5zb3IoZSxcInhcIixcImFueVwiLFwiYm9vbFwiKTthc3NlcnQoXCJib29sXCI9PT1uLmR0eXBlLFwiRXJyb3IgVGVuc29yIG11c3QgYmUgb2YgdHlwZSBib29sLiBHb3Q6IFwiK24uZHR5cGUpO3ZhciBvPXBhcnNlQXhpc1BhcmFtKHQsbi5zaGFwZSksYT1vLGk9Z2V0QXhlc1Blcm11dGF0aW9uKGEsbi5yYW5rKTtudWxsIT1pJiYobj1uLnRyYW5zcG9zZShpKSxhPWdldElubmVyTW9zdEF4ZXMoYS5sZW5ndGgsbi5yYW5rKSk7dmFyIHM9RU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24oZSl7cmV0dXJuIGUuYW55KG4sYSl9LHskeDpufSk7aWYocil7dmFyIHU9ZXhwYW5kU2hhcGVUb0tlZXBEaW0ocy5zaGFwZSxvKTtyZXR1cm4gcy5yZXNoYXBlKHUpfXJldHVybiBzfWZ1bmN0aW9uIG1vbWVudHNfKGUsdCxyKXt2b2lkIDA9PT10JiYodD1udWxsKSx2b2lkIDA9PT1yJiYocj0hMSk7dmFyIG49cGFyc2VBeGlzUGFyYW0odCwoZT1jb252ZXJ0VG9UZW5zb3IoZSxcInhcIixcIm1vbWVudHNcIikpLnNoYXBlKSxvPWUubWVhbihuLHIpLGE9by5zaGFwZTtyZXR1cm4gcnx8KGE9ZXhwYW5kU2hhcGVUb0tlZXBEaW0oby5zaGFwZSxuKSkse21lYW46byx2YXJpYW5jZTplLnRvRmxvYXQoKS5zdWIoby5yZXNoYXBlKGEpKS5zcXVhcmUoKS5tZWFuKG4scil9fXZhciBhbGw9b3Aoe2FsbF86YWxsX30pLGFueT1vcCh7YW55XzphbnlffSksYXJnTWF4PW9wKHthcmdNYXhfOmFyZ01heF99KSxhcmdNaW49b3Aoe2FyZ01pbl86YXJnTWluX30pLGxvZ1N1bUV4cD1vcCh7bG9nU3VtRXhwXzpsb2dTdW1FeHBffSksbWF4PW9wKHttYXhfOm1heF99KSxtZWFuPW9wKHttZWFuXzptZWFuX30pLG1pbj1vcCh7bWluXzptaW5ffSksbW9tZW50cz1vcCh7bW9tZW50c186bW9tZW50c199KSxzdW0kMT1vcCh7c3VtXzpzdW1ffSkscHJvZD1vcCh7cHJvZF86cHJvZF99KTtmdW5jdGlvbiBub3RFcXVhbF8oZSx0KXt2YXIgcj1jb252ZXJ0VG9UZW5zb3IoZSxcImFcIixcIm5vdEVxdWFsXCIpLG49Y29udmVydFRvVGVuc29yKHQsXCJiXCIsXCJub3RFcXVhbFwiKTtyZXR1cm4gYXNzZXJ0VHlwZXNNYXRjaChyLG4pLGFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKHIuc2hhcGUsbi5zaGFwZSksRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24oZSl7cmV0dXJuIGUubm90RXF1YWwocixuKX0seyRhOnIsJGI6bn0pfWZ1bmN0aW9uIG5vdEVxdWFsU3RyaWN0XyhlLHQpe3ZhciByPWNvbnZlcnRUb1RlbnNvcihlLFwiYVwiLFwibm90RXF1YWxTdHJpY3RcIiksbj1jb252ZXJ0VG9UZW5zb3IodCxcImJcIixcIm5vdEVxdWFsU3RyaWN0XCIpO3JldHVybiBhc3NlcnRTaGFwZXNNYXRjaChyLnNoYXBlLG4uc2hhcGUsXCJFcnJvciBpbiBub3RFcXVhbFN0cmljdDogXCIpLHIubm90RXF1YWwobil9ZnVuY3Rpb24gbGVzc18oZSx0KXt2YXIgcj1jb252ZXJ0VG9UZW5zb3IoZSxcImFcIixcImxlc3NcIiksbj1jb252ZXJ0VG9UZW5zb3IodCxcImJcIixcImxlc3NcIik7cmV0dXJuIGFzc2VydFR5cGVzTWF0Y2gocixuKSxhc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShyLnNoYXBlLG4uc2hhcGUpLEVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKGUpe3JldHVybiBlLmxlc3MocixuKX0seyRhOnIsJGI6bn0pfWZ1bmN0aW9uIGxlc3NTdHJpY3RfKGUsdCl7dmFyIHI9Y29udmVydFRvVGVuc29yKGUsXCJhXCIsXCJsZXNzU3RyaWN0XCIpLG49Y29udmVydFRvVGVuc29yKHQsXCJiXCIsXCJsZXNzU3RyaWN0XCIpO3JldHVybiBhc3NlcnRTaGFwZXNNYXRjaChyLnNoYXBlLG4uc2hhcGUsXCJFcnJvciBpbiBsZXNzU3RyaWN0OiBcIiksci5sZXNzKG4pfWZ1bmN0aW9uIGVxdWFsXyhlLHQpe3ZhciByPWNvbnZlcnRUb1RlbnNvcihlLFwiYVwiLFwiZXF1YWxcIiksbj1jb252ZXJ0VG9UZW5zb3IodCxcImJcIixcImVxdWFsXCIpO3JldHVybiBhc3NlcnRUeXBlc01hdGNoKHIsbiksYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoci5zaGFwZSxuLnNoYXBlKSxFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbihlKXtyZXR1cm4gZS5lcXVhbChyLG4pfSx7JGE6ciwkYjpufSl9ZnVuY3Rpb24gZXF1YWxTdHJpY3RfKGUsdCl7dmFyIHI9Y29udmVydFRvVGVuc29yKGUsXCJhXCIsXCJlcXVhbFN0cmljdFwiKSxuPWNvbnZlcnRUb1RlbnNvcih0LFwiYlwiLFwiZXF1YWxTdHJpY3RcIik7cmV0dXJuIGFzc2VydFNoYXBlc01hdGNoKHIuc2hhcGUsbi5zaGFwZSxcIkVycm9yIGluIGVxdWFsU3RyaWN0OiBcIiksci5lcXVhbChuKX1mdW5jdGlvbiBsZXNzRXF1YWxfKGUsdCl7dmFyIHI9Y29udmVydFRvVGVuc29yKGUsXCJhXCIsXCJsZXNzRXF1YWxcIiksbj1jb252ZXJ0VG9UZW5zb3IodCxcImJcIixcImxlc3NFcXVhbFwiKTtyZXR1cm4gYXNzZXJ0VHlwZXNNYXRjaChyLG4pLGFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKHIuc2hhcGUsbi5zaGFwZSksRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24oZSl7cmV0dXJuIGUubGVzc0VxdWFsKHIsbil9LHskYTpyLCRiOm59KX1mdW5jdGlvbiBsZXNzRXF1YWxTdHJpY3RfKGUsdCl7dmFyIHI9Y29udmVydFRvVGVuc29yKGUsXCJhXCIsXCJsZXNzRXF1YWxTdHJpY3RcIiksbj1jb252ZXJ0VG9UZW5zb3IodCxcImJcIixcImxlc3NFcXVhbFN0cmljdFwiKTtyZXR1cm4gYXNzZXJ0U2hhcGVzTWF0Y2goci5zaGFwZSxuLnNoYXBlLFwiRXJyb3IgaW4gbGVzc0VxdWFsU3RyaWN0OiBcIiksci5sZXNzRXF1YWwobil9ZnVuY3Rpb24gZ3JlYXRlcl8oZSx0KXt2YXIgcj1jb252ZXJ0VG9UZW5zb3IoZSxcImFcIixcImdyZWF0ZXJcIiksbj1jb252ZXJ0VG9UZW5zb3IodCxcImJcIixcImdyZWF0ZXJcIik7cmV0dXJuIGFzc2VydFR5cGVzTWF0Y2gocixuKSxhc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShyLnNoYXBlLG4uc2hhcGUpLEVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKGUpe3JldHVybiBlLmdyZWF0ZXIocixuKX0seyRhOnIsJGI6bn0pfWZ1bmN0aW9uIGdyZWF0ZXJTdHJpY3RfKGUsdCl7dmFyIHI9Y29udmVydFRvVGVuc29yKGUsXCJhXCIsXCJncmVhdGVyU3RyaWN0XCIpLG49Y29udmVydFRvVGVuc29yKHQsXCJiXCIsXCJncmVhdGVyU3RyaWN0XCIpO3JldHVybiBhc3NlcnRTaGFwZXNNYXRjaChyLnNoYXBlLG4uc2hhcGUsXCJFcnJvciBpbiBncmVhdGVyU3RyaWN0OiBcIiksci5ncmVhdGVyKG4pfWZ1bmN0aW9uIGdyZWF0ZXJFcXVhbF8oZSx0KXt2YXIgcj1jb252ZXJ0VG9UZW5zb3IoZSxcImFcIixcImdyZWF0ZXJFcXVhbFwiKSxuPWNvbnZlcnRUb1RlbnNvcih0LFwiYlwiLFwiZ3JlYXRlckVxdWFsXCIpO2Fzc2VydFR5cGVzTWF0Y2gocixuKSxhc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShyLnNoYXBlLG4uc2hhcGUpO3JldHVybiBFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbihlKXtyZXR1cm4gZS5ncmVhdGVyRXF1YWwocixuKX0seyRhOnIsJGI6bn0sZnVuY3Rpb24oZSl7cmV0dXJueyRhOmZ1bmN0aW9uKCl7cmV0dXJuIHplcm9zTGlrZShyKX0sJGI6ZnVuY3Rpb24oKXtyZXR1cm4gemVyb3NMaWtlKG4pfX19KX1mdW5jdGlvbiBncmVhdGVyRXF1YWxTdHJpY3RfKGUsdCl7dmFyIHI9Y29udmVydFRvVGVuc29yKGUsXCJhXCIsXCJncmVhdGVyRXF1YWxTdHJpY3RcIiksbj1jb252ZXJ0VG9UZW5zb3IodCxcImJcIixcImdyZWF0ZXJFcXVhbFN0cmljdFwiKTtyZXR1cm4gYXNzZXJ0U2hhcGVzTWF0Y2goci5zaGFwZSxuLnNoYXBlLFwiRXJyb3IgaW4gZ3JlYXRlckVxdWFsU3RyaWN0OiBcIiksci5ncmVhdGVyRXF1YWwobil9dmFyIGVxdWFsPW9wKHtlcXVhbF86ZXF1YWxffSksZXF1YWxTdHJpY3Q9b3Aoe2VxdWFsU3RyaWN0XzplcXVhbFN0cmljdF99KSxncmVhdGVyPW9wKHtncmVhdGVyXzpncmVhdGVyX30pLGdyZWF0ZXJFcXVhbD1vcCh7Z3JlYXRlckVxdWFsXzpncmVhdGVyRXF1YWxffSksZ3JlYXRlckVxdWFsU3RyaWN0PW9wKHtncmVhdGVyRXF1YWxTdHJpY3RfOmdyZWF0ZXJFcXVhbFN0cmljdF99KSxncmVhdGVyU3RyaWN0PW9wKHtncmVhdGVyU3RyaWN0XzpncmVhdGVyU3RyaWN0X30pLGxlc3M9b3Aoe2xlc3NfOmxlc3NffSksbGVzc0VxdWFsPW9wKHtsZXNzRXF1YWxfOmxlc3NFcXVhbF99KSxsZXNzRXF1YWxTdHJpY3Q9b3Aoe2xlc3NFcXVhbFN0cmljdF86bGVzc0VxdWFsU3RyaWN0X30pLGxlc3NTdHJpY3Q9b3Aoe2xlc3NTdHJpY3RfOmxlc3NTdHJpY3RffSksbm90RXF1YWw9b3Aoe25vdEVxdWFsXzpub3RFcXVhbF99KSxub3RFcXVhbFN0cmljdD1vcCh7bm90RXF1YWxTdHJpY3RfOm5vdEVxdWFsU3RyaWN0X30pO2Z1bmN0aW9uIGFkZF8oZSx0KXt2YXIgcj1jb252ZXJ0VG9UZW5zb3IoZSxcImFcIixcImFkZFwiKSxuPWNvbnZlcnRUb1RlbnNvcih0LFwiYlwiLFwiYWRkXCIpO2Fzc2VydFR5cGVzTWF0Y2gocixuKTt2YXIgbz1hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShyLnNoYXBlLG4uc2hhcGUpO3JldHVybiBFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbihlKXtyZXR1cm4gZS5hZGQocixuKX0seyRhOnIsJGI6bn0sZnVuY3Rpb24oZSl7cmV0dXJueyRhOmZ1bmN0aW9uKCl7dmFyIHQ9ZSxuPWdldFJlZHVjdGlvbkF4ZXMoci5zaGFwZSxvKTtyZXR1cm4gbi5sZW5ndGg+MCYmKHQ9dC5zdW0obikpLHQucmVzaGFwZShyLnNoYXBlKX0sJGI6ZnVuY3Rpb24oKXt2YXIgdD1lLHI9Z2V0UmVkdWN0aW9uQXhlcyhuLnNoYXBlLG8pO3JldHVybiByLmxlbmd0aD4wJiYodD10LnN1bShyKSksdC5yZXNoYXBlKG4uc2hhcGUpfX19KX1mdW5jdGlvbiBhZGROXyhlKXthc3NlcnQoQXJyYXkuaXNBcnJheShlKSxmdW5jdGlvbigpe3JldHVyblwiVGhlIGFyZ3VtZW50IHBhc3NlZCB0byB0Zi5hZGROKCkgbXVzdCBiZSBhIGxpc3Qgb2YgdGVuc29yc1wifSksYXNzZXJ0KGUubGVuZ3RoPj0xLGZ1bmN0aW9uKCl7cmV0dXJuXCJNdXN0IHBhc3MgYXQgbGVhc3Qgb25lIHRlbnNvciB0byB0Zi5hZGROKCksIGJ1dCBnb3QgXCIrZS5sZW5ndGh9KTt2YXIgdD1lLm1hcChmdW5jdGlvbihlLHQpe3JldHVybiBjb252ZXJ0VG9UZW5zb3IoZSxcInRlbnNvcnNcIit0LFwiYWRkTlwiKX0pLHI9dFswXTt0LmZvckVhY2goZnVuY3Rpb24oZSl7aWYoZS5kdHlwZSE9PXIuZHR5cGUpdGhyb3cgbmV3IEVycm9yKFwiQWxsIHRlbnNvcnMgcGFzc2VkIHRvIHRmLmFkZE4oKSBtdXN0IGhhdmUgdGhlIHNhbWUgZHR5cGVcIil9KSx0LmZvckVhY2goZnVuY3Rpb24oZSl7aWYoIWFycmF5c0VxdWFsKGUuc2hhcGUsci5zaGFwZSkpdGhyb3cgbmV3IEVycm9yKFwiQWxsIHRlbnNvcnMgcGFzc2VkIHRvIHRmLmFkZE4oKSBtdXN0IGhhdmUgdGhlIHNhbWUgc2hhcGVcIil9KTt2YXIgbj10O3JldHVybiBFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbihlKXtyZXR1cm4gZS5hZGROKHQpfSxuLGZ1bmN0aW9uKGUpe3ZhciByPXt9O3JldHVybiB0LmZvckVhY2goZnVuY3Rpb24odCxuKXtyW25dPWZ1bmN0aW9uKCl7cmV0dXJuIGUuY2xvbmUoKX19KSxyfSl9ZnVuY3Rpb24gYWRkU3RyaWN0XyhlLHQpe3JldHVybiBhc3NlcnRTaGFwZXNNYXRjaChlLnNoYXBlLHQuc2hhcGUsXCJFcnJvciBpbiBhZGRTdHJpY3Q6IFwiKSxlLmFkZCh0KX1mdW5jdGlvbiBzdWJfKGUsdCl7dmFyIHI9Y29udmVydFRvVGVuc29yKGUsXCJhXCIsXCJzdWJcIiksbj1jb252ZXJ0VG9UZW5zb3IodCxcImJcIixcInN1YlwiKTthc3NlcnRUeXBlc01hdGNoKHIsbik7dmFyIG89YXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoci5zaGFwZSxuLnNoYXBlKTtyZXR1cm4gRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24oZSl7cmV0dXJuIGUuc3VidHJhY3QocixuKX0seyRhOnIsJGI6bn0sZnVuY3Rpb24oZSl7cmV0dXJueyRhOmZ1bmN0aW9uKCl7dmFyIHQ9ZSxuPWdldFJlZHVjdGlvbkF4ZXMoci5zaGFwZSxvKTtyZXR1cm4gbi5sZW5ndGg+MCYmKHQ9dC5zdW0obikpLHQucmVzaGFwZShyLnNoYXBlKX0sJGI6ZnVuY3Rpb24oKXt2YXIgdD1lLHI9Z2V0UmVkdWN0aW9uQXhlcyhuLnNoYXBlLG8pO3JldHVybiByLmxlbmd0aD4wJiYodD10LnN1bShyKSksdC5uZWcoKS5yZXNoYXBlKG4uc2hhcGUpfX19KX1mdW5jdGlvbiBzdWJTdHJpY3RfKGUsdCl7cmV0dXJuIGFzc2VydFNoYXBlc01hdGNoKGUuc2hhcGUsdC5zaGFwZSxcIkVycm9yIGluIHN1YlN0cmljdDogXCIpLGUuc3ViKHQpfWZ1bmN0aW9uIHBvd18oZSx0KXt2YXIgcj1jb252ZXJ0VG9UZW5zb3IoZSxcImJhc2VcIixcInBvd1wiKSxuPWNvbnZlcnRUb1RlbnNvcih0LFwiZXhwXCIsXCJwb3dcIiksbz1hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShyLnNoYXBlLG4uc2hhcGUpO2U9ci5jYXN0KHVwY2FzdFR5cGUoci5kdHlwZSxuLmR0eXBlKSksdD1uLmNhc3QodXBjYXN0VHlwZShyLmR0eXBlLG4uZHR5cGUpKTtyZXR1cm4gRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24oZSx0KXtyZXR1cm4gdChlLnBvdyhyLG4pKX0seyRiYXNlOnIsJGV4cDpufSxmdW5jdGlvbihlLHQpe3ZhciBhPXRbMF07cmV0dXJueyRiYXNlOmZ1bmN0aW9uKCl7dmFyIHQ9bi50b0Zsb2F0KCksYT1lLm11bCh0Lm11bChyLnBvdyh0LnN1YihzY2FsYXIoMSkpKSkpLGk9Z2V0UmVkdWN0aW9uQXhlcyhyLnNoYXBlLG8pO3JldHVybiBpLmxlbmd0aD4wJiYoYT1hLnN1bShpKSksYS5yZXNoYXBlKHIuc2hhcGUpfSwkZXhwOmZ1bmN0aW9uKCl7dmFyIHQ9ZS5tdWwoYS5tdWwoci5sb2coKSkudG9GbG9hdCgpKSxpPWdldFJlZHVjdGlvbkF4ZXMobi5zaGFwZSxvKTtyZXR1cm4gaS5sZW5ndGg+MCYmKHQ9dC5zdW0oaSkpLHQucmVzaGFwZShuLnNoYXBlKX19fSl9ZnVuY3Rpb24gcG93U3RyaWN0XyhlLHQpe3JldHVybiBhc3NlcnRTaGFwZXNNYXRjaChlLnNoYXBlLHQuc2hhcGUsXCJFcnJvciBpbiBwb3dTdHJpY3Q6IFwiKSxlLnBvdyh0KX1mdW5jdGlvbiBtdWxfKGUsdCl7dmFyIHI9Y29udmVydFRvVGVuc29yKGUsXCJhXCIsXCJtdWxcIiksbj1jb252ZXJ0VG9UZW5zb3IodCxcImJcIixcIm11bFwiKTthc3NlcnRUeXBlc01hdGNoKHIsbik7dmFyIG89YXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoci5zaGFwZSxuLnNoYXBlKTtyZXR1cm4gRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24oZSl7cmV0dXJuIGUubXVsdGlwbHkocixuKX0seyRhOnIsJGI6bn0sZnVuY3Rpb24oZSl7cmV0dXJueyRhOmZ1bmN0aW9uKCl7dmFyIHQ9ZS5tdWwobi50b0Zsb2F0KCkpLGE9Z2V0UmVkdWN0aW9uQXhlcyhyLnNoYXBlLG8pO3JldHVybiBhLmxlbmd0aD4wP3Quc3VtKGEpLnJlc2hhcGUoci5zaGFwZSk6dH0sJGI6ZnVuY3Rpb24oKXt2YXIgdD1lLm11bChyLnRvRmxvYXQoKSksYT1nZXRSZWR1Y3Rpb25BeGVzKG4uc2hhcGUsbyk7cmV0dXJuIGEubGVuZ3RoPjA/dC5zdW0oYSkucmVzaGFwZShuLnNoYXBlKTp0fX19KX1mdW5jdGlvbiBtdWxTdHJpY3RfKGUsdCl7cmV0dXJuIGFzc2VydFNoYXBlc01hdGNoKGUuc2hhcGUsdC5zaGFwZSxcIkVycm9yIGluIG11bHRpcGx5U3RyaWN0OiBcIiksZS5tdWwodCl9ZnVuY3Rpb24gZGl2XyhlLHQpe3ZhciByLG49Y29udmVydFRvVGVuc29yKGUsXCJhXCIsXCJkaXZcIiksbz1jb252ZXJ0VG9UZW5zb3IodCxcImJcIixcImRpdlwiKTtpZihhc3NlcnRUeXBlc01hdGNoKG4sbyksXCJpbnQzMlwiPT09bi5kdHlwZSYmXCJpbnQzMlwiPT09by5kdHlwZSlyZXR1cm4gZmxvb3JEaXYobixvKTtyPWZ1bmN0aW9uKGUpe3JldHVybiBlLnJlYWxEaXZpZGUobixvKX07dmFyIGE9YXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUobi5zaGFwZSxvLnNoYXBlKTtyZXR1cm4gRU5WLmVuZ2luZS5ydW5LZXJuZWwocix7JGE6biwkYjpvfSxmdW5jdGlvbihlKXtyZXR1cm57JGE6ZnVuY3Rpb24oKXt2YXIgdD1lLmRpdihvLnRvRmxvYXQoKSkscj1nZXRSZWR1Y3Rpb25BeGVzKG4uc2hhcGUsYSk7cmV0dXJuIHIubGVuZ3RoPjA/dC5zdW0ocikucmVzaGFwZShuLnNoYXBlKTp0fSwkYjpmdW5jdGlvbigpe3ZhciB0PWUubXVsKG4udG9GbG9hdCgpKSxyPWdldFJlZHVjdGlvbkF4ZXMoby5zaGFwZSxhKTtyLmxlbmd0aD4wJiYodD10LnN1bShyKS5yZXNoYXBlKG8uc2hhcGUpKTt2YXIgaT1vLnNxdWFyZSgpO3JldHVybiB0LmRpdihpLnRvRmxvYXQoKSkubmVnKCl9fX0pfWZ1bmN0aW9uIGZsb29yRGl2XyhlLHQpe3ZhciByPWNvbnZlcnRUb1RlbnNvcihlLFwiYVwiLFwiZmxvb3JEaXZcIiksbj1jb252ZXJ0VG9UZW5zb3IodCxcImJcIixcImZsb29yRGl2XCIpO2Fzc2VydFR5cGVzTWF0Y2gocixuKTt2YXIgbz1hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShyLnNoYXBlLG4uc2hhcGUpO3JldHVybiBFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbihlKXtyZXR1cm4gZS5mbG9vckRpdihyLG4pfSx7JGE6ciwkYjpufSxmdW5jdGlvbihlKXtyZXR1cm57JGE6ZnVuY3Rpb24oKXt2YXIgdD1lLmRpdihuLnRvRmxvYXQoKSksYT1nZXRSZWR1Y3Rpb25BeGVzKHIuc2hhcGUsbyk7cmV0dXJuIGEubGVuZ3RoPjA/dC5zdW0oYSkucmVzaGFwZShyLnNoYXBlKTp0fSwkYjpmdW5jdGlvbigpe3ZhciB0PWUubXVsKHIudG9GbG9hdCgpKSxhPWdldFJlZHVjdGlvbkF4ZXMobi5zaGFwZSxvKTthLmxlbmd0aD4wJiYodD10LnN1bShhKS5yZXNoYXBlKG4uc2hhcGUpKTt2YXIgaT1uLnNxdWFyZSgpO3JldHVybiB0LmRpdihpLnRvRmxvYXQoKSkubmVnKCl9fX0pfWZ1bmN0aW9uIGRpdlN0cmljdF8oZSx0KXtyZXR1cm4gYXNzZXJ0U2hhcGVzTWF0Y2goZS5zaGFwZSx0LnNoYXBlLFwiRXJyb3IgaW4gZGl2aWRlU3RyaWN0OiBcIiksZS5kaXYodCl9ZnVuY3Rpb24gbW9kXyhlLHQpe3ZhciByPWNvbnZlcnRUb1RlbnNvcihlLFwiYVwiLFwibW9kXCIpLG49Y29udmVydFRvVGVuc29yKHQsXCJiXCIsXCJtb2RcIik7YXNzZXJ0VHlwZXNNYXRjaChyLG4pO3ZhciBvPWFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKHIuc2hhcGUsbi5zaGFwZSk7cmV0dXJuIEVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKGUpe3JldHVybiBlLm1vZChyLG4pfSx7JGE6ciwkYjpufSxmdW5jdGlvbihlKXtyZXR1cm57JGE6ZnVuY3Rpb24oKXt2YXIgdD1nZXRSZWR1Y3Rpb25BeGVzKHIuc2hhcGUsbyk7cmV0dXJuIHQubGVuZ3RoPjA/ZS5zdW0odCkucmVzaGFwZShyLnNoYXBlKTplfSwkYjpmdW5jdGlvbigpe3ZhciB0PWUubXVsKHIuZGl2KG4pLmZsb29yKCkubmVnKCkpLGE9Z2V0UmVkdWN0aW9uQXhlcyhuLnNoYXBlLG8pO3JldHVybiBhLmxlbmd0aD4wP3Quc3VtKGEpLnJlc2hhcGUobi5zaGFwZSk6dH19fSl9ZnVuY3Rpb24gbW9kU3RyaWN0XyhlLHQpe3JldHVybiBhc3NlcnRTaGFwZXNNYXRjaChlLnNoYXBlLHQuc2hhcGUsXCJFcnJvciBpbiBtb2RTdHJpY3Q6IFwiKSxlLm1vZCh0KX1mdW5jdGlvbiBtaW5pbXVtXyhlLHQpe3ZhciByPWNvbnZlcnRUb1RlbnNvcihlLFwiYVwiLFwibWluaW11bVwiKSxuPWNvbnZlcnRUb1RlbnNvcih0LFwiYlwiLFwibWluaW11bVwiKTthc3NlcnRUeXBlc01hdGNoKHIsbiksXCJib29sXCI9PT1yLmR0eXBlJiYocj1yLnRvSW50KCkpLFwiYm9vbFwiPT09bi5kdHlwZSYmKG49bi50b0ludCgpKSxhc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShyLnNoYXBlLG4uc2hhcGUpO3JldHVybiBFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbihlKXtyZXR1cm4gZS5taW5pbXVtKHIsbil9LHskYTpyLCRiOm59LGZ1bmN0aW9uKGUpe3JldHVybnskYTpmdW5jdGlvbigpe3JldHVybiBlLm11bChyLmxlc3NFcXVhbChuKS50b0Zsb2F0KCkpfSwkYjpmdW5jdGlvbigpe3JldHVybiBlLm11bChyLmdyZWF0ZXIobikudG9GbG9hdCgpKX19fSl9ZnVuY3Rpb24gbWluaW11bVN0cmljdF8oZSx0KXtyZXR1cm4gYXNzZXJ0U2hhcGVzTWF0Y2goZS5zaGFwZSx0LnNoYXBlLFwiRXJyb3IgaW4gbWluaW11bVN0cmljdDogXCIpLGUubWluaW11bSh0KX1mdW5jdGlvbiBtYXhpbXVtXyhlLHQpe3ZhciByPWNvbnZlcnRUb1RlbnNvcihlLFwiYVwiLFwibWF4aW11bVwiKSxuPWNvbnZlcnRUb1RlbnNvcih0LFwiYlwiLFwibWF4aW11bVwiKTthc3NlcnRUeXBlc01hdGNoKHIsbiksXCJib29sXCI9PT1yLmR0eXBlJiYocj1yLnRvSW50KCkpLFwiYm9vbFwiPT09bi5kdHlwZSYmKG49bi50b0ludCgpKSxhc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShyLnNoYXBlLG4uc2hhcGUpO3JldHVybiBFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbihlKXtyZXR1cm4gZS5tYXhpbXVtKHIsbil9LHskYTpyLCRiOm59LGZ1bmN0aW9uKGUpe3JldHVybnskYTpmdW5jdGlvbigpe3JldHVybiBlLm11bChyLmdyZWF0ZXJFcXVhbChuKS50b0Zsb2F0KCkpfSwkYjpmdW5jdGlvbigpe3JldHVybiBlLm11bChyLmxlc3MobikudG9GbG9hdCgpKX19fSl9ZnVuY3Rpb24gbWF4aW11bVN0cmljdF8oZSx0KXtyZXR1cm4gYXNzZXJ0U2hhcGVzTWF0Y2goZS5zaGFwZSx0LnNoYXBlLFwiRXJyb3IgaW4gbWF4aW11bVN0cmljdDogXCIpLGUubWF4aW11bSh0KX1mdW5jdGlvbiBzcXVhcmVkRGlmZmVyZW5jZV8oZSx0KXt2YXIgcj1jb252ZXJ0VG9UZW5zb3IoZSxcImFcIixcInNxdWFyZWREaWZmZXJlbmNlXCIpLG49Y29udmVydFRvVGVuc29yKHQsXCJiXCIsXCJzcXVhcmVkRGlmZmVyZW5jZVwiKTthc3NlcnRUeXBlc01hdGNoKHIsbiksYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoci5zaGFwZSxuLnNoYXBlKTtyZXR1cm4gRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24oZSl7cmV0dXJuIGUuc3F1YXJlZERpZmZlcmVuY2UocixuKX0seyRhOnIsJGI6bn0sZnVuY3Rpb24oZSl7dmFyIHQ9c2NhbGFyKDIpO3JldHVybnskYTpmdW5jdGlvbigpe3JldHVybiBlLm11bChyLnN1YihuKS5tdWwodCkpfSwkYjpmdW5jdGlvbigpe3JldHVybiBlLm11bChuLnN1YihyKS5tdWwodCkpfX19KX1mdW5jdGlvbiBzcXVhcmVkRGlmZmVyZW5jZVN0cmljdF8oZSx0KXtyZXR1cm4gYXNzZXJ0U2hhcGVzTWF0Y2goZS5zaGFwZSx0LnNoYXBlLFwiRXJyb3IgaW4gc3F1YXJlZERpZmZlcmVuY2VTdHJpY3Q6IFwiKSxlLnNxdWFyZWREaWZmZXJlbmNlKHQpfWZ1bmN0aW9uIGF0YW4yXyhlLHQpe3ZhciByPWNvbnZlcnRUb1RlbnNvcihlLFwiYVwiLFwiYXRhbjJcIiksbj1jb252ZXJ0VG9UZW5zb3IodCxcImJcIixcImF0YW4yXCIpO2Fzc2VydFR5cGVzTWF0Y2gocixuKTt2YXIgbz1hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShyLnNoYXBlLG4uc2hhcGUpO3JldHVybiBFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbihlKXtyZXR1cm4gZS5hdGFuMihyLG4pfSx7JGE6ciwkYjpufSxmdW5jdGlvbihlKXtyZXR1cm57JGE6ZnVuY3Rpb24oKXt2YXIgdD1hZGQoci5zcXVhcmUoKSxuLnNxdWFyZSgpKSxhPWUubXVsKG4uZGl2KHQpKSxpPWdldFJlZHVjdGlvbkF4ZXMoci5zaGFwZSxvKTtyZXR1cm4gaS5sZW5ndGg+MCYmKGE9YS5zdW0oaSkpLGEucmVzaGFwZShyLnNoYXBlKX0sJGI6ZnVuY3Rpb24oKXt2YXIgdD1hZGQoci5zcXVhcmUoKSxuLnNxdWFyZSgpKSxhPW5lZyhlLm11bChyLmRpdih0KSkpLGk9Z2V0UmVkdWN0aW9uQXhlcyhuLnNoYXBlLG8pO3JldHVybiBpLmxlbmd0aD4wJiYoYT1hLnN1bShpKSksYS5yZXNoYXBlKG4uc2hhcGUpfX19KX12YXIgYWRkPW9wKHthZGRfOmFkZF99KSxhZGROPW9wKHthZGROXzphZGROX30pLGFkZFN0cmljdD1vcCh7YWRkU3RyaWN0XzphZGRTdHJpY3RffSksYXRhbjI9b3Aoe2F0YW4yXzphdGFuMl99KSxkaXY9b3Aoe2Rpdl86ZGl2X30pLGRpdlN0cmljdD1vcCh7ZGl2U3RyaWN0XzpkaXZTdHJpY3RffSksZmxvb3JEaXY9b3Aoe2Zsb29yRGl2XzpmbG9vckRpdl99KSxtYXhpbXVtPW9wKHttYXhpbXVtXzptYXhpbXVtX30pLG1heGltdW1TdHJpY3Q9b3Aoe21heGltdW1TdHJpY3RfOm1heGltdW1TdHJpY3RffSksbWluaW11bT1vcCh7bWluaW11bV86bWluaW11bV99KSxtaW5pbXVtU3RyaWN0PW9wKHttaW5pbXVtU3RyaWN0XzptaW5pbXVtU3RyaWN0X30pLG1vZD1vcCh7bW9kXzptb2RffSksbW9kU3RyaWN0PW9wKHttb2RTdHJpY3RfOm1vZFN0cmljdF99KSxtdWw9b3Aoe211bF86bXVsX30pLG11bFN0cmljdD1vcCh7bXVsU3RyaWN0XzptdWxTdHJpY3RffSkscG93PW9wKHtwb3dfOnBvd199KSxwb3dTdHJpY3Q9b3Aoe3Bvd1N0cmljdF86cG93U3RyaWN0X30pLHNxdWFyZWREaWZmZXJlbmNlPW9wKHtzcXVhcmVkRGlmZmVyZW5jZV86c3F1YXJlZERpZmZlcmVuY2VffSksc3F1YXJlZERpZmZlcmVuY2VTdHJpY3Q9b3Aoe3NxdWFyZWREaWZmZXJlbmNlU3RyaWN0XzpzcXVhcmVkRGlmZmVyZW5jZVN0cmljdF99KSxzdWI9b3Aoe3N1Yl86c3ViX30pLHN1YlN0cmljdD1vcCh7c3ViU3RyaWN0XzpzdWJTdHJpY3RffSk7ZnVuY3Rpb24gbG9naWNhbE5vdF8oZSl7dmFyIHQ9Y29udmVydFRvVGVuc29yKGUsXCJ4XCIsXCJsb2dpY2FsTm90XCIsXCJib29sXCIpO3JldHVybiBhc3NlcnQoXCJib29sXCI9PT10LmR0eXBlLFwiRXJyb3IgQXJyYXkgbXVzdCBiZSBvZiB0eXBlIGJvb2wuXCIpLEVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKGUpe3JldHVybiBlLmxvZ2ljYWxOb3QodCl9LHskeDp0fSl9ZnVuY3Rpb24gbG9naWNhbEFuZF8oZSx0KXt2YXIgcj1jb252ZXJ0VG9UZW5zb3IoZSxcImFcIixcImxvZ2ljYWxBbmRcIixcImJvb2xcIiksbj1jb252ZXJ0VG9UZW5zb3IodCxcImJcIixcImxvZ2ljYWxBbmRcIixcImJvb2xcIik7cmV0dXJuIGFzc2VydChcImJvb2xcIj09PXIuZHR5cGUmJlwiYm9vbFwiPT09bi5kdHlwZSxcIkVycm9yIEFycmF5IG11c3QgYmUgb2YgdHlwZSBib29sLlwiKSxhc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShyLnNoYXBlLG4uc2hhcGUpLEVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKGUpe3JldHVybiBlLmxvZ2ljYWxBbmQocixuKX0seyRhOnIsJGI6bn0pfWZ1bmN0aW9uIGxvZ2ljYWxPcl8oZSx0KXt2YXIgcj1jb252ZXJ0VG9UZW5zb3IoZSxcImFcIixcImxvZ2ljYWxPclwiLFwiYm9vbFwiKSxuPWNvbnZlcnRUb1RlbnNvcih0LFwiYlwiLFwibG9naWNhbE9yXCIsXCJib29sXCIpO3JldHVybiBhc3NlcnQoXCJib29sXCI9PT1yLmR0eXBlJiZcImJvb2xcIj09PW4uZHR5cGUsXCJFcnJvciBBcnJheSBtdXN0IGJlIG9mIHR5cGUgYm9vbC5cIiksYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoci5zaGFwZSxuLnNoYXBlKSxFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbihlKXtyZXR1cm4gZS5sb2dpY2FsT3IocixuKX0seyRhOnIsJGI6bn0pfWZ1bmN0aW9uIGxvZ2ljYWxYb3JfKGUsdCl7dmFyIHI9Y29udmVydFRvVGVuc29yKGUsXCJhXCIsXCJsb2dpY2FsWG9yXCIsXCJib29sXCIpLG49Y29udmVydFRvVGVuc29yKHQsXCJiXCIsXCJsb2dpY2FsWG9yXCIsXCJib29sXCIpO3JldHVybiBhc3NlcnQoXCJib29sXCI9PT1yLmR0eXBlJiZcImJvb2xcIj09PW4uZHR5cGUsXCJFcnJvciBBcnJheSBtdXN0IGJlIG9mIHR5cGUgYm9vbC5cIiksYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoci5zaGFwZSxuLnNoYXBlKSxsb2dpY2FsT3IoZSx0KS5sb2dpY2FsQW5kKGxvZ2ljYWxBbmQoZSx0KS5sb2dpY2FsTm90KCkpfWZ1bmN0aW9uIHdoZXJlXyhlLHQscil7dmFyIG49Y29udmVydFRvVGVuc29yKHQsXCJhXCIsXCJ3aGVyZVwiKSxvPWNvbnZlcnRUb1RlbnNvcihyLFwiYlwiLFwid2hlcmVcIiksYT1jb252ZXJ0VG9UZW5zb3IoZSxcImNvbmRpdGlvblwiLFwid2hlcmVcIixcImJvb2xcIik7YXNzZXJ0KFwiYm9vbFwiPT09YS5kdHlwZSxcIkVycm9yIENvbmRpdGlvbiBtdXN0IGJlIG9mIHR5cGUgYm9vbC5cIiksYXNzZXJ0U2hhcGVzTWF0Y2gobi5zaGFwZSxvLnNoYXBlLFwiRXJyb3IgaW4gd2hlcmU6IFwiKSwxPT09YS5yYW5rP2Fzc2VydChhLnNoYXBlWzBdPT09bi5zaGFwZVswXSxcIlRoZSBmaXJzdCBkaW1lbnNpb24gb2YgYGFgIG11c3QgbWF0Y2ggdGhlIHNpemUgb2YgYGNvbmRpdGlvbmAuXCIpOmFzc2VydFNoYXBlc01hdGNoKGEuc2hhcGUsby5zaGFwZSxcIkVycm9yIGluIHdoZXJlOiBcIik7cmV0dXJuIEVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKGUpe3JldHVybiBlLnNlbGVjdChhLG4sbyl9LHskY29uZGl0aW9uOmEsJGE6biwkYjpvfSxmdW5jdGlvbihlKXtyZXR1cm57JGNvbmRpdGlvbjpmdW5jdGlvbigpe3JldHVybiB6ZXJvc0xpa2UoYSl9LCRhOmZ1bmN0aW9uKCl7cmV0dXJuIGUubXVsKGEuY2FzdChuLmR0eXBlKSl9LCRiOmZ1bmN0aW9uKCl7cmV0dXJuIGUubXVsKGEubG9naWNhbE5vdCgpLmNhc3Qoby5kdHlwZSkpfX19KX1mdW5jdGlvbiB3aGVyZUFzeW5jXyhlKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciB0LHIsbjtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihvKXtzd2l0Y2goby5sYWJlbCl7Y2FzZSAwOnJldHVybiBhc3NlcnQoXCJib29sXCI9PT0odD1jb252ZXJ0VG9UZW5zb3IoZSxcImNvbmRpdGlvblwiLFwid2hlcmVcIixcImJvb2xcIikpLmR0eXBlLFwiQ29uZGl0aW9uIG11c3QgYmUgb2YgdHlwZSBib29sLlwiKSxbNCx0LmRhdGEoKV07Y2FzZSAxOnJldHVybiByPW8uc2VudCgpLG49d2hlcmVJbXBsKHQuc2hhcGUsciksZSE9PXQmJnQuZGlzcG9zZSgpLFsyLG5dfX0pfSl9dmFyIGxvZ2ljYWxBbmQ9b3Aoe2xvZ2ljYWxBbmRfOmxvZ2ljYWxBbmRffSksbG9naWNhbE5vdD1vcCh7bG9naWNhbE5vdF86bG9naWNhbE5vdF99KSxsb2dpY2FsT3I9b3Aoe2xvZ2ljYWxPcl86bG9naWNhbE9yX30pLGxvZ2ljYWxYb3I9b3Aoe2xvZ2ljYWxYb3JfOmxvZ2ljYWxYb3JffSksd2hlcmU9b3Aoe3doZXJlXzp3aGVyZV99KSx3aGVyZUFzeW5jPXdoZXJlQXN5bmNfO2Z1bmN0aW9uIHJlbHVfKGUpe3ZhciB0PWNvbnZlcnRUb1RlbnNvcihlLFwieFwiLFwicmVsdVwiKTtpZihcImJvb2xcIj09PXQuZHR5cGUpcmV0dXJuIHQudG9JbnQoKTtyZXR1cm4gRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24oZSl7cmV0dXJuIGUucmVsdSh0KX0seyR4OnR9LGZ1bmN0aW9uKGUpe3ZhciByPXQuc3RlcCgpO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBlLm11bFN0cmljdChyLnRvRmxvYXQoKSl9fX0pfWZ1bmN0aW9uIGVsdV8oZSl7dmFyIHQ9Y29udmVydFRvVGVuc29yKGUsXCJ4XCIsXCJlbHVcIik7cmV0dXJuIEVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKGUscil7cmV0dXJuIHIoZS5lbHUodCkpfSx7JHg6dH0sZnVuY3Rpb24oZSx0KXt2YXIgcj10WzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5lbHVEZXIoZSxyKX0se2R5OmUseTpyfSl9fX0pfWZ1bmN0aW9uIHNlbHVfKGUpe3ZhciB0PWNvbnZlcnRUb1RlbnNvcihlLFwieFwiLFwic2VsdVwiKTtyZXR1cm4gRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24oZSl7cmV0dXJuIGUuc2VsdSh0KX0seyR4OnR9LGZ1bmN0aW9uKGUpe3JldHVybnskeDpmdW5jdGlvbigpe3ZhciByPXQuZ3JlYXRlcihzY2FsYXIoMCkpLG49c2NhbGFyKFNFTFVfU0NBTEVBTFBIQSksbz1zY2FsYXIoU0VMVV9TQ0FMRSksYT1lLm11bChvKSxpPWUubXVsKG4pLm11bCh0LnRvRmxvYXQoKS5leHAoKSk7cmV0dXJuIHdoZXJlKHIsYSxpKX19fSl9ZnVuY3Rpb24gbGVha3lSZWx1XyhlLHQpe3ZvaWQgMD09PXQmJih0PS4yKTt2YXIgcj1jb252ZXJ0VG9UZW5zb3IoZSxcInhcIixcImxlYWt5UmVsdVwiKTtyZXR1cm4gbWF4aW11bShzY2FsYXIodCkubXVsKHIpLHIpfWZ1bmN0aW9uIHByZWx1XyhlLHQpe3ZhciByPWNvbnZlcnRUb1RlbnNvcihlLFwieFwiLFwicHJlbHVcIiksbj1jb252ZXJ0VG9UZW5zb3IodCxcImFscGhhXCIsXCJwcmVsdVwiKSxvPXNjYWxhcigwKTtyZXR1cm4gbWF4aW11bShvLHIpLmFkZChuLm11bChtaW5pbXVtKG8scikpKX12YXIgZWx1PW9wKHtlbHVfOmVsdV99KSxsZWFreVJlbHU9b3Aoe2xlYWt5UmVsdV86bGVha3lSZWx1X30pLHByZWx1PW9wKHtwcmVsdV86cHJlbHVffSkscmVsdT1vcCh7cmVsdV86cmVsdV99KSxzZWx1PW9wKHtzZWx1XzpzZWx1X30pO2Z1bmN0aW9uIHRyYW5zcG9zZV8oZSx0KXt2YXIgcj1jb252ZXJ0VG9UZW5zb3IoZSxcInhcIixcInRyYW5zcG9zZVwiKTtpZihudWxsPT10JiYodD1yLnNoYXBlLm1hcChmdW5jdGlvbihlLHQpe3JldHVybiB0fSkucmV2ZXJzZSgpKSxhc3NlcnQoci5yYW5rPT09dC5sZW5ndGgsXCJFcnJvciBpbiB0cmFuc3Bvc2U6IHJhbmsgb2YgaW5wdXQgXCIrci5yYW5rK1wiIG11c3QgbWF0Y2ggbGVuZ3RoIG9mIHBlcm0gXCIrdCtcIi5cIiksdC5mb3JFYWNoKGZ1bmN0aW9uKGUpe2Fzc2VydChlPj0wJiZlPHIucmFuayxcIkFsbCBlbnRyaWVzIGluICdwZXJtJyBtdXN0IGJlIGJldHdlZW4gMCBhbmQgXCIrKHIucmFuay0xKStcIiBidXQgZ290IFwiK3QpfSksci5yYW5rPD0xKXJldHVybiByLmNsb25lKCk7cmV0dXJuIEVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKGUpe3JldHVybiBlLnRyYW5zcG9zZShyLHQpfSx7JHg6cn0sZnVuY3Rpb24oZSl7dmFyIHI9Z2V0VW5kb0F4ZXNQZXJtdXRhdGlvbih0KTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gZS50cmFuc3Bvc2Uocil9fX0pfXZhciB0cmFuc3Bvc2U9b3Aoe3RyYW5zcG9zZV86dHJhbnNwb3NlX30pO2Z1bmN0aW9uIGxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uXyhlLHQscixuLG8pe3ZvaWQgMD09PXQmJih0PTUpLHZvaWQgMD09PXImJihyPTEpLHZvaWQgMD09PW4mJihuPTEpLHZvaWQgMD09PW8mJihvPS41KTt2YXIgYT1jb252ZXJ0VG9UZW5zb3IoZSxcInhcIixcImxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uXCIpO2Fzc2VydCg0PT09YS5yYW5rfHwzPT09YS5yYW5rLFwiRXJyb3IgaW4gbG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb246IHggbXVzdCBiZSByYW5rIDMgb3IgNCBidXQgZ290XFxuICAgICAgICAgICAgICAgcmFuayBcIithLnJhbmsrXCIuXCIpLGFzc2VydChpc0ludCh0KSxcIkVycm9yIGluIGxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uOiBkZXB0aFJhZGl1cyBtdXN0IGJlIGFuIGludGVnZXJcXG4gICAgICAgICAgICAgICAgICAgICBidXQgZ290IGRlcHRoUmFkaXVzIFwiK3QrXCIuXCIpO3ZhciBpPWEscz0hMTszPT09YS5yYW5rJiYocz0hMCxpPWEuYXM0RCgxLGEuc2hhcGVbMF0sYS5zaGFwZVsxXSxhLnNoYXBlWzJdKSk7dmFyIHU9RU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24oZSxhKXtyZXR1cm4gYShlLmxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uNEQoaSx0LHIsbixvKSl9LHt4NEQ6aX0sZnVuY3Rpb24oZSxhKXt2YXIgcz1hWzBdO3JldHVybnt4NEQ6ZnVuY3Rpb24oKXtyZXR1cm4gRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24oYSl7cmV0dXJuIGEuTFJOR3JhZChlLGkscyx0LHIsbixvKX0se30pfX19KTtyZXR1cm4gcz91LmFzM0QodS5zaGFwZVsxXSx1LnNoYXBlWzJdLHUuc2hhcGVbM10pOnV9dmFyIGxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uPW9wKHtsb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbl86bG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb25ffSk7ZnVuY3Rpb24gbm9ybV8oZSx0LHIsbil7dm9pZCAwPT09dCYmKHQ9XCJldWNsaWRlYW5cIiksdm9pZCAwPT09ciYmKHI9bnVsbCksdm9pZCAwPT09biYmKG49ITEpO3ZhciBvPW5vcm1JbXBsKGU9Y29udmVydFRvVGVuc29yKGUsXCJ4XCIsXCJub3JtXCIpLHQsciksYT1vLnNoYXBlO2lmKG4pe3ZhciBpPXBhcnNlQXhpc1BhcmFtKHIsZS5zaGFwZSk7YT1leHBhbmRTaGFwZVRvS2VlcERpbShvLnNoYXBlLGkpfXJldHVybiBvLnJlc2hhcGUoYSl9ZnVuY3Rpb24gbm9ybUltcGwoZSx0LHIpe2lmKHZvaWQgMD09PXImJihyPW51bGwpLDA9PT1lLnJhbmspcmV0dXJuIGUuYWJzKCk7aWYoMSE9PWUucmFuayYmbnVsbD09PXIpcmV0dXJuIG5vcm1JbXBsKGUucmVzaGFwZShbLTFdKSx0LHIpO2lmKDE9PT1lLnJhbmt8fFwibnVtYmVyXCI9PXR5cGVvZiByfHxyIGluc3RhbmNlb2YgQXJyYXkmJjE9PT1yLmxlbmd0aCl7aWYoMT09PXQpcmV0dXJuIGUuYWJzKCkuc3VtKHIpO2lmKHQ9PT0xLzApcmV0dXJuIGUuYWJzKCkubWF4KHIpO2lmKHQ9PT0tMS8wKXJldHVybiBlLmFicygpLm1pbihyKTtpZihcImV1Y2xpZGVhblwiPT09dHx8Mj09PXQpcmV0dXJuIGUuYWJzKCkucG93KHNjYWxhcigyLFwiaW50MzJcIikpLnN1bShyKS5zcXJ0KCk7dGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgaW4gbm9ybTogaW52YWxpZCBvcmQgdmFsdWU6IFwiK3QpfWlmKHIgaW5zdGFuY2VvZiBBcnJheSYmMj09PXIubGVuZ3RoKXtpZigxPT09dClyZXR1cm4gZS5hYnMoKS5zdW0oclswXSkubWF4KHJbMV0tMSk7aWYodD09PTEvMClyZXR1cm4gZS5hYnMoKS5zdW0oclsxXSkubWF4KHJbMF0pO2lmKHQ9PT0tMS8wKXJldHVybiBlLmFicygpLnN1bShyWzFdKS5taW4oclswXSk7aWYoXCJmcm9cIj09PXR8fFwiZXVjbGlkZWFuXCI9PT10KXJldHVybiBlLnNxdWFyZSgpLnN1bShyKS5zcXJ0KCk7dGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgaW4gbm9ybTogaW52YWxpZCBvcmQgdmFsdWU6IFwiK3QpfXRocm93IG5ldyBFcnJvcihcIkVycm9yIGluIG5vcm06IGludmFsaWQgYXhpczogXCIrcil9dmFyIG5vcm09b3Aoe25vcm1fOm5vcm1ffSk7ZnVuY3Rpb24gdW5zb3J0ZWRTZWdtZW50U3VtXyhlLHQscil7dmFyIG49Y29udmVydFRvVGVuc29yKGUsXCJ4XCIsXCJ1bnNvcnRlZFNlZ21lbnRTdW1cIiksbz1jb252ZXJ0VG9UZW5zb3IodCxcInNlZ21lbnRJZHNcIixcInVuc29ydGVkU2VnbWVudFN1bVwiLFwiaW50MzJcIik7YXNzZXJ0KFwiaW50MzJcIj09PW8uZHR5cGUsXCJzZWdtZW50SWRzIG11c3QgYmUgb2YgZHR5cGUgYGludDMyYFwiKSxhc3NlcnQoaXNJbnQociksXCJudW1TZWdtZW50cyBtdXN0IGJlIG9mIGR0eXBlIGludFwiKTtyZXR1cm4gRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24oZSl7cmV0dXJuIGUudW5zb3J0ZWRTZWdtZW50U3VtKG4sbyxyKX0seyR4Om59LGZ1bmN0aW9uKGUpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBnYXRoZXJEcm9wTmVnYXRpdmVzKGUsbyl9fX0pfWZ1bmN0aW9uIGdhdGhlcl8oZSx0LHIpe3ZvaWQgMD09PXImJihyPTApO3ZhciBuPWNvbnZlcnRUb1RlbnNvcihlLFwieFwiLFwiZ2F0aGVyXCIpLG89Y29udmVydFRvVGVuc29yKHQsXCJpbmRpY2VzXCIsXCJnYXRoZXJcIixcImludDMyXCIpO2Fzc2VydChcImludDMyXCI9PT1vLmR0eXBlLFwiSW5kaWNlcyBtdXN0IGJlIG9mIGR0eXBlIGBpbnQzMmBcIikscj1wYXJzZUF4aXNQYXJhbShyLG4uc2hhcGUpWzBdO3JldHVybiBFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbihlKXtyZXR1cm4gZS5nYXRoZXIobixvLHIpfSx7JHg6bn0sZnVuY3Rpb24oZSl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7aWYoMD09PXIpcmV0dXJuIHVuc29ydGVkU2VnbWVudFN1bShlLG8sbi5zaGFwZVtyXSk7dmFyIHQ9bi5zaGFwZSxhPW8uc2l6ZSxpPXQuc2xpY2UoMCxyKSxzPWkubGVuZ3RoLHU9dC5zbGljZShyLHQubGVuZ3RoKS5zbGljZSgxKSxsPXUubGVuZ3RoLGM9YXJyYXlSYW5nZSgwLHMpLHA9YXJyYXlSYW5nZShzKzEscysxK2wpLGQ9YXJyYXlDb25jYXQoW2ksW2FdLHVdKSxoPWUucmVzaGFwZShkKSxmPW8ucmVzaGFwZShbYV0pLG09YXJyYXlDb25jYXQoW1tzXSxjLHBdKSxnPWgudHJhbnNwb3NlKG0pLHY9dW5zb3J0ZWRTZWdtZW50U3VtKGcsZixuLnNoYXBlW3JdKSx5PWdldFVuZG9BeGVzUGVybXV0YXRpb24obSk7cmV0dXJuIHY9di50cmFuc3Bvc2UoeSl9fX0pfWZ1bmN0aW9uIGFycmF5UmFuZ2UoZSx0KXtmb3IodmFyIHI9W10sbj1lO248dDsrK24pci5wdXNoKG4pO3JldHVybiByfWZ1bmN0aW9uIGFycmF5Q29uY2F0KGUpe2Zvcih2YXIgdD1bXSxyPTA7cjxlLmxlbmd0aDsrK3IpZm9yKHZhciBuPTA7bjxlW3JdLmxlbmd0aDsrK24pdC5wdXNoKGVbcl1bbl0pO3JldHVybiB0fWZ1bmN0aW9uIGdhdGhlckRyb3BOZWdhdGl2ZXMoZSx0KXtmb3IodmFyIHI9bWF4aW11bSh0LHplcm9zTGlrZSh0KSksbj1nYXRoZXIoZSxyKSxvPWdyZWF0ZXJFcXVhbCh0LHNjYWxhcigwLFwiaW50MzJcIikpLGE9bi5yYW5rLW8ucmFuayxpPTA7aTxhOysraSlvPWV4cGFuZERpbXMobyxpKzEpO289bG9naWNhbEFuZChvLG9uZXMkMShuLnNoYXBlLFwiYm9vbFwiKSk7dmFyIHM9emVyb3NMaWtlKG4pO3JldHVybiB3aGVyZShvLG4scyl9dmFyIGdhdGhlcj1vcCh7Z2F0aGVyXzpnYXRoZXJffSksdW5zb3J0ZWRTZWdtZW50U3VtPW9wKHt1bnNvcnRlZFNlZ21lbnRTdW1fOnVuc29ydGVkU2VnbWVudFN1bV99KTtmdW5jdGlvbiBtdWx0aVJOTkNlbGxfKGUsdCxyLG4pe2Zvcih2YXIgbz1jb252ZXJ0VG9UZW5zb3IodCxcImRhdGFcIixcIm11bHRpUk5OQ2VsbFwiKSxhPWNvbnZlcnRUb1RlbnNvckFycmF5KHIsXCJjXCIsXCJtdWx0aVJOTkNlbGxcIiksaT1jb252ZXJ0VG9UZW5zb3JBcnJheShuLFwiaFwiLFwibXVsdGlSTk5DZWxsXCIpLHM9byx1PVtdLGw9MDtsPGUubGVuZ3RoO2wrKyl7dmFyIGM9ZVtsXShzLGFbbF0saVtsXSk7dS5wdXNoKGNbMF0pLHUucHVzaChjWzFdKSxzPWNbMV19dmFyIHA9W10sZD1bXTtmb3IobD0wO2w8dS5sZW5ndGg7bCs9MilwLnB1c2godVtsXSksZC5wdXNoKHVbbCsxXSk7cmV0dXJuW3AsZF19ZnVuY3Rpb24gYmFzaWNMU1RNQ2VsbF8oZSx0LHIsbixvLGEpe3ZhciBpPWNvbnZlcnRUb1RlbnNvcihlLFwiZm9yZ2V0Qmlhc1wiLFwiYmFzaWNMU1RNQ2VsbFwiKSxzPWNvbnZlcnRUb1RlbnNvcih0LFwibHN0bUtlcm5lbFwiLFwiYmFzaWNMU1RNQ2VsbFwiKSx1PWNvbnZlcnRUb1RlbnNvcihyLFwibHN0bUJpYXNcIixcImJhc2ljTFNUTUNlbGxcIiksbD1jb252ZXJ0VG9UZW5zb3IobixcImRhdGFcIixcImJhc2ljTFNUTUNlbGxcIiksYz1jb252ZXJ0VG9UZW5zb3IobyxcImNcIixcImJhc2ljTFNUTUNlbGxcIikscD1jb252ZXJ0VG9UZW5zb3IoYSxcImhcIixcImJhc2ljTFNUTUNlbGxcIiksZD1sLmNvbmNhdChwLDEpLm1hdE11bChzKS5hZGQodSksaD1kLnNoYXBlWzBdLGY9ZC5zaGFwZVsxXS80LG09W2gsZl0sZz1kLnNsaWNlKFswLDBdLG0pLHY9ZC5zbGljZShbMCxmXSxtKSx5PWQuc2xpY2UoWzAsMipmXSxtKSx4PWQuc2xpY2UoWzAsMypmXSxtKSxUPWcuc2lnbW9pZCgpLm11bFN0cmljdCh2LnRhbmgoKSkuYWRkU3RyaWN0KGMubXVsU3RyaWN0KGkuYWRkKHkpLnNpZ21vaWQoKSkpO3JldHVybltULFQudGFuaCgpLm11bFN0cmljdCh4LnNpZ21vaWQoKSldfXZhciBiYXNpY0xTVE1DZWxsPW9wKHtiYXNpY0xTVE1DZWxsXzpiYXNpY0xTVE1DZWxsX30pLG11bHRpUk5OQ2VsbD1vcCh7bXVsdGlSTk5DZWxsXzptdWx0aVJOTkNlbGxffSk7ZnVuY3Rpb24gbW92aW5nQXZlcmFnZV8oZSx0LHIsbixvKXt2b2lkIDA9PT1vJiYobz0hMCk7dmFyIGE9Y29udmVydFRvVGVuc29yKGUsXCJ2XCIsXCJtb3ZpbmdBdmVyYWdlXCIpLGk9Y29udmVydFRvVGVuc29yKHQsXCJ4XCIsXCJtb3ZpbmdBdmVyYWdlXCIpLHM9Y29udmVydFRvVGVuc29yKHIsXCJkZWNheVwiLFwibW92aW5nQXZlcmFnZVwiKTthc3NlcnRUeXBlc01hdGNoKGEsaSksYXNzZXJ0KGFycmF5c0VxdWFsKGEuc2hhcGUsaS5zaGFwZSksXCJTaGFwZSBtaXNtYXRjaCBpbiB2IGFuZCB4XCIpO3ZhciB1PXNjYWxhcigxKSxsPXUuc3ViKHMpLGM9aS5zdWIoYSkubXVsKGwpO2lmKG8pe2Fzc2VydChudWxsIT1uLFwiV2hlbiB1c2luZyB6ZXJvRGViaWFzOiB0cnVlLCBzdGVwIGlzIHJlcXVpcmVkLlwiKTt2YXIgcD1jb252ZXJ0VG9UZW5zb3IobixcInN0ZXBcIixcIm1vdmluZ0F2ZXJhZ2VcIik7Yz1jLmRpdih1LnN1Yihwb3cocyxwKSkpfXJldHVybiBhLmFkZChjKX12YXIgbW92aW5nQXZlcmFnZT1vcCh7bW92aW5nQXZlcmFnZV86bW92aW5nQXZlcmFnZV99KTtmdW5jdGlvbiBzdHJpZGVkU2xpY2VfKGUsdCxyLG4sbyxhLGkscyx1KXtpZih2b2lkIDA9PT1vJiYobz0wKSx2b2lkIDA9PT1hJiYoYT0wKSx2b2lkIDA9PT1pJiYoaT0wKSx2b2lkIDA9PT1zJiYocz0wKSx2b2lkIDA9PT11JiYodT0wKSwwIT09aSl0aHJvdyBuZXcgRXJyb3IoXCJlbGxpcHNpcyBtYXNrIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpO2lmKDAhPT1zKXRocm93IG5ldyBFcnJvcihcIm5ldyBheGlzIG1hc2sgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7dmFyIGw9Y29udmVydFRvVGVuc29yKGUsXCJ4XCIsXCJzdHJpZGVkU2xpY2VcIik7cmV0dXJuIEVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKGUpe3JldHVybiBlLnN0cmlkZWRTbGljZShsLHQscixuLG8sYSxpLHMsdSl9LHskeDpsfSl9dmFyIHN0cmlkZWRTbGljZT1vcCh7c3RyaWRlZFNsaWNlXzpzdHJpZGVkU2xpY2VffSk7ZnVuY3Rpb24gdG9wa18oZSx0LHIpe3ZvaWQgMD09PXQmJih0PTEpLHZvaWQgMD09PXImJihyPSEwKTt2YXIgbj1jb252ZXJ0VG9UZW5zb3IoZSxcInhcIixcInRvcGtcIik7aWYoMD09PW4ucmFuayl0aHJvdyBuZXcgRXJyb3IoXCJ0b3BrKCkgZXhwZWN0cyB0aGUgaW5wdXQgdG8gYmUgb2YgcmFuayAxIG9yIGhpZ2hlclwiKTt2YXIgbz1uLnNoYXBlW24uc2hhcGUubGVuZ3RoLTFdO2lmKHQ+byl0aHJvdyBuZXcgRXJyb3IoXCInaycgcGFzc2VkIHRvIHRvcGsoKSBtdXN0IGJlIDw9IHRoZSBsYXN0IGRpbWVuc2lvbiAoXCIrbytcIikgYnV0IGdvdCBcIit0KTt2YXIgYT1FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbihlKXtyZXR1cm4gZS50b3BrKG4sdCxyKX0seyR4Om59KTtyZXR1cm57dmFsdWVzOmFbMF0saW5kaWNlczphWzFdfX12YXIgdG9waz1vcCh7dG9wa186dG9wa199KTtmdW5jdGlvbiBzY2F0dGVyTkRfKGUsdCxyKXt2YXIgbj1jb252ZXJ0VG9UZW5zb3IoZSxcImluZGljZXNcIixcInNjYXR0ZXJORFwiLFwiaW50MzJcIiksbz1jb252ZXJ0VG9UZW5zb3IodCxcInVwZGF0ZXNcIixcInNjYXR0ZXJORFwiKTtyZXR1cm4gdmFsaWRhdGVJbnB1dChvLG4sciksRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24oZSl7cmV0dXJuIGUuc2NhdHRlck5EKG4sbyxyKX0seyRpbmRpY2VzOm4sJHVwZGF0ZXM6b30pfXZhciBzY2F0dGVyTkQ9b3Aoe3NjYXR0ZXJORF86c2NhdHRlck5EX30pO2Z1bmN0aW9uIGZmdF8oZSl7YXNzZXJ0KFwiY29tcGxleDY0XCI9PT1lLmR0eXBlLFwiVGhlIGR0eXBlIGZvciB0Zi5zcGVjdHJhbC5mZnQoKSBtdXN0IGJlIGNvbXBsZXg2NCBidXQgZ290IFwiK2UuZHR5cGUrXCIuXCIpO3ZhciB0PWUuc2hhcGVbZS5zaGFwZS5sZW5ndGgtMV0scj1lLnNpemUvdCxuPWUuYXMyRChyLHQpO3JldHVybiBFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbihlKXtyZXR1cm4gZS5mZnQobil9LHtpbnB1dDplfSkucmVzaGFwZShlLnNoYXBlKX1mdW5jdGlvbiBpZmZ0XyhlKXthc3NlcnQoXCJjb21wbGV4NjRcIj09PWUuZHR5cGUsXCJUaGUgZHR5cGUgZm9yIHRmLnNwZWN0cmFsLmlmZnQoKSBtdXN0IGJlIGNvbXBsZXg2NCBidXQgZ290IFwiK2UuZHR5cGUrXCIuXCIpO3ZhciB0PWUuc2hhcGVbZS5zaGFwZS5sZW5ndGgtMV0scj1lLnNpemUvdCxuPWUuYXMyRChyLHQpO3JldHVybiBFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbihlKXtyZXR1cm4gZS5pZmZ0KG4pfSx7aW5wdXQ6ZX0pLnJlc2hhcGUoZS5zaGFwZSl9ZnVuY3Rpb24gcmZmdF8oZSl7YXNzZXJ0KFwiZmxvYXQzMlwiPT09ZS5kdHlwZSxcIlRoZSBkdHlwZSBmb3IgcmZmdCgpIG11c3QgYmUgcmVhbCB2YWx1ZSBidXRcXG4gICAgZ290IFwiK2UuZHR5cGUpO3ZhciB0PWUuc2hhcGVbZS5zaGFwZS5sZW5ndGgtMV0scj1lLnNpemUvdCxuPWUuemVyb3NMaWtlKCksbz1jb21wbGV4KGUsbikuYXMyRChyLHQpLGE9RU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24oZSl7cmV0dXJuIGUuZmZ0KG8pfSx7Y29tcGxleElucHV0Om99KSxpPU1hdGguZmxvb3IodC8yKSsxLHM9cmVhbChhKSx1PWltYWcoYSksbD1zLnNwbGl0KFtpLHQtaV0scy5zaGFwZS5sZW5ndGgtMSksYz11LnNwbGl0KFtpLHQtaV0sdS5zaGFwZS5sZW5ndGgtMSkscD1lLnNoYXBlLnNsaWNlKCk7cmV0dXJuIHBbZS5zaGFwZS5sZW5ndGgtMV09aSxjb21wbGV4KGxbMF0sY1swXSkucmVzaGFwZShwKX12YXIgZmZ0PW9wKHtmZnRfOmZmdF99KSxpZmZ0PW9wKHtpZmZ0XzppZmZ0X30pLHJmZnQ9b3Aoe3JmZnRfOnJmZnRffSksc3BlY3RyYWxfb3BzPU9iamVjdC5mcmVlemUoe2ZmdDpmZnQsaWZmdDppZmZ0LHJmZnQ6cmZmdH0pO2Z1bmN0aW9uIHZhbGlkYXRlSW5wdXQkMShlLHQscixuKXtpZihcImludDMyXCIhPT1lLmR0eXBlKXRocm93IG5ldyBFcnJvcihcInRmLnNwYXJzZVRvRGVuc2UoKSBleHBlY3RzIHRoZSBpbmRpY2VzIHRvIGJlIGludDMyIHR5cGUsIGJ1dCB0aGUgZHR5cGUgd2FzIFwiK2UuZHR5cGUrXCIuXCIpO2lmKGUucmFuaz4yKXRocm93IG5ldyBFcnJvcihcInNwYXJzZUluZGljZXMgc2hvdWxkIGJlIGEgc2NhbGFyLCB2ZWN0b3IsIG9yIG1hdHJpeCwgYnV0IGdvdCBzaGFwZSBcIitlLnNoYXBlK1wiLlwiKTt2YXIgbz1lLnJhbms+MD9lLnNoYXBlWzBdOjEsYT1lLnJhbms+MT9lLnNoYXBlWzFdOjE7aWYoci5sZW5ndGghPT1hKXRocm93IG5ldyBFcnJvcihcIm91dHB1dFNoYXBlIGhhcyBpbmNvcnJlY3QgbnVtYmVyIG9mIGVsZW1lbnRzOiwgXCIrci5sZW5ndGgrXCIsIHNob3VsZCBiZTogXCIrYStcIi5cIik7dmFyIGk9dC5zaXplO2lmKDAhPT10LnJhbmsmJigxIT09dC5yYW5rfHxpIT09bykpdGhyb3cgbmV3IEVycm9yKFwic3BhcnNlVmFsdWVzIGhhcyBpbmNvcnJlY3Qgc2hhcGUgXCIrdC5zaGFwZStcIiwgc2hvdWxkIGJlIFtdIG9yIFtcIitvK1wiXVwiKTtpZih0LmR0eXBlIT09bi5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJzcGFyc2VWYWx1ZXMuZHR5cGUgbXVzdCBtYXRjaCBkZWZhdWx0VmFsdWVzLmR0eXBlXCIpfWZ1bmN0aW9uIHNwYXJzZVRvRGVuc2VfKGUsdCxyLG4pe3ZhciBvPWNvbnZlcnRUb1RlbnNvcihlLFwic3BhcnNlSW5kaWNlc1wiLFwic3BhcnNlVG9EZW5zZVwiLFwiaW50MzJcIiksYT1jb252ZXJ0VG9UZW5zb3IodCxcInNwYXJzZVZhbHVlc1wiLFwic3BhcnNlVG9EZW5zZVwiKSxpPWNvbnZlcnRUb1RlbnNvcihuLFwiZGVmYXVsdFZhbHVlXCIsXCJzcGFyc2VUb0RlbnNlXCIsYS5kdHlwZSk7cmV0dXJuIHZhbGlkYXRlSW5wdXQkMShvLGEscixpKSxFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbihlKXtyZXR1cm4gZS5zcGFyc2VUb0RlbnNlKG8sYSxyLGkpfSx7JHNwYXJzZUluZGljZXM6bywkc3BhcnNlVmFsdWVzOmEsJGRlZmF1bHRWYWx1ZTppfSl9dmFyIHNwYXJzZVRvRGVuc2U9b3Aoe3NwYXJzZVRvRGVuc2VfOnNwYXJzZVRvRGVuc2VffSk7ZnVuY3Rpb24gZ2F0aGVyTkRfKGUsdCl7dmFyIHI9Y29udmVydFRvVGVuc29yKHQsXCJpbmRpY2VzXCIsXCJnYXRoZXJORFwiLFwiaW50MzJcIiksbj1jb252ZXJ0VG9UZW5zb3IoZSxcInhcIixcImdhdGhlck5EXCIpO3JldHVybiBFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbihlKXtyZXR1cm4gZS5nYXRoZXJORChuLHIpfSx7JHg6biwkaW5kaWNlczpyfSl9dmFyIFJlZHVjdGlvbixnYXRoZXJORD1vcCh7Z2F0aGVyTkRfOmdhdGhlck5EX30pO2Z1bmN0aW9uIGNvbXB1dGVXZWlnaHRlZExvc3NfKGUsdCxyKXt2b2lkIDA9PT1yJiYocj1SZWR1Y3Rpb24uU1VNX0JZX05PTlpFUk9fV0VJR0hUUyk7dmFyIG49Y29udmVydFRvVGVuc29yKGUsXCJsb3NzZXNcIixcImNvbXB1dGVXZWlnaHRlZExvc3NcIiksbz1udWxsO251bGwhPXQmJihvPWNvbnZlcnRUb1RlbnNvcih0LFwid2VpZ2h0c1wiLFwiY29tcHV0ZVdlaWdodGVkTG9zc1wiKSk7dmFyIGE9bnVsbD09bz9uOm4ubXVsKG8pO2lmKHI9PT1SZWR1Y3Rpb24uTk9ORSlyZXR1cm4gYTtpZihyPT09UmVkdWN0aW9uLlNVTSlyZXR1cm4gYS5zdW0oKTtpZihyPT09UmVkdWN0aW9uLk1FQU4pe2lmKG51bGw9PW8pcmV0dXJuIGEubWVhbigpO3ZhciBpPXNpemVGcm9tU2hhcGUobi5zaGFwZSkvc2l6ZUZyb21TaGFwZShvLnNoYXBlKSxzPWEuc3VtKCkuZGl2KG8uc3VtKCkpO3JldHVybiBpPjE/cy5kaXYoc2NhbGFyKGkpKTpzfWlmKHI9PT1SZWR1Y3Rpb24uU1VNX0JZX05PTlpFUk9fV0VJR0hUUyl7aWYobnVsbD09bylyZXR1cm4gYS5zdW0oKS5kaXYoc2NhbGFyKG4uc2l6ZSkpO3ZhciB1PW8ubXVsKG9uZXMkMShuLnNoYXBlKSkubm90RXF1YWwoc2NhbGFyKDApKS5zdW0oKS50b0Zsb2F0KCk7cmV0dXJuIGEuc3VtKCkuZGl2KHUpfXRocm93IEVycm9yKFwiVW5rbm93biByZWR1Y3Rpb246IFwiK3IpfWZ1bmN0aW9uIGFic29sdXRlRGlmZmVyZW5jZV8oZSx0LHIsbil7dm9pZCAwPT09biYmKG49UmVkdWN0aW9uLlNVTV9CWV9OT05aRVJPX1dFSUdIVFMpO3ZhciBvPWNvbnZlcnRUb1RlbnNvcihlLFwibGFiZWxzXCIsXCJhYnNvbHV0ZURpZmZlcmVuY2VcIiksYT1jb252ZXJ0VG9UZW5zb3IodCxcInByZWRpY3Rpb25zXCIsXCJhYnNvbHV0ZURpZmZlcmVuY2VcIiksaT1udWxsO251bGwhPXImJihpPWNvbnZlcnRUb1RlbnNvcihyLFwid2VpZ2h0c1wiLFwiYWJzb2x1dGVEaWZmZXJlbmNlXCIpKSxhc3NlcnRTaGFwZXNNYXRjaChvLnNoYXBlLGEuc2hhcGUsXCJFcnJvciBpbiBhYnNvbHV0ZURpZmZlcmVuY2U6IFwiKTt2YXIgcz1vLnN1YihhKS5hYnMoKTtyZXR1cm4gY29tcHV0ZVdlaWdodGVkTG9zcyhzLGksbil9ZnVuY3Rpb24gbWVhblNxdWFyZWRFcnJvcl8oZSx0LHIsbil7dm9pZCAwPT09biYmKG49UmVkdWN0aW9uLlNVTV9CWV9OT05aRVJPX1dFSUdIVFMpO3ZhciBvPWNvbnZlcnRUb1RlbnNvcihlLFwibGFiZWxzXCIsXCJtZWFuU3F1YXJlZEVycm9yXCIpLGE9Y29udmVydFRvVGVuc29yKHQsXCJwcmVkaWN0aW9uc1wiLFwibWVhblNxdWFyZWRFcnJvclwiKSxpPW51bGw7bnVsbCE9ciYmKGk9Y29udmVydFRvVGVuc29yKHIsXCJ3ZWlnaHRzXCIsXCJtZWFuU3F1YXJlZEVycm9yXCIpKSxhc3NlcnRTaGFwZXNNYXRjaChvLnNoYXBlLGEuc2hhcGUsXCJFcnJvciBpbiBtZWFuU3F1YXJlZEVycm9yOiBcIik7dmFyIHM9by5zcXVhcmVkRGlmZmVyZW5jZShhKTtyZXR1cm4gY29tcHV0ZVdlaWdodGVkTG9zcyhzLGksbil9ZnVuY3Rpb24gY29zaW5lRGlzdGFuY2VfKGUsdCxyLG4sbyl7dm9pZCAwPT09byYmKG89UmVkdWN0aW9uLlNVTV9CWV9OT05aRVJPX1dFSUdIVFMpO3ZhciBhPWNvbnZlcnRUb1RlbnNvcihlLFwibGFiZWxzXCIsXCJjb3NpbmVEaXN0YW5jZVwiKSxpPWNvbnZlcnRUb1RlbnNvcih0LFwicHJlZGljdGlvbnNcIixcImNvc2luZURpc3RhbmNlXCIpLHM9bnVsbDtudWxsIT1uJiYocz1jb252ZXJ0VG9UZW5zb3IobixcIndlaWdodHNcIixcImNvc2luZURpc3RhbmNlXCIpKSxhc3NlcnRTaGFwZXNNYXRjaChhLnNoYXBlLGkuc2hhcGUsXCJFcnJvciBpbiBjb3NpbmVEaXN0YW5jZTogXCIpO3ZhciB1PXNjYWxhcigxKS5zdWIoYS5tdWwoaSkuc3VtKHIsITApKTtyZXR1cm4gY29tcHV0ZVdlaWdodGVkTG9zcyh1LHMsbyl9ZnVuY3Rpb24gaGluZ2VMb3NzXyhlLHQscixuKXt2b2lkIDA9PT1uJiYobj1SZWR1Y3Rpb24uU1VNX0JZX05PTlpFUk9fV0VJR0hUUyk7dmFyIG89Y29udmVydFRvVGVuc29yKGUsXCJsYWJlbHNcIixcImhpbmdlTG9zc1wiKSxhPWNvbnZlcnRUb1RlbnNvcih0LFwicHJlZGljdGlvbnNcIixcImhpbmdlTG9zc1wiKSxpPW51bGw7bnVsbCE9ciYmKGk9Y29udmVydFRvVGVuc29yKHIsXCJ3ZWlnaHRzXCIsXCJoaW5nZUxvc3NcIikpLGFzc2VydFNoYXBlc01hdGNoKG8uc2hhcGUsYS5zaGFwZSxcIkVycm9yIGluIGhpbmdlTG9zczogXCIpO3ZhciBzPXNjYWxhcigxKTtvPXNjYWxhcigyKS5tdWwobykuc3ViKHMpO3ZhciB1PXMuc3ViKG8ubXVsKGEpKS5yZWx1KCk7cmV0dXJuIGNvbXB1dGVXZWlnaHRlZExvc3ModSxpLG4pfWZ1bmN0aW9uIGxvZ0xvc3NfKGUsdCxyLG4sbyl7dm9pZCAwPT09biYmKG49MWUtNyksdm9pZCAwPT09byYmKG89UmVkdWN0aW9uLlNVTV9CWV9OT05aRVJPX1dFSUdIVFMpO3ZhciBhPWNvbnZlcnRUb1RlbnNvcihlLFwibGFiZWxzXCIsXCJsb2dMb3NzXCIpLGk9Y29udmVydFRvVGVuc29yKHQsXCJwcmVkaWN0aW9uc1wiLFwibG9nTG9zc1wiKSxzPW51bGw7bnVsbCE9ciYmKHM9Y29udmVydFRvVGVuc29yKHIsXCJ3ZWlnaHRzXCIsXCJsb2dMb3NzXCIpKSxhc3NlcnRTaGFwZXNNYXRjaChhLnNoYXBlLGkuc2hhcGUsXCJFcnJvciBpbiBsb2dMb3NzOiBcIik7dmFyIHU9c2NhbGFyKDEpLGw9c2NhbGFyKG4pLGM9YS5tdWwoaS5hZGQobCkubG9nKCkpLm5lZygpLnN1Yih1LnN1YihhKS5tdWwodS5zdWIoaSkuYWRkKGwpLmxvZygpKSk7cmV0dXJuIGNvbXB1dGVXZWlnaHRlZExvc3MoYyxzLG8pfWZ1bmN0aW9uIHNpZ21vaWRDcm9zc0VudHJvcHlXaXRoTG9naXRzXyhlLHQpe3ZhciByPWNvbnZlcnRUb1RlbnNvcihlLFwibGFiZWxzXCIsXCJzaWdtb2lkQ3Jvc3NFbnRyb3B5V2l0aExvZ2l0c1wiKSxuPWNvbnZlcnRUb1RlbnNvcih0LFwibG9naXRzXCIsXCJzaWdtb2lkQ3Jvc3NFbnRyb3B5V2l0aExvZ2l0c1wiKTthc3NlcnRTaGFwZXNNYXRjaChyLnNoYXBlLG4uc2hhcGUsXCJFcnJvciBpbiBzaWdtb2lkQ3Jvc3NFbnRyb3B5V2l0aExvZ2l0czogXCIpO3ZhciBvPW4ucmVsdSgpLGE9bi5tdWwociksaT1uLmFicygpLm5lZygpLmV4cCgpLmxvZzFwKCk7cmV0dXJuIG8uc3ViKGEpLmFkZChpKX1mdW5jdGlvbiBzaWdtb2lkQ3Jvc3NFbnRyb3B5XyhlLHQscixuLG8pe3ZvaWQgMD09PW4mJihuPTApLHZvaWQgMD09PW8mJihvPVJlZHVjdGlvbi5TVU1fQllfTk9OWkVST19XRUlHSFRTKTt2YXIgYT1jb252ZXJ0VG9UZW5zb3IoZSxcIm11bHRpQ2xhc3NMYWJlbHNcIixcInNpZ21vaWRDcm9zc0VudHJvcHlcIiksaT1jb252ZXJ0VG9UZW5zb3IodCxcImxvZ2l0c1wiLFwic2lnbW9pZENyb3NzRW50cm9weVwiKSxzPW51bGw7aWYobnVsbCE9ciYmKHM9Y29udmVydFRvVGVuc29yKHIsXCJ3ZWlnaHRzXCIsXCJzaWdtb2lkQ3Jvc3NFbnRyb3B5XCIpKSxhc3NlcnRTaGFwZXNNYXRjaChhLnNoYXBlLGkuc2hhcGUsXCJFcnJvciBpbiBzaWdtb2lkQ3Jvc3NFbnRyb3B5OiBcIiksbj4wKXt2YXIgdT1zY2FsYXIobiksbD1zY2FsYXIoMSksYz1zY2FsYXIoLjUpO2E9YS5tdWwobC5zdWIodSkpLmFkZChjLm11bCh1KSl9dmFyIHA9c2lnbW9pZENyb3NzRW50cm9weVdpdGhMb2dpdHNfKGEsaSk7cmV0dXJuIGNvbXB1dGVXZWlnaHRlZExvc3MocCxzLG8pfWZ1bmN0aW9uIGh1YmVyTG9zc18oZSx0LHIsbixvKXt2b2lkIDA9PT1uJiYobj0xKSx2b2lkIDA9PT1vJiYobz1SZWR1Y3Rpb24uU1VNX0JZX05PTlpFUk9fV0VJR0hUUyk7dmFyIGE9Y29udmVydFRvVGVuc29yKGUsXCJsYWJlbHNcIixcImh1YmVyTG9zc1wiKSxpPWNvbnZlcnRUb1RlbnNvcih0LFwicHJlZGljdGlvbnNcIixcImh1YmVyTG9zc1wiKSxzPW51bGw7bnVsbCE9ciYmKHM9Y29udmVydFRvVGVuc29yKHIsXCJ3ZWlnaHRzXCIsXCJodWJlckxvc3NcIikpLGFzc2VydFNoYXBlc01hdGNoKGEuc2hhcGUsaS5zaGFwZSxcIkVycm9yIGluIGh1YmVyTG9zczogXCIpO3ZhciB1PXNjYWxhcihuKSxsPWkuc3ViKGEpLmFicygpLGM9bWluaW11bShsLHUpLHA9bC5zdWIoYyksZD1zY2FsYXIoLjUpLm11bChjLnNxdWFyZSgpKS5hZGQodS5tdWwocCkpO3JldHVybiBjb21wdXRlV2VpZ2h0ZWRMb3NzKGQscyxvKX1mdW5jdGlvbiBzb2Z0bWF4Q3Jvc3NFbnRyb3B5V2l0aExvZ2l0c18oZSx0LHIpe2lmKHZvaWQgMD09PXImJihyPS0xKSwtMT09PXImJihyPXQucmFuay0xKSxyIT09dC5yYW5rLTEpdGhyb3cgRXJyb3IoXCJTb2Z0bWF4IGNyb3NzIGVudHJvcHkgYWxvbmcgYSBub24tbGFzdCBkaW1lbnNpb24gaXMgbm90IHlldCBzdXBwb3J0ZWQuIExhYmVscyAvIGxvZ2l0cyB3YXMgcmFuayBcIit0LnJhbmsrXCIgYW5kIGRpbSB3YXMgXCIrcik7cmV0dXJuIGN1c3RvbUdyYWQoZnVuY3Rpb24oZSx0KXt2YXIgbj10LmxvZ1N1bUV4cChbcl0sITApLG89dC50b0Zsb2F0KCkuc3ViKG4pO3JldHVybnt2YWx1ZTpvLm11bChlKS5uZWcoKS5zdW0oW3JdKSxncmFkRnVuYzpmdW5jdGlvbih0KXt2YXIgbj1leHBhbmRTaGFwZVRvS2VlcERpbSh0LnNoYXBlLFtyXSk7cmV0dXJuW3QucmVzaGFwZShuKS5tdWwoZS50b0Zsb2F0KCkuc3ViKG8uZXhwKCkpKSx0LnJlc2hhcGUobikubXVsKG8uZXhwKCkuc3ViKGUudG9GbG9hdCgpKSldfX19KShlLHQpfWZ1bmN0aW9uIHNvZnRtYXhDcm9zc0VudHJvcHlfKGUsdCxyLG4sbyl7dm9pZCAwPT09biYmKG49MCksdm9pZCAwPT09byYmKG89UmVkdWN0aW9uLlNVTV9CWV9OT05aRVJPX1dFSUdIVFMpO3ZhciBhPWNvbnZlcnRUb1RlbnNvcihlLFwib25laG90TGFiZWxzXCIsXCJzb2Z0bWF4Q3Jvc3NFbnRyb3B5XCIpLGk9Y29udmVydFRvVGVuc29yKHQsXCJsb2dpdHNcIixcInNvZnRtYXhDcm9zc0VudHJvcHlcIikscz1udWxsO2lmKG51bGwhPXImJihzPWNvbnZlcnRUb1RlbnNvcihyLFwid2VpZ2h0c1wiLFwic29mdG1heENyb3NzRW50cm9weVwiKSksYXNzZXJ0U2hhcGVzTWF0Y2goYS5zaGFwZSxpLnNoYXBlLFwiRXJyb3IgaW4gc29mdG1heENyb3NzRW50cm9weTogXCIpLG4+MCl7dmFyIHU9c2NhbGFyKG4pLGw9c2NhbGFyKDEpLGM9c2NhbGFyKGEuc2hhcGVbMV0pO2E9YS5tdWwobC5zdWIodSkpLmFkZCh1LmRpdihjKSl9dmFyIHA9c29mdG1heENyb3NzRW50cm9weVdpdGhMb2dpdHNfKGEsaSk7cmV0dXJuIGNvbXB1dGVXZWlnaHRlZExvc3MocCxzLG8pfSFmdW5jdGlvbihlKXtlW2UuTk9ORT0wXT1cIk5PTkVcIixlW2UuTUVBTj0xXT1cIk1FQU5cIixlW2UuU1VNPTJdPVwiU1VNXCIsZVtlLlNVTV9CWV9OT05aRVJPX1dFSUdIVFM9M109XCJTVU1fQllfTk9OWkVST19XRUlHSFRTXCJ9KFJlZHVjdGlvbnx8KFJlZHVjdGlvbj17fSkpO3ZhciBhYnNvbHV0ZURpZmZlcmVuY2U9b3Aoe2Fic29sdXRlRGlmZmVyZW5jZV86YWJzb2x1dGVEaWZmZXJlbmNlX30pLGNvbXB1dGVXZWlnaHRlZExvc3M9b3Aoe2NvbXB1dGVXZWlnaHRlZExvc3NfOmNvbXB1dGVXZWlnaHRlZExvc3NffSksY29zaW5lRGlzdGFuY2U9b3Aoe2Nvc2luZURpc3RhbmNlXzpjb3NpbmVEaXN0YW5jZV99KSxoaW5nZUxvc3M9b3Aoe2hpbmdlTG9zc186aGluZ2VMb3NzX30pLGh1YmVyTG9zcz1vcCh7aHViZXJMb3NzXzpodWJlckxvc3NffSksbG9nTG9zcz1vcCh7bG9nTG9zc186bG9nTG9zc199KSxtZWFuU3F1YXJlZEVycm9yPW9wKHttZWFuU3F1YXJlZEVycm9yXzptZWFuU3F1YXJlZEVycm9yX30pLHNpZ21vaWRDcm9zc0VudHJvcHk9b3Aoe3NpZ21vaWRDcm9zc0VudHJvcHlfOnNpZ21vaWRDcm9zc0VudHJvcHlffSksc29mdG1heENyb3NzRW50cm9weT1vcCh7c29mdG1heENyb3NzRW50cm9weV86c29mdG1heENyb3NzRW50cm9weV99KSxsb3NzX29wcz1PYmplY3QuZnJlZXplKHtnZXQgUmVkdWN0aW9uKCl7cmV0dXJuIFJlZHVjdGlvbn0sYWJzb2x1dGVEaWZmZXJlbmNlOmFic29sdXRlRGlmZmVyZW5jZSxjb21wdXRlV2VpZ2h0ZWRMb3NzOmNvbXB1dGVXZWlnaHRlZExvc3MsY29zaW5lRGlzdGFuY2U6Y29zaW5lRGlzdGFuY2UsaGluZ2VMb3NzOmhpbmdlTG9zcyxodWJlckxvc3M6aHViZXJMb3NzLGxvZ0xvc3M6bG9nTG9zcyxtZWFuU3F1YXJlZEVycm9yOm1lYW5TcXVhcmVkRXJyb3Isc2lnbW9pZENyb3NzRW50cm9weTpzaWdtb2lkQ3Jvc3NFbnRyb3B5LHNvZnRtYXhDcm9zc0VudHJvcHk6c29mdG1heENyb3NzRW50cm9weX0pO2Z1bmN0aW9uIGdyYW1TY2htaWR0XyhlKXt2YXIgdDtpZihBcnJheS5pc0FycmF5KGUpKXt0PSExLGFzc2VydChudWxsIT1lJiZlLmxlbmd0aD4wLFwiR3JhbS1TY2htaWR0IHByb2Nlc3M6IGlucHV0IG11c3Qgbm90IGJlIG51bGwsIHVuZGVmaW5lZCwgb3IgZW1wdHlcIik7Zm9yKHZhciByPWVbMF0uc2hhcGVbMF0sbj0xO248ZS5sZW5ndGg7KytuKWFzc2VydChlW25dLnNoYXBlWzBdPT09cixcIkdyYW0tU2NobWlkdDogTm9uLXVuaXF1ZSBsZW5ndGhzIGZvdW5kIGluIHRoZSBpbnB1dCB2ZWN0b3JzOiAoXCIrZVtuXS5zaGFwZVswXStcIiB2cy4gXCIrcitcIilcIil9ZWxzZSB0PSEwLGU9c3BsaXQkMShlLGUuc2hhcGVbMF0sMCkubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBzcXVlZXplKGUsWzBdKX0pO2Fzc2VydChlLmxlbmd0aDw9ZVswXS5zaGFwZVswXSxcIkdyYW0tU2NobWlkdDogTnVtYmVyIG9mIHZlY3RvcnMgKFwiK2UubGVuZ3RoK1wiKSBleGNlZWRzIG51bWJlciBvZiBkaW1lbnNpb25zIChcIitlWzBdLnNoYXBlWzBdK1wiKS5cIik7dmFyIG89W10sYT1lLGk9ZnVuY3Rpb24oZSl7by5wdXNoKEVOVi5lbmdpbmUudGlkeShmdW5jdGlvbigpe3ZhciB0PWFbZV07aWYoZT4wKWZvcih2YXIgcj0wO3I8ZTsrK3Ipe3ZhciBuPXN1bSQxKG9bcl0ubXVsU3RyaWN0KHQpKS5tdWwob1tyXSk7dD10LnN1YihuKX1yZXR1cm4gdC5kaXYobm9ybSh0LFwiZXVjbGlkZWFuXCIpKX0pKX07Zm9yKG49MDtuPGUubGVuZ3RoOysrbilpKG4pO3JldHVybiB0P3N0YWNrKG8sMCk6b31mdW5jdGlvbiBxcl8oZSx0KXtpZih2b2lkIDA9PT10JiYodD0hMSksZS5yYW5rPDIpdGhyb3cgbmV3IEVycm9yKFwicXIoKSByZXF1aXJlcyBpbnB1dCB0ZW5zb3IgdG8gaGF2ZSBhIHJhbmsgPj0gMiwgYnV0IGdvdCByYW5rIFwiK2UucmFuayk7aWYoMj09PWUucmFuaylyZXR1cm4gcXIyZChlLHQpO3ZhciByPWUuc2hhcGUuc2xpY2UoMCxlLnNoYXBlLmxlbmd0aC0yKS5yZWR1Y2UoZnVuY3Rpb24oZSx0KXtyZXR1cm4gZSp0fSksbj1bXSxvPVtdO3JldHVybiB1bnN0YWNrKGUucmVzaGFwZShbcixlLnNoYXBlW2Uuc2hhcGUubGVuZ3RoLTJdLGUuc2hhcGVbZS5zaGFwZS5sZW5ndGgtMV1dKSwwKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciByPXFyMmQoZSx0KSxhPXJbMF0saT1yWzFdO24ucHVzaChhKSxvLnB1c2goaSl9KSxbc3RhY2sobiwwKS5yZXNoYXBlKGUuc2hhcGUpLHN0YWNrKG8sMCkucmVzaGFwZShlLnNoYXBlKV19ZnVuY3Rpb24gcXIyZChlLHQpe3JldHVybiB2b2lkIDA9PT10JiYodD0hMSksRU5WLmVuZ2luZS50aWR5KGZ1bmN0aW9uKCl7aWYoMiE9PWUuc2hhcGUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInFyMmQoKSByZXF1aXJlcyBhIDJEIFRlbnNvciwgYnV0IGdvdCBhIFwiK2Uuc2hhcGUubGVuZ3RoK1wiRCBUZW5zb3IuXCIpO2Zvcih2YXIgcj1lLnNoYXBlWzBdLG49ZS5zaGFwZVsxXSxvPWV5ZShyKSxhPWUuY2xvbmUoKSxpPXRlbnNvcjJkKFtbMV1dLFsxLDFdKSxzPWkuY2xvbmUoKSx1PXI+PW4/bjpyLGw9ZnVuY3Rpb24oZSl7dmFyIHQsdT1hLGw9cyxjPW87dD1FTlYuZW5naW5lLnRpZHkoZnVuY3Rpb24oKXt2YXIgdD1hLnNsaWNlKFtlLGVdLFtyLWUsMV0pLHU9dC5ub3JtKCksbD1hLnNsaWNlKFtlLGVdLFsxLDFdKSxjPWwuc2lnbigpLm5lZygpLHA9bC5zdWIoYy5tdWwodSkpLGQ9dC5kaXYocCk7cz0xPT09ZC5zaGFwZVswXT9pLmNsb25lKCk6aS5jb25jYXQoZC5zbGljZShbMSwwXSxbZC5zaGFwZVswXS0xLGQuc2hhcGVbMV1dKSwwKTt2YXIgaD1jLm1hdE11bChwKS5kaXYodSkubmVnKCksZj1hLnNsaWNlKFtlLDBdLFtyLWUsbl0pLG09aC5tdWwocyk7YT0wPT09ZT9mLnN1YihtLm1hdE11bChzLnRyYW5zcG9zZSgpLm1hdE11bChmKSkpOmEuc2xpY2UoWzAsMF0sW2Usbl0pLmNvbmNhdChmLnN1YihtLm1hdE11bChzLnRyYW5zcG9zZSgpLm1hdE11bChmKSkpLDApO3ZhciBnPW8uc2xpY2UoWzAsZV0sW3Isby5zaGFwZVsxXS1lXSk7cmV0dXJuIG89MD09PWU/Zy5zdWIoZy5tYXRNdWwocykubWF0TXVsKG0udHJhbnNwb3NlKCkpKTpvLnNsaWNlKFswLDBdLFtyLGVdKS5jb25jYXQoZy5zdWIoZy5tYXRNdWwocykubWF0TXVsKG0udHJhbnNwb3NlKCkpKSwxKSxbcyxhLG9dfSkscz10WzBdLGE9dFsxXSxvPXRbMl0sZGlzcG9zZShbdSxsLGNdKX0sYz0wO2M8dTsrK2MpbChjKTtyZXR1cm4hdCYmcj5uJiYobz1vLnNsaWNlKFswLDBdLFtyLG5dKSxhPWEuc2xpY2UoWzAsMF0sW24sbl0pKSxbbyxhXX0pfXZhciBncmFtU2NobWlkdD1vcCh7Z3JhbVNjaG1pZHRfOmdyYW1TY2htaWR0X30pLHFyPW9wKHtxcl86cXJffSksbGluYWxnX29wcz1PYmplY3QuZnJlZXplKHtncmFtU2NobWlkdDpncmFtU2NobWlkdCxxcjpxcn0pO2Z1bmN0aW9uIHJlc2l6ZUJpbGluZWFyXyhlLHQscil7dm9pZCAwPT09ciYmKHI9ITEpO3ZhciBuPWNvbnZlcnRUb1RlbnNvcihlLFwiaW1hZ2VzXCIsXCJyZXNpemVCaWxpbmVhclwiKTthc3NlcnQoMz09PW4ucmFua3x8ND09PW4ucmFuayxcIkVycm9yIGluIHJlc2l6ZUJpbGluZWFyOiB4IG11c3QgYmUgcmFuayAzIG9yIDQsIGJ1dCBnb3QgcmFuayBcIituLnJhbmsrXCIuXCIpLGFzc2VydCgyPT09dC5sZW5ndGgsXCJFcnJvciBpbiByZXNpemVCaWxpbmVhcjogbmV3IHNoYXBlIG11c3QgMkQsIGJ1dCBnb3Qgc2hhcGUgXCIrdCtcIi5cIik7dmFyIG89bixhPSExOzM9PT1uLnJhbmsmJihhPSEwLG89bi5hczREKDEsbi5zaGFwZVswXSxuLnNoYXBlWzFdLG4uc2hhcGVbMl0pKTt2YXIgaT10WzBdLHM9dFsxXSx1PUVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUucmVzaXplQmlsaW5lYXIobyxpLHMscil9LHtiYXRjaEltYWdlczpvfSxmdW5jdGlvbihlLHQpe3JldHVybntiYXRjaEltYWdlczpmdW5jdGlvbigpe3JldHVybiBFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5yZXNpemVCaWxpbmVhckJhY2twcm9wKGUsbyxyKX0se30pfX19KTtyZXR1cm4gYT91LmFzM0QodS5zaGFwZVsxXSx1LnNoYXBlWzJdLHUuc2hhcGVbM10pOnV9ZnVuY3Rpb24gcmVzaXplTmVhcmVzdE5laWdoYm9yXyhlLHQscil7dm9pZCAwPT09ciYmKHI9ITEpO3ZhciBuPWNvbnZlcnRUb1RlbnNvcihlLFwiaW1hZ2VzXCIsXCJyZXNpemVOZWFyZXN0TmVpZ2hib3JcIik7YXNzZXJ0KDM9PT1uLnJhbmt8fDQ9PT1uLnJhbmssXCJFcnJvciBpbiByZXNpemVOZWFyZXN0TmVpZ2hib3I6IHggbXVzdCBiZSByYW5rIDMgb3IgNCwgYnV0IGdvdCByYW5rIFwiK24ucmFuaytcIi5cIiksYXNzZXJ0KDI9PT10Lmxlbmd0aCxcIkVycm9yIGluIHJlc2l6ZU5lYXJlc3ROZWlnaGJvcjogbmV3IHNoYXBlIG11c3QgMkQsIGJ1dCBnb3Qgc2hhcGUgXCIrdCtcIi5cIiksYXNzZXJ0KFwiZmxvYXQzMlwiPT09bi5kdHlwZXx8XCJpbnQzMlwiPT09bi5kdHlwZSxcImBpbWFnZXNgIG11c3QgaGF2ZSBgaW50MzJgIG9yIGBmbG9hdDMyYCBhcyBkdHlwZVwiKTt2YXIgbz1uLGE9ITE7Mz09PW4ucmFuayYmKGE9ITAsbz1uLmFzNEQoMSxuLnNoYXBlWzBdLG4uc2hhcGVbMV0sbi5zaGFwZVsyXSkpO3ZhciBpPXRbMF0scz10WzFdLHU9RU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS5yZXNpemVOZWFyZXN0TmVpZ2hib3IobyxpLHMscil9LHtiYXRjaEltYWdlczpvfSxmdW5jdGlvbihlLHQpe3JldHVybntiYXRjaEltYWdlczpmdW5jdGlvbigpe3JldHVybiBFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5yZXNpemVOZWFyZXN0TmVpZ2hib3JCYWNrcHJvcChlLG8scil9LHt9KX19fSk7cmV0dXJuIGE/dS5hczNEKHUuc2hhcGVbMV0sdS5zaGFwZVsyXSx1LnNoYXBlWzNdKTp1fWZ1bmN0aW9uIG5vbk1heFN1cHByZXNzaW9uXyhlLHQscixuLG8pe3ZvaWQgMD09PW4mJihuPS41KSx2b2lkIDA9PT1vJiYobz1OdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpO3ZhciBhPWNvbnZlcnRUb1RlbnNvcihlLFwiYm94ZXNcIixcIm5vbk1heFN1cHByZXNzaW9uXCIpLGk9Y29udmVydFRvVGVuc29yKHQsXCJzY29yZXNcIixcIm5vbk1heFN1cHByZXNzaW9uXCIpLHM9bm9uTWF4U3VwcFNhbml0eUNoZWNrKGEsaSxyLG4sbyk7cmV0dXJuIHI9cy5tYXhPdXRwdXRTaXplLG49cy5pb3VUaHJlc2hvbGQsbz1zLnNjb3JlVGhyZXNob2xkLEVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKGUpe3JldHVybiBlLm5vbk1heFN1cHByZXNzaW9uKGEsaSxyLG4sbyl9LHskYm94ZXM6YX0pfWZ1bmN0aW9uIG5vbk1heFN1cHByZXNzaW9uQXN5bmNfKGUsdCxyLG4sbyl7cmV0dXJuIHZvaWQgMD09PW4mJihuPS41KSx2b2lkIDA9PT1vJiYobz1OdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpLF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgYSxpLHMsdSxsLGM7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24ocCl7c3dpdGNoKHAubGFiZWwpe2Nhc2UgMDpyZXR1cm4gYT1jb252ZXJ0VG9UZW5zb3IoZSxcImJveGVzXCIsXCJub25NYXhTdXBwcmVzc2lvbkFzeW5jXCIpLGk9Y29udmVydFRvVGVuc29yKHQsXCJzY29yZXNcIixcIm5vbk1heFN1cHByZXNzaW9uQXN5bmNcIikscz1ub25NYXhTdXBwU2FuaXR5Q2hlY2soYSxpLHIsbixvKSxyPXMubWF4T3V0cHV0U2l6ZSxuPXMuaW91VGhyZXNob2xkLG89cy5zY29yZVRocmVzaG9sZCxbNCxhLmRhdGEoKV07Y2FzZSAxOnJldHVybiB1PXAuc2VudCgpLFs0LGkuZGF0YSgpXTtjYXNlIDI6cmV0dXJuIGw9cC5zZW50KCksYz1ub25NYXhTdXBwcmVzc2lvbkltcGwodSxsLHIsbixvKSxhIT09ZSYmYS5kaXNwb3NlKCksaSE9PXQmJmkuZGlzcG9zZSgpLFsyLGNdfX0pfSl9ZnVuY3Rpb24gbm9uTWF4U3VwcFNhbml0eUNoZWNrKGUsdCxyLG4sbyl7bnVsbD09biYmKG49LjUpLG51bGw9PW8mJihvPU51bWJlci5ORUdBVElWRV9JTkZJTklUWSk7dmFyIGE9ZS5zaGFwZVswXTtyZXR1cm4gcj1NYXRoLm1pbihyLGEpLGFzc2VydCgwPD1uJiZuPD0xLFwiaW91VGhyZXNob2xkIG11c3QgYmUgaW4gWzAsIDFdLCBidXQgd2FzICdcIituK1wiJ1wiKSxhc3NlcnQoMj09PWUucmFuayxcImJveGVzIG11c3QgYmUgYSAyRCB0ZW5zb3IsIGJ1dCB3YXMgb2YgcmFuayAnXCIrZS5yYW5rK1wiJ1wiKSxhc3NlcnQoND09PWUuc2hhcGVbMV0sXCJib3hlcyBtdXN0IGhhdmUgNCBjb2x1bW5zLCBidXQgMm5kIGRpbWVuc2lvbiB3YXMgXCIrZS5zaGFwZVsxXSksYXNzZXJ0KDE9PT10LnJhbmssXCJzY29yZXMgbXVzdCBiZSBhIDFEIHRlbnNvclwiKSxhc3NlcnQodC5zaGFwZVswXT09PWEsXCJzY29yZXMgaGFzIGluY29tcGF0aWJsZSBzaGFwZSB3aXRoIGJveGVzLiBFeHBlY3RlZCBcIithK1wiLCBidXQgd2FzIFwiK3Quc2hhcGVbMF0pLHttYXhPdXRwdXRTaXplOnIsaW91VGhyZXNob2xkOm4sc2NvcmVUaHJlc2hvbGQ6b319ZnVuY3Rpb24gY3JvcEFuZFJlc2l6ZV8oZSx0LHIsbixvLGEpe3ZhciBpPWNvbnZlcnRUb1RlbnNvcihlLFwiaW1hZ2VcIixcImNyb3BBbmRSZXNpemVcIixcImZsb2F0MzJcIikscz1jb252ZXJ0VG9UZW5zb3IodCxcImJveGVzXCIsXCJjcm9wQW5kUmVzaXplXCIsXCJmbG9hdDMyXCIpLHU9Y29udmVydFRvVGVuc29yKHIsXCJib3hJbmRcIixcImNyb3BBbmRSZXNpemVcIixcImludDMyXCIpO289b3x8XCJiaWxpbmVhclwiLGE9YXx8MDt2YXIgbD1zLnNoYXBlWzBdO2Fzc2VydCg0PT09aS5yYW5rLFwiRXJyb3IgaW4gY3JvcEFuZFJlc2l6ZTogaW1hZ2UgbXVzdCBiZSByYW5rIDQsYnV0IGdvdCByYW5rIFwiK2kucmFuaytcIi5cIiksYXNzZXJ0KDI9PT1zLnJhbmsmJjQ9PT1zLnNoYXBlWzFdLFwiRXJyb3IgaW4gY3JvcEFuZFJlc2l6ZTogYm94ZXMgbXVzdCBiZSBoYXZlIHNpemUgW1wiK2wrXCIsNF0gYnV0IGhhZCBzaGFwZSBcIitzLnNoYXBlK1wiLlwiKSxhc3NlcnQoMT09PXUucmFuayYmdS5zaGFwZVswXT09PWwsXCJFcnJvciBpbiBjcm9wQW5kUmVzaXplOiBib3hJbmQgbXVzdCBiZSBoYXZlIHNpemUgW1wiK2wrXCJdIGJ1dCBoYWQgc2hhcGUgXCIrcy5zaGFwZStcIi5cIiksYXNzZXJ0KFwiaW50MzJcIj09PXUuZHR5cGUsXCJFcnJvciBpbiBjcm9wQW5kUmVzaXplOiBib3hJbmQgbXVzdCBiZSBvZiBkdHlwZSBpbnQzMiwgYnV0IGdvdCBkdHlwZSBcIit1LmR0eXBlK1wiLlwiKSxhc3NlcnQoMj09PW4ubGVuZ3RoLFwiRXJyb3IgaW4gY3JvcEFuZFJlc2l6ZTogY3JvcFNpemUgbXVzdCBiZSBvZiBsZW5ndGggMiwgYnV0IGdvdCBsZW5ndGggXCIrbi5sZW5ndGgrXCIuXCIpLGFzc2VydChuWzBdPj0xJiZuWzFdPj0xLFwiY3JvcFNpemUgbXVzdCBiZSBhdGxlYXN0IFsxLDFdLCBidXQgd2FzIFwiK24pLGFzc2VydChcImJpbGluZWFyXCI9PT1vfHxcIm5lYXJlc3RcIj09PW8sXCJtZXRob2QgbXVzdCBiZSBiaWxpbmVhciBvciBuZWFyZXN0LCBidXQgd2FzIFwiK28pO3JldHVybiBFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbihlLHQpe3JldHVybiBlLmNyb3BBbmRSZXNpemUoaSxzLHUsbixvLGEpfSx7JGltYWdlOmksJGJveGVzOnN9KX12YXIgcmVzaXplQmlsaW5lYXI9b3Aoe3Jlc2l6ZUJpbGluZWFyXzpyZXNpemVCaWxpbmVhcl99KSxyZXNpemVOZWFyZXN0TmVpZ2hib3I9b3Aoe3Jlc2l6ZU5lYXJlc3ROZWlnaGJvcl86cmVzaXplTmVhcmVzdE5laWdoYm9yX30pLG5vbk1heFN1cHByZXNzaW9uPW9wKHtub25NYXhTdXBwcmVzc2lvbl86bm9uTWF4U3VwcHJlc3Npb25ffSksbm9uTWF4U3VwcHJlc3Npb25Bc3luYz1ub25NYXhTdXBwcmVzc2lvbkFzeW5jXyxjcm9wQW5kUmVzaXplPWNyb3BBbmRSZXNpemVfLGltYWdlX29wcz1PYmplY3QuZnJlZXplKHtyZXNpemVCaWxpbmVhcjpyZXNpemVCaWxpbmVhcixyZXNpemVOZWFyZXN0TmVpZ2hib3I6cmVzaXplTmVhcmVzdE5laWdoYm9yLG5vbk1heFN1cHByZXNzaW9uOm5vbk1heFN1cHByZXNzaW9uLG5vbk1heFN1cHByZXNzaW9uQXN5bmM6bm9uTWF4U3VwcHJlc3Npb25Bc3luYyxjcm9wQW5kUmVzaXplOmNyb3BBbmRSZXNpemV9KSxvcHM9T2JqZWN0LmZyZWV6ZSh7aW1hZ2U6aW1hZ2Vfb3BzLGxpbmFsZzpsaW5hbGdfb3BzLGxvc3Nlczpsb3NzX29wcyxzcGVjdHJhbDpzcGVjdHJhbF9vcHMsb3A6b3AsYmF0Y2hOb3JtYWxpemF0aW9uMmQ6YmF0Y2hOb3JtYWxpemF0aW9uMmQsYmF0Y2hOb3JtYWxpemF0aW9uM2Q6YmF0Y2hOb3JtYWxpemF0aW9uM2QsYmF0Y2hOb3JtYWxpemF0aW9uNGQ6YmF0Y2hOb3JtYWxpemF0aW9uNGQsYmF0Y2hOb3JtYWxpemF0aW9uOmJhdGNoTm9ybWFsaXphdGlvbixjb21wbGV4OmNvbXBsZXgscmVhbDpyZWFsLGltYWc6aW1hZyxjb25jYXQ6Y29uY2F0LGNvbmNhdDFkOmNvbmNhdDFkLGNvbmNhdDJkOmNvbmNhdDJkLGNvbmNhdDNkOmNvbmNhdDNkLGNvbmNhdDRkOmNvbmNhdDRkLHNwbGl0OnNwbGl0JDEsY29udjFkOmNvbnYxZCxjb252MmQ6Y29udjJkLGNvbnYyZERlckZpbHRlcjpjb252MmREZXJGaWx0ZXIsZGVwdGh3aXNlQ29udjJkOmRlcHRod2lzZUNvbnYyZCxzZXBhcmFibGVDb252MmQ6c2VwYXJhYmxlQ29udjJkLGNvbnYyZFRyYW5zcG9zZTpjb252MmRUcmFuc3Bvc2UsbWF0TXVsOm1hdE11bCxkb3Q6ZG90LG91dGVyUHJvZHVjdDpvdXRlclByb2R1Y3QscmV2ZXJzZTpyZXZlcnNlLHJldmVyc2UxZDpyZXZlcnNlMWQscmV2ZXJzZTJkOnJldmVyc2UyZCxyZXZlcnNlM2Q6cmV2ZXJzZTNkLHJldmVyc2U0ZDpyZXZlcnNlNGQsbWF4UG9vbDptYXhQb29sLGF2Z1Bvb2w6YXZnUG9vbCxwb29sOnBvb2wsc2xpY2U6c2xpY2Usc2xpY2UxZDpzbGljZTFkLHNsaWNlMmQ6c2xpY2UyZCxzbGljZTNkOnNsaWNlM2Qsc2xpY2U0ZDpzbGljZTRkLGFiczphYnMsYWNvczphY29zLGFjb3NoOmFjb3NoLGFzaW46YXNpbixhc2luaDphc2luaCxhdGFuOmF0YW4sYXRhbmg6YXRhbmgsY2VpbDpjZWlsLGNsaXBCeVZhbHVlOmNsaXBCeVZhbHVlLGNvczpjb3MsY29zaDpjb3NoLGVyZjplcmYsZXhwOmV4cCxleHBtMTpleHBtMSxmbG9vcjpmbG9vcixsb2c6bG9nJDEsbG9nMXA6bG9nMXAsbG9nU2lnbW9pZDpsb2dTaWdtb2lkLG5lZzpuZWcscmVjaXByb2NhbDpyZWNpcHJvY2FsLHJvdW5kOnJvdW5kLHJzcXJ0OnJzcXJ0LHNpZ21vaWQ6c2lnbW9pZCxzaWduOnNpZ24sc2luOnNpbixzaW5oOnNpbmgsc29mdHBsdXM6c29mdHBsdXMsc3FydDpzcXJ0LHNxdWFyZTpzcXVhcmUsc3RlcDpzdGVwLHRhbjp0YW4sdGFuaDp0YW5oJDEsYWxsOmFsbCxhbnk6YW55LGFyZ01heDphcmdNYXgsYXJnTWluOmFyZ01pbixsb2dTdW1FeHA6bG9nU3VtRXhwLG1heDptYXgsbWVhbjptZWFuLG1pbjptaW4sbW9tZW50czptb21lbnRzLHN1bTpzdW0kMSxwcm9kOnByb2QsZXF1YWw6ZXF1YWwsZXF1YWxTdHJpY3Q6ZXF1YWxTdHJpY3QsZ3JlYXRlcjpncmVhdGVyLGdyZWF0ZXJFcXVhbDpncmVhdGVyRXF1YWwsZ3JlYXRlckVxdWFsU3RyaWN0OmdyZWF0ZXJFcXVhbFN0cmljdCxncmVhdGVyU3RyaWN0OmdyZWF0ZXJTdHJpY3QsbGVzczpsZXNzLGxlc3NFcXVhbDpsZXNzRXF1YWwsbGVzc0VxdWFsU3RyaWN0Omxlc3NFcXVhbFN0cmljdCxsZXNzU3RyaWN0Omxlc3NTdHJpY3Qsbm90RXF1YWw6bm90RXF1YWwsbm90RXF1YWxTdHJpY3Q6bm90RXF1YWxTdHJpY3QsYWRkOmFkZCxhZGROOmFkZE4sYWRkU3RyaWN0OmFkZFN0cmljdCxhdGFuMjphdGFuMixkaXY6ZGl2LGRpdlN0cmljdDpkaXZTdHJpY3QsZmxvb3JEaXY6Zmxvb3JEaXYsbWF4aW11bTptYXhpbXVtLG1heGltdW1TdHJpY3Q6bWF4aW11bVN0cmljdCxtaW5pbXVtOm1pbmltdW0sbWluaW11bVN0cmljdDptaW5pbXVtU3RyaWN0LG1vZDptb2QsbW9kU3RyaWN0Om1vZFN0cmljdCxtdWw6bXVsLG11bFN0cmljdDptdWxTdHJpY3QscG93OnBvdyxwb3dTdHJpY3Q6cG93U3RyaWN0LHNxdWFyZWREaWZmZXJlbmNlOnNxdWFyZWREaWZmZXJlbmNlLHNxdWFyZWREaWZmZXJlbmNlU3RyaWN0OnNxdWFyZWREaWZmZXJlbmNlU3RyaWN0LHN1YjpzdWIsc3ViU3RyaWN0OnN1YlN0cmljdCxlbHU6ZWx1LGxlYWt5UmVsdTpsZWFreVJlbHUscHJlbHU6cHJlbHUscmVsdTpyZWx1LHNlbHU6c2VsdSxsb2dpY2FsQW5kOmxvZ2ljYWxBbmQsbG9naWNhbE5vdDpsb2dpY2FsTm90LGxvZ2ljYWxPcjpsb2dpY2FsT3IsbG9naWNhbFhvcjpsb2dpY2FsWG9yLHdoZXJlOndoZXJlLHdoZXJlQXN5bmM6d2hlcmVBc3luYyxidWZmZXI6YnVmZmVyLHRvUGl4ZWxzOnRvUGl4ZWxzLHByaW50OnByaW50LGJhdGNoVG9TcGFjZU5EOmJhdGNoVG9TcGFjZU5ELGNhc3Q6Y2FzdCxjbG9uZTpjbG9uZSxjdW1zdW06Y3Vtc3VtLGRlcHRoVG9TcGFjZTpkZXB0aFRvU3BhY2UsZXhwYW5kRGltczpleHBhbmREaW1zLGV5ZTpleWUsZnJvbVBpeGVsczpmcm9tUGl4ZWxzLG11bHRpbm9taWFsOm11bHRpbm9taWFsLG9uZUhvdDpvbmVIb3QscGFkOnBhZCxwYWQxZDpwYWQxZCxwYWQyZDpwYWQyZCxwYWQzZDpwYWQzZCxwYWQ0ZDpwYWQ0ZCxyYW5kOnJhbmQscmFuZG9tTm9ybWFsOnJhbmRvbU5vcm1hbCxyYW5kb21Vbmlmb3JtOnJhbmRvbVVuaWZvcm0scmVzaGFwZTpyZXNoYXBlLHNwYWNlVG9CYXRjaE5EOnNwYWNlVG9CYXRjaE5ELHNxdWVlemU6c3F1ZWV6ZSxzdGFjazpzdGFjayx0aWxlOnRpbGUsdHJ1bmNhdGVkTm9ybWFsOnRydW5jYXRlZE5vcm1hbCx1bnN0YWNrOnVuc3RhY2ssc2V0ZGlmZjFkQXN5bmM6c2V0ZGlmZjFkQXN5bmMsZmlsbDpmaWxsLGxpbnNwYWNlOmxpbnNwYWNlLG9uZXM6b25lcyQxLHJhbmdlOnJhbmdlLHNjYWxhcjpzY2FsYXIsdGVuc29yOnRlbnNvcix0ZW5zb3IxZDp0ZW5zb3IxZCx0ZW5zb3IyZDp0ZW5zb3IyZCx0ZW5zb3IzZDp0ZW5zb3IzZCx0ZW5zb3I0ZDp0ZW5zb3I0ZCx0ZW5zb3I1ZDp0ZW5zb3I1ZCx0ZW5zb3I2ZDp0ZW5zb3I2ZCx6ZXJvczp6ZXJvcyxvbmVzTGlrZTpvbmVzTGlrZSx6ZXJvc0xpa2U6emVyb3NMaWtlLHRyYW5zcG9zZTp0cmFuc3Bvc2Usc29mdG1heDpzb2Z0bWF4LGxvZ1NvZnRtYXg6bG9nU29mdG1heCxsb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbjpsb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbixub3JtOm5vcm0sZ2F0aGVyOmdhdGhlcix1bnNvcnRlZFNlZ21lbnRTdW06dW5zb3J0ZWRTZWdtZW50U3VtLGJhc2ljTFNUTUNlbGw6YmFzaWNMU1RNQ2VsbCxtdWx0aVJOTkNlbGw6bXVsdGlSTk5DZWxsLG1vdmluZ0F2ZXJhZ2U6bW92aW5nQXZlcmFnZSxzdHJpZGVkU2xpY2U6c3RyaWRlZFNsaWNlLHRvcGs6dG9wayxzY2F0dGVyTkQ6c2NhdHRlck5ELGZmdDpmZnQsaWZmdDppZmZ0LHJmZnQ6cmZmdCxzcGFyc2VUb0RlbnNlOnNwYXJzZVRvRGVuc2UsZ2F0aGVyTkQ6Z2F0aGVyTkR9KSxNYXRoQmFja2VuZENQVT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXt0aGlzLmJsb2NrU2l6ZT00OCx0aGlzLmZpcnN0VXNlPSEwLEVOVi5nZXQoXCJJU19CUk9XU0VSXCIpJiYodGhpcy5mcm9tUGl4ZWxzMkRDb250ZXh0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIikuZ2V0Q29udGV4dChcIjJkXCIpKX1yZXR1cm4gZS5wcm90b3R5cGUuc2V0RGF0YU1vdmVyPWZ1bmN0aW9uKGUpe3RoaXMuZGF0YT1uZXcgRGF0YVN0b3JhZ2UoZSl9LGUucHJvdG90eXBlLnJlZ2lzdGVyPWZ1bmN0aW9uKGUsdCxyKXtpZih0aGlzLmZpcnN0VXNlJiYodGhpcy5maXJzdFVzZT0hMSxFTlYuZ2V0KFwiSVNfTk9ERVwiKSYmd2FybihcIlxcbj09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG5IaSB0aGVyZSDwn5GLLiBMb29rcyBsaWtlIHlvdSBhcmUgcnVubmluZyBUZW5zb3JGbG93LmpzIGluIE5vZGUuanMuIFRvIHNwZWVkIHRoaW5ncyB1cCBkcmFtYXRpY2FsbHksIGluc3RhbGwgb3VyIG5vZGUgYmFja2VuZCwgd2hpY2ggYmluZHMgdG8gVGVuc29yRmxvdyBDKyssIGJ5IHJ1bm5pbmcgbnBtIGkgQHRlbnNvcmZsb3cvdGZqcy1ub2RlLCBvciBucG0gaSBAdGVuc29yZmxvdy90ZmpzLW5vZGUtZ3B1IGlmIHlvdSBoYXZlIENVREEuIFRoZW4gY2FsbCByZXF1aXJlKCdAdGVuc29yZmxvdy90ZmpzLW5vZGUnKTsgKC1ncHUgc3VmZml4IGZvciBDVURBKSBhdCB0aGUgc3RhcnQgb2YgeW91ciBwcm9ncmFtLiBWaXNpdCBodHRwczovL2dpdGh1Yi5jb20vdGVuc29yZmxvdy90ZmpzLW5vZGUgZm9yIG1vcmUgZGV0YWlscy5cXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuXCIpKSx0aGlzLmRhdGEuaGFzKGUpKXRocm93IG5ldyBFcnJvcihcIkRhdGEgYnVmZmVyIGlzIGFscmVhZHkgcmVnaXN0ZXJlZFwiKTt0aGlzLmRhdGEuc2V0KGUse2R0eXBlOnJ9KX0sZS5wcm90b3R5cGUud3JpdGU9ZnVuY3Rpb24oZSx0KXtpZihudWxsPT10KXRocm93IG5ldyBFcnJvcihcIk1hdGhCYWNrZW5kQ1BVLndyaXRlKCk6IHZhbHVlcyBjYW4gbm90IGJlIG51bGxcIik7dGhpcy5kYXRhLmdldChlKS52YWx1ZXM9dH0sZS5wcm90b3R5cGUuZnJvbVBpeGVscz1mdW5jdGlvbihlLHQpe2lmKG51bGw9PWUpdGhyb3cgbmV3IEVycm9yKFwicGl4ZWxzIHBhc3NlZCB0byB0Zi5mcm9tUGl4ZWxzKCkgY2FuIG5vdCBiZSBudWxsXCIpO3ZhciByLG47aWYoRU5WLmdldChcIklTX05PREVcIikmJm51bGw9PWUuZ2V0Q29udGV4dCl0aHJvdyBuZXcgRXJyb3IoXCJXaGVuIHJ1bm5pbmcgaW4gbm9kZSwgcGl4ZWxzIG11c3QgYmUgYW4gSFRNTENhbnZhc0VsZW1lbnQgbGlrZSB0aGUgb25lIHJldHVybmVkIGJ5IHRoZSBgY2FudmFzYCBucG0gcGFja2FnZVwiKTtpZihudWxsIT1lLmdldENvbnRleHQpcj1lLmdldENvbnRleHQoXCIyZFwiKS5nZXRJbWFnZURhdGEoMCwwLGUud2lkdGgsZS5oZWlnaHQpLmRhdGE7ZWxzZSBpZihlIGluc3RhbmNlb2YgSW1hZ2VEYXRhKXI9ZS5kYXRhO2Vsc2V7aWYoIShlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudHx8ZSBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQpKXRocm93IG5ldyBFcnJvcihcInBpeGVscyBwYXNzZWQgdG8gdGYuZnJvbVBpeGVscygpIG11c3QgYmUgZWl0aGVyIGFuIEhUTUxWaWRlb0VsZW1lbnQsIEhUTUxJbWFnZUVsZW1lbnQsIEhUTUxDYW52YXNFbGVtZW50IG9yIEltYWdlRGF0YSwgYnV0IHdhcyBcIitlLmNvbnN0cnVjdG9yLm5hbWUpO2lmKG51bGw9PXRoaXMuZnJvbVBpeGVsczJEQ29udGV4dCl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCByZWFkIHBpeGVscyBmcm9tIEhUTUxJbWFnZUVsZW1lbnQgb3V0c2lkZSB0aGUgYnJvd3Nlci5cIik7dGhpcy5mcm9tUGl4ZWxzMkRDb250ZXh0LmNhbnZhcy53aWR0aD1lLndpZHRoLHRoaXMuZnJvbVBpeGVsczJEQ29udGV4dC5jYW52YXMuaGVpZ2h0PWUuaGVpZ2h0LHRoaXMuZnJvbVBpeGVsczJEQ29udGV4dC5kcmF3SW1hZ2UoZSwwLDAsZS53aWR0aCxlLmhlaWdodCkscj10aGlzLmZyb21QaXhlbHMyRENvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsMCxlLndpZHRoLGUuaGVpZ2h0KS5kYXRhfWlmKDQ9PT10KW49bmV3IEludDMyQXJyYXkocik7ZWxzZXt2YXIgbz1lLndpZHRoKmUuaGVpZ2h0O249bmV3IEludDMyQXJyYXkobyp0KTtmb3IodmFyIGE9MDthPG87YSsrKWZvcih2YXIgaT0wO2k8dDsrK2kpblthKnQraV09cls0KmEraV19cmV0dXJuIHRlbnNvcjNkKG4sW2UuaGVpZ2h0LGUud2lkdGgsdF0sXCJpbnQzMlwiKX0sZS5wcm90b3R5cGUucmVhZD1mdW5jdGlvbihlKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHQpe3JldHVyblsyLHRoaXMucmVhZFN5bmMoZSldfSl9KX0sZS5wcm90b3R5cGUucmVhZFN5bmM9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5kYXRhLmdldChlKSxyPXQuZHR5cGUsbj10LmNvbXBsZXhUZW5zb3JzO3JldHVyblwiY29tcGxleDY0XCI9PT1yP21lcmdlUmVhbEFuZEltYWdBcnJheXMobi5yZWFsLmRhdGFTeW5jKCksbi5pbWFnLmRhdGFTeW5jKCkpOnRoaXMuZGF0YS5nZXQoZSkudmFsdWVzfSxlLnByb3RvdHlwZS5kaXNwb3NlRGF0YT1mdW5jdGlvbihlKXtpZih0aGlzLmRhdGEuaGFzKGUpKXt2YXIgdD10aGlzLmRhdGEuZ2V0KGUpLmNvbXBsZXhUZW5zb3JzO251bGwhPXQmJih0LnJlYWwuZGlzcG9zZSgpLHQuaW1hZy5kaXNwb3NlKCkpLHRoaXMuZGF0YS5kZWxldGUoZSl9fSxlLnByb3RvdHlwZS50aW1lPWZ1bmN0aW9uKGUpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQ7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24ocil7cmV0dXJuIHQ9bm93KCksZSgpLFsyLHtrZXJuZWxNczpub3coKS10fV19KX0pfSxlLnByb3RvdHlwZS5tZW1vcnk9ZnVuY3Rpb24oKXtyZXR1cm57dW5yZWxpYWJsZTohMH19LGUucHJvdG90eXBlLmNvbXBsZXg9ZnVuY3Rpb24oZSx0KXt2YXIgcj1UZW5zb3IubWFrZShlLnNoYXBlLHt9LFwiY29tcGxleDY0XCIpO3JldHVybiB0aGlzLmRhdGEuZ2V0KHIuZGF0YUlkKS5jb21wbGV4VGVuc29ycz17cmVhbDpFTlYuZW5naW5lLmtlZXAoZS5jbG9uZSgpKSxpbWFnOkVOVi5lbmdpbmUua2VlcCh0LmNsb25lKCkpfSxyfSxlLnByb3RvdHlwZS5yZWFsPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmRhdGEuZ2V0KGUuZGF0YUlkKS5jb21wbGV4VGVuc29ycy5yZWFsLmNsb25lKCl9LGUucHJvdG90eXBlLmltYWc9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuZGF0YS5nZXQoZS5kYXRhSWQpLmNvbXBsZXhUZW5zb3JzLmltYWcuY2xvbmUoKX0sZS5wcm90b3R5cGUuYXNzZXJ0Tm90Q29tcGxleD1mdW5jdGlvbihlLHQpe0FycmF5LmlzQXJyYXkoZSl8fChlPVtlXSksZS5mb3JFYWNoKGZ1bmN0aW9uKGUpe251bGwhPWUmJmFzc2VydChcImNvbXBsZXg2NFwiIT09ZS5kdHlwZSx0K1wiIGRvZXMgbm90IHN1cHBvcnQgY29tcGxleDY0IHRlbnNvcnMuXCIpfSl9LGUucHJvdG90eXBlLnNsaWNlPWZ1bmN0aW9uKGUsdCxyKXt0aGlzLmFzc2VydE5vdENvbXBsZXgoZSxcInNsaWNlXCIpO2Zvcih2YXIgbj1idWZmZXIocixlLmR0eXBlKSxvPTA7bzxuLnNpemU7KytvKXt2YXIgYT1uLmluZGV4VG9Mb2MobyksaT1hLm1hcChmdW5jdGlvbihlLHIpe3JldHVybiBlK3Rbcl19KTtuLnNldC5hcHBseShuLFtlLmdldC5hcHBseShlLGkpXS5jb25jYXQoYSkpfXJldHVybiBuLnRvVGVuc29yKCl9LGUucHJvdG90eXBlLnN0cmlkZWRTbGljZT1mdW5jdGlvbihlLHQscixuLG8sYSxpLHMsdSl7dGhpcy5hc3NlcnROb3RDb21wbGV4KGUsXCJzdHJpZGVkU2xpY2VcIik7dmFyIGw9Z2V0U3RyaWRlZFNsaWNlZEluZm8oZS5zaGFwZSx0LHIsbixvLGEsaSxzLHUpLGM9bFswXSxwPWxbMV0sZD1sWzJdLGg9cC5maWx0ZXIoZnVuY3Rpb24oZSx0KXtyZXR1cm4tMT09PWQuaW5kZXhPZih0KX0pO2lmKGguc29tZShmdW5jdGlvbihlKXtyZXR1cm4gMD09PWV9KSlyZXR1cm4gdGVuc29yKFtdLGgpO2Zvcih2YXIgZj1idWZmZXIocCxlLmR0eXBlKSxtPTA7bTxmLnNpemU7bSsrKXtmb3IodmFyIGc9Zi5pbmRleFRvTG9jKG0pLHY9bmV3IEFycmF5KGcubGVuZ3RoKSx5PTA7eTx2Lmxlbmd0aDt5Kyspdlt5XT1nW3ldKm5beV0rY1t5XTtmLnNldC5hcHBseShmLFtlLmdldC5hcHBseShlLHYpXS5jb25jYXQoZykpfXJldHVybiBmLnRvVGVuc29yKCkucmVzaGFwZShoKX0sZS5wcm90b3R5cGUucmV2ZXJzZT1mdW5jdGlvbihlLHQpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChlLFwicmV2ZXJzZVwiKTtmb3IodmFyIHI9YnVmZmVyKGUuc2hhcGUsZS5kdHlwZSksbj1lLmJ1ZmZlcigpLG89ZnVuY3Rpb24obyl7dmFyIGE9ci5pbmRleFRvTG9jKG8pLGk9YS5zbGljZSgpO3QuZm9yRWFjaChmdW5jdGlvbih0KXtyZXR1cm4gaVt0XT1lLnNoYXBlW3RdLTEtaVt0XX0pLHIuc2V0LmFwcGx5KHIsW24uZ2V0LmFwcGx5KG4saSldLmNvbmNhdChhKSl9LGE9MDthPHIuc2l6ZTthKyspbyhhKTtyZXR1cm4gci50b1RlbnNvcigpfSxlLnByb3RvdHlwZS5jb25jYXQ9ZnVuY3Rpb24oZSx0KXt0aGlzLmFzc2VydE5vdENvbXBsZXgoZSxcImNvbmNhdFwiKTt2YXIgcj1lLm1hcChmdW5jdGlvbihlKXt2YXIgcj1zaXplRnJvbVNoYXBlKGUuc2hhcGUuc2xpY2UodCkpO3JldHVybiBlLmFzMkQoLTEscil9KSxuPWNvbXB1dGVPdXRTaGFwZShyLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5zaGFwZX0pLDEpLG89YnVmZmVyKG4sZVswXS5kdHlwZSkudmFsdWVzO2lmKDE9PT1yWzBdLnNoYXBlWzBdKXt2YXIgYT0wO3IuZm9yRWFjaChmdW5jdGlvbihlKXtvLnNldChlLmRhdGFTeW5jKCksYSksYSs9ZS5zaXplfSl9ZWxzZXt2YXIgaT0wO3IuZm9yRWFjaChmdW5jdGlvbihlKXtmb3IodmFyIHQ9ZS5kYXRhU3luYygpLHI9MCxhPTA7YTxlLnNoYXBlWzBdOysrYSlmb3IodmFyIHM9YSpuWzFdK2ksdT0wO3U8ZS5zaGFwZVsxXTsrK3Upb1tzK3VdPXRbcisrXTtpKz1lLnNoYXBlWzFdfSl9dmFyIHM9Y29tcHV0ZU91dFNoYXBlKGUubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLnNoYXBlfSksdCk7cmV0dXJuIHRlbnNvcihvLHMsZVswXS5kdHlwZSl9LGUucHJvdG90eXBlLm5lZz1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5hc3NlcnROb3RDb21wbGV4KGUsXCJuZWdcIiksdGhpcy5tdWx0aXBseShzY2FsYXIoLTEpLGUpfSxlLnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm5cImNvbXBsZXg2NFwiPT09ZS5kdHlwZXx8XCJjb21wbGV4NjRcIj09PXQuZHR5cGU/dGhpcy5icm9hZGNhc3RlZEJpbmFyeUNvbXBsZXhPcChlLmNhc3QoXCJjb21wbGV4NjRcIiksdC5jYXN0KFwiY29tcGxleDY0XCIpLGZ1bmN0aW9uKGUsdCxyLG4pe3JldHVybntyZWFsOmUrcixpbWFnOnQrbn19KTp0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AoZSx0LHVwY2FzdFR5cGUoZS5kdHlwZSx0LmR0eXBlKSxmdW5jdGlvbihlLHQpe3JldHVybiBlK3R9KX0sZS5wcm90b3R5cGUuYWRkTj1mdW5jdGlvbihlKXt0aGlzLmFzc2VydE5vdENvbXBsZXgoZSxcImFkZE5cIik7Zm9yKHZhciB0PWUubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLmRhdGFTeW5jKCl9KSxyPWJ1ZmZlcihlWzBdLnNoYXBlLGVbMF0uZHR5cGUpLG49ci52YWx1ZXMsbz0wO288ZS5sZW5ndGg7bysrKWZvcih2YXIgYT10W29dLGk9MDtpPG4ubGVuZ3RoO2krKyluW2ldKz1hW2ldO3JldHVybiByLnRvVGVuc29yKCl9LGUucHJvdG90eXBlLnN1YnRyYWN0PWZ1bmN0aW9uKGUsdCl7cmV0dXJuXCJjb21wbGV4NjRcIj09PWUuZHR5cGV8fFwiY29tcGxleDY0XCI9PT10LmR0eXBlP3RoaXMuYnJvYWRjYXN0ZWRCaW5hcnlDb21wbGV4T3AoZS5jYXN0KFwiY29tcGxleDY0XCIpLHQuY2FzdChcImNvbXBsZXg2NFwiKSxmdW5jdGlvbihlLHQscixuKXtyZXR1cm57cmVhbDplLXIsaW1hZzp0LW59fSk6dGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKGUsdCx1cGNhc3RUeXBlKGUuZHR5cGUsdC5kdHlwZSksZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS10fSl9LGUucHJvdG90eXBlLnBvdz1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLmFzc2VydE5vdENvbXBsZXgoW2UsdF0sXCJwb3dcIiksdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKGUsdCxlLmR0eXBlLGZ1bmN0aW9uKGUsdCl7cmV0dXJuIE1hdGgucG93KGUsdCl9KX0sZS5wcm90b3R5cGUuYmF0Y2hNYXRNdWw9ZnVuY3Rpb24oZSx0LHIsbil7dGhpcy5hc3NlcnROb3RDb21wbGV4KFtlLHRdLFwibWF0TXVsXCIpO2Zvcih2YXIgbz1yP2Uuc2hhcGVbMV06ZS5zaGFwZVsyXSxhPXI/ZS5zaGFwZVsyXTplLnNoYXBlWzFdLGk9bj90LnNoYXBlWzFdOnQuc2hhcGVbMl0scz1lLnNoYXBlWzBdLHU9ZS5kYXRhU3luYygpLGw9dC5kYXRhU3luYygpLGM9cj9bZS5zdHJpZGVzWzBdLDEsZS5zdHJpZGVzWzFdXTpbZS5zdHJpZGVzWzBdLGUuc3RyaWRlc1sxXSwxXSxwPWNbMF0sZD1jWzFdLGg9Y1syXSxmPW4/WzEsdC5zdHJpZGVzWzFdLHQuc3RyaWRlc1swXV06W3Quc3RyaWRlc1sxXSwxLHQuc3RyaWRlc1swXV0sbT1mWzBdLGc9ZlsxXSx2PWZbMl0seT1hKmkseD1uZXcgRmxvYXQzMkFycmF5KHMqeSksVD10aGlzLmJsb2NrU2l6ZSxFPTA7RTxzO0UrKylmb3IodmFyIHc9MDt3PGE7dys9VClmb3IodmFyIFM9MDtTPGk7Uys9VClmb3IodmFyIGI9MDtiPG87Yis9VClmb3IodmFyIEM9TWF0aC5taW4odytULGEpLF89TWF0aC5taW4oUytULGkpLEE9TWF0aC5taW4oYitULG8pLE49dztOPEM7TisrKWZvcih2YXIgUj1TO1I8XztSKyspe2Zvcih2YXIgST0wLGs9YjtrPEE7aysrKUkrPXVbRSpwK04qZCtrKmhdKmxbayptK1IqZytFKnZdO3hbRSp5KyhOKmkrUildKz1JfXJldHVybiB0ZW5zb3IzZCh4LFtzLGEsaV0pfSxlLnByb3RvdHlwZS5tdWx0aXBseT1mdW5jdGlvbihlLHQpe3JldHVyblwiY29tcGxleDY0XCI9PT1lLmR0eXBlfHxcImNvbXBsZXg2NFwiPT09dC5kdHlwZT90aGlzLmJyb2FkY2FzdGVkQmluYXJ5Q29tcGxleE9wKGUuY2FzdChcImNvbXBsZXg2NFwiKSx0LmNhc3QoXCJjb21wbGV4NjRcIiksZnVuY3Rpb24oZSx0LHIsbil7cmV0dXJue3JlYWw6ZSpyLXQqbixpbWFnOmUqbit0KnJ9fSk6dGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKGUsdCx1cGNhc3RUeXBlKGUuZHR5cGUsdC5kdHlwZSksZnVuY3Rpb24oZSx0KXtyZXR1cm4gZSp0fSl9LGUucHJvdG90eXBlLnJlYWxEaXZpZGU9ZnVuY3Rpb24oZSx0KXt0aGlzLmFzc2VydE5vdENvbXBsZXgoW2UsdF0sXCJyZWFsRGl2aWRlXCIpO3JldHVybiB0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AoZSx0LFwiZmxvYXQzMlwiLGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUvdH0pfSxlLnByb3RvdHlwZS5mbG9vckRpdj1mdW5jdGlvbihlLHQpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChbZSx0XSxcImZsb29yRGl2XCIpO3JldHVybiB0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AoZSx0LFwiaW50MzJcIixmdW5jdGlvbihlLHQpe3JldHVybiBNYXRoLmZsb29yKGUvdCl9KX0sZS5wcm90b3R5cGUuc3VtPWZ1bmN0aW9uKGUsdCl7dGhpcy5hc3NlcnROb3RDb21wbGV4KGUsXCJzdW1cIiksYXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXMoXCJzdW1cIix0LGUucmFuayk7Zm9yKHZhciByPWNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMoZS5zaGFwZSx0KSxuPXJbMF0sbz1yWzFdLGE9emVyb3Mobix1cGNhc3RUeXBlKGUuZHR5cGUsXCJpbnQzMlwiKSksaT1zaXplRnJvbVNoYXBlKG8pLHM9YS5kYXRhU3luYygpLHU9ZS5kYXRhU3luYygpLGw9MDtsPHMubGVuZ3RoOysrbCl7Zm9yKHZhciBjPWwqaSxwPTAsZD0wO2Q8aTsrK2QpcCs9dVtjK2RdO3NbbF09cH1yZXR1cm4gYX0sZS5wcm90b3R5cGUucHJvZD1mdW5jdGlvbihlLHQpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChlLFwic3VtXCIpO2Zvcih2YXIgcj1jb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKGUuc2hhcGUsdCksbj1yWzBdLG89clsxXSxhPXplcm9zKG4sdXBjYXN0VHlwZShlLmR0eXBlLFwiaW50MzJcIikpLGk9c2l6ZUZyb21TaGFwZShvKSxzPWEuZGF0YVN5bmMoKSx1PWUuZGF0YVN5bmMoKSxsPTA7bDxzLmxlbmd0aDsrK2wpe2Zvcih2YXIgYz1sKmkscD0xLGQ9MDtkPGk7KytkKXAqPXVbYytkXTtzW2xdPXB9cmV0dXJuIGF9LGUucHJvdG90eXBlLnVuc29ydGVkU2VnbWVudFN1bT1mdW5jdGlvbihlLHQscil7dGhpcy5hc3NlcnROb3RDb21wbGV4KGUsXCJ1bnNvcnRlZFNlZ21lbnRTdW1cIik7Zm9yKHZhciBuPVtdLG89ZS5yYW5rLXQucmFuayxhPTA7YTxvOysrYSl0PXQuZXhwYW5kRGltcyhhKzEpO2ZvcihhPTA7YTxyOysrYSl7dmFyIGk9c2NhbGFyKGEsXCJpbnQzMlwiKSxzPWVxdWFsKGksdCkuYXNUeXBlKFwiZmxvYXQzMlwiKS5tdWwoZSkuc3VtKDApO24ucHVzaChzKX1yZXR1cm4gc3RhY2sobil9LGUucHJvdG90eXBlLmFyZ01pbj1mdW5jdGlvbihlLHQpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChlLFwiYXJnTWluXCIpO3ZhciByPVt0XTthc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcyhcImFyZ01pblwiLHIsZS5yYW5rKTtmb3IodmFyIG49Y29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyhlLnNoYXBlLHIpLG89blswXSxhPW5bMV0saT16ZXJvcyhvLFwiaW50MzJcIikscz1zaXplRnJvbVNoYXBlKGEpLHU9aS5kYXRhU3luYygpLGw9ZS5kYXRhU3luYygpLGM9MDtjPHUubGVuZ3RoOysrYyl7Zm9yKHZhciBwPWMqcyxkPWxbcF0saD0wLGY9MDtmPHM7KytmKXt2YXIgbT1sW3ArZl07bTxkJiYoZD1tLGg9Zil9dVtjXT1ofXJldHVybiBpfSxlLnByb3RvdHlwZS5hcmdNYXg9ZnVuY3Rpb24oZSx0KXt0aGlzLmFzc2VydE5vdENvbXBsZXgoZSxcImFyZ01heFwiKTt2YXIgcj1bdF07YXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXMoXCJhcmdNYXhcIixyLGUucmFuayk7Zm9yKHZhciBuPWNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMoZS5zaGFwZSxyKSxvPW5bMF0sYT1uWzFdLGk9emVyb3MobyxcImludDMyXCIpLHM9c2l6ZUZyb21TaGFwZShhKSx1PWkuZGF0YVN5bmMoKSxsPWUuZGF0YVN5bmMoKSxjPTA7Yzx1Lmxlbmd0aDsrK2Mpe2Zvcih2YXIgcD1jKnMsZD1sW3BdLGg9MCxmPTA7ZjxzOysrZil7dmFyIG09bFtwK2ZdO20+ZCYmKGQ9bSxoPWYpfXVbY109aH1yZXR1cm4gaX0sZS5wcm90b3R5cGUuY3Vtc3VtPWZ1bmN0aW9uKGUsdCxyLG4pe2lmKHRoaXMuYXNzZXJ0Tm90Q29tcGxleChlLFwiY3Vtc3VtXCIpLHQhPT1lLnJhbmstMSl0aHJvdyBuZXcgRXJyb3IoXCJiYWNrZW5kLmN1bXN1bSBpbiBDUFUgZXhwZWN0cyBhbiBpbm5lci1tb3N0IGF4aXM9XCIrKGUucmFuay0xKStcIiBidXQgZ290IGF4aXM9XCIrdCk7Zm9yKHZhciBvPXVwY2FzdFR5cGUoZS5kdHlwZSxcImludDMyXCIpLGE9emVyb3MoZS5zaGFwZSxvKSxpPWEuZGF0YVN5bmMoKSxzPWUuZGF0YVN5bmMoKSx1PWUuc2hhcGVbZS5yYW5rLTFdLGw9bj9mdW5jdGlvbihlLHQpe3JldHVybiBlK3UtdC0xfTpmdW5jdGlvbihlLHQpe3JldHVybiBlK3R9LGM9MDtjPHMubGVuZ3RoO2MrPXUpZm9yKHZhciBwPTA7cDx1O3ArKyl7dmFyIGQ9bChjLHApO2lmKDA9PT1wKWlbZF09cj8wOnNbZF07ZWxzZXt2YXIgaD1sKGMscC0xKTtpW2RdPXI/c1toXStpW2hdOnNbZF0raVtoXX19cmV0dXJuIGF9LGUucHJvdG90eXBlLmVxdWFsPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuYXNzZXJ0Tm90Q29tcGxleChbZSx0XSxcImVxdWFsXCIpLHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcChlLHQsXCJib29sXCIsZnVuY3Rpb24oZSx0KXtyZXR1cm4gZT09PXQ/MTowfSl9LGUucHJvdG90eXBlLm5vdEVxdWFsPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuYXNzZXJ0Tm90Q29tcGxleChbZSx0XSxcIm5vdEVxdWFsXCIpLHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcChlLHQsXCJib29sXCIsZnVuY3Rpb24oZSx0KXtyZXR1cm4gZSE9PXQ/MTowfSl9LGUucHJvdG90eXBlLmxlc3M9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5hc3NlcnROb3RDb21wbGV4KFtlLHRdLFwibGVzc1wiKSx0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AoZSx0LFwiYm9vbFwiLGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGU8dD8xOjB9KX0sZS5wcm90b3R5cGUubGVzc0VxdWFsPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuYXNzZXJ0Tm90Q29tcGxleChbZSx0XSxcImxlc3NFcXVhbFwiKSx0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AoZSx0LFwiYm9vbFwiLGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGU8PXQ/MTowfSl9LGUucHJvdG90eXBlLmdyZWF0ZXI9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5hc3NlcnROb3RDb21wbGV4KFtlLHRdLFwiZ3JlYXRlclwiKSx0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AoZSx0LFwiYm9vbFwiLGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGU+dD8xOjB9KX0sZS5wcm90b3R5cGUuZ3JlYXRlckVxdWFsPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuYXNzZXJ0Tm90Q29tcGxleChbZSx0XSxcImdyZWF0ZXJFcXVhbFwiKSx0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AoZSx0LFwiYm9vbFwiLGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGU+PXQ/MTowfSl9LGUucHJvdG90eXBlLmxvZ2ljYWxOb3Q9ZnVuY3Rpb24oZSl7dGhpcy5hc3NlcnROb3RDb21wbGV4KGUsXCJsb2dpY2FsTm90XCIpO2Zvcih2YXIgdD1lLmRhdGFTeW5jKCkscj1uZXcgSW50MzJBcnJheSh0Lmxlbmd0aCksbj0wO248dC5sZW5ndGg7KytuKXJbbl09dFtuXT8wOjE7cmV0dXJuIFRlbnNvci5tYWtlKGUuc2hhcGUse3ZhbHVlczpyfSxcImJvb2xcIil9LGUucHJvdG90eXBlLmxvZ2ljYWxBbmQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5hc3NlcnROb3RDb21wbGV4KFtlLHRdLFwibG9naWNhbEFuZFwiKSx0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AoZSx0LFwiYm9vbFwiLGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUmJnR9KX0sZS5wcm90b3R5cGUubG9naWNhbE9yPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuYXNzZXJ0Tm90Q29tcGxleChbZSx0XSxcImxvZ2ljYWxPclwiKSx0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AoZSx0LFwiYm9vbFwiLGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGV8fHR9KX0sZS5wcm90b3R5cGUuc2VsZWN0PWZ1bmN0aW9uKGUsdCxyKXt0aGlzLmFzc2VydE5vdENvbXBsZXgoW2UsdCxyXSxcInNlbGVjdFwiKTtmb3IodmFyIG49ZS5kYXRhU3luYygpLG89dC5kYXRhU3luYygpLGE9ci5kYXRhU3luYygpLGk9emVyb3ModC5zaGFwZSx1cGNhc3RUeXBlKHQuZHR5cGUsci5kdHlwZSkpLHM9aS5kYXRhU3luYygpLHU9MCxsPTA9PT1lLnJhbmt8fGUucmFuaz4xfHwxPT09dC5yYW5rPzE6dC5zaGFwZVsxXSxjPTA7YzxuLmxlbmd0aDtjKyspZm9yKHZhciBwPTA7cDxsO3ArKykxPT09bltjXT9zW3UrK109b1tjXTpzW3UrK109YVtjXTtyZXR1cm4gaX0sZS5wcm90b3R5cGUud2hlcmU9ZnVuY3Rpb24oZSl7dGhpcy5hc3NlcnROb3RDb21wbGV4KFtlXSxcIndoZXJlXCIpO3ZhciB0PWUuZGF0YVN5bmMoKTtyZXR1cm4gd2hlcmVJbXBsKGUuc2hhcGUsdCl9LGUucHJvdG90eXBlLnRvcGs9ZnVuY3Rpb24oZSx0LHIpe3JldHVybiB0aGlzLmFzc2VydE5vdENvbXBsZXgoZSxcInRvcGtcIiksdG9wa0ltcGwoZS5kYXRhU3luYygpLGUuc2hhcGUsZS5kdHlwZSx0LHIpfSxlLnByb3RvdHlwZS5taW49ZnVuY3Rpb24oZSx0KXt0aGlzLmFzc2VydE5vdENvbXBsZXgoZSxcIm1pblwiKSxhc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcyhcIm1pblwiLHQsZS5yYW5rKTtmb3IodmFyIHI9Y29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyhlLnNoYXBlLHQpLG49clswXSxvPXJbMV0sYT16ZXJvcyhuLGUuZHR5cGUpLGk9c2l6ZUZyb21TaGFwZShvKSxzPWEuZGF0YVN5bmMoKSx1PWUuZGF0YVN5bmMoKSxsPTA7bDxzLmxlbmd0aDsrK2wpe2Zvcih2YXIgYz1sKmkscD11W2NdLGQ9MDtkPGk7KytkKXt2YXIgaD11W2MrZF07aDxwJiYocD1oKX1zW2xdPXB9cmV0dXJuIGF9LGUucHJvdG90eXBlLm1pbmltdW09ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5hc3NlcnROb3RDb21wbGV4KFtlLHRdLFwibWluaW11bVwiKSx0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AoZSx0LGUuZHR5cGUsZnVuY3Rpb24oZSx0KXtyZXR1cm4gTWF0aC5taW4oZSx0KX0pfSxlLnByb3RvdHlwZS5tb2Q9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5hc3NlcnROb3RDb21wbGV4KFtlLHRdLFwibW9kXCIpLHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcChlLHQsZS5kdHlwZSxmdW5jdGlvbihlLHQpe3ZhciByPWUldDtyZXR1cm4gZTwwJiZ0PDB8fGU+PTAmJnQ+PTA/cjoocit0KSV0fSl9LGUucHJvdG90eXBlLm1heD1mdW5jdGlvbihlLHQpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChlLFwibWF4XCIpLGFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKFwibWF4XCIsdCxlLnJhbmspO2Zvcih2YXIgcj1jb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKGUuc2hhcGUsdCksbj1yWzBdLG89clsxXSxhPXplcm9zKG4sZS5kdHlwZSksaT1zaXplRnJvbVNoYXBlKG8pLHM9YS5kYXRhU3luYygpLHU9ZS5kYXRhU3luYygpLGw9MDtsPHMubGVuZ3RoOysrbCl7Zm9yKHZhciBjPWwqaSxwPXVbY10sZD0wO2Q8aTsrK2Qpe3ZhciBoPXVbYytkXTtoPnAmJihwPWgpfXNbbF09cH1yZXR1cm4gYX0sZS5wcm90b3R5cGUubWF4aW11bT1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLmFzc2VydE5vdENvbXBsZXgoW2UsdF0sXCJtYXhpbXVtXCIpLHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcChlLHQsZS5kdHlwZSxmdW5jdGlvbihlLHQpe3JldHVybiBNYXRoLm1heChlLHQpfSl9LGUucHJvdG90eXBlLmFsbD1mdW5jdGlvbihlLHQpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChlLFwiYWxsXCIpLGFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKFwiYWxsXCIsdCxlLnJhbmspO2Zvcih2YXIgcj1jb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKGUuc2hhcGUsdCksbj1yWzBdLG89clsxXSxhPXplcm9zKG4sZS5kdHlwZSksaT1zaXplRnJvbVNoYXBlKG8pLHM9YS5kYXRhU3luYygpLHU9ZS5kYXRhU3luYygpLGw9MDtsPHMubGVuZ3RoOysrbCl7Zm9yKHZhciBjPWwqaSxwPXVbY10sZD0wO2Q8aTsrK2Qpe3ZhciBoPXVbYytkXTtwPXAmJmh9c1tsXT1wfXJldHVybiBhfSxlLnByb3RvdHlwZS5hbnk9ZnVuY3Rpb24oZSx0KXt0aGlzLmFzc2VydE5vdENvbXBsZXgoZSxcImFueVwiKSxhc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcyhcImFueVwiLHQsZS5yYW5rKTtmb3IodmFyIHI9Y29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyhlLnNoYXBlLHQpLG49clswXSxvPXJbMV0sYT16ZXJvcyhuLGUuZHR5cGUpLGk9c2l6ZUZyb21TaGFwZShvKSxzPWEuZGF0YVN5bmMoKSx1PWUuZGF0YVN5bmMoKSxsPTA7bDxzLmxlbmd0aDsrK2wpe2Zvcih2YXIgYz1sKmkscD11W2NdLGQ9MDtkPGk7KytkKXt2YXIgaD11W2MrZF07cD1wfHxofXNbbF09cH1yZXR1cm4gYX0sZS5wcm90b3R5cGUuc3F1YXJlZERpZmZlcmVuY2U9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5hc3NlcnROb3RDb21wbGV4KFtlLHRdLFwic3F1YXJlZERpZmZlcmVuY2VcIiksdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKGUsdCxlLmR0eXBlLGZ1bmN0aW9uKGUsdCl7dmFyIHI9ZS10O3JldHVybiByKnJ9KX0sZS5wcm90b3R5cGUuY2VpbD1mdW5jdGlvbihlKXt0aGlzLmFzc2VydE5vdENvbXBsZXgoZSxcImNlaWxcIik7Zm9yKHZhciB0PWUuZGF0YVN5bmMoKSxyPW5ldyBGbG9hdDMyQXJyYXkodC5sZW5ndGgpLG49MDtuPHQubGVuZ3RoOysrbilyW25dPU1hdGguY2VpbCh0W25dKTtyZXR1cm4gVGVuc29yLm1ha2UoZS5zaGFwZSx7dmFsdWVzOnJ9KX0sZS5wcm90b3R5cGUuZmxvb3I9ZnVuY3Rpb24oZSl7dGhpcy5hc3NlcnROb3RDb21wbGV4KGUsXCJmbG9vclwiKTtmb3IodmFyIHQ9ZS5kYXRhU3luYygpLHI9bmV3IEZsb2F0MzJBcnJheSh0Lmxlbmd0aCksbj0wO248dC5sZW5ndGg7KytuKXJbbl09TWF0aC5mbG9vcih0W25dKTtyZXR1cm4gVGVuc29yLm1ha2UoZS5zaGFwZSx7dmFsdWVzOnJ9KX0sZS5wcm90b3R5cGUuc2lnbj1mdW5jdGlvbihlKXt0aGlzLmFzc2VydE5vdENvbXBsZXgoZSxcInhcIik7Zm9yKHZhciB0PWUuZGF0YVN5bmMoKSxyPW5ldyBGbG9hdDMyQXJyYXkodC5sZW5ndGgpLG49MDtuPHQubGVuZ3RoOysrbil0W25dPDA/cltuXT0tMTp0W25dPjA/cltuXT0xOnJbbl09MDtyZXR1cm4gVGVuc29yLm1ha2UoZS5zaGFwZSx7dmFsdWVzOnJ9KX0sZS5wcm90b3R5cGUucm91bmQ9ZnVuY3Rpb24oZSl7dGhpcy5hc3NlcnROb3RDb21wbGV4KGUsXCJyb3VuZFwiKTtmb3IodmFyIHQ9ZS5kYXRhU3luYygpLHI9bmV3IEZsb2F0MzJBcnJheSh0Lmxlbmd0aCksbj0wO248dC5sZW5ndGg7KytuKXt2YXIgbz1NYXRoLmZsb29yKHRbbl0pO3Rbbl0tbzwuNT9yW25dPU1hdGguZmxvb3IodFtuXSk6dFtuXS1vPi41P3Jbbl09TWF0aC5jZWlsKHRbbl0pOnJbbl09byUyPT0wP286bysxfXJldHVybiBUZW5zb3IubWFrZShlLnNoYXBlLHt2YWx1ZXM6cn0pfSxlLnByb3RvdHlwZS5leHA9ZnVuY3Rpb24oZSl7dGhpcy5hc3NlcnROb3RDb21wbGV4KGUsXCJleHBcIik7Zm9yKHZhciB0PWUuZGF0YVN5bmMoKSxyPW5ldyBGbG9hdDMyQXJyYXkodC5sZW5ndGgpLG49MDtuPHQubGVuZ3RoOysrbilyW25dPU1hdGguZXhwKHRbbl0pO3JldHVybiBUZW5zb3IubWFrZShlLnNoYXBlLHt2YWx1ZXM6cn0pfSxlLnByb3RvdHlwZS5leHBtMT1mdW5jdGlvbihlKXt0aGlzLmFzc2VydE5vdENvbXBsZXgoZSxcImV4cG0xXCIpO2Zvcih2YXIgdD1lLmRhdGFTeW5jKCkscj1uZXcgRmxvYXQzMkFycmF5KHQubGVuZ3RoKSxuPTA7bjx0Lmxlbmd0aDsrK24pcltuXT1NYXRoLmV4cG0xKHRbbl0pO3JldHVybiBUZW5zb3IubWFrZShlLnNoYXBlLHt2YWx1ZXM6cn0pfSxlLnByb3RvdHlwZS5sb2c9ZnVuY3Rpb24oZSl7dGhpcy5hc3NlcnROb3RDb21wbGV4KGUsXCJsb2dcIik7Zm9yKHZhciB0PWUuZGF0YVN5bmMoKSxyPW5ldyBGbG9hdDMyQXJyYXkodC5sZW5ndGgpLG49MDtuPHQubGVuZ3RoOysrbil7dmFyIG89dFtuXTtyW25dPU1hdGgubG9nKG8pfXJldHVybiBUZW5zb3IubWFrZShlLnNoYXBlLHt2YWx1ZXM6cn0pfSxlLnByb3RvdHlwZS5sb2cxcD1mdW5jdGlvbihlKXt0aGlzLmFzc2VydE5vdENvbXBsZXgoZSxcImxvZzFwXCIpO2Zvcih2YXIgdD1lLmRhdGFTeW5jKCkscj1uZXcgRmxvYXQzMkFycmF5KHQubGVuZ3RoKSxuPTA7bjx0Lmxlbmd0aDsrK24pe3ZhciBvPXRbbl07cltuXT1NYXRoLmxvZzFwKG8pfXJldHVybiBUZW5zb3IubWFrZShlLnNoYXBlLHt2YWx1ZXM6cn0pfSxlLnByb3RvdHlwZS5zcXJ0PWZ1bmN0aW9uKGUpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChlLFwic3FydFwiKTtmb3IodmFyIHQ9ZS5kYXRhU3luYygpLHI9bmV3IEZsb2F0MzJBcnJheSh0Lmxlbmd0aCksbj0wO248dC5sZW5ndGg7KytuKXt2YXIgbz10W25dO3Jbbl09TWF0aC5zcXJ0KG8pfXJldHVybiBUZW5zb3IubWFrZShlLnNoYXBlLHt2YWx1ZXM6cn0pfSxlLnByb3RvdHlwZS5yc3FydD1mdW5jdGlvbihlKXt0aGlzLmFzc2VydE5vdENvbXBsZXgoZSxcInJzcXJ0XCIpO2Zvcih2YXIgdD1lLmRhdGFTeW5jKCkscj1uZXcgRmxvYXQzMkFycmF5KHQubGVuZ3RoKSxuPTA7bjx0Lmxlbmd0aDsrK24pe3ZhciBvPXRbbl07cltuXT0xL01hdGguc3FydChvKX1yZXR1cm4gVGVuc29yLm1ha2UoZS5zaGFwZSx7dmFsdWVzOnJ9KX0sZS5wcm90b3R5cGUuc3F1YXJlPWZ1bmN0aW9uKGUpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChlLFwic3F1YXJlXCIpO2Zvcih2YXIgdD1lLmRhdGFTeW5jKCkscj1uZXcgRmxvYXQzMkFycmF5KHQubGVuZ3RoKSxuPTA7bjx0Lmxlbmd0aDsrK24pe3ZhciBvPXRbbl07cltuXT1vKm99cmV0dXJuIFRlbnNvci5tYWtlKGUuc2hhcGUse3ZhbHVlczpyfSl9LGUucHJvdG90eXBlLnJlY2lwcm9jYWw9ZnVuY3Rpb24oZSl7dGhpcy5hc3NlcnROb3RDb21wbGV4KGUsXCJyZWNpcHJvY2FsXCIpO2Zvcih2YXIgdD1lLmRhdGFTeW5jKCkscj1uZXcgRmxvYXQzMkFycmF5KHQubGVuZ3RoKSxuPTA7bjx0Lmxlbmd0aDsrK24pcltuXT0xL3Rbbl07cmV0dXJuIFRlbnNvci5tYWtlKGUuc2hhcGUse3ZhbHVlczpyfSl9LGUucHJvdG90eXBlLnJlbHU9ZnVuY3Rpb24oZSl7dGhpcy5hc3NlcnROb3RDb21wbGV4KGUsXCJyZWx1XCIpO2Zvcih2YXIgdD16ZXJvcyhlLnNoYXBlLGUuZHR5cGUpLHI9dC5kYXRhU3luYygpLG49ZS5kYXRhU3luYygpLG89MDtvPG4ubGVuZ3RoOysrbylyW29dPU1hdGgubWF4KDAsbltvXSk7cmV0dXJuIHR9LGUucHJvdG90eXBlLmVsdT1mdW5jdGlvbihlKXt0aGlzLmFzc2VydE5vdENvbXBsZXgoZSxcImVsdVwiKTtmb3IodmFyIHQ9bmV3IEZsb2F0MzJBcnJheShlLnNpemUpLHI9ZS5kYXRhU3luYygpLG49MDtuPHIubGVuZ3RoOysrbil7dmFyIG89cltuXTt0W25dPW8+PTA/bzpNYXRoLmV4cChvKS0xfXJldHVybiBUZW5zb3IubWFrZShlLnNoYXBlLHt2YWx1ZXM6dH0pfSxlLnByb3RvdHlwZS5lbHVEZXI9ZnVuY3Rpb24oZSx0KXt0aGlzLmFzc2VydE5vdENvbXBsZXgoW2UsdF0sXCJlbHVEZXJcIik7Zm9yKHZhciByPW5ldyBGbG9hdDMyQXJyYXkodC5zaXplKSxuPXQuZGF0YVN5bmMoKSxvPWUuZGF0YVN5bmMoKSxhPTA7YTxuLmxlbmd0aDsrK2Epe3ZhciBpPW5bYV07clthXT1pPj0xP29bYV06b1thXSooaSsxKX1yZXR1cm4gVGVuc29yLm1ha2UodC5zaGFwZSx7dmFsdWVzOnJ9KX0sZS5wcm90b3R5cGUuc2VsdT1mdW5jdGlvbihlKXt0aGlzLmFzc2VydE5vdENvbXBsZXgoZSxcInNlbHVcIik7Zm9yKHZhciB0PVNFTFVfU0NBTEVBTFBIQSxyPVNFTFVfU0NBTEUsbj1uZXcgRmxvYXQzMkFycmF5KGUuc2l6ZSksbz1lLmRhdGFTeW5jKCksYT0wO2E8by5sZW5ndGg7KythKXt2YXIgaT1vW2FdO25bYV09aT49MD9yKmk6dCooTWF0aC5leHAoaSktMSl9cmV0dXJuIFRlbnNvci5tYWtlKGUuc2hhcGUse3ZhbHVlczpufSl9LGUucHJvdG90eXBlLmNsaXA9ZnVuY3Rpb24oZSx0LHIpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChlLFwiY2xpcFwiKTtmb3IodmFyIG49bmV3IEZsb2F0MzJBcnJheShlLnNpemUpLG89ZS5kYXRhU3luYygpLGE9MDthPG8ubGVuZ3RoOysrYSl7dmFyIGk9b1thXTtuW2FdPWk+cj9yOmk8dD90Oml9cmV0dXJuIFRlbnNvci5tYWtlKGUuc2hhcGUse3ZhbHVlczpufSl9LGUucHJvdG90eXBlLmFicz1mdW5jdGlvbihlKXtmb3IodmFyIHQ9bmV3IEZsb2F0MzJBcnJheShlLnNpemUpLHI9ZS5kYXRhU3luYygpLG49MDtuPHIubGVuZ3RoOysrbil0W25dPU1hdGguYWJzKHJbbl0pO3JldHVybiBUZW5zb3IubWFrZShlLnNoYXBlLHt2YWx1ZXM6dH0pfSxlLnByb3RvdHlwZS5jb21wbGV4QWJzPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1uZXcgRmxvYXQzMkFycmF5KGUuc2l6ZSkscj1lLmRhdGFTeW5jKCksbj0wO248ZS5zaXplOysrbil7dmFyIG89clsyKm5dLGE9clsyKm4rMV07dFtuXT1NYXRoLnNxcnQobypvK2EqYSl9cmV0dXJuIFRlbnNvci5tYWtlKGUuc2hhcGUse3ZhbHVlczp0fSl9LGUucHJvdG90eXBlLmludD1mdW5jdGlvbihlKXt0aGlzLmFzc2VydE5vdENvbXBsZXgoZSxcImludFwiKTtmb3IodmFyIHQ9bmV3IEludDMyQXJyYXkoZS5zaXplKSxyPWUuZGF0YVN5bmMoKSxuPTA7bjxyLmxlbmd0aDsrK24pdFtuXT1yW25dO3JldHVybiBUZW5zb3IubWFrZShlLnNoYXBlLHt2YWx1ZXM6dH0sXCJpbnQzMlwiKX0sZS5wcm90b3R5cGUuc2lnbW9pZD1mdW5jdGlvbihlKXt0aGlzLmFzc2VydE5vdENvbXBsZXgoZSxcInNpZ21vaWRcIik7Zm9yKHZhciB0PW5ldyBGbG9hdDMyQXJyYXkoZS5zaXplKSxyPWUuZGF0YVN5bmMoKSxuPTA7bjxyLmxlbmd0aDsrK24pdFtuXT0xLygxK01hdGguZXhwKC1yW25dKSk7cmV0dXJuIFRlbnNvci5tYWtlKGUuc2hhcGUse3ZhbHVlczp0fSl9LGUucHJvdG90eXBlLnNvZnRwbHVzPWZ1bmN0aW9uKGUpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChlLFwic29mdHBsdXNcIik7Zm9yKHZhciB0PU1hdGgubG9nKDEuMTkyMDkyODk1NTA3ODEyNWUtNykrMixyPW5ldyBGbG9hdDMyQXJyYXkoZS5zaXplKSxuPWUuZGF0YVN5bmMoKSxvPTA7bzxuLmxlbmd0aDsrK28pe3ZhciBhPW5bb10+LXQsaT1uW29dPHQscz1NYXRoLmV4cChuW29dKSx1PXZvaWQgMDt1PWk/czphP25bb106TWF0aC5sb2coMStzKSxyW29dPXV9cmV0dXJuIFRlbnNvci5tYWtlKGUuc2hhcGUse3ZhbHVlczpyfSl9LGUucHJvdG90eXBlLnNpbj1mdW5jdGlvbihlKXt0aGlzLmFzc2VydE5vdENvbXBsZXgoZSxcInNpblwiKTtmb3IodmFyIHQ9bmV3IEZsb2F0MzJBcnJheShlLnNpemUpLHI9ZS5kYXRhU3luYygpLG49MDtuPHIubGVuZ3RoOysrbil0W25dPU1hdGguc2luKHJbbl0pO3JldHVybiBUZW5zb3IubWFrZShlLnNoYXBlLHt2YWx1ZXM6dH0pfSxlLnByb3RvdHlwZS5jb3M9ZnVuY3Rpb24oZSl7dGhpcy5hc3NlcnROb3RDb21wbGV4KGUsXCJjb3NcIik7Zm9yKHZhciB0PW5ldyBGbG9hdDMyQXJyYXkoZS5zaXplKSxyPWUuZGF0YVN5bmMoKSxuPTA7bjxyLmxlbmd0aDsrK24pdFtuXT1NYXRoLmNvcyhyW25dKTtyZXR1cm4gVGVuc29yLm1ha2UoZS5zaGFwZSx7dmFsdWVzOnR9KX0sZS5wcm90b3R5cGUudGFuPWZ1bmN0aW9uKGUpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChlLFwidGFuXCIpO2Zvcih2YXIgdD1uZXcgRmxvYXQzMkFycmF5KGUuc2l6ZSkscj1lLmRhdGFTeW5jKCksbj0wO248ci5sZW5ndGg7KytuKXRbbl09TWF0aC50YW4ocltuXSk7cmV0dXJuIFRlbnNvci5tYWtlKGUuc2hhcGUse3ZhbHVlczp0fSl9LGUucHJvdG90eXBlLmFzaW49ZnVuY3Rpb24oZSl7dGhpcy5hc3NlcnROb3RDb21wbGV4KGUsXCJhc2luXCIpO2Zvcih2YXIgdD1uZXcgRmxvYXQzMkFycmF5KGUuc2l6ZSkscj1lLmRhdGFTeW5jKCksbj0wO248ci5sZW5ndGg7KytuKXRbbl09TWF0aC5hc2luKHJbbl0pO3JldHVybiBUZW5zb3IubWFrZShlLnNoYXBlLHt2YWx1ZXM6dH0pfSxlLnByb3RvdHlwZS5hY29zPWZ1bmN0aW9uKGUpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChlLFwiYWNvc1wiKTtmb3IodmFyIHQ9bmV3IEZsb2F0MzJBcnJheShlLnNpemUpLHI9ZS5kYXRhU3luYygpLG49MDtuPHIubGVuZ3RoOysrbil0W25dPU1hdGguYWNvcyhyW25dKTtyZXR1cm4gVGVuc29yLm1ha2UoZS5zaGFwZSx7dmFsdWVzOnR9KX0sZS5wcm90b3R5cGUuYXRhbj1mdW5jdGlvbihlKXt0aGlzLmFzc2VydE5vdENvbXBsZXgoZSxcImF0YW5cIik7Zm9yKHZhciB0PW5ldyBGbG9hdDMyQXJyYXkoZS5zaXplKSxyPWUuZGF0YVN5bmMoKSxuPTA7bjxyLmxlbmd0aDsrK24pdFtuXT1NYXRoLmF0YW4ocltuXSk7cmV0dXJuIFRlbnNvci5tYWtlKGUuc2hhcGUse3ZhbHVlczp0fSl9LGUucHJvdG90eXBlLmF0YW4yPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuYXNzZXJ0Tm90Q29tcGxleChbZSx0XSxcImF0YW4yXCIpLHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcChlLHQsZS5kdHlwZSxmdW5jdGlvbihlLHQpe3JldHVybiBNYXRoLmF0YW4yKGUsdCl9KX0sZS5wcm90b3R5cGUuc2luaD1mdW5jdGlvbihlKXt0aGlzLmFzc2VydE5vdENvbXBsZXgoZSxcInNpbmhcIik7Zm9yKHZhciB0PW5ldyBGbG9hdDMyQXJyYXkoZS5zaXplKSxyPWUuZGF0YVN5bmMoKSxuPTA7bjxyLmxlbmd0aDsrK24pdFtuXT1NYXRoLnNpbmgocltuXSk7cmV0dXJuIFRlbnNvci5tYWtlKGUuc2hhcGUse3ZhbHVlczp0fSl9LGUucHJvdG90eXBlLmNvc2g9ZnVuY3Rpb24oZSl7dGhpcy5hc3NlcnROb3RDb21wbGV4KGUsXCJjb3NoXCIpO2Zvcih2YXIgdD1uZXcgRmxvYXQzMkFycmF5KGUuc2l6ZSkscj1lLmRhdGFTeW5jKCksbj0wO248ci5sZW5ndGg7KytuKXRbbl09TWF0aC5jb3NoKHJbbl0pO3JldHVybiBUZW5zb3IubWFrZShlLnNoYXBlLHt2YWx1ZXM6dH0pfSxlLnByb3RvdHlwZS50YW5oPWZ1bmN0aW9uKGUpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChlLFwidGFuaFwiKTtmb3IodmFyIHQ9bmV3IEZsb2F0MzJBcnJheShlLnNpemUpLHI9ZS5kYXRhU3luYygpLG49MDtuPHIubGVuZ3RoOysrbil0W25dPXRhbmgocltuXSk7cmV0dXJuIFRlbnNvci5tYWtlKGUuc2hhcGUse3ZhbHVlczp0fSl9LGUucHJvdG90eXBlLmFzaW5oPWZ1bmN0aW9uKGUpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChlLFwiYXNpbmhcIik7Zm9yKHZhciB0PW5ldyBGbG9hdDMyQXJyYXkoZS5zaXplKSxyPWUuZGF0YVN5bmMoKSxuPTA7bjxyLmxlbmd0aDsrK24pdFtuXT1NYXRoLmFzaW5oKHJbbl0pO3JldHVybiBUZW5zb3IubWFrZShlLnNoYXBlLHt2YWx1ZXM6dH0pfSxlLnByb3RvdHlwZS5hY29zaD1mdW5jdGlvbihlKXt0aGlzLmFzc2VydE5vdENvbXBsZXgoZSxcImFjb3NoXCIpO2Zvcih2YXIgdD1uZXcgRmxvYXQzMkFycmF5KGUuc2l6ZSkscj1lLmRhdGFTeW5jKCksbj0wO248ci5sZW5ndGg7KytuKXRbbl09TWF0aC5hY29zaChyW25dKTtyZXR1cm4gVGVuc29yLm1ha2UoZS5zaGFwZSx7dmFsdWVzOnR9KX0sZS5wcm90b3R5cGUuYXRhbmg9ZnVuY3Rpb24oZSl7dGhpcy5hc3NlcnROb3RDb21wbGV4KGUsXCJhdGFuaFwiKTtmb3IodmFyIHQ9bmV3IEZsb2F0MzJBcnJheShlLnNpemUpLHI9ZS5kYXRhU3luYygpLG49MDtuPHIubGVuZ3RoOysrbil0W25dPU1hdGguYXRhbmgocltuXSk7cmV0dXJuIFRlbnNvci5tYWtlKGUuc2hhcGUse3ZhbHVlczp0fSl9LGUucHJvdG90eXBlLmVyZj1mdW5jdGlvbihlKXt0aGlzLmFzc2VydE5vdENvbXBsZXgoZSxcImVyZlwiKTtmb3IodmFyIHQ9bmV3IEZsb2F0MzJBcnJheShlLnNpemUpLHI9ZS5kYXRhU3luYygpLG49RVJGX1Asbz1FUkZfQTEsYT1FUkZfQTIsaT1FUkZfQTMscz1FUkZfQTQsdT1FUkZfQTUsbD0wO2w8ci5sZW5ndGg7KytsKXt2YXIgYz1yW2xdLHA9MS8oMStuKmMpO3RbbF09MS0oKCgodSpwK3MpKnAraSkqcCthKSpwK28pKnAqTWF0aC5leHAoLWMqYyl9cmV0dXJuIFRlbnNvci5tYWtlKGUuc2hhcGUse3ZhbHVlczp0fSl9LGUucHJvdG90eXBlLnN0ZXA9ZnVuY3Rpb24oZSx0KXt2b2lkIDA9PT10JiYodD0wKSx0aGlzLmFzc2VydE5vdENvbXBsZXgoZSxcInN0ZXBcIik7Zm9yKHZhciByPW5ldyBGbG9hdDMyQXJyYXkoZS5zaXplKSxuPWUuZGF0YVN5bmMoKSxvPTA7bzxuLmxlbmd0aDsrK28pe3ZhciBhPW5bb107aXNOYU4oYSk/cltvXT1OYU46cltvXT1hPjA/MTp0fXJldHVybiBUZW5zb3IubWFrZShlLnNoYXBlLHt2YWx1ZXM6cn0pfSxlLnByb3RvdHlwZS5jb252MmQ9ZnVuY3Rpb24oZSx0LHIpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChbZSx0XSxcImNvbnYyZFwiKTtmb3IodmFyIG49ci5maWx0ZXJIZWlnaHQsbz1yLmZpbHRlcldpZHRoLGE9ci5kaWxhdGlvbkhlaWdodCxpPXIuZGlsYXRpb25XaWR0aCxzPXIucGFkSW5mby5sZWZ0LHU9ci5wYWRJbmZvLnRvcCxsPWJ1ZmZlcihyLm91dFNoYXBlLGUuZHR5cGUpLGM9ZS5kYXRhU3luYygpLHA9dC5kYXRhU3luYygpLGQ9bC52YWx1ZXMsaD0wO2g8ci5iYXRjaFNpemU7KytoKWZvcih2YXIgZj1oKmUuc3RyaWRlc1swXSxtPWgqbC5zdHJpZGVzWzBdLGc9MDtnPHIub3V0SGVpZ2h0OysrZylmb3IodmFyIHY9bStnKmwuc3RyaWRlc1sxXSx5PWcqci5zdHJpZGVIZWlnaHQtcyx4PTA7eDxuO3grKyl7dmFyIFQ9eSt4KmE7aWYoIShUPDB8fFQ+PXIuaW5IZWlnaHQpKWZvcih2YXIgRT14KnQuc3RyaWRlc1swXSx3PWYrVCplLnN0cmlkZXNbMV0sUz0wO1M8ci5vdXRXaWR0aDsrK1MpZm9yKHZhciBiPXYrUypyLm91dENoYW5uZWxzLEM9UypyLnN0cmlkZVdpZHRoLXUsXz0wO188bztfKyspe3ZhciBBPUMrXyppO2lmKCEoQTwwfHxBPj1yLmluV2lkdGgpKWZvcih2YXIgTj1FK18qdC5zdHJpZGVzWzFdLFI9dytBKnIuaW5DaGFubmVscyxJPU4saz0wO2s8ci5pbkNoYW5uZWxzOysrayl7Zm9yKHZhciBEPWNbUitrXSxNPTA7TTxyLm91dENoYW5uZWxzOysrTSlkW2IrTV0rPUQqcFtJK01dO0krPXIub3V0Q2hhbm5lbHN9fX1yZXR1cm4gbC50b1RlbnNvcigpfSxlLnByb3RvdHlwZS5jb252MmREZXJJbnB1dD1mdW5jdGlvbihlLHQscil7dGhpcy5hc3NlcnROb3RDb21wbGV4KFtlLHRdLFwiY29udjJkRGVySW5wdXRcIik7Zm9yKHZhciBuPWJ1ZmZlcihyLmluU2hhcGUsXCJmbG9hdDMyXCIpLG89bi52YWx1ZXMsYT1uLnN0cmlkZXMsaT1hWzBdLHM9YVsxXSx1PWFbMl0sbD1lLmRhdGFTeW5jKCksYz1lLnN0cmlkZXMscD1jWzBdLGQ9Y1sxXSxoPWNbMl0sZj10LmRhdGFTeW5jKCksbT10LnN0cmlkZXMsZz1tWzBdLHY9bVsxXSx5PW1bMl0seD1yLmJhdGNoU2l6ZSxUPXIuZmlsdGVySGVpZ2h0LEU9ci5maWx0ZXJXaWR0aCx3PXIuaW5DaGFubmVscyxTPXIuaW5IZWlnaHQsYj1yLmluV2lkdGgsQz1yLm91dENoYW5uZWxzLF89ci5vdXRIZWlnaHQsQT1yLm91dFdpZHRoLE49ci5zdHJpZGVIZWlnaHQsUj1yLnN0cmlkZVdpZHRoLEk9VC0xLXIucGFkSW5mby50b3Asaz1FLTEtci5wYWRJbmZvLmxlZnQsRD0wO0Q8eDsrK0QpZm9yKHZhciBNPTA7TTx3OysrTSlmb3IodmFyIE89MDtPPFM7KytPKWZvcih2YXIgUD1PLUksRj1NYXRoLm1heCgwLE1hdGguY2VpbChQL04pKSxMPU1hdGgubWluKF8sKFQrUCkvTiksQj0wO0I8YjsrK0Ipe2Zvcih2YXIgVT1CLWssej1NYXRoLm1heCgwLE1hdGguY2VpbChVL1IpKSxWPU1hdGgubWluKEEsKEUrVSkvUiksSD0wLEc9RjtHPEw7KytHKWZvcih2YXIgVz1HKk4tUCxxPXo7cTxWOysrcSlmb3IodmFyICQ9cCpEK2QqRytoKnEsWD1nKihULTEtVykrdiooRS0xLShxKlItVSkpK3kqTSxLPTA7SzxDOysrSyl7SCs9bFskK0tdKmZbWCtLXX1vW2kqRCtzKk8rdSpCK01dPUh9cmV0dXJuIG4udG9UZW5zb3IoKX0sZS5wcm90b3R5cGUuY29udjJkRGVyRmlsdGVyPWZ1bmN0aW9uKGUsdCxyKXt0aGlzLmFzc2VydE5vdENvbXBsZXgoW2UsdF0sXCJjb252MmREZXJGaWx0ZXJcIik7Zm9yKHZhciBuPXIuc3RyaWRlSGVpZ2h0LG89ci5zdHJpZGVXaWR0aCxhPXIuZmlsdGVySGVpZ2h0LGk9ci5maWx0ZXJXaWR0aCxzPWJ1ZmZlcihyLmZpbHRlclNoYXBlLFwiZmxvYXQzMlwiKSx1PXIucGFkSW5mby5sZWZ0LGw9ci5wYWRJbmZvLnRvcCxjPTA7YzxhOysrYylmb3IodmFyIHA9TWF0aC5tYXgoMCxNYXRoLmNlaWwoKGwtYykvbikpLGQ9TWF0aC5taW4oci5vdXRIZWlnaHQsKHIuaW5IZWlnaHQrbC1jKS9uKSxoPTA7aDxpOysraClmb3IodmFyIGY9TWF0aC5tYXgoMCxNYXRoLmNlaWwoKHUtaCkvbykpLG09TWF0aC5taW4oci5vdXRXaWR0aCwoci5pbldpZHRoK3UtaCkvbyksZz0wO2c8ci5pbkNoYW5uZWxzOysrZylmb3IodmFyIHY9MDt2PHIub3V0Q2hhbm5lbHM7Kyt2KXtmb3IodmFyIHk9MCx4PTA7eDxyLmJhdGNoU2l6ZTsrK3gpZm9yKHZhciBUPXA7VDxkOysrVClmb3IodmFyIEU9YytUKm4tbCx3PWY7dzxtOysrdyl7dmFyIFM9aCt3Km8tdTt5Kz1lLmdldCh4LEUsUyxnKSp0LmdldCh4LFQsdyx2KX1zLnNldCh5LGMsaCxnLHYpfXJldHVybiBzLnRvVGVuc29yKCl9LGUucHJvdG90eXBlLmRlcHRod2lzZUNvbnYyRD1mdW5jdGlvbihlLHQscil7dGhpcy5hc3NlcnROb3RDb21wbGV4KFtlLHRdLFwiZGVwdGh3aXNlQ29udjJEXCIpO2Zvcih2YXIgbj1yLmZpbHRlckhlaWdodCxvPXIuZmlsdGVyV2lkdGgsYT1yLmRpbGF0aW9uSGVpZ2h0LGk9ci5kaWxhdGlvbldpZHRoLHM9ci5wYWRJbmZvLmxlZnQsdT1yLnBhZEluZm8udG9wLGw9ci5vdXRDaGFubmVscy9yLmluQ2hhbm5lbHMsYz1idWZmZXIoci5vdXRTaGFwZSxlLmR0eXBlKSxwPWUuZGF0YVN5bmMoKSxkPXQuZGF0YVN5bmMoKSxoPWMudmFsdWVzLGY9MDtmPHIuYmF0Y2hTaXplOysrZilmb3IodmFyIG09ZiplLnN0cmlkZXNbMF0sZz1mKmMuc3RyaWRlc1swXSx2PTA7djxyLm91dEhlaWdodDsrK3YpZm9yKHZhciB5PWcrdipjLnN0cmlkZXNbMV0seD12KnIuc3RyaWRlSGVpZ2h0LXMsVD0wO1Q8bjsrK1Qpe3ZhciBFPXgrVCphO2lmKCEoRTwwfHxFPj1yLmluSGVpZ2h0KSlmb3IodmFyIHc9VCp0LnN0cmlkZXNbMF0sUz1tK0UqZS5zdHJpZGVzWzFdLGI9MDtiPHIub3V0V2lkdGg7KytiKWZvcih2YXIgQz15K2IqYy5zdHJpZGVzWzJdLF89YipyLnN0cmlkZVdpZHRoLXUsQT0wO0E8bzsrK0Epe3ZhciBOPV8rQSppO2lmKCEoTjwwfHxOPj1yLmluV2lkdGgpKWZvcih2YXIgUj13K0EqdC5zdHJpZGVzWzFdLEk9UytOKnIuaW5DaGFubmVscyxrPUMsRD1SLE09MDtNPHIuaW5DaGFubmVsczsrK00pe2Zvcih2YXIgTz1wW0krTV0sUD0wO1A8bDsrK1ApaFtrK1BdKz1PKmRbRCtQXTtrKz1sLEQrPWx9fX1yZXR1cm4gYy50b1RlbnNvcigpfSxlLnByb3RvdHlwZS5kZXB0aHdpc2VDb252MkREZXJJbnB1dD1mdW5jdGlvbihlLHQscil7dGhpcy5hc3NlcnROb3RDb21wbGV4KFtlLHRdLFwiZGVwdGh3aXNlQ29udjJERGVySW5wdXRcIik7Zm9yKHZhciBuPWJ1ZmZlcihyLmluU2hhcGUsXCJmbG9hdDMyXCIpLG89bi52YWx1ZXMsYT1uLnN0cmlkZXMsaT1hWzBdLHM9YVsxXSx1PWFbMl0sbD1lLmRhdGFTeW5jKCksYz1lLnN0cmlkZXMscD1jWzBdLGQ9Y1sxXSxoPWNbMl0sZj10LmRhdGFTeW5jKCksbT10LnN0cmlkZXMsZz1tWzBdLHY9bVsxXSx5PW1bMl0seD1yLmJhdGNoU2l6ZSxUPXIuZmlsdGVySGVpZ2h0LEU9ci5maWx0ZXJXaWR0aCx3PXIuaW5DaGFubmVscyxTPXIuaW5IZWlnaHQsYj1yLmluV2lkdGgsQz1yLm91dENoYW5uZWxzLF89ci5vdXRIZWlnaHQsQT1yLm91dFdpZHRoLE49ci5zdHJpZGVIZWlnaHQsUj1yLnN0cmlkZVdpZHRoLEk9VC0xLXIucGFkSW5mby50b3Asaz1FLTEtci5wYWRJbmZvLmxlZnQsRD1DL3csTT0wO008eDsrK00pZm9yKHZhciBPPTA7Tzx3OysrTylmb3IodmFyIFA9MDtQPFM7KytQKWZvcih2YXIgRj1QLUksTD1NYXRoLm1heCgwLE1hdGguY2VpbChGL04pKSxCPU1hdGgubWluKF8sKFQrRikvTiksVT0wO1U8YjsrK1Upe2Zvcih2YXIgej1VLWssVj1NYXRoLm1heCgwLE1hdGguY2VpbCh6L1IpKSxIPU1hdGgubWluKEEsKEUreikvUiksRz0wLFc9TDtXPEI7KytXKWZvcih2YXIgcT1XKk4tRiwkPVY7JDxIOysrJClmb3IodmFyIFg9cCpNK2QqVytoKiQsSz1nKihULTEtcSkrdiooRS0xLSgkKlIteikpK3kqTyxqPTA7ajxEOysrail7Rys9bFtYKyhPKkQraildKmZbSytqXX1vW2kqTStzKlArdSpVK09dPUd9cmV0dXJuIG4udG9UZW5zb3IoKX0sZS5wcm90b3R5cGUuZGVwdGh3aXNlQ29udjJERGVyRmlsdGVyPWZ1bmN0aW9uKGUsdCxyKXt0aGlzLmFzc2VydE5vdENvbXBsZXgoW2UsdF0sXCJkZXB0aHdpc2VDb252MkREZXJGaWx0ZXJcIik7Zm9yKHZhciBuPXIuc3RyaWRlSGVpZ2h0LG89ci5zdHJpZGVXaWR0aCxhPXIuZmlsdGVySGVpZ2h0LGk9ci5maWx0ZXJXaWR0aCxzPWJ1ZmZlcihyLmZpbHRlclNoYXBlLFwiZmxvYXQzMlwiKSx1PXIucGFkSW5mby5sZWZ0LGw9ci5wYWRJbmZvLnRvcCxjPXIub3V0Q2hhbm5lbHMvci5pbkNoYW5uZWxzLHA9MDtwPGE7KytwKWZvcih2YXIgZD1NYXRoLm1heCgwLE1hdGguY2VpbCgobC1wKS9uKSksaD1NYXRoLm1pbihyLm91dEhlaWdodCwoci5pbkhlaWdodCtsLXApL24pLGY9MDtmPGk7KytmKWZvcih2YXIgbT1NYXRoLm1heCgwLE1hdGguY2VpbCgodS1mKS9vKSksZz1NYXRoLm1pbihyLm91dFdpZHRoLChyLmluV2lkdGgrdS1mKS9vKSx2PTA7djxyLm91dENoYW5uZWxzOysrdil7Zm9yKHZhciB5PU1hdGgudHJ1bmModi9jKSx4PXYlYyxUPTAsRT0wO0U8ci5iYXRjaFNpemU7KytFKWZvcih2YXIgdz1kO3c8aDsrK3cpZm9yKHZhciBTPXArdypuLWwsYj1tO2I8ZzsrK2Ipe3ZhciBDPWYrYipvLXU7VCs9ZS5nZXQoRSxTLEMseSkqdC5nZXQoRSx3LGIsdil9cy5zZXQoVCxwLGYseSx4KX1yZXR1cm4gcy50b1RlbnNvcigpfSxlLnByb3RvdHlwZS50aWxlPWZ1bmN0aW9uKGUsdCl7dGhpcy5hc3NlcnROb3RDb21wbGV4KGUsXCJ0aWxlXCIpO2Zvcih2YXIgcj1uZXcgQXJyYXkoZS5yYW5rKSxuPTA7bjxyLmxlbmd0aDtuKyspcltuXT1lLnNoYXBlW25dKnRbbl07dmFyIG89YnVmZmVyKHIsZS5kdHlwZSksYT1lLmJ1ZmZlcigpO2ZvcihuPTA7bjxvLnZhbHVlcy5sZW5ndGg7KytuKXtmb3IodmFyIGk9by5pbmRleFRvTG9jKG4pLHM9bmV3IEFycmF5KGUucmFuayksdT0wO3U8cy5sZW5ndGg7dSsrKXNbdV09aVt1XSVlLnNoYXBlW3VdO3ZhciBsPWEubG9jVG9JbmRleChzKTtvLnZhbHVlc1tuXT1hLnZhbHVlc1tsXX1yZXR1cm4gby50b1RlbnNvcigpfSxlLnByb3RvdHlwZS5wYWQ9ZnVuY3Rpb24oZSx0LHIpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChlLFwicGFkXCIpO3ZhciBuPXQubWFwKGZ1bmN0aW9uKHQscil7cmV0dXJuIHRbMF0rZS5zaGFwZVtyXSt0WzFdfSksbz10Lm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZVswXX0pLGE9ZS5idWZmZXIoKSxpPWJ1ZmZlcihuLGUuZHR5cGUpOzAhPT1yJiZpLnZhbHVlcy5maWxsKHIpO2Zvcih2YXIgcz0wO3M8ZS5zaXplO3MrKyl7dmFyIHU9YS5pbmRleFRvTG9jKHMpLGw9dS5tYXAoZnVuY3Rpb24oZSx0KXtyZXR1cm4gZStvW3RdfSk7aS5zZXQuYXBwbHkoaSxbZS5nZXQuYXBwbHkoZSx1KV0uY29uY2F0KGwpKX1yZXR1cm4gaS50b1RlbnNvcigpfSxlLnByb3RvdHlwZS50cmFuc3Bvc2U9ZnVuY3Rpb24oZSx0KXt0aGlzLmFzc2VydE5vdENvbXBsZXgoZSxcInRyYW5zcG9zZVwiKTtmb3IodmFyIHI9bmV3IEFycmF5KGUucmFuayksbj0wO248ci5sZW5ndGg7bisrKXJbbl09ZS5zaGFwZVt0W25dXTt2YXIgbz1lLmRhdGFTeW5jKCksYT1idWZmZXIocixlLmR0eXBlKSxpPWUuYnVmZmVyKCk7Zm9yKG49MDtuPGUuc2l6ZTsrK24pe2Zvcih2YXIgcz1pLmluZGV4VG9Mb2MobiksdT1uZXcgQXJyYXkocy5sZW5ndGgpLGw9MDtsPHUubGVuZ3RoO2wrKyl1W2xdPXNbdFtsXV07dmFyIGM9YS5sb2NUb0luZGV4KHUpO2EudmFsdWVzW2NdPW9bbl19cmV0dXJuIGEudG9UZW5zb3IoKX0sZS5wcm90b3R5cGUuZ2F0aGVyPWZ1bmN0aW9uKGUsdCxyKXt0aGlzLmFzc2VydE5vdENvbXBsZXgoW2UsdF0sXCJnYXRoZXJcIik7dmFyIG49ZS5zaGFwZS5zbGljZSgpLG89dC5kYXRhU3luYygpO25bcl09by5sZW5ndGg7Zm9yKHZhciBhPWJ1ZmZlcihuLGUuZHR5cGUpLGk9ZS5idWZmZXIoKSxzPTA7czxhLnNpemU7KytzKXt2YXIgdT1hLmluZGV4VG9Mb2MocyksbD11LnNsaWNlKCk7bFtyXT1vW3Vbcl1dO3ZhciBjPWkubG9jVG9JbmRleChsKTthLnZhbHVlc1tzXT1pLnZhbHVlc1tjXX1yZXR1cm4gYS50b1RlbnNvcigpfSxlLnByb3RvdHlwZS5iYXRjaFRvU3BhY2VORD1mdW5jdGlvbihlLHQscil7dGhpcy5hc3NlcnROb3RDb21wbGV4KFtlXSxcImJhdGNoVG9TcGFjZU5EXCIpO3ZhciBuPXQucmVkdWNlKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUqdH0pLG89Z2V0UmVzaGFwZWQoZS5zaGFwZSx0LG4pLGE9Z2V0UGVybXV0ZWQoby5sZW5ndGgsdC5sZW5ndGgpLGk9Z2V0UmVzaGFwZWRQZXJtdXRlZChlLnNoYXBlLHQsbikscz1nZXRTbGljZUJlZ2luQ29vcmRzKHIsdC5sZW5ndGgpLHU9Z2V0U2xpY2VTaXplKGkscix0Lmxlbmd0aCk7cmV0dXJuIGUucmVzaGFwZShvKS50cmFuc3Bvc2UoYSkucmVzaGFwZShpKS5zbGljZShzLHUpfSxlLnByb3RvdHlwZS5zcGFjZVRvQmF0Y2hORD1mdW5jdGlvbihlLHQscil7dGhpcy5hc3NlcnROb3RDb21wbGV4KFtlXSxcInNwYWNlVG9CYXRjaE5EXCIpO3ZhciBuPXQucmVkdWNlKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUqdH0pLG89W1swLDBdXTtvLnB1c2guYXBwbHkobyxyKTtmb3IodmFyIGE9MSt0Lmxlbmd0aDthPGUuc2hhcGUubGVuZ3RoOysrYSlvLnB1c2goWzAsMF0pO3ZhciBpPWUucGFkKG8pLHM9Z2V0UmVzaGFwZWQoaS5zaGFwZSx0LG4sITEpLHU9Z2V0UGVybXV0ZWQocy5sZW5ndGgsdC5sZW5ndGgsITEpLGw9Z2V0UmVzaGFwZWRQZXJtdXRlZChpLnNoYXBlLHQsbiwhMSk7cmV0dXJuIGkucmVzaGFwZShzKS50cmFuc3Bvc2UodSkucmVzaGFwZShsKX0sZS5wcm90b3R5cGUucG9vbD1mdW5jdGlvbihlLHQscil7dGhpcy5hc3NlcnROb3RDb21wbGV4KGUsXCJwb29sXCIpO2Zvcih2YXIgbj10LnN0cmlkZUhlaWdodCxvPXQuc3RyaWRlV2lkdGgsYT10LmRpbGF0aW9uSGVpZ2h0LGk9dC5kaWxhdGlvbldpZHRoLHM9dC5lZmZlY3RpdmVGaWx0ZXJIZWlnaHQsdT10LmVmZmVjdGl2ZUZpbHRlcldpZHRoLGw9dC5wYWRJbmZvLnRvcCxjPXQucGFkSW5mby5sZWZ0LHA9XCJtYXhcIj09PXI/TnVtYmVyLk5FR0FUSVZFX0lORklOSVRZOk51bWJlci5QT1NJVElWRV9JTkZJTklUWSxkPWUuZGF0YVN5bmMoKSxoPWJ1ZmZlcih0Lm91dFNoYXBlLGUuZHR5cGUpLGY9aC52YWx1ZXMsbT10Lm91dFNoYXBlWzFdKnQub3V0U2hhcGVbMl0qdC5vdXRTaGFwZVszXSxnPXQub3V0U2hhcGVbMl0qdC5vdXRTaGFwZVszXSx2PXQub3V0U2hhcGVbM10seT0wO3k8dC5iYXRjaFNpemU7Kyt5KWZvcih2YXIgeD15Km0sVD15KmUuc3RyaWRlc1swXSxFPTA7RTx0LmluQ2hhbm5lbHM7KytFKWZvcih2YXIgdz0wO3c8dC5vdXRIZWlnaHQ7Kyt3KWZvcih2YXIgUz13Km4tbCxiPU1hdGgubWF4KDAsUyksQz1NYXRoLm1pbih0LmluSGVpZ2h0LHMrUyksXz14K3cqZyxBPTA7QTx0Lm91dFdpZHRoOysrQSl7Zm9yKHZhciBOPUEqby1jLFI9TWF0aC5tYXgoMCxOKSxJPU1hdGgubWluKHQuaW5XaWR0aCx1K04pLGs9cCxEPTAsTT0wLE89YjtPPEM7Tys9YSl7Zm9yKHZhciBQPVQrTyplLnN0cmlkZXNbMV0sRj1SO0Y8STtGKz1pKXt2YXIgTD1kW1ArRiplLnN0cmlkZXNbMl0rRV07XCJtYXhcIj09PXImJkw+az9rPUw6XCJhdmdcIj09PXImJihEKz1MLE0rKyl9aWYoaXNOYU4oaykpYnJlYWt9ZltfK0EqditFXT1cImF2Z1wiPT09cj9EL006a31yZXR1cm4gaC50b1RlbnNvcigpfSxlLnByb3RvdHlwZS5tYXhQb29sPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMucG9vbChlLHQsXCJtYXhcIil9LGUucHJvdG90eXBlLm1heFBvb2xQb3NpdGlvbnM9ZnVuY3Rpb24oZSx0KXtmb3IodmFyIHI9YnVmZmVyKHQub3V0U2hhcGUsXCJpbnQzMlwiKSxuPXQuc3RyaWRlSGVpZ2h0LG89dC5zdHJpZGVXaWR0aCxhPXQuZGlsYXRpb25IZWlnaHQsaT10LmRpbGF0aW9uV2lkdGgscz10LmVmZmVjdGl2ZUZpbHRlckhlaWdodCx1PXQuZWZmZWN0aXZlRmlsdGVyV2lkdGgsbD10LnBhZEluZm8udG9wLGM9dC5wYWRJbmZvLmxlZnQscD0wO3A8dC5iYXRjaFNpemU7KytwKWZvcih2YXIgZD0wO2Q8dC5pbkNoYW5uZWxzOysrZClmb3IodmFyIGg9MDtoPHQub3V0SGVpZ2h0OysraCl7Zm9yKHZhciBmPWgqbi1sLG09ZjttPDA7KW0rPWE7Zm9yKHZhciBnPU1hdGgubWluKHQuaW5IZWlnaHQscytmKSx2PTA7djx0Lm91dFdpZHRoOysrdil7Zm9yKHZhciB5PXYqby1jLHg9eTt4PDA7KXgrPWk7Zm9yKHZhciBUPU1hdGgubWluKHQuaW5XaWR0aCx1K3kpLEU9TnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLHc9LTEsUz1tO1M8ZztTKz1hKWZvcih2YXIgYj1TLWYsQz14O0M8VDtDKz1pKXt2YXIgXz1DLXksQT1lLmdldChwLFMsQyxkKTtBPkUmJihFPUEsdz1iKnUrXyl9ci5zZXQodyxwLGgsdixkKX19cmV0dXJuIHIudG9UZW5zb3IoKX0sZS5wcm90b3R5cGUubWF4UG9vbEJhY2twcm9wPWZ1bmN0aW9uKGUsdCxyLG4pe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChbdCxyXSxcIm1heFBvb2xCYWNrcHJvcFwiKTtmb3IodmFyIG89dGhpcy5tYXhQb29sUG9zaXRpb25zKHQsbiksYT1uLnN0cmlkZUhlaWdodCxpPW4uc3RyaWRlV2lkdGgscz1uLmRpbGF0aW9uSGVpZ2h0LHU9bi5kaWxhdGlvbldpZHRoLGw9bi5lZmZlY3RpdmVGaWx0ZXJIZWlnaHQsYz1uLmVmZmVjdGl2ZUZpbHRlcldpZHRoLHA9Yy0xLW4ucGFkSW5mby5sZWZ0LGQ9bC0xLW4ucGFkSW5mby50b3AsaD1idWZmZXIodC5zaGFwZSxcImZsb2F0MzJcIiksZj0wO2Y8bi5iYXRjaFNpemU7KytmKWZvcih2YXIgbT0wO208bi5pbkNoYW5uZWxzOysrbSlmb3IodmFyIGc9MDtnPG4uaW5IZWlnaHQ7KytnKWZvcih2YXIgdj0wO3Y8bi5pbldpZHRoOysrdil7Zm9yKHZhciB5PWctZCx4PXYtcCxUPTAsRT0wO0U8bDtFKz1zKXt2YXIgdz0oeStFKS9hO2lmKCEodzwwfHx3Pj1uLm91dEhlaWdodHx8TWF0aC5mbG9vcih3KSE9PXcpKWZvcih2YXIgUz0wO1M8YztTKz11KXt2YXIgYj0oeCtTKS9pO2lmKCEoYjwwfHxiPj1uLm91dFdpZHRofHxNYXRoLmZsb29yKGIpIT09Yikpe3ZhciBDPWwqYy0xLW8uZ2V0KGYsdyxiLG0pPT09RSpjK1M/MTowO2lmKDAhPT1DKVQrPWUuZ2V0KGYsdyxiLG0pKkN9fX1oLnNldChULGYsZyx2LG0pfXJldHVybiBoLnRvVGVuc29yKCl9LGUucHJvdG90eXBlLmF2Z1Bvb2xCYWNrcHJvcD1mdW5jdGlvbihlLHQscil7dGhpcy5hc3NlcnROb3RDb21wbGV4KFtlLHRdLFwiYXZnUG9vbEJhY2twcm9wXCIpO2Zvcih2YXIgbj1yLnN0cmlkZUhlaWdodCxvPXIuc3RyaWRlV2lkdGgsYT1yLmZpbHRlckhlaWdodCxpPXIuZmlsdGVyV2lkdGgscz1yLmRpbGF0aW9uSGVpZ2h0LHU9ci5kaWxhdGlvbldpZHRoLGw9ci5lZmZlY3RpdmVGaWx0ZXJIZWlnaHQsYz1yLmVmZmVjdGl2ZUZpbHRlcldpZHRoLHA9Yy0xLXIucGFkSW5mby5sZWZ0LGQ9bC0xLXIucGFkSW5mby50b3AsaD1idWZmZXIodC5zaGFwZSxcImZsb2F0MzJcIiksZj0xLyhhKmkpLG09MDttPHIuYmF0Y2hTaXplOysrbSlmb3IodmFyIGc9MDtnPHIuaW5DaGFubmVsczsrK2cpZm9yKHZhciB2PTA7djxyLmluSGVpZ2h0Oysrdilmb3IodmFyIHk9MDt5PHIuaW5XaWR0aDsrK3kpe2Zvcih2YXIgeD12LWQsVD15LXAsRT0wLHc9MDt3PGw7dys9cyl7dmFyIFM9KHgrdykvbjtpZighKFM8MHx8Uz49ci5vdXRIZWlnaHR8fE1hdGguZmxvb3IoUykhPT1TKSlmb3IodmFyIGI9MDtiPGM7Yis9dSl7dmFyIEM9KFQrYikvbztpZighKEM8MHx8Qz49ci5vdXRXaWR0aHx8TWF0aC5mbG9vcihDKSE9PUMpKUUrPWUuZ2V0KG0sUyxDLGcpfX1oLnNldChFKmYsbSx2LHksZyl9cmV0dXJuIGgudG9UZW5zb3IoKX0sZS5wcm90b3R5cGUuY2FzdD1mdW5jdGlvbihlLHQpe3JldHVybiBjYXN0VGVuc29yKGUsdCx0aGlzKX0sZS5wcm90b3R5cGUucmVzaGFwZT1mdW5jdGlvbihlLHQpe3JldHVybiByZXNoYXBlVGVuc29yKGUsdCl9LGUucHJvdG90eXBlLmF2Z1Bvb2w9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5hc3NlcnROb3RDb21wbGV4KGUsXCJhdmdQb29sXCIpLHRoaXMucG9vbChlLHQsXCJhdmdcIikudG9GbG9hdCgpfSxlLnByb3RvdHlwZS5yZXNpemVCaWxpbmVhcj1mdW5jdGlvbihlLHQscixuKXt0aGlzLmFzc2VydE5vdENvbXBsZXgoZSxcInJlc2l6ZUJpbGluZWFyXCIpO2Zvcih2YXIgbz1lLnNoYXBlLGE9b1swXSxpPW9bMV0scz1vWzJdLHU9b1szXSxsPWUuZGF0YVN5bmMoKSxjPW5ldyBGbG9hdDMyQXJyYXkoc2l6ZUZyb21TaGFwZShbYSx0LHIsdV0pKSxwPVtuJiZ0PjE/aS0xOmksbiYmcj4xP3MtMTpzXSxkPVtuJiZ0PjE/dC0xOnQsbiYmcj4xP3ItMTpyXSxoPTAsZj1wWzBdL2RbMF0sbT1wWzFdL2RbMV0sZz0wO2c8YTtnKyspZm9yKHZhciB2PTA7djx0O3YrKylmb3IodmFyIHk9Zip2LHg9TWF0aC5mbG9vcih5KSxUPXkteCxFPU1hdGgubWluKGktMSxNYXRoLmNlaWwoeSkpLHc9ZyplLnN0cmlkZXNbMF0reCplLnN0cmlkZXNbMV0sUz1nKmUuc3RyaWRlc1swXStFKmUuc3RyaWRlc1sxXSxiPTA7YjxyO2IrKylmb3IodmFyIEM9bSpiLF89TWF0aC5mbG9vcihDKSxBPUMtXyxOPU1hdGgubWluKHMtMSxNYXRoLmNlaWwoQykpLFI9dytfKmUuc3RyaWRlc1syXSxJPVMrXyplLnN0cmlkZXNbMl0saz13KyArTiplLnN0cmlkZXNbMl0sRD1TK04qZS5zdHJpZGVzWzJdLE09MDtNPHU7TSsrKXt2YXIgTz1sW1IrTV0sUD1sW0krTV0sRj1PKyhsW2srTV0tTykqQSxMPUYrKFArKGxbRCtNXS1QKSpBLUYpKlQ7Y1toKytdPUx9cmV0dXJuIHRlbnNvcihjLFthLHQscix1XSl9LGUucHJvdG90eXBlLnJlc2l6ZUJpbGluZWFyQmFja3Byb3A9ZnVuY3Rpb24oZSx0LHIpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChbZSx0XSxcInJlc2l6ZUJpbGluZWFyQmFja3Byb3BcIik7Zm9yKHZhciBuPXQuc2hhcGUsbz1uWzBdLGE9blsxXSxpPW5bMl0scz1uWzNdLHU9ZS5zaGFwZSxsPXVbMV0sYz11WzJdLHA9bmV3IEZsb2F0MzJBcnJheShvKmEqaSpzKSxkPVtyJiZsPjE/YS0xOmEsciYmYz4xP2ktMTppXSxoPVtyJiZsPjE/bC0xOmwsciYmYz4xP2MtMTpjXSxmPWRbMF0vaFswXSxtPWRbMV0vaFsxXSxnPWUuZGF0YVN5bmMoKSx2PTAseT0wO3k8bzt5KyspZm9yKHZhciB4PXkqdC5zdHJpZGVzWzBdLFQ9MDtUPGw7VCsrKWZvcih2YXIgRT1UKmYsdz1NYXRoLmZsb29yKEUpLFM9TWF0aC5taW4oTWF0aC5jZWlsKEUpLGEtMSksYj14K3cqdC5zdHJpZGVzWzFdLEM9eCtTKnQuc3RyaWRlc1sxXSxfPUUtdyxBPTEtXyxOPTA7TjxjO04rKylmb3IodmFyIFI9TiptLEk9TWF0aC5mbG9vcihSKSxrPU1hdGgubWluKE1hdGguY2VpbChSKSxpLTEpLEQ9Ui1JLE09MS1ELE89YitJKnQuc3RyaWRlc1syXSxQPWIrayp0LnN0cmlkZXNbMl0sRj1DK0kqdC5zdHJpZGVzWzJdLEw9QytrKnQuc3RyaWRlc1syXSxCPUEqTSxVPUEqRCx6PV8qTSxWPV8qRCxIPTA7SDxzO0grKyl7dmFyIEc9Z1t2KytdO3BbTytIXSs9RypCLHBbUCtIXSs9RypVLHBbRitIXSs9Ryp6LHBbTCtIXSs9RypWfXJldHVybiB0ZW5zb3I0ZChwLFtvLGksYSxzXSx0LmR0eXBlKX0sZS5wcm90b3R5cGUucmVzaXplTmVhcmVzdE5laWdoYm9yPWZ1bmN0aW9uKGUsdCxyLG4pe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChlLFwicmVzaXplTmVhcmVzdE5laWdoYm9yXCIpO2Zvcih2YXIgbz1lLnNoYXBlLGE9b1swXSxpPW9bMV0scz1vWzJdLHU9b1szXSxsPWUuZGF0YVN5bmMoKSxjPW5ldyBGbG9hdDMyQXJyYXkoYSp0KnIqdSkscD1bbiYmdD4xP2ktMTppLG4mJnI+MT9zLTE6c10sZD1bbiYmdD4xP3QtMTp0LG4mJnI+MT9yLTE6cl0saD1wWzBdL2RbMF0sZj1wWzFdL2RbMV0sbT0wLGc9MDtnPGE7ZysrKWZvcih2YXIgdj1nKmUuc3RyaWRlc1swXSx5PTA7eTx0O3krKylmb3IodmFyIHg9aCp5LFQ9ditNYXRoLm1pbihpLTEsbj9NYXRoLnJvdW5kKHgpOk1hdGguZmxvb3IoeCkpKmUuc3RyaWRlc1sxXSxFPTA7RTxyO0UrKylmb3IodmFyIHc9ZipFLFM9VCtNYXRoLm1pbihzLTEsbj9NYXRoLnJvdW5kKHcpOk1hdGguZmxvb3IodykpKmUuc3RyaWRlc1syXSxiPTA7Yjx1O2IrKyl7dmFyIEM9bFtTK2JdO2NbbSsrXT1DfXJldHVybiB0ZW5zb3IoYyxbYSx0LHIsdV0sZS5kdHlwZSl9LGUucHJvdG90eXBlLnJlc2l6ZU5lYXJlc3ROZWlnaGJvckJhY2twcm9wPWZ1bmN0aW9uKGUsdCxyKXt0aGlzLmFzc2VydE5vdENvbXBsZXgoW2UsdF0sXCJyZXNpemVOZWFyZXN0TmVpZ2hib3JCYWNrcHJvcFwiKTtmb3IodmFyIG49dC5zaGFwZSxvPW5bMF0sYT1uWzFdLGk9blsyXSxzPW5bM10sdT1lLnNoYXBlLGw9dVsxXSxjPXVbMl0scD1uZXcgRmxvYXQzMkFycmF5KG8qYSppKnMpLGQ9ZS5kYXRhU3luYygpLGg9W3ImJmw+MT9hLTE6YSxyJiZjPjE/aS0xOmldLGY9W3ImJmw+MT9sLTE6bCxyJiZjPjE/Yy0xOmNdLG09aFswXS9mWzBdLGc9aFsxXS9mWzFdLHY9MS9tLHk9MS9nLHg9MipNYXRoLmNlaWwodikrMixUPTIqTWF0aC5jZWlsKHkpKzIsRT0wO0U8bztFKyspZm9yKHZhciB3PUUqdC5zdHJpZGVzWzBdLFM9MDtTPGE7UysrKWZvcih2YXIgYj13K1MqdC5zdHJpZGVzWzFdLEM9TWF0aC5mbG9vcihTKnYpLF89TWF0aC5mbG9vcihDLXgvMiksQT0wO0E8aTtBKyspZm9yKHZhciBOPWIrQSp0LnN0cmlkZXNbMl0sUj1NYXRoLmZsb29yKEEqeSksST1NYXRoLmZsb29yKFItVC8yKSxrPTA7azxzO2srKyl7Zm9yKHZhciBEPTAsTT0wO008eDtNKyspe3ZhciBPPU0rXztpZighKE88MHx8Tz49bCkpe3ZhciBQPXcrTyplLnN0cmlkZXNbMV0sRj1PKm07aWYoUz09PU1hdGgubWluKGEtMSxyP01hdGgucm91bmQoRik6TWF0aC5mbG9vcihGKSkpZm9yKHZhciBMPTA7TDxUO0wrKyl7dmFyIEI9TCtJO2lmKCEoQjwwfHxCPj1jKSl7dmFyIFU9UCtCKmUuc3RyaWRlc1syXSx6PUIqZztBPT09TWF0aC5taW4oaS0xLHI/TWF0aC5yb3VuZCh6KTpNYXRoLmZsb29yKHopKSYmKEQrPWRbVStrXSl9fX19cFtOK2tdPUR9cmV0dXJuIHRlbnNvcjRkKHAsdC5zaGFwZSx0LmR0eXBlKX0sZS5wcm90b3R5cGUuYmF0Y2hOb3JtYWxpemF0aW9uPWZ1bmN0aW9uKGUsdCxyLG4sbyxhKXt0aGlzLmFzc2VydE5vdENvbXBsZXgoW2UsdCxyLG8sYV0sXCJiYXRjaE5vcm1hbGl6YXRpb25cIik7Zm9yKHZhciBpPWUuZGF0YVN5bmMoKSxzPXQuZGF0YVN5bmMoKSx1PXIuZGF0YVN5bmMoKSxsPW8/by5kYXRhU3luYygpOm5ldyBGbG9hdDMyQXJyYXkoWzFdKSxjPWE/YS5kYXRhU3luYygpOm5ldyBGbG9hdDMyQXJyYXkoWzBdKSxwPW5ldyBGbG9hdDMyQXJyYXkoaS5sZW5ndGgpLGQ9Yy5sZW5ndGgsaD1sLmxlbmd0aCxmPXUubGVuZ3RoLG09cy5sZW5ndGgsZz0wLHY9MCx5PTAseD0wLFQ9MDtUPGkubGVuZ3RoOysrVClwW1RdPWNbZysrXSsoaVtUXS1zW3YrK10pKmxbeSsrXS9NYXRoLnNxcnQodVt4KytdK24pLGc+PWQmJihnPTApLHY+PW0mJih2PTApLHk+PWgmJih5PTApLHg+PWYmJih4PTApO3JldHVybiB0ZW5zb3I0ZChwLGUuc2hhcGUpfSxlLnByb3RvdHlwZS5sb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbjREPWZ1bmN0aW9uKGUsdCxyLG4sbyl7dGhpcy5hc3NlcnROb3RDb21wbGV4KGUsXCJsb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbjREXCIpO3ZhciBhPWUuc2hhcGVbM10saT1hLTEscz1lLmRhdGFTeW5jKCksdT1zaXplRnJvbVNoYXBlKGUuc2hhcGUpLGw9bmV3IEZsb2F0MzJBcnJheSh1KTtmdW5jdGlvbiBjKGUpe2Zvcih2YXIgcj1lJWEsbj1lLXIrTWF0aC5tYXgoMCxyLXQpLG89ZS1yK01hdGgubWluKHIrdCxpKSx1PTA7bjw9bztuKyspe3ZhciBsPXNbbl07dSs9bCpsfXJldHVybiB1fWZvcih2YXIgcD0wO3A8dTtwKyspe3ZhciBkPWMocCksaD1zW3BdKk1hdGgucG93KHIrbipkLC1vKTtsW3BdPWh9cmV0dXJuIHRlbnNvcjRkKGwsZS5zaGFwZSl9LGUucHJvdG90eXBlLkxSTkdyYWQ9ZnVuY3Rpb24oZSx0LHIsbixvLGEsaSl7dGhpcy5hc3NlcnROb3RDb21wbGV4KGUsXCJMUk5HcmFkXCIpO2Zvcih2YXIgcz1lLnNoYXBlWzNdLHU9ZS5kYXRhU3luYygpLGw9dC5kYXRhU3luYygpLGM9ci5kYXRhU3luYygpLHA9bmV3IEZsb2F0MzJBcnJheShzaXplRnJvbVNoYXBlKGUuc2hhcGUpKSxkPXNpemVGcm9tU2hhcGUoZS5zaGFwZSksaD0wO2g8ZDtoKyspe2Zvcih2YXIgZj1oJXMsbT1oLWYrTWF0aC5tYXgoMCxmLW4pLGc9aC1mK01hdGgubWluKHMsZituKzEpLHY9MCx5PW07eTxnO3krKyl2Kz1NYXRoLnBvdyhsW3ldLDIpO3Y9YSp2K287Zm9yKHk9bTt5PGc7eSsrKXt2YXIgeD0tMiphKmkqbFt5XSpjW2hdL3Y7aD09PXkmJih4Kz1NYXRoLnBvdyh2LC1pKSkseCo9dVtoXSxwW3ldKz14fX1yZXR1cm4gdGVuc29yNGQocCxlLnNoYXBlKX0sZS5wcm90b3R5cGUubXVsdGlub21pYWw9ZnVuY3Rpb24oZSx0LHIsbil7dGhpcy5hc3NlcnROb3RDb21wbGV4KGUsXCJtdWx0aW5vbWlhbFwiKTtmb3IodmFyIG89dD9lOnNvZnRtYXgoZSksYT1vLnNoYXBlWzBdLGk9by5zaGFwZVsxXSxzPXplcm9zKFthLHJdLFwiaW50MzJcIiksdT1zLmRhdGFTeW5jKCksbD1vLmRhdGFTeW5jKCksYz0wO2M8YTsrK2Mpe3ZhciBwPWMqaSxkPW5ldyBGbG9hdDMyQXJyYXkoaS0xKTtkWzBdPWxbcF07Zm9yKHZhciBoPTE7aDxkLmxlbmd0aDsrK2gpZFtoXT1kW2gtMV0rbFtwK2hdO2Zvcih2YXIgZj1zZWVkcmFuZG9tXzEobi50b1N0cmluZygpKSxtPWMqcixnPTA7ZzxyOysrZyl7dmFyIHY9ZigpO3VbbStnXT1kLmxlbmd0aDtmb3IodmFyIHk9MDt5PGQubGVuZ3RoO3krKylpZih2PGRbeV0pe3VbbStnXT15O2JyZWFrfX19cmV0dXJuIHN9LGUucHJvdG90eXBlLm9uZUhvdD1mdW5jdGlvbihlLHQscixuKXt0aGlzLmFzc2VydE5vdENvbXBsZXgoZSxcIm9uZUhvdFwiKTt2YXIgbz1uZXcgRmxvYXQzMkFycmF5KGUuc2l6ZSp0KTtvLmZpbGwobik7Zm9yKHZhciBhPTA7YTxlLnNpemU7KythKWUuZ2V0KGEpPj0wJiZlLmdldChhKTx0JiYob1thKnQrZS5nZXQoYSldPXIpO3JldHVybiB0ZW5zb3IyZChvLFtlLnNpemUsdF0sXCJpbnQzMlwiKX0sZS5wcm90b3R5cGUubm9uTWF4U3VwcHJlc3Npb249ZnVuY3Rpb24oZSx0LHIsbixvKXtyZXR1cm4gdGhpcy5hc3NlcnROb3RDb21wbGV4KGUsXCJub25NYXhTdXBwcmVzc2lvblwiKSxub25NYXhTdXBwcmVzc2lvbkltcGwoZS5kYXRhU3luYygpLHQuZGF0YVN5bmMoKSxyLG4sbyl9LGUucHJvdG90eXBlLmZmdD1mdW5jdGlvbihlKXtpZigxIT09ZS5zaGFwZVswXSl0aHJvdyBuZXcgRXJyb3IoXCJ0Zi5mZnQoKSBvbiBDUFUgb25seSBzdXBwb3J0cyB2ZWN0b3JzLlwiKTtyZXR1cm4gdGhpcy5mZnRJbXBsKGUsITEpfSxlLnByb3RvdHlwZS5pZmZ0PWZ1bmN0aW9uKGUpe2lmKDEhPT1lLnNoYXBlWzBdKXRocm93IG5ldyBFcnJvcihcInRmLmlmZnQoKSBvbiBDUFUgb25seSBzdXBwb3J0cyB2ZWN0b3JzLlwiKTtyZXR1cm4gdGhpcy5mZnRJbXBsKGUsITApfSxlLnByb3RvdHlwZS5mZnRJbXBsPWZ1bmN0aW9uKGUsdCl7dmFyIHI9ZS5hczFEKCksbj1yLnNpemU7aWYodGhpcy5pc0V4cG9uZW50T2YyKG4pKXt2YXIgbz10aGlzLmZmdFJhZGl4MihyLG4sdCkuYXMyRChlLnNoYXBlWzBdLGUuc2hhcGVbMV0pO3JldHVybiB0JiYobz1jb21wbGV4KHJlYWwobykuZGl2KHNjYWxhcihuKSksaW1hZyhvKS5kaXYoc2NhbGFyKG4pKSkpLG99dmFyIGE9ZS5kYXRhU3luYygpLGk9c3BsaXRSZWFsQW5kSW1hZ0FycmF5cyh0aGlzLmZvdXJpZXJUcmFuc2Zvcm1CeU1hdG11bChhLG4sdCkpO3JldHVybiBjb21wbGV4KGkucmVhbCxpLmltYWcpLmFzMkQoZS5zaGFwZVswXSxlLnNoYXBlWzFdKX0sZS5wcm90b3R5cGUuaXNFeHBvbmVudE9mMj1mdW5jdGlvbihlKXtyZXR1cm4gMD09KGUmZS0xKX0sZS5wcm90b3R5cGUuZmZ0UmFkaXgyPWZ1bmN0aW9uKGUsdCxyKXtpZigxPT09dClyZXR1cm4gZTt2YXIgbj1lLmRhdGFTeW5jKCksbz10LzIsYT1jb21wbGV4V2l0aEV2ZW5JbmRleChuKSxpPWNvbXBsZXgoYS5yZWFsLGEuaW1hZykuYXMxRCgpLHM9Y29tcGxleFdpdGhPZGRJbmRleChuKSx1PWNvbXBsZXgocy5yZWFsLHMuaW1hZykuYXMxRCgpO2k9dGhpcy5mZnRSYWRpeDIoaSxvLHIpLHU9dGhpcy5mZnRSYWRpeDIodSxvLHIpO3ZhciBsPWV4cG9uZW50cyh0LHIpLGM9Y29tcGxleChsLnJlYWwsbC5pbWFnKS5tdWwodSkscD1pLmFkZChjKSxkPWkuc3ViKGMpLGg9cmVhbChwKS5jb25jYXQocmVhbChkKSksZj1pbWFnKHApLmNvbmNhdChpbWFnKGQpKTtyZXR1cm4gY29tcGxleChoLGYpLmFzMUQoKX0sZS5wcm90b3R5cGUuZm91cmllclRyYW5zZm9ybUJ5TWF0bXVsPWZ1bmN0aW9uKGUsdCxyKXtmb3IodmFyIG49bmV3IEZsb2F0MzJBcnJheSgyKnQpLG89MDtvPHQ7bysrKXtmb3IodmFyIGE9MCxpPTAscz0wO3M8dDtzKyspe3ZhciB1PWV4cG9uZW50KG8qcyx0LHIpLGw9Z2V0Q29tcGxleFdpdGhJbmRleChlLHMpO2ErPWwucmVhbCp1LnJlYWwtbC5pbWFnKnUuaW1hZyxpKz1sLnJlYWwqdS5pbWFnK2wuaW1hZyp1LnJlYWx9ciYmKGEvPXQsaS89dCksYXNzaWduVG9UeXBlZEFycmF5KG4sYSxpLG8pfXJldHVybiBufSxlLnByb3RvdHlwZS5kZXB0aFRvU3BhY2U9ZnVuY3Rpb24oZSx0LHIpe2Fzc2VydChcIk5IV0NcIj09PXIsXCJPbmx5IE5IV0MgZGF0YUZvcm1hdCBzdXBwb3J0ZWQgb24gQ1BVIGZvciBkZXB0aFRvU3BhY2UuIEdvdCBcIityKSxhc3NlcnQodD4xLFwiYmxvY2tTaXplIHNob3VsZCBiZSA+IDEgZm9yIGRlcHRoVG9TcGFjZSwgYnV0IHdhczogXCIrdCk7Zm9yKHZhciBuPWUuc2hhcGVbMF0sbz1lLnNoYXBlWzFdLGE9ZS5zaGFwZVsyXSxpPWUuc2hhcGVbM10scz1vKnQsdT1hKnQsbD1pLyh0KnQpLGM9ZS5kYXRhU3luYygpLHA9bmV3IEZsb2F0MzJBcnJheShuKnMqdSpsKSxkPTAsaD0wO2g8bjsrK2gpZm9yKHZhciBmPTA7ZjxzOysrZilmb3IodmFyIG09TWF0aC5mbG9vcihmL3QpLGc9ZiV0LHY9MDt2PHU7Kyt2KWZvcih2YXIgeT1NYXRoLmZsb29yKHYvdCkseD0oZyp0K3YldCkqbCxUPTA7VDxsOysrVCl7dmFyIEU9VCt4K2kqKHkrYSoobStvKmgpKTtwW2QrK109Y1tFXX1yZXR1cm4gdGVuc29yNGQocCxbbixzLHUsbF0pfSxlLnByb3RvdHlwZS5icm9hZGNhc3RlZEJpbmFyeU9wPWZ1bmN0aW9uKGUsdCxyLG4pe3ZhciBvPWFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKGUuc2hhcGUsdC5zaGFwZSksYT1idWZmZXIobyxyKSxpPWUuZGF0YVN5bmMoKSxzPXQuZGF0YVN5bmMoKSx1PWdldEJyb2FkY2FzdERpbXMoZS5zaGFwZSxvKSxsPWdldEJyb2FkY2FzdERpbXModC5zaGFwZSxvKSxjPWEudmFsdWVzO2lmKHUubGVuZ3RoK2wubGVuZ3RoPT09MClmb3IodmFyIHA9MDtwPGMubGVuZ3RoOysrcCljW3BdPW4oaVtwJWkubGVuZ3RoXSxzW3Alcy5sZW5ndGhdKTtlbHNle3ZhciBkPWUuYnVmZmVyKCksaD10LmJ1ZmZlcigpLGY9ZnVuY3Rpb24ocil7dmFyIG89YS5pbmRleFRvTG9jKHIpLHA9by5zbGljZSgtZS5yYW5rKTt1LmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIHBbZV09MH0pO3ZhciBmPWQubG9jVG9JbmRleChwKSxtPW8uc2xpY2UoLXQucmFuayk7bC5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiBtW2VdPTB9KTt2YXIgZz1oLmxvY1RvSW5kZXgobSk7Y1tyXT1uKGlbZl0sc1tnXSl9O2ZvcihwPTA7cDxjLmxlbmd0aDsrK3ApZihwKX1yZXR1cm4gYS50b1RlbnNvcigpfSxlLnByb3RvdHlwZS5icm9hZGNhc3RlZEJpbmFyeUNvbXBsZXhPcD1mdW5jdGlvbihlLHQscil7dmFyIG49YXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoZS5zaGFwZSx0LnNoYXBlKSxvPWJ1ZmZlcihuLFwiZmxvYXQzMlwiKSxhPWJ1ZmZlcihuLFwiZmxvYXQzMlwiKSxpPWUuZGF0YVN5bmMoKSxzPXQuZGF0YVN5bmMoKSx1PWdldEJyb2FkY2FzdERpbXMoZS5zaGFwZSxuKSxsPWdldEJyb2FkY2FzdERpbXModC5zaGFwZSxuKSxjPW8udmFsdWVzLHA9YS52YWx1ZXM7aWYodS5sZW5ndGgrbC5sZW5ndGg9PT0wKWZvcih2YXIgZD0wO2Q8Yy5sZW5ndGg7ZCsrKXt2YXIgaD1kJWkubGVuZ3RoLGY9ZCVzLmxlbmd0aCxtPXIoaVsyKmhdLGlbMipoKzFdLHNbMipmXSxzWzIqZisxXSk7Y1tkXT1tLnJlYWwscFtkXT1tLmltYWd9ZWxzZXt2YXIgZz10aGlzLmRhdGEuZ2V0KGUuZGF0YUlkKS5jb21wbGV4VGVuc29ycy5yZWFsLmJ1ZmZlcigpLHY9dGhpcy5kYXRhLmdldCh0LmRhdGFJZCkuY29tcGxleFRlbnNvcnMucmVhbC5idWZmZXIoKSx5PWZ1bmN0aW9uKG4pe3ZhciBhPW8uaW5kZXhUb0xvYyhuKSxkPWEuc2xpY2UoLWUucmFuayk7dS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiBkW2VdPTB9KTt2YXIgaD1nLmxvY1RvSW5kZXgoZCksZj1hLnNsaWNlKC10LnJhbmspO2wuZm9yRWFjaChmdW5jdGlvbihlKXtyZXR1cm4gZltlXT0wfSk7dmFyIG09di5sb2NUb0luZGV4KGYpLHk9cihpWzIqaF0saVsyKmgrMV0sc1syKm1dLHNbMiptKzFdKTtjW25dPXkucmVhbCxwW25dPXkuaW1hZ307Zm9yKGQ9MDtkPGMubGVuZ3RoO2QrKyl5KGQpfXJldHVybiB0aGlzLmNvbXBsZXgoby50b1RlbnNvcigpLGEudG9UZW5zb3IoKSl9LGUucHJvdG90eXBlLnNwbGl0PWZ1bmN0aW9uKGUsdCxyKXtyZXR1cm4gc3BsaXQoZSx0LHIpfSxlLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7fSxlLnByb3RvdHlwZS5mbG9hdFByZWNpc2lvbj1mdW5jdGlvbigpe3JldHVybiAzMn0sZS5wcm90b3R5cGUuY3JvcEFuZFJlc2l6ZT1mdW5jdGlvbihlLHQscixuLG8sYSl7Zm9yKHZhciBpPWUuc2hhcGUscz1pWzBdLHU9aVsxXSxsPWlbMl0sYz1pWzNdLHA9dC5zaGFwZVswXSxkPW5bMF0saD1uWzFdLGY9YnVmZmVyKFtwLGQsaCxjXSksbT10LmRhdGFTeW5jKCksZz1yLmRhdGFTeW5jKCksdj1lLmRhdGFTeW5jKCkseT1lLnN0cmlkZXMseD1mLnN0cmlkZXMsVD0wO1Q8cDtUKyspe3ZhciBFPTQqVCx3PW1bRV0sUz1tW0UrMV0sYj1tW0UrMl0sQz1tW0UrM10sXz1nW1RdO2lmKCEoXz49cykpZm9yKHZhciBBPWQ+MT8oYi13KSoodS0xKS8oZC0xKTowLE49aD4xPyhDLVMpKihsLTEpLyhoLTEpOjAsUj0wO1I8ZDtSKyspe3ZhciBJPWQ+MT93Kih1LTEpK1IqQTouNSoodytiKSoodS0xKTtpZihJPDB8fEk+dS0xKWZvcih2YXIgaz0wO2s8aDtrKyspZm9yKHZhciBEPTA7RDxjO0QrKyl7dmFyIE09RCtrKnhbMl0rUip4WzFdK1QqeFswXTtmLnZhbHVlc1tNXT1hfWVsc2UgaWYoXCJiaWxpbmVhclwiPT09byl7dmFyIE89TWF0aC5mbG9vcihJKSxQPU1hdGguY2VpbChJKSxGPUktTztmb3Ioaz0wO2s8aDtrKyspe2lmKChxPWg+MT9TKihsLTEpK2sqTjouNSooUytDKSoobC0xKSk8MHx8cT5sLTEpZm9yKEQ9MDtEPGM7RCsrKXtNPUQrayp4WzJdK1IqeFsxXStUKnhbMF07Zi52YWx1ZXNbTV09YX1lbHNle3ZhciBMPU1hdGguZmxvb3IocSksQj1NYXRoLmNlaWwocSksVT1xLUw7Zm9yKEQ9MDtEPGM7RCsrKXt2YXIgej12W009RCtMKnlbMl0rTyp5WzFdK18qeVswXV0sVj12W009RCtCKnlbMl0rTyp5WzFdK18qeVswXV0sSD12W009RCtMKnlbMl0rUCp5WzFdK18qeVswXV0sRz16KyhWLXopKlUsVz1IKyh2W009RCtCKnlbMl0rUCp5WzFdK18qeVswXV0tSCkqVTtNPUQrayp4WzJdK1IqeFsxXStUKnhbMF0sZi52YWx1ZXNbTV09RysoVy1HKSpGfX19fWVsc2UgZm9yKGs9MDtrPGg7KytrKXt2YXIgcTtpZigocT1oPjE/UyoobC0xKStrKk46LjUqKFMrQykqKGwtMSkpPDB8fHE+bC0xKWZvcihEPTA7RDxjO0QrKyl7TT1EK2sqeFsyXStSKnhbMV0rVCp4WzBdO2YudmFsdWVzW01dPWF9ZWxzZXt2YXIgJD1NYXRoLnJvdW5kKHEpLFg9TWF0aC5yb3VuZChJKTtmb3IoRD0wO0Q8YztEKyspe3ZhciBLPUQrJCp5WzJdK1gqeVsxXStfKnlbMF0saj1EK2sqeFsyXStSKnhbMV0rVCp4WzBdO2YudmFsdWVzW2pdPXZbS119fX19fXJldHVybiBmLnRvVGVuc29yKCl9LGUucHJvdG90eXBlLnNwYXJzZVRvRGVuc2U9ZnVuY3Rpb24oZSx0LHIsbil7dmFyIG89Y2FsY3VsYXRlU2hhcGVzKHQsZSxyKSxhPW8uc2xpY2VSYW5rLGk9by5udW1VcGRhdGVzLHM9by5zbGljZVNpemUsdT1vLnN0cmlkZXMsbD1vLm91dHB1dFNpemU7cmV0dXJuIHRoaXMuc2NhdHRlcihlLHQscixsLHMsaSxhLHUsbiwhMSl9LGUucHJvdG90eXBlLmdhdGhlck5EPWZ1bmN0aW9uKGUsdCl7dmFyIHI9dC5zaGFwZSxuPXJbci5sZW5ndGgtMV0sbz1wcmVwYXJlQW5kVmFsaWRhdGUoZSx0KSxhPW9bMF0saT1vWzFdLHM9b1syXSx1PW9bM107aWYoMD09PWkpcmV0dXJuIHRlbnNvcihbXSxhLGUuZHR5cGUpO2Zvcih2YXIgbD1uZXcgVGVuc29yQnVmZmVyKFtpLHNdLGUuZHR5cGUpLGM9dC5kYXRhU3luYygpLHA9ZS5kYXRhU3luYygpLGQ9MDtkPGk7ZCsrKXtmb3IodmFyIGg9W10sZj0wLG09MDttPG47bSsrKXt2YXIgZz1jW2QqbittXTtmKz1nKnVbbV0saC5wdXNoKGcpfWlmKGY8MHx8Zj49ZS5zaXplL3MpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbmRpY2VzOiBcIitoK1wiIGRvZXMgbm90IGluZGV4IGludG8gXCIrZS5zaGFwZSk7Zm9yKHZhciB2PTA7djxzO3YrKylsLnZhbHVlc1tkKnMrdl09cFtmKnMrdl19cmV0dXJuIGwudG9UZW5zb3IoKS5yZXNoYXBlKGEpfSxlLnByb3RvdHlwZS5zY2F0dGVyTkQ9ZnVuY3Rpb24oZSx0LHIpe3ZhciBuPWNhbGN1bGF0ZVNoYXBlcyh0LGUsciksbz1uLnNsaWNlUmFuayxhPW4ubnVtVXBkYXRlcyxpPW4uc2xpY2VTaXplLHM9bi5zdHJpZGVzLHU9bi5vdXRwdXRTaXplLGw9c2NhbGFyKDApO3JldHVybiB0aGlzLnNjYXR0ZXIoZSx0LHIsdSxpLGEsbyxzLGwsITApfSxlLnByb3RvdHlwZS5zY2F0dGVyPWZ1bmN0aW9uKGUsdCxyLG4sbyxhLGkscyx1LGwpe3ZhciBjPVtuL28sb10scD1lLmRhdGFTeW5jKCksZD10LmRhdGFTeW5jKCk7aWYoMD09PW4pcmV0dXJuIHRlbnNvcihbXSxyLHQuZHR5cGUpO3ZhciBoPW5ldyBUZW5zb3JCdWZmZXIoYyx0LmR0eXBlKTtoLnZhbHVlcy5maWxsKHUuZGF0YVN5bmMoKVswXSk7Zm9yKHZhciBmPTA7ZjxhO2YrKyl7Zm9yKHZhciBtPVtdLGc9MCx2PTA7djxpO3YrKyl7dmFyIHk9cFtmKmkrdl07bS5wdXNoKHkpLGcrPXkqc1t2XX1pZihnPDB8fGc+PW4vbyl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGluZGljZXM6IFwiK20rXCIgZG9lcyBub3QgaW5kZXggaW50byBcIityKTtmb3IodmFyIHg9MDt4PG87eCsrKWw/aC52YWx1ZXNbZypvK3hdKz1kW2Yqbyt4XTpoLnZhbHVlc1tnKm8reF09MD09PXQucmFuaz9kWzBdOmRbZipvK3hdfXJldHVybiBoLnRvVGVuc29yKCkucmVzaGFwZShyKX0sZX0oKTtFTlYucmVnaXN0ZXJCYWNrZW5kKFwiY3B1XCIsZnVuY3Rpb24oKXtyZXR1cm4gbmV3IE1hdGhCYWNrZW5kQ1BVfSwxLHNldFRlbnNvclRyYWNrZXIpO3ZhciBkZWxheUNhbGxiYWNrPVwidW5kZWZpbmVkXCIhPXR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWU/cmVxdWVzdEFuaW1hdGlvbkZyYW1lOnNldEltbWVkaWF0ZTtmdW5jdGlvbiBuZXh0RnJhbWUoKXtyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24oZSl7cmV0dXJuIGRlbGF5Q2FsbGJhY2soZnVuY3Rpb24oKXtyZXR1cm4gZSgpfSl9KX12YXIgRFRZUEVfVkFMVUVfU0laRV9NQVA9e2Zsb2F0MzI6NCxpbnQzMjo0LHVpbnQxNjoyLHVpbnQ4OjEsYm9vbDoxfTtmdW5jdGlvbiBlbmNvZGVXZWlnaHRzKGUpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQscixuLG87cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oYSl7c3dpdGNoKGEubGFiZWwpe2Nhc2UgMDpmb3IobiBpbiB0PVtdLHI9W10sZSl7aWYoXCJmbG9hdDMyXCIhPT0obz1lW25dKS5kdHlwZSYmXCJpbnQzMlwiIT09by5kdHlwZSYmXCJib29sXCIhPT1vLmR0eXBlKXRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGR0eXBlIGluIHdlaWdodCAnXCIrbitcIic6IFwiK28uZHR5cGUpO3QucHVzaCh7bmFtZTpuLHNoYXBlOm8uc2hhcGUsZHR5cGU6by5kdHlwZX0pLHIucHVzaChvLmRhdGEoKSl9cmV0dXJuWzQsUHJvbWlzZS5hbGwocildO2Nhc2UgMTpyZXR1cm5bMix7ZGF0YTpjb25jYXRlbmF0ZVR5cGVkQXJyYXlzKGEuc2VudCgpKSxzcGVjczp0fV19fSl9KX1mdW5jdGlvbiBkZWNvZGVXZWlnaHRzKGUsdCl7Zm9yKHZhciByPXt9LG49MCxvPWZ1bmN0aW9uKHQpe3ZhciBvPXQubmFtZSxhPXQuZHR5cGUsaT10LnNoYXBlLHM9c2l6ZUZyb21TaGFwZShpKSx1PXZvaWQgMDtpZihcInF1YW50aXphdGlvblwiaW4gdCl7dmFyIGw9dC5xdWFudGl6YXRpb247aWYoXCJ1aW50OFwiIT09bC5kdHlwZSYmXCJ1aW50MTZcIiE9PWwuZHR5cGUpdGhyb3cgbmV3IEVycm9yKFwiV2VpZ2h0IFwiK3QubmFtZStcIiBoYXMgdW5rbm93biBxdWFudGl6YXRpb24gZHR5cGUgXCIrbC5kdHlwZStcIi4gU3VwcG9ydGVkIHF1YW50aXphdGlvbiBkdHlwZXMgYXJlOiAndWludDgnIGFuZCAndWludDE2Jy5cIik7dmFyIGM9RFRZUEVfVkFMVUVfU0laRV9NQVBbbC5kdHlwZV0scD1lLnNsaWNlKG4sbitzKmMpLGQ9XCJ1aW50OFwiPT09bC5kdHlwZT9uZXcgVWludDhBcnJheShwKTpuZXcgVWludDE2QXJyYXkocCk7aWYoXCJmbG9hdDMyXCI9PT1hKXU9RmxvYXQzMkFycmF5LmZyb20oZCxmdW5jdGlvbihlKXtyZXR1cm4gZSpsLnNjYWxlK2wubWlufSk7ZWxzZXtpZihcImludDMyXCIhPT1hKXRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGR0eXBlIGluIHdlaWdodCAnXCIrbytcIic6IFwiK2EpO3U9SW50MzJBcnJheS5mcm9tKGQsZnVuY3Rpb24oZSl7cmV0dXJuIE1hdGgucm91bmQoZSpsLnNjYWxlK2wubWluKX0pfW4rPXMqY31lbHNle3ZhciBoPURUWVBFX1ZBTFVFX1NJWkVfTUFQW2FdO3A9ZS5zbGljZShuLG4rcypoKTtpZihcImZsb2F0MzJcIj09PWEpdT1uZXcgRmxvYXQzMkFycmF5KHApO2Vsc2UgaWYoXCJpbnQzMlwiPT09YSl1PW5ldyBJbnQzMkFycmF5KHApO2Vsc2V7aWYoXCJib29sXCIhPT1hKXRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGR0eXBlIGluIHdlaWdodCAnXCIrbytcIic6IFwiK2EpO3U9bmV3IFVpbnQ4QXJyYXkocCl9bis9cypofXZhciBmPXZvaWQgMDtpZihcImZsb2F0MzJcIj09PWEpZj10ZW5zb3IodSxpLFwiZmxvYXQzMlwiKTtlbHNlIGlmKFwiaW50MzJcIj09PWEpZj10ZW5zb3IodSxpLFwiaW50MzJcIik7ZWxzZXtpZihcImJvb2xcIiE9PWEpdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgZHR5cGUgaW4gd2VpZ2h0ICdcIitvK1wiJzogXCIrYSk7Zj10ZW5zb3IodSxpLFwiYm9vbFwiKX1yW29dPWZ9LGE9MCxpPXQ7YTxpLmxlbmd0aDthKyspe28oaVthXSl9cmV0dXJuIHJ9ZnVuY3Rpb24gY29uY2F0ZW5hdGVUeXBlZEFycmF5cyhlKXtpZihudWxsPT09ZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHZhbHVlOiBcIitKU09OLnN0cmluZ2lmeShlKSk7dmFyIHQ9MCxyPVtdO2UuZm9yRWFjaChmdW5jdGlvbihlKXtpZih0Kz1lLmJ5dGVMZW5ndGgsci5wdXNoKGUuYnl0ZUxlbmd0aD09PWUuYnVmZmVyLmJ5dGVMZW5ndGg/ZTpuZXcgZS5jb25zdHJ1Y3RvcihlKSksIShlIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5fHxlIGluc3RhbmNlb2YgSW50MzJBcnJheXx8ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKXRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIFR5cGVkQXJyYXkgc3VidHlwZTogXCIrZS5jb25zdHJ1Y3Rvci5uYW1lKX0pO3ZhciBuPW5ldyBVaW50OEFycmF5KHQpLG89MDtyZXR1cm4gci5mb3JFYWNoKGZ1bmN0aW9uKGUpe24uc2V0KG5ldyBVaW50OEFycmF5KGUuYnVmZmVyKSxvKSxvKz1lLmJ5dGVMZW5ndGh9KSxuLmJ1ZmZlcn12YXIgdXNlTm9kZUJ1ZmZlcj1cInVuZGVmaW5lZFwiIT10eXBlb2YgQnVmZmVyJiYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIEJsb2J8fFwidW5kZWZpbmVkXCI9PXR5cGVvZiBhdG9ifHxcInVuZGVmaW5lZFwiPT10eXBlb2YgYnRvYSk7ZnVuY3Rpb24gc3RyaW5nQnl0ZUxlbmd0aChlKXtyZXR1cm4gdXNlTm9kZUJ1ZmZlcj9CdWZmZXIuYnl0ZUxlbmd0aChlKTpuZXcgQmxvYihbZV0pLnNpemV9ZnVuY3Rpb24gYXJyYXlCdWZmZXJUb0Jhc2U2NFN0cmluZyhlKXtyZXR1cm4gdXNlTm9kZUJ1ZmZlcj9CdWZmZXIuZnJvbShlKS50b1N0cmluZyhcImJhc2U2NFwiKTpidG9hKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCxuZXcgVWludDhBcnJheShlKSkpfWZ1bmN0aW9uIGJhc2U2NFN0cmluZ1RvQXJyYXlCdWZmZXIoZSl7aWYodXNlTm9kZUJ1ZmZlcil7dmFyIHQ9QnVmZmVyLmZyb20oZSxcImJhc2U2NFwiKTtyZXR1cm4gdC5idWZmZXIuc2xpY2UodC5ieXRlT2Zmc2V0LHQuYnl0ZU9mZnNldCt0LmJ5dGVMZW5ndGgpfWZvcih2YXIgcj1hdG9iKGUpLG49bmV3IFVpbnQ4QXJyYXkoci5sZW5ndGgpLG89MDtvPHIubGVuZ3RoOysrbyluLnNldChbci5jaGFyQ29kZUF0KG8pXSxvKTtyZXR1cm4gbi5idWZmZXJ9ZnVuY3Rpb24gY29uY2F0ZW5hdGVBcnJheUJ1ZmZlcnMoZSl7dmFyIHQ9MDtlLmZvckVhY2goZnVuY3Rpb24oZSl7dCs9ZS5ieXRlTGVuZ3RofSk7dmFyIHI9bmV3IFVpbnQ4QXJyYXkodCksbj0wO3JldHVybiBlLmZvckVhY2goZnVuY3Rpb24oZSl7ci5zZXQobmV3IFVpbnQ4QXJyYXkoZSksbiksbis9ZS5ieXRlTGVuZ3RofSksci5idWZmZXJ9ZnVuY3Rpb24gYmFzZW5hbWUoZSl7Zm9yKGU9ZS50cmltKCk7ZS5lbmRzV2l0aChcIi9cIik7KWU9ZS5zbGljZSgwLGUubGVuZ3RoLTEpO3ZhciB0PWUuc3BsaXQoXCIvXCIpO3JldHVybiB0W3QubGVuZ3RoLTFdfWZ1bmN0aW9uIGdldE1vZGVsQXJ0aWZhY3RzSW5mb0ZvckpTT04oZSl7aWYoZS5tb2RlbFRvcG9sb2d5IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgSlNPTiBtb2RlbCB0b3BvbG9neSwgcmVjZWl2ZWQgQXJyYXlCdWZmZXIuXCIpO3JldHVybntkYXRlU2F2ZWQ6bmV3IERhdGUsbW9kZWxUb3BvbG9neVR5cGU6XCJKU09OXCIsbW9kZWxUb3BvbG9neUJ5dGVzOm51bGw9PWUubW9kZWxUb3BvbG9neT8wOnN0cmluZ0J5dGVMZW5ndGgoSlNPTi5zdHJpbmdpZnkoZS5tb2RlbFRvcG9sb2d5KSksd2VpZ2h0U3BlY3NCeXRlczpudWxsPT1lLndlaWdodFNwZWNzPzA6c3RyaW5nQnl0ZUxlbmd0aChKU09OLnN0cmluZ2lmeShlLndlaWdodFNwZWNzKSksd2VpZ2h0RGF0YUJ5dGVzOm51bGw9PWUud2VpZ2h0RGF0YT8wOmUud2VpZ2h0RGF0YS5ieXRlTGVuZ3RofX12YXIgSU9Sb3V0ZXJSZWdpc3RyeT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXt0aGlzLnNhdmVSb3V0ZXJzPVtdLHRoaXMubG9hZFJvdXRlcnM9W119cmV0dXJuIGUuZ2V0SW5zdGFuY2U9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09ZS5pbnN0YW5jZSYmKGUuaW5zdGFuY2U9bmV3IGUpLGUuaW5zdGFuY2V9LGUucmVnaXN0ZXJTYXZlUm91dGVyPWZ1bmN0aW9uKHQpe2UuZ2V0SW5zdGFuY2UoKS5zYXZlUm91dGVycy5wdXNoKHQpfSxlLnJlZ2lzdGVyTG9hZFJvdXRlcj1mdW5jdGlvbih0KXtlLmdldEluc3RhbmNlKCkubG9hZFJvdXRlcnMucHVzaCh0KX0sZS5nZXRTYXZlSGFuZGxlcnM9ZnVuY3Rpb24odCl7cmV0dXJuIGUuZ2V0SGFuZGxlcnModCxcInNhdmVcIil9LGUuZ2V0TG9hZEhhbmRsZXJzPWZ1bmN0aW9uKHQpe3JldHVybiBlLmdldEhhbmRsZXJzKHQsXCJsb2FkXCIpfSxlLmdldEhhbmRsZXJzPWZ1bmN0aW9uKGUsdCl7dmFyIHI9W107cmV0dXJuKFwibG9hZFwiPT09dD90aGlzLmdldEluc3RhbmNlKCkubG9hZFJvdXRlcnM6dGhpcy5nZXRJbnN0YW5jZSgpLnNhdmVSb3V0ZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3ZhciBuPXQoZSk7bnVsbCE9PW4mJnIucHVzaChuKX0pLHJ9LGV9KCksVVJMX1NDSEVNRV9TVUZGSVg9XCI6Ly9cIixNb2RlbFN0b3JlTWFuYWdlclJlZ2lzdHJ5PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpe3RoaXMubWFuYWdlcnM9e319cmV0dXJuIGUuZ2V0SW5zdGFuY2U9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09ZS5pbnN0YW5jZSYmKGUuaW5zdGFuY2U9bmV3IGUpLGUuaW5zdGFuY2V9LGUucmVnaXN0ZXJNYW5hZ2VyPWZ1bmN0aW9uKHQscil7YXNzZXJ0KG51bGwhPXQsXCJzY2hlbWUgbXVzdCBub3QgYmUgdW5kZWZpbmVkIG9yIG51bGwuXCIpLHQuZW5kc1dpdGgoVVJMX1NDSEVNRV9TVUZGSVgpJiYodD10LnNsaWNlKDAsdC5pbmRleE9mKFVSTF9TQ0hFTUVfU1VGRklYKSkpLGFzc2VydCh0Lmxlbmd0aD4wLFwic2NoZW1lIG11c3Qgbm90IGJlIGFuIGVtcHR5IHN0cmluZy5cIik7dmFyIG49ZS5nZXRJbnN0YW5jZSgpO2Fzc2VydChudWxsPT1uLm1hbmFnZXJzW3RdLFwiQSBtb2RlbCBzdG9yZSBtYW5hZ2VyIGlzIGFscmVhZHkgcmVnaXN0ZXJlZCBmb3Igc2NoZW1lICdcIit0K1wiJy5cIiksbi5tYW5hZ2Vyc1t0XT1yfSxlLmdldE1hbmFnZXI9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5nZXRJbnN0YW5jZSgpLm1hbmFnZXJzW2VdO2lmKG51bGw9PXQpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kZWwgbWFuYWdlciBmb3Igc2NoZW1lICdcIitlK1wiJ1wiKTtyZXR1cm4gdH0sZS5nZXRTY2hlbWVzPWZ1bmN0aW9uKCl7cmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuZ2V0SW5zdGFuY2UoKS5tYW5hZ2Vycyl9LGV9KCk7ZnVuY3Rpb24gcGFyc2VVUkwoZSl7aWYoLTE9PT1lLmluZGV4T2YoVVJMX1NDSEVNRV9TVUZGSVgpKXRocm93IG5ldyBFcnJvcihcIlRoZSB1cmwgc3RyaW5nIHByb3ZpZGVkIGRvZXMgbm90IGNvbnRhaW4gYSBzY2hlbWUuIFN1cHBvcnRlZCBzY2hlbWVzIGFyZTogXCIrTW9kZWxTdG9yZU1hbmFnZXJSZWdpc3RyeS5nZXRTY2hlbWVzKCkuam9pbihcIixcIikpO3JldHVybntzY2hlbWU6ZS5zcGxpdChVUkxfU0NIRU1FX1NVRkZJWClbMF0scGF0aDplLnNwbGl0KFVSTF9TQ0hFTUVfU1VGRklYKVsxXX19ZnVuY3Rpb24gY2xvbmVNb2RlbEludGVybmFsKGUsdCxyKXtyZXR1cm4gdm9pZCAwPT09ciYmKHI9ITEpLF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgbixvLGEsaSxzLHUsbCxjLHA7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oZCl7c3dpdGNoKGQubGFiZWwpe2Nhc2UgMDpyZXR1cm4gYXNzZXJ0KGUhPT10LFwiT2xkIHBhdGggYW5kIG5ldyBwYXRoIGFyZSB0aGUgc2FtZTogJ1wiK2UrXCInXCIpLGFzc2VydCgobj1JT1JvdXRlclJlZ2lzdHJ5LmdldExvYWRIYW5kbGVycyhlKSkubGVuZ3RoPjAsXCJDb3B5aW5nIGZhaWxlZCBiZWNhdXNlIG5vIGxvYWQgaGFuZGxlciBpcyBmb3VuZCBmb3Igc291cmNlIFVSTCBcIitlK1wiLlwiKSxhc3NlcnQobi5sZW5ndGg8MixcIkNvcHlpbmcgZmFpbGVkIGJlY2F1c2UgbW9yZSB0aGFuIG9uZSAoXCIrbi5sZW5ndGgrXCIpIGxvYWQgaGFuZGxlcnMgZm9yIHNvdXJjZSBVUkwgXCIrZStcIi5cIiksbz1uWzBdLGFzc2VydCgoYT1JT1JvdXRlclJlZ2lzdHJ5LmdldFNhdmVIYW5kbGVycyh0KSkubGVuZ3RoPjAsXCJDb3B5aW5nIGZhaWxlZCBiZWNhdXNlIG5vIHNhdmUgaGFuZGxlciBpcyBmb3VuZCBmb3IgZGVzdGluYXRpb24gVVJMIFwiK3QrXCIuXCIpLGFzc2VydChhLmxlbmd0aDwyLFwiQ29weWluZyBmYWlsZWQgYmVjYXVzZSBtb3JlIHRoYW4gb25lIChcIituLmxlbmd0aCtcIikgc2F2ZSBoYW5kbGVycyBmb3IgZGVzdGluYXRpb24gVVJMIFwiK3QrXCIuXCIpLGk9YVswXSxzPXBhcnNlVVJMKGUpLnNjaGVtZSx1PXBhcnNlVVJMKGUpLnBhdGgsbD1zPT09cGFyc2VVUkwoZSkuc2NoZW1lLFs0LG8ubG9hZCgpXTtjYXNlIDE6cmV0dXJuIGM9ZC5zZW50KCksciYmbD9bNCxNb2RlbFN0b3JlTWFuYWdlclJlZ2lzdHJ5LmdldE1hbmFnZXIocykucmVtb3ZlTW9kZWwodSldOlszLDNdO2Nhc2UgMjpkLnNlbnQoKSxkLmxhYmVsPTM7Y2FzZSAzOnJldHVybls0LGkuc2F2ZShjKV07Y2FzZSA0OnJldHVybiBwPWQuc2VudCgpLCFyfHxsP1szLDZdOls0LE1vZGVsU3RvcmVNYW5hZ2VyUmVnaXN0cnkuZ2V0TWFuYWdlcihzKS5yZW1vdmVNb2RlbCh1KV07Y2FzZSA1OmQuc2VudCgpLGQubGFiZWw9NjtjYXNlIDY6cmV0dXJuWzIscC5tb2RlbEFydGlmYWN0c0luZm9dfX0pfSl9ZnVuY3Rpb24gbGlzdE1vZGVscygpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIGUsdCxyLG4sbyxhLGk7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24ocyl7c3dpdGNoKHMubGFiZWwpe2Nhc2UgMDplPU1vZGVsU3RvcmVNYW5hZ2VyUmVnaXN0cnkuZ2V0U2NoZW1lcygpLHQ9e30scj0wLG49ZSxzLmxhYmVsPTE7Y2FzZSAxOnJldHVybiByPG4ubGVuZ3RoPyhvPW5bcl0sWzQsTW9kZWxTdG9yZU1hbmFnZXJSZWdpc3RyeS5nZXRNYW5hZ2VyKG8pLmxpc3RNb2RlbHMoKV0pOlszLDRdO2Nhc2UgMjpmb3IoaSBpbiBhPXMuc2VudCgpKXRbbytVUkxfU0NIRU1FX1NVRkZJWCtpXT1hW2ldO3MubGFiZWw9MztjYXNlIDM6cmV0dXJuIHIrKyxbMywxXTtjYXNlIDQ6cmV0dXJuWzIsdF19fSl9KX1mdW5jdGlvbiByZW1vdmVNb2RlbChlKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciB0O3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6cmV0dXJuIHQ9cGFyc2VVUkwoZSksWzQsTW9kZWxTdG9yZU1hbmFnZXJSZWdpc3RyeS5nZXRNYW5hZ2VyKHQuc2NoZW1lKS5yZW1vdmVNb2RlbCh0LnBhdGgpXTtjYXNlIDE6cmV0dXJuWzIsci5zZW50KCldfX0pfSl9ZnVuY3Rpb24gY29weU1vZGVsKGUsdCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOnJldHVybls0LGNsb25lTW9kZWxJbnRlcm5hbChlLHQsITEpXTtjYXNlIDE6cmV0dXJuWzIsci5zZW50KCldfX0pfSl9ZnVuY3Rpb24gbW92ZU1vZGVsKGUsdCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOnJldHVybls0LGNsb25lTW9kZWxJbnRlcm5hbChlLHQsITApXTtjYXNlIDE6cmV0dXJuWzIsci5zZW50KCldfX0pfSl9dmFyIERBVEFCQVNFX05BTUU9XCJ0ZW5zb3JmbG93anNcIixEQVRBQkFTRV9WRVJTSU9OPTEsTU9ERUxfU1RPUkVfTkFNRT1cIm1vZGVsc19zdG9yZVwiLElORk9fU1RPUkVfTkFNRT1cIm1vZGVsX2luZm9fc3RvcmVcIjtmdW5jdGlvbiBnZXRJbmRleGVkREJGYWN0b3J5KCl7aWYoIUVOVi5nZXQoXCJJU19CUk9XU0VSXCIpKXRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBvYnRhaW4gSW5kZXhlZERCIGZhY3RvcnkgYmVjYXVzZSB0aGUgY3VycmVudCBlbnZpcm9ubWVudGlzIG5vdCBhIHdlYiBicm93c2VyLlwiKTt2YXIgZT13aW5kb3csdD1lLmluZGV4ZWREQnx8ZS5tb3pJbmRleGVkREJ8fGUud2Via2l0SW5kZXhlZERCfHxlLm1zSW5kZXhlZERCfHxlLnNoaW1JbmRleGVkREI7aWYobnVsbD09dCl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgY3VycmVudCBicm93c2VyIGRvZXMgbm90IGFwcGVhciB0byBzdXBwb3J0IEluZGV4ZWREQi5cIik7cmV0dXJuIHR9ZnVuY3Rpb24gc2V0VXBEYXRhYmFzZShlKXt2YXIgdD1lLnJlc3VsdDt0LmNyZWF0ZU9iamVjdFN0b3JlKE1PREVMX1NUT1JFX05BTUUse2tleVBhdGg6XCJtb2RlbFBhdGhcIn0pLHQuY3JlYXRlT2JqZWN0U3RvcmUoSU5GT19TVE9SRV9OQU1FLHtrZXlQYXRoOlwibW9kZWxQYXRoXCJ9KX12YXIgQnJvd3NlckluZGV4ZWREQj1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSl7aWYodGhpcy5pbmRleGVkREI9Z2V0SW5kZXhlZERCRmFjdG9yeSgpLG51bGw9PWV8fCFlKXRocm93IG5ldyBFcnJvcihcIkZvciBJbmRleGVkREIsIG1vZGVsUGF0aCBtdXN0IG5vdCBiZSBudWxsLCB1bmRlZmluZWQgb3IgZW1wdHkuXCIpO3RoaXMubW9kZWxQYXRoPWV9cmV0dXJuIGUucHJvdG90eXBlLnNhdmU9ZnVuY3Rpb24oZSl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbih0KXtpZihlLm1vZGVsVG9wb2xvZ3kgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcil0aHJvdyBuZXcgRXJyb3IoXCJCcm93c2VyTG9jYWxTdG9yYWdlLnNhdmUoKSBkb2VzIG5vdCBzdXBwb3J0IHNhdmluZyBtb2RlbCB0b3BvbG9neSBpbiBiaW5hcnkgZm9ybWF0cyB5ZXQuXCIpO3JldHVyblsyLHRoaXMuZGF0YWJhc2VBY3Rpb24odGhpcy5tb2RlbFBhdGgsZSldfSl9KX0sZS5wcm90b3R5cGUubG9hZD1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oZSl7cmV0dXJuWzIsdGhpcy5kYXRhYmFzZUFjdGlvbih0aGlzLm1vZGVsUGF0aCldfSl9KX0sZS5wcm90b3R5cGUuZGF0YWJhc2VBY3Rpb249ZnVuY3Rpb24oZSx0KXt2YXIgcj10aGlzO3JldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihlLG4pe3ZhciBvPXIuaW5kZXhlZERCLm9wZW4oREFUQUJBU0VfTkFNRSxEQVRBQkFTRV9WRVJTSU9OKTtvLm9udXBncmFkZW5lZWRlZD1mdW5jdGlvbigpe3JldHVybiBzZXRVcERhdGFiYXNlKG8pfSxvLm9uc3VjY2Vzcz1mdW5jdGlvbigpe3ZhciBhPW8ucmVzdWx0O2lmKG51bGw9PXQpe3ZhciBpPWEudHJhbnNhY3Rpb24oTU9ERUxfU1RPUkVfTkFNRSxcInJlYWRvbmx5XCIpLHM9aS5vYmplY3RTdG9yZShNT0RFTF9TVE9SRV9OQU1FKS5nZXQoci5tb2RlbFBhdGgpO3Mub25zdWNjZXNzPWZ1bmN0aW9uKCl7aWYobnVsbD09cy5yZXN1bHQpcmV0dXJuIGEuY2xvc2UoKSxuKG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZGVsIHdpdGggcGF0aCAnXCIrci5tb2RlbFBhdGgrXCInIGluIEluZGV4ZWREQi5cIikpO2Uocy5yZXN1bHQubW9kZWxBcnRpZmFjdHMpfSxzLm9uZXJyb3I9ZnVuY3Rpb24oZSl7cmV0dXJuIGEuY2xvc2UoKSxuKHMuZXJyb3IpfSxpLm9uY29tcGxldGU9ZnVuY3Rpb24oKXtyZXR1cm4gYS5jbG9zZSgpfX1lbHNle3ZhciB1LGw9Z2V0TW9kZWxBcnRpZmFjdHNJbmZvRm9ySlNPTih0KSxjPWEudHJhbnNhY3Rpb24oSU5GT19TVE9SRV9OQU1FLFwicmVhZHdyaXRlXCIpLHA9Yy5vYmplY3RTdG9yZShJTkZPX1NUT1JFX05BTUUpLGQ9cC5wdXQoe21vZGVsUGF0aDpyLm1vZGVsUGF0aCxtb2RlbEFydGlmYWN0c0luZm86bH0pO2Qub25zdWNjZXNzPWZ1bmN0aW9uKCl7dmFyIG89KHU9YS50cmFuc2FjdGlvbihNT0RFTF9TVE9SRV9OQU1FLFwicmVhZHdyaXRlXCIpKS5vYmplY3RTdG9yZShNT0RFTF9TVE9SRV9OQU1FKS5wdXQoe21vZGVsUGF0aDpyLm1vZGVsUGF0aCxtb2RlbEFydGlmYWN0czp0LG1vZGVsQXJ0aWZhY3RzSW5mbzpsfSk7by5vbnN1Y2Nlc3M9ZnVuY3Rpb24oKXtyZXR1cm4gZSh7bW9kZWxBcnRpZmFjdHNJbmZvOmx9KX0sby5vbmVycm9yPWZ1bmN0aW9uKGUpe3ZhciB0PShwPWMub2JqZWN0U3RvcmUoSU5GT19TVE9SRV9OQU1FKSkuZGVsZXRlKHIubW9kZWxQYXRoKTt0Lm9uc3VjY2Vzcz1mdW5jdGlvbigpe3JldHVybiBhLmNsb3NlKCksbihvLmVycm9yKX0sdC5vbmVycm9yPWZ1bmN0aW9uKGUpe3JldHVybiBhLmNsb3NlKCksbihvLmVycm9yKX19fSxkLm9uZXJyb3I9ZnVuY3Rpb24oZSl7cmV0dXJuIGEuY2xvc2UoKSxuKGQuZXJyb3IpfSxjLm9uY29tcGxldGU9ZnVuY3Rpb24oKXtudWxsPT11P2EuY2xvc2UoKTp1Lm9uY29tcGxldGU9ZnVuY3Rpb24oKXtyZXR1cm4gYS5jbG9zZSgpfX19fSxvLm9uZXJyb3I9ZnVuY3Rpb24oZSl7cmV0dXJuIG4oby5lcnJvcil9fSl9LGUuVVJMX1NDSEVNRT1cImluZGV4ZWRkYjovL1wiLGV9KCksaW5kZXhlZERCUm91dGVyPWZ1bmN0aW9uKGUpe3JldHVybiBFTlYuZ2V0KFwiSVNfQlJPV1NFUlwiKSYmIUFycmF5LmlzQXJyYXkoZSkmJmUuc3RhcnRzV2l0aChCcm93c2VySW5kZXhlZERCLlVSTF9TQ0hFTUUpP2Jyb3dzZXJJbmRleGVkREIoZS5zbGljZShCcm93c2VySW5kZXhlZERCLlVSTF9TQ0hFTUUubGVuZ3RoKSk6bnVsbH07ZnVuY3Rpb24gYnJvd3NlckluZGV4ZWREQihlKXtyZXR1cm4gbmV3IEJyb3dzZXJJbmRleGVkREIoZSl9ZnVuY3Rpb24gbWF5YmVTdHJpcFNjaGVtZShlKXtyZXR1cm4gZS5zdGFydHNXaXRoKEJyb3dzZXJJbmRleGVkREIuVVJMX1NDSEVNRSk/ZS5zbGljZShCcm93c2VySW5kZXhlZERCLlVSTF9TQ0hFTUUubGVuZ3RoKTplfUlPUm91dGVyUmVnaXN0cnkucmVnaXN0ZXJTYXZlUm91dGVyKGluZGV4ZWREQlJvdXRlciksSU9Sb3V0ZXJSZWdpc3RyeS5yZWdpc3RlckxvYWRSb3V0ZXIoaW5kZXhlZERCUm91dGVyKTt2YXIgQnJvd3NlckluZGV4ZWREQk1hbmFnZXI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKCl7dGhpcy5pbmRleGVkREI9Z2V0SW5kZXhlZERCRmFjdG9yeSgpfXJldHVybiBlLnByb3RvdHlwZS5saXN0TW9kZWxzPWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgZT10aGlzO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHQpe3JldHVyblsyLG5ldyBQcm9taXNlKGZ1bmN0aW9uKHQscil7dmFyIG49ZS5pbmRleGVkREIub3BlbihEQVRBQkFTRV9OQU1FLERBVEFCQVNFX1ZFUlNJT04pO24ub251cGdyYWRlbmVlZGVkPWZ1bmN0aW9uKCl7cmV0dXJuIHNldFVwRGF0YWJhc2Uobil9LG4ub25zdWNjZXNzPWZ1bmN0aW9uKCl7dmFyIGU9bi5yZXN1bHQsbz1lLnRyYW5zYWN0aW9uKElORk9fU1RPUkVfTkFNRSxcInJlYWRvbmx5XCIpLGE9by5vYmplY3RTdG9yZShJTkZPX1NUT1JFX05BTUUpLmdldEFsbCgpO2Eub25zdWNjZXNzPWZ1bmN0aW9uKCl7Zm9yKHZhciBlPXt9LHI9MCxuPWEucmVzdWx0O3I8bi5sZW5ndGg7cisrKXt2YXIgbz1uW3JdO2Vbby5tb2RlbFBhdGhdPW8ubW9kZWxBcnRpZmFjdHNJbmZvfXQoZSl9LGEub25lcnJvcj1mdW5jdGlvbih0KXtyZXR1cm4gZS5jbG9zZSgpLHIoYS5lcnJvcil9LG8ub25jb21wbGV0ZT1mdW5jdGlvbigpe3JldHVybiBlLmNsb3NlKCl9fSxuLm9uZXJyb3I9ZnVuY3Rpb24oZSl7cmV0dXJuIHIobi5lcnJvcil9fSldfSl9KX0sZS5wcm90b3R5cGUucmVtb3ZlTW9kZWw9ZnVuY3Rpb24oZSl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgdD10aGlzO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHIpe3JldHVybiBlPW1heWJlU3RyaXBTY2hlbWUoZSksWzIsbmV3IFByb21pc2UoZnVuY3Rpb24ocixuKXt2YXIgbz10LmluZGV4ZWREQi5vcGVuKERBVEFCQVNFX05BTUUsREFUQUJBU0VfVkVSU0lPTik7by5vbnVwZ3JhZGVuZWVkZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gc2V0VXBEYXRhYmFzZShvKX0sby5vbnN1Y2Nlc3M9ZnVuY3Rpb24oKXt2YXIgdCxhPW8ucmVzdWx0LGk9YS50cmFuc2FjdGlvbihJTkZPX1NUT1JFX05BTUUsXCJyZWFkd3JpdGVcIikscz1pLm9iamVjdFN0b3JlKElORk9fU1RPUkVfTkFNRSksdT1zLmdldChlKTt1Lm9uc3VjY2Vzcz1mdW5jdGlvbigpe2lmKG51bGw9PXUucmVzdWx0KXJldHVybiBhLmNsb3NlKCksbihuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2RlbCB3aXRoIHBhdGggJ1wiK2UrXCInIGluIEluZGV4ZWREQi5cIikpO3ZhciBvPXMuZGVsZXRlKGUpLGk9ZnVuY3Rpb24oKXt2YXIgbz0odD1hLnRyYW5zYWN0aW9uKE1PREVMX1NUT1JFX05BTUUsXCJyZWFkd3JpdGVcIikpLm9iamVjdFN0b3JlKE1PREVMX1NUT1JFX05BTUUpLmRlbGV0ZShlKTtvLm9uc3VjY2Vzcz1mdW5jdGlvbigpe3JldHVybiByKHUucmVzdWx0Lm1vZGVsQXJ0aWZhY3RzSW5mbyl9LG8ub25lcnJvcj1mdW5jdGlvbihlKXtyZXR1cm4gbih1LmVycm9yKX19O28ub25zdWNjZXNzPWksby5vbmVycm9yPWZ1bmN0aW9uKGUpe3JldHVybiBpKCksYS5jbG9zZSgpLG4odS5lcnJvcil9fSx1Lm9uZXJyb3I9ZnVuY3Rpb24oZSl7cmV0dXJuIGEuY2xvc2UoKSxuKHUuZXJyb3IpfSxpLm9uY29tcGxldGU9ZnVuY3Rpb24oKXtudWxsPT10P2EuY2xvc2UoKTp0Lm9uY29tcGxldGU9ZnVuY3Rpb24oKXtyZXR1cm4gYS5jbG9zZSgpfX19LG8ub25lcnJvcj1mdW5jdGlvbihlKXtyZXR1cm4gbihvLmVycm9yKX19KV19KX0pfSxlfSgpO2lmKEVOVi5nZXQoXCJJU19CUk9XU0VSXCIpKXRyeXtNb2RlbFN0b3JlTWFuYWdlclJlZ2lzdHJ5LnJlZ2lzdGVyTWFuYWdlcihCcm93c2VySW5kZXhlZERCLlVSTF9TQ0hFTUUsbmV3IEJyb3dzZXJJbmRleGVkREJNYW5hZ2VyKX1jYXRjaChlKXt9dmFyIFBBVEhfU0VQQVJBVE9SPVwiL1wiLFBBVEhfUFJFRklYPVwidGVuc29yZmxvd2pzX21vZGVsc1wiLElORk9fU1VGRklYPVwiaW5mb1wiLE1PREVMX1RPUE9MT0dZX1NVRkZJWD1cIm1vZGVsX3RvcG9sb2d5XCIsV0VJR0hUX1NQRUNTX1NVRkZJWD1cIndlaWdodF9zcGVjc1wiLFdFSUdIVF9EQVRBX1NVRkZJWD1cIndlaWdodF9kYXRhXCI7ZnVuY3Rpb24gZ2V0TW9kZWxLZXlzKGUpe3JldHVybntpbmZvOltQQVRIX1BSRUZJWCxlLElORk9fU1VGRklYXS5qb2luKFBBVEhfU0VQQVJBVE9SKSx0b3BvbG9neTpbUEFUSF9QUkVGSVgsZSxNT0RFTF9UT1BPTE9HWV9TVUZGSVhdLmpvaW4oUEFUSF9TRVBBUkFUT1IpLHdlaWdodFNwZWNzOltQQVRIX1BSRUZJWCxlLFdFSUdIVF9TUEVDU19TVUZGSVhdLmpvaW4oUEFUSF9TRVBBUkFUT1IpLHdlaWdodERhdGE6W1BBVEhfUFJFRklYLGUsV0VJR0hUX0RBVEFfU1VGRklYXS5qb2luKFBBVEhfU0VQQVJBVE9SKX19ZnVuY3Rpb24gZ2V0TW9kZWxQYXRoRnJvbUtleShlKXt2YXIgdD1lLnNwbGl0KFBBVEhfU0VQQVJBVE9SKTtpZih0Lmxlbmd0aDwzKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQga2V5IGZvcm1hdDogXCIrZSk7cmV0dXJuIHQuc2xpY2UoMSx0Lmxlbmd0aC0xKS5qb2luKFBBVEhfU0VQQVJBVE9SKX1mdW5jdGlvbiBtYXliZVN0cmlwU2NoZW1lJDEoZSl7cmV0dXJuIGUuc3RhcnRzV2l0aChCcm93c2VyTG9jYWxTdG9yYWdlLlVSTF9TQ0hFTUUpP2Uuc2xpY2UoQnJvd3NlckxvY2FsU3RvcmFnZS5VUkxfU0NIRU1FLmxlbmd0aCk6ZX12YXIgQnJvd3NlckxvY2FsU3RvcmFnZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSl7aWYoIUVOVi5nZXQoXCJJU19CUk9XU0VSXCIpfHx2b2lkIDA9PT13aW5kb3cubG9jYWxTdG9yYWdlKXRocm93IG5ldyBFcnJvcihcIlRoZSBjdXJyZW50IGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgbG9jYWwgc3RvcmFnZS5cIik7aWYodGhpcy5MUz13aW5kb3cubG9jYWxTdG9yYWdlLG51bGw9PWV8fCFlKXRocm93IG5ldyBFcnJvcihcIkZvciBsb2NhbCBzdG9yYWdlLCBtb2RlbFBhdGggbXVzdCBub3QgYmUgbnVsbCwgdW5kZWZpbmVkIG9yIGVtcHR5LlwiKTt0aGlzLm1vZGVsUGF0aD1lLHRoaXMua2V5cz1nZXRNb2RlbEtleXModGhpcy5tb2RlbFBhdGgpfXJldHVybiBlLnByb3RvdHlwZS5zYXZlPWZ1bmN0aW9uKGUpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQscixuLG87cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oYSl7aWYoZS5tb2RlbFRvcG9sb2d5IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpdGhyb3cgbmV3IEVycm9yKFwiQnJvd3NlckxvY2FsU3RvcmFnZS5zYXZlKCkgZG9lcyBub3Qgc3VwcG9ydCBzYXZpbmcgbW9kZWwgdG9wb2xvZ3kgaW4gYmluYXJ5IGZvcm1hdHMgeWV0LlwiKTt0PUpTT04uc3RyaW5naWZ5KGUubW9kZWxUb3BvbG9neSkscj1KU09OLnN0cmluZ2lmeShlLndlaWdodFNwZWNzKSxuPWdldE1vZGVsQXJ0aWZhY3RzSW5mb0ZvckpTT04oZSk7dHJ5e3JldHVybiB0aGlzLkxTLnNldEl0ZW0odGhpcy5rZXlzLmluZm8sSlNPTi5zdHJpbmdpZnkobikpLHRoaXMuTFMuc2V0SXRlbSh0aGlzLmtleXMudG9wb2xvZ3ksdCksdGhpcy5MUy5zZXRJdGVtKHRoaXMua2V5cy53ZWlnaHRTcGVjcyxyKSx0aGlzLkxTLnNldEl0ZW0odGhpcy5rZXlzLndlaWdodERhdGEsYXJyYXlCdWZmZXJUb0Jhc2U2NFN0cmluZyhlLndlaWdodERhdGEpKSxbMix7bW9kZWxBcnRpZmFjdHNJbmZvOm59XX1jYXRjaChlKXtmb3IobyBpbiB0aGlzLmtleXMpdGhpcy5MUy5yZW1vdmVJdGVtKHRoaXMua2V5c1tvXSk7dGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIHNhdmUgbW9kZWwgJ1wiK3RoaXMubW9kZWxQYXRoK1wiJyB0byBsb2NhbCBzdG9yYWdlOiBzaXplIHF1b3RhIGJlaW5nIGV4Y2VlZGVkIGlzIGEgcG9zc2libGUgY2F1c2Ugb2YgdGhpcyBmYWlsdXJlOiBtb2RlbFRvcG9sb2d5Qnl0ZXM9XCIrbi5tb2RlbFRvcG9sb2d5Qnl0ZXMrXCIsIHdlaWdodFNwZWNzQnl0ZXM9XCIrbi53ZWlnaHRTcGVjc0J5dGVzK1wiLCB3ZWlnaHREYXRhQnl0ZXM9XCIrbi53ZWlnaHREYXRhQnl0ZXMrXCIuXCIpfXJldHVyblsyXX0pfSl9LGUucHJvdG90eXBlLmxvYWQ9ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBlLHQscixuLG87cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oYSl7aWYobnVsbD09KGU9SlNPTi5wYXJzZSh0aGlzLkxTLmdldEl0ZW0odGhpcy5rZXlzLmluZm8pKSkpdGhyb3cgbmV3IEVycm9yKFwiSW4gbG9jYWwgc3RvcmFnZSwgdGhlcmUgaXMgbm8gbW9kZWwgd2l0aCBuYW1lICdcIit0aGlzLm1vZGVsUGF0aCtcIidcIik7aWYoXCJKU09OXCIhPT1lLm1vZGVsVG9wb2xvZ3lUeXBlKXRocm93IG5ldyBFcnJvcihcIkJyb3dzZXJMb2NhbFN0b3JhZ2UgZG9lcyBub3Qgc3VwcG9ydCBsb2FkaW5nIG5vbi1KU09OIG1vZGVsIHRvcG9sb2d5IHlldC5cIik7aWYodD17fSxudWxsPT0ocj1KU09OLnBhcnNlKHRoaXMuTFMuZ2V0SXRlbSh0aGlzLmtleXMudG9wb2xvZ3kpKSkpdGhyb3cgbmV3IEVycm9yKFwiSW4gbG9jYWwgc3RvcmFnZSwgdGhlIHRvcG9sb2d5IG9mIG1vZGVsICdcIit0aGlzLm1vZGVsUGF0aCtcIicgaXMgbWlzc2luZy5cIik7aWYodC5tb2RlbFRvcG9sb2d5PXIsbnVsbD09KG49SlNPTi5wYXJzZSh0aGlzLkxTLmdldEl0ZW0odGhpcy5rZXlzLndlaWdodFNwZWNzKSkpKXRocm93IG5ldyBFcnJvcihcIkluIGxvY2FsIHN0b3JhZ2UsIHRoZSB3ZWlnaHQgc3BlY3Mgb2YgbW9kZWwgJ1wiK3RoaXMubW9kZWxQYXRoK1wiJyBhcmUgbWlzc2luZy5cIik7aWYodC53ZWlnaHRTcGVjcz1uLG51bGw9PShvPXRoaXMuTFMuZ2V0SXRlbSh0aGlzLmtleXMud2VpZ2h0RGF0YSkpKXRocm93IG5ldyBFcnJvcihcIkluIGxvY2FsIHN0b3JhZ2UsIHRoZSBiaW5hcnkgd2VpZ2h0IHZhbHVlcyBvZiBtb2RlbCAnXCIrdGhpcy5tb2RlbFBhdGgrXCInIGFyZSBtaXNzaW5nLlwiKTtyZXR1cm4gdC53ZWlnaHREYXRhPWJhc2U2NFN0cmluZ1RvQXJyYXlCdWZmZXIobyksWzIsdF19KX0pfSxlLlVSTF9TQ0hFTUU9XCJsb2NhbHN0b3JhZ2U6Ly9cIixlfSgpLGxvY2FsU3RvcmFnZVJvdXRlcj1mdW5jdGlvbihlKXtyZXR1cm4gRU5WLmdldChcIklTX0JST1dTRVJcIikmJiFBcnJheS5pc0FycmF5KGUpJiZlLnN0YXJ0c1dpdGgoQnJvd3NlckxvY2FsU3RvcmFnZS5VUkxfU0NIRU1FKT9icm93c2VyTG9jYWxTdG9yYWdlKGUuc2xpY2UoQnJvd3NlckxvY2FsU3RvcmFnZS5VUkxfU0NIRU1FLmxlbmd0aCkpOm51bGx9O2Z1bmN0aW9uIGJyb3dzZXJMb2NhbFN0b3JhZ2UoZSl7cmV0dXJuIG5ldyBCcm93c2VyTG9jYWxTdG9yYWdlKGUpfUlPUm91dGVyUmVnaXN0cnkucmVnaXN0ZXJTYXZlUm91dGVyKGxvY2FsU3RvcmFnZVJvdXRlciksSU9Sb3V0ZXJSZWdpc3RyeS5yZWdpc3RlckxvYWRSb3V0ZXIobG9jYWxTdG9yYWdlUm91dGVyKTt2YXIgQnJvd3NlckxvY2FsU3RvcmFnZU1hbmFnZXI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKCl7YXNzZXJ0KEVOVi5nZXQoXCJJU19CUk9XU0VSXCIpLFwiQ3VycmVudCBlbnZpcm9ubWVudCBpcyBub3QgYSB3ZWIgYnJvd3NlclwiKSxhc3NlcnQodm9pZCAwIT09d2luZG93LmxvY2FsU3RvcmFnZSxcIkN1cnJlbnQgYnJvd3NlciBkb2VzIG5vdCBhcHBlYXIgdG8gc3VwcG9ydCBsb2NhbFN0b3JhZ2VcIiksdGhpcy5MUz13aW5kb3cubG9jYWxTdG9yYWdlfXJldHVybiBlLnByb3RvdHlwZS5saXN0TW9kZWxzPWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgZSx0LHIsbixvLGE7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oaSl7Zm9yKGU9e30sdD1QQVRIX1BSRUZJWCtQQVRIX1NFUEFSQVRPUixyPVBBVEhfU0VQQVJBVE9SK0lORk9fU1VGRklYLG49MDtuPHRoaXMuTFMubGVuZ3RoOysrbikobz10aGlzLkxTLmtleShuKSkuc3RhcnRzV2l0aCh0KSYmby5lbmRzV2l0aChyKSYmKGE9Z2V0TW9kZWxQYXRoRnJvbUtleShvKSxlW2FdPUpTT04ucGFyc2UodGhpcy5MUy5nZXRJdGVtKG8pKSk7cmV0dXJuWzIsZV19KX0pfSxlLnByb3RvdHlwZS5yZW1vdmVNb2RlbD1mdW5jdGlvbihlKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciB0LHI7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24obil7aWYoZT1tYXliZVN0cmlwU2NoZW1lJDEoZSksdD1nZXRNb2RlbEtleXMoZSksbnVsbD09dGhpcy5MUy5nZXRJdGVtKHQuaW5mbykpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kZWwgYXQgcGF0aCAnXCIrZStcIidcIik7cmV0dXJuIHI9SlNPTi5wYXJzZSh0aGlzLkxTLmdldEl0ZW0odC5pbmZvKSksdGhpcy5MUy5yZW1vdmVJdGVtKHQuaW5mbyksdGhpcy5MUy5yZW1vdmVJdGVtKHQudG9wb2xvZ3kpLHRoaXMuTFMucmVtb3ZlSXRlbSh0LndlaWdodFNwZWNzKSx0aGlzLkxTLnJlbW92ZUl0ZW0odC53ZWlnaHREYXRhKSxbMixyXX0pfSl9LGV9KCk7aWYoRU5WLmdldChcIklTX0JST1dTRVJcIikpdHJ5e01vZGVsU3RvcmVNYW5hZ2VyUmVnaXN0cnkucmVnaXN0ZXJNYW5hZ2VyKEJyb3dzZXJMb2NhbFN0b3JhZ2UuVVJMX1NDSEVNRSxuZXcgQnJvd3NlckxvY2FsU3RvcmFnZU1hbmFnZXIpfWNhdGNoKGUpe312YXIgREVGQVVMVF9GSUxFX05BTUVfUFJFRklYPVwibW9kZWxcIixERUZBVUxUX0pTT05fRVhURU5TSU9OX05BTUU9XCIuanNvblwiLERFRkFVTFRfV0VJR0hUX0RBVEFfRVhURU5TSU9OX05BTUU9XCIud2VpZ2h0cy5iaW5cIixCcm93c2VyRG93bmxvYWRzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0KXtpZighRU5WLmdldChcIklTX0JST1dTRVJcIikpdGhyb3cgbmV3IEVycm9yKFwidHJpZ2dlckRvd25sb2FkcygpIGNhbm5vdCBwcm9jZWVkIGJlY2F1c2UgdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQgaXMgbm90IGEgYnJvd3Nlci5cIik7dC5zdGFydHNXaXRoKGUuVVJMX1NDSEVNRSkmJih0PXQuc2xpY2UoZS5VUkxfU0NIRU1FLmxlbmd0aCkpLG51bGwhPXQmJjAhPT10Lmxlbmd0aHx8KHQ9REVGQVVMVF9GSUxFX05BTUVfUFJFRklYKSx0aGlzLm1vZGVsVG9wb2xvZ3lGaWxlTmFtZT10K0RFRkFVTFRfSlNPTl9FWFRFTlNJT05fTkFNRSx0aGlzLndlaWdodERhdGFGaWxlTmFtZT10K0RFRkFVTFRfV0VJR0hUX0RBVEFfRVhURU5TSU9OX05BTUV9cmV0dXJuIGUucHJvdG90eXBlLnNhdmU9ZnVuY3Rpb24oZSl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgdCxyLG4sbyxhLGk7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24ocyl7aWYodD13aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbZS53ZWlnaHREYXRhXSx7dHlwZTpcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwifSkpLGUubW9kZWxUb3BvbG9neSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKXRocm93IG5ldyBFcnJvcihcIkRvd25sb2FkVHJpZ2dlci5zYXZlKCkgZG9lcyBub3Qgc3VwcG9ydCBzYXZpbmcgbW9kZWwgdG9wb2xvZ3kgaW4gYmluYXJ5IGZvcm1hdHMgeWV0LlwiKTtyZXR1cm4gcj1be3BhdGhzOltcIi4vXCIrdGhpcy53ZWlnaHREYXRhRmlsZU5hbWVdLHdlaWdodHM6ZS53ZWlnaHRTcGVjc31dLG49e21vZGVsVG9wb2xvZ3k6ZS5tb2RlbFRvcG9sb2d5LHdlaWdodHNNYW5pZmVzdDpyfSxvPXdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFtKU09OLnN0cmluZ2lmeShuKV0se3R5cGU6XCJhcHBsaWNhdGlvbi9qc29uXCJ9KSksKGE9bnVsbD09dGhpcy5qc29uQW5jaG9yP2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpOnRoaXMuanNvbkFuY2hvcikuZG93bmxvYWQ9dGhpcy5tb2RlbFRvcG9sb2d5RmlsZU5hbWUsYS5ocmVmPW8sYS5jbGljaygpLG51bGwhPWUud2VpZ2h0RGF0YSYmKChpPW51bGw9PXRoaXMud2VpZ2h0RGF0YUFuY2hvcj9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTp0aGlzLndlaWdodERhdGFBbmNob3IpLmRvd25sb2FkPXRoaXMud2VpZ2h0RGF0YUZpbGVOYW1lLGkuaHJlZj10LGkuY2xpY2soKSksWzIse21vZGVsQXJ0aWZhY3RzSW5mbzpnZXRNb2RlbEFydGlmYWN0c0luZm9Gb3JKU09OKGUpfV19KX0pfSxlLlVSTF9TQ0hFTUU9XCJkb3dubG9hZHM6Ly9cIixlfSgpLEJyb3dzZXJGaWxlcz1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSl7aWYobnVsbD09ZXx8ZS5sZW5ndGg8MSl0aHJvdyBuZXcgRXJyb3IoXCJXaGVuIGNhbGxpbmcgYnJvd3NlckZpbGVzLCBhdCBsZWFzdCAxIGZpbGUgaXMgcmVxdWlyZWQsIGJ1dCByZWNlaXZlZCBcIitlKTt0aGlzLmZpbGVzPWV9cmV0dXJuIGUucHJvdG90eXBlLmxvYWQ9ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBlLHQscj10aGlzO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKG4pe3JldHVybiBlPXRoaXMuZmlsZXNbMF0sdD10aGlzLmZpbGVzLnNsaWNlKDEpLFsyLG5ldyBQcm9taXNlKGZ1bmN0aW9uKG4sbyl7dmFyIGE9bmV3IEZpbGVSZWFkZXI7YS5vbmxvYWQ9ZnVuY3Rpb24oYSl7dmFyIGk9SlNPTi5wYXJzZShhLnRhcmdldC5yZXN1bHQpLHM9aS5tb2RlbFRvcG9sb2d5O2lmKG51bGwhPXMpezA9PT10Lmxlbmd0aCYmbih7bW9kZWxUb3BvbG9neTpzfSk7dmFyIHU9aS53ZWlnaHRzTWFuaWZlc3Q7aWYobnVsbCE9dSl7dmFyIGw7dHJ5e2w9ci5jaGVja01hbmlmZXN0QW5kV2VpZ2h0RmlsZXModSx0KX1jYXRjaChlKXtyZXR1cm4gdm9pZCBvKGUpfXZhciBjPVtdLHA9W10sZD1bXTt1LmZvckVhY2goZnVuY3Rpb24oZSl7ZS5wYXRocy5mb3JFYWNoKGZ1bmN0aW9uKGUpe3AucHVzaChlKSxkLnB1c2gobnVsbCl9KSxjLnB1c2guYXBwbHkoYyxlLndlaWdodHMpfSksdS5mb3JFYWNoKGZ1bmN0aW9uKGUpe2UucGF0aHMuZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgdD1uZXcgRmlsZVJlYWRlcjt0Lm9ubG9hZD1mdW5jdGlvbih0KXt2YXIgcj10LnRhcmdldC5yZXN1bHQsbz1wLmluZGV4T2YoZSk7ZFtvXT1yLC0xPT09ZC5pbmRleE9mKG51bGwpJiZuKHttb2RlbFRvcG9sb2d5OnMsd2VpZ2h0U3BlY3M6Yyx3ZWlnaHREYXRhOmNvbmNhdGVuYXRlQXJyYXlCdWZmZXJzKGQpfSl9LHQub25lcnJvcj1mdW5jdGlvbih0KXtvKFwiRmFpbGVkIHRvIHdlaWdodHMgZGF0YSBmcm9tIGZpbGUgb2YgcGF0aCAnXCIrZStcIicuXCIpfSx0LnJlYWRBc0FycmF5QnVmZmVyKGxbZV0pfSl9KX1lbHNlIG8obmV3IEVycm9yKFwid2VpZ2h0TWFuaWZlc3QgZmllbGQgaXMgbWlzc2luZyBmcm9tIGZpbGUgXCIrZS5uYW1lKSl9ZWxzZSBvKG5ldyBFcnJvcihcIm1vZGVsVG9wb2xvZ3kgZmllbGQgaXMgbWlzc2luZyBmcm9tIGZpbGUgXCIrZS5uYW1lKSl9LGEub25lcnJvcj1mdW5jdGlvbih0KXtvKFwiRmFpbGVkIHRvIHJlYWQgbW9kZWwgdG9wb2xvZ3kgYW5kIHdlaWdodHMgbWFuaWZlc3QgSlNPTiBmcm9tIGZpbGUgJ1wiK2UubmFtZStcIicuIEJyb3dzZXJGaWxlcyBzdXBwb3J0cyBsb2FkaW5nIEtlcmFzLXN0eWxlIHRmLk1vZGVsIGFydGlmYWN0cyBvbmx5LlwiKX0sYS5yZWFkQXNUZXh0KGUpfSldfSl9KX0sZS5wcm90b3R5cGUuY2hlY2tNYW5pZmVzdEFuZFdlaWdodEZpbGVzPWZ1bmN0aW9uKGUsdCl7Zm9yKHZhciByPVtdLG49dC5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGJhc2VuYW1lKGUubmFtZSl9KSxvPXt9LGE9MCxpPWU7YTxpLmxlbmd0aDthKyspe2lbYV0ucGF0aHMuZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgYT1iYXNlbmFtZShlKTtpZigtMSE9PXIuaW5kZXhPZihhKSl0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgZmlsZSBiYXNlbmFtZSBmb3VuZCBpbiB3ZWlnaHRzIG1hbmlmZXN0OiAnXCIrYStcIidcIik7aWYoci5wdXNoKGEpLC0xPT09bi5pbmRleE9mKGEpKXRocm93IG5ldyBFcnJvcihcIldlaWdodCBmaWxlIHdpdGggYmFzZW5hbWUgJ1wiK2ErXCInIGlzIG5vdCBwcm92aWRlZC5cIik7b1tlXT10W24uaW5kZXhPZihhKV19KX1pZihyLmxlbmd0aCE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIk1pc21hdGNoIGluIHRoZSBudW1iZXIgb2YgZmlsZXMgaW4gd2VpZ2h0cyBtYW5pZmVzdCAoXCIrci5sZW5ndGgrXCIpIGFuZCB0aGUgbnVtYmVyIG9mIHdlaWdodCBmaWxlcyBwcm92aWRlZCAoXCIrdC5sZW5ndGgrXCIpLlwiKTtyZXR1cm4gb30sZX0oKSxicm93c2VyRG93bmxvYWRzUm91dGVyPWZ1bmN0aW9uKGUpe3JldHVybiBFTlYuZ2V0KFwiSVNfQlJPV1NFUlwiKSYmIUFycmF5LmlzQXJyYXkoZSkmJmUuc3RhcnRzV2l0aChCcm93c2VyRG93bmxvYWRzLlVSTF9TQ0hFTUUpP2Jyb3dzZXJEb3dubG9hZHMoZS5zbGljZShCcm93c2VyRG93bmxvYWRzLlVSTF9TQ0hFTUUubGVuZ3RoKSk6bnVsbH07ZnVuY3Rpb24gYnJvd3NlckRvd25sb2FkcyhlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9XCJtb2RlbFwiKSxuZXcgQnJvd3NlckRvd25sb2FkcyhlKX1mdW5jdGlvbiBicm93c2VyRmlsZXMoZSl7cmV0dXJuIG5ldyBCcm93c2VyRmlsZXMoZSl9ZnVuY3Rpb24gbG9hZFdlaWdodHNBc0FycmF5QnVmZmVyKGUsdCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgcixuO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKG8pe3N3aXRjaChvLmxhYmVsKXtjYXNlIDA6cmV0dXJuIHI9ZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGZldGNoKGUsdCl9KSxbNCxQcm9taXNlLmFsbChyKV07Y2FzZSAxOnJldHVybiBuPW8uc2VudCgpLFs0LFByb21pc2UuYWxsKG4ubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLmFycmF5QnVmZmVyKCl9KSldO2Nhc2UgMjpyZXR1cm5bMixvLnNlbnQoKV19fSl9KX1mdW5jdGlvbiBsb2FkV2VpZ2h0cyhlLHQscixuKXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9XCJcIiksX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBvLGEsaSxzLHUsbCxjLHAsZCxoO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGYpe3N3aXRjaChmLmxhYmVsKXtjYXNlIDA6aWYobz1lLm1hcChmdW5jdGlvbigpe3JldHVybiExfSksYT17fSxpPW51bGwhPXI/ci5tYXAoZnVuY3Rpb24oKXtyZXR1cm4hMX0pOltdLHM9W10sZS5mb3JFYWNoKGZ1bmN0aW9uKGUsdCl7dmFyIG49MDtlLndlaWdodHMuZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgdT1cInF1YW50aXphdGlvblwiaW4gZT9lLnF1YW50aXphdGlvbi5kdHlwZTplLmR0eXBlLGw9RFRZUEVfVkFMVUVfU0laRV9NQVBbdV0qc2l6ZUZyb21TaGFwZShlLnNoYXBlKSxjPWZ1bmN0aW9uKCl7b1t0XT0hMCxudWxsPT1hW3RdJiYoYVt0XT1bXSksYVt0XS5wdXNoKHttYW5pZmVzdEVudHJ5OmUsZ3JvdXBPZmZzZXQ6bixzaXplQnl0ZXM6bH0pfTtudWxsIT1yP3IuZm9yRWFjaChmdW5jdGlvbih0LHIpe3Q9PT1lLm5hbWUmJihjKCksaVtyXT0hMCl9KTpjKCkscy5wdXNoKGUubmFtZSksbis9bH0pfSksIWkuZXZlcnkoZnVuY3Rpb24oZSl7cmV0dXJuIGV9KSl0aHJvdyB1PXIuZmlsdGVyKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIWlbdF19KSxuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCB3ZWlnaHRzIGluIG1hbmlmZXN0IHdpdGggbmFtZXM6IFwiK3Uuam9pbihcIiwgXCIpK1wiLiBcXG5NYW5pZmVzdCBKU09OIGhhcyB3ZWlnaHRzIHdpdGggbmFtZXM6IFwiK3Muam9pbihcIiwgXCIpK1wiLlwiKTtyZXR1cm4gbD1vLnJlZHVjZShmdW5jdGlvbihlLHQscil7cmV0dXJuIHQmJmUucHVzaChyKSxlfSxbXSksYz1bXSxsLmZvckVhY2goZnVuY3Rpb24ocil7ZVtyXS5wYXRocy5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciByPXQrKHQuZW5kc1dpdGgoXCIvXCIpP1wiXCI6XCIvXCIpK2U7Yy5wdXNoKHIpfSl9KSxbNCxsb2FkV2VpZ2h0c0FzQXJyYXlCdWZmZXIoYyxuKV07Y2FzZSAxOnJldHVybiBwPWYuc2VudCgpLGQ9e30saD0wLGwuZm9yRWFjaChmdW5jdGlvbih0KXtmb3IodmFyIHI9ZVt0XS5wYXRocy5sZW5ndGgsbj0wLG89MDtvPHI7bysrKW4rPXBbaCtvXS5ieXRlTGVuZ3RoO2Zvcih2YXIgaT1uZXcgQXJyYXlCdWZmZXIobikscz1uZXcgVWludDhBcnJheShpKSx1PTAsbD0wO2w8cjtsKyspe3ZhciBjPW5ldyBVaW50OEFycmF5KHBbaCtsXSk7cy5zZXQoYyx1KSx1Kz1jLmJ5dGVMZW5ndGh9YVt0XS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciB0PWRlY29kZVdlaWdodHMoaS5zbGljZShlLmdyb3VwT2Zmc2V0LGUuZ3JvdXBPZmZzZXQrZS5zaXplQnl0ZXMpLFtlLm1hbmlmZXN0RW50cnldKTtmb3IodmFyIHIgaW4gdClkW3JdPXRbcl19KSxoKz1yfSksWzIsZF19fSl9KX1JT1JvdXRlclJlZ2lzdHJ5LnJlZ2lzdGVyU2F2ZVJvdXRlcihicm93c2VyRG93bmxvYWRzUm91dGVyKTt2YXIgQnJvd3NlckhUVFBSZXF1ZXN0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQscil7aWYodGhpcy53ZWlnaHRQYXRoUHJlZml4PXIsdGhpcy5ERUZBVUxUX01FVEhPRD1cIlBPU1RcIixcInVuZGVmaW5lZFwiPT10eXBlb2YgZmV0Y2gpdGhyb3cgbmV3IEVycm9yKFwiYnJvd3NlckhUVFBSZXF1ZXN0IGlzIG5vdCBzdXBwb3J0ZWQgb3V0c2lkZSB0aGUgd2ViIGJyb3dzZXIgd2l0aG91dCBhIGZldGNoIHBvbHlmaWxsLlwiKTtpZihhc3NlcnQobnVsbCE9ZSYmZS5sZW5ndGg+MCxcIlVSTCBwYXRoIGZvciBicm93c2VySFRUUFJlcXVlc3QgbXVzdCBub3QgYmUgbnVsbCwgdW5kZWZpbmVkIG9yIGVtcHR5LlwiKSxBcnJheS5pc0FycmF5KGUpJiZhc3NlcnQoMj09PWUubGVuZ3RoLFwiVVJMIHBhdGhzIGZvciBicm93c2VySFRUUFJlcXVlc3QgbXVzdCBoYXZlIGEgbGVuZ3RoIG9mIDIsIChhY3R1YWwgbGVuZ3RoIGlzIFwiK2UubGVuZ3RoK1wiKS5cIiksdGhpcy5wYXRoPWUsbnVsbCE9dCYmbnVsbCE9dC5ib2R5KXRocm93IG5ldyBFcnJvcihcInJlcXVlc3RJbml0IGlzIGV4cGVjdGVkIHRvIGhhdmUgbm8gcHJlLWV4aXN0aW5nIGJvZHksIGJ1dCBoYXMgb25lLlwiKTt0aGlzLnJlcXVlc3RJbml0PXR8fHt9fXJldHVybiBlLnByb3RvdHlwZS5zYXZlPWZ1bmN0aW9uKGUpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQscixuLG87cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oYSl7c3dpdGNoKGEubGFiZWwpe2Nhc2UgMDppZihlLm1vZGVsVG9wb2xvZ3kgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcil0aHJvdyBuZXcgRXJyb3IoXCJCcm93c2VySFRUUFJlcXVlc3Quc2F2ZSgpIGRvZXMgbm90IHN1cHBvcnQgc2F2aW5nIG1vZGVsIHRvcG9sb2d5IGluIGJpbmFyeSBmb3JtYXRzIHlldC5cIik7cmV0dXJuKHQ9T2JqZWN0LmFzc2lnbih7bWV0aG9kOnRoaXMuREVGQVVMVF9NRVRIT0R9LHRoaXMucmVxdWVzdEluaXQpKS5ib2R5PW5ldyBGb3JtRGF0YSxyPVt7cGF0aHM6W1wiLi9tb2RlbC53ZWlnaHRzLmJpblwiXSx3ZWlnaHRzOmUud2VpZ2h0U3BlY3N9XSxuPXttb2RlbFRvcG9sb2d5OmUubW9kZWxUb3BvbG9neSx3ZWlnaHRzTWFuaWZlc3Q6cn0sdC5ib2R5LmFwcGVuZChcIm1vZGVsLmpzb25cIixuZXcgQmxvYihbSlNPTi5zdHJpbmdpZnkobildLHt0eXBlOlwiYXBwbGljYXRpb24vanNvblwifSksXCJtb2RlbC5qc29uXCIpLG51bGwhPWUud2VpZ2h0RGF0YSYmdC5ib2R5LmFwcGVuZChcIm1vZGVsLndlaWdodHMuYmluXCIsbmV3IEJsb2IoW2Uud2VpZ2h0RGF0YV0se3R5cGU6XCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIn0pLFwibW9kZWwud2VpZ2h0cy5iaW5cIiksWzQsZmV0Y2godGhpcy5wYXRoLHQpXTtjYXNlIDE6aWYoKG89YS5zZW50KCkpLm9rKXJldHVyblsyLHttb2RlbEFydGlmYWN0c0luZm86Z2V0TW9kZWxBcnRpZmFjdHNJbmZvRm9ySlNPTihlKSxyZXNwb25zZXM6W29dfV07dGhyb3cgbmV3IEVycm9yKFwiQnJvd3NlckhUVFBSZXF1ZXN0LnNhdmUoKSBmYWlsZWQgZHVlIHRvIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIFwiK28uc3RhdHVzK1wiLlwiKX19KX0pfSxlLnByb3RvdHlwZS5sb2FkPWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihlKXtyZXR1cm5bMixBcnJheS5pc0FycmF5KHRoaXMucGF0aCk/dGhpcy5sb2FkQmluYXJ5TW9kZWwoKTp0aGlzLmxvYWRKU09OTW9kZWwoKV19KX0pfSxlLnByb3RvdHlwZS5sb2FkQmluYXJ5VG9wb2xvZ3k9ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBlLHQ7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24ocil7c3dpdGNoKHIubGFiZWwpe2Nhc2UgMDpyZXR1cm4gci50cnlzLnB1c2goWzAsMywsNF0pLFs0LGZldGNoKHRoaXMucGF0aFswXSx0aGlzLnJlcXVlc3RJbml0KV07Y2FzZSAxOmlmKCEoZT1yLnNlbnQoKSkub2spdGhyb3cgbmV3IEVycm9yKFwiQnJvd3NlckhUVFBSZXF1ZXN0LmxvYWQoKSBmYWlsZWQgZHVlIHRvIEhUVFAgcmVzcG9uc2U6IFwiK2Uuc3RhdHVzVGV4dCk7cmV0dXJuWzQsZS5hcnJheUJ1ZmZlcigpXTtjYXNlIDI6cmV0dXJuWzIsci5zZW50KCldO2Nhc2UgMzp0aHJvdyB0PXIuc2VudCgpLG5ldyBFcnJvcih0aGlzLnBhdGhbMF0rXCIgbm90IGZvdW5kLiBcIit0KTtjYXNlIDQ6cmV0dXJuWzJdfX0pfSl9LGUucHJvdG90eXBlLmxvYWRCaW5hcnlNb2RlbD1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIGUsdCxyLG4sbyxhLGkscztyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbih1KXtzd2l0Y2godS5sYWJlbCl7Y2FzZSAwOnJldHVybiBlPXRoaXMubG9hZEJpbmFyeVRvcG9sb2d5KCksWzQsZmV0Y2godGhpcy5wYXRoWzFdLHRoaXMucmVxdWVzdEluaXQpXTtjYXNlIDE6aWYoISh0PXUuc2VudCgpKS5vayl0aHJvdyBuZXcgRXJyb3IoXCJCcm93c2VySFRUUFJlcXVlc3QubG9hZCgpIGZhaWxlZCBkdWUgdG8gSFRUUCByZXNwb25zZTogXCIrdC5zdGF0dXNUZXh0KTtyZXR1cm5bNCxQcm9taXNlLmFsbChbZSx0XSldO2Nhc2UgMjpyZXR1cm4gcj11LnNlbnQoKSxuPXJbMF0sWzQsclsxXS5qc29uKCldO2Nhc2UgMzpyZXR1cm4gbnVsbD09KG89dS5zZW50KCkpP1szLDVdOls0LHRoaXMubG9hZFdlaWdodHMobyldO2Nhc2UgNDpzPXUuc2VudCgpLGE9c1swXSxpPXNbMV0sdS5sYWJlbD01O2Nhc2UgNTpyZXR1cm5bMix7bW9kZWxUb3BvbG9neTpuLHdlaWdodFNwZWNzOmEsd2VpZ2h0RGF0YTppfV19fSl9KX0sZS5wcm90b3R5cGUubG9hZEpTT05Nb2RlbD1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIGUsdCxyLG4sbyxhLGkscztyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbih1KXtzd2l0Y2godS5sYWJlbCl7Y2FzZSAwOnJldHVybls0LGZldGNoKHRoaXMucGF0aCx0aGlzLnJlcXVlc3RJbml0KV07Y2FzZSAxOmlmKCEoZT11LnNlbnQoKSkub2spdGhyb3cgbmV3IEVycm9yKFwiQnJvd3NlckhUVFBSZXF1ZXN0LmxvYWQoKSBmYWlsZWQgZHVlIHRvIEhUVFAgcmVzcG9uc2U6IFwiK2Uuc3RhdHVzVGV4dCk7cmV0dXJuWzQsZS5qc29uKCldO2Nhc2UgMjppZih0PXUuc2VudCgpLHI9dC5tb2RlbFRvcG9sb2d5LG49dC53ZWlnaHRzTWFuaWZlc3QsbnVsbD09ciYmbnVsbD09bil0aHJvdyBuZXcgRXJyb3IoXCJUaGUgSlNPTiBmcm9tIEhUVFAgcGF0aCBcIit0aGlzLnBhdGgrXCIgY29udGFpbnMgbmVpdGhlciBtb2RlbCB0b3BvbG9neSBvciBtYW5pZmVzdCBmb3Igd2VpZ2h0cy5cIik7cmV0dXJuIG51bGw9PW4/WzMsNF06KGk9dC53ZWlnaHRzTWFuaWZlc3QsWzQsdGhpcy5sb2FkV2VpZ2h0cyhpKV0pO2Nhc2UgMzpzPXUuc2VudCgpLG89c1swXSxhPXNbMV0sdS5sYWJlbD00O2Nhc2UgNDpyZXR1cm5bMix7bW9kZWxUb3BvbG9neTpyLHdlaWdodFNwZWNzOm8sd2VpZ2h0RGF0YTphfV19fSl9KX0sZS5wcm90b3R5cGUubG9hZFdlaWdodHM9ZnVuY3Rpb24oZSl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgdCxyLG4sbyxhLGkscyx1LGwsYyxwLGQ7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oaCl7c3dpdGNoKGgubGFiZWwpe2Nhc2UgMDpmb3IodD1BcnJheS5pc0FycmF5KHRoaXMucGF0aCk/dGhpcy5wYXRoWzFdOnRoaXMucGF0aCxyPXBhcnNlVXJsKHQpLG49clswXSxvPXJbMV0sYT10aGlzLndlaWdodFBhdGhQcmVmaXh8fG4saT1bXSxzPTAsdT1lO3M8dS5sZW5ndGg7cysrKWw9dVtzXSxpLnB1c2guYXBwbHkoaSxsLndlaWdodHMpO3JldHVybiBjPVtdLGUuZm9yRWFjaChmdW5jdGlvbihlKXtlLnBhdGhzLmZvckVhY2goZnVuY3Rpb24oZSl7Yy5wdXNoKGErZStvKX0pfSkscD1baV0sZD1jb25jYXRlbmF0ZUFycmF5QnVmZmVycyxbNCxsb2FkV2VpZ2h0c0FzQXJyYXlCdWZmZXIoYyx0aGlzLnJlcXVlc3RJbml0KV07Y2FzZSAxOnJldHVyblsyLHAuY29uY2F0KFtkLmFwcGx5KHZvaWQgMCxbaC5zZW50KCldKV0pXX19KX0pfSxlLlVSTF9TQ0hFTUVfUkVHRVg9L15odHRwcz86XFwvXFwvLyxlfSgpO2Z1bmN0aW9uIHBhcnNlVXJsKGUpe3ZhciB0PWUubGFzdEluZGV4T2YoXCIvXCIpLHI9ZS5sYXN0SW5kZXhPZihcIj9cIik7cmV0dXJuW2Uuc3Vic3RyaW5nKDAsdCkrXCIvXCIscj50P2Uuc3Vic3RyaW5nKHIpOlwiXCJdfWZ1bmN0aW9uIGlzSFRUUFNjaGVtZShlKXtyZXR1cm4gbnVsbCE9ZS5tYXRjaChCcm93c2VySFRUUFJlcXVlc3QuVVJMX1NDSEVNRV9SRUdFWCl9dmFyIGh0dHBSZXF1ZXN0Um91dGVyPWZ1bmN0aW9uKGUpe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBmZXRjaClyZXR1cm4gbnVsbDtyZXR1cm4oQXJyYXkuaXNBcnJheShlKT9lLmV2ZXJ5KGZ1bmN0aW9uKGUpe3JldHVybiBpc0hUVFBTY2hlbWUoZSl9KTppc0hUVFBTY2hlbWUoZSkpP2Jyb3dzZXJIVFRQUmVxdWVzdChlKTpudWxsfTtmdW5jdGlvbiBicm93c2VySFRUUFJlcXVlc3QoZSx0LHIpe3JldHVybiBuZXcgQnJvd3NlckhUVFBSZXF1ZXN0KGUsdCxyKX1JT1JvdXRlclJlZ2lzdHJ5LnJlZ2lzdGVyU2F2ZVJvdXRlcihodHRwUmVxdWVzdFJvdXRlciksSU9Sb3V0ZXJSZWdpc3RyeS5yZWdpc3RlckxvYWRSb3V0ZXIoaHR0cFJlcXVlc3RSb3V0ZXIpO3ZhciBQYXNzdGhyb3VnaExvYWRlcj1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0LHIpe3RoaXMubW9kZWxUb3BvbG9neT1lLHRoaXMud2VpZ2h0U3BlY3M9dCx0aGlzLndlaWdodERhdGE9cn1yZXR1cm4gZS5wcm90b3R5cGUubG9hZD1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIGU7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24odCl7cmV0dXJuIGU9e30sbnVsbCE9dGhpcy5tb2RlbFRvcG9sb2d5JiYoZT1fX2Fzc2lnbih7bW9kZWxUb3BvbG9neTp0aGlzLm1vZGVsVG9wb2xvZ3l9LGUpKSxudWxsIT10aGlzLndlaWdodFNwZWNzJiZ0aGlzLndlaWdodFNwZWNzLmxlbmd0aD4wJiYoZT1fX2Fzc2lnbih7d2VpZ2h0U3BlY3M6dGhpcy53ZWlnaHRTcGVjc30sZSkpLG51bGwhPXRoaXMud2VpZ2h0RGF0YSYmdGhpcy53ZWlnaHREYXRhLmJ5dGVMZW5ndGg+MCYmKGU9X19hc3NpZ24oe3dlaWdodERhdGE6dGhpcy53ZWlnaHREYXRhfSxlKSksWzIsZV19KX0pfSxlfSgpLFBhc3N0aHJvdWdoU2F2ZXI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUpe3RoaXMuc2F2ZUhhbmRsZXI9ZX1yZXR1cm4gZS5wcm90b3R5cGUuc2F2ZT1mdW5jdGlvbihlKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHQpe3JldHVyblsyLHRoaXMuc2F2ZUhhbmRsZXIoZSldfSl9KX0sZX0oKTtmdW5jdGlvbiBmcm9tTWVtb3J5KGUsdCxyKXtyZXR1cm4gbmV3IFBhc3N0aHJvdWdoTG9hZGVyKGUsdCxyKX1mdW5jdGlvbiB3aXRoU2F2ZUhhbmRsZXIoZSl7cmV0dXJuIG5ldyBQYXNzdGhyb3VnaFNhdmVyKGUpfXZhciByZWdpc3RlclNhdmVSb3V0ZXI9SU9Sb3V0ZXJSZWdpc3RyeS5yZWdpc3RlclNhdmVSb3V0ZXIscmVnaXN0ZXJMb2FkUm91dGVyPUlPUm91dGVyUmVnaXN0cnkucmVnaXN0ZXJMb2FkUm91dGVyLGdldFNhdmVIYW5kbGVycz1JT1JvdXRlclJlZ2lzdHJ5LmdldFNhdmVIYW5kbGVycyxnZXRMb2FkSGFuZGxlcnM9SU9Sb3V0ZXJSZWdpc3RyeS5nZXRMb2FkSGFuZGxlcnMsaW89T2JqZWN0LmZyZWV6ZSh7YnJvd3NlckZpbGVzOmJyb3dzZXJGaWxlcyxicm93c2VySFRUUFJlcXVlc3Q6YnJvd3NlckhUVFBSZXF1ZXN0LGNvbmNhdGVuYXRlQXJyYXlCdWZmZXJzOmNvbmNhdGVuYXRlQXJyYXlCdWZmZXJzLGRlY29kZVdlaWdodHM6ZGVjb2RlV2VpZ2h0cyxlbmNvZGVXZWlnaHRzOmVuY29kZVdlaWdodHMsZnJvbU1lbW9yeTpmcm9tTWVtb3J5LGdldExvYWRIYW5kbGVyczpnZXRMb2FkSGFuZGxlcnMsZ2V0TW9kZWxBcnRpZmFjdHNJbmZvRm9ySlNPTjpnZXRNb2RlbEFydGlmYWN0c0luZm9Gb3JKU09OLGdldFNhdmVIYW5kbGVyczpnZXRTYXZlSGFuZGxlcnMsbG9hZFdlaWdodHM6bG9hZFdlaWdodHMscmVnaXN0ZXJMb2FkUm91dGVyOnJlZ2lzdGVyTG9hZFJvdXRlcixyZWdpc3RlclNhdmVSb3V0ZXI6cmVnaXN0ZXJTYXZlUm91dGVyLHdpdGhTYXZlSGFuZGxlcjp3aXRoU2F2ZUhhbmRsZXIsY29weU1vZGVsOmNvcHlNb2RlbCxsaXN0TW9kZWxzOmxpc3RNb2RlbHMsbW92ZU1vZGVsOm1vdmVNb2RlbCxyZW1vdmVNb2RlbDpyZW1vdmVNb2RlbH0pO2Z1bmN0aW9uIGNvbmZ1c2lvbk1hdHJpeF8oZSx0LHIpe3ZhciBuPWNvbnZlcnRUb1RlbnNvcihlLFwibGFiZWxcIixcImNvbmZ1c2lvbk1hdHJpeFwiLFwiaW50MzJcIiksbz1jb252ZXJ0VG9UZW5zb3IodCxcImxhYmVsXCIsXCJjb25mdXNpb25NYXRyaXhcIixcImludDMyXCIpO2Fzc2VydChudWxsPT1yfHxyPjAmJk51bWJlci5pc0ludGVnZXIociksXCJJZiBwcm92aWRlZCwgbnVtQ2xhc3NlcyBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgYnV0IGdvdCBcIityKSxhc3NlcnQoMT09PW4ucmFuayxcIkV4cGVjdGVkIHRoZSByYW5rIG9mIGxhYmVscyB0byBiZSAxLCBidXQgZ290IFwiK24ucmFuayksYXNzZXJ0KDE9PT1vLnJhbmssXCJFeHBlY3RlZCB0aGUgcmFuayBvZiBwcmVkaWN0aW9ucyB0byBiZSAxLCBidXQgZ290IFwiK28ucmFuayksYXNzZXJ0KG4uc2hhcGVbMF09PT1vLnNoYXBlWzBdLFwiTWlzbWF0Y2ggaW4gdGhlIG51bWJlciBvZiBleGFtcGxlczogXCIrbi5zaGFwZVswXStcIiB2cy4gXCIrby5zaGFwZVswXStcIi4gTGFiZWxzIGFuZCBwcmVkaWN0aW9ucyBzaG91bGQgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgZWxlbWVudHMuXCIpLGFzc2VydChyPjAmJk51bWJlci5pc0ludGVnZXIociksXCJudW1DbGFzc2VzIGlzIHJlcXVpcmVkIHRvIGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgYnV0IGdvdCBcIityKTt2YXIgYT1vbmVIb3Qobi5hc1R5cGUoXCJpbnQzMlwiKSxyKSxpPW9uZUhvdChvLmFzVHlwZShcImludDMyXCIpLHIpO3JldHVybiBhLnRyYW5zcG9zZSgpLm1hdE11bChpKS5hc1R5cGUoXCJpbnQzMlwiKX12YXIgY29uZnVzaW9uTWF0cml4PW9wKHtjb25mdXNpb25NYXRyaXhfOmNvbmZ1c2lvbk1hdHJpeF99KSxtYXRoPU9iamVjdC5mcmVlemUoe2NvbmZ1c2lvbk1hdHJpeDpjb25mdXNpb25NYXRyaXh9KSxTZXJpYWxpemFibGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKCl7fXJldHVybiBlLnByb3RvdHlwZS5nZXRDbGFzc05hbWU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5jbGFzc05hbWV9LGUuZnJvbUNvbmZpZz1mdW5jdGlvbihlLHQpe3JldHVybiBuZXcgZSh0KX0sZX0oKSxTZXJpYWxpemF0aW9uTWFwPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpe3RoaXMuY2xhc3NOYW1lTWFwPXt9fXJldHVybiBlLmdldE1hcD1mdW5jdGlvbigpe3JldHVybiBudWxsPT1lLmluc3RhbmNlJiYoZS5pbnN0YW5jZT1uZXcgZSksZS5pbnN0YW5jZX0sZS5yZWdpc3Rlcj1mdW5jdGlvbih0KXtlLmdldE1hcCgpLmNsYXNzTmFtZU1hcFt0LmNsYXNzTmFtZV09W3QsdC5mcm9tQ29uZmlnXX0sZX0oKTtmdW5jdGlvbiByZWdpc3RlckNsYXNzKGUpe2Fzc2VydChudWxsIT1lLmNsYXNzTmFtZSxcIkNsYXNzIGJlaW5nIHJlZ2lzdGVyZWQgZG9lcyBub3QgaGF2ZSB0aGUgc3RhdGljIGNsYXNzTmFtZSBwcm9wZXJ0eSBkZWZpbmVkLlwiKSxhc3NlcnQoXCJzdHJpbmdcIj09dHlwZW9mIGUuY2xhc3NOYW1lLFwiY2xhc3NOYW1lIGlzIHJlcXVpcmVkIHRvIGJlIGEgc3RyaW5nLCBidXQgZ290IHR5cGUgXCIrdHlwZW9mIGUuY2xhc3NOYW1lKSxhc3NlcnQoZS5jbGFzc05hbWUubGVuZ3RoPjAsXCJDbGFzcyBiZWluZyByZWdpc3RlcmVkIGhhcyBhbiBlbXB0eS1zdHJpbmcgYXMgaXRzIGNsYXNzTmFtZSwgd2hpY2ggaXMgZGlzYWxsb3dlZC5cIiksU2VyaWFsaXphdGlvbk1hcC5yZWdpc3RlcihlKX12YXIgc2VyaWFsaXphdGlvbj1PYmplY3QuZnJlZXplKHtTZXJpYWxpemFibGU6U2VyaWFsaXphYmxlLFNlcmlhbGl6YXRpb25NYXA6U2VyaWFsaXphdGlvbk1hcCxyZWdpc3RlckNsYXNzOnJlZ2lzdGVyQ2xhc3N9KSxXRUJHTF9FTlZTPXtIQVNfV0VCR0w6ITB9LE5PREVfRU5WUz17SVNfTk9ERTohMH0sQ0hST01FX0VOVlM9e0lTX0NIUk9NRTohMH0sQlJPV1NFUl9FTlZTPXtJU19CUk9XU0VSOiEwfSxDUFVfRU5WUz17SEFTX1dFQkdMOiExfSxCUk9XU0VSX0NQVV9FTlZTPXtCQUNLRU5EOlwidGVzdC1jcHVcIn0sQUxMX0VOVlM9e307ZnVuY3Rpb24gZXhwZWN0QXJyYXlzQ2xvc2UoZSx0LHIpe2lmKG51bGw9PXImJihyPUVOVi5nZXQoXCJURVNUX0VQU0lMT05cIikpLGUgaW5zdGFuY2VvZiBUZW5zb3J8fHQgaW5zdGFuY2VvZiBUZW5zb3Ipe2lmKGUgaW5zdGFuY2VvZiBUZW5zb3ImJnQgaW5zdGFuY2VvZiBUZW5zb3Ipe2lmKGUuZHR5cGUhPT10LmR0eXBlKXRocm93IG5ldyBFcnJvcihcIkFycmF5cyBhcmUgb2YgZGlmZmVyZW50IHR5cGUgYWN0dWFsOiBcIitlLmR0eXBlK1wiIHZzIGV4cGVjdGVkOiBcIit0LmR0eXBlK1wiLlwiKTtpZighYXJyYXlzRXF1YWwoZS5zaGFwZSx0LnNoYXBlKSl0aHJvdyBuZXcgRXJyb3IoXCJBcnJheXMgYXJlIG9mIGRpZmZlcmVudCBzaGFwZSBhY3R1YWw6IFwiK2Uuc2hhcGUrXCIgdnMgZXhwZWN0ZWQ6IFwiK3Quc2hhcGUrXCIuXCIpfX1lbHNle3ZhciBuPWUuY29uc3RydWN0b3IubmFtZSxvPXQuY29uc3RydWN0b3IubmFtZTtpZihuIT09byl0aHJvdyBuZXcgRXJyb3IoXCJBcnJheXMgYXJlIG9mIGRpZmZlcmVudCB0eXBlIGFjdHVhbDogXCIrbitcIiB2cyBleHBlY3RlZDogXCIrbyl9dmFyIGEsaTtpZihhPWUgaW5zdGFuY2VvZiBUZW5zb3I/ZS5kYXRhU3luYygpOmUsaT10IGluc3RhbmNlb2YgVGVuc29yP3QuZGF0YVN5bmMoKTp0LGEubGVuZ3RoIT09aS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiQXJyYXlzIGhhdmUgZGlmZmVyZW50IGxlbmd0aHMgYWN0dWFsOiBcIithLmxlbmd0aCtcIiB2cyBleHBlY3RlZDogXCIraS5sZW5ndGgrXCIuXFxuQWN0dWFsOiAgIFwiK2ErXCIuXFxuRXhwZWN0ZWQ6IFwiK2krXCIuXCIpO2Zvcih2YXIgcz0wO3M8aS5sZW5ndGg7KytzKXt2YXIgdT1hW3NdLGw9aVtzXTtpZighYXJlQ2xvc2UodSxOdW1iZXIobCkscikpdGhyb3cgbmV3IEVycm9yKFwiQXJyYXlzIGRpZmZlcjogYWN0dWFsW1wiK3MrXCJdID0gXCIrdStcIiwgZXhwZWN0ZWRbXCIrcytcIl0gPSBcIitsK1wiLlxcbkFjdHVhbDogICBcIithK1wiLlxcbkV4cGVjdGVkOiBcIitpK1wiLlwiKX19ZnVuY3Rpb24gZXhwZWN0UHJvbWlzZVRvRmFpbChlLHQpe2UoKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIHQuZmFpbCgpfSxmdW5jdGlvbigpe3JldHVybiB0KCl9KX1mdW5jdGlvbiBleHBlY3RBcnJheXNFcXVhbChlLHQpe3JldHVybiBleHBlY3RBcnJheXNDbG9zZShlLHQsMCl9ZnVuY3Rpb24gZXhwZWN0TnVtYmVyc0Nsb3NlKGUsdCxyKXtpZihudWxsPT1yJiYocj1FTlYuZ2V0KFwiVEVTVF9FUFNJTE9OXCIpKSwhYXJlQ2xvc2UoZSx0LHIpKXRocm93IG5ldyBFcnJvcihcIk51bWJlcnMgZGlmZmVyOiBhY3R1YWwgPT09IFwiK2UrXCIsIGV4cGVjdGVkID09PSBcIit0KX1mdW5jdGlvbiBhcmVDbG9zZShlLHQscil7cmV0dXJuISghaXNOYU4oZSl8fCFpc05hTih0KSl8fCEoaXNOYU4oZSl8fGlzTmFOKHQpfHxNYXRoLmFicyhlLXQpPnIpfWZ1bmN0aW9uIGV4cGVjdFZhbHVlc0luUmFuZ2UoZSx0LHIpe3ZhciBuO249ZSBpbnN0YW5jZW9mIFRlbnNvcj9lLmRhdGFTeW5jKCk6ZTtmb3IodmFyIG89MDtvPG4ubGVuZ3RoO28rKylpZihuW29dPHR8fG5bb10+cil0aHJvdyBuZXcgRXJyb3IoXCJWYWx1ZSBvdXQgb2YgcmFuZ2U6XCIrbltvXStcIiBsb3c6IFwiK3QrXCIsIGhpZ2g6IFwiK3IpfWZ1bmN0aW9uIGV4cGVjdEFycmF5QnVmZmVyc0VxdWFsKGUsdCl7ZXhwZWN0KG5ldyBGbG9hdDMyQXJyYXkoZSkpLnRvRXF1YWwobmV3IEZsb2F0MzJBcnJheSh0KSl9dmFyIHRlc3RfdXRpbD1PYmplY3QuZnJlZXplKHtXRUJHTF9FTlZTOldFQkdMX0VOVlMsTk9ERV9FTlZTOk5PREVfRU5WUyxDSFJPTUVfRU5WUzpDSFJPTUVfRU5WUyxCUk9XU0VSX0VOVlM6QlJPV1NFUl9FTlZTLENQVV9FTlZTOkNQVV9FTlZTLEJST1dTRVJfQ1BVX0VOVlM6QlJPV1NFUl9DUFVfRU5WUyxBTExfRU5WUzpBTExfRU5WUyxleHBlY3RBcnJheXNDbG9zZTpleHBlY3RBcnJheXNDbG9zZSxleHBlY3RQcm9taXNlVG9GYWlsOmV4cGVjdFByb21pc2VUb0ZhaWwsZXhwZWN0QXJyYXlzRXF1YWw6ZXhwZWN0QXJyYXlzRXF1YWwsZXhwZWN0TnVtYmVyc0Nsb3NlOmV4cGVjdE51bWJlcnNDbG9zZSxleHBlY3RWYWx1ZXNJblJhbmdlOmV4cGVjdFZhbHVlc0luUmFuZ2UsZXhwZWN0QXJyYXlCdWZmZXJzRXF1YWw6ZXhwZWN0QXJyYXlCdWZmZXJzRXF1YWx9KSx2ZXJzaW9uPVwiMC4xMy4xMVwiLHdlYmdsPU9iamVjdC5mcmVlemUoe2dwZ3B1X3V0aWw6Z3BncHVfdXRpbCx3ZWJnbF91dGlsOndlYmdsX3V0aWwsTWF0aEJhY2tlbmRXZWJHTDpNYXRoQmFja2VuZFdlYkdMLEdQR1BVQ29udGV4dDpHUEdQVUNvbnRleHR9KSxPcHRpbWl6ZXI9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe3JldHVybiBudWxsIT09ZSYmZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLm1pbmltaXplPWZ1bmN0aW9uKGUsdCxyKXt2b2lkIDA9PT10JiYodD0hMSk7dmFyIG49dGhpcy5jb21wdXRlR3JhZGllbnRzKGUsciksbz1uLnZhbHVlLGE9bi5ncmFkcztyZXR1cm4gdGhpcy5hcHBseUdyYWRpZW50cyhhKSxPYmplY3Qua2V5cyhhKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiBhW2VdLmRpc3Bvc2UoKX0pLHQ/bzooby5kaXNwb3NlKCksbnVsbCl9LHQucHJvdG90eXBlLmNvbXB1dGVHcmFkaWVudHM9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdmFyaWFibGVHcmFkcyhlLHQpfSx0fShTZXJpYWxpemFibGUpLEFkYWRlbHRhT3B0aW1pemVyPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCxyLG4pe3ZvaWQgMD09PW4mJihuPW51bGwpO3ZhciBvPWUuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gby5sZWFybmluZ1JhdGU9dCxvLnJobz1yLG8uZXBzaWxvbj1uLG8uYWNjdW11bGF0ZWRHcmFkcz17fSxvLmFjY3VtdWxhdGVkVXBkYXRlcz17fSxvLmM9a2VlcChzY2FsYXIoLXQpKSxvLnJob1NjYWxhcj1rZWVwKHNjYWxhcihyKSksby5vbmVNaW51c1Jobz1rZWVwKHNjYWxhcigxLXIpKSxudWxsPT09biYmKG49RU5WLmdldChcIkVQU0lMT05cIikpLG8uZXBzaWxvblNjYWxhcj1rZWVwKHNjYWxhcihuKSksb31yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuYXBwbHlHcmFkaWVudHM9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcyxyPWZ1bmN0aW9uKHIpe3ZhciBvPUVOVi5lbmdpbmUucmVnaXN0ZXJlZFZhcmlhYmxlc1tyXTtpZihudWxsPT1uLmFjY3VtdWxhdGVkR3JhZHNbcl0pe3RpZHkoZnVuY3Rpb24oKXt0LmFjY3VtdWxhdGVkR3JhZHNbcl09emVyb3NMaWtlKG8pLnZhcmlhYmxlKCExKX0pfWlmKG51bGw9PW4uYWNjdW11bGF0ZWRVcGRhdGVzW3JdKXt0aWR5KGZ1bmN0aW9uKCl7dC5hY2N1bXVsYXRlZFVwZGF0ZXNbcl09emVyb3NMaWtlKG8pLnZhcmlhYmxlKCExKX0pfXZhciBhPWVbcl0saT1uLmFjY3VtdWxhdGVkR3JhZHNbcl0scz1uLmFjY3VtdWxhdGVkVXBkYXRlc1tyXTt0aWR5KGZ1bmN0aW9uKCl7dmFyIGU9dC5yaG9TY2FsYXIubXVsKGkpLmFkZCh0Lm9uZU1pbnVzUmhvLm11bChhLnNxdWFyZSgpKSksbj1zLmFkZCh0LmVwc2lsb25TY2FsYXIpLnNxcnQoKS5kaXYoaS5hZGQodC5lcHNpbG9uU2NhbGFyKS5zcXJ0KCkpLm11bChhKSx1PXQucmhvU2NhbGFyLm11bChzKS5hZGQodC5vbmVNaW51c1Joby5tdWwobi5zcXVhcmUoKSkpO3QuYWNjdW11bGF0ZWRHcmFkc1tyXS5hc3NpZ24oZSksdC5hY2N1bXVsYXRlZFVwZGF0ZXNbcl0uYXNzaWduKHUpO3ZhciBsPXQuYy5tdWwobikuYWRkKG8pO28uYXNzaWduKGwpfSl9LG49dGhpcztmb3IodmFyIG8gaW4gZSlyKG8pfSx0LnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7dmFyIGU9dGhpczt0aGlzLmMuZGlzcG9zZSgpLHRoaXMuZXBzaWxvblNjYWxhci5kaXNwb3NlKCksdGhpcy5yaG9TY2FsYXIuZGlzcG9zZSgpLHRoaXMub25lTWludXNSaG8uZGlzcG9zZSgpLG51bGwhPXRoaXMuYWNjdW11bGF0ZWRVcGRhdGVzJiYoT2JqZWN0LmtleXModGhpcy5hY2N1bXVsYXRlZFVwZGF0ZXMpLmZvckVhY2goZnVuY3Rpb24odCl7cmV0dXJuIGUuYWNjdW11bGF0ZWRVcGRhdGVzW3RdLmRpc3Bvc2UoKX0pLE9iamVjdC5rZXlzKHRoaXMuYWNjdW11bGF0ZWRHcmFkcykuZm9yRWFjaChmdW5jdGlvbih0KXtyZXR1cm4gZS5hY2N1bXVsYXRlZEdyYWRzW3RdLmRpc3Bvc2UoKX0pKX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7cmV0dXJue2xlYXJuaW5nUmF0ZTp0aGlzLmxlYXJuaW5nUmF0ZSxyaG86dGhpcy5yaG8sZXBzaWxvbjp0aGlzLmVwc2lsb259fSx0LmZyb21Db25maWc9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gbmV3IGUodC5sZWFybmluZ1JhdGUsdC5yaG8sdC5lcHNpbG9uKX0sdC5jbGFzc05hbWU9XCJBZGFkZWx0YU9wdGltaXplclwiLHR9KE9wdGltaXplcik7cmVnaXN0ZXJDbGFzcyhBZGFkZWx0YU9wdGltaXplcik7dmFyIEFkYWdyYWRPcHRpbWl6ZXI9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0LHIpe3ZvaWQgMD09PXImJihyPS4xKTt2YXIgbj1lLmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIG4ubGVhcm5pbmdSYXRlPXQsbi5pbml0aWFsQWNjdW11bGF0b3JWYWx1ZT1yLG4uYWNjdW11bGF0ZWRHcmFkcz17fSxuLmM9a2VlcChzY2FsYXIoLXQpKSxuLmVwc2lsb249a2VlcChzY2FsYXIoRU5WLmdldChcIkVQU0lMT05cIikpKSxufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5hcHBseUdyYWRpZW50cz1mdW5jdGlvbihlKXt2YXIgdD10aGlzLHI9ZnVuY3Rpb24ocil7dmFyIG89RU5WLmVuZ2luZS5yZWdpc3RlcmVkVmFyaWFibGVzW3JdO2lmKG51bGw9PW4uYWNjdW11bGF0ZWRHcmFkc1tyXSl7dGlkeShmdW5jdGlvbigpe3QuYWNjdW11bGF0ZWRHcmFkc1tyXT1maWxsKG8uc2hhcGUsdC5pbml0aWFsQWNjdW11bGF0b3JWYWx1ZSkudmFyaWFibGUoITEpfSl9dmFyIGE9ZVtyXSxpPW4uYWNjdW11bGF0ZWRHcmFkc1tyXTt0aWR5KGZ1bmN0aW9uKCl7dmFyIGU9aS5hZGQoYS5zcXVhcmUoKSk7dC5hY2N1bXVsYXRlZEdyYWRzW3JdLmFzc2lnbihlKTt2YXIgbj10LmMubXVsKGEuZGl2KGUuYWRkKHQuZXBzaWxvbikuc3FydCgpKSkuYWRkKG8pO28uYXNzaWduKG4pfSl9LG49dGhpcztmb3IodmFyIG8gaW4gZSlyKG8pfSx0LnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7dmFyIGU9dGhpczt0aGlzLmVwc2lsb24uZGlzcG9zZSgpLHRoaXMuYy5kaXNwb3NlKCksbnVsbCE9dGhpcy5hY2N1bXVsYXRlZEdyYWRzJiZPYmplY3Qua2V5cyh0aGlzLmFjY3VtdWxhdGVkR3JhZHMpLmZvckVhY2goZnVuY3Rpb24odCl7cmV0dXJuIGUuYWNjdW11bGF0ZWRHcmFkc1t0XS5kaXNwb3NlKCl9KX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7cmV0dXJue2xlYXJuaW5nUmF0ZTp0aGlzLmxlYXJuaW5nUmF0ZSxpbml0aWFsQWNjdW11bGF0b3JWYWx1ZTp0aGlzLmluaXRpYWxBY2N1bXVsYXRvclZhbHVlfX0sdC5mcm9tQ29uZmlnPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIG5ldyBlKHQubGVhcm5pbmdSYXRlLHQuaW5pdGlhbEFjY3VtdWxhdG9yVmFsdWUpfSx0LmNsYXNzTmFtZT1cIkFkYWdyYWRPcHRpbWl6ZXJcIix0fShPcHRpbWl6ZXIpO3JlZ2lzdGVyQ2xhc3MoQWRhZ3JhZE9wdGltaXplcik7dmFyIEFkYW1PcHRpbWl6ZXI9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0LHIsbixvKXt2b2lkIDA9PT1vJiYobz1udWxsKTt2YXIgYT1lLmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIGEubGVhcm5pbmdSYXRlPXQsYS5iZXRhMT1yLGEuYmV0YTI9bixhLmVwc2lsb249byxhLmFjY3VtdWxhdGVkRmlyc3RNb21lbnQ9e30sYS5hY2N1bXVsYXRlZFNlY29uZE1vbWVudD17fSxhLmM9a2VlcChzY2FsYXIoLXQpKSxhLmJldGExU2NhbGFyPWtlZXAoc2NhbGFyKHIpKSxhLmJldGEyU2NhbGFyPWtlZXAoc2NhbGFyKG4pKSx0aWR5KGZ1bmN0aW9uKCl7YS5hY2NCZXRhMT1zY2FsYXIocikudmFyaWFibGUoKSxhLmFjY0JldGEyPXNjYWxhcihuKS52YXJpYWJsZSgpfSksYS5vbmVNaW51c0JldGExPWtlZXAoc2NhbGFyKDEtcikpLGEub25lTWludXNCZXRhMj1rZWVwKHNjYWxhcigxLW4pKSxhLm9uZT1rZWVwKHNjYWxhcigxKSksbnVsbD09PW8mJihvPUVOVi5nZXQoXCJFUFNJTE9OXCIpKSxhLmVwc1NjYWxhcj1rZWVwKHNjYWxhcihvKSksYX1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuYXBwbHlHcmFkaWVudHM9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpczt0aWR5KGZ1bmN0aW9uKCl7dmFyIHI9dC5vbmUuc3ViKHQuYWNjQmV0YTEpLG49dC5vbmUuc3ViKHQuYWNjQmV0YTIpO2Zvcih2YXIgbyBpbiBlKXt2YXIgYT1FTlYuZW5naW5lLnJlZ2lzdGVyZWRWYXJpYWJsZXNbb107aWYobnVsbD09dC5hY2N1bXVsYXRlZEZpcnN0TW9tZW50W29dKXt2YXIgaT0hMTt0LmFjY3VtdWxhdGVkRmlyc3RNb21lbnRbb109emVyb3NMaWtlKGEpLnZhcmlhYmxlKGkpfWlmKG51bGw9PXQuYWNjdW11bGF0ZWRTZWNvbmRNb21lbnRbb10pe2k9ITE7dC5hY2N1bXVsYXRlZFNlY29uZE1vbWVudFtvXT16ZXJvc0xpa2UoYSkudmFyaWFibGUoaSl9dmFyIHM9ZVtvXSx1PXQuYWNjdW11bGF0ZWRGaXJzdE1vbWVudFtvXSxsPXQuYWNjdW11bGF0ZWRTZWNvbmRNb21lbnRbb10sYz10LmJldGExU2NhbGFyLm11bCh1KS5hZGQodC5vbmVNaW51c0JldGExLm11bChzKSkscD10LmJldGEyU2NhbGFyLm11bChsKS5hZGQodC5vbmVNaW51c0JldGEyLm11bChzLnNxdWFyZSgpKSksZD1jLmRpdihyKSxoPXAuZGl2KG4pO3QuYWNjdW11bGF0ZWRGaXJzdE1vbWVudFtvXS5hc3NpZ24oYyksdC5hY2N1bXVsYXRlZFNlY29uZE1vbWVudFtvXS5hc3NpZ24ocCk7dmFyIGY9dC5jLm11bChkLmRpdih0LmVwc1NjYWxhci5hZGQoaC5zcXJ0KCkpKSkuYWRkKGEpO2EuYXNzaWduKGYpfXQuYWNjQmV0YTEuYXNzaWduKHQuYWNjQmV0YTEubXVsKHQuYmV0YTFTY2FsYXIpKSx0LmFjY0JldGEyLmFzc2lnbih0LmFjY0JldGEyLm11bCh0LmJldGEyU2NhbGFyKSl9KX0sdC5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe3ZhciBlPXRoaXM7dGhpcy5jLmRpc3Bvc2UoKSx0aGlzLmVwc1NjYWxhci5kaXNwb3NlKCksdGhpcy5iZXRhMVNjYWxhci5kaXNwb3NlKCksdGhpcy5iZXRhMlNjYWxhci5kaXNwb3NlKCksdGhpcy5hY2NCZXRhMS5kaXNwb3NlKCksdGhpcy5hY2NCZXRhMi5kaXNwb3NlKCksdGhpcy5vbmVNaW51c0JldGExLmRpc3Bvc2UoKSx0aGlzLm9uZU1pbnVzQmV0YTIuZGlzcG9zZSgpLHRoaXMub25lLmRpc3Bvc2UoKSxudWxsIT10aGlzLmFjY3VtdWxhdGVkRmlyc3RNb21lbnQmJk9iamVjdC5rZXlzKHRoaXMuYWNjdW11bGF0ZWRGaXJzdE1vbWVudCkuZm9yRWFjaChmdW5jdGlvbih0KXtyZXR1cm4gZS5hY2N1bXVsYXRlZEZpcnN0TW9tZW50W3RdLmRpc3Bvc2UoKX0pLG51bGwhPXRoaXMuYWNjdW11bGF0ZWRTZWNvbmRNb21lbnQmJk9iamVjdC5rZXlzKHRoaXMuYWNjdW11bGF0ZWRTZWNvbmRNb21lbnQpLmZvckVhY2goZnVuY3Rpb24odCl7cmV0dXJuIGUuYWNjdW11bGF0ZWRTZWNvbmRNb21lbnRbdF0uZGlzcG9zZSgpfSl9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3JldHVybntsZWFybmluZ1JhdGU6dGhpcy5sZWFybmluZ1JhdGUsYmV0YTE6dGhpcy5iZXRhMSxiZXRhMjp0aGlzLmJldGEyLGVwc2lsb246dGhpcy5lcHNpbG9ufX0sdC5mcm9tQ29uZmlnPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIG5ldyBlKHQubGVhcm5pbmdSYXRlLHQuYmV0YTEsdC5iZXRhMix0LmVwc2lsb24pfSx0LmNsYXNzTmFtZT1cIkFkYW1PcHRpbWl6ZXJcIix0fShPcHRpbWl6ZXIpO3JlZ2lzdGVyQ2xhc3MoQWRhbU9wdGltaXplcik7dmFyIEFkYW1heE9wdGltaXplcj1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQscixuLG8sYSl7dm9pZCAwPT09byYmKG89bnVsbCksdm9pZCAwPT09YSYmKGE9MCk7dmFyIGk9ZS5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiBpLmxlYXJuaW5nUmF0ZT10LGkuYmV0YTE9cixpLmJldGEyPW4saS5lcHNpbG9uPW8saS5kZWNheT1hLGkuYWNjdW11bGF0ZWRGaXJzdE1vbWVudD17fSxpLmFjY3VtdWxhdGVkV2VpZ2h0ZWRJbmZOb3JtPXt9LGkuYz1rZWVwKHNjYWxhcigtdCkpLGkuYmV0YTFTY2FsYXI9a2VlcChzY2FsYXIocikpLGkuYmV0YTJTY2FsYXI9a2VlcChzY2FsYXIobikpLGkuZGVjYXlTY2FsYXI9a2VlcChzY2FsYXIoYSkpLHRpZHkoZnVuY3Rpb24oKXtpLml0ZXJhdGlvbj1zY2FsYXIoMCkudmFyaWFibGUoKSxpLmFjY0JldGExPXNjYWxhcihyKS52YXJpYWJsZSgpfSksaS5vbmVNaW51c0JldGExPWtlZXAoc2NhbGFyKDEtcikpLGkub25lPWtlZXAoc2NhbGFyKDEpKSxudWxsPT09byYmKG89RU5WLmdldChcIkVQU0lMT05cIikpLGkuZXBzU2NhbGFyPWtlZXAoc2NhbGFyKG8pKSxpfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5hcHBseUdyYWRpZW50cz1mdW5jdGlvbihlKXt2YXIgdD10aGlzO3RpZHkoZnVuY3Rpb24oKXt2YXIgcj10Lm9uZS5zdWIodC5hY2NCZXRhMSksbj10LmMuZGl2KHQub25lLmFkZCh0LmRlY2F5U2NhbGFyLm11bCh0Lml0ZXJhdGlvbikpKTtmb3IodmFyIG8gaW4gZSl7dmFyIGE9RU5WLmVuZ2luZS5yZWdpc3RlcmVkVmFyaWFibGVzW29dO2lmKG51bGw9PXQuYWNjdW11bGF0ZWRGaXJzdE1vbWVudFtvXSl7dmFyIGk9ITE7dC5hY2N1bXVsYXRlZEZpcnN0TW9tZW50W29dPXplcm9zTGlrZShhKS52YXJpYWJsZShpKX1pZihudWxsPT10LmFjY3VtdWxhdGVkV2VpZ2h0ZWRJbmZOb3JtW29dKXtpPSExO3QuYWNjdW11bGF0ZWRXZWlnaHRlZEluZk5vcm1bb109emVyb3NMaWtlKGEpLnZhcmlhYmxlKGkpfXZhciBzPWVbb10sdT10LmFjY3VtdWxhdGVkRmlyc3RNb21lbnRbb10sbD10LmFjY3VtdWxhdGVkV2VpZ2h0ZWRJbmZOb3JtW29dLGM9dC5iZXRhMVNjYWxhci5tdWwodSkuYWRkKHQub25lTWludXNCZXRhMS5tdWwocykpLHA9dC5iZXRhMlNjYWxhci5tdWwobCksZD1zLmFicygpLGg9cC5tYXhpbXVtKGQpO3QuYWNjdW11bGF0ZWRGaXJzdE1vbWVudFtvXS5hc3NpZ24oYyksdC5hY2N1bXVsYXRlZFdlaWdodGVkSW5mTm9ybVtvXS5hc3NpZ24oaCk7dmFyIGY9bi5kaXYocikubXVsKGMuZGl2KHQuZXBzU2NhbGFyLmFkZChoKSkpLmFkZChhKTthLmFzc2lnbihmKX10Lml0ZXJhdGlvbi5hc3NpZ24odC5pdGVyYXRpb24uYWRkKHQub25lKSksdC5hY2NCZXRhMS5hc3NpZ24odC5hY2NCZXRhMS5tdWwodC5iZXRhMVNjYWxhcikpfSl9LHQucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3RoaXMuYy5kaXNwb3NlKCksdGhpcy5lcHNTY2FsYXIuZGlzcG9zZSgpLHRoaXMuYWNjQmV0YTEuZGlzcG9zZSgpLHRoaXMuYmV0YTFTY2FsYXIuZGlzcG9zZSgpLHRoaXMuYmV0YTJTY2FsYXIuZGlzcG9zZSgpLHRoaXMub25lTWludXNCZXRhMS5kaXNwb3NlKCksdGhpcy5kZWNheVNjYWxhci5kaXNwb3NlKCksdGhpcy5pdGVyYXRpb24uZGlzcG9zZSgpLHRoaXMub25lLmRpc3Bvc2UoKSxudWxsIT10aGlzLmFjY3VtdWxhdGVkRmlyc3RNb21lbnQmJk9iamVjdC5rZXlzKHRoaXMuYWNjdW11bGF0ZWRGaXJzdE1vbWVudCkuZm9yRWFjaChmdW5jdGlvbih0KXtyZXR1cm4gZS5hY2N1bXVsYXRlZEZpcnN0TW9tZW50W3RdLmRpc3Bvc2UoKX0pLG51bGwhPXRoaXMuYWNjdW11bGF0ZWRXZWlnaHRlZEluZk5vcm0mJk9iamVjdC5rZXlzKHRoaXMuYWNjdW11bGF0ZWRXZWlnaHRlZEluZk5vcm0pLmZvckVhY2goZnVuY3Rpb24odCl7cmV0dXJuIGUuYWNjdW11bGF0ZWRXZWlnaHRlZEluZk5vcm1bdF0uZGlzcG9zZSgpfSl9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3JldHVybntsZWFybmluZ1JhdGU6dGhpcy5sZWFybmluZ1JhdGUsYmV0YTE6dGhpcy5iZXRhMSxiZXRhMjp0aGlzLmJldGEyLGVwc2lsb246dGhpcy5lcHNpbG9uLGRlY2F5OnRoaXMuZGVjYXl9fSx0LmZyb21Db25maWc9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gbmV3IGUodC5sZWFybmluZ1JhdGUsdC5iZXRhMSx0LmJldGEyLHQuZXBzaWxvbix0LmRlY2F5KX0sdC5jbGFzc05hbWU9XCJBZGFtYXhPcHRpbWl6ZXJcIix0fShPcHRpbWl6ZXIpO3JlZ2lzdGVyQ2xhc3MoQWRhbWF4T3B0aW1pemVyKTt2YXIgU0dET3B0aW1pemVyPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIHI9ZS5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiByLmxlYXJuaW5nUmF0ZT10LHIuc2V0TGVhcm5pbmdSYXRlKHQpLHJ9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmFwcGx5R3JhZGllbnRzPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7T2JqZWN0LmtleXMoZSkuZm9yRWFjaChmdW5jdGlvbihyKXt2YXIgbj1lW3JdLG89RU5WLmVuZ2luZS5yZWdpc3RlcmVkVmFyaWFibGVzW3JdO3RpZHkoZnVuY3Rpb24oKXt2YXIgZT10LmMubXVsKG4pLmFkZChvKTtvLmFzc2lnbihlKX0pfSl9LHQucHJvdG90eXBlLnNldExlYXJuaW5nUmF0ZT1mdW5jdGlvbihlKXt0aGlzLmxlYXJuaW5nUmF0ZT1lLG51bGwhPXRoaXMuYyYmdGhpcy5jLmRpc3Bvc2UoKSx0aGlzLmM9a2VlcChzY2FsYXIoLWUpKX0sdC5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe3RoaXMuYy5kaXNwb3NlKCl9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3JldHVybntsZWFybmluZ1JhdGU6dGhpcy5sZWFybmluZ1JhdGV9fSx0LmZyb21Db25maWc9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gbmV3IGUodC5sZWFybmluZ1JhdGUpfSx0LmNsYXNzTmFtZT1cIlNHRE9wdGltaXplclwiLHR9KE9wdGltaXplcik7cmVnaXN0ZXJDbGFzcyhTR0RPcHRpbWl6ZXIpO3ZhciBNb21lbnR1bU9wdGltaXplcj1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQscixuKXt2b2lkIDA9PT1uJiYobj0hMSk7dmFyIG89ZS5jYWxsKHRoaXMsdCl8fHRoaXM7cmV0dXJuIG8ubGVhcm5pbmdSYXRlPXQsby5tb21lbnR1bT1yLG8udXNlTmVzdGVyb3Y9bixvLm09c2NhbGFyKG8ubW9tZW50dW0pLG8uYWNjdW11bGF0aW9ucz17fSxvfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5hcHBseUdyYWRpZW50cz1mdW5jdGlvbihlKXt2YXIgdD10aGlzLHI9ZnVuY3Rpb24ocil7dmFyIG89RU5WLmVuZ2luZS5yZWdpc3RlcmVkVmFyaWFibGVzW3JdO2lmKG51bGw9PW4uYWNjdW11bGF0aW9uc1tyXSl7dGlkeShmdW5jdGlvbigpe3QuYWNjdW11bGF0aW9uc1tyXT16ZXJvc0xpa2UobykudmFyaWFibGUoITEpfSl9dmFyIGE9bi5hY2N1bXVsYXRpb25zW3JdLGk9ZVtyXTt0aWR5KGZ1bmN0aW9uKCl7dmFyIGUsbj10Lm0ubXVsKGEpLmFkZChpKTtlPXQudXNlTmVzdGVyb3Y/dC5jLm11bChpLmFkZChuLm11bCh0Lm0pKSkuYWRkKG8pOnQuYy5tdWwobikuYWRkKG8pLHQuYWNjdW11bGF0aW9uc1tyXS5hc3NpZ24obiksby5hc3NpZ24oZSl9KX0sbj10aGlzO2Zvcih2YXIgbyBpbiBlKXIobyl9LHQucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXtpZihlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyksdGhpcy5tLmRpc3Bvc2UoKSxudWxsIT10aGlzLmFjY3VtdWxhdGlvbnMpZm9yKHZhciB0IGluIHRoaXMuYWNjdW11bGF0aW9ucyl0aGlzLmFjY3VtdWxhdGlvbnNbdF0uZGlzcG9zZSgpfSx0LnByb3RvdHlwZS5zZXRNb21lbnR1bT1mdW5jdGlvbihlKXt0aGlzLm1vbWVudHVtPWV9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3JldHVybntsZWFybmluZ1JhdGU6dGhpcy5sZWFybmluZ1JhdGUsbW9tZW50dW06dGhpcy5tb21lbnR1bSx1c2VOZXN0ZXJvdjp0aGlzLnVzZU5lc3Rlcm92fX0sdC5mcm9tQ29uZmlnPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIG5ldyBlKHQubGVhcm5pbmdSYXRlLHQubW9tZW50dW0sdC51c2VOZXN0ZXJvdil9LHQuY2xhc3NOYW1lPVwiTW9tZW50dW1PcHRpbWl6ZXJcIix0fShTR0RPcHRpbWl6ZXIpO3JlZ2lzdGVyQ2xhc3MoTW9tZW50dW1PcHRpbWl6ZXIpO3ZhciBSTVNQcm9wT3B0aW1pemVyPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCxyLG4sbyxhKXt2b2lkIDA9PT1yJiYocj0uOSksdm9pZCAwPT09biYmKG49MCksdm9pZCAwPT09byYmKG89bnVsbCksdm9pZCAwPT09YSYmKGE9ITEpO3ZhciBpPWUuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gaS5sZWFybmluZ1JhdGU9dCxpLmRlY2F5PXIsaS5tb21lbnR1bT1uLGkuZXBzaWxvbj1vLGkuYWNjdW11bGF0ZWRNZWFuU3F1YXJlcz17fSxpLmFjY3VtdWxhdGVkTWVhbkdyYWRzPXt9LGkuYWNjdW11bGF0ZWRNb21lbnRzPXt9LGkuYz1rZWVwKHNjYWxhcih0KSksaS5kZWNheVNjYWxhcj1rZWVwKHNjYWxhcihyKSksaS5tb21lbnR1bVNjYWxhcj1rZWVwKHNjYWxhcihuKSksaS5vbmVNaW51c0RlY2F5PWtlZXAoc2NhbGFyKDEtcikpLGkuY2VudGVyZWQ9YSxudWxsPT09byYmKG89RU5WLmdldChcIkVQU0lMT05cIikpLGkuZXBzaWxvblNjYWxhcj1rZWVwKHNjYWxhcihvKSksaX1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuYXBwbHlHcmFkaWVudHM9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcyxyPWZ1bmN0aW9uKHIpe3ZhciBvPUVOVi5lbmdpbmUucmVnaXN0ZXJlZFZhcmlhYmxlc1tyXTtpZihudWxsPT1uLmFjY3VtdWxhdGVkTWVhblNxdWFyZXNbcl0pe3RpZHkoZnVuY3Rpb24oKXt0LmFjY3VtdWxhdGVkTWVhblNxdWFyZXNbcl09emVyb3NMaWtlKG8pLnZhcmlhYmxlKCExKX0pfWlmKG51bGw9PW4uYWNjdW11bGF0ZWRNZWFuR3JhZHNbcl0mJm4uY2VudGVyZWQpe3RpZHkoZnVuY3Rpb24oKXt0LmFjY3VtdWxhdGVkTWVhbkdyYWRzW3JdPXplcm9zTGlrZShvKS52YXJpYWJsZSghMSl9KX1pZihudWxsPT1uLmFjY3VtdWxhdGVkTW9tZW50c1tyXSl7dGlkeShmdW5jdGlvbigpe3QuYWNjdW11bGF0ZWRNb21lbnRzW3JdPXplcm9zTGlrZShvKS52YXJpYWJsZSghMSl9KX12YXIgYT1uLmFjY3VtdWxhdGVkTWVhblNxdWFyZXNbcl0saT1uLmFjY3VtdWxhdGVkTWVhbkdyYWRzW3JdLHM9bi5hY2N1bXVsYXRlZE1vbWVudHNbcl0sdT1lW3JdO3RpZHkoZnVuY3Rpb24oKXt2YXIgZT10LmRlY2F5U2NhbGFyLm11bChhKS5hZGQodC5vbmVNaW51c0RlY2F5Lm11bCh1LnNxdWFyZSgpKSk7aWYodC5jZW50ZXJlZCl7dmFyIG49dC5kZWNheVNjYWxhci5tdWwoaSkuYWRkKHQub25lTWludXNEZWNheS5tdWwodSkpLGw9dC5tb21lbnR1bVNjYWxhci5tdWwocykuYWRkKHQuYy5tdWwodSkuZGl2KGUuc3ViKG4uc3F1YXJlKCkuYWRkKHQuZXBzaWxvblNjYWxhcikpLnNxcnQoKSkpO3QuYWNjdW11bGF0ZWRNZWFuU3F1YXJlc1tyXS5hc3NpZ24oZSksdC5hY2N1bXVsYXRlZE1lYW5HcmFkc1tyXS5hc3NpZ24obiksdC5hY2N1bXVsYXRlZE1vbWVudHNbcl0uYXNzaWduKGwpO3ZhciBjPW8uc3ViKGwpO28uYXNzaWduKGMpfWVsc2V7dmFyIHA9dC5kZWNheVNjYWxhci5tdWwoYSkuYWRkKHQub25lTWludXNEZWNheS5tdWwodS5zcXVhcmUoKSkpO2w9dC5tb21lbnR1bVNjYWxhci5tdWwocykuYWRkKHQuYy5tdWwodSkuZGl2KHAuYWRkKHQuZXBzaWxvblNjYWxhcikuc3FydCgpKSk7dC5hY2N1bXVsYXRlZE1lYW5TcXVhcmVzW3JdLmFzc2lnbihwKSx0LmFjY3VtdWxhdGVkTW9tZW50c1tyXS5hc3NpZ24obCk7Yz1vLnN1YihsKTtvLmFzc2lnbihjKX19KX0sbj10aGlzO2Zvcih2YXIgbyBpbiBlKXIobyl9LHQucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3RoaXMuYy5kaXNwb3NlKCksdGhpcy5lcHNpbG9uU2NhbGFyLmRpc3Bvc2UoKSx0aGlzLmRlY2F5U2NhbGFyLmRpc3Bvc2UoKSx0aGlzLm1vbWVudHVtU2NhbGFyLmRpc3Bvc2UoKSx0aGlzLm9uZU1pbnVzRGVjYXkuZGlzcG9zZSgpLG51bGwhPXRoaXMuYWNjdW11bGF0ZWRNZWFuU3F1YXJlcyYmT2JqZWN0LmtleXModGhpcy5hY2N1bXVsYXRlZE1lYW5TcXVhcmVzKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3JldHVybiBlLmFjY3VtdWxhdGVkTWVhblNxdWFyZXNbdF0uZGlzcG9zZSgpfSksbnVsbCE9dGhpcy5hY2N1bXVsYXRlZE1lYW5HcmFkcyYmdGhpcy5jZW50ZXJlZCYmT2JqZWN0LmtleXModGhpcy5hY2N1bXVsYXRlZE1lYW5HcmFkcykuZm9yRWFjaChmdW5jdGlvbih0KXtyZXR1cm4gZS5hY2N1bXVsYXRlZE1lYW5HcmFkc1t0XS5kaXNwb3NlKCl9KSxudWxsIT10aGlzLmFjY3VtdWxhdGVkTW9tZW50cyYmT2JqZWN0LmtleXModGhpcy5hY2N1bXVsYXRlZE1vbWVudHMpLmZvckVhY2goZnVuY3Rpb24odCl7cmV0dXJuIGUuYWNjdW11bGF0ZWRNb21lbnRzW3RdLmRpc3Bvc2UoKX0pfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXtyZXR1cm57bGVhcm5pbmdSYXRlOnRoaXMubGVhcm5pbmdSYXRlLGRlY2F5OnRoaXMuZGVjYXksbW9tZW50dW06dGhpcy5tb21lbnR1bSxlcHNpbG9uOnRoaXMuZXBzaWxvbixjZW50ZXJlZDp0aGlzLmNlbnRlcmVkfX0sdC5mcm9tQ29uZmlnPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIG5ldyBlKHQubGVhcm5pbmdSYXRlLHQuZGVjYXksdC5tb21lbnR1bSx0LmVwc2lsb24sdC5jZW50ZXJlZCl9LHQuY2xhc3NOYW1lPVwiUk1TUHJvcE9wdGltaXplclwiLHR9KE9wdGltaXplcik7cmVnaXN0ZXJDbGFzcyhSTVNQcm9wT3B0aW1pemVyKTt2YXIgT3B0aW1pemVyQ29uc3RydWN0b3JzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpe31yZXR1cm4gZS5zZ2Q9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBTR0RPcHRpbWl6ZXIoZSl9LGUubW9tZW50dW09ZnVuY3Rpb24oZSx0LHIpe3JldHVybiB2b2lkIDA9PT1yJiYocj0hMSksbmV3IE1vbWVudHVtT3B0aW1pemVyKGUsdCxyKX0sZS5ybXNwcm9wPWZ1bmN0aW9uKGUsdCxyLG4sbyl7cmV0dXJuIHZvaWQgMD09PXQmJih0PS45KSx2b2lkIDA9PT1yJiYocj0wKSx2b2lkIDA9PT1uJiYobj1udWxsKSx2b2lkIDA9PT1vJiYobz0hMSksbmV3IFJNU1Byb3BPcHRpbWl6ZXIoZSx0LHIsbixvKX0sZS5hZGFtPWZ1bmN0aW9uKGUsdCxyLG4pe3JldHVybiB2b2lkIDA9PT1lJiYoZT0uMDAxKSx2b2lkIDA9PT10JiYodD0uOSksdm9pZCAwPT09ciYmKHI9Ljk5OSksdm9pZCAwPT09biYmKG49bnVsbCksbmV3IEFkYW1PcHRpbWl6ZXIoZSx0LHIsbil9LGUuYWRhZGVsdGE9ZnVuY3Rpb24oZSx0LHIpe3JldHVybiB2b2lkIDA9PT1lJiYoZT0uMDAxKSx2b2lkIDA9PT10JiYodD0uOTUpLHZvaWQgMD09PXImJihyPW51bGwpLG5ldyBBZGFkZWx0YU9wdGltaXplcihlLHQscil9LGUuYWRhbWF4PWZ1bmN0aW9uKGUsdCxyLG4sbyl7cmV0dXJuIHZvaWQgMD09PWUmJihlPS4wMDIpLHZvaWQgMD09PXQmJih0PS45KSx2b2lkIDA9PT1yJiYocj0uOTk5KSx2b2lkIDA9PT1uJiYobj1udWxsKSx2b2lkIDA9PT1vJiYobz0wKSxuZXcgQWRhbWF4T3B0aW1pemVyKGUsdCxyLG4sbyl9LGUuYWRhZ3JhZD1mdW5jdGlvbihlLHQpe3JldHVybiB2b2lkIDA9PT10JiYodD0uMSksbmV3IEFkYWdyYWRPcHRpbWl6ZXIoZSx0KX0sZX0oKSx0cmFpbj17c2dkOk9wdGltaXplckNvbnN0cnVjdG9ycy5zZ2QsbW9tZW50dW06T3B0aW1pemVyQ29uc3RydWN0b3JzLm1vbWVudHVtLGFkYWRlbHRhOk9wdGltaXplckNvbnN0cnVjdG9ycy5hZGFkZWx0YSxhZGFncmFkOk9wdGltaXplckNvbnN0cnVjdG9ycy5hZGFncmFkLHJtc3Byb3A6T3B0aW1pemVyQ29uc3RydWN0b3JzLnJtc3Byb3AsYWRhbWF4Ok9wdGltaXplckNvbnN0cnVjdG9ycy5hZGFtYXgsYWRhbTpPcHRpbWl6ZXJDb25zdHJ1Y3RvcnMuYWRhbX0sc2V0QmFja2VuZD1FbnZpcm9ubWVudC5zZXRCYWNrZW5kLGdldEJhY2tlbmQ9RW52aXJvbm1lbnQuZ2V0QmFja2VuZCxkaXNwb3NlVmFyaWFibGVzPUVudmlyb25tZW50LmRpc3Bvc2VWYXJpYWJsZXMsbWVtb3J5PUVudmlyb25tZW50Lm1lbW9yeTtzZXRPcEhhbmRsZXIob3BzKTtleHBvcnR7c2V0QmFja2VuZCxnZXRCYWNrZW5kLGRpc3Bvc2VWYXJpYWJsZXMsbWVtb3J5LHZlcnNpb24gYXMgdmVyc2lvbl9jb3JlLG5leHRGcmFtZSxlbnZpcm9ubWVudCxpbyxtYXRoLHNlcmlhbGl6YXRpb24sdGVzdF91dGlsLHV0aWwsd2ViZ2wsQWRhZGVsdGFPcHRpbWl6ZXIsQWRhZ3JhZE9wdGltaXplcixBZGFtT3B0aW1pemVyLEFkYW1heE9wdGltaXplcixNb21lbnR1bU9wdGltaXplcixPcHRpbWl6ZXIsUk1TUHJvcE9wdGltaXplcixTR0RPcHRpbWl6ZXIsVGVuc29yLFRlbnNvckJ1ZmZlcix2YXJpYWJsZSxWYXJpYWJsZSxSYW5rLFJlZHVjdGlvbixFTlYsRW52aXJvbm1lbnQsS2VybmVsQmFja2VuZCxEYXRhU3RvcmFnZSxpbWFnZV9vcHMgYXMgaW1hZ2UsbGluYWxnX29wcyBhcyBsaW5hbGcsbG9zc19vcHMgYXMgbG9zc2VzLHNwZWN0cmFsX29wcyBhcyBzcGVjdHJhbCxvcCxiYXRjaE5vcm1hbGl6YXRpb24yZCxiYXRjaE5vcm1hbGl6YXRpb24zZCxiYXRjaE5vcm1hbGl6YXRpb240ZCxiYXRjaE5vcm1hbGl6YXRpb24sY29tcGxleCxyZWFsLGltYWcsY29uY2F0LGNvbmNhdDFkLGNvbmNhdDJkLGNvbmNhdDNkLGNvbmNhdDRkLHNwbGl0JDEgYXMgc3BsaXQsY29udjFkLGNvbnYyZCxjb252MmREZXJGaWx0ZXIsZGVwdGh3aXNlQ29udjJkLHNlcGFyYWJsZUNvbnYyZCxjb252MmRUcmFuc3Bvc2UsbWF0TXVsLGRvdCxvdXRlclByb2R1Y3QscmV2ZXJzZSxyZXZlcnNlMWQscmV2ZXJzZTJkLHJldmVyc2UzZCxyZXZlcnNlNGQsbWF4UG9vbCxhdmdQb29sLHBvb2wsc2xpY2Usc2xpY2UxZCxzbGljZTJkLHNsaWNlM2Qsc2xpY2U0ZCxhYnMsYWNvcyxhY29zaCxhc2luLGFzaW5oLGF0YW4sYXRhbmgsY2VpbCxjbGlwQnlWYWx1ZSxjb3MsY29zaCxlcmYsZXhwLGV4cG0xLGZsb29yLGxvZyQxIGFzIGxvZyxsb2cxcCxsb2dTaWdtb2lkLG5lZyxyZWNpcHJvY2FsLHJvdW5kLHJzcXJ0LHNpZ21vaWQsc2lnbixzaW4sc2luaCxzb2Z0cGx1cyxzcXJ0LHNxdWFyZSxzdGVwLHRhbix0YW5oJDEgYXMgdGFuaCxhbGwsYW55LGFyZ01heCxhcmdNaW4sbG9nU3VtRXhwLG1heCxtZWFuLG1pbixtb21lbnRzLHN1bSQxIGFzIHN1bSxwcm9kLGVxdWFsLGVxdWFsU3RyaWN0LGdyZWF0ZXIsZ3JlYXRlckVxdWFsLGdyZWF0ZXJFcXVhbFN0cmljdCxncmVhdGVyU3RyaWN0LGxlc3MsbGVzc0VxdWFsLGxlc3NFcXVhbFN0cmljdCxsZXNzU3RyaWN0LG5vdEVxdWFsLG5vdEVxdWFsU3RyaWN0LGFkZCxhZGROLGFkZFN0cmljdCxhdGFuMixkaXYsZGl2U3RyaWN0LGZsb29yRGl2LG1heGltdW0sbWF4aW11bVN0cmljdCxtaW5pbXVtLG1pbmltdW1TdHJpY3QsbW9kLG1vZFN0cmljdCxtdWwsbXVsU3RyaWN0LHBvdyxwb3dTdHJpY3Qsc3F1YXJlZERpZmZlcmVuY2Usc3F1YXJlZERpZmZlcmVuY2VTdHJpY3Qsc3ViLHN1YlN0cmljdCxlbHUsbGVha3lSZWx1LHByZWx1LHJlbHUsc2VsdSxsb2dpY2FsQW5kLGxvZ2ljYWxOb3QsbG9naWNhbE9yLGxvZ2ljYWxYb3Isd2hlcmUsd2hlcmVBc3luYyxidWZmZXIsdG9QaXhlbHMscHJpbnQsYmF0Y2hUb1NwYWNlTkQsY2FzdCxjbG9uZSxjdW1zdW0sZGVwdGhUb1NwYWNlLGV4cGFuZERpbXMsZXllLGZyb21QaXhlbHMsbXVsdGlub21pYWwsb25lSG90LHBhZCxwYWQxZCxwYWQyZCxwYWQzZCxwYWQ0ZCxyYW5kLHJhbmRvbU5vcm1hbCxyYW5kb21Vbmlmb3JtLHJlc2hhcGUsc3BhY2VUb0JhdGNoTkQsc3F1ZWV6ZSxzdGFjayx0aWxlLHRydW5jYXRlZE5vcm1hbCx1bnN0YWNrLHNldGRpZmYxZEFzeW5jLGZpbGwsbGluc3BhY2Usb25lcyQxIGFzIG9uZXMscmFuZ2Usc2NhbGFyLHRlbnNvcix0ZW5zb3IxZCx0ZW5zb3IyZCx0ZW5zb3IzZCx0ZW5zb3I0ZCx0ZW5zb3I1ZCx0ZW5zb3I2ZCx6ZXJvcyxvbmVzTGlrZSx6ZXJvc0xpa2UsdHJhbnNwb3NlLHNvZnRtYXgsbG9nU29mdG1heCxsb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbixub3JtLGdhdGhlcix1bnNvcnRlZFNlZ21lbnRTdW0sYmFzaWNMU1RNQ2VsbCxtdWx0aVJOTkNlbGwsbW92aW5nQXZlcmFnZSxzdHJpZGVkU2xpY2UsdG9wayxzY2F0dGVyTkQsZmZ0LGlmZnQscmZmdCxzcGFyc2VUb0RlbnNlLGdhdGhlck5ELHRyYWluLHRpZHksa2VlcCxkaXNwb3NlLHRpbWUscHJvZmlsZSxjdXN0b21HcmFkLGdyYWQsZ3JhZHMsdmFsdWVBbmRHcmFkLHZhbHVlQW5kR3JhZHMsdmFyaWFibGVHcmFkc307XG4vLyMgc291cmNlTWFwcGluZ1VSTD10Zi1jb3JlLmVzbS5qcy5tYXBcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmltcG9ydHtFTlYsa2VlcCxzY2FsYXIsdGlkeSxvbmVzTGlrZSx0ZW5zb3IxZCx1dGlsLHdoZXJlLHplcm9zTGlrZSx0cmFpbixjYXN0LHNlcmlhbGl6YXRpb24sbmV4dEZyYW1lLGFkZCxtdWwsZGl2LFRlbnNvcixPcHRpbWl6ZXIsbWVhbixpbyx0cmFuc3Bvc2UscmV2ZXJzZSxjb25jYXQsemVyb3MsZGlzcG9zZSxzdW0sc3BsaXQsbmVnLHZhcmlhYmxlLG9uZXMsZXllLHJhbmRvbVVuaWZvcm0sdHJ1bmNhdGVkTm9ybWFsLHJhbmRvbU5vcm1hbCxzdWIsc3FydCxtdWxTdHJpY3QsY2xpcEJ5VmFsdWUscmVsdSxsaW5hbGcsbGVha3lSZWx1LGVsdSxjb252MWQsY29udjJkLGNvbnYyZFRyYW5zcG9zZSxzZXBhcmFibGVDb252MmQsZGVwdGh3aXNlQ29udjJkLG1heGltdW0sbWluaW11bSxiYXRjaE5vcm1hbGl6YXRpb24yZCxiYXRjaE5vcm1hbGl6YXRpb24zZCxiYXRjaE5vcm1hbGl6YXRpb240ZCxtb21lbnRzLG1vdmluZ0F2ZXJhZ2UscGFkLG1heFBvb2wsYXZnUG9vbCxzcXVlZXplLG1heCxhYnMsbG9nLHNvZnRwbHVzLHNvZnRtYXgsZmxvb3Isb25lSG90LGV4cCxncmVhdGVyLGVxdWFsLGFyZ01heCxsb2dpY2FsQW5kLHNsaWNlMWQsc2xpY2UyZCxzbGljZTNkLHNsaWNlNGQsY29uY2F0MWQsY29uY2F0MmQsY29uY2F0M2QsY29uY2F0NGQsdGlsZSxtYXRNdWwsZ2F0aGVyLHN0ZXAsbWluLHNlbHUsc2lnbW9pZCx0YW5ofWZyb21cIkB0ZW5zb3JmbG93L3RmanMtY29yZVwiO3ZhciBleHRlbmRTdGF0aWNzPWZ1bmN0aW9uKGUsdCl7cmV0dXJuKGV4dGVuZFN0YXRpY3M9T2JqZWN0LnNldFByb3RvdHlwZU9mfHx7X19wcm90b19fOltdfWluc3RhbmNlb2YgQXJyYXkmJmZ1bmN0aW9uKGUsdCl7ZS5fX3Byb3RvX189dH18fGZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBuIGluIHQpdC5oYXNPd25Qcm9wZXJ0eShuKSYmKGVbbl09dFtuXSl9KShlLHQpfTtmdW5jdGlvbiBfX2V4dGVuZHMoZSx0KXtmdW5jdGlvbiBuKCl7dGhpcy5jb25zdHJ1Y3Rvcj1lfWV4dGVuZFN0YXRpY3MoZSx0KSxlLnByb3RvdHlwZT1udWxsPT09dD9PYmplY3QuY3JlYXRlKHQpOihuLnByb3RvdHlwZT10LnByb3RvdHlwZSxuZXcgbil9dmFyIF9fYXNzaWduPWZ1bmN0aW9uKCl7cmV0dXJuKF9fYXNzaWduPU9iamVjdC5hc3NpZ258fGZ1bmN0aW9uKGUpe2Zvcih2YXIgdCxuPTEscj1hcmd1bWVudHMubGVuZ3RoO248cjtuKyspZm9yKHZhciBpIGluIHQ9YXJndW1lbnRzW25dKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LGkpJiYoZVtpXT10W2ldKTtyZXR1cm4gZX0pLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07ZnVuY3Rpb24gX19hd2FpdGVyKGUsdCxuLHIpe3JldHVybiBuZXcobnx8KG49UHJvbWlzZSkpKGZ1bmN0aW9uKGksYSl7ZnVuY3Rpb24gbyhlKXt0cnl7bChyLm5leHQoZSkpfWNhdGNoKGUpe2EoZSl9fWZ1bmN0aW9uIHMoZSl7dHJ5e2woci50aHJvdyhlKSl9Y2F0Y2goZSl7YShlKX19ZnVuY3Rpb24gbChlKXtlLmRvbmU/aShlLnZhbHVlKTpuZXcgbihmdW5jdGlvbih0KXt0KGUudmFsdWUpfSkudGhlbihvLHMpfWwoKHI9ci5hcHBseShlLHR8fFtdKSkubmV4dCgpKX0pfWZ1bmN0aW9uIF9fZ2VuZXJhdG9yKGUsdCl7dmFyIG4scixpLGEsbz17bGFiZWw6MCxzZW50OmZ1bmN0aW9uKCl7aWYoMSZpWzBdKXRocm93IGlbMV07cmV0dXJuIGlbMV19LHRyeXM6W10sb3BzOltdfTtyZXR1cm4gYT17bmV4dDpzKDApLHRocm93OnMoMSkscmV0dXJuOnMoMil9LFwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmKGFbU3ltYm9sLml0ZXJhdG9yXT1mdW5jdGlvbigpe3JldHVybiB0aGlzfSksYTtmdW5jdGlvbiBzKGEpe3JldHVybiBmdW5jdGlvbihzKXtyZXR1cm4gZnVuY3Rpb24oYSl7aWYobil0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtmb3IoO287KXRyeXtpZihuPTEsciYmKGk9MiZhWzBdP3IucmV0dXJuOmFbMF0/ci50aHJvd3x8KChpPXIucmV0dXJuKSYmaS5jYWxsKHIpLDApOnIubmV4dCkmJiEoaT1pLmNhbGwocixhWzFdKSkuZG9uZSlyZXR1cm4gaTtzd2l0Y2gocj0wLGkmJihhPVsyJmFbMF0saS52YWx1ZV0pLGFbMF0pe2Nhc2UgMDpjYXNlIDE6aT1hO2JyZWFrO2Nhc2UgNDpyZXR1cm4gby5sYWJlbCsrLHt2YWx1ZTphWzFdLGRvbmU6ITF9O2Nhc2UgNTpvLmxhYmVsKysscj1hWzFdLGE9WzBdO2NvbnRpbnVlO2Nhc2UgNzphPW8ub3BzLnBvcCgpLG8udHJ5cy5wb3AoKTtjb250aW51ZTtkZWZhdWx0OmlmKCEoaT0oaT1vLnRyeXMpLmxlbmd0aD4wJiZpW2kubGVuZ3RoLTFdKSYmKDY9PT1hWzBdfHwyPT09YVswXSkpe289MDtjb250aW51ZX1pZigzPT09YVswXSYmKCFpfHxhWzFdPmlbMF0mJmFbMV08aVszXSkpe28ubGFiZWw9YVsxXTticmVha31pZig2PT09YVswXSYmby5sYWJlbDxpWzFdKXtvLmxhYmVsPWlbMV0saT1hO2JyZWFrfWlmKGkmJm8ubGFiZWw8aVsyXSl7by5sYWJlbD1pWzJdLG8ub3BzLnB1c2goYSk7YnJlYWt9aVsyXSYmby5vcHMucG9wKCksby50cnlzLnBvcCgpO2NvbnRpbnVlfWE9dC5jYWxsKGUsbyl9Y2F0Y2goZSl7YT1bNixlXSxyPTB9ZmluYWxseXtuPWk9MH1pZig1JmFbMF0pdGhyb3cgYVsxXTtyZXR1cm57dmFsdWU6YVswXT9hWzFdOnZvaWQgMCxkb25lOiEwfX0oW2Esc10pfX19dmFyIF9lcHNpbG9uPUVOVi5nZXQoXCJFUFNJTE9OXCIpO2Z1bmN0aW9uIGVwc2lsb24oKXtyZXR1cm4gX2Vwc2lsb259ZnVuY3Rpb24gaW1hZ2VEYXRhRm9ybWF0KCl7cmV0dXJuXCJjaGFubmVsc0xhc3RcIn12YXIgX25leHRVbmlxdWVUZW5zb3JJZD0wO2Z1bmN0aW9uIGdldE5leHRVbmlxdWVUZW5zb3JJZCgpe3JldHVybiBfbmV4dFVuaXF1ZVRlbnNvcklkKyt9dmFyIF91aWRQcmVmaXhlcz17fTtmdW5jdGlvbiBnZXRVaWQoZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPVwiXCIpLGUgaW4gX3VpZFByZWZpeGVzfHwoX3VpZFByZWZpeGVzW2VdPTApLF91aWRQcmVmaXhlc1tlXSs9MSxlK191aWRQcmVmaXhlc1tlXS50b1N0cmluZygpfXZhciBzY2FsYXJDYWNoZT17ZmxvYXQzMjp7fSxpbnQzMjp7fX0sREVGQVVMVF9EVFlQRT1cImZsb2F0MzJcIjtmdW5jdGlvbiBnZXRTY2FsYXIoZSx0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9REVGQVVMVF9EVFlQRSksbnVsbD09c2NhbGFyQ2FjaGVbdF1bZV0mJihzY2FsYXJDYWNoZVt0XVtlXT1zY2FsYXIoZSx0KSxrZWVwKHNjYWxhckNhY2hlW3RdW2VdKSksc2NhbGFyQ2FjaGVbdF1bZV19dmFyIEF0dHJpYnV0ZUVycm9yPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQobil7dmFyIHI9ZS5jYWxsKHRoaXMsbil8fHRoaXM7cmV0dXJuIE9iamVjdC5zZXRQcm90b3R5cGVPZihyLHQucHJvdG90eXBlKSxyfXJldHVybiBfX2V4dGVuZHModCxlKSx0fShFcnJvciksUnVudGltZUVycm9yPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQobil7dmFyIHI9ZS5jYWxsKHRoaXMsbil8fHRoaXM7cmV0dXJuIE9iamVjdC5zZXRQcm90b3R5cGVPZihyLHQucHJvdG90eXBlKSxyfXJldHVybiBfX2V4dGVuZHModCxlKSx0fShFcnJvciksVmFsdWVFcnJvcj1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KG4pe3ZhciByPWUuY2FsbCh0aGlzLG4pfHx0aGlzO3JldHVybiBPYmplY3Quc2V0UHJvdG90eXBlT2Yocix0LnByb3RvdHlwZSkscn1yZXR1cm4gX19leHRlbmRzKHQsZSksdH0oRXJyb3IpLE5vdEltcGxlbWVudGVkRXJyb3I9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdChuKXt2YXIgcj1lLmNhbGwodGhpcyxuKXx8dGhpcztyZXR1cm4gT2JqZWN0LnNldFByb3RvdHlwZU9mKHIsdC5wcm90b3R5cGUpLHJ9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHR9KEVycm9yKSxBc3NlcnRpb25FcnJvcj1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KG4pe3ZhciByPWUuY2FsbCh0aGlzLG4pfHx0aGlzO3JldHVybiBPYmplY3Quc2V0UHJvdG90eXBlT2Yocix0LnByb3RvdHlwZSkscn1yZXR1cm4gX19leHRlbmRzKHQsZSksdH0oRXJyb3IpLEluZGV4RXJyb3I9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdChuKXt2YXIgcj1lLmNhbGwodGhpcyxuKXx8dGhpcztyZXR1cm4gT2JqZWN0LnNldFByb3RvdHlwZU9mKHIsdC5wcm90b3R5cGUpLHJ9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHR9KEVycm9yKTtmdW5jdGlvbiBweUxpc3RSZXBlYXQoZSx0KXtpZihBcnJheS5pc0FycmF5KGUpKXtmb3IodmFyIG49W10scj0wO3I8dDtyKyspbj1uLmNvbmNhdChlKTtyZXR1cm4gbn1yZXR1cm4obj1uZXcgQXJyYXkodCkpLmZpbGwoZSksbn1mdW5jdGlvbiBhc3NlcnQoZSx0KXtpZighZSl0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IodCl9ZnVuY3Rpb24gY291bnQoZSx0KXtmb3IodmFyIG49MCxyPTAsaT1lO3I8aS5sZW5ndGg7cisrKXtpW3JdPT09dCYmbisrfXJldHVybiBufWZ1bmN0aW9uIHNpbmdsZXRvbk9yQXJyYXkoZSl7cmV0dXJuIDE9PT1lLmxlbmd0aD9lWzBdOmV9ZnVuY3Rpb24gdG9MaXN0KGUpe3JldHVybiBBcnJheS5pc0FycmF5KGUpP2U6W2VdfWZ1bmN0aW9uIHRvU25ha2VDYXNlKGUpe3ZhciB0PWUucmVwbGFjZSgvKC4pKFtBLVpdW2EtejAtOV0rKS9nLFwiJDFfJDJcIikucmVwbGFjZSgvKFthLXpdKShbQS1aXSkvZyxcIiQxXyQyXCIpLnRvTG93ZXJDYXNlKCk7cmV0dXJuXCJfXCIhPT10WzBdP3Q6XCJwcml2YXRlXCIrdH1mdW5jdGlvbiB0b0NhbWVsQ2FzZShlKXtyZXR1cm4gZS5sZW5ndGg8PTE/ZTotMT09PWUuaW5kZXhPZihcIl9cIik/ZTplLnJlcGxhY2UoL1tfXSsoXFx3fCQpL2csZnVuY3Rpb24oZSx0KXtyZXR1cm4gdC50b1VwcGVyQ2FzZSgpfSl9dmFyIF9HTE9CQUxfQ1VTVE9NX09CSkVDVFM9e307ZnVuY3Rpb24gc2VyaWFsaXplS2VyYXNPYmplY3QoZSl7cmV0dXJuIG51bGw9PT1lfHx2b2lkIDA9PT1lP251bGw6e2NsYXNzTmFtZTplLmdldENsYXNzTmFtZSgpLGNvbmZpZzplLmdldENvbmZpZygpfX1mdW5jdGlvbiBkZXNlcmlhbGl6ZUtlcmFzT2JqZWN0KGUsdCxuLHIpe2lmKHZvaWQgMD09PXQmJih0PXt9KSx2b2lkIDA9PT1uJiYobj17fSksdm9pZCAwPT09ciYmKHI9XCJvYmplY3RcIiksXCJzdHJpbmdcIj09dHlwZW9mIGUpe3ZhciBpPWUsYT12b2lkIDA7aWYoaSBpbiBuKWE9bltpXTtlbHNlIGlmKGkgaW4gX0dMT0JBTF9DVVNUT01fT0JKRUNUUylhPV9HTE9CQUxfQ1VTVE9NX09CSkVDVFNbaV07ZWxzZSBpZihudWxsPT0oYT10W2ldKSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlVua25vd24gXCIrcitcIjogXCIrZStcIi4gVGhpcyBtYXkgYmUgZHVlIHRvIG9uZSBvZiB0aGUgZm9sbG93aW5nIHJlYXNvbnM6XFxuMS4gVGhlIFwiK3IrXCIgaXMgZGVmaW5lZCBpbiBQeXRob24sIGluIHdoaWNoIGNhc2UgaXQgbmVlZHMgdG8gYmUgcG9ydGVkIHRvIFRlbnNvckZsb3cuanMgb3IgeW91ciBKYXZhU2NyaXB0IGNvZGUuXFxuMi4gVGhlIGN1c3RvbSBcIityK1wiIGlzIGRlZmluZWQgaW4gSmF2YVNjcmlwdCwgYnV0IGlzIG5vdCByZWdpc3RlcmVkIHByb3Blcmx5IHdpdGggdGYuc2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKCkuXCIpO3JldHVybiBhfXZhciBvPWU7aWYobnVsbD09by5jbGFzc05hbWV8fG51bGw9PW8uY29uZmlnKXRocm93IG5ldyBWYWx1ZUVycm9yKHIrXCI6IEltcHJvcGVyIGNvbmZpZyBmb3JtYXQ6IFwiK0pTT04uc3RyaW5naWZ5KG8pK1wiLlxcbidjbGFzc05hbWUnIGFuZCAnY29uZmlnJyBtdXN0IHNldC5cIik7dmFyIHM9by5jbGFzc05hbWUsbD12b2lkIDAsdT12b2lkIDA7aWYocyBpbiBuPyhsPShTPW4uZ2V0KHMpKVswXSx1PVNbMV0pOnMgaW4gX0dMT0JBTF9DVVNUT01fT0JKRUNUUz8obD0oST1fR0xPQkFMX0NVU1RPTV9PQkpFQ1RTLmNsYXNzTmFtZSlbMF0sdT1JWzFdKTpzIGluIHQmJihsPShOPXRbc10pWzBdLHU9TlsxXSksbnVsbD09bCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlVua25vd24gXCIrcitcIjogXCIrcytcIi4gVGhpcyBtYXkgYmUgZHVlIHRvIG9uZSBvZiB0aGUgZm9sbG93aW5nIHJlYXNvbnM6XFxuMS4gVGhlIFwiK3IrXCIgaXMgZGVmaW5lZCBpbiBQeXRob24sIGluIHdoaWNoIGNhc2UgaXQgbmVlZHMgdG8gYmUgcG9ydGVkIHRvIFRlbnNvckZsb3cuanMgb3IgeW91ciBKYXZhU2NyaXB0IGNvZGUuXFxuMi4gVGhlIGN1c3RvbSBcIityK1wiIGlzIGRlZmluZWQgaW4gSmF2YVNjcmlwdCwgYnV0IGlzIG5vdCByZWdpc3RlcmVkIHByb3Blcmx5IHdpdGggdGYuc2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKCkuXCIpO2lmKG51bGwhPXUpe2Zvcih2YXIgYz17fSxwPTAsaD1PYmplY3Qua2V5cyhfR0xPQkFMX0NVU1RPTV9PQkpFQ1RTKTtwPGgubGVuZ3RoO3ArKyl7Y1t2PWhbcF1dPV9HTE9CQUxfQ1VTVE9NX09CSkVDVFNbdl19Zm9yKHZhciBkPTAsZj1PYmplY3Qua2V5cyhuKTtkPGYubGVuZ3RoO2QrKyl7Y1t2PWZbZF1dPW5bdl19by5jb25maWcuY3VzdG9tT2JqZWN0cz1jO2Zvcih2YXIgZz1fX2Fzc2lnbih7fSxfR0xPQkFMX0NVU1RPTV9PQkpFQ1RTKSxtPTAseT1PYmplY3Qua2V5cyhuKTttPHkubGVuZ3RoO20rKyl7dmFyIHY9eVttXTtfR0xPQkFMX0NVU1RPTV9PQkpFQ1RTW3ZdPW5bdl19dmFyIGI9dShsLG8uY29uZmlnKTtyZXR1cm4gX0dMT0JBTF9DVVNUT01fT0JKRUNUUz1fX2Fzc2lnbih7fSxnKSxifWc9X19hc3NpZ24oe30sX0dMT0JBTF9DVVNUT01fT0JKRUNUUyk7Zm9yKHZhciB3PTAsej1PYmplY3Qua2V5cyhuKTt3PHoubGVuZ3RoO3crKyl7dj16W3ddO19HTE9CQUxfQ1VTVE9NX09CSkVDVFNbdl09blt2XX12YXIgUyxJLE47Yj1uZXcgbChvLmNvbmZpZyk7cmV0dXJuIF9HTE9CQUxfQ1VTVE9NX09CSkVDVFM9X19hc3NpZ24oe30sZyksYn1mdW5jdGlvbiBudW1iZXJDb21wYXJlKGUsdCl7cmV0dXJuIGU8dD8tMTplPnQ/MTowfWZ1bmN0aW9uIHJldmVyc2VOdW1iZXJDb21wYXJlKGUsdCl7cmV0dXJuLTEqbnVtYmVyQ29tcGFyZShlLHQpfWZ1bmN0aW9uIHN0cmluZ1RvRFR5cGUoZSl7c3dpdGNoKGUpe2Nhc2VcImZsb2F0MzJcIjpyZXR1cm5cImZsb2F0MzJcIjtkZWZhdWx0OnRocm93IG5ldyBWYWx1ZUVycm9yKFwiSW52YWxpZCBkdHlwZTogXCIrZSl9fWZ1bmN0aW9uIHVuaXF1ZShlKXtpZihudWxsPT1lKXJldHVybiBlO2Zvcih2YXIgdD1bXSxuPTAscj1lO248ci5sZW5ndGg7bisrKXt2YXIgaT1yW25dOy0xPT09dC5pbmRleE9mKGkpJiZ0LnB1c2goaSl9cmV0dXJuIHR9ZnVuY3Rpb24gaXNPYmplY3RFbXB0eShlKXtpZihudWxsPT1lKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiSW52YWxpZCB2YWx1ZSBpbiBvYmo6IFwiK0pTT04uc3RyaW5naWZ5KGUpKTtmb3IodmFyIHQgaW4gZSlpZihlLmhhc093blByb3BlcnR5KHQpKXJldHVybiExO3JldHVybiEwfWZ1bmN0aW9uIGNoZWNrU3RyaW5nVHlwZVVuaW9uVmFsdWUoZSx0LG4pe2lmKG51bGwhPW4mJmUuaW5kZXhPZihuKTwwKXRocm93IG5ldyBWYWx1ZUVycm9yKG4rXCIgaXMgbm90IGEgdmFsaWQgXCIrdCtcIi4gIFZhbGlkIHZhbHVlcyBhcmUgXCIrZStcIiBvciBudWxsL3VuZGVmaW5lZC5cIil9ZnVuY3Rpb24gY2hlY2tBcnJheVR5cGVBbmRMZW5ndGgoZSx0LG4scil7cmV0dXJuIHZvaWQgMD09PW4mJihuPTApLHZvaWQgMD09PXImJihyPTEvMCksYXNzZXJ0KG4+PTApLGFzc2VydChyPj1uKSxBcnJheS5pc0FycmF5KGUpJiZlLmxlbmd0aD49biYmZS5sZW5ndGg8PXImJmUuZXZlcnkoZnVuY3Rpb24oZSl7cmV0dXJuIHR5cGVvZiBlPT09dH0pfWZ1bmN0aW9uIGNhbGNMMk5vcm1zKGUsdCl7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtyZXR1cm4gc3FydChzdW0obXVsU3RyaWN0KGUsZSksdCwhMCkpfSl9dmFyIENvbnN0cmFpbnQ9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe3JldHVybiBudWxsIT09ZSYmZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3JldHVybnt9fSx0fShzZXJpYWxpemF0aW9uLlNlcmlhbGl6YWJsZSksTWF4Tm9ybT1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gbi5kZWZhdWx0TWF4VmFsdWU9MixuLmRlZmF1bHRBeGlzPTAsbi5tYXhWYWx1ZT1udWxsIT10Lm1heFZhbHVlP3QubWF4VmFsdWU6bi5kZWZhdWx0TWF4VmFsdWUsbi5heGlzPW51bGwhPXQuYXhpcz90LmF4aXM6bi5kZWZhdWx0QXhpcyxufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbihlKXt2YXIgdD10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIG49Y2FsY0wyTm9ybXMoZSx0LmF4aXMpLHI9Y2xpcEJ5VmFsdWUobiwwLHQubWF4VmFsdWUpO3JldHVybiBtdWwoZSxkaXYocixhZGQoZ2V0U2NhbGFyKGVwc2lsb24oKSksbikpKX0pfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXtyZXR1cm57bWF4VmFsdWU6dGhpcy5tYXhWYWx1ZSxheGlzOnRoaXMuYXhpc319LHQuY2xhc3NOYW1lPVwiTWF4Tm9ybVwiLHR9KENvbnN0cmFpbnQpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhNYXhOb3JtKTt2YXIgVW5pdE5vcm09ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIG4uZGVmYXVsdEF4aXM9MCxuLmF4aXM9bnVsbCE9dC5heGlzP3QuYXhpczpuLmRlZmF1bHRBeGlzLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtyZXR1cm4gZGl2KGUsYWRkKGdldFNjYWxhcihlcHNpbG9uKCkpLGNhbGNMMk5vcm1zKGUsdC5heGlzKSkpfSl9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3JldHVybntheGlzOnRoaXMuYXhpc319LHQuY2xhc3NOYW1lPVwiVW5pdE5vcm1cIix0fShDb25zdHJhaW50KTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoVW5pdE5vcm0pO3ZhciBOb25OZWc9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe3JldHVybiBudWxsIT09ZSYmZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKGUpe3JldHVybiByZWx1KGUpfSx0LmNsYXNzTmFtZT1cIk5vbk5lZ1wiLHR9KENvbnN0cmFpbnQpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhOb25OZWcpO3ZhciBNaW5NYXhOb3JtPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49ZS5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiBuLmRlZmF1bHRNaW5WYWx1ZT0wLG4uZGVmYXVsdE1heFZhbHVlPTEsbi5kZWZhdWx0UmF0ZT0xLG4uZGVmYXVsdEF4aXM9MCxuLm1pblZhbHVlPW51bGwhPXQubWluVmFsdWU/dC5taW5WYWx1ZTpuLmRlZmF1bHRNaW5WYWx1ZSxuLm1heFZhbHVlPW51bGwhPXQubWF4VmFsdWU/dC5tYXhWYWx1ZTpuLmRlZmF1bHRNYXhWYWx1ZSxuLnJhdGU9bnVsbCE9dC5yYXRlP3QucmF0ZTpuLmRlZmF1bHRSYXRlLG4uYXhpcz1udWxsIT10LmF4aXM/dC5heGlzOm4uZGVmYXVsdEF4aXMsbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuYXBwbHk9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciBuPWNhbGNMMk5vcm1zKGUsdC5heGlzKSxyPWFkZChtdWwoZ2V0U2NhbGFyKHQucmF0ZSksY2xpcEJ5VmFsdWUobix0Lm1pblZhbHVlLHQubWF4VmFsdWUpKSxtdWwoZ2V0U2NhbGFyKDEtdC5yYXRlKSxuKSk7cmV0dXJuIG11bChlLGRpdihyLGFkZChnZXRTY2FsYXIoZXBzaWxvbigpKSxuKSkpfSl9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3JldHVybnttaW5WYWx1ZTp0aGlzLm1pblZhbHVlLG1heFZhbHVlOnRoaXMubWF4VmFsdWUscmF0ZTp0aGlzLnJhdGUsYXhpczp0aGlzLmF4aXN9fSx0LmNsYXNzTmFtZT1cIk1pbk1heE5vcm1cIix0fShDb25zdHJhaW50KTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoTWluTWF4Tm9ybSk7dmFyIENPTlNUUkFJTlRfSURFTlRJRklFUl9SRUdJU1RSWV9TWU1CT0xfTUFQPXttYXhOb3JtOlwiTWF4Tm9ybVwiLG1pbk1heE5vcm06XCJNaW5NYXhOb3JtXCIsbm9uTmVnOlwiTm9uTmVnXCIsdW5pdE5vcm06XCJVbml0Tm9ybVwifTtmdW5jdGlvbiBzZXJpYWxpemVDb25zdHJhaW50KGUpe3JldHVybiBzZXJpYWxpemVLZXJhc09iamVjdChlKX1mdW5jdGlvbiBkZXNlcmlhbGl6ZUNvbnN0cmFpbnQoZSx0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9e30pLGRlc2VyaWFsaXplS2VyYXNPYmplY3QoZSxzZXJpYWxpemF0aW9uLlNlcmlhbGl6YXRpb25NYXAuZ2V0TWFwKCkuY2xhc3NOYW1lTWFwLHQsXCJjb25zdHJhaW50XCIpfWZ1bmN0aW9uIGdldENvbnN0cmFpbnQoZSl7cmV0dXJuIG51bGw9PWU/bnVsbDpcInN0cmluZ1wiPT10eXBlb2YgZT9kZXNlcmlhbGl6ZUNvbnN0cmFpbnQoe2NsYXNzTmFtZTplIGluIENPTlNUUkFJTlRfSURFTlRJRklFUl9SRUdJU1RSWV9TWU1CT0xfTUFQP0NPTlNUUkFJTlRfSURFTlRJRklFUl9SRUdJU1RSWV9TWU1CT0xfTUFQW2VdOmUsY29uZmlnOnt9fSk6ZSBpbnN0YW5jZW9mIENvbnN0cmFpbnQ/ZTpkZXNlcmlhbGl6ZUNvbnN0cmFpbnQoZSl9ZnVuY3Rpb24gbWF4Tm9ybShlKXtyZXR1cm4gbmV3IE1heE5vcm0oZSl9ZnVuY3Rpb24gdW5pdE5vcm0oZSl7cmV0dXJuIG5ldyBVbml0Tm9ybShlKX1mdW5jdGlvbiBub25OZWcoKXtyZXR1cm4gbmV3IE5vbk5lZ31mdW5jdGlvbiBtaW5NYXhOb3JtKGUpe3JldHVybiBuZXcgTWluTWF4Tm9ybShlKX12YXIgZXhwb3J0c19jb25zdHJhaW50cz1PYmplY3QuZnJlZXplKHttYXhOb3JtOm1heE5vcm0sdW5pdE5vcm06dW5pdE5vcm0sbm9uTmVnOm5vbk5lZyxtaW5NYXhOb3JtOm1pbk1heE5vcm19KSxuYW1lTWFwPW5ldyBNYXAsVkFMSURfREFUQV9GT1JNQVRfVkFMVUVTPVtcImNoYW5uZWxzRmlyc3RcIixcImNoYW5uZWxzTGFzdFwiXTtmdW5jdGlvbiBjaGVja0RhdGFGb3JtYXQoZSl7Y2hlY2tTdHJpbmdUeXBlVW5pb25WYWx1ZShWQUxJRF9EQVRBX0ZPUk1BVF9WQUxVRVMsXCJEYXRhRm9ybWF0XCIsZSl9dmFyIFZBTElEX1BBRERJTkdfTU9ERV9WQUxVRVM9W1widmFsaWRcIixcInNhbWVcIixcImNhdXNhbFwiXTtmdW5jdGlvbiBjaGVja1BhZGRpbmdNb2RlKGUpe2NoZWNrU3RyaW5nVHlwZVVuaW9uVmFsdWUoVkFMSURfUEFERElOR19NT0RFX1ZBTFVFUyxcIlBhZGRpbmdNb2RlXCIsZSl9dmFyIFZBTElEX1BPT0xfTU9ERV9WQUxVRVM9W1wibWF4XCIsXCJhdmdcIl07ZnVuY3Rpb24gY2hlY2tQb29sTW9kZShlKXtjaGVja1N0cmluZ1R5cGVVbmlvblZhbHVlKFZBTElEX1BPT0xfTU9ERV9WQUxVRVMsXCJQb29sTW9kZVwiLGUpfXZhciBfbmFtZVNjb3BlU3RhY2s9W10sX25hbWVTY29wZURpdmlkZXI9XCIvXCI7ZnVuY3Rpb24gbmFtZVNjb3BlKGUsdCl7X25hbWVTY29wZVN0YWNrLnB1c2goZSk7dHJ5e3ZhciBuPXQoKTtyZXR1cm4gX25hbWVTY29wZVN0YWNrLnBvcCgpLG59Y2F0Y2goZSl7dGhyb3cgX25hbWVTY29wZVN0YWNrLnBvcCgpLGV9fWZ1bmN0aW9uIGN1cnJlbnROYW1lU2NvcGVQcmVmaXgoKXtyZXR1cm4gMD09PV9uYW1lU2NvcGVTdGFjay5sZW5ndGg/XCJcIjpfbmFtZVNjb3BlU3RhY2suam9pbihfbmFtZVNjb3BlRGl2aWRlcikrX25hbWVTY29wZURpdmlkZXJ9ZnVuY3Rpb24gZ2V0U2NvcGVkVGVuc29yTmFtZShlKXtpZighaXNWYWxpZFRlbnNvck5hbWUoZSkpdGhyb3cgbmV3IEVycm9yKFwiTm90IGEgdmFsaWQgdGVuc29yIG5hbWU6ICdcIitlK1wiJ1wiKTtyZXR1cm4gY3VycmVudE5hbWVTY29wZVByZWZpeCgpK2V9ZnVuY3Rpb24gZ2V0VW5pcXVlVGVuc29yTmFtZShlKXtpZighaXNWYWxpZFRlbnNvck5hbWUoZSkpdGhyb3cgbmV3IEVycm9yKFwiTm90IGEgdmFsaWQgdGVuc29yIG5hbWU6ICdcIitlK1wiJ1wiKTtuYW1lTWFwLmhhcyhlKXx8bmFtZU1hcC5zZXQoZSwwKTt2YXIgdD1uYW1lTWFwLmdldChlKTtpZihuYW1lTWFwLnNldChlLG5hbWVNYXAuZ2V0KGUpKzEpLHQ+MCl7dmFyIG49ZStcIl9cIit0O3JldHVybiBuYW1lTWFwLnNldChuLDEpLG59cmV0dXJuIGV9dmFyIHRlbnNvck5hbWVSZWdleD1uZXcgUmVnRXhwKC9eW0EtWmEtel1bLUEtWmEtejAtOVxcLl9cXC9dKiQvKTtmdW5jdGlvbiBpc1ZhbGlkVGVuc29yTmFtZShlKXtyZXR1cm4hIWUubWF0Y2godGVuc29yTmFtZVJlZ2V4KX1mdW5jdGlvbiBpc0ludGVnZXIoZSl7cmV0dXJuIGU9PT1wYXJzZUludChlLnRvU3RyaW5nKCksMTApfWZ1bmN0aW9uIGFycmF5UHJvZChlLHQsbil7bnVsbD09dCYmKHQ9MCksbnVsbD09biYmKG49ZS5sZW5ndGgpO2Zvcih2YXIgcj0xLGk9dDtpPG47KytpKXIqPWVbaV07cmV0dXJuIHJ9ZnVuY3Rpb24gdG9BcnJheTFEKGUpe3JldHVybiBlPUFycmF5LmlzQXJyYXkoZSk/bmV3IEZsb2F0MzJBcnJheShlKTplLHRlbnNvcjFkKGUpfWZ1bmN0aW9uIG1pbiQxKGUpe3JldHVybiBtaW4odG9BcnJheTFEKGUpKS5kYXRhU3luYygpWzBdfWZ1bmN0aW9uIG1heCQxKGUpe3JldHVybiBtYXgodG9BcnJheTFEKGUpKS5kYXRhU3luYygpWzBdfWZ1bmN0aW9uIHJhbmdlKGUsdCl7aWYodDxlKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiZW5kIChcIit0K1wiKSA8IGJlZ2luIChcIitlK1wiKSBpcyBmb3JiaWRkZW4uXCIpO2Zvcih2YXIgbj1bXSxyPWU7cjx0OysrciluLnB1c2gocik7cmV0dXJuIG59ZnVuY3Rpb24gY2FzdCQxKGUsdCl7cmV0dXJuIGUuYXNUeXBlKHQpfWZ1bmN0aW9uIGV4cGFuZERpbXMoZSx0KXt2b2lkIDA9PT10JiYodD0tMSk7dmFyIG49ZS5zaGFwZS5zbGljZSgpO3JldHVybiB0PDAmJih0PW4ubGVuZ3RoK3QrMSksbi5zcGxpY2UodCwwLDEpLGUucmVzaGFwZShuKX1mdW5jdGlvbiByZXBlYXQoZSx0KXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe2lmKDIhPT1lLnNoYXBlLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcInJlcGVhdCgpIGV4cGVjdHMgYSByYW5rLTIgdGVuc29yLCBidXQgcmVjZWl2ZWQgYSByYW5rLVwiK2Uuc2hhcGUubGVuZ3RoK1wiIHRlbnNvci5cIik7cmV0dXJuIHRpbGUkMShleHBhbmREaW1zKGUsMSksWzEsdCwxXSl9KX1mdW5jdGlvbiBmbGF0dGVuKGUpe3ZhciB0PVthcnJheVByb2QoZS5zaGFwZSldO3JldHVybiBlLnJlc2hhcGUodCl9ZnVuY3Rpb24gYmF0Y2hGbGF0dGVuKGUpe2lmKGUucmFuazw9MSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcImJhdGNoRmxhdHRlbiByZXF1aXJlcyBhIG1pbmltdW0gcmFuayBvZiAyLiBHb3QgcmFuazogXCIrZS5yYW5rK1wiLlwiKTt2YXIgdD1bZS5zaGFwZVswXSxhcnJheVByb2QoZS5zaGFwZSwxKV07cmV0dXJuIGUucmVzaGFwZSh0KX1mdW5jdGlvbiBzbGljZUFsb25nRmlyc3RBeGlzKGUsdCxuKXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3N3aXRjaChlLnJhbmspe2Nhc2UgMTpyZXR1cm4gc2xpY2UxZChlLHQsbik7Y2FzZSAyOnJldHVybiBzbGljZTJkKGUsW3QsMF0sW24sZS5zaGFwZVsxXV0pO2Nhc2UgMzpyZXR1cm4gc2xpY2UzZChlLFt0LDAsMF0sW24sZS5zaGFwZVsxXSxlLnNoYXBlWzJdXSk7Y2FzZSA0OnJldHVybiBzbGljZTRkKGUsW3QsMCwwLDBdLFtuLGUuc2hhcGVbMV0sZS5zaGFwZVsyXSxlLnNoYXBlWzNdXSk7ZGVmYXVsdDp0aHJvdyBuZXcgVmFsdWVFcnJvcihcInNsaWNlQWxvbmdGaXJzdEF4aXMoKSByZWNlaXZlZCBhbiB1bnN1cHBvcnRlZCB0ZW5zb3IgcmFuazogXCIrZS5yYW5rKX19KX1mdW5jdGlvbiBzbGljZUFsb25nTGFzdEF4aXMoZSx0LG4pe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7c3dpdGNoKGUucmFuayl7Y2FzZSAxOnJldHVybiBzbGljZTFkKGUsdCxuKTtjYXNlIDI6cmV0dXJuIHNsaWNlMmQoZSxbMCx0XSxbZS5zaGFwZVswXSxuXSk7Y2FzZSAzOnJldHVybiBzbGljZTNkKGUsWzAsMCx0XSxbZS5zaGFwZVswXSxlLnNoYXBlWzFdLG5dKTtjYXNlIDQ6cmV0dXJuIHNsaWNlNGQoZSxbMCwwLDAsdF0sW2Uuc2hhcGVbMF0sZS5zaGFwZVsxXSxlLnNoYXBlWzJdLG5dKTtkZWZhdWx0OnRocm93IG5ldyBWYWx1ZUVycm9yKFwic2xpY2VBbG9uZ0xhc3RBeGlzKCkgcmVjZWl2ZWQgYW4gdW5zdXBwb3J0ZWQgdGVuc29yIHJhbms6IFwiK2UucmFuayl9fSl9ZnVuY3Rpb24gc2xpY2VBbG9uZ0F4aXMoZSx0LG4scil7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtzd2l0Y2goZS5yYW5rKXtjYXNlIDE6cmV0dXJuIHNsaWNlMWQoZSx0LG4pO2Nhc2UgMjpzd2l0Y2gocil7Y2FzZSAxOnJldHVybiBzbGljZUFsb25nRmlyc3RBeGlzKGUsdCxuKTtjYXNlIDI6cmV0dXJuIHNsaWNlQWxvbmdMYXN0QXhpcyhlLHQsbik7ZGVmYXVsdDp0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlRoZSBheGlzIGlzIG5vdCB3aXRoaW4gdGhlIHJhbmsgb2YgdGhlIHRlbnNvciBcIityKX1jYXNlIDM6c3dpdGNoKHIpe2Nhc2UgMTpyZXR1cm4gc2xpY2VBbG9uZ0ZpcnN0QXhpcyhlLHQsbik7Y2FzZSAyOnJldHVybiBzbGljZTNkKGUsWzAsdCwwXSxbZS5zaGFwZVswXSxuLGUuc2hhcGVbMl1dKTtjYXNlIDM6cmV0dXJuIHNsaWNlQWxvbmdMYXN0QXhpcyhlLHQsbik7ZGVmYXVsdDp0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlRoZSBheGlzIGlzIG5vdCB3aXRoaW4gdGhlIHJhbmsgb2YgdGhlIHRlbnNvciBcIityKX1jYXNlIDQ6c3dpdGNoKHIpe2Nhc2UgMTpyZXR1cm4gc2xpY2VBbG9uZ0ZpcnN0QXhpcyhlLHQsbik7Y2FzZSAyOnJldHVybiBzbGljZTRkKGUsWzAsdCwwLDBdLFtlLnNoYXBlWzBdLG4sZS5zaGFwZVsyXSxlLnNoYXBlWzNdXSk7Y2FzZSAzOnJldHVybiBzbGljZTRkKGUsWzAsMCx0LDBdLFtlLnNoYXBlWzBdLGUuc2hhcGVbMV0sbixlLnNoYXBlWzNdXSk7Y2FzZSA0OnJldHVybiBzbGljZUFsb25nTGFzdEF4aXMoZSx0LG4pO2RlZmF1bHQ6dGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJUaGUgYXhpcyBpcyBub3Qgd2l0aGluIHRoZSByYW5rIG9mIHRoZSB0ZW5zb3IgXCIrcil9ZGVmYXVsdDp0aHJvdyBuZXcgVmFsdWVFcnJvcihcInNsaWNlQWxvbmdMYXN0QXhpcygpIHJlY2VpdmVkIGFuIHVuc3VwcG9ydGVkIHRlbnNvciByYW5rOiBcIitlLnJhbmspfX0pfWZ1bmN0aW9uIGNvbmNhdGVuYXRlKGUsdCl7dmFyIG47cmV0dXJuIHZvaWQgMD09PXQmJih0PS0xKSx0PDAmJih0PTAhPT0obj1lWzBdLnJhbmspP246MCksdD09PWVbMF0ucmFuayYmKHQ9LTEpLGNvbmNhdChlLHQpfWZ1bmN0aW9uIGNvbmNhdEFsb25nRmlyc3RBeGlzKGUsdCl7c3dpdGNoKGUucmFuayl7Y2FzZSAxOnJldHVybiBjb25jYXQxZChbZSx0XSk7Y2FzZSAyOnJldHVybiBjb25jYXQyZChbZSx0XSwwKTtjYXNlIDM6cmV0dXJuIGNvbmNhdDNkKFtlLHRdLDApO2Nhc2UgNDpyZXR1cm4gY29uY2F0NGQoW2UsdF0sMCk7ZGVmYXVsdDp0aHJvdyBuZXcgVmFsdWVFcnJvcihcImNvbmNhdEFsb25nRmlyc3RBeGlzKCkgcmVjZWl2ZWQgYW4gdW5zdXBwb3J0ZWQgdGVuc29yIHJhbms6IFwiK2UucmFuayl9fWZ1bmN0aW9uIHRpbGUkMShlLHQpe2lmKEFycmF5LmlzQXJyYXkodCl8fCh0PVt0XSksZS5yYW5rIT09dC5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJUaGUgbGVuZ3RoIG9mIGlucHV0IG4gKFwiK3QubGVuZ3RoK1wiKSBkb2VzIG5vdCBtYXRjaCB0aGUgbnVtYmVyIG9mIGRpbWVuc2lvbnMgaW4gaW5wdXQgeCAoXCIrZS5yYW5rK1wiKVwiKTtyZXR1cm4gdGlsZShlLHQpfWZ1bmN0aW9uIHJhbmRvbU5vcm1hbCQxKGUsdCxuLHIsaSl7cmV0dXJuIHZvaWQgMD09PXQmJih0PTApLHZvaWQgMD09PW4mJihuPTEpLHJhbmRvbU5vcm1hbChlLHQsbixyLGkpfWZ1bmN0aW9uIGRvdChlLHQpe2lmKGUucmFuazwyfHx0LnJhbms8Mil0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcImRvdCByZXF1aXJlcyBib3RoIGlucHV0cyB0byBiZSByYW5rID49IDIgYnV0IGdvdCB4IHNoYXBlID0gXCIrZS5zaGFwZStcIiBhbmQgeSBzaGFwZSA9IFwiK3Quc2hhcGUpO2lmKHQucmFuaz49MyYmKHI9ZS5zaGFwZS5zbGljZSgtMSlbMF0pIT09KG89dC5zaGFwZS5zbGljZSgtMilbMF0pKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwiSWYgcmFuayB5ID49IDMsIHRoZW4gdGhlIHNlY29uZCBsYXN0IGRpbSBvZiB5IG11c3QgZXF1YWwgdGhlIGxhc3QgZGltIG9mIHggYnV0IGdvdCB4IHNoYXBlID0gXCIrZS5zaGFwZStcIiBhbmQgIHkgc2hhcGUgPSBcIit0LnNoYXBlKTtpZigyPT09ZS5yYW5rJiYyPT09dC5yYW5rKXJldHVybiBtYXRNdWwoZSx0KTt2YXIgbj1lLnNoYXBlLnNsaWNlKCkscj1uLnBvcCgpO2U9ZS5yZXNoYXBlKFstMSxyXSk7dmFyIGk9dC5zaGFwZS5zbGljZSgpLGE9aS5wb3AoKSxvPWkucG9wKCkscz1pLmNvbmNhdChbYV0pLGw9QXJyYXkuZnJvbSh7bGVuZ3RoOnQucmFua30sZnVuY3Rpb24oZSxuKXtyZXR1cm4gMD09PW4/dC5yYW5rLTI6bjw9dC5yYW5rLTI/bi0xOm59KTt0PXQudHJhbnNwb3NlKGwpLnJlc2hhcGUoW28sLTFdKTt2YXIgdT1uLmNvbmNhdChzKTtyZXR1cm4gbWF0TXVsKGUsdCkucmVzaGFwZSh1KX1mdW5jdGlvbiBnYXRoZXIkMShlLHQsbil7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtyZXR1cm4gdD1BcnJheS5pc0FycmF5KHQpP3RlbnNvcjFkKHQsXCJpbnQzMlwiKTp0LnRvSW50KCksZ2F0aGVyKGUsdCxuKX0pfWZ1bmN0aW9uIHNxdWFyZShlKXtyZXR1cm4gbXVsU3RyaWN0KGUsZSl9ZnVuY3Rpb24gYmlhc0FkZChlLHQsbil7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtpZihudWxsPT1uJiYobj1pbWFnZURhdGFGb3JtYXQoKSksY2hlY2tEYXRhRm9ybWF0KG4pLDEhPT10LnJhbmsmJnQucmFuayE9PWUucmFuayl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlVuZXhwZWN0ZWQgYmlhcyBkaW1lbnNpb25zOiBcIit0LnJhbmsrXCI7IGV4cGVjdGVkIGl0IHRvIGJlIDEgb3IgXCIrZS5yYW5rKTt2YXIgcixpPXQuc2hhcGU7aWYoNT09PWUucmFuaylcImNoYW5uZWxzRmlyc3RcIj09PW4/cj0xPT09aS5sZW5ndGg/ZS5hZGQodC5yZXNoYXBlKFsxLGlbMF0sMSwxLDFdKSk6ZS5hZGQodC5yZXNoYXBlKFsxLGlbM10saVswXSxpWzFdLGlbMl1dKSk6XCJjaGFubmVsc0xhc3RcIj09PW4mJihyPTE9PT1pLmxlbmd0aD9lLmFkZCh0LnJlc2hhcGUoWzEsMSwxLDEsaVswXV0pKTplLmFkZCh0LnJlc2hhcGUoWzFdLmNvbmNhdChpKSkpKTtlbHNlIGlmKDQ9PT1lLnJhbmspXCJjaGFubmVsc0ZpcnN0XCI9PT1uP3I9MT09PWkubGVuZ3RoP2UuYWRkKHQucmVzaGFwZShbMSxpWzBdLDEsMV0pKTplLmFkZCh0LnJlc2hhcGUoWzEsaVsyXSxpWzBdLGlbMV1dKSk6XCJjaGFubmVsc0xhc3RcIj09PW4mJihyPTE9PT1pLmxlbmd0aD9lLmFkZCh0LnJlc2hhcGUoWzEsMSwxLGlbMF1dKSk6ZS5hZGQodC5yZXNoYXBlKFsxXS5jb25jYXQoaSkpKSk7ZWxzZSBpZigzPT09ZS5yYW5rKVwiY2hhbm5lbHNGaXJzdFwiPT09bj9yPTE9PT1pLmxlbmd0aD9lLmFkZCh0LnJlc2hhcGUoWzEsaVswXSwxXSkpOmUuYWRkKHQucmVzaGFwZShbMSxpWzFdLGlbMF1dKSk6XCJjaGFubmVsc0xhc3RcIj09PW4mJihyPTE9PT1pLmxlbmd0aD9lLmFkZCh0LnJlc2hhcGUoWzEsMSxpWzBdXSkpOmUuYWRkKHQucmVzaGFwZShbMV0uY29uY2F0KGkpKSkpO2Vsc2V7aWYoIShlLnJhbms8MykpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJVbnN1cHBvcnRlZCBpbnB1dCByYW5rIGJ5IGJpYXNBZGQ6IFwiK2UucmFuayk7cj1lLmFkZCh0KX1yZXR1cm4gcn0pfWZ1bmN0aW9uIGVsdSQxKGUsdCl7aWYodm9pZCAwPT09dCYmKHQ9MSksMSE9PXQpdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJTdXBwb3J0IGZvciBhbHBoYSB2YWx1ZXMgb3RoZXIgdGhhbiAxIChcIit0K1wiKSBpcyBub3QgaW1wbGVtZW50ZWQgeWV0LlwiKTtyZXR1cm4gZWx1KGUpfWZ1bmN0aW9uIHNvZnRzaWduKGUpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7cmV0dXJuIGRpdihlLGFkZChnZXRTY2FsYXIoMSksYWJzKGUpKSl9KX1mdW5jdGlvbiBkcm9wb3V0KGUsdCxuLHIpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7aWYobnVsbCE9biYmIXV0aWwuYXJyYXlzRXF1YWwoZS5zaGFwZSxuKSl0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcIk5vbi1kZWZhdWx0IG5vaXNlIHNoYXBlIGlzIG5vdCBpbXBsZW1lbnRlZCB5ZXQ6IFwiK0pTT04uc3RyaW5naWZ5KG4pKTtpZihudWxsIT1yKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwic2VlZCBpcyBub3QgaW1wbGVtZW50ZWQgZm9yIGRyb3BvdXQgeWV0LlwiKTt2YXIgaT1zdGVwKGFkZChuZWcodCkscmFuZG9tVW5pZm9ybShlLnNoYXBlLDAsMSxcImZsb2F0MzJcIikpKTtyZXR1cm4gaT1tdWwoZGl2KGdldFNjYWxhcigxKSxzdWIoZ2V0U2NhbGFyKDEpLHQpKSxpKSxtdWwoZSxpKX0pfWZ1bmN0aW9uIGhhcmRTaWdtb2lkKGUpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIHQ9YWRkKGdldFNjYWxhciguNSksbXVsKGdldFNjYWxhciguMiksZSkpO3JldHVybiBjbGlwQnlWYWx1ZSh0LDAsMSl9KX1mdW5jdGlvbiBpblRyYWluUGhhc2UoZSx0LG4pe3JldHVybiB2b2lkIDA9PT1uJiYobj0hMSksbj9lKCk6dCgpfXZhciBWQUxJRF9GQU5fTU9ERV9WQUxVRVM9W1wiZmFuSW5cIixcImZhbk91dFwiLFwiZmFuQXZnXCJdO2Z1bmN0aW9uIGNoZWNrRmFuTW9kZShlKXtjaGVja1N0cmluZ1R5cGVVbmlvblZhbHVlKFZBTElEX0ZBTl9NT0RFX1ZBTFVFUyxcIkZhbk1vZGVcIixlKX12YXIgVkFMSURfRElTVFJJQlVUSU9OX1ZBTFVFUz1bXCJub3JtYWxcIixcInVuaWZvcm1cIl07ZnVuY3Rpb24gY2hlY2tEaXN0cmlidXRpb24oZSl7Y2hlY2tTdHJpbmdUeXBlVW5pb25WYWx1ZShWQUxJRF9ESVNUUklCVVRJT05fVkFMVUVTLFwiRGlzdHJpYnV0aW9uXCIsZSl9dmFyIEluaXRpYWxpemVyPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoKXtyZXR1cm4gbnVsbCE9PWUmJmUuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5mcm9tQ29uZmlnVXNlc0N1c3RvbU9iamVjdHM9ZnVuY3Rpb24oKXtyZXR1cm4hMX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7cmV0dXJue319LHR9KHNlcmlhbGl6YXRpb24uU2VyaWFsaXphYmxlKSxaZXJvcz1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KCl7cmV0dXJuIG51bGwhPT1lJiZlLmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpc31yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuYXBwbHk9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gemVyb3MoZSx0KX0sdC5jbGFzc05hbWU9XCJaZXJvc1wiLHR9KEluaXRpYWxpemVyKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoWmVyb3MpO3ZhciBPbmVzPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoKXtyZXR1cm4gbnVsbCE9PWUmJmUuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbihlLHQpe3JldHVybiBvbmVzKGUsdCl9LHQuY2xhc3NOYW1lPVwiT25lc1wiLHR9KEluaXRpYWxpemVyKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoT25lcyk7dmFyIENvbnN0YW50PWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49ZS5jYWxsKHRoaXMpfHx0aGlzO2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0KXRocm93IG5ldyBWYWx1ZUVycm9yKFwiRXhwZWN0ZWQgYXJndW1lbnQgb2YgdHlwZSBDb25zdGFudENvbmZpZyBidXQgZ290IFwiK3QpO2lmKHZvaWQgMD09PXQudmFsdWUpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJjb25maWcgbXVzdCBoYXZlIHZhbHVlIHNldCBidXQgZ290IFwiK3QpO3JldHVybiBuLnZhbHVlPXQudmFsdWUsbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuYXBwbHk9ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7cmV0dXJuIG11bChzY2FsYXIobi52YWx1ZSksb25lcyhlLHQpKX0pfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXtyZXR1cm57dmFsdWU6dGhpcy52YWx1ZX19LHQuY2xhc3NOYW1lPVwiQ29uc3RhbnRcIix0fShJbml0aWFsaXplcik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKENvbnN0YW50KTt2YXIgUmFuZG9tVW5pZm9ybT1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gbi5ERUZBVUxUX01JTlZBTD0tLjA1LG4uREVGQVVMVF9NQVhWQUw9LjA1LG4ubWludmFsPXQubWludmFsfHxuLkRFRkFVTFRfTUlOVkFMLG4ubWF4dmFsPXQubWF4dmFsfHxuLkRFRkFVTFRfTUFYVkFMLG4uc2VlZD10LnNlZWQsbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuYXBwbHk9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gcmFuZG9tVW5pZm9ybShlLHRoaXMubWludmFsLHRoaXMubWF4dmFsLHQpfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXtyZXR1cm57bWludmFsOnRoaXMubWludmFsLG1heHZhbDp0aGlzLm1heHZhbCxzZWVkOnRoaXMuc2VlZH19LHQuY2xhc3NOYW1lPVwiUmFuZG9tVW5pZm9ybVwiLHR9KEluaXRpYWxpemVyKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoUmFuZG9tVW5pZm9ybSk7dmFyIFJhbmRvbU5vcm1hbD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gbi5ERUZBVUxUX01FQU49MCxuLkRFRkFVTFRfU1REREVWPS4wNSxuLm1lYW49dC5tZWFufHxuLkRFRkFVTFRfTUVBTixuLnN0ZGRldj10LnN0ZGRldnx8bi5ERUZBVUxUX1NURERFVixuLnNlZWQ9dC5zZWVkLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKGUsdCl7aWYoXCJmbG9hdDMyXCIhPT0odD10fHxcImZsb2F0MzJcIikmJlwiaW50MzJcIiE9PXQpdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJyYW5kb21Ob3JtYWwgZG9lcyBub3Qgc3VwcG9ydCBkVHlwZSBcIit0K1wiLlwiKTtyZXR1cm4gcmFuZG9tTm9ybWFsJDEoZSx0aGlzLm1lYW4sdGhpcy5zdGRkZXYsdCx0aGlzLnNlZWQpfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXtyZXR1cm57bWVhbjp0aGlzLm1lYW4sc3RkZGV2OnRoaXMuc3RkZGV2LHNlZWQ6dGhpcy5zZWVkfX0sdC5jbGFzc05hbWU9XCJSYW5kb21Ob3JtYWxcIix0fShJbml0aWFsaXplcik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKFJhbmRvbU5vcm1hbCk7dmFyIFRydW5jYXRlZE5vcm1hbD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gbi5ERUZBVUxUX01FQU49MCxuLkRFRkFVTFRfU1REREVWPS4wNSxuLm1lYW49dC5tZWFufHxuLkRFRkFVTFRfTUVBTixuLnN0ZGRldj10LnN0ZGRldnx8bi5ERUZBVUxUX1NURERFVixuLnNlZWQ9dC5zZWVkLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKGUsdCl7aWYoXCJmbG9hdDMyXCIhPT0odD10fHxcImZsb2F0MzJcIikmJlwiaW50MzJcIiE9PXQpdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJ0cnVuY2F0ZWROb3JtYWwgZG9lcyBub3Qgc3VwcG9ydCBkVHlwZSBcIit0K1wiLlwiKTtyZXR1cm4gdHJ1bmNhdGVkTm9ybWFsKGUsdGhpcy5tZWFuLHRoaXMuc3RkZGV2LHQsdGhpcy5zZWVkKX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7cmV0dXJue21lYW46dGhpcy5tZWFuLHN0ZGRldjp0aGlzLnN0ZGRldixzZWVkOnRoaXMuc2VlZH19LHQuY2xhc3NOYW1lPVwiVHJ1bmNhdGVkTm9ybWFsXCIsdH0oSW5pdGlhbGl6ZXIpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhUcnVuY2F0ZWROb3JtYWwpO3ZhciBJZGVudGl0eT1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gbi5nYWluPW51bGwhPXQuZ2Fpbj9zY2FsYXIodC5nYWluKTpnZXRTY2FsYXIoMSksbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuYXBwbHk9ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7aWYoMiE9PWUubGVuZ3RofHxlWzBdIT09ZVsxXSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIklkZW50aXR5IG1hdHJpeCBpbml0aWFsaXplciBjYW4gb25seSBiZSB1c2VkIGZvciAyRCBzcXVhcmUgbWF0cmljZXMuXCIpO3JldHVybiBtdWwobi5nYWluLGV5ZShlWzBdKSl9KX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7cmV0dXJue2dhaW46dGhpcy5nYWluLmdldCgpfX0sdC5jbGFzc05hbWU9XCJJZGVudGl0eVwiLHR9KEluaXRpYWxpemVyKTtmdW5jdGlvbiBjb21wdXRlRmFucyhlLHQpe3ZhciBuLHI7aWYodm9pZCAwPT09dCYmKHQ9XCJjaGFubmVsc0xhc3RcIiksY2hlY2tEYXRhRm9ybWF0KHQpLDI9PT1lLmxlbmd0aCluPWVbMF0scj1lWzFdO2Vsc2UgaWYoLTEhPT1bMyw0LDVdLmluZGV4T2YoZS5sZW5ndGgpKXtpZihcImNoYW5uZWxzRmlyc3RcIj09PXQpe3ZhciBpPWFycmF5UHJvZChlLDIpO249ZVsxXSppLHI9ZVswXSppfWVsc2UgaWYoXCJjaGFubmVsc0xhc3RcIj09PXQpe2k9YXJyYXlQcm9kKGUsMCxlLmxlbmd0aC0yKTtuPWVbZS5sZW5ndGgtMl0qaSxyPWVbZS5sZW5ndGgtMV0qaX19ZWxzZXt2YXIgYT1hcnJheVByb2QoZSk7bj1NYXRoLnNxcnQoYSkscj1NYXRoLnNxcnQoYSl9cmV0dXJuW24scl19c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKElkZW50aXR5KTt2YXIgVmFyaWFuY2VTY2FsaW5nPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49ZS5jYWxsKHRoaXMpfHx0aGlzO2lmKHQuc2NhbGU8MCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcInNjYWxlIG11c3QgYmUgYSBwb3NpdGl2ZSBmbG9hdC4gR290OiBcIit0LnNjYWxlKTtyZXR1cm4gbi5zY2FsZT1udWxsPT10LnNjYWxlPzE6dC5zY2FsZSxuLm1vZGU9dC5tb2RlLGNoZWNrRmFuTW9kZShuLm1vZGUpLG4uZGlzdHJpYnV0aW9uPXQuZGlzdHJpYnV0aW9uLGNoZWNrRGlzdHJpYnV0aW9uKG4uZGlzdHJpYnV0aW9uKSxuLnNlZWQ9dC5zZWVkLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKGUsdCl7dmFyIG49Y29tcHV0ZUZhbnMoZSkscj1uWzBdLGk9blsxXSxhPXRoaXMuc2NhbGU7aWYoXCJmYW5JblwiPT09dGhpcy5tb2RlP2EvPU1hdGgubWF4KDEscik6XCJmYW5PdXRcIj09PXRoaXMubW9kZT9hLz1NYXRoLm1heCgxLGkpOmEvPU1hdGgubWF4KDEsKHIraSkvMiksXCJub3JtYWxcIj09PXRoaXMuZGlzdHJpYnV0aW9uKXt2YXIgbz1NYXRoLnNxcnQoYSk7aWYoXCJmbG9hdDMyXCIhPT0odD10fHxcImZsb2F0MzJcIikmJlwiaW50MzJcIiE9PXQpdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IodGhpcy5nZXRDbGFzc05hbWUoKStcIiBkb2VzIG5vdCBzdXBwb3J0IGRUeXBlIFwiK3QrXCIuXCIpO3JldHVybiB0cnVuY2F0ZWROb3JtYWwoZSwwLG8sdCx0aGlzLnNlZWQpfXZhciBzPU1hdGguc3FydCgzKmEpO3JldHVybiByYW5kb21Vbmlmb3JtKGUsLXMscyx0KX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7cmV0dXJue3NjYWxlOnRoaXMuc2NhbGUsbW9kZTp0aGlzLm1vZGUsZGlzdHJpYnV0aW9uOnRoaXMuZGlzdHJpYnV0aW9uLHNlZWQ6dGhpcy5zZWVkfX0sdC5jbGFzc05hbWU9XCJWYXJpYW5jZVNjYWxpbmdcIix0fShJbml0aWFsaXplcik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKFZhcmlhbmNlU2NhbGluZyk7dmFyIEdsb3JvdFVuaWZvcm09ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXtyZXR1cm4gZS5jYWxsKHRoaXMse3NjYWxlOjEsbW9kZTpcImZhbkF2Z1wiLGRpc3RyaWJ1dGlvbjpcInVuaWZvcm1cIixzZWVkOm51bGw9PXQ/bnVsbDp0LnNlZWR9KXx8dGhpc31yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lPWZ1bmN0aW9uKCl7cmV0dXJuIFZhcmlhbmNlU2NhbGluZy5jbGFzc05hbWV9LHQuY2xhc3NOYW1lPVwiR2xvcm90VW5pZm9ybVwiLHR9KFZhcmlhbmNlU2NhbGluZyk7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKEdsb3JvdFVuaWZvcm0pO3ZhciBHbG9yb3ROb3JtYWw9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXtyZXR1cm4gZS5jYWxsKHRoaXMse3NjYWxlOjEsbW9kZTpcImZhbkF2Z1wiLGRpc3RyaWJ1dGlvbjpcIm5vcm1hbFwiLHNlZWQ6bnVsbD09dD9udWxsOnQuc2VlZH0pfHx0aGlzfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5nZXRDbGFzc05hbWU9ZnVuY3Rpb24oKXtyZXR1cm4gVmFyaWFuY2VTY2FsaW5nLmNsYXNzTmFtZX0sdC5jbGFzc05hbWU9XCJHbG9yb3ROb3JtYWxcIix0fShWYXJpYW5jZVNjYWxpbmcpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhHbG9yb3ROb3JtYWwpO3ZhciBIZU5vcm1hbD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3JldHVybiBlLmNhbGwodGhpcyx7c2NhbGU6Mixtb2RlOlwiZmFuSW5cIixkaXN0cmlidXRpb246XCJub3JtYWxcIixzZWVkOm51bGw9PXQ/bnVsbDp0LnNlZWR9KXx8dGhpc31yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lPWZ1bmN0aW9uKCl7cmV0dXJuIFZhcmlhbmNlU2NhbGluZy5jbGFzc05hbWV9LHQuY2xhc3NOYW1lPVwiSGVOb3JtYWxcIix0fShWYXJpYW5jZVNjYWxpbmcpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhIZU5vcm1hbCk7dmFyIExlQ3VuTm9ybWFsPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7cmV0dXJuIGUuY2FsbCh0aGlzLHtzY2FsZToxLG1vZGU6XCJmYW5JblwiLGRpc3RyaWJ1dGlvbjpcIm5vcm1hbFwiLHNlZWQ6bnVsbD09dD9udWxsOnQuc2VlZH0pfHx0aGlzfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5nZXRDbGFzc05hbWU9ZnVuY3Rpb24oKXtyZXR1cm4gVmFyaWFuY2VTY2FsaW5nLmNsYXNzTmFtZX0sdC5jbGFzc05hbWU9XCJMZUN1bk5vcm1hbFwiLHR9KFZhcmlhbmNlU2NhbGluZyk7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKExlQ3VuTm9ybWFsKTt2YXIgT3J0aG9nb25hbD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzKXx8dGhpcztpZihuLkRFRkFVTFRfR0FJTj0xLG4uZ2Fpbj1udWxsPT10LmdhaW4/bi5ERUZBVUxUX0dBSU46dC5nYWluLG4uc2VlZD10LnNlZWQsbnVsbCE9bi5zZWVkKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwiUmFuZG9tIHNlZWQgaXMgbm90IGltcGxlbWVudGVkIGZvciBPcnRob2dvbmFsIEluaXRpYWxpemVyIHlldC5cIik7cmV0dXJuIG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe2lmKDIhPT1lLmxlbmd0aCl0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcIlRoZSBPcnRob2dvbmFsIEluaXRpYWxpemVyIGRvZXMgbm90IHN1cHBvcnQgbm9uLTJEIHNoYXBlcyB5ZXQuXCIpO2VbMF0qZVsxXT4yZTMmJmNvbnNvbGUud2FybihcIk9ydGhvZ29uYWwgaW5pdGlhbGl6ZXIgaXMgYmVpbmcgY2FsbGVkIG9uIGEgbWF0cml4IHdpdGggbW9yZSB0aGFuIDIwMDAgKFwiK2VbMF0qZVsxXStcIikgZWxlbWVudHM6IFNsb3duZXNzIG1heSByZXN1bHQuXCIpO3ZhciB0PXJhbmRvbU5vcm1hbCQxKGVbMF0+ZVsxXT9bZVsxXSxlWzBdXTplLDAsMSxcImZsb2F0MzJcIikscj1saW5hbGcuZ3JhbVNjaG1pZHQodCk7cmV0dXJuIGVbMF0+ZVsxXSYmKHI9ci50cmFuc3Bvc2UoKSksbXVsKGdldFNjYWxhcihuLmdhaW4pLHIpfSl9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3JldHVybntnYWluOnRoaXMuZ2FpbixzZWVkOnRoaXMuc2VlZH19LHQuY2xhc3NOYW1lPVwiT3J0aG9nb25hbFwiLHR9KEluaXRpYWxpemVyKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoT3J0aG9nb25hbCk7dmFyIElOSVRJQUxJWkVSX0lERU5USUZJRVJfUkVHSVNUUllfU1lNQk9MX01BUD17Y29uc3RhbnQ6XCJDb25zdGFudFwiLGdsb3JvdE5vcm1hbDpcIkdsb3JvdE5vcm1hbFwiLGdsb3JvdFVuaWZvcm06XCJHbG9yb3RVbmlmb3JtXCIsaGVOb3JtYWw6XCJIZU5vcm1hbFwiLGlkZW50aXR5OlwiSWRlbnRpdHlcIixsZUN1bk5vcm1hbDpcIkxlQ3VuTm9ybWFsXCIsb25lczpcIk9uZXNcIixvcnRob2dvbmFsOlwiT3J0aG9nb25hbFwiLHJhbmRvbU5vcm1hbDpcIlJhbmRvbU5vcm1hbFwiLHJhbmRvbVVuaWZvcm06XCJSYW5kb21Vbmlmb3JtXCIsdHJ1bmNhdGVkTm9ybWFsOlwiVHJ1bmNhdGVkTm9ybWFsXCIsdmFyaWFuY2VTY2FsaW5nOlwiVmFyaWFuY2VTY2FsaW5nXCIsemVyb3M6XCJaZXJvc1wifTtmdW5jdGlvbiBkZXNlcmlhbGl6ZUluaXRpYWxpemVyKGUsdCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PXt9KSxkZXNlcmlhbGl6ZUtlcmFzT2JqZWN0KGUsc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLmdldE1hcCgpLmNsYXNzTmFtZU1hcCx0LFwiaW5pdGlhbGl6ZXJcIil9ZnVuY3Rpb24gc2VyaWFsaXplSW5pdGlhbGl6ZXIoZSl7cmV0dXJuIHNlcmlhbGl6ZUtlcmFzT2JqZWN0KGUpfWZ1bmN0aW9uIGdldEluaXRpYWxpemVyKGUpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlKXt2YXIgdD1lIGluIElOSVRJQUxJWkVSX0lERU5USUZJRVJfUkVHSVNUUllfU1lNQk9MX01BUD9JTklUSUFMSVpFUl9JREVOVElGSUVSX1JFR0lTVFJZX1NZTUJPTF9NQVBbZV06ZTtyZXR1cm5cIkdsb3JvdFVuaWZvcm1cIj09PXQ/bmV3IEdsb3JvdFVuaWZvcm06XCJHbG9yb3ROb3JtYWxcIj09PXQ/bmV3IEdsb3JvdE5vcm1hbDpcIkhlTm9ybWFsXCI9PT10P25ldyBIZU5vcm1hbDpcIkxlQ3VuTm9ybWFsXCI9PT10P25ldyBMZUN1bk5vcm1hbDpkZXNlcmlhbGl6ZUluaXRpYWxpemVyKHtjbGFzc05hbWU6dCxjb25maWc6e319KX1yZXR1cm4gZSBpbnN0YW5jZW9mIEluaXRpYWxpemVyP2U6ZGVzZXJpYWxpemVJbml0aWFsaXplcihlKX1mdW5jdGlvbiB6ZXJvcyQxKCl7cmV0dXJuIG5ldyBaZXJvc31mdW5jdGlvbiBvbmVzJDEoKXtyZXR1cm4gbmV3IE9uZXN9ZnVuY3Rpb24gY29uc3RhbnQoZSl7cmV0dXJuIG5ldyBDb25zdGFudChlKX1mdW5jdGlvbiByYW5kb21Vbmlmb3JtJDEoZSl7cmV0dXJuIG5ldyBSYW5kb21Vbmlmb3JtKGUpfWZ1bmN0aW9uIHJhbmRvbU5vcm1hbCQyKGUpe3JldHVybiBuZXcgUmFuZG9tTm9ybWFsKGUpfWZ1bmN0aW9uIHRydW5jYXRlZE5vcm1hbCQxKGUpe3JldHVybiBuZXcgVHJ1bmNhdGVkTm9ybWFsKGUpfWZ1bmN0aW9uIGlkZW50aXR5KGUpe3JldHVybiBuZXcgSWRlbnRpdHkoZSl9ZnVuY3Rpb24gdmFyaWFuY2VTY2FsaW5nKGUpe3JldHVybiBuZXcgVmFyaWFuY2VTY2FsaW5nKGUpfWZ1bmN0aW9uIGdsb3JvdFVuaWZvcm0oZSl7cmV0dXJuIG5ldyBHbG9yb3RVbmlmb3JtKGUpfWZ1bmN0aW9uIGdsb3JvdE5vcm1hbChlKXtyZXR1cm4gbmV3IEdsb3JvdE5vcm1hbChlKX1mdW5jdGlvbiBoZU5vcm1hbChlKXtyZXR1cm4gbmV3IEhlTm9ybWFsKGUpfWZ1bmN0aW9uIGxlQ3VuTm9ybWFsKGUpe3JldHVybiBuZXcgTGVDdW5Ob3JtYWwoZSl9ZnVuY3Rpb24gb3J0aG9nb25hbChlKXtyZXR1cm4gbmV3IE9ydGhvZ29uYWwoZSl9dmFyIGV4cG9ydHNfaW5pdGlhbGl6ZXJzPU9iamVjdC5mcmVlemUoe3plcm9zOnplcm9zJDEsb25lczpvbmVzJDEsY29uc3RhbnQ6Y29uc3RhbnQscmFuZG9tVW5pZm9ybTpyYW5kb21Vbmlmb3JtJDEscmFuZG9tTm9ybWFsOnJhbmRvbU5vcm1hbCQyLHRydW5jYXRlZE5vcm1hbDp0cnVuY2F0ZWROb3JtYWwkMSxpZGVudGl0eTppZGVudGl0eSx2YXJpYW5jZVNjYWxpbmc6dmFyaWFuY2VTY2FsaW5nLGdsb3JvdFVuaWZvcm06Z2xvcm90VW5pZm9ybSxnbG9yb3ROb3JtYWw6Z2xvcm90Tm9ybWFsLGhlTm9ybWFsOmhlTm9ybWFsLGxlQ3VuTm9ybWFsOmxlQ3VuTm9ybWFsLG9ydGhvZ29uYWw6b3J0aG9nb25hbH0pO2Z1bmN0aW9uIGlzQXJyYXlPZlNoYXBlcyhlKXtyZXR1cm4gQXJyYXkuaXNBcnJheShlKSYmQXJyYXkuaXNBcnJheShlWzBdKX1mdW5jdGlvbiBub3JtYWxpemVTaGFwZUxpc3QoZSl7cmV0dXJuIDA9PT1lLmxlbmd0aD9bXTpBcnJheS5pc0FycmF5KGVbMF0pP2U6W2VdfWZ1bmN0aW9uIGdldEV4YWN0bHlPbmVUZW5zb3IoZSl7dmFyIHQ7aWYoQXJyYXkuaXNBcnJheShlKSl7aWYoMSE9PWUubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiRXhwZWN0ZWQgVGVuc29yIGxlbmd0aCB0byBiZSAxOyBnb3QgXCIrZS5sZW5ndGgpO3Q9ZVswXX1lbHNlIHQ9ZTtyZXR1cm4gdH1mdW5jdGlvbiBnZXRFeGFjdGx5T25lU2hhcGUoZSl7aWYoQXJyYXkuaXNBcnJheShlKSYmQXJyYXkuaXNBcnJheShlWzBdKSl7aWYoMT09PWUubGVuZ3RoKXJldHVybihlPWUpWzBdO3Rocm93IG5ldyBWYWx1ZUVycm9yKFwiRXhwZWN0ZWQgZXhhY3RseSAxIFNoYXBlOyBnb3QgXCIrZS5sZW5ndGgpfXJldHVybiBlfWZ1bmN0aW9uIGNvdW50UGFyYW1zSW5XZWlnaHRzKGUpe2Zvcih2YXIgdD0wLG49MCxyPWU7bjxyLmxlbmd0aDtuKyspe3ZhciBpPXJbbl07MD09PWkuc2hhcGUubGVuZ3RoP3QrPTE6dCs9aS5zaGFwZS5yZWR1Y2UoZnVuY3Rpb24oZSx0KXtyZXR1cm4gZSp0fSl9cmV0dXJuIHR9dmFyIERFRkFVTFRfVkFSSUFCTEVfTkFNRV9QUkVGSVg9XCJWYXJpYWJsZVwiLExheWVyVmFyaWFibGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCxuLHIsaSl7dm9pZCAwPT09dCYmKHQ9XCJmbG9hdDMyXCIpLHZvaWQgMD09PW4mJihuPURFRkFVTFRfVkFSSUFCTEVfTkFNRV9QUkVGSVgpLHZvaWQgMD09PXImJihyPSEwKSx2b2lkIDA9PT1pJiYoaT1udWxsKSx0aGlzLmR0eXBlPW51bGw9PXQ/XCJmbG9hdDMyXCI6dCx0aGlzLnNoYXBlPWUuc2hhcGUsdGhpcy5pZD1nZXROZXh0VW5pcXVlVGVuc29ySWQoKSxuPW51bGw9PW4/REVGQVVMVF9WQVJJQUJMRV9OQU1FX1BSRUZJWDpuLHRoaXMub3JpZ2luYWxOYW1lPWdldFNjb3BlZFRlbnNvck5hbWUobiksdGhpcy5uYW1lPWdldFVuaXF1ZVRlbnNvck5hbWUodGhpcy5vcmlnaW5hbE5hbWUpLHRoaXMudHJhaW5hYmxlPXIsdGhpcy5jb25zdHJhaW50PWksdGhpcy52YWw9dmFyaWFibGUoZSx0aGlzLnRyYWluYWJsZSx0aGlzLm5hbWUsdGhpcy5kdHlwZSl9cmV0dXJuIGUucHJvdG90eXBlLnJlYWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hc3NlcnROb3REaXNwb3NlZCgpLHRoaXMudmFsfSxlLnByb3RvdHlwZS53cml0ZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5hc3NlcnROb3REaXNwb3NlZCgpLGNoZWNrU2hhcGVzTWF0Y2godGhpcy52YWwsZSksdGhpcy52YWwuaWQhPT1lLmlkJiYodGhpcy52YWwuYXNzaWduKGUpLG51bGwhPXRoaXMuY29uc3RyYWludCYmdGhpcy52YWwuYXNzaWduKHRoaXMuY29uc3RyYWludC5hcHBseSh0aGlzLnZhbCkpKSx0aGlzfSxlLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7dGhpcy5hc3NlcnROb3REaXNwb3NlZCgpLHRoaXMudmFsLmRpc3Bvc2UoKX0sZS5wcm90b3R5cGUuYXNzZXJ0Tm90RGlzcG9zZWQ9ZnVuY3Rpb24oKXtpZih0aGlzLnZhbC5pc0Rpc3Bvc2VkKXRocm93IG5ldyBFcnJvcihcIkxheWVyc1ZhcmlhYmxlIFwiK3RoaXMubmFtZStcIiBpcyBhbHJlYWR5IGRpc3Bvc2VkLlwiKX0sZX0oKTtmdW5jdGlvbiBjaGVja1NoYXBlc01hdGNoKGUsdCl7aWYoZS5zaGFwZS50b1N0cmluZygpIT09dC5zaGFwZS50b1N0cmluZygpKXRocm93IG5ldyBFcnJvcihcIlNoYXBlIG1pc21hdGNoOiBcIitKU09OLnN0cmluZ2lmeShlLnNoYXBlKStcIiB2cy4gXCIrSlNPTi5zdHJpbmdpZnkodC5zaGFwZSkpfWZ1bmN0aW9uIGJhdGNoR2V0VmFsdWUoZSl7cmV0dXJuIGUubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLnJlYWQoKX0pfWZ1bmN0aW9uIGJhdGNoU2V0VmFsdWUoZSl7ZS5tYXAoZnVuY3Rpb24oZSl7ZVswXS53cml0ZShlWzFdKX0pfXZhciBJbnB1dFNwZWM9ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oZSl7dGhpcy5kdHlwZT1lLmR0eXBlLHRoaXMuc2hhcGU9ZS5zaGFwZSxudWxsIT1lLnNoYXBlP3RoaXMubmRpbT1lLnNoYXBlLmxlbmd0aDp0aGlzLm5kaW09ZS5uZGltLHRoaXMubWF4TkRpbT1lLm1heE5EaW0sdGhpcy5taW5ORGltPWUubWluTkRpbSx0aGlzLmF4ZXM9ZS5heGVzfHx7fX19KCksU3ltYm9saWNUZW5zb3I9ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oZSx0LG4scixpLGEsbyl7dGhpcy5kdHlwZT1lLHRoaXMuc2hhcGU9dCx0aGlzLnNvdXJjZUxheWVyPW4sdGhpcy5pbnB1dHM9cix0aGlzLmNhbGxBcmdzPWksdGhpcy5vdXRwdXRUZW5zb3JJbmRleD1vLHRoaXMuaWQ9Z2V0TmV4dFVuaXF1ZVRlbnNvcklkKCksbnVsbCE9YSYmKHRoaXMub3JpZ2luYWxOYW1lPWdldFNjb3BlZFRlbnNvck5hbWUoYSksdGhpcy5uYW1lPWdldFVuaXF1ZVRlbnNvck5hbWUodGhpcy5vcmlnaW5hbE5hbWUpKSx0aGlzLnJhbms9dC5sZW5ndGh9fSgpLF9uZXh0Tm9kZUlEPTAsTm9kZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0KXt0aGlzLmNhbGxBcmdzPXQsdGhpcy5pZD1fbmV4dE5vZGVJRCsrLHRoaXMub3V0Ym91bmRMYXllcj1lLm91dGJvdW5kTGF5ZXIsdGhpcy5pbmJvdW5kTGF5ZXJzPWUuaW5ib3VuZExheWVycyx0aGlzLm5vZGVJbmRpY2VzPWUubm9kZUluZGljZXMsdGhpcy50ZW5zb3JJbmRpY2VzPWUudGVuc29ySW5kaWNlcyx0aGlzLmlucHV0VGVuc29ycz1lLmlucHV0VGVuc29ycyx0aGlzLm91dHB1dFRlbnNvcnM9ZS5vdXRwdXRUZW5zb3JzLHRoaXMuaW5wdXRNYXNrcz1lLmlucHV0TWFza3MsdGhpcy5vdXRwdXRNYXNrcz1lLm91dHB1dE1hc2tzLHRoaXMuaW5wdXRTaGFwZXM9ZS5pbnB1dFNoYXBlcyx0aGlzLm91dHB1dFNoYXBlcz1lLm91dHB1dFNoYXBlcztmb3IodmFyIG49MCxyPWUuaW5ib3VuZExheWVycztuPHIubGVuZ3RoO24rKyl7dmFyIGk9cltuXTtudWxsIT1pJiZpLm91dGJvdW5kTm9kZXMucHVzaCh0aGlzKX1lLm91dGJvdW5kTGF5ZXIuaW5ib3VuZE5vZGVzLnB1c2godGhpcyl9cmV0dXJuIGUucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe2Zvcih2YXIgZT1bXSx0PTAsbj10aGlzLmluYm91bmRMYXllcnM7dDxuLmxlbmd0aDt0Kyspe3ZhciByPW5bdF07bnVsbCE9cj9lLnB1c2goci5uYW1lKTplLnB1c2gobnVsbCl9cmV0dXJue291dGJvdW5kTGF5ZXI6dGhpcy5vdXRib3VuZExheWVyP3RoaXMub3V0Ym91bmRMYXllci5uYW1lOm51bGwsaW5ib3VuZExheWVyczplLG5vZGVJbmRpY2VzOnRoaXMubm9kZUluZGljZXMsdGVuc29ySW5kaWNlczp0aGlzLnRlbnNvckluZGljZXN9fSxlfSgpLF9uZXh0TGF5ZXJJRD0wLExheWVyPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49ZS5jYWxsKHRoaXMpfHx0aGlzO24uX2NhbGxIb29rPW51bGwsbi5fYWRkZWRXZWlnaHROYW1lcz1bXSxuLl9zdGF0ZWZ1bD0hMSxuLmlkPV9uZXh0TGF5ZXJJRCsrLG4uYWN0aXZpdHlSZWd1bGFyaXplcj1udWxsLG4uaW5wdXRTcGVjPW51bGwsbi5zdXBwb3J0c01hc2tpbmc9ITEsbi5fdHJhaW5hYmxlV2VpZ2h0cz1bXSxuLl9ub25UcmFpbmFibGVXZWlnaHRzPVtdLG4uX2xvc3Nlcz1bXSxuLl91cGRhdGVzPVtdLG4uX2J1aWx0PSExLG4uaW5ib3VuZE5vZGVzPVtdLG4ub3V0Ym91bmROb2Rlcz1bXTt2YXIgcj10Lm5hbWU7aWYoIXIpe3ZhciBpPW4uZ2V0Q2xhc3NOYW1lKCk7cj10b1NuYWtlQ2FzZShpKStcIl9cIitnZXRVaWQoaSl9aWYobi5uYW1lPXIsbi50cmFpbmFibGU9bnVsbD09dC50cmFpbmFibGV8fHQudHJhaW5hYmxlLG4udXBkYXRhYmxlPW51bGw9PXQudXBkYXRhYmxlfHx0LnVwZGF0YWJsZSxudWxsIT10LmlucHV0U2hhcGV8fG51bGwhPXQuYmF0Y2hJbnB1dFNoYXBlKXt2YXIgYT12b2lkIDA7aWYobnVsbCE9dC5iYXRjaElucHV0U2hhcGUpYT10LmJhdGNoSW5wdXRTaGFwZTtlbHNlIGlmKG51bGwhPXQuaW5wdXRTaGFwZSl7dmFyIG89bnVsbDtudWxsIT10LmJhdGNoU2l6ZSYmKG89dC5iYXRjaFNpemUpLGE9W29dLmNvbmNhdCh0LmlucHV0U2hhcGUpfW4uYmF0Y2hJbnB1dFNoYXBlPWE7dmFyIHM9dC5kdHlwZTtudWxsPT1zJiYocz10LmlucHV0RFR5cGUpLG51bGw9PXMmJihzPVwiZmxvYXQzMlwiKSxuLmR0eXBlPXN9cmV0dXJuIG51bGwhPXQud2VpZ2h0cz9uLmluaXRpYWxXZWlnaHRzPXQud2VpZ2h0czpuLmluaXRpYWxXZWlnaHRzPW51bGwsbi5fcmVmQ291bnQ9bnVsbCxufXJldHVybiBfX2V4dGVuZHModCxlKSx0Lm5vZGVLZXk9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS5uYW1lK1wiX2liLVwiK3QudG9TdHJpbmcoKX0sdC5wcm90b3R5cGUuZ2V0Tm9kZUF0SW5kZXg9ZnVuY3Rpb24oZSx0KXtpZigwPT09dGhpcy5pbmJvdW5kTm9kZXMubGVuZ3RoKXRocm93IG5ldyBSdW50aW1lRXJyb3IoXCJUaGUgbGF5ZXIgaGFzIG5ldmVyIGJlZW4gY2FsbGVkIGFuZCB0aHVzIGhhcyBubyBkZWZpbmVkIFwiK3QrXCIuXCIpO2lmKHRoaXMuaW5ib3VuZE5vZGVzLmxlbmd0aDw9ZSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkFza2VkIHRvIGdldCBcIit0K1wiIGF0IG5vZGUgXCIrZStcIiwgYnV0IHRoZSBsYXllciBoYXMgb25seSBcIit0aGlzLmluYm91bmROb2Rlcy5sZW5ndGgrXCIgaW5ib3VuZCBub2Rlcy5cIik7cmV0dXJuIHRoaXMuaW5ib3VuZE5vZGVzW2VdfSx0LnByb3RvdHlwZS5nZXRJbnB1dEF0PWZ1bmN0aW9uKGUpe3JldHVybiBzaW5nbGV0b25PckFycmF5KHRoaXMuZ2V0Tm9kZUF0SW5kZXgoZSxcImlucHV0XCIpLmlucHV0VGVuc29ycyl9LHQucHJvdG90eXBlLmdldE91dHB1dEF0PWZ1bmN0aW9uKGUpe3JldHVybiBzaW5nbGV0b25PckFycmF5KHRoaXMuZ2V0Tm9kZUF0SW5kZXgoZSxcIm91dHB1dFwiKS5vdXRwdXRUZW5zb3JzKX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwiaW5wdXRcIix7Z2V0OmZ1bmN0aW9uKCl7aWYodGhpcy5pbmJvdW5kTm9kZXMubGVuZ3RoPjEpdGhyb3cgbmV3IEF0dHJpYnV0ZUVycm9yKFwiTGF5ZXIgXCIrdGhpcy5uYW1lKycgaGFzIG11bHRpcGxlIGluYm91bmQgbm9kZXMsIGhlbmNlIHRoZSBub3Rpb24gb2YgXCJsYXllciBpbnB1dFwiIGlzIGlsbC1kZWZpbmVkLiBVc2UgYGdldElucHV0QXQobm9kZUluZGV4KWAgaW5zdGVhZC4nKTtpZigwPT09dGhpcy5pbmJvdW5kTm9kZXMubGVuZ3RoKXRocm93IG5ldyBBdHRyaWJ1dGVFcnJvcihcIkxheWVyIFwiK3RoaXMubmFtZStcIiBpcyBub3QgY29ubmVjdGVkLCBubyBpbnB1dCB0byByZXR1cm4uXCIpO3JldHVybiBzaW5nbGV0b25PckFycmF5KHRoaXMuZ2V0Tm9kZUF0SW5kZXgoMCxcImlucHV0XCIpLmlucHV0VGVuc29ycyl9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwib3V0cHV0XCIse2dldDpmdW5jdGlvbigpe2lmKDA9PT10aGlzLmluYm91bmROb2Rlcy5sZW5ndGgpdGhyb3cgbmV3IEF0dHJpYnV0ZUVycm9yKFwiTGF5ZXIgXCIrdGhpcy5uYW1lK1wiIGhhcyBubyBpbmJvdW5kIG5vZGVzLlwiKTtpZih0aGlzLmluYm91bmROb2Rlcy5sZW5ndGg+MSl0aHJvdyBuZXcgQXR0cmlidXRlRXJyb3IoXCJMYXllciBcIit0aGlzLm5hbWUrJyBoYXMgbXVsdGlwbGUgaW5ib3VuZCBub2RlcywgaGVuY2UgdGhlIG5vdGlvbiBvZiBcImxheWVyIG91dHB1dFwiIGlzIGlsbC1kZWZpbmVkLiBVc2UgYGdldE91dHB1dEF0KG5vZGVJbmRleClgIGluc3RlYWQuJyk7cmV0dXJuIHNpbmdsZXRvbk9yQXJyYXkodGhpcy5nZXROb2RlQXRJbmRleCgwLFwib3V0cHV0XCIpLm91dHB1dFRlbnNvcnMpfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImxvc3Nlc1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbG9zc2VzfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLHQucHJvdG90eXBlLmNhbGN1bGF0ZUxvc3Nlcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmxvc3Nlcy5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUoKX0pfSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJ1cGRhdGVzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl91cGRhdGVzfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImJ1aWx0XCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9idWlsdH0sc2V0OmZ1bmN0aW9uKGUpe3RoaXMuX2J1aWx0PWV9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwidHJhaW5hYmxlV2VpZ2h0c1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50cmFpbmFibGU/dGhpcy5fdHJhaW5hYmxlV2VpZ2h0czpbXX0sc2V0OmZ1bmN0aW9uKGUpe3RoaXMuX3RyYWluYWJsZVdlaWdodHM9ZX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJub25UcmFpbmFibGVXZWlnaHRzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnRyYWluYWJsZT90aGlzLl9ub25UcmFpbmFibGVXZWlnaHRzOnRoaXMuX3RyYWluYWJsZVdlaWdodHMuY29uY2F0KHRoaXMuX25vblRyYWluYWJsZVdlaWdodHMpfSxzZXQ6ZnVuY3Rpb24oZSl7dGhpcy5fbm9uVHJhaW5hYmxlV2VpZ2h0cz1lfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcIndlaWdodHNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudHJhaW5hYmxlV2VpZ2h0cy5jb25jYXQodGhpcy5ub25UcmFpbmFibGVXZWlnaHRzKX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJzdGF0ZWZ1bFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc3RhdGVmdWx9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksdC5wcm90b3R5cGUucmVzZXRTdGF0ZXM9ZnVuY3Rpb24oKXtpZighdGhpcy5zdGF0ZWZ1bCl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCB0aGUgcmVzZXRTdGF0ZXMoKSBtZXRob2Qgb2YgYSBub24tc3RhdGVmdWwgTGF5ZXIgb2JqZWN0LlwiKX0sdC5wcm90b3R5cGUuYXNzZXJ0SW5wdXRDb21wYXRpYmlsaXR5PWZ1bmN0aW9uKGUpe2lmKGU9dG9MaXN0KGUpLG51bGwhPXRoaXMuaW5wdXRTcGVjJiYwIT09dGhpcy5pbnB1dFNwZWMubGVuZ3RoKXt2YXIgdD10b0xpc3QodGhpcy5pbnB1dFNwZWMpO2lmKGUubGVuZ3RoIT09dC5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJMYXllciBcIit0aGlzLm5hbWUrXCIgZXhwZWN0cyBcIit0Lmxlbmd0aCtcIiBpbnB1dHMsIGJ1dCBpdCByZWNlaXZlZCBcIitlLmxlbmd0aCtcIiBpbnB1dCB0ZW5zb3JzLiBJbnB1dCByZWNlaXZlZDogXCIrZSk7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciByPWVbbl0saT10W25dO2lmKG51bGwhPWkpe3ZhciBhPXIucmFuaztpZihudWxsIT1pLm5kaW0mJmEhPT1pLm5kaW0pdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJJbnB1dCBcIituK1wiIGlzIGluY29tcGF0aWJsZSB3aXRoIGxheWVyIFwiK3RoaXMubmFtZStcIjogZXhwZWN0ZWQgbmRpbT1cIitpLm5kaW0rXCIsIGZvdW5kIG5kaW09XCIrYSk7aWYobnVsbCE9aS5tYXhORGltJiZhPmkubWF4TkRpbSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIklucHV0IFwiK24rXCIgaXMgaW5jb21wYXRpYmxlIHdpdGggbGF5ZXIgXCIrdGhpcy5uYW1lK1wiOiBleHBlY3RlZCBtYXhfbmRpbT1cIitpLm1heE5EaW0rXCIsIGZvdW5kIG5kaW09XCIrYSk7aWYobnVsbCE9aS5taW5ORGltJiZhPGkubWluTkRpbSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIklucHV0IFwiK24rXCIgaXMgaW5jb21wYXRpYmxlIHdpdGggbGF5ZXIgXCIrdGhpcy5uYW1lK1wiOiBleHBlY3RlZCBtaW5fbmRpbT1cIitpLm1pbk5EaW0rXCIsIGZvdW5kIG5kaW09XCIrYStcIi5cIik7aWYobnVsbCE9aS5kdHlwZSYmci5kdHlwZSE9PWkuZHR5cGUpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJJbnB1dCBcIituK1wiIGlzIGluY29tcGF0aWJsZSB3aXRoIGxheWVyIFwiK3RoaXMubmFtZStcIiA6IGV4cGVjdGVkIGR0eXBlPVwiK2kuZHR5cGUrXCIsIGZvdW5kIGR0eXBlPVwiK3IuZHR5cGUrXCIuXCIpO2lmKGkuYXhlcyl7dmFyIG89ci5zaGFwZTtmb3IodmFyIHMgaW4gaS5heGVzKXt2YXIgbD1OdW1iZXIocyksdT1pLmF4ZXNbc10sYz1sPj0wP29bbF06b1tvLmxlbmd0aCtsXTtpZihudWxsIT11JiYtMT09PVt1LG51bGxdLmluZGV4T2YoYykpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJJbnB1dCBcIituK1wiIGlzIGluY29tcGF0aWJsZSB3aXRoIGxheWVyIFwiK3RoaXMubmFtZStcIjogZXhwZWN0ZWQgYXhpcyBcIitsK1wiIG9mIGlucHV0IHNoYXBlIHRvIGhhdmUgdmFsdWUgXCIrdStcIiBidXQgZ290IHNoYXBlIFwiK28rXCIuXCIpfX1pZihudWxsIT1pLnNoYXBlKWZvcih2YXIgcD0wO3A8aS5zaGFwZS5sZW5ndGg7KytwKXt2YXIgaD1pLnNoYXBlW3BdLGQ9ci5zaGFwZVtwXTtpZihudWxsIT1oJiZudWxsIT1kJiZoIT09ZCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIklucHV0IFwiK24rXCIgaXMgaW5jb21wYXRpYmxlIHdpdGggbGF5ZXIgXCIrdGhpcy5uYW1lK1wiOiBleHBlY3RlZCBzaGFwZT1cIitpLnNoYXBlK1wiLCBmb3VuZCBzaGFwZT0ke3hTaGFwZX0uXCIpfX19fX0sdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihlLHQpe3JldHVybiBlfSx0LnByb3RvdHlwZS5pbnZva2VDYWxsSG9vaz1mdW5jdGlvbihlLHQpe251bGwhPXRoaXMuX2NhbGxIb29rJiZ0aGlzLl9jYWxsSG9vayhlLHQpfSx0LnByb3RvdHlwZS5zZXRDYWxsSG9vaz1mdW5jdGlvbihlKXt0aGlzLl9jYWxsSG9vaz1lfSx0LnByb3RvdHlwZS5jbGVhckNhbGxIb29rPWZ1bmN0aW9uKCl7dGhpcy5fY2FsbEhvb2s9bnVsbH0sdC5wcm90b3R5cGUuYXBwbHk9ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3Q9dHx8e30sdGhpcy5hc3NlcnROb3REaXNwb3NlZCgpO2Zvcih2YXIgcj10b0xpc3QoZSksaT0hMCxhPTAsbz1yO2E8by5sZW5ndGg7YSsrKXtpZighKG9bYV1pbnN0YW5jZW9mIFN5bWJvbGljVGVuc29yKSl7aT0hMTticmVha319Zm9yKHZhciBzPSEwLGw9MCx1PXI7bDx1Lmxlbmd0aDtsKyspe2lmKHVbbF1pbnN0YW5jZW9mIFN5bWJvbGljVGVuc29yKXtzPSExO2JyZWFrfX1pZihpPT09cyl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkFyZ3VtZW50cyB0byBhcHBseSgpIG11c3QgYmUgYWxsIFN5bWJvbGljVGVuc29ycyBvciBhbGwgVGVuc29yc1wiKTtyZXR1cm4gbmFtZVNjb3BlKHRoaXMubmFtZSxmdW5jdGlvbigpe2lmKCFuLmJ1aWx0KXtuLmFzc2VydElucHV0Q29tcGF0aWJpbGl0eShlKTtmb3IodmFyIGk9W10sYT0wLG89dG9MaXN0KGUpO2E8by5sZW5ndGg7YSsrKXt2YXIgbD1vW2FdO2kucHVzaChsLnNoYXBlKX1uLmJ1aWxkKHNpbmdsZXRvbk9yQXJyYXkoaSkpLG4uYnVpbHQ9ITAsbi5pbml0aWFsV2VpZ2h0cyYmbi5zZXRXZWlnaHRzKG4uaW5pdGlhbFdlaWdodHMpLG51bGw9PT1uLl9yZWZDb3VudCYmcyYmKG4uX3JlZkNvdW50PTEpfWlmKG4uYXNzZXJ0SW5wdXRDb21wYXRpYmlsaXR5KGUpLHMpe2Zvcih2YXIgdT1bXSxjPTAscD10b0xpc3QoZz1uLmNhbGwoZSx0KSk7YzxwLmxlbmd0aDtjKyspe3ZhciBoPXBbY107LTEhPT1yLmluZGV4T2YoaCkmJihoPWguY2xvbmUoKSksdS5wdXNoKGgpfWlmKGc9c2luZ2xldG9uT3JBcnJheSh1KSxudWxsIT1uLmFjdGl2aXR5UmVndWxhcml6ZXIpdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJMYXllciBpbnZvY2F0aW9uIGluIHRoZSBwcmVzZW5jZSBvZiBhY3Rpdml0eSByZWd1bGFyaXplcihzKSBpcyBub3Qgc3VwcG9ydGVkIHlldC5cIik7cmV0dXJuIGd9dmFyIGQ9Y29sbGVjdElucHV0U2hhcGUoZSksZj1uLmNvbXB1dGVPdXRwdXRTaGFwZShkKSxnPXZvaWQgMCxtPWd1ZXNzT3V0cHV0RFR5cGUoZSk7aWYobi53YXJuT25JbmNvbXBhdGlibGVJbnB1dFNoYXBlKEFycmF5LmlzQXJyYXkoZSk/ZFswXTpkKSxnPW51bGwhPWYmJmYubGVuZ3RoPjAmJkFycmF5LmlzQXJyYXkoZlswXSk/Zi5tYXAoZnVuY3Rpb24ocixpKXtyZXR1cm4gbmV3IFN5bWJvbGljVGVuc29yKG0scixuLHRvTGlzdChlKSx0LG4ubmFtZSxpKX0pOm5ldyBTeW1ib2xpY1RlbnNvcihtLGYsbix0b0xpc3QoZSksdCxuLm5hbWUpLG4uYWRkSW5ib3VuZE5vZGUoZSxnLG51bGwsbnVsbCxkLGYsdCksbi5fcmVmQ291bnQrKyxudWxsIT1uLmFjdGl2aXR5UmVndWxhcml6ZXIpdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJMYXllciBpbnZvY2F0aW9uIGluIHRoZSBwcmVzZW5jZSBvZiBhY3Rpdml0eSByZWd1bGFyaXplcihzKSBpcyBub3Qgc3VwcG9ydGVkIHlldC5cIik7cmV0dXJuIGd9KX0sdC5wcm90b3R5cGUud2Fybk9uSW5jb21wYXRpYmxlSW5wdXRTaGFwZT1mdW5jdGlvbihlKXtpZihudWxsIT10aGlzLmJhdGNoSW5wdXRTaGFwZSlpZihlLmxlbmd0aCE9PXRoaXMuYmF0Y2hJbnB1dFNoYXBlLmxlbmd0aCljb25zb2xlLndhcm4oXCJUaGUgcmFuayBvZiB0aGUgaW5wdXQgdGVuc29yIHByb3ZpZGVkIChzaGFwZTogXCIrSlNPTi5zdHJpbmdpZnkoZSkrXCIpIGRvZXMgbm90IG1hdGNoIHRoYXQgb2YgdGhlIGJhdGNoSW5wdXRTaGFwZSAoXCIrSlNPTi5zdHJpbmdpZnkodGhpcy5iYXRjaElucHV0U2hhcGUpK1wiKSBvZiB0aGUgbGF5ZXIgXCIrdGhpcy5uYW1lKTtlbHNle3ZhciB0PSExO3RoaXMuYmF0Y2hJbnB1dFNoYXBlLmZvckVhY2goZnVuY3Rpb24obixyKXtudWxsIT1uJiZudWxsIT1lW3JdJiZlW3JdIT09biYmKHQ9ITApfSksdCYmY29uc29sZS53YXJuKFwiVGhlIHNoYXBlIG9mIHRoZSBpbnB1dCB0ZW5zb3IgKFwiK0pTT04uc3RyaW5naWZ5KGUpK1wiKSBkb2VzIG5vdCBtYXRjaCB0aGUgZXhwZWN0YXRpb24gb2YgbGF5ZXIgXCIrdGhpcy5uYW1lK1wiOiBcIitKU09OLnN0cmluZ2lmeSh0aGlzLmJhdGNoSW5wdXRTaGFwZSkpfX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwib3V0cHV0U2hhcGVcIix7Z2V0OmZ1bmN0aW9uKCl7aWYobnVsbD09dGhpcy5pbmJvdW5kTm9kZXN8fDA9PT10aGlzLmluYm91bmROb2Rlcy5sZW5ndGgpdGhyb3cgbmV3IEF0dHJpYnV0ZUVycm9yKFwiVGhlIGxheWVyIFwiK3RoaXMubmFtZStcIiBoYXMgbmV2ZXIgYmVlbiBjYWxsZWQgYW5kIHRodXMgaGFzIG5vIGRlZmluZWQgb3V0cHV0IHNoYXBlLlwiKTtmb3IodmFyIGU9W10sdD0wLG49dGhpcy5pbmJvdW5kTm9kZXM7dDxuLmxlbmd0aDt0Kyspe3ZhciByPW5bdF0saT1KU09OLnN0cmluZ2lmeShyLm91dHB1dFNoYXBlcyk7LTE9PT1lLmluZGV4T2YoaSkmJmUucHVzaChpKX1pZigxPT09ZS5sZW5ndGgpe3ZhciBhPXRoaXMuaW5ib3VuZE5vZGVzWzBdLm91dHB1dFNoYXBlcztyZXR1cm4gQXJyYXkuaXNBcnJheShhKSYmQXJyYXkuaXNBcnJheShhWzBdKSYmMT09PWEubGVuZ3RoP2FbMF06YX10aHJvdyBuZXcgQXR0cmlidXRlRXJyb3IoXCJUaGUgbGF5ZXIgXCIrdGhpcy5uYW1lKycgaGFzIG11bHRpcGxlIGluYm91bmQgbm9kZXMgd2l0aCBkaWZmZXJlbnQgb3V0cHV0IHNoYXBlcy4gSGVuY2UgdGhlIG5vdGlvbiBvZiBcIm91dHV0IHNoYXBlXCIgaXMgaWxsLWRlZmluZWQgZm9yIHRoZSBsYXllci4nKX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSx0LnByb3RvdHlwZS5jb3VudFBhcmFtcz1mdW5jdGlvbigpe2lmKCF0aGlzLmJ1aWx0KXRocm93IG5ldyBSdW50aW1lRXJyb3IoXCJZb3UgdHJpZWQgdG8gY2FsbCBjb3VudFBhcmFtcygpIG9uIFwiK3RoaXMubmFtZStcIiwgYnV0IHRoZSBsYXllciBpcyBub3QgYnVpbHQgeWV0LiBCdWlsZCBpdCBmaXJzdCBieSBjYWxsaW5nIGJ1aWxkKGJhdGNoSW5wdXRTaGFwZSkuXCIpO3JldHVybiBjb3VudFBhcmFtc0luV2VpZ2h0cyh0aGlzLndlaWdodHMpfSx0LnByb3RvdHlwZS5idWlsZD1mdW5jdGlvbihlKXt0aGlzLmJ1aWx0PSEwfSx0LnByb3RvdHlwZS5nZXRXZWlnaHRzPWZ1bmN0aW9uKGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT0hMSksYmF0Y2hHZXRWYWx1ZShlP3RoaXMudHJhaW5hYmxlV2VpZ2h0czp0aGlzLndlaWdodHMpfSx0LnByb3RvdHlwZS5zZXRXZWlnaHRzPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7dGlkeShmdW5jdGlvbigpe3ZhciBuPXQud2VpZ2h0cztpZihuLmxlbmd0aCE9PWUubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKCdZb3UgY2FsbGVkIHNldFdlaWdodHMod2VpZ2h0cykgb24gbGF5ZXIgXCInK3QubmFtZSsnXCIgd2l0aCBhIHdlaWdodCBsaXN0IG9mIGxlbmd0aCAnK2UubGVuZ3RoK1wiLCBidXQgdGhlIGxheWVyIHdhcyBleHBlY3RpbmcgXCIrbi5sZW5ndGgrXCIgd2VpZ2h0cy4gUHJvdmlkZWQgd2VpZ2h0czogXCIrZStcIi4uLlwiKTtpZigwIT09bi5sZW5ndGgpe2Zvcih2YXIgcj1bXSxpPWJhdGNoR2V0VmFsdWUobiksYT0wO2E8aS5sZW5ndGg7KythKXt2YXIgbz1pW2FdLHM9blthXSxsPWVbYV07aWYoIXV0aWwuYXJyYXlzRXF1YWwoby5zaGFwZSxsLnNoYXBlKSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkxheWVyIHdlaWdodCBzaGFwZSBcIitvLnNoYXBlK1wiIG5vdCBjb21wYXRpYmxlIHdpdGggcHJvdmlkZWQgd2VpZ2h0IHNoYXBlIFwiK2wuc2hhcGUpO3IucHVzaChbcyxsXSl9YmF0Y2hTZXRWYWx1ZShyKX19KX0sdC5wcm90b3R5cGUuYWRkV2VpZ2h0PWZ1bmN0aW9uKGUsdCxuLHIsaSxhLG8pe2lmKC0xIT09dGhpcy5fYWRkZWRXZWlnaHROYW1lcy5pbmRleE9mKGUpKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiRHVwbGljYXRlIHdlaWdodCBuYW1lIFwiK2UrXCIgZm9yIGxheWVyIFwiK3RoaXMubmFtZSk7dGhpcy5fYWRkZWRXZWlnaHROYW1lcy5wdXNoKGUpLG51bGw9PW4mJihuPVwiZmxvYXQzMlwiKTt2YXIgcz1uZXcgTGF5ZXJWYXJpYWJsZShyLmFwcGx5KHQsbiksbixlLGEsbyk7cmV0dXJuIG51bGwhPWkmJnRoaXMuYWRkTG9zcyhmdW5jdGlvbigpe3JldHVybiBpLmFwcGx5KHMucmVhZCgpKX0pLG51bGw9PWEmJihhPSEwKSxhP3RoaXMuX3RyYWluYWJsZVdlaWdodHMucHVzaChzKTp0aGlzLl9ub25UcmFpbmFibGVXZWlnaHRzLnB1c2gocyksc30sdC5wcm90b3R5cGUuYWRkTG9zcz1mdW5jdGlvbihlKXt2YXIgdDtudWxsPT1lfHxBcnJheS5pc0FycmF5KGUpJiYwPT09ZS5sZW5ndGh8fChlPXRvTGlzdChlKSx2b2lkIDAhPT10aGlzLl9sb3NzZXMmJm51bGwhPT10aGlzLl9sb3NzZXMmJih0PXRoaXMubG9zc2VzKS5wdXNoLmFwcGx5KHQsZSkpfSx0LnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGU9ZnVuY3Rpb24oZSl7cmV0dXJuIGV9LHQucHJvdG90eXBlLmNvbXB1dGVNYXNrPWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztpZighdGhpcy5zdXBwb3J0c01hc2tpbmcpe2lmKG51bGwhPXQpe2lmKCFBcnJheS5pc0FycmF5KHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJMYXllciBcIit0aGlzLm5hbWUrXCIgZG9lcyBub3Qgc3VwcG9ydCBtYXNraW5nLGJ1dCB3YXMgcGFzc2VkIGFuIGlucHV0TWFzay5cIik7dC5mb3JFYWNoKGZ1bmN0aW9uKGUpe2lmKG51bGwhPWUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkxheWVyIFwiK24ubmFtZStcIiBkb2VzIG5vdCBzdXBwb3J0IG1hc2tpbmcsYnV0IHdhcyBwYXNzZWQgYW4gaW5wdXRNYXNrLlwiKX0pfXJldHVybiBudWxsfXJldHVybiB0fSx0LnByb3RvdHlwZS5hZGRJbmJvdW5kTm9kZT1mdW5jdGlvbihlLHQsbixyLGksYSxvKXt2b2lkIDA9PT1vJiYobz1udWxsKTt2YXIgcz10b0xpc3QoZSk7dD10b0xpc3QodCksbj10b0xpc3Qobikscj10b0xpc3QociksaT1ub3JtYWxpemVTaGFwZUxpc3QoaSksYT1ub3JtYWxpemVTaGFwZUxpc3QoYSk7Zm9yKHZhciBsPVtdLHU9W10sYz1bXSxwPTAsaD1zO3A8aC5sZW5ndGg7cCsrKXt2YXIgZD1oW3BdO2wucHVzaChkLnNvdXJjZUxheWVyKSx1LnB1c2goZC5ub2RlSW5kZXgpLGMucHVzaChkLnRlbnNvckluZGV4KX1uZXcgTm9kZSh7b3V0Ym91bmRMYXllcjp0aGlzLGluYm91bmRMYXllcnM6bCxub2RlSW5kaWNlczp1LHRlbnNvckluZGljZXM6YyxpbnB1dFRlbnNvcnM6cyxvdXRwdXRUZW5zb3JzOnQsaW5wdXRNYXNrczpuLG91dHB1dE1hc2tzOnIsaW5wdXRTaGFwZXM6aSxvdXRwdXRTaGFwZXM6YX0sbyk7Zm9yKHZhciBmPTA7Zjx0Lmxlbmd0aDtmKyspdFtmXS5zb3VyY2VMYXllcj10aGlzLHRbZl0ubm9kZUluZGV4PXRoaXMuaW5ib3VuZE5vZGVzLmxlbmd0aC0xLHRbZl0udGVuc29ySW5kZXg9Zn0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIGU9e25hbWU6dGhpcy5uYW1lLHRyYWluYWJsZTp0aGlzLnRyYWluYWJsZX07cmV0dXJuIG51bGwhPXRoaXMuYmF0Y2hJbnB1dFNoYXBlJiYoZS5iYXRjaElucHV0U2hhcGU9dGhpcy5iYXRjaElucHV0U2hhcGUpLG51bGwhPXRoaXMuZHR5cGUmJihlLmR0eXBlPXRoaXMuZHR5cGUpLGV9LHQucHJvdG90eXBlLmRpc3Bvc2VXZWlnaHRzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMud2VpZ2h0cy5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiBlLmRpc3Bvc2UoKX0pLHRoaXMud2VpZ2h0cy5sZW5ndGh9LHQucHJvdG90eXBlLmFzc2VydE5vdERpc3Bvc2VkPWZ1bmN0aW9uKCl7aWYoMD09PXRoaXMuX3JlZkNvdW50KXRocm93IG5ldyBFcnJvcihcIkxheWVyICdcIit0aGlzLm5hbWUrXCInIGlzIGFscmVhZHkgZGlzcG9zZWQuXCIpfSx0LnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7aWYoIXRoaXMuYnVpbHQpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGRpc3Bvc2UgTGF5ZXIgXCIrdGhpcy5uYW1lK1wiIGJlY2F1c2UgaXQgaGFzIG5vdCBiZWVuIGJ1aWx0IHlldC5cIik7aWYobnVsbD09PXRoaXMuX3JlZkNvdW50KXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBkaXNwb3NlIExheWVyIFwiK3RoaXMubmFtZStcIiBiZWNhdXNlIGl0IGhhcyBub3QgYmVlbiB1c2VkIHlldC5cIik7dGhpcy5hc3NlcnROb3REaXNwb3NlZCgpO3ZhciBlPTA7cmV0dXJuIDA9PS0tdGhpcy5fcmVmQ291bnQmJihlPXRoaXMuZGlzcG9zZVdlaWdodHMoKSkse3JlZkNvdW50QWZ0ZXJEaXNwb3NlOnRoaXMuX3JlZkNvdW50LG51bURpc3Bvc2VkVmFyaWFibGVzOmV9fSx0fShzZXJpYWxpemF0aW9uLlNlcmlhbGl6YWJsZSk7ZnVuY3Rpb24gY29sbGVjdElucHV0U2hhcGUoZSl7Zm9yKHZhciB0PVtdLG49MCxyPWU9dG9MaXN0KGUpO248ci5sZW5ndGg7bisrKXt2YXIgaT1yW25dO3QucHVzaChpLnNoYXBlKX1yZXR1cm4gc2luZ2xldG9uT3JBcnJheSh0KX1mdW5jdGlvbiBndWVzc091dHB1dERUeXBlKGUpe3JldHVyblwiZmxvYXQzMlwifWZ1bmN0aW9uIGdldFNvdXJjZUlucHV0cyhlLHQsbil7aWYoKG51bGw9PXR8fG51bGwhPW4mJm4+MCkmJih0PWUuc291cmNlTGF5ZXIsbj1lLm5vZGVJbmRleCksMD09PXQuaW5ib3VuZE5vZGVzLmxlbmd0aClyZXR1cm5bZV07dmFyIHI9dC5pbmJvdW5kTm9kZXNbbl07aWYoMD09PXIuaW5ib3VuZExheWVycy5sZW5ndGgpcmV0dXJuIHIuaW5wdXRUZW5zb3JzO2Zvcih2YXIgaT1bXSxhPTA7YTxyLmluYm91bmRMYXllcnMubGVuZ3RoO2ErKylmb3IodmFyIG89MCxzPWdldFNvdXJjZUlucHV0cyhyLmlucHV0VGVuc29yc1thXSxyLmluYm91bmRMYXllcnNbYV0sci5ub2RlSW5kaWNlc1thXSk7bzxzLmxlbmd0aDtvKyspe3ZhciBsPXNbb107LTE9PT1pLmluZGV4T2YobCkmJmkucHVzaChsKX1yZXR1cm4gaX12YXIgTW9kZWxMb2dnaW5nVmVyYm9zaXR5LElucHV0TGF5ZXI9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyx7ZHR5cGU6dC5kdHlwZSxuYW1lOm51bGwhPXQubmFtZT90Lm5hbWU6Z2V0VWlkKFwiaW5wdXRcIikudG9TdHJpbmcoKX0pfHx0aGlzO2lmKG51bGw9PXQuYmF0Y2hTaXplJiYodC5iYXRjaFNpemU9bnVsbCksbnVsbD09dC5zcGFyc2UmJih0LnNwYXJzZT0hMSksbi50cmFpbmFibGU9ITEsbi5idWlsdD0hMCxuLnNwYXJzZT10LnNwYXJzZSxudWxsIT10LmlucHV0U2hhcGUmJm51bGwhPXQuYmF0Y2hJbnB1dFNoYXBlKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiT25seSBwcm92aWRlIHRoZSBpbnB1dFNoYXBlIE9SIGJhdGNoSW5wdXRTaGFwZSBhcmd1bWVudCB0byBpbnB1dExheWVyLCBub3QgYm90aCBhdCB0aGUgc2FtZSB0aW1lLlwiKTt2YXIgcj10LmJhdGNoSW5wdXRTaGFwZTtpZihudWxsPT1yKXtpZihudWxsPT10LmlucHV0U2hhcGUpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJBbiBJbnB1dExheWVyIHNob3VsZCBiZSBwYXNzZWQgZWl0aGVyIGEgYGJhdGNoSW5wdXRTaGFwZWAgb3IgYW4gYGlucHV0U2hhcGVgLlwiKTtyPVt0LmJhdGNoU2l6ZV0uY29uY2F0KHQuaW5wdXRTaGFwZSl9ZWxzZSBpZihudWxsIT10LmJhdGNoU2l6ZSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkNhbm5vdCBzcGVjaWZ5IGJhdGNoU2l6ZSBpZiBiYXRjaElucHV0U2hhcGUgaXNzcGVjaWZpZWQgd2hlbiBjcmVhdGluZyBhbiBJbnB1dExheWVyLlwiKTt2YXIgaT10LmR0eXBlfHxcImZsb2F0MzJcIjtuLmJhdGNoSW5wdXRTaGFwZT1yLG4uZHR5cGU9aSxuLmlucHV0U3BlYz1be3NoYXBlOnJ9XTt2YXIgYT1uZXcgU3ltYm9saWNUZW5zb3Iobi5kdHlwZSxuLmJhdGNoSW5wdXRTaGFwZSxuLFtdLHt9LG4ubmFtZSk7cmV0dXJuIGEubm9kZUluZGV4PTAsYS50ZW5zb3JJbmRleD0wLG5ldyBOb2RlKHtvdXRib3VuZExheWVyOm4saW5ib3VuZExheWVyczpbXSxub2RlSW5kaWNlczpbXSx0ZW5zb3JJbmRpY2VzOltdLGlucHV0VGVuc29yczpbYV0sb3V0cHV0VGVuc29yczpbYV0saW5wdXRNYXNrczpbbnVsbF0sb3V0cHV0TWFza3M6W251bGxdLGlucHV0U2hhcGVzOltyXSxvdXRwdXRTaGFwZXM6W3JdfSksbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuYXBwbHk9ZnVuY3Rpb24oZSx0KXt0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkNhbm5vdCBwYXNzIGFueSBpbnB1dCB0byBhbiBJbnB1dExheWVyJ3MgYXBwbHkoKSBtZXRob2QuIElucHV0TGF5ZXIgbmFtZTogXCIrdGhpcy5uYW1lKX0sdC5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe3JldHVybntyZWZDb3VudEFmdGVyRGlzcG9zZTp0aGlzLl9yZWZDb3VudCxudW1EaXNwb3NlZFZhcmlhYmxlczowfX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7cmV0dXJue2JhdGNoSW5wdXRTaGFwZTp0aGlzLmJhdGNoSW5wdXRTaGFwZSxkdHlwZTp0aGlzLmR0eXBlLHNwYXJzZTp0aGlzLnNwYXJzZSxuYW1lOnRoaXMubmFtZX19LHQuY2xhc3NOYW1lPVwiSW5wdXRMYXllclwiLHR9KExheWVyKTtmdW5jdGlvbiBJbnB1dChlKXtpZihudWxsPT1lLmJhdGNoU2hhcGUmJm51bGw9PWUuc2hhcGUpdGhyb3cgbmV3IEVycm9yKFwiUGxlYXNlIHByb3ZpZGUgdG8gSW5wdXQgZWl0aGVyIGEgYHNoYXBlYCBvciBhIGBiYXRjaFNoYXBlYCBhcmd1bWVudC4gTm90ZSB0aGF0IGBzaGFwZWAgZG9lcyBub3QgaW5jbHVkZSB0aGUgYmF0Y2ggZGltZW5zaW9uLlwiKTtpZihudWxsIT1lLmJhdGNoU2hhcGUmJm51bGwhPWUuc2hhcGUpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJQbGVhc2UgcHJvdmlkZSBlaXRoZXIgYSBgc2hhcGVgIG9yIGBiYXRjaFNoYXBlYCBhcmd1bWVudCB0byBJbnB1dCwgYnV0IG5vdCBib3RoLlwiKTt2YXIgdD1lLmJhdGNoU2hhcGU7bnVsbCE9ZS5zaGFwZSYmbnVsbD09dCYmKHQ9W251bGxdLmNvbmNhdChlLnNoYXBlKSk7dmFyIG49ZS5kdHlwZTtyZXR1cm4gbnVsbD09biYmKG49XCJmbG9hdDMyXCIpLG5ldyBJbnB1dExheWVyKHtiYXRjaElucHV0U2hhcGU6dCxuYW1lOmUubmFtZSxkdHlwZTpuLHNwYXJzZTplLnNwYXJzZX0pLmluYm91bmROb2Rlc1swXS5vdXRwdXRUZW5zb3JzWzBdfWZ1bmN0aW9uIHJlc29sdmVTY2FsYXJzSW5Mb2dzKGUpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQsbixyLGksYSxvLHMsbDtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbih1KXtzd2l0Y2godS5sYWJlbCl7Y2FzZSAwOmlmKG51bGw9PWUpcmV0dXJuWzJdO2ZvcihpIGluIHQ9W10sbj1bXSxyPVtdLGUpXCJudW1iZXJcIiE9dHlwZW9mKGE9ZVtpXSkmJihvPWEsdC5wdXNoKG8uZGF0YSgpKSxuLnB1c2goaSksci5wdXNoKG8pKTtyZXR1cm5bNCxQcm9taXNlLmFsbCh0KV07Y2FzZSAxOmZvcihzPXUuc2VudCgpLGw9MDtsPHMubGVuZ3RoOysrbCllW25bbF1dPXNbbF1bMF07cmV0dXJuIGRpc3Bvc2UociksWzJdfX0pfSl9ZnVuY3Rpb24gZGlzcG9zZVRlbnNvcnNJbkxvZ3MoZSl7aWYobnVsbCE9ZSlmb3IodmFyIHQgaW4gZSl7dmFyIG49ZVt0XTtcIm51bWJlclwiIT10eXBlb2YgbiYmbi5kaXNwb3NlKCl9fXNlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhJbnB1dExheWVyKSxmdW5jdGlvbihlKXtlW2UuU0lMRU5UPTBdPVwiU0lMRU5UXCIsZVtlLlZFUkJPU0U9MV09XCJWRVJCT1NFXCJ9KE1vZGVsTG9nZ2luZ1ZlcmJvc2l0eXx8KE1vZGVsTG9nZ2luZ1ZlcmJvc2l0eT17fSkpO3ZhciBCYXNlQ2FsbGJhY2s9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKCl7dGhpcy52YWxpZGF0aW9uRGF0YT1udWxsfXJldHVybiBlLnByb3RvdHlwZS5zZXRQYXJhbXM9ZnVuY3Rpb24oZSl7dGhpcy5wYXJhbXM9ZX0sZS5wcm90b3R5cGUub25FcG9jaEJlZ2luPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihlKXtyZXR1cm5bMl19KX0pfSxlLnByb3RvdHlwZS5vbkVwb2NoRW5kPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihlKXtyZXR1cm5bMl19KX0pfSxlLnByb3RvdHlwZS5vbkJhdGNoQmVnaW49ZnVuY3Rpb24oZSx0KXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGUpe3JldHVyblsyXX0pfSl9LGUucHJvdG90eXBlLm9uQmF0Y2hFbmQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGUpe3JldHVyblsyXX0pfSl9LGUucHJvdG90eXBlLm9uVHJhaW5CZWdpbj1mdW5jdGlvbihlKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGUpe3JldHVyblsyXX0pfSl9LGUucHJvdG90eXBlLm9uVHJhaW5FbmQ9ZnVuY3Rpb24oZSl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihlKXtyZXR1cm5bMl19KX0pfSxlLnByb3RvdHlwZS5zZXRNb2RlbD1mdW5jdGlvbihlKXt9LGV9KCksQ2FsbGJhY2tMaXN0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQpe3ZvaWQgMD09PXQmJih0PTEwKSxudWxsPT1lJiYoZT1bXSksdGhpcy5jYWxsYmFja3M9ZSx0aGlzLnF1ZXVlTGVuZ3RoPXR9cmV0dXJuIGUucHJvdG90eXBlLmFwcGVuZD1mdW5jdGlvbihlKXt0aGlzLmNhbGxiYWNrcy5wdXNoKGUpfSxlLnByb3RvdHlwZS5zZXRQYXJhbXM9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PTAsbj10aGlzLmNhbGxiYWNrczt0PG4ubGVuZ3RoO3QrKyl7blt0XS5zZXRQYXJhbXMoZSl9fSxlLnByb3RvdHlwZS5zZXRNb2RlbD1mdW5jdGlvbihlKXtmb3IodmFyIHQ9MCxuPXRoaXMuY2FsbGJhY2tzO3Q8bi5sZW5ndGg7dCsrKXtuW3RdLnNldE1vZGVsKGUpfX0sZS5wcm90b3R5cGUub25FcG9jaEJlZ2luPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgbixyO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGkpe3N3aXRjaChpLmxhYmVsKXtjYXNlIDA6bnVsbD09dCYmKHQ9e30pLG49MCxyPXRoaXMuY2FsbGJhY2tzLGkubGFiZWw9MTtjYXNlIDE6cmV0dXJuIG48ci5sZW5ndGg/WzQscltuXS5vbkVwb2NoQmVnaW4oZSx0KV06WzMsNF07Y2FzZSAyOmkuc2VudCgpLGkubGFiZWw9MztjYXNlIDM6cmV0dXJuIG4rKyxbMywxXTtjYXNlIDQ6cmV0dXJuWzJdfX0pfSl9LGUucHJvdG90eXBlLm9uRXBvY2hFbmQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBuLHI7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oaSl7c3dpdGNoKGkubGFiZWwpe2Nhc2UgMDpudWxsPT10JiYodD17fSksbj0wLHI9dGhpcy5jYWxsYmFja3MsaS5sYWJlbD0xO2Nhc2UgMTpyZXR1cm4gbjxyLmxlbmd0aD9bNCxyW25dLm9uRXBvY2hFbmQoZSx0KV06WzMsNF07Y2FzZSAyOmkuc2VudCgpLGkubGFiZWw9MztjYXNlIDM6cmV0dXJuIG4rKyxbMywxXTtjYXNlIDQ6cmV0dXJuWzJdfX0pfSl9LGUucHJvdG90eXBlLm9uQmF0Y2hCZWdpbj1mdW5jdGlvbihlLHQpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIG4scjtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihpKXtzd2l0Y2goaS5sYWJlbCl7Y2FzZSAwOm51bGw9PXQmJih0PXt9KSxuPTAscj10aGlzLmNhbGxiYWNrcyxpLmxhYmVsPTE7Y2FzZSAxOnJldHVybiBuPHIubGVuZ3RoP1s0LHJbbl0ub25CYXRjaEJlZ2luKGUsdCldOlszLDRdO2Nhc2UgMjppLnNlbnQoKSxpLmxhYmVsPTM7Y2FzZSAzOnJldHVybiBuKyssWzMsMV07Y2FzZSA0OnJldHVyblsyXX19KX0pfSxlLnByb3RvdHlwZS5vbkJhdGNoRW5kPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgbixyO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGkpe3N3aXRjaChpLmxhYmVsKXtjYXNlIDA6cmV0dXJuIG51bGw9PXQmJih0PXt9KSxbNCxyZXNvbHZlU2NhbGFyc0luTG9ncyh0KV07Y2FzZSAxOmkuc2VudCgpLG49MCxyPXRoaXMuY2FsbGJhY2tzLGkubGFiZWw9MjtjYXNlIDI6cmV0dXJuIG48ci5sZW5ndGg/WzQscltuXS5vbkJhdGNoRW5kKGUsdCldOlszLDVdO2Nhc2UgMzppLnNlbnQoKSxpLmxhYmVsPTQ7Y2FzZSA0OnJldHVybiBuKyssWzMsMl07Y2FzZSA1OnJldHVyblsyXX19KX0pfSxlLnByb3RvdHlwZS5vblRyYWluQmVnaW49ZnVuY3Rpb24oZSl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgdCxuO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6bnVsbD09ZSYmKGU9e30pLHQ9MCxuPXRoaXMuY2FsbGJhY2tzLHIubGFiZWw9MTtjYXNlIDE6cmV0dXJuIHQ8bi5sZW5ndGg/WzQsblt0XS5vblRyYWluQmVnaW4oZSldOlszLDRdO2Nhc2UgMjpyLnNlbnQoKSxyLmxhYmVsPTM7Y2FzZSAzOnJldHVybiB0KyssWzMsMV07Y2FzZSA0OnJldHVyblsyXX19KX0pfSxlLnByb3RvdHlwZS5vblRyYWluRW5kPWZ1bmN0aW9uKGUpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQsbjtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOm51bGw9PWUmJihlPXt9KSx0PTAsbj10aGlzLmNhbGxiYWNrcyxyLmxhYmVsPTE7Y2FzZSAxOnJldHVybiB0PG4ubGVuZ3RoP1s0LG5bdF0ub25UcmFpbkVuZChlKV06WzMsNF07Y2FzZSAyOnIuc2VudCgpLHIubGFiZWw9MztjYXNlIDM6cmV0dXJuIHQrKyxbMywxXTtjYXNlIDQ6cmV0dXJuWzJdfX0pfSl9LGV9KCksTW9kZWxUcmFpbmluZ1lpZWxkZXI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUpe3RoaXMueWllbGRFdmVyeT1lLHRoaXMuYmF0Y2hDb3VudD0wLHRoaXMuYmF0Y2hEdXJhdGlvbnNNaWxsaXM9W10sdGhpcy5hdXRvWWllbGRFdmVyeUJhdGNoZXM9bnVsbCx0aGlzLmJhdGNoU3RhcnRNaWxsaXM9dXRpbC5ub3coKX1yZXR1cm4gZS5wcm90b3R5cGUucmVzb2x2ZU9uZVRlbnNvckluTG9ncz1mdW5jdGlvbihlKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciB0LG4scixpLGE7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24obyl7c3dpdGNoKG8ubGFiZWwpe2Nhc2UgMDpmb3IobiBpbiB0PVtdLGUpdC5wdXNoKG4pO3I9MCxvLmxhYmVsPTE7Y2FzZSAxOnJldHVybiByPHQubGVuZ3RoPyhpPXRbcl0sXCJudW1iZXJcIj09dHlwZW9mKGE9ZVtpXSk/WzMsM106WzQsYS5kYXRhKCldKTpbMyw0XTtjYXNlIDI6cmV0dXJuIG8uc2VudCgpLFszLDRdO2Nhc2UgMzpyZXR1cm4gcisrLFszLDFdO2Nhc2UgNDpyZXR1cm5bMl19fSl9KX0sZS5wcm90b3R5cGUubWF5YmVZaWVsZE9uQmF0Y2g9ZnVuY3Rpb24odCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgbixyO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGkpe3N3aXRjaChpLmxhYmVsKXtjYXNlIDA6cmV0dXJuXCJhdXRvXCIhPT10aGlzLnlpZWxkRXZlcnk/WzMsN106KHRoaXMuYmF0Y2hDb3VudCsrLG51bGwhPXRoaXMuYXV0b1lpZWxkRXZlcnlCYXRjaGVzP1szLDNdOls0LHRoaXMucmVzb2x2ZU9uZVRlbnNvckluTG9ncyh0KV0pO2Nhc2UgMTpyZXR1cm4gaS5zZW50KCksbj11dGlsLm5vdygpLFs0LG5leHRGcmFtZSgpXTtjYXNlIDI6cmV0dXJuIGkuc2VudCgpLHRoaXMuYmF0Y2hDb3VudD5lLlNLSVBfRklSU1RfQkFUQ0hFUyYmKHRoaXMuYmF0Y2hEdXJhdGlvbnNNaWxsaXMucHVzaChuLXRoaXMuYmF0Y2hTdGFydE1pbGxpcyksdGhpcy5iYXRjaER1cmF0aW9uc01pbGxpcy5sZW5ndGg+PWUuREVDSVNJT05fQkFUQ0hfQ09VTlQmJihyPXRoaXMuYmF0Y2hEdXJhdGlvbnNNaWxsaXMucmVkdWNlKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUrdH0pL3RoaXMuYmF0Y2hEdXJhdGlvbnNNaWxsaXMubGVuZ3RoLHRoaXMuYXV0b1lpZWxkRXZlcnlCYXRjaGVzPU1hdGgucm91bmQoZS5USFJFU0hPTERfTUlMTElTL3IpLHRoaXMuYXV0b1lpZWxkRXZlcnlCYXRjaGVzPDEmJih0aGlzLmF1dG9ZaWVsZEV2ZXJ5QmF0Y2hlcz0xKSkpLHRoaXMuYmF0Y2hTdGFydE1pbGxpcz11dGlsLm5vdygpLHRoaXMubGFzdFlpZWxkQmF0Y2hDb3VudD10aGlzLmJhdGNoQ291bnQsWzMsNl07Y2FzZSAzOnJldHVybiB0aGlzLmJhdGNoQ291bnQtdGhpcy5sYXN0WWllbGRCYXRjaENvdW50Pj10aGlzLmF1dG9ZaWVsZEV2ZXJ5QmF0Y2hlcz9bNCxuZXh0RnJhbWUoKV06WzMsNl07Y2FzZSA0OnJldHVybiBpLnNlbnQoKSxbNCx0aGlzLnJlc29sdmVPbmVUZW5zb3JJbkxvZ3ModCldO2Nhc2UgNTppLnNlbnQoKSx0aGlzLmxhc3RZaWVsZEJhdGNoQ291bnQ9dGhpcy5iYXRjaENvdW50LGkubGFiZWw9NjtjYXNlIDY6cmV0dXJuWzMsOV07Y2FzZSA3OnJldHVyblwiYmF0Y2hcIiE9PXRoaXMueWllbGRFdmVyeT9bMyw5XTpbNCxuZXh0RnJhbWUoKV07Y2FzZSA4Omkuc2VudCgpLGkubGFiZWw9OTtjYXNlIDk6cmV0dXJuWzJdfX0pfSl9LGUucHJvdG90eXBlLm1heWJlWWllbGRPbkVwb2NoPWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihlKXtzd2l0Y2goZS5sYWJlbCl7Y2FzZSAwOnJldHVyblwiZXBvY2hcIiE9PXRoaXMueWllbGRFdmVyeT9bMywyXTpbNCxuZXh0RnJhbWUoKV07Y2FzZSAxOmUuc2VudCgpLGUubGFiZWw9MjtjYXNlIDI6cmV0dXJuWzJdfX0pfSl9LGUuU0tJUF9GSVJTVF9CQVRDSEVTPTEsZS5ERUNJU0lPTl9CQVRDSF9DT1VOVD0yLGUuVEhSRVNIT0xEX01JTExJUz0xNixlfSgpLEJhc2VMb2dnZXI9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIG4ueWllbGRFdmVyeT10fHxcImF1dG9cIixufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5vblRyYWluQmVnaW49ZnVuY3Rpb24oZSl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5hdXRvWWllbGRlcj1uZXcgTW9kZWxUcmFpbmluZ1lpZWxkZXIodGhpcy55aWVsZEV2ZXJ5KSxbMl19KX0pfSx0LnByb3RvdHlwZS5vbkVwb2NoQmVnaW49ZnVuY3Rpb24oZSl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5zZWVuPTAsdGhpcy50b3RhbHM9e30sWzJdfSl9KX0sdC5wcm90b3R5cGUub25CYXRjaEVuZD1mdW5jdGlvbihlLHQpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIGUsbixyLGksYT10aGlzO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKG8pe3N3aXRjaChvLmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsdGhpcy5hdXRvWWllbGRlci5tYXliZVlpZWxkT25CYXRjaCh0KV07Y2FzZSAxOmZvcihpIGluIG8uc2VudCgpLG51bGw9PXQmJih0PXt9KSxlPW51bGw9PXQuc2l6ZT8wOnQuc2l6ZSx0aGlzLnNlZW4rPWUsbj1mdW5jdGlvbihuKXt2YXIgaT10W25dO2lmKFwibnVtYmVyXCI9PXR5cGVvZiBpKXIudG90YWxzLmhhc093blByb3BlcnR5KG4pfHwoci50b3RhbHNbbl09MCksci50b3RhbHNbbl09ci50b3RhbHNbbl0raSplO2Vsc2V7dmFyIG89dm9pZCAwO24gaW4gci50b3RhbHM/bz1yLnRvdGFsc1tuXTpyLnRvdGFsc1tuXT1nZXRTY2FsYXIoMCksci50b3RhbHNbbl09dGlkeShmdW5jdGlvbigpe3JldHVybiBhZGQoYS50b3RhbHNbbl0sbXVsKGksZ2V0U2NhbGFyKGUpKSl9KSxudWxsIT1vJiZvLmRpc3Bvc2UoKX19LHI9dGhpcyx0KW4oaSk7cmV0dXJuWzJdfX0pfSl9LHQucHJvdG90eXBlLm9uRXBvY2hFbmQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBlLG4scixpLGEsbz10aGlzO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHMpe3N3aXRjaChzLmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsdGhpcy5hdXRvWWllbGRlci5tYXliZVlpZWxkT25FcG9jaCgpXTtjYXNlIDE6aWYocy5zZW50KCksbnVsbCE9dClmb3IoZT1mdW5jdGlvbihlKXtpZihudWxsPT1uLnRvdGFsc1tlXSlyZXR1cm5cImNvbnRpbnVlXCI7XCJudW1iZXJcIj09dHlwZW9mIG4udG90YWxzW2VdP3RbZV09bi50b3RhbHNbZV0vbi5zZWVuOnRpZHkoZnVuY3Rpb24oKXt0W2VdPW11bChkaXYoZ2V0U2NhbGFyKDEpLGdldFNjYWxhcihvLnNlZW4pKSxvLnRvdGFsc1tlXSksby50b3RhbHNbZV0uZGlzcG9zZSgpLGtlZXAodFtlXSl9KX0sbj10aGlzLHI9MCxpPXRoaXMucGFyYW1zLm1ldHJpY3M7cjxpLmxlbmd0aDtyKyspYT1pW3JdLGUoYSk7cmV0dXJuWzJdfX0pfSl9LHR9KEJhc2VDYWxsYmFjayksSGlzdG9yeT1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KCl7cmV0dXJuIG51bGwhPT1lJiZlLmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpc31yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUub25UcmFpbkJlZ2luPWZ1bmN0aW9uKGUpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuZXBvY2g9W10sdGhpcy5oaXN0b3J5PXt9LFsyXX0pfSl9LHQucHJvdG90eXBlLm9uRXBvY2hFbmQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBuO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHIpe2ZvcihuIGluIG51bGw9PXQmJih0PXt9KSx0aGlzLmVwb2NoLnB1c2goZSksdCludWxsPT10aGlzLmhpc3Rvcnlbbl0mJih0aGlzLmhpc3Rvcnlbbl09W10pLHRoaXMuaGlzdG9yeVtuXS5wdXNoKHRbbl0pO3JldHVyblsyXX0pfSl9LHQucHJvdG90eXBlLnN5bmNEYXRhPWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgZSx0LG4scixpLGEsbyxzLGw7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24odSl7c3dpdGNoKHUubGFiZWwpe2Nhc2UgMDpmb3IociBpbiBlPVtdLHQ9W10sbj1bXSx0aGlzLmhpc3RvcnkpZm9yKGk9dGhpcy5oaXN0b3J5W3JdLGE9MDthPGkubGVuZ3RoOysrYSlcIm51bWJlclwiIT10eXBlb2YgaVthXSYmKG89aVthXSxlLnB1c2goby5kYXRhKCkpLHQucHVzaChyKSxuLnB1c2goYSkpO3JldHVybls0LFByb21pc2UuYWxsKGUpXTtjYXNlIDE6Zm9yKHM9dS5zZW50KCksbD0wO2w8cy5sZW5ndGg7KytsKXRoaXMuaGlzdG9yeVt0W2xdXVtuW2xdXS5kaXNwb3NlKCksdGhpcy5oaXN0b3J5W3RbbF1dW25bbF1dPXNbbF1bMF07cmV0dXJuWzJdfX0pfSl9LHR9KEJhc2VDYWxsYmFjayksQ3VzdG9tQ2FsbGJhY2s9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIG4udHJhaW5CZWdpbj10Lm9uVHJhaW5CZWdpbixuLnRyYWluRW5kPXQub25UcmFpbkVuZCxuLmVwb2NoQmVnaW49dC5vbkVwb2NoQmVnaW4sbi5lcG9jaEVuZD10Lm9uRXBvY2hFbmQsbi5iYXRjaEJlZ2luPXQub25CYXRjaEJlZ2luLG4uYmF0Y2hFbmQ9dC5vbkJhdGNoRW5kLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLm9uRXBvY2hCZWdpbj1mdW5jdGlvbihlLHQpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24obil7c3dpdGNoKG4ubGFiZWwpe2Nhc2UgMDpyZXR1cm4gbnVsbD09dGhpcy5lcG9jaEJlZ2luP1szLDNdOls0LHJlc29sdmVTY2FsYXJzSW5Mb2dzKHQpXTtjYXNlIDE6cmV0dXJuIG4uc2VudCgpLFs0LHRoaXMuZXBvY2hCZWdpbihlLHQpXTtjYXNlIDI6bi5zZW50KCksbi5sYWJlbD0zO2Nhc2UgMzpyZXR1cm5bMl19fSl9KX0sdC5wcm90b3R5cGUub25FcG9jaEVuZD1mdW5jdGlvbihlLHQpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24obil7c3dpdGNoKG4ubGFiZWwpe2Nhc2UgMDpyZXR1cm4gbnVsbD09dGhpcy5lcG9jaEVuZD9bMywzXTpbNCxyZXNvbHZlU2NhbGFyc0luTG9ncyh0KV07Y2FzZSAxOnJldHVybiBuLnNlbnQoKSxbNCx0aGlzLmVwb2NoRW5kKGUsdCldO2Nhc2UgMjpuLnNlbnQoKSxuLmxhYmVsPTM7Y2FzZSAzOnJldHVyblsyXX19KX0pfSx0LnByb3RvdHlwZS5vbkJhdGNoQmVnaW49ZnVuY3Rpb24oZSx0KXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKG4pe3N3aXRjaChuLmxhYmVsKXtjYXNlIDA6cmV0dXJuIG51bGw9PXRoaXMuYmF0Y2hCZWdpbj9bMywzXTpbNCxyZXNvbHZlU2NhbGFyc0luTG9ncyh0KV07Y2FzZSAxOnJldHVybiBuLnNlbnQoKSxbNCx0aGlzLmJhdGNoQmVnaW4oZSx0KV07Y2FzZSAyOm4uc2VudCgpLG4ubGFiZWw9MztjYXNlIDM6cmV0dXJuWzJdfX0pfSl9LHQucHJvdG90eXBlLm9uQmF0Y2hFbmQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKG4pe3N3aXRjaChuLmxhYmVsKXtjYXNlIDA6cmV0dXJuIG51bGw9PXRoaXMuYmF0Y2hFbmQ/WzMsM106WzQscmVzb2x2ZVNjYWxhcnNJbkxvZ3ModCldO2Nhc2UgMTpyZXR1cm4gbi5zZW50KCksWzQsdGhpcy5iYXRjaEVuZChlLHQpXTtjYXNlIDI6bi5zZW50KCksbi5sYWJlbD0zO2Nhc2UgMzpyZXR1cm5bMl19fSl9KX0sdC5wcm90b3R5cGUub25UcmFpbkJlZ2luPWZ1bmN0aW9uKGUpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24odCl7c3dpdGNoKHQubGFiZWwpe2Nhc2UgMDpyZXR1cm4gbnVsbD09dGhpcy50cmFpbkJlZ2luP1szLDNdOls0LHJlc29sdmVTY2FsYXJzSW5Mb2dzKGUpXTtjYXNlIDE6cmV0dXJuIHQuc2VudCgpLFs0LHRoaXMudHJhaW5CZWdpbihlKV07Y2FzZSAyOnQuc2VudCgpLHQubGFiZWw9MztjYXNlIDM6cmV0dXJuWzJdfX0pfSl9LHQucHJvdG90eXBlLm9uVHJhaW5FbmQ9ZnVuY3Rpb24oZSl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbih0KXtzd2l0Y2godC5sYWJlbCl7Y2FzZSAwOnJldHVybiBudWxsPT10aGlzLnRyYWluRW5kP1szLDNdOls0LHJlc29sdmVTY2FsYXJzSW5Mb2dzKGUpXTtjYXNlIDE6cmV0dXJuIHQuc2VudCgpLFs0LHRoaXMudHJhaW5FbmQoZSldO2Nhc2UgMjp0LnNlbnQoKSx0LmxhYmVsPTM7Y2FzZSAzOnJldHVyblsyXX19KX0pfSx0fShCYXNlQ2FsbGJhY2spO2Z1bmN0aW9uIHN0YW5kYXJkaXplQ2FsbGJhY2tzKGUpe3JldHVybiBudWxsPT1lP251bGw6ZSBpbnN0YW5jZW9mIEJhc2VDYWxsYmFjaz9bZV06QXJyYXkuaXNBcnJheShlKSYmZVswXWluc3RhbmNlb2YgQmFzZUNhbGxiYWNrP2U6dG9MaXN0KGUpLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gbmV3IEN1c3RvbUNhbGxiYWNrKGUpfSl9dmFyIENhbGxiYWNrQ29uc3RydWN0b3JSZWdpc3RyeT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXt9cmV0dXJuIGUucmVnaXN0ZXJDYWxsYmFja0NvbnN0cnVjdG9yPWZ1bmN0aW9uKHQsbil7dXRpbC5hc3NlcnQodD49MCYmTnVtYmVyLmlzSW50ZWdlcih0KSxcIlZlcmJvc2l0eSBsZXZlbCBpcyBleHBlY3RlZCB0byBiZSBhbiBpbnRlZ2VyID49IDAsIGJ1dCBnb3QgXCIrdCksZS5jaGVja0ZvckR1cGxpY2F0ZShuKSxudWxsPT1lLmNvbnN0cnVjdG9yc1t0XSYmKGUuY29uc3RydWN0b3JzW3RdPVtdKSxlLmNvbnN0cnVjdG9yc1t0XS5wdXNoKG4pfSxlLmNoZWNrRm9yRHVwbGljYXRlPWZ1bmN0aW9uKHQpe2Zvcih2YXIgbiBpbiBlLmNvbnN0cnVjdG9ycyl7ZS5jb25zdHJ1Y3RvcnNbK25dLmZvckVhY2goZnVuY3Rpb24oZSl7aWYoZT09PXQpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJEdXBsaWNhdGUgY2FsbGJhY2sgY29uc3RydWN0b3IuXCIpfSl9fSxlLmNsZWFyPWZ1bmN0aW9uKCl7ZS5jb25zdHJ1Y3RvcnM9e319LGUuY3JlYXRlQ2FsbGJhY2tzPWZ1bmN0aW9uKHQpe3ZhciBuPVtdO2Zvcih2YXIgciBpbiBlLmNvbnN0cnVjdG9ycyl7dmFyIGk9K3I7dD49aSYmbi5wdXNoLmFwcGx5KG4sZS5jb25zdHJ1Y3RvcnNbaV0pfXJldHVybiBuLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gbmV3IGV9KX0sZS5jb25zdHJ1Y3RvcnM9e30sZX0oKTtmdW5jdGlvbiBjb25maWd1cmVDYWxsYmFja3MoZSx0LG4scixpLGEsbyxzLGwsdSl7dmFyIGM9bmV3IEhpc3RvcnkscD1bbmV3IEJhc2VMb2dnZXIodCldLmNvbmNhdChDYWxsYmFja0NvbnN0cnVjdG9yUmVnaXN0cnkuY3JlYXRlQ2FsbGJhY2tzKG4pKTtudWxsIT1lJiZwLnB1c2guYXBwbHkocCxlKSxwLnB1c2goYyk7dmFyIGg9bmV3IENhbGxiYWNrTGlzdChwKTtyZXR1cm4gaC5zZXRQYXJhbXMoe2Vwb2NoczpyLGluaXRpYWxFcG9jaDppLHNhbXBsZXM6YSxzdGVwczpvLGJhdGNoU2l6ZTpzLHZlcmJvc2U6bixkb1ZhbGlkYXRpb246bCxtZXRyaWNzOnV9KSx7Y2FsbGJhY2tMaXN0OmgsaGlzdG9yeTpjfX1mdW5jdGlvbiBsMk5vcm1hbGl6ZShlLHQpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIG49c3VtKHNxdWFyZShlKSx0LCEwKSxyPW11bChzY2FsYXIoZXBzaWxvbigpKSxvbmVzTGlrZShlKSksaT1zcXJ0KG1heGltdW0obixyKSk7cmV0dXJuIGRpdihlLGkpfSl9ZnVuY3Rpb24gbWVhblNxdWFyZWRFcnJvcihlLHQpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7cmV0dXJuIG1lYW4oc3F1YXJlKHN1Yih0LGUpKSwtMSl9KX1mdW5jdGlvbiBtZWFuQWJzb2x1dGVFcnJvcihlLHQpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7cmV0dXJuIG1lYW4oYWJzKHN1Yih0LGUpKSwtMSl9KX1mdW5jdGlvbiBtZWFuQWJzb2x1dGVQZXJjZW50YWdlRXJyb3IoZSx0KXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciBuPXN1YihlLHQpLHI9Y2xpcEJ5VmFsdWUoYWJzKGUpLGVwc2lsb24oKSxOdW1iZXIuTUFYX1ZBTFVFKSxpPWFicyhkaXYobixyKSk7cmV0dXJuIG11bChnZXRTY2FsYXIoMTAwKSxtZWFuKGksLTEpKX0pfWZ1bmN0aW9uIG1lYW5TcXVhcmVkTG9nYXJpdGhtaWNFcnJvcihlLHQpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIG49Z2V0U2NhbGFyKDEpLHI9Y2xpcEJ5VmFsdWUodCxlcHNpbG9uKCksTnVtYmVyLk1BWF9WQUxVRSksaT1sb2coYWRkKG4scikpLGE9Y2xpcEJ5VmFsdWUoZSxlcHNpbG9uKCksTnVtYmVyLk1BWF9WQUxVRSksbz1sb2coYWRkKG4sYSkpO3JldHVybiBtZWFuKHNxdWFyZShzdWIoaSxvKSksLTEpfSl9ZnVuY3Rpb24gc3F1YXJlZEhpbmdlKGUsdCl7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXt2YXIgbj1nZXRTY2FsYXIoMCkscj1nZXRTY2FsYXIoMSksaT1tYXhpbXVtKG4sc3ViKHIsbXVsKGUsdCkpKTtyZXR1cm4gbWVhbihzcXVhcmUoaSksLTEpfSl9ZnVuY3Rpb24gaGluZ2UoZSx0KXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciBuPWdldFNjYWxhcigwKSxyPWdldFNjYWxhcigxKSxpPW1heGltdW0obixzdWIocixtdWwoZSx0KSkpO3JldHVybiBtZWFuKGksLTEpfSl9ZnVuY3Rpb24gY2F0ZWdvcmljYWxIaW5nZShlLHQpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIG49Z2V0U2NhbGFyKDApLHI9Z2V0U2NhbGFyKDEpLGk9c3VtKG11bChlLHQpLC0xKSxhPW1heChtdWwoc3ViKHIsZSksdCksLTEpO3JldHVybiBtYXhpbXVtKG4sYWRkKHIsc3ViKGEsaSkpKX0pfWZ1bmN0aW9uIGxvZ2Nvc2goZSx0KXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciBuPWdldFNjYWxhcihNYXRoLmxvZygyKSkscj1zdWIodCxlKSxpPXN1YihhZGQocixzb2Z0cGx1cyhtdWwoZ2V0U2NhbGFyKC0yKSxyKSkpLG4pO3JldHVybiBtZWFuKGksLTEpfSl9ZnVuY3Rpb24gY2F0ZWdvcmljYWxDcm9zc2VudHJvcHkoZSx0LG4pe3JldHVybiB2b2lkIDA9PT1uJiYobj0hMSksdGlkeShmdW5jdGlvbigpe2lmKG4pdD1zb2Z0bWF4KHQpO2Vsc2V7dmFyIHI9c3VtKHQsdC5zaGFwZS5sZW5ndGgtMSwhMCk7dD1kaXYodCxyKX1yZXR1cm4gdD1jbGlwQnlWYWx1ZSh0LGVwc2lsb24oKSwxLWVwc2lsb24oKSksbmVnKHN1bShtdWwoZS50b0Zsb2F0KCksbG9nKHQpKSx0LnNoYXBlLmxlbmd0aC0xKSl9KX1mdW5jdGlvbiBzcGFyc2VDYXRlZ29yaWNhbENyb3NzZW50cm9weShlLHQsbil7cmV0dXJuIHZvaWQgMD09PW4mJihuPSExKSx0aWR5KGZ1bmN0aW9uKCl7dmFyIHI9Zmxvb3IoZmxhdHRlbihlKSkudG9JbnQoKSxpPXQuc2hhcGU7cmV0dXJuIGNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5KG9uZUhvdChyLGlbaS5sZW5ndGgtMV0pLnJlc2hhcGUoaSksdCxuKX0pfWZ1bmN0aW9uIHNpZ21vaWRDcm9zc0VudHJvcHlXaXRoTG9naXRzKGUsdCl7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXt2YXIgbj1tYXhpbXVtKHQsemVyb3NMaWtlKHQpKSxyPW11bCh0LGUpLGk9bG9nKGFkZChnZXRTY2FsYXIoMSksZXhwKG5lZyhhYnModCkpKSkpO3JldHVybiBhZGQoc3ViKG4sciksaSl9KX1mdW5jdGlvbiBiaW5hcnlDcm9zc2VudHJvcHkoZSx0KXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciBuO3JldHVybiBuPWNsaXBCeVZhbHVlKHQsZXBzaWxvbigpLDEtZXBzaWxvbigpKSxuPWxvZyhkaXYobixzdWIob25lc0xpa2UobiksbikpKSxtZWFuKHNpZ21vaWRDcm9zc0VudHJvcHlXaXRoTG9naXRzKGUsbiksLTEpfSl9ZnVuY3Rpb24ga3VsbGJhY2tMZWlibGVyRGl2ZXJnZW5jZShlLHQpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIG49Y2xpcEJ5VmFsdWUoZSxlcHNpbG9uKCksMSkscj1jbGlwQnlWYWx1ZSh0LGVwc2lsb24oKSwxKTtyZXR1cm4gc3VtKG11bChlLGxvZyhkaXYobixyKSkpLC0xKX0pfWZ1bmN0aW9uIHBvaXNzb24oZSx0KXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciBuPWxvZyhhZGQoZ2V0U2NhbGFyKGVwc2lsb24oKSksdCkpO3JldHVybiBtZWFuKHN1Yih0LG11bChlLG4pKSwtMSl9KX1mdW5jdGlvbiBjb3NpbmVQcm94aW1pdHkoZSx0KXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciBuPWwyTm9ybWFsaXplKGUsLTEpLHI9bDJOb3JtYWxpemUodCwtMSksaT1tdWwobixyKTtyZXR1cm4gbmVnKHN1bShpLC0xKSl9KX1mdW5jdGlvbiBnZXQoZSl7dmFyIHQ9e21lYW5TcXVhcmVkRXJyb3I6bWVhblNxdWFyZWRFcnJvcixtZWFuQWJzb2x1dGVFcnJvcjptZWFuQWJzb2x1dGVFcnJvcixtZWFuQWJzb2x1dGVQZXJjZW50YWdlRXJyb3I6bWVhbkFic29sdXRlUGVyY2VudGFnZUVycm9yLG1lYW5TcXVhcmVkTG9nYXJpdGhtaWNFcnJvcjptZWFuU3F1YXJlZExvZ2FyaXRobWljRXJyb3Isc3F1YXJlZEhpbmdlOnNxdWFyZWRIaW5nZSxoaW5nZTpoaW5nZSxjYXRlZ29yaWNhbEhpbmdlOmNhdGVnb3JpY2FsSGluZ2UsbG9nY29zaDpsb2djb3NoLGNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5OmNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5LHNwYXJzZUNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5OnNwYXJzZUNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5LGJpbmFyeUNyb3NzZW50cm9weTpiaW5hcnlDcm9zc2VudHJvcHksa3VsbGJhY2tMZWlibGVyRGl2ZXJnZW5jZTprdWxsYmFja0xlaWJsZXJEaXZlcmdlbmNlLHBvaXNzb246cG9pc3Nvbixjb3NpbmVQcm94aW1pdHk6Y29zaW5lUHJveGltaXR5fTtpZihcInN0cmluZ1wiPT10eXBlb2YgZSl7aWYoZSBpbiB0KXJldHVybiB0W2VdO3ZhciBuPVwiVW5rbm93biBsb3NzIFwiK2U7dGhyb3cgZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwic29mdG1heGNyb3NzZW50cm9weVwiKSYmKG49XCJVbmtub3duIGxvc3MgXCIrZSsnLiBVc2UgXCJjYXRlZ29yaWNhbENyb3NzZW50cm9weVwiIGFzIHRoZSBzdHJpbmcgbmFtZSBmb3IgdGYubG9zc2VzLnNvZnRtYXhDcm9zc0VudHJvcHknKSxuZXcgVmFsdWVFcnJvcihuKX1yZXR1cm4gZX1mdW5jdGlvbiBiaW5hcnlBY2N1cmFjeShlLHQpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIG49bXVsKGdldFNjYWxhciguNSksb25lc0xpa2UodCkpLHI9Y2FzdCQxKGdyZWF0ZXIodCxuKSxlLmR0eXBlKTtyZXR1cm4gbWVhbihlcXVhbChlLHIpLC0xKX0pfWZ1bmN0aW9uIGNhdGVnb3JpY2FsQWNjdXJhY3koZSx0KXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3JldHVybiBjYXN0JDEoZXF1YWwoYXJnTWF4KGUsLTEpLGFyZ01heCh0LC0xKSksXCJmbG9hdDMyXCIpfSl9ZnVuY3Rpb24gdHJ1ZVBvc2l0aXZlcyhlLHQpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIG49Z2V0U2NhbGFyKDEpO3JldHVybiBsb2dpY2FsQW5kKGUuZXF1YWwobiksdC5lcXVhbChuKSkuc3VtKCkuY2FzdChcImZsb2F0MzJcIil9KX1mdW5jdGlvbiBmYWxzZU5lZ2F0aXZlcyhlLHQpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIG49Z2V0U2NhbGFyKDEpLHI9Z2V0U2NhbGFyKDApO3JldHVybiBsb2dpY2FsQW5kKGUuZXF1YWwobiksdC5lcXVhbChyKSkuc3VtKCkuY2FzdChcImZsb2F0MzJcIil9KX1mdW5jdGlvbiBmYWxzZVBvc2l0aXZlcyhlLHQpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIG49Z2V0U2NhbGFyKDEpLHI9Z2V0U2NhbGFyKDApO3JldHVybiBsb2dpY2FsQW5kKGUuZXF1YWwociksdC5lcXVhbChuKSkuc3VtKCkuY2FzdChcImZsb2F0MzJcIil9KX1mdW5jdGlvbiBwcmVjaXNpb24oZSx0KXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciBuPWdldFNjYWxhcigwKSxyPXRydWVQb3NpdGl2ZXMoZSx0KSxpPWZhbHNlUG9zaXRpdmVzKGUsdCksYT1yLmFkZChpKTtyZXR1cm4gd2hlcmUoZ3JlYXRlcihhLG4pLHIuZGl2KGEpLG4pLmNhc3QoXCJmbG9hdDMyXCIpfSl9ZnVuY3Rpb24gcmVjYWxsKGUsdCl7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXt2YXIgbj1nZXRTY2FsYXIoMCkscj10cnVlUG9zaXRpdmVzKGUsdCksaT1mYWxzZU5lZ2F0aXZlcyhlLHQpLGE9ci5hZGQoaSk7cmV0dXJuIHdoZXJlKGdyZWF0ZXIoYSxuKSxyLmRpdihhKSxuKS5jYXN0KFwiZmxvYXQzMlwiKX0pfWZ1bmN0aW9uIGJpbmFyeUNyb3NzZW50cm9weSQxKGUsdCl7cmV0dXJuIGJpbmFyeUNyb3NzZW50cm9weShlLHQpfWZ1bmN0aW9uIHNwYXJzZUNhdGVnb3JpY2FsQWNjdXJhY3koZSx0KXt0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcn12YXIgbXNlJDE9bWVhblNxdWFyZWRFcnJvcixNU0UkMT1tZWFuU3F1YXJlZEVycm9yLG1hZSQxPW1lYW5BYnNvbHV0ZUVycm9yLE1BRSQxPW1lYW5BYnNvbHV0ZUVycm9yLG1hcGUkMT1tZWFuQWJzb2x1dGVQZXJjZW50YWdlRXJyb3IsTUFQRSQxPW1lYW5BYnNvbHV0ZVBlcmNlbnRhZ2VFcnJvcixjYXRlZ29yaWNhbENyb3NzZW50cm9weSQxPWNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5LGNvc2luZSQxPWNvc2luZVByb3hpbWl0eSxzcGFyc2VDYXRlZ29yaWNhbENyb3NzZW50cm9weSQxPXNwYXJzZUNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5O2Z1bmN0aW9uIGdldCQxKGUpe3ZhciB0PXtiaW5hcnlBY2N1cmFjeTpiaW5hcnlBY2N1cmFjeSxjYXRlZ29yaWNhbEFjY3VyYWN5OmNhdGVnb3JpY2FsQWNjdXJhY3kscHJlY2lzaW9uOnByZWNpc2lvbixjYXRlZ29yaWNhbENyb3NzZW50cm9weTpjYXRlZ29yaWNhbENyb3NzZW50cm9weSQxLHNwYXJzZUNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5OnNwYXJzZUNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5JDEsbXNlOm1zZSQxLE1TRTpNU0UkMSxtYWU6bWFlJDEsTUFFOk1BRSQxLG1hcGU6bWFwZSQxLE1BUEU6TUFQRSQxLGNvc2luZTpjb3NpbmUkMX07aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUmJmUgaW4gdClyZXR1cm4gdFtlXTtpZihcInN0cmluZ1wiIT10eXBlb2YgZSYmbnVsbCE9ZSlyZXR1cm4gZTt0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlVua25vd24gbWV0cmljIFwiK2UpfWZ1bmN0aW9uIGdldE9wdGltaXplcihlKXt2YXIgdD17QWRhZ3JhZDpmdW5jdGlvbigpe3JldHVybiB0cmFpbi5hZGFncmFkKC4wMSl9LEFkYWRlbHRhOmZ1bmN0aW9uKCl7cmV0dXJuIHRyYWluLmFkYWRlbHRhKDEsLjk1LGVwc2lsb24oKSl9LEFkYW06ZnVuY3Rpb24oKXtyZXR1cm4gdHJhaW4uYWRhbSguMDAxLC45LC45OTksZXBzaWxvbigpKX0sQWRhbWF4OmZ1bmN0aW9uKCl7cmV0dXJuIHRyYWluLmFkYW1heCguMDAyLC45LC45OTksZXBzaWxvbigpLDApfSxSTVNQcm9wOmZ1bmN0aW9uKCl7cmV0dXJuIHRyYWluLnJtc3Byb3AoLjAwMSwuOSwwLGVwc2lsb24oKSl9LFNHRDpmdW5jdGlvbigpe3JldHVybiB0cmFpbi5zZ2QoLjAxKX19O2lmKHQuYWRhZ3JhZD10LkFkYWdyYWQsdC5hZGFkZWx0YT10LkFkYWRlbHRhLHQuYWRhbT10LkFkYW0sdC5hZGFtYXg9dC5BZGFtYXgsdC5ybXNwcm9wPXQuUk1TUHJvcCx0LnNnZD10LlNHRCxlIGluIHQpcmV0dXJuIHRbZV0oKTt0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlVua25vd24gT3B0aW1pemVyIFwiK2UpfWZ1bmN0aW9uIHByaW50U3VtbWFyeShlLHQsbixyKXt2b2lkIDA9PT1yJiYocj1jb25zb2xlLmxvZyk7dmFyIGksYT1pc01vZGVsU2VxdWVudGlhbExpa2UoZSksbz1bXCJMYXllciAodHlwZSlcIixcIk91dHB1dCBzaGFwZVwiLFwiUGFyYW0gI1wiXTtpZihhPyh0PXR8fDY1LG49bnx8Wy40NSwuODUsMV0pOih0PXR8fDk4LG49bnx8Wy4zMywuNTUsLjY3LDFdKSxuW24ubGVuZ3RoLTFdPD0xJiYobj1uLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gTWF0aC5mbG9vcih0KmUpfSkpLCFhKWZvcih2YXIgcyBpbiBvLnB1c2goXCJSZWNlaXZlcyBpbnB1dHNcIiksaT1bXSxlLm5vZGVzQnlEZXB0aClpLnB1c2guYXBwbHkoaSxlLm5vZGVzQnlEZXB0aFtzXSk7cihcIl9cIi5yZXBlYXQodCkpLHByaW50Um93KG8sbixyKSxyKFwiPVwiLnJlcGVhdCh0KSk7Zm9yKHZhciBsPWUubGF5ZXJzLHU9MDt1PGwubGVuZ3RoOysrdSlhP3ByaW50TGF5ZXJTdW1tYXJ5KGxbdV0sbixyKTpwcmludExheWVyU3VtbWFyeVdpdGhDb25uZWN0aW9ucyhsW3VdLG4saSxyKSxyKCh1PT09bC5sZW5ndGgtMT9cIj1cIjpcIl9cIikucmVwZWF0KHQpKTtlLmNoZWNrVHJhaW5hYmxlV2VpZ2h0c0NvbnNpc3RlbmN5KCk7dmFyIGM9Y291bnRUcmFpbmFibGVQYXJhbXMoZSkscD1jb3VudFBhcmFtc0luV2VpZ2h0cyhlLm5vblRyYWluYWJsZVdlaWdodHMpO3IoXCJUb3RhbCBwYXJhbXM6IFwiKyhjK3ApKSxyKFwiVHJhaW5hYmxlIHBhcmFtczogXCIrYykscihcIk5vbi10cmFpbmFibGUgcGFyYW1zOiBcIitwKSxyKFwiX1wiLnJlcGVhdCh0KSl9ZnVuY3Rpb24gY291bnRUcmFpbmFibGVQYXJhbXMoZSl7cmV0dXJuIG51bGwhPWUuY29sbGVjdGVkVHJhaW5hYmxlV2VpZ2h0cz9jb3VudFBhcmFtc0luV2VpZ2h0cyhlLmNvbGxlY3RlZFRyYWluYWJsZVdlaWdodHMpOmNvdW50UGFyYW1zSW5XZWlnaHRzKGUudHJhaW5hYmxlV2VpZ2h0cyl9ZnVuY3Rpb24gaXNNb2RlbFNlcXVlbnRpYWxMaWtlKGUpe3ZhciB0PSEwLG49W10scj1bXTtmb3IodmFyIGkgaW4gZS5ub2Rlc0J5RGVwdGgpbi5wdXNoKGUubm9kZXNCeURlcHRoW2ldKTtmb3IodmFyIGE9MCxvPW47YTxvLmxlbmd0aDthKyspe3ZhciBzPW9bYV07aWYocy5sZW5ndGg+MXx8MT09PXMubGVuZ3RoJiZzWzBdLmluYm91bmRMYXllcnMubGVuZ3RoPjEpe3Q9ITE7YnJlYWt9ci5wdXNoLmFwcGx5KHIscyl9aWYodClmb3IodmFyIGw9MCx1PWUubGF5ZXJzO2w8dS5sZW5ndGg7bCsrKXtmb3IodmFyIGM9ITEscD0wLGg9dVtsXS5pbmJvdW5kTm9kZXM7cDxoLmxlbmd0aDtwKyspe3ZhciBkPWhbcF07aWYoLTEhPT1yLmluZGV4T2YoZCkpe2lmKGMpe3Q9ITE7YnJlYWt9Yz0hMH19aWYoIXQpYnJlYWt9cmV0dXJuIHR9ZnVuY3Rpb24gcHJpbnRSb3coZSx0LG4pe3ZvaWQgMD09PW4mJihuPWNvbnNvbGUubG9nKTtmb3IodmFyIHI9XCJcIixpPTA7aTxlLmxlbmd0aDsrK2kpaT4wJiYocj1yLnNsaWNlKDAsci5sZW5ndGgtMSkrXCIgXCIpLHI9KHIrPWVbaV0pLnNsaWNlKDAsdFtpXSkscis9XCIgXCIucmVwZWF0KHRbaV0tci5sZW5ndGgpO24ocil9ZnVuY3Rpb24gcHJpbnRMYXllclN1bW1hcnkoZSx0LG4pe3ZhciByO3RyeXtyPUpTT04uc3RyaW5naWZ5KGUub3V0cHV0U2hhcGUpfWNhdGNoKGUpe3I9XCJtdWx0aXBsZVwifXByaW50Um93KFtlLm5hbWUrXCIgKFwiK2UuZ2V0Q2xhc3NOYW1lKCkrXCIpXCIscixlLmNvdW50UGFyYW1zKCkudG9TdHJpbmcoKV0sdCxuKX1mdW5jdGlvbiBwcmludExheWVyU3VtbWFyeVdpdGhDb25uZWN0aW9ucyhlLHQsbixyKXt2YXIgaTt0cnl7aT1KU09OLnN0cmluZ2lmeShlLm91dHB1dFNoYXBlKX1jYXRjaChlKXtpPVwibXVsdGlwbGVcIn1mb3IodmFyIGE9W10sbz0wLHM9ZS5pbmJvdW5kTm9kZXM7bzxzLmxlbmd0aDtvKyspe3ZhciBsPXNbb107aWYoIShudWxsIT1uJiZuLmxlbmd0aD4wJiYtMT09PW4uaW5kZXhPZihsKSkpZm9yKHZhciB1PTA7dTxsLmluYm91bmRMYXllcnMubGVuZ3RoOysrdSl7dmFyIGM9bC5pbmJvdW5kTGF5ZXJzW3VdLm5hbWUscD1sLm5vZGVJbmRpY2VzW3VdLGg9bC50ZW5zb3JJbmRpY2VzW3VdO2EucHVzaChjK1wiW1wiK3ArXCJdW1wiK2grXCJdXCIpfX12YXIgZD1lLm5hbWUsZj1lLmdldENsYXNzTmFtZSgpLGc9MD09PWEubGVuZ3RoP1wiXCI6YVswXTtwcmludFJvdyhbZCtcIiAoXCIrZitcIilcIixpLGUuY291bnRQYXJhbXMoKS50b1N0cmluZygpLGddLHQscik7Zm9yKHU9MTt1PGEubGVuZ3RoOysrdSlwcmludFJvdyhbXCJcIixcIlwiLFwiXCIsYVt1XV0sdCxyKX1mdW5jdGlvbiBkZXNlcmlhbGl6ZShlLHQpe3JldHVybiB2b2lkIDA9PT10JiYodD17fSksZGVzZXJpYWxpemVLZXJhc09iamVjdChlLHNlcmlhbGl6YXRpb24uU2VyaWFsaXphdGlvbk1hcC5nZXRNYXAoKS5jbGFzc05hbWVNYXAsdCxcImxheWVyXCIpfWZ1bmN0aW9uIGlzQXJyYXlJdGVtSW5wdXRPck91dHB1dE5hbWUoZSx0LG4pe3JldHVybihcImluYm91bmROb2Rlc1wiPT09ZXx8XCJvdXRwdXRMYXllcnNcIj09PWV8fFwiaW5wdXRMYXllcnNcIj09PWUpJiYwPT09dCYmXCJzdHJpbmdcIj09dHlwZW9mIG59ZnVuY3Rpb24gY29udmVydFB5dGhvbmljVG9UcyhlLHQpe2lmKG51bGw9PT1lKXJldHVybiBudWxsO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlKXJldHVybiB0b0NhbWVsQ2FzZShlKTtpZihcIm51bWJlclwiPT10eXBlb2YgZXx8XCJib29sZWFuXCI9PXR5cGVvZiBlKXJldHVybiBlO2lmKGUgaW5zdGFuY2VvZiBBcnJheSl7Zm9yKHZhciBuPVtdLHI9ZS5sZW5ndGgsaT0wO2k8cjsrK2kpe3ZhciBhPWVbaV07aXNBcnJheUl0ZW1JbnB1dE9yT3V0cHV0TmFtZSh0LGksYSk/bi5wdXNoKGEpOm4ucHVzaChjb252ZXJ0UHl0aG9uaWNUb1RzKGEsdCkpfXJldHVybiBufWZvcih2YXIgbz17fSxzPTAsbD1PYmplY3Qua2V5cyhlKTtzPGwubGVuZ3RoO3MrKyl7dmFyIHU9bFtzXSxjPWVbdV07aWYoXCJuYW1lXCI9PT11JiZcInN0cmluZ1wiPT10eXBlb2YgYylvW3VdPWM7ZWxzZXt2YXIgcD10b0NhbWVsQ2FzZSh1KTtvW3BdPWNvbnZlcnRQeXRob25pY1RvVHMoYyxwKX19cmV0dXJuIG99ZnVuY3Rpb24gY29udmVydFRzVG9QeXRob25pYyhlLHQpe2lmKG51bGw9PT1lfHx2b2lkIDA9PT1lKXJldHVybiBudWxsO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlKXJldHVybiB0b1NuYWtlQ2FzZShlKTtpZihcIm51bWJlclwiPT10eXBlb2YgZXx8XCJib29sZWFuXCI9PXR5cGVvZiBlKXJldHVybiBlO2lmKGUgaW5zdGFuY2VvZiBBcnJheSl7Zm9yKHZhciBuPVtdLHI9ZS5sZW5ndGgsaT0wO2k8cjsrK2kpe3ZhciBhPWVbaV07aXNBcnJheUl0ZW1JbnB1dE9yT3V0cHV0TmFtZSh0LGksYSk/bi5wdXNoKGEpOm4ucHVzaChjb252ZXJ0VHNUb1B5dGhvbmljKGEsdCkpfXJldHVybiBufWZvcih2YXIgbz17fSxzPTAsbD1PYmplY3Qua2V5cyhlKTtzPGwubGVuZ3RoO3MrKyl7dmFyIHU9bFtzXSxjPWVbdV0scD10b1NuYWtlQ2FzZSh1KTtvW3BdPVwibmFtZVwiIT09dSYmXCJjbGFzc05hbWVcIiE9PXV8fFwic3RyaW5nXCIhPXR5cGVvZiBjP2NvbnZlcnRUc1RvUHl0aG9uaWMoYyx1KTpjfXJldHVybiBvfXZhciB2ZXJzaW9uPVwiMC44LjVcIjtmdW5jdGlvbiBwcmVwcm9jZXNzV2VpZ2h0c0ZvckxvYWRpbmcoZSx0LG4scil7aWYoIW4uc3RhcnRzV2l0aChcIjIuXCIpKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiVW5zdXBwb3J0ZWQgS2VyYXMgdmVyc2lvbiBpbiB3ZWlnaHRzIGJlaW5nIGxvYWRlZDogXCIrbik7cmV0dXJuIHR9ZnVuY3Rpb24gbG9hZFRlbnNvcihlLHQsbil7dmFyIHI9c3RyaW5nVG9EVHlwZShlKTtyZXR1cm4gVGVuc29yLm1ha2UodCx7dmFsdWVzOjA9PT10Lmxlbmd0aD9uOnV0aWwuZmxhdHRlbihuKX0scil9ZnVuY3Rpb24gbG9hZFdlaWdodHNGcm9tSnNvbihlLHQsbil7dm9pZCAwPT09biYmKG49ITEpO2Zvcih2YXIgcj1lLmtlcmFzX3ZlcnNpb24saT1lLmJhY2tlbmQsYT10Lm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5uYW1lfSksbz17fSxzPTAsbD10O3M8bC5sZW5ndGg7cysrKXtudWxsIT0oYj1sW3NdKS5uYW1lJiYobnVsbD09b1tiLm5hbWVdJiYob1tiLm5hbWVdPVtdKSxvW2IubmFtZV0ucHVzaChiKSl9Zm9yKHZhciB1PWUud2VpZ2h0cyxjPVtdLHA9MDtwPGEubGVuZ3RoOysrcCl7dmFyIGg9YVtwXSxkPXVbaF07bnVsbD09ZCYmKGQ9W10pO2Zvcih2YXIgZj1bXSxnPTA7ZzxkLmxlbmd0aDsrK2cpe3ZhciBtPWRbZ107Zi5wdXNoKG5ldyBMYXllclZhcmlhYmxlKGxvYWRUZW5zb3IobS5kdHlwZSxtLnNoYXBlLG0udmFsdWUpKSl9Zm9yKHZhciB5PTAsdj1vW2hdO3k8di5sZW5ndGg7eSsrKXt2YXIgYix3PShiPXZbeV0pLndlaWdodHM7aWYoKGY9cHJlcHJvY2Vzc1dlaWdodHNGb3JMb2FkaW5nKGIsZixyLGkpKS5sZW5ndGghPT13Lmxlbmd0aCl7aWYoIW4pdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJMYXllciAjXCIrcCsnIChuYW1lZCBcIicrYi5uYW1lKydcIikgZXhwZWN0cyAnK3cubGVuZ3RoK1wiIHdlaWdodChzKSwgYnV0IHRoZSBzYXZlZCB3ZWlnaHRzIGhhdmUgXCIrZi5sZW5ndGgrXCIgZWxlbWVudChzKS5cIik7Y29uc29sZS53YXJuKFwiU2tpcHBpbmcgbG9hZGluZyBvZiB3ZWlnaHRzIG9mIGxheWVyIFwiK2IubmFtZStcIiBkdWUgdG8gbWlzbWF0Y2ggaW4gbnVtYmVyIG9mIHdlaWdodHM6IChcIitmLmxlbmd0aCtcIiB2cyBcIit3Lmxlbmd0aCtcIikuXCIpfWZvcih2YXIgej0wO3o8Zi5sZW5ndGg7Kyt6KSFufHx1dGlsLmFycmF5c0VxdWFsKHdbel0uc2hhcGUsZlt6XS5zaGFwZSk/Yy5wdXNoKFt3W3pdLGZbel0ucmVhZCgpXSk6Y29uc29sZS53YXJuKFwiU2tpcHBpbmcgbG9hZGluZyBvZiB3ZWlnaHRzIGZvciBsYXllciBcIitiLm5hbWUrXCIgZHVlIHRvIG1pc21hdGNoIGluIHNoYXBlIChcIit3W3pdLnNoYXBlK1wiIHZzIFwiK2Zbel0uc2hhcGUrXCIpXCIpfX1iYXRjaFNldFZhbHVlKGMpfWZ1bmN0aW9uIGxvYWRXZWlnaHRzRnJvbU5hbWVkVGVuc29yTWFwKGUsdCxuKXt2b2lkIDA9PT1uJiYobj0hMCk7Zm9yKHZhciByPXt9LGk9MCxhPTAsbz10O2E8by5sZW5ndGg7YSsrKWZvcih2YXIgcz0wLGw9b1thXS53ZWlnaHRzO3M8bC5sZW5ndGg7cysrKXt2YXIgdT1sW3NdO2lmKG51bGwhPXJbdS5vcmlnaW5hbE5hbWVdKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiRHVwbGljYXRlIHdlaWdodCBuYW1lOiBcIit1Lm9yaWdpbmFsTmFtZSk7clt1Lm9yaWdpbmFsTmFtZV09dSxpKyt9dmFyIGM9W107Zm9yKHZhciBwIGluIGUpe2lmKG51bGwhPXJbcF0pYy5wdXNoKFtyW3BdLGVbcF1dKTtlbHNlIGlmKG4pdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJQcm92aWRlZCB3ZWlnaHQgZGF0YSBoYXMgbm8gdGFyZ2V0IHZhcmlhYmxlOiBcIitwKTtkZWxldGUgcltwXX1pZihuKXt2YXIgaD1bXTtmb3IodmFyIGQgaW4gciloLnB1c2goZCk7aWYoaC5sZW5ndGg+MCl0aHJvdyBuZXcgVmFsdWVFcnJvcihoLmxlbmd0aCtcIiBvZiBcIitpK1wiIHdlaWdodHMgYXJlIG5vdCBzZXQ6IFwiK2gpfWJhdGNoU2V0VmFsdWUoYyl9dmFyIENvbnRhaW5lcj1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KG4pe3ZhciByPWUuY2FsbCh0aGlzLHt9KXx8dGhpcztpZihyLmNvbnRhaW5lck5vZGVzPW5ldyBTZXQsci5uYW1lPW4ubmFtZSxudWxsPT1yLm5hbWUpe3ZhciBpPXIuZ2V0Q2xhc3NOYW1lKCkudG9Mb3dlckNhc2UoKTtyLm5hbWU9Z2V0VWlkKGkpfWlmKHIuc3VwcG9ydHNNYXNraW5nPSExLHIudHJhaW5hYmxlPSEwLHIudXBkYXRhYmxlPSEwLEFycmF5LmlzQXJyYXkobi5pbnB1dHMpP3IuaW5wdXRzPW4uaW5wdXRzLnNsaWNlKCk6ci5pbnB1dHM9W24uaW5wdXRzXSxBcnJheS5pc0FycmF5KG4ub3V0cHV0cyk/ci5vdXRwdXRzPW4ub3V0cHV0cy5zbGljZSgpOnIub3V0cHV0cz1bbi5vdXRwdXRzXSx1bmlxdWUoci5pbnB1dHMpLmxlbmd0aCE9PXIuaW5wdXRzLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlRoZSBsaXN0IG9mIGlucHV0cyBwYXNzZWQgdG8gdGhlIG1vZGVsIGlzIHJlZHVuZGFudC4gQWxsIGlucHV0cyBzaG91bGQgb25seSBhcHBlYXIgb25jZS4gRm91bmQ6IFwiK3IuaW5wdXRzLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5uYW1lfSkpO3VuaXF1ZShyLm91dHB1dHMpLmxlbmd0aCE9PXIub3V0cHV0cy5sZW5ndGgmJmNvbnNvbGUud2FybihcIlRoZSBsaXN0IG9mIG91dHB1dHMgcGFzc2VkIHRvIHRoZSBtb2RlbCBpcyByZWR1bmRhbnQuIEFsbCBvdXRwdXRzIHNob3VsZCBvbmx5IGFwcGVhciBvbmNlLiBGb3VuZDogXCIrci5vdXRwdXRzLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5uYW1lfSkpLHIuaW5wdXRMYXllcnM9W10sci5pbnB1dExheWVyc05vZGVJbmRpY2VzPVtdLHIuaW5wdXRMYXllcnNUZW5zb3JJbmRpY2VzPVtdLHIub3V0cHV0TGF5ZXJzPVtdLHIub3V0cHV0TGF5ZXJzTm9kZUluZGljZXM9W10sci5vdXRwdXRMYXllcnNUZW5zb3JJbmRpY2VzPVtdLHIubGF5ZXJzPVtdO2Zvcih2YXIgYT0wLG89ci5vdXRwdXRzO2E8by5sZW5ndGg7YSsrKXt2YXIgcz0oQT1vW2FdKS5zb3VyY2VMYXllcixsPUEubm9kZUluZGV4LHU9QS50ZW5zb3JJbmRleDtyLm91dHB1dExheWVycy5wdXNoKHMpLHIub3V0cHV0TGF5ZXJzTm9kZUluZGljZXMucHVzaChsKSxyLm91dHB1dExheWVyc1RlbnNvckluZGljZXMucHVzaCh1KX1mb3IodmFyIGM9MCxwPXIuaW5wdXRzO2M8cC5sZW5ndGg7YysrKXtzPShBPXBbY10pLnNvdXJjZUxheWVyLGw9QS5ub2RlSW5kZXgsdT1BLnRlbnNvckluZGV4O2Fzc2VydCgwPT09bCxcImlucHV0IGxheWVyIGhhcyA+MSBub2Rlc1wiKSxhc3NlcnQoMD09PXUsXCJpbnB1dCBsYXllciBoYXMgPjEgdGVuc29yc1wiKSxyLmlucHV0TGF5ZXJzLnB1c2gocyksci5pbnB1dExheWVyc05vZGVJbmRpY2VzLnB1c2gobCksci5pbnB1dExheWVyc1RlbnNvckluZGljZXMucHVzaCh1KX1yLmlucHV0TmFtZXM9W10sci5vdXRwdXROYW1lcz1bXSxyLmZlZWRJbnB1dFNoYXBlcz1bXSxyLmZlZWRJbnB1dE5hbWVzPVtdLHIuZmVlZE91dHB1dE5hbWVzPVtdO2Zvcih2YXIgaD0wO2g8ci5pbnB1dExheWVycy5sZW5ndGg7aCsrKXtpZighKChzPXIuaW5wdXRMYXllcnNbaF0paW5zdGFuY2VvZiBJbnB1dExheWVyKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW5wdXQgbGF5ZXJzIHRvIGEgTW9kZWwgbXVzdCBiZSBJbnB1dExheWVyIG9iamVjdHMuIFJlY2VpdmVkIGlucHV0czogXCIrbi5pbnB1dHMrXCIuIElucHV0IFwiK2grXCIgKDAtYmFzZWQpIG9yaWdpbmF0ZXMgZnJvbSBsYXllciB0eXBlIFwiK3MuZ2V0Q2xhc3NOYW1lKCkrXCIuXCIpO3IuaW5wdXROYW1lcy5wdXNoKHMubmFtZSksci5mZWVkSW5wdXRTaGFwZXMucHVzaChzLmJhdGNoSW5wdXRTaGFwZSksci5mZWVkSW5wdXROYW1lcy5wdXNoKHMubmFtZSl9Zm9yKHZhciBkPTAsZj1yLm91dHB1dExheWVycztkPGYubGVuZ3RoO2QrKyl7cz1mW2RdO3Iub3V0cHV0TmFtZXMucHVzaChzLm5hbWUpfXIuaW50ZXJuYWxJbnB1dFNoYXBlcz1yLmlucHV0cy5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUuc2hhcGV9KSxyLmludGVybmFsT3V0cHV0U2hhcGVzPXIub3V0cHV0cy5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUuc2hhcGV9KTtmb3IodmFyIGc9e30sbT17fSx5PXt9LHY9e30sYj17fSx3PVtdLHo9ZnVuY3Rpb24oZSxuLGksYSxvLHMpe251bGwhPWEmJm51bGwhPW8mJm51bGwhPXN8fChhPWUuc291cmNlTGF5ZXIsbz1lLm5vZGVJbmRleCxzPWUudGVuc29ySW5kZXgpO3ZhciBsPWEuaW5ib3VuZE5vZGVzW29dO2lmKC0xIT09aS5pbmRleE9mKGwpKXRocm93IG5ldyBSdW50aW1lRXJyb3IoXCJUaGUgdGVuc29yIFwiK2UubmFtZSsnIGF0IGxheWVyIFwiJythLm5hbWUrJ1wiIGlzIHBhcnQgb2YgYSBjeWNsZS4nKTtpZigtMT09PW4uaW5kZXhPZihsKSl7ci5jb250YWluZXJOb2Rlcy5hZGQodC5ub2RlS2V5KGEsbykpLGEuaWQgaW4gYnx8KGJbYS5pZF09T2JqZWN0LmtleXMoYikubGVuZ3RoKSwtMT09PWkuaW5kZXhPZihsKSYmaS5wdXNoKGwpO2Zvcih2YXIgdT1sLmluYm91bmRMYXllcnMubGVuZ3RoLGM9MDtjPHU7YysrKXt2YXIgcD1sLmlucHV0VGVuc29yc1tjXSxoPWwuaW5ib3VuZExheWVyc1tjXSxkPWwubm9kZUluZGljZXNbY10sZj1sLnRlbnNvckluZGljZXNbY107eihwLG4saSxoLGQsZil9Zm9yKG4ucHVzaChsKTtpLmluZGV4T2YobCk+PTA7KWkuc3BsaWNlKGkuaW5kZXhPZihsKSwxKTt3LnB1c2gobCl9fSxTPVtdLEk9W10sTj0wLEM9ci5vdXRwdXRzO048Qy5sZW5ndGg7TisrKXt2YXIgQT1DW05dO3ooQSxTLEkpfWZvcih2YXIgXz0wLEU9dy5zbGljZSgpLnJldmVyc2UoKTtfPEUubGVuZ3RoO18rKyl7bVsoSz1FW19dKS5pZF09SyxLLmlkIGluIGd8fChnW0suaWRdPTApO3ZhciBrPWdbSy5pZF0sTD1udWxsPT15W0sub3V0Ym91bmRMYXllci5pZF0/MDp5W0sub3V0Ym91bmRMYXllci5pZF07az1NYXRoLm1heChrLEwpLHlbSy5vdXRib3VuZExheWVyLmlkXT1rLHZbSy5vdXRib3VuZExheWVyLmlkXT1LLm91dGJvdW5kTGF5ZXIsZ1tLLmlkXT1rO2ZvcihoPTA7aDxLLmluYm91bmRMYXllcnMubGVuZ3RoO2grKyl7dmFyIHg9Sy5pbmJvdW5kTGF5ZXJzW2hdLFQ9KGw9Sy5ub2RlSW5kaWNlc1toXSx4LmluYm91bmROb2Rlc1tsXSksRD1udWxsPT1nW1QuaWRdPzA6Z1tULmlkXTtnW1QuaWRdPU1hdGgubWF4KGsrMSxEKSxtW1QuaWRdPVR9fXZhciBPPXt9O2Zvcih2YXIgUiBpbiBnKXsoaz1nW1JdKWluIE98fChPW2tdPVtdKSxPW2tdLnB1c2gobVtSXSl9dmFyIE09e307Zm9yKHZhciBQIGluIHkpeyhrPXlbUF0paW4gTXx8KE1ba109W10pLE1ba10ucHVzaCh2W1BdKX12YXIgVj1PYmplY3Qua2V5cyhNKS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIHBhcnNlSW50KGUsMTApfSkuc29ydChyZXZlcnNlTnVtYmVyQ29tcGFyZSk7ci5sYXllcnM9W107Zm9yKHZhciBGPTAsQj1WO0Y8Qi5sZW5ndGg7RisrKXt2YXIgVT1NW2s9QltGXV07VS5zb3J0KGZ1bmN0aW9uKGUsdCl7dmFyIG49YltlLmlkXSxyPWJbdC5pZF07cmV0dXJuIG48cj8tMTpuPnI/MTowfSk7Zm9yKHZhciBqPTAsVz1VO2o8Vy5sZW5ndGg7aisrKXtzPVdbal07ci5sYXllcnMucHVzaChzKX19ci5sYXllcnNCeURlcHRoPU0sVj1PYmplY3Qua2V5cyhPKS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIHBhcnNlSW50KGUsMTApfSkuc29ydChyZXZlcnNlTnVtYmVyQ29tcGFyZSk7Zm9yKHZhciAkPXIuaW5wdXRzLnNsaWNlKCkscT1bXSxHPTAsSj1WO0c8Si5sZW5ndGg7RysrKWZvcih2YXIgSD0wLFo9T1trPUpbR11dO0g8Wi5sZW5ndGg7SCsrKXt2YXIgSztpZihudWxsIT0ocz0oSz1aW0hdKS5vdXRib3VuZExheWVyKSl7Zm9yKHZhciBZPTAsWD1LLmlucHV0VGVuc29ycztZPFgubGVuZ3RoO1krKyl7QT1YW1ldO2lmKC0xPT09JC5pbmRleE9mKEEpKXRocm93IG5ldyBSdW50aW1lRXJyb3IoXCJHcmFwaCBkaXNjb25uZWN0ZWQ6IGNhbm5vdCBvYnRhaW4gdmFsdWUgZm9yIHRlbnNvciBcIitBKycgYXQgbGF5ZXIgXCInK3MubmFtZSsnXCIuIFRoZSBmb2xsb3dpbmcgcHJldmlvdXMgbGF5ZXJzIHdlcmUgYWNjZXNzZWQgd2l0aG91dCBpc3N1ZTogJytxKX1mb3IodmFyIFE9MCxlZT1LLm91dHB1dFRlbnNvcnM7UTxlZS5sZW5ndGg7USsrKXtBPWVlW1FdOyQucHVzaChBKX1xLnB1c2gocy5uYW1lKX19ci5ub2Rlc0J5RGVwdGg9Tztmb3IodmFyIHRlPXIubGF5ZXJzLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5uYW1lfSksbmU9ZnVuY3Rpb24oZSl7dmFyIHQ9dGUuZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVybiB0PT09ZX0pLmxlbmd0aDtpZigxIT09dCl0aHJvdyBuZXcgUnVudGltZUVycm9yKCdUaGUgbmFtZSBcIicrZSsnXCIgaXMgdXNlZCAnK3QrXCIgdGltZXMgaW4gdGhlIG1vZGVsLiBBbGwgbGF5ZXIgbmFtZXMgc2hvdWxkIGJlIHVuaXF1ZS4gTGF5ZXIgbmFtZXM6IFwiK0pTT04uc3RyaW5naWZ5KHRlKSl9LHJlPTAsaWU9dGU7cmU8aWUubGVuZ3RoO3JlKyspe25lKGllW3JlXSl9cmV0dXJuIHIub3V0Ym91bmROb2Rlcz1bXSxyLmluYm91bmROb2Rlcz1bXSxuZXcgTm9kZSh7b3V0Ym91bmRMYXllcjpyLGluYm91bmRMYXllcnM6W10sbm9kZUluZGljZXM6W10sdGVuc29ySW5kaWNlczpbXSxpbnB1dFRlbnNvcnM6ci5pbnB1dHMsb3V0cHV0VGVuc29yczpyLm91dHB1dHMsaW5wdXRNYXNrczpyLmlucHV0cy5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIG51bGx9KSxvdXRwdXRNYXNrczpyLm91dHB1dHMubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBudWxsfSksaW5wdXRTaGFwZXM6ci5pbnB1dHMubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLnNoYXBlfSksb3V0cHV0U2hhcGVzOnIub3V0cHV0cy5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUuc2hhcGV9KX0pLHIuYnVpbHQ9ITAsci5fcmVmQ291bnQ9MSxyfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5hc3NlcnROb3REaXNwb3NlZD1mdW5jdGlvbigpe2lmKDA9PT10aGlzLl9yZWZDb3VudCl0aHJvdyBuZXcgRXJyb3IoXCJDb250YWluZXIgJ1wiK3RoaXMubmFtZStcIicgaXMgYWxyZWFkeSBkaXNwb3NlZC5cIil9LHQucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt0aGlzLmFzc2VydE5vdERpc3Bvc2VkKCk7dmFyIGU9e3JlZkNvdW50QWZ0ZXJEaXNwb3NlOm51bGwsbnVtRGlzcG9zZWRWYXJpYWJsZXM6MH07aWYoMD09LS10aGlzLl9yZWZDb3VudClmb3IodmFyIHQ9MCxuPXRoaXMubGF5ZXJzO3Q8bi5sZW5ndGg7dCsrKXt2YXIgcj1uW3RdO2UubnVtRGlzcG9zZWRWYXJpYWJsZXMrPXIuZGlzcG9zZSgpLm51bURpc3Bvc2VkVmFyaWFibGVzfXJldHVybiBlLnJlZkNvdW50QWZ0ZXJEaXNwb3NlPXRoaXMuX3JlZkNvdW50LGV9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInRyYWluYWJsZVdlaWdodHNcIix7Z2V0OmZ1bmN0aW9uKCl7aWYodGhpcy5fdHJhaW5hYmxlV2VpZ2h0cy5sZW5ndGg+MCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkNvbnRhaW5lciBpbnN0YW5jZSB1bmV4cGVjdGVkbHkgY29udGFpbnMgX3RyYWluYWJsZVdlaWdodHMuVGhlIHRyYWluYWJsZSB3ZWlnaHRzIG9mIGEgQ29udGFpbmVyIGFyZSBhIHVuaW9uIG9mIHRoZSB0cmFpbmFibGUgd2VpZ2h0cyBvZiBpdHMgY29uc2l0dWVudCBMYXllcnMuIEl0cyBvd24gX3RyYWluYWJsZVdlaWdodHMgbXVzdCByZW1haW4gYW4gZW1wdHkgQXJyYXkuXCIpO2lmKCF0aGlzLnRyYWluYWJsZSlyZXR1cm5bXTtmb3IodmFyIGU9W10sdD0wLG49dGhpcy5sYXllcnM7dDxuLmxlbmd0aDt0Kyspe3ZhciByPW5bdF07ZT1lLmNvbmNhdChyLnRyYWluYWJsZVdlaWdodHMpfXJldHVybiBlfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcIm5vblRyYWluYWJsZVdlaWdodHNcIix7Z2V0OmZ1bmN0aW9uKCl7Zm9yKHZhciBlPVtdLHQ9MCxuPXRoaXMubGF5ZXJzO3Q8bi5sZW5ndGg7dCsrKXt2YXIgcj1uW3RdO2UucHVzaC5hcHBseShlLHIubm9uVHJhaW5hYmxlV2VpZ2h0cyl9aWYoIXRoaXMudHJhaW5hYmxlKXtmb3IodmFyIGk9W10sYT0wLG89dGhpcy5sYXllcnM7YTxvLmxlbmd0aDthKyspe3I9b1thXTtpLnB1c2guYXBwbHkoaSxyLnRyYWluYWJsZVdlaWdodHMpfXJldHVybiBpLmNvbmNhdChlKX1yZXR1cm4gZX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJ3ZWlnaHRzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnRyYWluYWJsZVdlaWdodHMuY29uY2F0KHRoaXMubm9uVHJhaW5hYmxlV2VpZ2h0cyl9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksdC5wcm90b3R5cGUubG9hZFdlaWdodHM9ZnVuY3Rpb24oZSx0LG4scil7dm9pZCAwPT09dCYmKHQ9ITEpLHZvaWQgMD09PW4mJihuPSExKSx2b2lkIDA9PT1yJiYocj0hMCksbj9sb2FkV2VpZ2h0c0Zyb21OYW1lZFRlbnNvck1hcChlLHRoaXMubGF5ZXJzLHIpOmxvYWRXZWlnaHRzRnJvbUpzb24oZSx0aGlzLmxheWVycyx0KX0sdC5wcm90b3R5cGUudXBkYXRlZENvbmZpZz1mdW5jdGlvbigpe3ZhciBlPXRoaXMuZ2V0Q29uZmlnKCk7cmV0dXJue2NsYXNzTmFtZTp0aGlzLmdldENsYXNzTmFtZSgpLGNvbmZpZzplLGtlcmFzVmVyc2lvbjpcInRmanMtbGF5ZXJzIFwiK3ZlcnNpb24sYmFja2VuZDpcIlRlbnNvckZsb3cuanNcIn19LHQucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbihlLHQpe3ZvaWQgMD09PXQmJih0PSEwKTt2YXIgbj1jb252ZXJ0VHNUb1B5dGhvbmljKHRoaXMudXBkYXRlZENvbmZpZygpKTtyZXR1cm4gdD9KU09OLnN0cmluZ2lmeShuKTpufSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciByO3JldHVybiBlPXRvTGlzdChlKSxyPVwibWFza1wiaW4gdD90b0xpc3QodC5tYXNrKTpweUxpc3RSZXBlYXQobnVsbCxlLmxlbmd0aCksbi5ydW5JbnRlcm5hbEdyYXBoKGUscilbMF19KX0sdC5wcm90b3R5cGUuY29tcHV0ZU1hc2s9ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIHI7cmV0dXJuIGU9dG9MaXN0KGUpLHI9bnVsbD09dD9weUxpc3RSZXBlYXQobnVsbCxlLmxlbmd0aCk6dG9MaXN0KHQpLG4ucnVuSW50ZXJuYWxHcmFwaChlLHIpWzFdfSl9LHQucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZT1mdW5jdGlvbihlKXt2YXIgdD1ub3JtYWxpemVTaGFwZUxpc3QoZSk7aWYodC5sZW5ndGghPT10aGlzLmlucHV0TGF5ZXJzLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkludmFsaWQgaW5wdXRTaGFwZSBhcmd1bWVudCBcIitlK1wiOiBtb2RlbCBoYXMgXCIrdGhpcy5pbnB1dExheWVycy5sZW5ndGgrXCIgdGVuc29yIGlucHV0cy5cIik7Zm9yKHZhciBuPXt9LHI9MDtyPHQubGVuZ3RoO3IrKyl7dmFyIGk9dGhpcy5pbnB1dExheWVyc1tyXSxhPXRbcl07bltJPWkubmFtZStcIl8wXzBcIl09YX12YXIgbz1PYmplY3Qua2V5cyh0aGlzLm5vZGVzQnlEZXB0aCkubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBwYXJzZUludChlLDEwKX0pLnNvcnQocmV2ZXJzZU51bWJlckNvbXBhcmUpO2lmKG8ubGVuZ3RoPjEpZm9yKHZhciBzPTAsbD1vO3M8bC5sZW5ndGg7cysrKWZvcih2YXIgdT1sW3NdLGM9MCxwPXRoaXMubm9kZXNCeURlcHRoW3VdO2M8cC5sZW5ndGg7YysrKXt2YXIgaD1wW2NdO2k9aC5vdXRib3VuZExheWVyO2lmKC0xPT09dGhpcy5pbnB1dExheWVycy5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUuaWR9KS5pbmRleE9mKGkuaWQpKXtmb3IodmFyIGQ9W10sZj0wO2Y8aC5pbmJvdW5kTGF5ZXJzLmxlbmd0aDtmKyspe3ZhciBnPWguaW5ib3VuZExheWVyc1tmXSxtPWgubm9kZUluZGljZXNbZl0seT1oLnRlbnNvckluZGljZXNbZl0sdj1uW0k9Zy5uYW1lK1wiX1wiK20rXCJfXCIreV07ZC5wdXNoKHYpfXZhciBiPW5vcm1hbGl6ZVNoYXBlTGlzdChpLmNvbXB1dGVPdXRwdXRTaGFwZShzaW5nbGV0b25PckFycmF5KGQpKSksdz1pLmluYm91bmROb2Rlcy5pbmRleE9mKGgpO2ZvcihmPTA7ZjxiLmxlbmd0aDtmKyspe25bST1pLm5hbWUrXCJfXCIrdytcIl9cIitmXT1iW2ZdfX19dmFyIHo9W10sUz1bXTtmb3Iocj0wO3I8dGhpcy5vdXRwdXRMYXllcnMubGVuZ3RoO3IrKyl7aT10aGlzLm91dHB1dExheWVyc1tyXSx3PXRoaXMub3V0cHV0TGF5ZXJzTm9kZUluZGljZXNbcl0seT10aGlzLm91dHB1dExheWVyc1RlbnNvckluZGljZXNbcl07dmFyIEk9aS5uYW1lK1wiX1wiK3crXCJfXCIreTtTLnB1c2goSSl9Zm9yKHI9MDtyPFMubGVuZ3RoO3IrKyl7dmFyIE49U1tyXTthc3NlcnQoTiBpbiBuKSx6LnB1c2gobltOXSl9cmV0dXJuIHNpbmdsZXRvbk9yQXJyYXkoeil9LHQucHJvdG90eXBlLnJ1bkludGVybmFsR3JhcGg9ZnVuY3Rpb24oZSx0KXtudWxsPT10JiYodD1weUxpc3RSZXBlYXQobnVsbCxlLmxlbmd0aCkpO2Zvcih2YXIgbj17fSxyPTA7cjx0aGlzLmlucHV0cy5sZW5ndGg7KytyKXt2YXIgaT10aGlzLmlucHV0c1tyXSxhPWVbcl0sbz10W3JdO25baS5pZF09W2Esb119Zm9yKHZhciBzPTAsbD1PYmplY3Qua2V5cyh0aGlzLm5vZGVzQnlEZXB0aCkubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBwYXJzZUludChlLDEwKX0pLnNvcnQocmV2ZXJzZU51bWJlckNvbXBhcmUpO3M8bC5sZW5ndGg7cysrKWZvcih2YXIgdT1sW3NdLGM9MCxwPXRoaXMubm9kZXNCeURlcHRoW3VdO2M8cC5sZW5ndGg7YysrKXtmb3IodmFyIGg9cFtjXSxkPWgub3V0Ym91bmRMYXllcixmPWguaW5wdXRUZW5zb3JzLGc9aC5vdXRwdXRUZW5zb3JzLG09bmV3IEFycmF5LHk9MCx2PWY7eTx2Lmxlbmd0aDt5KyspeyhpPXZbeV0pLmlkIGluIG4mJm0ucHVzaChuW2kuaWRdKX1pZihtLmxlbmd0aD09PWYubGVuZ3RoKXt2YXIgYj17fSx3PXZvaWQgMCx6PXZvaWQgMCxTPXZvaWQgMCxJPXZvaWQgMDtpZihudWxsIT1oLmNhbGxBcmdzJiYoYj1oLmNhbGxBcmdzKSwxPT09bS5sZW5ndGgpe3ZhciBOPW1bMF0sQz1OWzBdLEE9TlsxXTtudWxsPT1iLm1hc2smJihiLm1hc2s9QSksUz10b0xpc3QoZC5jYWxsKEMsYikpLEk9dG9MaXN0KGQuY29tcHV0ZU1hc2soQyxBKSksdz1bQ10sej1bQV19ZWxzZSB3PW0ubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlWzBdfSksej1tLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZVsxXX0pLG51bGw9PWIubWFzayYmKGIubWFzaz16KSxTPXRvTGlzdChkLmNhbGwodyxiKSksST10b0xpc3QoZC5jb21wdXRlTWFzayh3LHopKTtpZihkLmFjdGl2aXR5UmVndWxhcml6ZXIpdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJNb2RlbCBpbnZvY2F0aW9uIHdpdGggY29uY3JldGUgVGVuc29yIHZhbHVlKHMpIGluIHRoZSBwcmVzZW5jZSBvZiBhY3Rpdml0eSByZWd1bGFyaXplcihzKSBpcyBub3Qgc3VwcG9ydGVkIHlldC5cIik7Zm9yKHI9MDtyPGcubGVuZ3RoOysrcil7aT1nW3JdLGE9U1tyXSxvPUlbcl07bltpLmlkXT1bYSxvXX19fWZvcih2YXIgXz1bXSxFPVtdLGs9W10sTD0wLHg9dGhpcy5vdXRwdXRzO0w8eC5sZW5ndGg7TCsrKXthc3NlcnQoKGk9eFtMXSkuaWQgaW4gbixcIkNvdWxkIG5vdCBjb21wdXRlIG91dHB1dCBcIitpLm5hbWUrXCIgOiBcIitpLmlkKTt2YXIgVD1uW2kuaWRdLEQ9VFswXTtvPVRbMV07ay5wdXNoKEQuc2hhcGUpLF8ucHVzaChEKSxFLnB1c2gobyl9cmV0dXJuW18sRSxrXX0sdC5wcm90b3R5cGUuYnVpbGROb2RlQ29udmVyc2lvbk1hcD1mdW5jdGlvbihlKXtmb3IodmFyIG4scj17fSxpPTAsYT10aGlzLmxheWVycztpPGEubGVuZ3RoO2krKyl7dmFyIG89YVtpXTtuPW8gaW5zdGFuY2VvZiB0PzE6MDtmb3IodmFyIHM9MDtzPG8uaW5ib3VuZE5vZGVzLmxlbmd0aDtzKyspe3ZhciBsPXQubm9kZUtleShvLHMpO3RoaXMuY29udGFpbmVyTm9kZXMuaGFzKGwpJiYocltsXT1uLG4rPTEpfX1yZXR1cm4gcn0sdC5wcm90b3R5cGUuZ2V0TGF5ZXI9ZnVuY3Rpb24oZSx0KXtpZihudWxsIT10KXtpZih0aGlzLmxheWVycy5sZW5ndGg8PXQpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJXYXMgYXNrZWQgdG8gcmV0cmlldmUgbGF5ZXIgYXQgaW5kZXggXCIrdCtcIiwgYnV0IG1vZGVsIG9ubHkgaGFzIFwiK3RoaXMubGF5ZXJzLmxlbmd0aCtcIiBsYXllcihzKS5cIik7cmV0dXJuIHRoaXMubGF5ZXJzW3RdfWlmKG51bGw9PWUpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJQcm92aWRlIGVpdGhlciBhIGxheWVyIG5hbWUgb3IgbGF5ZXIgaW5kZXhcIik7Zm9yKHZhciBuPTAscj10aGlzLmxheWVycztuPHIubGVuZ3RoO24rKyl7dmFyIGk9cltuXTtpZihpLm5hbWU9PT1lKXJldHVybiBpfXRocm93IG5ldyBWYWx1ZUVycm9yKFwiTm8gc3VjaCBsYXllcjogXCIrZSl9LHQucHJvdG90eXBlLmNhbGN1bGF0ZUxvc3Nlcz1mdW5jdGlvbigpe3ZhciBlPXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtmb3IodmFyIG49W10scj0wLGk9ZS5sYXllcnM7cjxpLmxlbmd0aDtyKyspZm9yKHZhciBhPWlbcl0sbz0wO288YS5pbmJvdW5kTm9kZXMubGVuZ3RoOysrbyl7dmFyIHM9dC5ub2RlS2V5KGEsbyk7ZS5jb250YWluZXJOb2Rlcy5oYXMocykmJm4ucHVzaC5hcHBseShuLGEuY2FsY3VsYXRlTG9zc2VzKCkpfXJldHVybiBufSl9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe2Zvcih2YXIgZT17bmFtZTp0aGlzLm5hbWV9LG49dGhpcy5idWlsZE5vZGVDb252ZXJzaW9uTWFwKHRoaXMubGF5ZXJzKSxyPVtdLGk9MCxhPXRoaXMubGF5ZXJzO2k8YS5sZW5ndGg7aSsrKXtmb3IodmFyIG89KGI9YVtpXSkuZ2V0Q2xhc3NOYW1lKCkscz1iLmdldENvbmZpZygpLGw9W10sdT0wO3U8Yi5pbmJvdW5kTm9kZXMubGVuZ3RoO3UrKyl7dmFyIGM9Yi5pbmJvdW5kTm9kZXNbdV0scD10Lm5vZGVLZXkoYix1KSxoPXt9O2lmKHRoaXMuY29udGFpbmVyTm9kZXMuaGFzKHApKXtpZihjLmNhbGxBcmdzKXRyeXtKU09OLnN0cmluZ2lmeShjLmNhbGxBcmdzKSxoPWMuY2FsbEFyZ3N9Y2F0Y2goZSl7Y29uc29sZS53YXJuKFwiTGF5ZXIgXCIrYi5uYW1lK1wiIHdhcyBwYXNzZWQgbm9uLXNlcmlhbGl6YWJsZSBrZXl3b3JkIGFyZ3VtZW50czogXCIrYy5jYWxsQXJncytcIi4gVGhleSB3aWxsIG5vdCBiZSBpbmNsdWRlZCBpbiB0aGUgc2VyaWFsaXplZCBtb2RlbCAoYW5kIHRodXMgd2lsbCBiZSBtaXNzaW5nIGF0IGRlc2VyaWFsaXphdGlvbiB0aW1lKS5cIiksaD17fX1pZihjLmluYm91bmRMYXllcnMubGVuZ3RoPjApe2Zvcih2YXIgZD1bXSxmPTA7ZjxjLmluYm91bmRMYXllcnMubGVuZ3RoO2YrKyl7dmFyIGc9Yy5pbmJvdW5kTGF5ZXJzW2ZdLG09Yy5ub2RlSW5kaWNlc1tmXSx5PWMudGVuc29ySW5kaWNlc1tmXTtudWxsPT0oej1uW3Qubm9kZUtleShnLG0pXSkmJih6PTApLGQucHVzaChbZy5uYW1lLHoseSxoXSl9bC5wdXNoKGQpfX19ci5wdXNoKHtuYW1lOmIubmFtZSxjbGFzc05hbWU6byxjb25maWc6cyxpbmJvdW5kTm9kZXM6bH0pfWUubGF5ZXJzPXI7dmFyIHY9W107Zm9yKGY9MDtmPHRoaXMuaW5wdXRMYXllcnMubGVuZ3RoO2YrKyl7dmFyIGI9dGhpcy5pbnB1dExheWVyc1tmXTttPXRoaXMuaW5wdXRMYXllcnNOb2RlSW5kaWNlc1tmXSxwPXQubm9kZUtleShiLG0pO2lmKHRoaXMuY29udGFpbmVyTm9kZXMuaGFzKHApKXtudWxsIT09KHo9bltwXSkmJnZvaWQgMCE9PXp8fCh6PTApO3k9dGhpcy5pbnB1dExheWVyc1RlbnNvckluZGljZXNbZl07di5wdXNoKFtiLm5hbWUseix5XSl9fWUuaW5wdXRMYXllcnM9djt2YXIgdz1bXTtmb3IoZj0wO2Y8dGhpcy5vdXRwdXRMYXllcnMubGVuZ3RoO2YrKyl7Yj10aGlzLm91dHB1dExheWVyc1tmXSxtPXRoaXMub3V0cHV0TGF5ZXJzTm9kZUluZGljZXNbZl0scD10Lm5vZGVLZXkoYixtKTtpZih0aGlzLmNvbnRhaW5lck5vZGVzLmhhcyhwKSl7dmFyIHo7bnVsbCE9PSh6PW5bcF0pJiZ2b2lkIDAhPT16fHwoej0wKTt5PXRoaXMub3V0cHV0TGF5ZXJzVGVuc29ySW5kaWNlc1tmXTt3LnB1c2goW2IubmFtZSx6LHldKX19cmV0dXJuIGUub3V0cHV0TGF5ZXJzPXcsZX0sdC5mcm9tQ29uZmlnPWZ1bmN0aW9uKGUsdCl7dmFyIG49e30scj17fTtmdW5jdGlvbiBpKGUsdCl7ZS5uYW1lIGluIHI/cltlLm5hbWVdLnB1c2godCk6cltlLm5hbWVdPVt0XX1mdW5jdGlvbiBhKGUsdCl7Zm9yKHZhciByLGE9W10sbz0wLHM9dDtvPHMubGVuZ3RoO28rKyl7dmFyIGw9c1tvXSx1PWxbMF0sYz1sWzFdLHA9bFsyXTtpZigzPT09bC5sZW5ndGgpcj17fTtlbHNle2lmKDQhPT1sLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkltcHJvcGVybHkgZm9ybWF0dGVkIG1vZGVsIGNvbmZpZyBmb3IgbGF5ZXIgXCIrSlNPTi5zdHJpbmdpZnkoZSkrXCI6IFwiK0pTT04uc3RyaW5naWZ5KGwpKTtyPWxbM119aWYoISh1IGluIG4pKXJldHVybiB2b2lkIGkoZSx0KTt2YXIgaD1uW3VdO2lmKGguaW5ib3VuZE5vZGVzLmxlbmd0aDw9YylyZXR1cm4gdm9pZCBpKGUsdCk7dmFyIGQ9aC5pbmJvdW5kTm9kZXNbY107YS5wdXNoKGQub3V0cHV0VGVuc29yc1twXSl9YS5sZW5ndGg+MCYmZS5hcHBseShzaW5nbGV0b25PckFycmF5KGEpLHIpfWZ1bmN0aW9uIG8oZSl7dmFyIHI9ZS5uYW1lLGE9ZGVzZXJpYWxpemUoZSxudWxsIT10LmN1c3RvbU9iamVjdHM/dC5jdXN0b21PYmplY3RzOnt9KTtuW3JdPWE7Zm9yKHZhciBvPTAscz1lLmluYm91bmROb2RlcztvPHMubGVuZ3RoO28rKyl7dmFyIGw9c1tvXTtpZighKGwgaW5zdGFuY2VvZiBBcnJheSkpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJDb3JydXB0ZWQgY29uZmlndXJhdGlvbiwgZXhwZWN0ZWQgYXJyYXkgZm9yIG5vZGVEYXRhOiBcIitsKTtpKGEsbCl9fWZvcih2YXIgcz10Lm5hbWUsbD10LmxheWVycyx1PTAsYz1sO3U8Yy5sZW5ndGg7dSsrKXtvKGQ9Y1t1XSl9Zm9yKDshaXNPYmplY3RFbXB0eShyKTspZm9yKHZhciBwPTAsaD1sO3A8aC5sZW5ndGg7cCsrKXt2YXIgZD1oW3BdO2lmKChfPW5bZC5uYW1lXSkubmFtZSBpbiByKXt2YXIgZj1yW18ubmFtZV07ZGVsZXRlIHJbXy5uYW1lXTtmb3IodmFyIGc9MCxtPWY7ZzxtLmxlbmd0aDtnKyspe2EoXyxtW2ddKX19fWZvcih2YXIgeT1bXSx2PVtdLGI9MCx3PXQuaW5wdXRMYXllcnM7Yjx3Lmxlbmd0aDtiKyspe3ZhciB6PShkPXdbYl0pWzBdLFM9ZFsxXSxJPWRbMl07YXNzZXJ0KHogaW4gbik7dmFyIE49KF89blt6XSkuaW5ib3VuZE5vZGVzW1NdLm91dHB1dFRlbnNvcnM7eS5wdXNoKE5bSV0pfWZvcih2YXIgQz0wLEE9dC5vdXRwdXRMYXllcnM7QzxBLmxlbmd0aDtDKyspe3o9KGQ9QVtDXSlbMF0sUz1kWzFdLEk9ZFsyXTthc3NlcnQoeiBpbiBuKTt2YXIgXztOPShfPW5bel0pLmluYm91bmROb2Rlc1tTXS5vdXRwdXRUZW5zb3JzO3YucHVzaChOW0ldKX1yZXR1cm4gbmV3IGUoe2lucHV0czp5LG91dHB1dHM6dixuYW1lOnN9KX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwic3RhdGVmdWxcIix7Z2V0OmZ1bmN0aW9uKCl7aWYodGhpcy5fc3RhdGVmdWwpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJDb250YWluZXIgaW5zdGFuY2UgdW5leHBlY3RlZGx5IGhhcyBfc3RhdGVmdWwgPSB0cnVlLiBUaGUgc3RhdGVmdWxuZXNzIG9mIGEgQ29udGFpbmVyIGlzIGRldGVybWluZWQgYnkgdGhlIExheWVycyBpdCBjb250YWlucy4gSXRzIF9zdGF0ZWZ1bCBwcm9wZXJ0eSBtdXN0IHJlbWFpbiB0aGUgZGVmYXVsdCBmYWxzZS5cIik7Zm9yKHZhciBlPTAsdD10aGlzLmxheWVycztlPHQubGVuZ3RoO2UrKyl7aWYodFtlXS5zdGF0ZWZ1bClyZXR1cm4hMH1yZXR1cm4hMX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSx0LnByb3RvdHlwZS5yZXNldFN0YXRlcz1mdW5jdGlvbigpe3ZhciBlPXRoaXM7dGlkeShmdW5jdGlvbigpe2UubGF5ZXJzLmZvckVhY2goZnVuY3Rpb24oZSl7ZS5zdGF0ZWZ1bCYmZS5yZXNldFN0YXRlcygpfSl9KX0sdH0oTGF5ZXIpO2Z1bmN0aW9uIGFzc2VydEZlZWRDb21wYXRpYmlsaXR5KGUsdCl7aWYobnVsbCE9ZS5zaGFwZSl7aWYoZS5zaGFwZS5sZW5ndGghPT10LnNoYXBlLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlRoZSByYW5rIG9mIGZlZWQgKFwiK3Quc2hhcGUubGVuZ3RoK1wiKSBkb2VzIG5vdCBtYXRjaCB0aGUgcmFuayBvZiB0aGUga2V5IChcIitlLnNoYXBlLmxlbmd0aCtcIikuXCIpO2Zvcih2YXIgbj0wO248ZS5zaGFwZS5sZW5ndGg7KytuKWlmKG51bGwhPWUuc2hhcGVbbl0mJmUuc2hhcGVbbl0hPT10LnNoYXBlW25dKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiVGhlIFwiK24rXCItdGggZGltZW5zaW9uIG9mIHRoZSBmZWVkIChcIit0LnNoYXBlW25dK1wiKSBpcyBpbmNvbXBhdGlibGUgd2l0aCB0aGF0IG9mIHRoZSBrZXkgKFwiK2Uuc2hhcGVbbl0rXCIpLlwiKX1pZihudWxsPT1lLmR0eXBlfHxlLmR0eXBlPT09dC5kdHlwZSlyZXR1cm4gdDt0cnl7cmV0dXJuIGNhc3QodCxlLmR0eXBlKX1jYXRjaChuKXt0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlRoZSBkdHlwZSBvZiB0aGUgZmVlZCAoXCIrdC5kdHlwZStcIikgY2FuIG5vdCBiZSBjYXN0IHRvIHRoZSBkdHlwZSBvZiB0aGUga2V5ICdcIitlLm5hbWUrXCInIChcIitlLmR0eXBlK1wiKS5cIil9fXZhciBGZWVkRGljdD1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCl7aWYodGhpcy5pZDJWYWx1ZT17fSx0IGluc3RhbmNlb2YgZSlmb3IodmFyIG4gaW4gdC5pZDJWYWx1ZSl0aGlzLmlkMlZhbHVlW25dPXQuaWQyVmFsdWVbbl07ZWxzZXtpZihudWxsPT10KXJldHVybjtmb3IodmFyIHI9MCxpPXQ7cjxpLmxlbmd0aDtyKyspe3ZhciBhPWlbcl07dGhpcy5hZGQoYS5rZXksYS52YWx1ZSl9fX1yZXR1cm4gZS5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKGUsdCl7aWYobnVsbCE9dGhpcy5pZDJWYWx1ZVtlLmlkXSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkR1cGxpY2F0ZSBrZXk6IG5hbWU9XCIrZS5uYW1lK1wiLCBpZD1cIitlLmlkKTtyZXR1cm4gdGhpcy5pZDJWYWx1ZVtlLmlkXT1hc3NlcnRGZWVkQ29tcGF0aWJpbGl0eShlLHQpLHRoaXN9LGUucHJvdG90eXBlLmFkZEZlZWQ9ZnVuY3Rpb24oZSl7dGhpcy5hZGQoZS5rZXksZS52YWx1ZSl9LGUucHJvdG90eXBlLmhhc0tleT1mdW5jdGlvbihlKXtyZXR1cm4gbnVsbCE9dGhpcy5pZDJWYWx1ZVtlLmlkXX0sZS5wcm90b3R5cGUuZ2V0VmFsdWU9ZnVuY3Rpb24oZSl7aWYobnVsbD09dGhpcy5pZDJWYWx1ZVtlLmlkXSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIk5vbmV4aXN0ZW50IGtleTogXCIrSlNPTi5zdHJpbmdpZnkoZSkpO3JldHVybiB0aGlzLmlkMlZhbHVlW2UuaWRdfSxlfSgpO2Z1bmN0aW9uIGV4ZWN1dGUoZSx0LG4pe2Zvcih2YXIgcj1BcnJheS5pc0FycmF5KGUpLGk9cj9lOltlXSxhPVtdLG89bmV3IEZlZWREaWN0KHQpLHM9MCxsPWk7czxsLmxlbmd0aDtzKyspe3ZhciB1PWxbc107YS5wdXNoKGV4ZWN1dGVJbnRlcm5hbCh1LG8sbikpfXJldHVybiByP2E6YVswXX1mdW5jdGlvbiBleGVjdXRlSW50ZXJuYWwoZSx0LG4pe2lmKHQuaGFzS2V5KGUpKXJldHVybiB0LmdldFZhbHVlKGUpO2lmKGUuc291cmNlTGF5ZXIgaW5zdGFuY2VvZiBJbnB1dExheWVyKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiTWlzc2luZyBhIGZlZWQgdmFsdWUgZm9yIFN5bWJvbGljVGVuc29yIGZyb20gSW5wdXRMYXllciAnXCIrSW5wdXRMYXllci5uYW1lK1wiJ1wiKTtmb3IodmFyIHI9W10saT0wLGE9ZS5pbnB1dHM7aTxhLmxlbmd0aDtpKyspe3ZhciBvPWV4ZWN1dGVJbnRlcm5hbChhW2ldLHQsbik7ci5wdXNoKG8pfXZhciBzPWUuc291cmNlTGF5ZXIuYXBwbHkocixuKTtBcnJheS5pc0FycmF5KHMpfHwocz1bc10pO2Zvcih2YXIgbD1nZXROb2RlT3V0cHV0cyhlKSx1PUFycmF5LmlzQXJyYXkobCk/bDpbbF0sYz0wO2M8dS5sZW5ndGg7KytjKXQuYWRkKHVbY10sc1tjXSk7cmV0dXJuIDE9PT1zLmxlbmd0aD9zWzBdOnNbZS5vdXRwdXRUZW5zb3JJbmRleF19ZnVuY3Rpb24gZ2V0Tm9kZU91dHB1dHMoZSl7dmFyIHQ7aWYoMT09PWUuc291cmNlTGF5ZXIuaW5ib3VuZE5vZGVzLmxlbmd0aCl0PWUuc291cmNlTGF5ZXIub3V0cHV0O2Vsc2V7Zm9yKHZhciBuPW51bGwscj0wO3I8ZS5zb3VyY2VMYXllci5pbmJvdW5kTm9kZXMubGVuZ3RoOysrcilmb3IodmFyIGk9MCxhPWUuc291cmNlTGF5ZXIuaW5ib3VuZE5vZGVzW3JdLm91dHB1dFRlbnNvcnM7aTxhLmxlbmd0aDtpKyspe2lmKGFbaV0uaWQ9PT1lLmlkKXtuPXI7YnJlYWt9fXQ9ZS5zb3VyY2VMYXllci5nZXRPdXRwdXRBdChuKX1yZXR1cm4gdH12YXIgREVGQVVMVF9WQUxJREFUSU9OX0JBVENIX1NJWkU9MzI7ZnVuY3Rpb24gc3RhbmRhcmRpemVEYXRhSXRlcmF0b3JPdXRwdXQoZSx0KXtpZihlLm91dHB1dHMubGVuZ3RoPjEpdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJTdXBwb3J0IGZvciB0cmFpbmluZyBhIG1vZGVsIHdpdGggbXVsdGlwbGUgb3V0cHV0IHRlbnNvcnMgd2l0aCBhIGRhdGFzZXQgb2JqZWN0IGlzIG5vdCBpbXBsZW1lbnRlZCB5ZXQuXCIpO3V0aWwuYXNzZXJ0KEFycmF5LmlzQXJyYXkodCkmJjI9PT10Lmxlbmd0aCxcIkRhdGFzZXQgaXRlcmF0b3IgZm9yIGZpdERhdGFzZXQoKSBpcyBleHBlY3RlZCB0byBnZW5lcmF0ZSBhbiBBcnJheSBvZiBsZW5ndGggMjogYFt4cywgeXNdYCwgYnV0IGluc3RlYWQgZ2VuZXJhdGVzIFwiK3QpO3ZhciBuPSh0PXQpWzFdLHI9dFswXTtpZihyIGluc3RhbmNlb2YgVGVuc29yKXJldHVybiB1dGlsLmFzc2VydCgxPT09ZS5pbnB1dHMubGVuZ3RoLFwiTW9kZWwgaGFzIG11bHRpcGxlIFwiK2UuaW5wdXRzLmxlbmd0aCtcIiBpbnB1dHMsIGhlbmNlIGl0IGV4cGVjdHMgdGhlIGlucHV0IGRhdGFzZXQgdG8gZ2VuZXJhdGUgYSBkaWN0aW9uYXJ5IG9mIHRlbnNvcnMgICh3aXRoIGtleXMgXCIrSlNPTi5zdHJpbmdpZnkoZS5pbnB1dE5hbWVzKStcIiwgYnV0IHJlY2VpdmVkIGEgc2luZ2xlIHRlbnNvci5cIiksdXRpbC5hc3NlcnQoci5zaGFwZVswXT09PW4uc2hhcGVbMF0sXCJNaXNtYXRjaCBpbiBiYXRjaCBzaXplIGJldHdlZW4geCBhbmQgeSB0ZW5zb3JzIChcIityLnNoYXBlWzBdK1wiIHZzLiBcIituLnNoYXBlWzBdK1wiKVwiKSxbcixuXTt2YXIgaT12b2lkIDA7cj1yO2Zvcih2YXIgYT1bXSxvPTAscz1lLmlucHV0TmFtZXM7bzxzLmxlbmd0aDtvKyspe3ZhciBsPXNbb107aWYobnVsbD09cltsXSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlRoZSBmZWF0dXJlIGRhdGEgZ2VuZXJhdGVkIGJ5IHRoZSBkYXRhc2V0IGxhY2tzIHRoZSByZXF1aXJlZCBpbnB1dCBrZXkgJ1wiK2wrXCInLlwiKTthLnB1c2gocltsXSksbnVsbD09aT9pPXJbbF0uc2hhcGVbMF06dXRpbC5hc3NlcnQocltsXS5zaGFwZVswXT09PWksXCJNaXNtYXRjaCBpbiBiYXRjaCBzaXplIGJldHdlZW4geCBhbmQgeSB0ZW5zb3JzIChcIityW2xdLnNoYXBlWzBdK1wiIHZzLiBcIituLnNoYXBlWzBdK1wiKVwiKX1yZXR1cm4gYS5jb25jYXQobil9ZnVuY3Rpb24gc3RhbmRhcmRpemVUZW5zb3JWYWxpZGF0aW9uRGF0YShlKXtpZigzPT09ZS5sZW5ndGgpdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJWYWxpZGF0aW9uIHdpdGggc2FtcGxlIHdlaWdodHMgaXMgbm90IGltcGxlbWVudGVkIHlldC5cIik7cmV0dXJue3hzOmVbMF0seXM6ZVsxXX19ZnVuY3Rpb24gZml0RGF0YXNldChlLHQsbil7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgcixpLGEsbyxzLGwsdSxjLHAsaCxkLGYsZyxtLHksdixiLHcseixTLEksTixDLEEsXyxFO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGspe3N3aXRjaChrLmxhYmVsKXtjYXNlIDA6aWYocj1udWxsIT1uLmJhdGNoZXNQZXJFcG9jaCx1dGlsLmFzc2VydChudWxsIT1lLm9wdGltaXplcixcIllvdSBtdXN0IGNvbXBpbGUgYSBtb2RlbCBiZWZvcmUgdHJhaW5pbmcvdGVzdGluZy4gVXNlIE1vZGVsLmNvbXBpbGUobW9kZWxDb21waWxlQ29uZmlnKS5cIiksdXRpbC5hc3NlcnQobnVsbCE9bixcIkZvciBmaXREYXRhc2V0KCksIHRoZSAybmQgYXJndW1lbnQgKGNvbmZpZykgaXMgcmVxdWlyZWQsIGJ1dCBpdCBpcyBub3QgcHJvdmlkZWQgaW4gdGhpcyBjYWxsLlwiKSx1dGlsLmFzc2VydChudWxsIT1uLmVwb2NocyYmbi5lcG9jaHM+MCYmTnVtYmVyLmlzSW50ZWdlcihuLmVwb2NocyksXCJGb3IgZml0RGF0YXNldCgpLCBjb25maWcuZXBvY2hzIGlzIGV4cGVjdGVkIHRvIGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgYnV0IGdvdCBcIituLmVwb2NocyksdXRpbC5hc3NlcnQoIXJ8fG4uYmF0Y2hlc1BlckVwb2NoPjAmJk51bWJlci5pc0ludGVnZXIobi5iYXRjaGVzUGVyRXBvY2gpLFwiRm9yIGZpdERhdGFzZXQoKSwgY29uZmlnLmJhdGNoZXNQZXJFcG9jaCBpcyBleHBlY3RlZCB0byBiZSBhIHBvc2l0aXZlIGludGVnZXIgaWYgc3BlY2lmaWVkLCBidXQgZ290IFwiK24uYmF0Y2hlc1BlckVwb2NoKSx1dGlsLmFzc2VydChudWxsPT1uLnZhbGlkYXRpb25TcGxpdCxcImB2YWxpZGF0aW9uU3BsaXRgIGlzIG5vdCBzdXBwb3J0ZWQgYnkgYGZpdERhdGFzZXQoKWAuIFVzZSB2YWxpZGF0aW9uRGF0YSBpbnN0ZWFkLlwiKSxlLmlzVHJhaW5pbmcpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHN0YXJ0IHRyYWluaW5nIGJlY2F1c2UgYW5vdGhlciBmaXQoKSBjYWxsIGlzIG9uZ29pbmcuXCIpO2UuaXNUcmFpbmluZz0hMCxrLmxhYmVsPTE7Y2FzZSAxOnJldHVybiBrLnRyeXMucHVzaChbMSwsMjEsMjJdKSxpPW51bGwhPW4udmFsaWRhdGlvbkRhdGEsYT12b2lkIDAsbz12b2lkIDAsaSYmKGlzRGF0YXNldE9iamVjdChuLnZhbGlkYXRpb25EYXRhKT91dGlsLmFzc2VydChudWxsPT1uLnZhbGlkYXRpb25CYXRjaGVzfHxuLnZhbGlkYXRpb25CYXRjaGVzPjAmJk51bWJlci5pc0ludGVnZXIobi52YWxpZGF0aW9uQmF0Y2hlcyksXCJGb3IgZml0RGF0YXNldCgpIHdpdGggZGF0YXNldC1iYXNlZCB2YWxpZGF0aW9uLCBjb25maWcudmFsaWRhdGlvbkJhdGNoZXMgaXMgZXhwZWN0ZWQgbm90IHRvIGJlIHByb3ZpZGVkLCBvciB0byBiZSBhIHBvc2l0aXZlIGludGVnZXIsIGJ1dCBnb3QgXCIrbi52YWxpZGF0aW9uQmF0Y2hlcyk6KHM9c3RhbmRhcmRpemVUZW5zb3JWYWxpZGF0aW9uRGF0YShuLnZhbGlkYXRpb25EYXRhKSxhPXMueHMsbz1zLnlzKSksbD1lLm1ha2VUcmFpbkZ1bmN0aW9uKCksdT1lLmdldERlZHVwZWRNZXRyaWNzTmFtZXMoKSxjPXZvaWQgMCxjPWk/dS5zbGljZSgpLmNvbmNhdCh1Lm1hcChmdW5jdGlvbihlKXtyZXR1cm5cInZhbF9cIitlfSkpOnUuc2xpY2UoKSxwPXN0YW5kYXJkaXplQ2FsbGJhY2tzKG4uY2FsbGJhY2tzKSxoPWNvbmZpZ3VyZUNhbGxiYWNrcyhwLG4ueWllbGRFdmVyeSxuLnZlcmJvc2Usbi5lcG9jaHMsbnVsbCxudWxsLG4uYmF0Y2hlc1BlckVwb2NoLG51bGwsaSxjKSxkPWguY2FsbGJhY2tMaXN0LGY9aC5oaXN0b3J5LGUuaGlzdG9yeT1mLFs0LGQub25UcmFpbkJlZ2luKCldO2Nhc2UgMjpyZXR1cm4gay5zZW50KCksZz1udWxsPT1uLmluaXRpYWxFcG9jaD8wOm4uaW5pdGlhbEVwb2NoLG09e30sWzQsdC5pdGVyYXRvcigpXTtjYXNlIDM6eT1rLnNlbnQoKSxrLmxhYmVsPTQ7Y2FzZSA0OnJldHVybiBnPG4uZXBvY2hzP1s0LGQub25FcG9jaEJlZ2luKGcpXTpbMywxOF07Y2FzZSA1OnJldHVybiBrLnNlbnQoKSx2PTAsYj0wLHI/WzMsN106WzQsdC5pdGVyYXRvcigpXTtjYXNlIDY6eT1rLnNlbnQoKSxrLmxhYmVsPTc7Y2FzZSA3OnJldHVybiFyfHx2PG4uYmF0Y2hlc1BlckVwb2NoP1s0LHkubmV4dCgpXTpbMywxNl07Y2FzZSA4OmlmKHc9ay5zZW50KCksciYmdy5kb25lKXJldHVybiBjb25zb2xlLndhcm4oXCJZb3UgcHJvdmlkZWQgYGJhdGNoZXNQZXJFcG9jaGAgYXMgXCIrbi5iYXRjaGVzUGVyRXBvY2grXCIsIGJ1dCB5b3VyIGRhdGFzZXQgaXRlcmF0b3IgcmFuIG91dCBvZiBkYXRhIGFmdGVyIFwiK3YrXCIgYmF0Y2hlczsgaW50ZXJydXB0aW5nIHRyYWluaW5nLiBNYWtlIHN1cmUgdGhhdCB5b3VyIGRhdGFzZXQgY2FuIGdlbmVyYXRlIGF0IGxlYXN0IGBiYXRjaGVzUGVyRXBvY2ggKiBlcG9jaHNgIGJhdGNoZXMgKGluIHRoaXMgY2FzZSwgXCIrbi5iYXRjaGVzUGVyRXBvY2gqbi5lcG9jaHMrXCIgYmF0Y2hlcykuIFlvdSBtYXkgbmVlZCB0byB1c2UgdGhlIHJlcGVhdCgpIGZ1bmN0aW9uIHdoZW4gYnVpbGRpbmcgeW91ciBkYXRhc2V0LlwiKSxbMywxNl07aWYobnVsbD09dy52YWx1ZSlyZXR1cm5bMywxMF07Zm9yKHo9c3RhbmRhcmRpemVEYXRhSXRlcmF0b3JPdXRwdXQoZSx3LnZhbHVlKSwoUz17fSkuYmF0Y2g9YixTLnNpemU9elswXS5zaGFwZVswXSxkLm9uQmF0Y2hCZWdpbihiLFMpLEk9bCh6KSxkaXNwb3NlKHopLEU9MDtFPHUubGVuZ3RoOysrRSlOPXVbRV0sQz1JW0VdLFNbTl09QyxrZWVwKEMpO3JldHVybls0LGQub25CYXRjaEVuZChiLFMpXTtjYXNlIDk6ay5zZW50KCksZGlzcG9zZVRlbnNvcnNJbkxvZ3MoUyksYisrLHYrKyxrLmxhYmVsPTEwO2Nhc2UgMTA6cmV0dXJuKHI/dj49bi5iYXRjaGVzUGVyRXBvY2g6dy5kb25lKT9pPyhBPXZvaWQgMCxpc0RhdGFzZXRPYmplY3Qobi52YWxpZGF0aW9uRGF0YSk/KF89dG9MaXN0LFs0LGUuZXZhbHVhdGVEYXRhc2V0KG4udmFsaWRhdGlvbkRhdGEse2JhdGNoZXM6bi52YWxpZGF0aW9uQmF0Y2hlc30pXSk6WzMsMTJdKTpbMywxNF06WzMsMTVdO2Nhc2UgMTE6cmV0dXJuIEE9Xy5hcHBseSh2b2lkIDAsW2suc2VudCgpXSksWzMsMTNdO2Nhc2UgMTI6QT10b0xpc3QoZS5ldmFsdWF0ZShhLG8se2JhdGNoU2l6ZTpudWxsPT1uLnZhbGlkYXRpb25CYXRjaFNpemU/REVGQVVMVF9WQUxJREFUSU9OX0JBVENIX1NJWkU6bi52YWxpZGF0aW9uQmF0Y2hTaXplLHZlcmJvc2U6MH0pKSxrLmxhYmVsPTEzO2Nhc2UgMTM6Zm9yKEU9MDtFPGUubWV0cmljc05hbWVzLmxlbmd0aDsrK0UpbVtcInZhbF9cIitlLm1ldHJpY3NOYW1lc1tFXV09QVtFXTtrLmxhYmVsPTE0O2Nhc2UgMTQ6cmV0dXJuWzMsMTZdO2Nhc2UgMTU6cmV0dXJuIGUuc3RvcFRyYWluaW5nXz9bMywxNl06WzMsN107Y2FzZSAxNjpyZXR1cm5bNCxkLm9uRXBvY2hFbmQoZyxtKV07Y2FzZSAxNzpyZXR1cm4gay5zZW50KCksZysrLGUuc3RvcFRyYWluaW5nXz9bMywxOF06WzMsNF07Y2FzZSAxODpyZXR1cm5bNCxkLm9uVHJhaW5FbmQoKV07Y2FzZSAxOTpyZXR1cm4gay5zZW50KCksWzQsZS5oaXN0b3J5LnN5bmNEYXRhKCldO2Nhc2UgMjA6cmV0dXJuIGsuc2VudCgpLFsyLGUuaGlzdG9yeV07Y2FzZSAyMTpyZXR1cm4gZS5pc1RyYWluaW5nPSExLFs3XTtjYXNlIDIyOnJldHVyblsyXX19KX0pfWZ1bmN0aW9uIGlzRGF0YXNldE9iamVjdChlKXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBlLml0ZXJhdG9yfWZ1bmN0aW9uIGlzTGF6eUl0ZXJhdG9yT2JqZWN0KGUpe3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIGUubmV4dH1mdW5jdGlvbiBldmFsdWF0ZURhdGFzZXQoZSx0LG4pe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHIsaSxhLG8scyxsLHUsYyxwLGg7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oZCl7c3dpdGNoKGQubGFiZWwpe2Nhc2UgMDppZihyPW51bGwhPW4uYmF0Y2hlcyxpPWUudGVzdEZ1bmN0aW9uLGE9W10sbi52ZXJib3NlPjApdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJWZXJib3NlIG1vZGUgaXMgbm90IGltcGxlbWVudGVkIHlldC5cIik7cmV0dXJuIHV0aWwuYXNzZXJ0KCFyfHxuLmJhdGNoZXM+MCYmTnVtYmVyLmlzSW50ZWdlcihuLmJhdGNoZXMpLFwiVGVzdCBsb29wIGV4cGVjdHMgYGJhdGNoZXNgIHRvIGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgYnV0IHJlY2VpdmVkIFwiK0pTT04uc3RyaW5naWZ5KG4uYmF0Y2hlcykpLGlzTGF6eUl0ZXJhdG9yT2JqZWN0KHQpPyhzPXQsWzMsM10pOlszLDFdO2Nhc2UgMTpyZXR1cm5bNCx0Lml0ZXJhdG9yKCldO2Nhc2UgMjpzPWQuc2VudCgpLGQubGFiZWw9MztjYXNlIDM6bz1zLGw9MCx1PTAsYz1mdW5jdGlvbigpe3ZhciB0LHMsYyxwLGgsZDtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihmKXtzd2l0Y2goZi5sYWJlbCl7Y2FzZSAwOnJldHVybls0LG8ubmV4dCgpXTtjYXNlIDE6aWYoKHQ9Zi5zZW50KCkpLnZhbHVlKXtpZihzPXN0YW5kYXJkaXplRGF0YUl0ZXJhdG9yT3V0cHV0KGUsdC52YWx1ZSksYz10aWR5KGZ1bmN0aW9uKCl7cmV0dXJuIGkocyl9KSxkaXNwb3NlKHMpLDA9PT11KWZvcihkPTA7ZDxjLmxlbmd0aDsrK2QpYS5wdXNoKGdldFNjYWxhcigwKSk7Zm9yKHA9c1swXS5zaGFwZVswXSxoPWZ1bmN0aW9uKGUpe3ZhciB0PWNbZV0sbj1hW2VdO2FbZV09dGlkeShmdW5jdGlvbigpe3JldHVybiBhZGQoYVtlXSxtdWwoZ2V0U2NhbGFyKHApLHQpKX0pLHU+MCYmZGlzcG9zZShuKX0sZD0wO2Q8Yy5sZW5ndGg7KytkKWgoZCk7ZGlzcG9zZShjKSxsKz1wLCsrdX1yZXR1cm4gdC5kb25lPyhyJiZjb25zb2xlLndhcm4oXCJZb3VyIGRhdGFzZXQgaXRlcmF0b3IgcmFuIG91dCBvZiBkYXRhIGR1cmluZyBldmFsdWF0ZURhdGFzZXQoKS4gSW50ZXJydXB0aW5nIGV2YWx1dGlvbi4gTWFrZSBzdXJlIHRoYXQgeW91ciBkYXRhc2V0IGNhbiBnZW5lcmF0ZSBhdCBsZWFzdCBgYmF0Y2hlc2AgYmF0Y2hlcyAoaW4gdGhpcyBjYXNlLCBcIituLmJhdGNoZXMrXCIgYmF0Y2hlcykuIFlvdSBtYXkgbmVlZCB0byB1c2UgdGhlIHJlcGVhdCgpIGZ1bmN0aW9uIHdoZW4gYnVpbGRpbmcgeW91ciBkYXRhc2V0LlwiKSxbMixcImJyZWFrXCJdKTpbMl19fSl9LGQubGFiZWw9NDtjYXNlIDQ6cmV0dXJuIXJ8fHU8bi5iYXRjaGVzP1s1LGMoKV06WzMsNl07Y2FzZSA1OnJldHVyblwiYnJlYWtcIj09PWQuc2VudCgpP1szLDZdOlszLDRdO2Nhc2UgNjpmb3IocD1mdW5jdGlvbihlKXt2YXIgdD1hW2VdO2FbZV09dGlkeShmdW5jdGlvbigpe3JldHVybiBkaXYoYVtlXSxnZXRTY2FsYXIobCkpfSksZGlzcG9zZSh0KX0saD0wO2g8YS5sZW5ndGg7KytoKXAoaCk7cmV0dXJuWzIsc2luZ2xldG9uT3JBcnJheShhKV19fSl9KX1mdW5jdGlvbiBjaGVja0JhdGNoU2l6ZShlKXt1dGlsLmFzc2VydChlPjAmJk51bWJlci5pc0ludGVnZXIoZSksXCJiYXRjaFNpemUgaXMgcmVxdWlyZWQgdG8gYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBidXQgZ290IFwiK2UpfWZ1bmN0aW9uIHNsaWNlQXJyYXlzKGUsdCxuKXtyZXR1cm4gbnVsbD09ZT9bbnVsbF06QXJyYXkuaXNBcnJheShlKT9lLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gc2xpY2VBbG9uZ0ZpcnN0QXhpcyhlLHQsbi10KX0pOnNsaWNlQWxvbmdGaXJzdEF4aXMoZSx0LG4tdCl9ZnVuY3Rpb24gc2xpY2VBcnJheXNCeUluZGljZXMoZSx0KXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3JldHVybiBudWxsPT1lP251bGw6QXJyYXkuaXNBcnJheShlKT9lLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gc2xpY2VBcnJheXNCeUluZGljZXMoZSx0KX0pOmdhdGhlciQxKGUsXCJpbnQzMlwiPT09dC5kdHlwZT90OnQudG9JbnQoKSl9KX1mdW5jdGlvbiBtYWtlQmF0Y2hlcyhlLHQpe2Zvcih2YXIgbj1bXSxyPTAsaT1udWxsO3I8ZTspKGk9cit0KT49ZSYmKGk9ZSksbi5wdXNoKFtyLGldKSxyPWk7cmV0dXJuIG59ZnVuY3Rpb24gZml0TG9vcChlLHQsbixyLGksYSxvLHMsbCx1LGMscCxoLGQsZixnKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBtLHksdixiLHcseixTLEk7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oTil7c3dpdGNoKE4ubGFiZWwpe2Nhc2UgMDppZihudWxsPT1pJiYoaT0zMiksbnVsbD09YSYmKGE9MSksbnVsbD09YyYmKGM9ITApLG51bGw9PWgmJihoPTApLG09ITEsbnVsbCE9bCYmbnVsbCE9dSYmKG09ITApLG51bGwhPWYmJihtPSEwLG51bGw9PWQpKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiQ2FuIG9ubHkgdXNlIGB2YWxpZGF0aW9uU3RlcHNgIHdoZW4gZG9pbmcgc3RlcC13aXNlIHRyYWluaW5nLCBpLmUuLCBgc3RlcHNQZXJFcG9jaGAgbXVzdCBiZSBzZXQuXCIpO3JldHVybiBudWxsIT0oeT1lLmNoZWNrTnVtU2FtcGxlcyhuLGksZCxcInN0ZXBzX3Blcl9lcG9jaFwiKSkmJih2PXJhbmdlKDAseSkpLG51bGw9PW8mJihvPTEpLGI9Y29uZmlndXJlQ2FsbGJhY2tzKHMsZyxvLGEsaCx5LGQsaSxtLHApLHc9Yi5jYWxsYmFja0xpc3Qsej1iLmhpc3Rvcnksdy5zZXRNb2RlbChlKSxlLmhpc3Rvcnk9eixbNCx3Lm9uVHJhaW5CZWdpbigpXTtjYXNlIDE6Ti5zZW50KCksZS5zdG9wVHJhaW5pbmdfPSExLFM9ZnVuY3Rpb24oYSl7dmFyIG8scyxwLGgsZjtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihnKXtzd2l0Y2goZy5sYWJlbCl7Y2FzZSAwOnJldHVybls0LHcub25FcG9jaEJlZ2luKGEpXTtjYXNlIDE6aWYoZy5zZW50KCksbz17fSxudWxsPT1kKXJldHVyblszLDJdO3Rocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwic3RlcHNQZXJFcG9jaCBtb2RlIGlzIG5vdCBpbXBsZW1lbnRlZCB5ZXQuXCIpO2Nhc2UgMjppZihcImJhdGNoXCI9PT1jKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwiYmF0Y2ggc2h1ZmZsaW5nIGlzIG5vdCBpbXBsZW1uZXRlZCB5ZXRcIik7YyYmdXRpbC5zaHVmZmxlKHYpLHM9dGVuc29yMWQodikscD1tYWtlQmF0Y2hlcyh5LGkpLGg9ZnVuY3Rpb24oYSl7dmFyIGM7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oaCl7c3dpdGNoKGgubGFiZWwpe2Nhc2UgMDpyZXR1cm4gYz17fSxbNCx3Lm9uQmF0Y2hCZWdpbihhLGMpXTtjYXNlIDE6cmV0dXJuIGguc2VudCgpLHRpZHkoZnVuY3Rpb24oKXt2YXIgaD1wW2FdWzBdLGQ9cFthXVsxXSxmPXNsaWNlQWxvbmdGaXJzdEF4aXMocyxoLGQtaCk7Yy5iYXRjaD1hLGMuc2l6ZT1kLWg7Zm9yKHZhciBnPXNsaWNlQXJyYXlzQnlJbmRpY2VzKG4sZikseT10KGcpLHY9MDt2PHIubGVuZ3RoOysrdil7dmFyIGI9clt2XSx3PXlbdl07Y1tiXT13LGtlZXAodyl9aWYoYT09PXAubGVuZ3RoLTEmJm0pe3ZhciB6PWUudGVzdExvb3AobCx1LGkpO2Zvcih2PTA7djxyLmxlbmd0aDsrK3Ype2I9clt2XSx3PXpbdl07a2VlcCh3KSxvW1widmFsX1wiK2JdPXd9fX0pLFs0LHcub25CYXRjaEVuZChhLGMpXTtjYXNlIDI6cmV0dXJuIGguc2VudCgpLGRpc3Bvc2VUZW5zb3JzSW5Mb2dzKGMpLGUuc3RvcFRyYWluaW5nXz9bMixcImJyZWFrXCJdOlsyXX19KX0sZj0wLGcubGFiZWw9MztjYXNlIDM6cmV0dXJuIGY8cC5sZW5ndGg/WzUsaChmKV06WzMsNl07Y2FzZSA0OmlmKFwiYnJlYWtcIj09PWcuc2VudCgpKXJldHVyblszLDZdO2cubGFiZWw9NTtjYXNlIDU6cmV0dXJuKytmLFszLDNdO2Nhc2UgNjpzLmRpc3Bvc2UoKSxnLmxhYmVsPTc7Y2FzZSA3OnJldHVybls0LHcub25FcG9jaEVuZChhLG8pXTtjYXNlIDg6cmV0dXJuIGcuc2VudCgpLGUuc3RvcFRyYWluaW5nXz9bMixcImJyZWFrXCJdOlsyXX19KX0sST1oLE4ubGFiZWw9MjtjYXNlIDI6cmV0dXJuIEk8YT9bNSxTKEkpXTpbMyw1XTtjYXNlIDM6aWYoXCJicmVha1wiPT09Ti5zZW50KCkpcmV0dXJuWzMsNV07Ti5sYWJlbD00O2Nhc2UgNDpyZXR1cm4rK0ksWzMsMl07Y2FzZSA1OnJldHVybls0LHcub25UcmFpbkVuZCgpXTtjYXNlIDY6cmV0dXJuIE4uc2VudCgpLFs0LGUuaGlzdG9yeS5zeW5jRGF0YSgpXTtjYXNlIDc6cmV0dXJuIE4uc2VudCgpLFsyLGUuaGlzdG9yeV19fSl9KX1mdW5jdGlvbiBmaXRUZW5zb3JzKGUsdCxuLHIpe3JldHVybiB2b2lkIDA9PT1yJiYocj17fSksX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBpLGEsbyxzLGwsdSxjLHAsaCxkLGYsZyxtLHksdixiLHcseixTLEk7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oTil7c3dpdGNoKE4ubGFiZWwpe2Nhc2UgMDppZihlLmlzVHJhaW5pbmcpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHN0YXJ0IHRyYWluaW5nIGJlY2F1c2UgYW5vdGhlciBmaXQoKSBjYWxsIGlzIG9uZ29pbmcuXCIpO2UuaXNUcmFpbmluZz0hMCxOLmxhYmVsPTE7Y2FzZSAxOmlmKE4udHJ5cy5wdXNoKFsxLCwzLDRdKSxjaGVja0JhdGNoU2l6ZShjPW51bGw9PXIuYmF0Y2hTaXplPzMyOnIuYmF0Y2hTaXplKSxwPWUuc3RhbmRhcmRpemVVc2VyRGF0YSh0LG4sITEsYyksaT1wWzBdLGE9cFsxXSxoPSExLGQ9dm9pZCAwLG51bGwhPXIudmFsaWRhdGlvbkRhdGEmJnIudmFsaWRhdGlvbkRhdGEubGVuZ3RoPjApe2lmKGg9ITAsMiE9PXIudmFsaWRhdGlvbkRhdGEubGVuZ3RoKXRocm93IDM9PT1yLnZhbGlkYXRpb25EYXRhLmxlbmd0aD9uZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcInZhbGlkYXRpb25EYXRhIGluY2x1ZGluZyBzYW1wbGUgd2VpZ2h0cyBpcyBub3Qgc3VwcG9ydGVkIHlldC5cIik6bmV3IFZhbHVlRXJyb3IoXCJXaGVuIHBhc3NpbmcgdmFsaWRhdGlvbiBkYXRhLCBpdCBtdXN0IGNvbnRhaW4gMiAodmFsWCwgdmFsWSkgb3IgMyAodmFsWCwgdmFsWSwgdmFsU2FtcGxlV2VpZ2h0KSBpdGVtczsgXCIrci52YWxpZGF0aW9uRGF0YStcIiBpcyBpbnZhbGlkLlwiKTtvPXIudmFsaWRhdGlvbkRhdGFbMF0scz1yLnZhbGlkYXRpb25EYXRhWzFdLGY9ZS5zdGFuZGFyZGl6ZVVzZXJEYXRhKG8scywhMCxjKSxsPWZbMF0sdT1mWzFdLGQ9bC5jb25jYXQodSl9ZWxzZSBudWxsIT1yLnZhbGlkYXRpb25TcGxpdCYmci52YWxpZGF0aW9uU3BsaXQ+MCYmci52YWxpZGF0aW9uU3BsaXQ8MT8oaD0hMCxnPU1hdGguZmxvb3IoaVswXS5zaGFwZVswXSooMS1yLnZhbGlkYXRpb25TcGxpdCkpLG09aVswXS5zaGFwZVswXSxsPXNsaWNlQXJyYXlzKGksZyxtKSxpPXNsaWNlQXJyYXlzKGksMCxnKSx1PXNsaWNlQXJyYXlzKGEsZyxtKSxhPXNsaWNlQXJyYXlzKGEsMCxnKSxkPWwuY29uY2F0KHUpKTpudWxsIT1yLnZhbGlkYXRpb25TdGVwcyYmKGg9ITApO3JldHVybiB5PWkuY29uY2F0KGEpLGUuY2hlY2tUcmFpbmFibGVXZWlnaHRzQ29uc2lzdGVuY3koKSx2PWUubWFrZVRyYWluRnVuY3Rpb24oKSxiPWUuZ2V0RGVkdXBlZE1ldHJpY3NOYW1lcygpLHc9dm9pZCAwLHo9dm9pZCAwLGg/KGUubWFrZVRlc3RGdW5jdGlvbigpLHc9ZS50ZXN0RnVuY3Rpb24sej1iLnNsaWNlKCkuY29uY2F0KGIubWFwKGZ1bmN0aW9uKGUpe3JldHVyblwidmFsX1wiK2V9KSkpOih3PW51bGwsZD1bXSx6PWIuc2xpY2UoKSksUz1zdGFuZGFyZGl6ZUNhbGxiYWNrcyhyLmNhbGxiYWNrcyksWzQsZml0TG9vcChlLHYseSxiLGMsci5lcG9jaHMsci52ZXJib3NlLFMsdyxkLHIuc2h1ZmZsZSx6LHIuaW5pdGlhbEVwb2NoLG51bGwsbnVsbCxyLnlpZWxkRXZlcnkpXTtjYXNlIDI6cmV0dXJuIEk9Ti5zZW50KCksZS5pc1RyYWluaW5nPSExLFsyLEldO2Nhc2UgMzpyZXR1cm4gZS5pc1RyYWluaW5nPSExLGRpc3Bvc2VOZXdUZW5zb3JzKGksdCksZGlzcG9zZU5ld1RlbnNvcnMoYSxuKSxkaXNwb3NlTmV3VGVuc29ycyhsLG8pLGRpc3Bvc2VOZXdUZW5zb3JzKHUscyksWzddO2Nhc2UgNDpyZXR1cm5bMl19fSl9KX1mdW5jdGlvbiBlbnN1cmVUZW5zb3JzUmFuazJPckhpZ2hlcihlKXt2YXIgdD1bXTtlIGluc3RhbmNlb2YgVGVuc29yJiYoZT1bZV0pO2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7KytuKXt2YXIgcj1lW25dO2lmKDE9PT1yLnJhbmspdC5wdXNoKGV4cGFuZERpbXMociwxKSk7ZWxzZXtpZigwPT09ci5yYW5rKXRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIHRlbnNvciB0byBiZSBhdCBsZWFzdCAxRCwgYnV0IHJlY2VpdmVkIGEgMEQgdGVuc29yIChzY2FsYXIpLlwiKTt0LnB1c2gocil9fXJldHVybiB0fWZ1bmN0aW9uIGRpc3Bvc2VOZXdUZW5zb3JzKGUsdCl7aWYobnVsbCE9ZSl7dmFyIG49W107aWYodCBpbnN0YW5jZW9mIFRlbnNvciluLnB1c2godC5pZCk7ZWxzZSBpZihBcnJheS5pc0FycmF5KHQpKXQuZm9yRWFjaChmdW5jdGlvbihlKXtyZXR1cm4gbi5wdXNoKGUuaWQpfSk7ZWxzZSBpZihudWxsIT10KWZvcih2YXIgciBpbiB0KXt2YXIgaT10W3JdO24ucHVzaChpLmlkKX12YXIgYT1bXTtpZihlIGluc3RhbmNlb2YgVGVuc29yKS0xPT09bi5pbmRleE9mKGUuaWQpJiZhLnB1c2goZSk7ZWxzZSBpZihBcnJheS5pc0FycmF5KGUpKWUuZm9yRWFjaChmdW5jdGlvbihlKXstMT09PW4uaW5kZXhPZihlLmlkKSYmYS5wdXNoKGUpfSk7ZWxzZSBpZihudWxsIT1lKWZvcih2YXIgbyBpbiBlKXt2YXIgcz1lW29dOy0xPT09bi5pbmRleE9mKHMuaWQpJiZhLnB1c2gocyl9YS5mb3JFYWNoKGZ1bmN0aW9uKGUpe2UuaXNEaXNwb3NlZHx8ZS5kaXNwb3NlKCl9KX19ZnVuY3Rpb24gaXNEYXRhVGVuc29yKGUpe3JldHVybiBlIGluc3RhbmNlb2YgVGVuc29yfWZ1bmN0aW9uIGlzRGF0YUFycmF5KGUpe3JldHVybiBBcnJheS5pc0FycmF5KGUpfWZ1bmN0aW9uIGlzRGF0YURpY3QoZSl7cmV0dXJuIWlzRGF0YVRlbnNvcihlKSYmIWlzRGF0YUFycmF5KGUpfWZ1bmN0aW9uIHN0YW5kYXJkaXplSW5wdXREYXRhKGUsdCxuLHIsaSl7aWYodm9pZCAwPT09ciYmKHI9ITApLHZvaWQgMD09PWkmJihpPVwiXCIpLG51bGw9PXR8fDA9PT10Lmxlbmd0aCl7aWYobnVsbCE9ZSl7dmFyIGE9ITE7aWYoaXNEYXRhQXJyYXkoZSkmJmUubGVuZ3RoPjApYT0hMDtlbHNlIGlmKGlzRGF0YURpY3QoZSkpe2Zvcih2YXIgbyBpbiBlKWlmKGUuaGFzT3duUHJvcGVydHkobykpe2E9ITA7YnJlYWt9fWVsc2UgYT0hMDtpZihhKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiRXJyb3Igd2hlbiBjaGVja2luZyBtb2RlbCBcIitpK1wiIGV4cGVjdGVkIG5vIGRhdGEsIGJ1dCBnb3QgXCIrZSl9cmV0dXJuW119aWYobnVsbD09ZSlyZXR1cm4gdC5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIG51bGx9KTt2YXIgcztpZihpc0RhdGFEaWN0KGUpKXtlPWUscz1bXTtmb3IodmFyIGw9MCx1PXQ7bDx1Lmxlbmd0aDtsKyspe3ZhciBjPXVbbF07aWYobnVsbD09ZVtjXSl0aHJvdyBuZXcgVmFsdWVFcnJvcignTm8gZGF0YSBwcm92aWRlZCBmb3IgXCInK2MrJ1wiLiBOZWVkIGRhdGEgZm9yIGVhY2gga2V5IGluOiAnK3QpO3MucHVzaChlW2NdKX19ZWxzZSBpZihpc0RhdGFBcnJheShlKSl7aWYoKGU9ZSkubGVuZ3RoIT09dC5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJFcnJvciB3aGVuIGNoZWNraW5nIG1vZGVsIFwiK2krXCI6IHRoZSBBcnJheSBvZiBUZW5zb3JzIHRoYXQgeW91IGFyZSBwYXNzaW5nIHRvIHlvdXIgbW9kZWwgaXMgbm90IHRoZSBzaXplIHRoZSBtb2RlbCBleHBlY3RlZC4gRXhwZWN0ZWQgdG8gc2VlIFwiK3QubGVuZ3RoK1wiIFRlbnNvcihzKSwgYnV0IGluc3RlYWQgZ290IHRoZSBmb2xsb3dpbmcgbGlzdCBvZiBUZW5zb3Iocyk6IFwiK2UpO3M9ZX1lbHNle2lmKGU9ZSx0Lmxlbmd0aD4xKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiVGhlIG1vZGVsIFwiK2krXCIgZXhwZWN0cyBcIit0Lmxlbmd0aCtcIiBUZW5zb3IocyksIGJ1dCBvbmx5IHJlY2VpdmVkIG9uZSBUZW5zb3IuIEZvdW5kOiBUZW5zb3Igd2l0aCBzaGFwZSBcIitlLnNoYXBlKTtzPVtlXX1pZihzPWVuc3VyZVRlbnNvcnNSYW5rMk9ySGlnaGVyKHMpLG51bGwhPW4pZm9yKHZhciBwPTA7cDx0Lmxlbmd0aDsrK3ApaWYobnVsbCE9bltwXSl7dmFyIGg9c1twXTtpZihoLnNoYXBlLmxlbmd0aCE9PW5bcF0ubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiRXJyb3Igd2hlbiBjaGVja2luZyBcIitpK1wiOiBleHBlY3RlZCBcIit0W3BdK1wiIHRvIGhhdmUgXCIrbltwXS5sZW5ndGgrXCIgZGltZW5zaW9uKHMpLiBidXQgZ290IGFycmF5IHdpdGggc2hhcGUgXCIraC5zaGFwZSk7Zm9yKHZhciBkPTA7ZDxuW3BdLmxlbmd0aDsrK2QpaWYoMCE9PWR8fHIpe3ZhciBmPWguc2hhcGVbZF0sZz1uW3BdW2RdO2lmKG51bGwhPWcmJmc+PTAmJmYhPT1nKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiRXJyb3Igd2hlbiBjaGVja2luZyBcIitpK1wiOiBleHBlY3RlZCBcIit0W3BdK1wiIHRvIGhhdmUgc2hhcGUgW1wiK25bcF0rXCJdLCBidXQgZ290IGFycmF5IHdpdGggc2hhcGUgW1wiK2guc2hhcGUrXCJdLlwiKX19cmV0dXJuIHN9ZnVuY3Rpb24gY2hlY2tBcnJheUxlbmd0aHMoZSx0LG4pe3ZhciByPXVuaXF1ZShlLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5zaGFwZVswXX0pKTtyLnNvcnQoKTt2YXIgaT11bmlxdWUodC5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUuc2hhcGVbMF19KSk7aWYoaS5zb3J0KCksci5sZW5ndGg+MSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkFsbCBpbnB1dCBUZW5zb3JzICh4KSBzaG91bGQgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2Ygc2FtcGxlcy4gR290IGFycmF5IHNoYXBlczogXCIrSlNPTi5zdHJpbmdpZnkoZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUuc2hhcGV9KSkpO2lmKGkubGVuZ3RoPjEpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJBbGwgdGFyZ2V0IFRlbnNvcnMgKHkpIHNob3VsZCBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBzYW1wbGVzLiBHb3QgYXJyYXkgc2hhcGVzOiBcIitKU09OLnN0cmluZ2lmeSh0Lm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5zaGFwZX0pKSk7aWYoci5sZW5ndGg+MCYmaS5sZW5ndGg+MCYmIXV0aWwuYXJyYXlzRXF1YWwocixpKSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIklucHV0IFRlbnNvcnMgc2hvdWxkIGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIHNhbXBsZXMgYXMgdGFyZ2V0IFRlbnNvcnMuIEZvdW5kIFwiK3JbMF0rXCIgaW5wdXQgc2FtcGxlKHMpIGFuZCBcIitpWzBdK1wiIHRhcmdldCBzYW1wbGUocykuXCIpfWZ1bmN0aW9uIGNoZWNrTG9zc0FuZFRhcmdldENvbXBhdGliaWxpdHkoZSx0LG4pe2Zvcih2YXIgcj1bbWVhblNxdWFyZWRFcnJvcixiaW5hcnlDcm9zc2VudHJvcHksY2F0ZWdvcmljYWxDcm9zc2VudHJvcHldLGk9MDtpPGUubGVuZ3RoOysraSl7dmFyIGE9ZVtpXSxvPXRbaV0scz1uW2ldO2lmKG51bGwhPW8pe2lmKG89PT1jYXRlZ29yaWNhbENyb3NzZW50cm9weSYmMT09PWEuc2hhcGVbYS5zaGFwZS5sZW5ndGgtMV0pdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJZb3UgYXJlIHBhc3NpbmcgYSB0YXJnZXQgYXJyYXkgb2Ygc2hhcGUgXCIrYS5zaGFwZStcIiB3aGlsZSB1c2luZyBhIGxvc3MgJ2NhdGVnb3JpY2FsX2Nyb3NzZW50cm9weScuICdjYXRlZ29yaWNhbF9jcm9zc2VudHJvcHknZXhwZWN0cyB0YXJnZXRzIHRvIGJlIGJpbmFyeSBtYXRyaWNlcyAoMXMgYW5kIDBzKSBvZiBzaGFwZSBbc2FtcGxlcywgY2xhc3Nlc10uXCIpO2lmKC0xIT09ci5pbmRleE9mKG8pKWZvcih2YXIgbD1hLnNoYXBlLnNsaWNlKDEpLHU9cy5zbGljZSgxKSxjPTA7YzxsLmxlbmd0aDsrK2Mpe3ZhciBwPWxbY10saD11W2NdO2lmKG51bGwhPWgmJnAhPT1oKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiQSB0YXJnZXQgVGVuc29yIHdpdGggc2hhcGUgXCIrYS5zaGFwZStcIiB3YXMgcGFzc2VkIGZvciBhbiBvdXRwdXQgb2Ygc2hhcGUgXCIrcytcIiwgd2hpbGUgdXNpbmcgYSBsb3NzIGZ1bmN0aW9uIHRoYXQgZXhwZWN0cyB0YXJnZXRzIHRvIGhhdmUgdGhlIHNhbWUgc2hhcGUgYXMgdGhlIG91dHB1dC5cIil9fX19ZnVuY3Rpb24gY2hlY2tJbnB1dERhdGEoZSx0LG4scixpKXt2YXIgYTtpZih2b2lkIDA9PT1yJiYocj0hMCksdm9pZCAwPT09aSYmKGk9XCJcIiksQXJyYXkuaXNBcnJheShlKSl7aWYoZS5sZW5ndGghPT10Lmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkVycm9yIHdoZW4gY2hlY2tpbmcgbW9kZWwgXCIraStcIjogdGhlIEFycmF5IG9mIFRlbnNvcnMgdGhhdCB5b3UgYXJlIHBhc3NpbmcgdG8geW91ciBtb2RlbCBpcyBub3QgdGhlIHNpemUgdGhlIHRoZSBtb2RlbCBleHBlY3RlZC4gRXhwZWN0ZWQgdG8gc2VlIFwiK3QubGVuZ3RoK1wiIFRlbnNvcihzKSwgYnV0IGluc3RlYWQgZ290IFwiK2UubGVuZ3RoK1wiIFRlbnNvcnMocykuXCIpO2E9ZX1lbHNle2lmKHQubGVuZ3RoPjEpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJUaGUgbW9kZWwgZXhwZWN0cyBcIit0Lmxlbmd0aCtcIiBcIitpK1wiIFRlbnNvcnMsIGJ1dCBvbmx5IHJlY2VpdmVkIG9uZSBUZW5zb3IuIEZvdW5kOiBhcnJheSB3aXRoIHNoYXBlIFwiK0pTT04uc3RyaW5naWZ5KGUuc2hhcGUpK1wiLlwiKTthPVtlXX1pZihudWxsIT1uKWZvcih2YXIgbz0wO288dC5sZW5ndGg7KytvKWlmKG51bGwhPW5bb10pe3ZhciBzPWFbb107aWYocy5zaGFwZS5sZW5ndGghPT1uW29dLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkVycm9yIHdoZW4gY2hlY2tpbmcgXCIraStcIjogZXhwZWN0ZWQgXCIrdFtvXStcIiB0byBoYXZlIFwiK25bb10ubGVuZ3RoK1wiIGRpbWVuc2lvbihzKSwgYnV0IGdvdCBhcnJheSB3aXRoIHNoYXBlIFwiK0pTT04uc3RyaW5naWZ5KHMuc2hhcGUpKTtmb3IodmFyIGw9MDtsPG5bb10ubGVuZ3RoOysrbClpZigwIT09bHx8cil7dmFyIHU9cy5zaGFwZVtsXSxjPW5bb11bbF07aWYobnVsbCE9YyYmYyE9PXUpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJFcnJvciB3aGVuIGNoZWNraW5nIFwiK2krXCI6IGV4cGVjdGVkIFwiK3Rbb10rXCIgdG8gaGF2ZSBzaGFwZSBcIitKU09OLnN0cmluZ2lmeShuW29dKStcIiBidXQgZ290IGFycmF5IHdpdGggc2hhcGUgXCIrSlNPTi5zdHJpbmdpZnkocy5zaGFwZSkrXCIuXCIpfX19ZnVuY3Rpb24gY29sbGVjdE1ldHJpY3MoZSx0KXtpZihudWxsPT1lfHxBcnJheS5pc0FycmF5KGUpJiYwPT09ZS5sZW5ndGgpcmV0dXJuIHQubWFwKGZ1bmN0aW9uKGUpe3JldHVybltdfSk7aWYoQXJyYXkuaXNBcnJheShlKSlyZXR1cm4gdC5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIGV9KTtpZihudWxsIT1lKXtmb3IodmFyIG49W10scj0wLGk9dDtyPGkubGVuZ3RoO3IrKyl7dmFyIGE9aVtyXSxvPWUuaGFzT3duUHJvcGVydHkoYSk/ZVthXTpbXTtBcnJheS5pc0FycmF5KG8pfHwobz1bb10pLG4ucHVzaChvKX1yZXR1cm4gbn10aHJvdyBuZXcgVHlwZUVycm9yKFwiVHlwZSBvZiBtZXRyaWNzIGFyZ3VtZW50IG5vdCB1bmRlcnN0b29kLiBFeHBlY3RlZCBhbiBBcnJheSBvciBPYmplY3QsIGZvdW5kOiBcIitlKX12YXIgTW9kZWw9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyx0KXx8dGhpcztyZXR1cm4gbi5pc1RyYWluaW5nPSExLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLnN1bW1hcnk9ZnVuY3Rpb24oZSx0LG4pe2lmKHZvaWQgMD09PW4mJihuPWNvbnNvbGUubG9nKSwhdGhpcy5idWlsdCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlRoaXMgbW9kZWwgaGFzIG5ldmVyIGJlZW4gY2FsbGVkLCB0aHVzIGl0cyB3ZWlnaHRzIGhhdmUgbm90IGJlZW4gY3JlYXRlZCB5ZXQuIFNvIG5vIHN1bW1hcnkgY2FuIGJlIGRpc3BsYXllZC4gQnVpbGQgdGhlIG1vZGVsIGZpcnN0IChlLmcuLCBieSBjYWxsaW5nIGl0IG9uIHNvbWUgdGVzdCBkYXRhKS5cIik7cHJpbnRTdW1tYXJ5KHRoaXMsZSx0LG4pfSx0LnByb3RvdHlwZS5jb21waWxlPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7aWYobnVsbD09ZS5sb3NzJiYoZS5sb3NzPVtdKSx0aGlzLmxvc3M9ZS5sb3NzLFwic3RyaW5nXCI9PXR5cGVvZiBlLm9wdGltaXplcil0aGlzLm9wdGltaXplcj1nZXRPcHRpbWl6ZXIoZS5vcHRpbWl6ZXIpO2Vsc2V7aWYoIShlLm9wdGltaXplciBpbnN0YW5jZW9mIE9wdGltaXplcikpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJVc2VyLWRlZmluZWQgb3B0aW1pemVyIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgdGYuT3B0aW1pemVyLlwiKTt0aGlzLm9wdGltaXplcj1lLm9wdGltaXplcn12YXIgbj1bXTtpZihBcnJheS5pc0FycmF5KGUubG9zcyl8fFwic3RyaW5nXCI9PXR5cGVvZiBlLmxvc3N8fFwiZnVuY3Rpb25cIj09dHlwZW9mIGUubG9zcylpZihBcnJheS5pc0FycmF5KGUubG9zcykpe2lmKGUubG9zcy5sZW5ndGghPT10aGlzLm91dHB1dHMubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiV2hlbiBwYXNzaW5nIGFuIEFycmF5IGFzIGxvc3MsIGl0IHNob3VsZCBoYXZlIG9uZSBlbnRyeSBwZXIgbW9kZWwgb3V0cHV0LiBUaGUgbW9kZWwgaGFzIFwiK3RoaXMub3V0cHV0cy5sZW5ndGgrXCIgb3V0cHV0KHMpLCBidXQgeW91IHBhc3NlZCBsb3NzPVwiK2UubG9zcytcIi5cIik7dmFyIHI9ZS5sb3NzO249ci5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGdldChlKX0pfWVsc2V7dmFyIGk9Z2V0KGUubG9zcyk7dGhpcy5vdXRwdXRzLm1hcChmdW5jdGlvbihlKXtuLnB1c2goaSl9KX1lbHNle2Zvcih2YXIgYSBpbiBlLmxvc3M9ZS5sb3NzLGUubG9zcylpZigtMT09PXRoaXMub3V0cHV0TmFtZXMuaW5kZXhPZihhKSl0aHJvdyBuZXcgVmFsdWVFcnJvcignVW5rbm93biBlbnRyeSBpbiBsb3NzIGRpY3Rpb25hcnk6IFwiJythKydcIi4gT25seSBleHBlY3QgdGhlIGZvbGxvd2luZyBrZXlzOiAnK3RoaXMub3V0cHV0TmFtZXMpO2Zvcih2YXIgbyBpbiB0aGlzLm91dHB1dE5hbWVzKW51bGw9PWUubG9zc1tvXSYmY29uc29sZS53YXJuKCdPdXRwdXQgXCInK28rJ1wiIGlzIG1pc3NpbmcgZnJvbSBsb3NzIGRpY3Rpb25hcnkuIFdlIGFzc3VtZSB0aGlzIHdhcyBkb25lIG9uIHB1cnBvc2UsIGFuZCB3ZSB3aWxsIG5vdCBiZSBleHBlY3RpbmcgZGF0YSB0byBiZSBwYXNzZWQgdG8gJytvK1wiIGR1cmluZyB0cmFpbmluZ1wiKSxuLnB1c2goZ2V0KGUubG9zc1tvXSkpfXRoaXMubG9zc0Z1bmN0aW9ucz1uLHRoaXMuZmVlZE91dHB1dE5hbWVzPVtdLHRoaXMuZmVlZE91dHB1dFNoYXBlcz1bXSx0aGlzLmZlZWRMb3NzRm5zPVtdO2Zvcih2YXIgcz0wO3M8dGhpcy5vdXRwdXRzLmxlbmd0aDsrK3Mpe3ZhciBsPXRoaXMuaW50ZXJuYWxPdXRwdXRTaGFwZXNbc10sdT10aGlzLm91dHB1dE5hbWVzW3NdO3RoaXMuZmVlZE91dHB1dE5hbWVzLnB1c2godSksdGhpcy5mZWVkT3V0cHV0U2hhcGVzLnB1c2gobCksdGhpcy5mZWVkTG9zc0Zucy5wdXNoKHRoaXMubG9zc0Z1bmN0aW9uc1tzXSl9dmFyIGM9W107dGhpcy5tZXRyaWNzPWUubWV0cmljcyx0aGlzLm1ldHJpY3NOYW1lcz1bXCJsb3NzXCJdLHRoaXMubWV0cmljc1RlbnNvcnM9W10sbmFtZVNjb3BlKFwibG9zc1wiLGZ1bmN0aW9uKCl7Zm9yKHZhciBlPTA7ZTx0Lm91dHB1dHMubGVuZ3RoOysrZSlpZigtMT09PWMuaW5kZXhPZihlKSl7dmFyIG49dC5sb3NzRnVuY3Rpb25zW2VdO3Qub3V0cHV0cy5sZW5ndGg+MSYmKHQubWV0cmljc1RlbnNvcnMucHVzaChbbixlXSksdC5tZXRyaWNzTmFtZXMucHVzaCh0Lm91dHB1dE5hbWVzW2VdK1wiX2xvc3NcIikpfX0pO3ZhciBwPWNvbGxlY3RNZXRyaWNzKGUubWV0cmljcyx0aGlzLm91dHB1dE5hbWVzKTtuYW1lU2NvcGUoXCJtZXRyaWNcIixmdW5jdGlvbigpe2Zvcih2YXIgZT1mdW5jdGlvbihlKXtpZigtMSE9PWMuaW5kZXhPZihlKSlyZXR1cm5cImNvbnRpbnVlXCI7IWZ1bmN0aW9uKG4pe2Zvcih2YXIgcixpLGEsbz1mdW5jdGlvbihuKXtpZigtMSE9PVtcImFjY3VyYWN5XCIsXCJhY2NcIixcImNyb3NzZW50cm9weVwiLFwiY2VcIl0uaW5kZXhPZihuKSl7dmFyIG89dC5pbnRlcm5hbE91dHB1dFNoYXBlc1tlXTsxPT09b1tvLmxlbmd0aC0xXXx8dC5sb3NzRnVuY3Rpb25zW2VdPT09YmluYXJ5Q3Jvc3NlbnRyb3B5Py0xIT09W1wiYWNjdXJhY3lcIixcImFjY1wiXS5pbmRleE9mKG4pP2k9YmluYXJ5QWNjdXJhY3k6LTEhPT1bXCJjcm9zc2VudHJvcHlcIixcImNlXCJdLmluZGV4T2YobikmJihpPWJpbmFyeUNyb3NzZW50cm9weSQxKTp0Lmxvc3NGdW5jdGlvbnNbZV09PT1zcGFyc2VDYXRlZ29yaWNhbENyb3NzZW50cm9weT8tMSE9PVtcImFjY3VyYWN5XCIsXCJhY2NcIl0uaW5kZXhPZihuKT9pPXNwYXJzZUNhdGVnb3JpY2FsQWNjdXJhY3k6LTEhPT1bXCJjcm9zc2VudHJvcHlcIixcImNlXCJdLmluZGV4T2YobikmJihpPXNwYXJzZUNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5JDEpOi0xIT09W1wiYWNjdXJhY3lcIixcImFjY1wiXS5pbmRleE9mKG4pP2k9Y2F0ZWdvcmljYWxBY2N1cmFjeTotMSE9PVtcImNyb3NzZW50cm9weVwiLFwiY2VcIl0uaW5kZXhPZihuKSYmKGk9Y2F0ZWdvcmljYWxDcm9zc2VudHJvcHkkMSk7dmFyIHM9dm9pZCAwOy0xIT09W1wiYWNjdXJhY3lcIixcImFjY1wiXS5pbmRleE9mKG4pP3M9XCJhY2NcIjotMSE9PVtcImNyb3NzZW50cm9weVwiLFwiY2VcIl0uaW5kZXhPZihuKSYmKHM9XCJjZVwiKSxhPWkscj1cIlwiK3N9ZWxzZXt2YXIgbD1nZXQkMShuKTthPWwscj1cIlwiK259dmFyIHU7bmFtZVNjb3BlKHIsZnVuY3Rpb24oKXt1PWF9KSxmdW5jdGlvbihlLG4scil7dC5vdXRwdXROYW1lcy5sZW5ndGg+MSYmKG49dC5vdXRwdXROYW1lc1tlXStcIl9cIituKSx0Lm1ldHJpY3NOYW1lcy5wdXNoKG4pLHQubWV0cmljc1RlbnNvcnMucHVzaChbcixlXSl9KGUscix1KX0scz0wLGw9bjtzPGwubGVuZ3RoO3MrKylvKGxbc10pfShwW2VdKX0sbj0wO248dC5vdXRwdXRzLmxlbmd0aDsrK24pZShuKX0pLHRoaXMuY29sbGVjdGVkVHJhaW5hYmxlV2VpZ2h0cz10aGlzLnRyYWluYWJsZVdlaWdodHN9LHQucHJvdG90eXBlLmNoZWNrVHJhaW5hYmxlV2VpZ2h0c0NvbnNpc3RlbmN5PWZ1bmN0aW9uKCl7bnVsbCE9dGhpcy5jb2xsZWN0ZWRUcmFpbmFibGVXZWlnaHRzJiZ0aGlzLnRyYWluYWJsZVdlaWdodHMubGVuZ3RoIT09dGhpcy5jb2xsZWN0ZWRUcmFpbmFibGVXZWlnaHRzLmxlbmd0aCYmY29uc29sZS53YXJuKFwiRGlzY3JlcGFuY3kgYmV0d2VlbiB0cmFpbmFibGV3ZWlnaHRzIGFuZCBjb2xsZWN0ZWQgdHJhaW5hYmxlIHdlaWdodHMuIERpZCB5b3Ugc2V0IGBtb2RlbC50cmFpbmFibGVgIHdpdGhvdXQgY2FsbGluZyBgbW9kZWwuY29tcGlsZSgpYCBhZnRlcndhcmRzP1wiKX0sdC5wcm90b3R5cGUuZXZhbHVhdGU9ZnVuY3Rpb24oZSx0LG4pe3ZvaWQgMD09PW4mJihuPXt9KTt2YXIgcj1udWxsPT1uLmJhdGNoU2l6ZT8zMjpuLmJhdGNoU2l6ZTtjaGVja0JhdGNoU2l6ZShyKTt2YXIgaT10aGlzLnN0YW5kYXJkaXplVXNlckRhdGEoZSx0LCEwLHIpO3RyeXt2YXIgYT1pWzBdLmNvbmNhdChpWzFdKTt0aGlzLm1ha2VUZXN0RnVuY3Rpb24oKTt2YXIgbz10aGlzLnRlc3RGdW5jdGlvbjtyZXR1cm4gc2luZ2xldG9uT3JBcnJheSh0aGlzLnRlc3RMb29wKG8sYSxyLG4udmVyYm9zZSxuLnN0ZXBzKSl9ZmluYWxseXtkaXNwb3NlTmV3VGVuc29ycyhpWzBdLGUpLGRpc3Bvc2VOZXdUZW5zb3JzKGlbMV0sdCl9fSx0LnByb3RvdHlwZS5ldmFsdWF0ZURhdGFzZXQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKG4pe3JldHVybiB0aGlzLm1ha2VUZXN0RnVuY3Rpb24oKSxbMixldmFsdWF0ZURhdGFzZXQodGhpcyxlLHQpXX0pfSl9LHQucHJvdG90eXBlLmNoZWNrTnVtU2FtcGxlcz1mdW5jdGlvbihlLHQsbixyKXt2YXIgaTtpZih2b2lkIDA9PT1yJiYocj1cInN0ZXBzXCIpLG51bGwhPW4pe2lmKGk9bnVsbCxudWxsIT10KXRocm93IG5ldyBWYWx1ZUVycm9yKFwiSWYgXCIrcitcIiBpcyBzZXQsIGJhdGNoU2l6ZSBtdXN0IGJlIG51bGwgb3IgdW5kZWZpbmVkLkdvdCBiYXRjaFNpemUgPSBcIit0KX1lbHNle2lmKG51bGw9PWUpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJFaXRoZXIgdGhlIGlucHV0IGRhdGEgc2hvdWxkIGhhdmUgYSBkZWZpbmVkIHNoYXBlLCBvciBcIityK1wiIHNob3VkIGJlIHNwZWNpZmllZC5cIik7aT1BcnJheS5pc0FycmF5KGUpP2VbMF0uc2hhcGVbMF06ZS5zaGFwZVswXX1yZXR1cm4gaX0sdC5wcm90b3R5cGUuZXhlY3V0ZT1mdW5jdGlvbihlLHQpe2lmKEFycmF5LmlzQXJyYXkodCkmJjA9PT10Lmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcImBvdXRwdXRzYCBpcyBhbiBlbXB0eSBBcnJheSwgd2hpY2ggaXMgbm90IGFsbG93ZWQuXCIpO3ZhciBuPUFycmF5LmlzQXJyYXkodCkscj1uP3Q6W3RdLGk9dGhpcy5yZXRyaWV2ZVN5bWJvbGljVGVuc29ycyhyKSxhPW5ldyBGZWVkRGljdDtpZihlIGluc3RhbmNlb2YgVGVuc29yJiYoZT1bZV0pLEFycmF5LmlzQXJyYXkoZSkpe2lmKGUubGVuZ3RoIT09dGhpcy5pbnB1dHMubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiVGhlIG51bWJlciBvZiBpbnB1dHMgcHJvdmlkZWQgKFwiK2UubGVuZ3RoK1wiKSBkb2VzIG5vdCBtYXRjaCB0aGUgbnVtYmVyIG9mIGlucHV0cyBvZiB0aGlzIG1vZGVsIChcIit0aGlzLmlucHV0cy5sZW5ndGgrXCIpLlwiKTtmb3IodmFyIG89MDtvPHRoaXMuaW5wdXRzLmxlbmd0aDsrK28pYS5hZGQodGhpcy5pbnB1dHNbb10sZVtvXSl9ZWxzZSBmb3IodmFyIHM9MCxsPXRoaXMuaW5wdXRzO3M8bC5sZW5ndGg7cysrKXt2YXIgdT1sW3NdLGM9ZVt1Lm5hbWVdO2lmKG51bGw9PWMpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJObyB2YWx1ZSBpcyBwcm92aWRlZCBmb3IgdGhlIG1vZGVsJ3MgaW5wdXQgXCIrdS5uYW1lKTthLmFkZCh1LGMpfXZhciBwPWV4ZWN1dGUoaSxhKTtyZXR1cm4gbj9wOnBbMF19LHQucHJvdG90eXBlLnJldHJpZXZlU3ltYm9saWNUZW5zb3JzPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1weUxpc3RSZXBlYXQobnVsbCxlLmxlbmd0aCksbj1lLmxlbmd0aCxyPTAsaT10aGlzLmxheWVycztyPGkubGVuZ3RoO3IrKyl7Zm9yKHZhciBhPWlbcl0sbz1BcnJheS5pc0FycmF5KGEub3V0cHV0KT9hLm91dHB1dDpbYS5vdXRwdXRdLHM9by5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUubmFtZX0pLGw9MDtsPGUubGVuZ3RoOysrbCl7dmFyIHU9cy5pbmRleE9mKGVbbF0pO2lmKC0xIT09dSYmKHRbbF09b1t1XSxuLS0pLDA9PT1uKWJyZWFrfWlmKDA9PT1uKWJyZWFrfWlmKG4+MCl7dmFyIGM9W107dGhyb3cgdC5mb3JFYWNoKGZ1bmN0aW9uKHQsbil7bnVsbD09dCYmYy5wdXNoKGVbbl0pfSksbmV3IFZhbHVlRXJyb3IoXCJDYW5ub3QgZmluZCBTeW1ib2xpY1RlbnNvcnMgZm9yIG91dHB1dCBuYW1lKHMpOiBcIitKU09OLnN0cmluZ2lmeShjKSl9cmV0dXJuIHR9LHQucHJvdG90eXBlLnByZWRpY3RMb29wPWZ1bmN0aW9uKGUsdCxuKXt2YXIgcj10aGlzO3JldHVybiB2b2lkIDA9PT10JiYodD0zMiksdm9pZCAwPT09biYmKG49ITEpLHRpZHkoZnVuY3Rpb24oKXt2YXIgaT1yLmNoZWNrTnVtU2FtcGxlcyhlKTtpZihuKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwiVmVyYm9zZSBwcmVkaWN0TG9vcCgpIGlzIG5vdCBpbXBsZW1lbnRlZCB5ZXQuXCIpO2Zvcih2YXIgYT1tYWtlQmF0Y2hlcyhpLHQpLG89W10scz1mdW5jdGlvbih0KXt2YXIgbj10aWR5KGZ1bmN0aW9uKCl7dmFyIG49YVt0XVswXSxpPWFbdF1bMV0sbz1zbGljZUFycmF5cyhlLG4saSkscz1bXTtpZihBcnJheS5pc0FycmF5KG8pKWZvcih2YXIgbD0wO2w8by5sZW5ndGg7KytsKXMucHVzaCh7a2V5OnIuaW5wdXRzW2xdLHZhbHVlOm9bbF19KTtlbHNlIHMucHVzaCh7a2V5OnIuaW5wdXRzWzBdLHZhbHVlOm99KTt2YXIgdT1uZXcgRmVlZERpY3Qocyk7cmV0dXJuIGV4ZWN1dGUoci5vdXRwdXRzLHUpfSk7aWYoMD09PXQpZm9yKHZhciBpPTAscz1uO2k8cy5sZW5ndGg7aSsrKXt2YXIgbD1zW2ldO28ucHVzaChsKX1lbHNlIGZvcih2YXIgdT0wO3U8bi5sZW5ndGg7Kyt1KW9bdV09Y29uY2F0QWxvbmdGaXJzdEF4aXMob1t1XSxuW3VdKX0sbD0wO2w8YS5sZW5ndGg7KytsKXMobCk7cmV0dXJuIHNpbmdsZXRvbk9yQXJyYXkobyl9KX0sdC5wcm90b3R5cGUucHJlZGljdD1mdW5jdGlvbihlLHQpe3ZvaWQgMD09PXQmJih0PXt9KTt2YXIgbj1lbnN1cmVUZW5zb3JzUmFuazJPckhpZ2hlcihlKTtjaGVja0lucHV0RGF0YShuLHRoaXMuaW5wdXROYW1lcyx0aGlzLmZlZWRJbnB1dFNoYXBlcywhMSk7dHJ5e3ZhciByPW51bGw9PXQuYmF0Y2hTaXplPzMyOnQuYmF0Y2hTaXplO3JldHVybiBjaGVja0JhdGNoU2l6ZShyKSx0aGlzLnByZWRpY3RMb29wKG4scil9ZmluYWxseXtkaXNwb3NlTmV3VGVuc29ycyhuLGUpfX0sdC5wcm90b3R5cGUucHJlZGljdE9uQmF0Y2g9ZnVuY3Rpb24oZSl7cmV0dXJuIGNoZWNrSW5wdXREYXRhKGUsdGhpcy5pbnB1dE5hbWVzLHRoaXMuZmVlZElucHV0U2hhcGVzLCEwKSx0aGlzLnByZWRpY3RMb29wKGUsZS5zaGFwZVswXSl9LHQucHJvdG90eXBlLnN0YW5kYXJkaXplVXNlckRhdGE9ZnVuY3Rpb24oZSx0LG4scil7aWYodm9pZCAwPT09biYmKG49ITApLG51bGw9PXRoaXMub3B0aW1pemVyKXRocm93IG5ldyBSdW50aW1lRXJyb3IoXCJZb3UgbXVzdCBjb21waWxlIGEgbW9kZWwgYmVmb3JlIHRyYWluaW5nL3Rlc3RpbmcuIFVzZSBNb2RlbC5jb21waWxlKG1vZGVsQ29tcGlsZUNvbmZpZykuXCIpO2Zvcih2YXIgaT1bXSxhPTA7YTx0aGlzLmZlZWRPdXRwdXRTaGFwZXMubGVuZ3RoOysrYSl7dmFyIG89dGhpcy5mZWVkT3V0cHV0U2hhcGVzW2FdO3RoaXMuZmVlZExvc3NGbnNbYV09PT1zcGFyc2VDYXRlZ29yaWNhbENyb3NzZW50cm9weT9pLnB1c2goby5zbGljZSgwLG8ubGVuZ3RoLTEpLmNvbmNhdChbMV0pKTppLnB1c2gobyl9aWYoY2hlY2tBcnJheUxlbmd0aHMoZT1zdGFuZGFyZGl6ZUlucHV0RGF0YShlLHRoaXMuZmVlZElucHV0TmFtZXMsdGhpcy5mZWVkSW5wdXRTaGFwZXMsITEsXCJpbnB1dFwiKSx0PXN0YW5kYXJkaXplSW5wdXREYXRhKHQsdGhpcy5mZWVkT3V0cHV0TmFtZXMsaSwhMSxcInRhcmdldFwiKSxudWxsKSxjaGVja0xvc3NBbmRUYXJnZXRDb21wYXRpYmlsaXR5KHQsdGhpcy5mZWVkTG9zc0Zucyx0aGlzLmZlZWRPdXRwdXRTaGFwZXMpLHRoaXMuc3RhdGVmdWwmJm51bGwhPXImJnI+MCYmZVswXS5zaGFwZVswXSVyIT0wKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiSW4gYSBzdGF0ZWZ1bCBuZXR3b3JrLCB5b3Ugc2hvdWxkIG9ubHkgcGFzcyBpbnB1dHMgd2l0aCBhIG51bWJlciBvZiBzYW1wbGVzIHRoYXQgaXMgZGl2aXNpYmxlIGJ5IHRoZSBiYXRjaCBzaXplIFwiK3IrXCIuIEZvdW5kOiBcIitlWzBdLnNoYXBlWzBdK1wiIHNhbXBsZShzKS5cIik7cmV0dXJuW2UsdCxudWxsXX0sdC5wcm90b3R5cGUudGVzdExvb3A9ZnVuY3Rpb24oZSx0LG4scixpKXt2YXIgYT10aGlzO3JldHVybiB2b2lkIDA9PT1yJiYocj0wKSx0aWR5KGZ1bmN0aW9uKCl7dmFyIG89YS5jaGVja051bVNhbXBsZXModCxuLGksXCJzdGVwc1wiKSxzPVtdO2lmKHI+MCl0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcIlZlcmJvc2UgbW9kZSBpcyBub3QgaW1wbGVtZW50ZWQgeWV0LlwiKTtpZihudWxsIT1pKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwic3RlcHMgbW9kZSBpbiB0ZXN0TG9vcCgpIGlzIG5vdCBpbXBsZW1lbnRlZCB5ZXRcIik7Zm9yKHZhciBsPW1ha2VCYXRjaGVzKG8sbiksdT10ZW5zb3IxZChyYW5nZSgwLG8pKSxjPTA7YzxsLmxlbmd0aDsrK2Mpe3ZhciBwPWxbY11bMF0saD1sW2NdWzFdLGQ9c2xpY2VBbG9uZ0ZpcnN0QXhpcyh1LHAsaC1wKSxmPXNsaWNlQXJyYXlzQnlJbmRpY2VzKHQsZCksZz1lKGYpO2lmKDA9PT1jKWZvcih2YXIgbT0wO208Zy5sZW5ndGg7KyttKXMucHVzaChnZXRTY2FsYXIoMCkpO2ZvcihtPTA7bTxnLmxlbmd0aDsrK20pe3ZhciB5PWdbbV07c1ttXT1hZGQoc1ttXSxtdWwoZ2V0U2NhbGFyKGgtcCkseSkpfX1mb3IobT0wO208cy5sZW5ndGg7KyttKXNbbV09ZGl2KHNbbV0sZ2V0U2NhbGFyKG8pKTtyZXR1cm4gc30pfSx0LnByb3RvdHlwZS5nZXREZWR1cGVkTWV0cmljc05hbWVzPWZ1bmN0aW9uKCl7Zm9yKHZhciBlPXRoaXMubWV0cmljc05hbWVzLHQ9W10sbj0wO248ZS5sZW5ndGg7KytuKXt2YXIgcj1lW25dLGk9cjtpZihjb3VudChlLHIpPjEpaSs9XCJfXCIrY291bnQoZS5zbGljZSgwLG4pLHIpO3QucHVzaChpKX1yZXR1cm4gdH0sdC5wcm90b3R5cGUubWFrZVRyYWluRnVuY3Rpb249ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3JldHVybiBmdW5jdGlvbih0KXt2YXIgbj10LnNsaWNlKDAsZS5pbnB1dHMubGVuZ3RoKSxyPXQuc2xpY2UoZS5pbnB1dHMubGVuZ3RoLGUuaW5wdXRzLmxlbmd0aCtlLm91dHB1dHMubGVuZ3RoKSxpPVtdLGE9ZS5jb2xsZWN0ZWRUcmFpbmFibGVXZWlnaHRzLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5yZWFkKCl9KTtyZXR1cm5bZS5vcHRpbWl6ZXIubWluaW1pemUoZnVuY3Rpb24oKXtmb3IodmFyIHQ9W10sYT0wO2E8ZS5pbnB1dHMubGVuZ3RoOysrYSl0LnB1c2goe2tleTplLmlucHV0c1thXSx2YWx1ZTpuW2FdfSk7dmFyIG8scz1uZXcgRmVlZERpY3QodCksbD1leGVjdXRlKGUub3V0cHV0cyxzLHt0cmFpbmluZzohMH0pO2ZvcihhPTA7YTxlLmxvc3NGdW5jdGlvbnMubGVuZ3RoOysrYSl7dmFyIHU9KDAsZS5sb3NzRnVuY3Rpb25zW2FdKShyW2FdLGxbYV0pO21lYW4odSksbz0wPT09YT91OmFkZChvLHUpfWZvcihhPTA7YTxlLm1ldHJpY3NUZW5zb3JzLmxlbmd0aDsrK2Epe3ZhciBjPWUubWV0cmljc1RlbnNvcnNbYV1bMF0scD1lLm1ldHJpY3NUZW5zb3JzW2FdWzFdLGg9bWVhbihjKHJbcF0sbFtwXSkpO2tlZXAoaCksaS5wdXNoKGgpfXJldHVybiBvPW1lYW4obyksZS5jYWxjdWxhdGVMb3NzZXMoKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe289YWRkKG8sZSl9KSxvfSwhMCxhKV0uY29uY2F0KGkpfX0sdC5wcm90b3R5cGUubWFrZVRlc3RGdW5jdGlvbj1mdW5jdGlvbigpe3ZhciBlPXRoaXM7dGhpcy50ZXN0RnVuY3Rpb249ZnVuY3Rpb24odCl7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtmb3IodmFyIG4scj1bXSxpPXQuc2xpY2UoMCxlLmlucHV0cy5sZW5ndGgpLGE9dC5zbGljZShlLmlucHV0cy5sZW5ndGgsZS5pbnB1dHMubGVuZ3RoK2Uub3V0cHV0cy5sZW5ndGgpLG89W10scz0wO3M8ZS5pbnB1dHMubGVuZ3RoOysrcylvLnB1c2goe2tleTplLmlucHV0c1tzXSx2YWx1ZTppW3NdfSk7dmFyIGw9bmV3IEZlZWREaWN0KG8pLHU9ZXhlY3V0ZShlLm91dHB1dHMsbCk7Zm9yKHM9MDtzPGUubG9zc0Z1bmN0aW9ucy5sZW5ndGg7KytzKXt2YXIgYz1lLmxvc3NGdW5jdGlvbnNbc10scD1tZWFuKGMoYVtzXSx1W3NdKSk7bj0wPT09cz9wOmFkZChuLHApLHIucHVzaChuKX1mb3Iocz0wO3M8ZS5tZXRyaWNzVGVuc29ycy5sZW5ndGg7KytzKXt2YXIgaD1lLm1ldHJpY3NUZW5zb3JzW3NdWzBdLGQ9ZS5tZXRyaWNzVGVuc29yc1tzXVsxXSxmPW1lYW4oaChhW2RdLHVbZF0pKTtyLnB1c2goZil9cmV0dXJuIHJ9KX19LHQucHJvdG90eXBlLmZpdD1mdW5jdGlvbihlLHQsbil7cmV0dXJuIHZvaWQgMD09PW4mJihuPXt9KSxfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24ocil7cmV0dXJuWzIsZml0VGVuc29ycyh0aGlzLGUsdCxuKV19KX0pfSx0LnByb3RvdHlwZS5maXREYXRhc2V0PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihuKXtyZXR1cm5bMixmaXREYXRhc2V0KHRoaXMsZSx0KV19KX0pfSx0LnByb3RvdHlwZS5nZXROYW1lZFdlaWdodHM9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PXt9LG49bnVsbCE9ZSYmZS50cmFpbmFibGVPbmx5LHI9bj90aGlzLnRyYWluYWJsZVdlaWdodHM6dGhpcy53ZWlnaHRzLGk9dGhpcy5nZXRXZWlnaHRzKG4pLGE9MDthPHIubGVuZ3RoOysrYSluJiYhclthXS50cmFpbmFibGV8fCh0W3JbYV0ub3JpZ2luYWxOYW1lXT1pW2FdKTtyZXR1cm4gdH0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwic3RvcFRyYWluaW5nXCIse3NldDpmdW5jdGlvbihlKXt0aGlzLnN0b3BUcmFpbmluZ189ZX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSx0LnByb3RvdHlwZS5zYXZlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgbixyLGksYSxvO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHMpe3N3aXRjaChzLmxhYmVsKXtjYXNlIDA6aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUpe2lmKDA9PT0obj1pby5nZXRTYXZlSGFuZGxlcnMoZSkpLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkNhbm5vdCBmaW5kIGFueSBzYXZlIGhhbmRsZXJzIGZvciBVUkwgJ1wiK2UrXCInXCIpO2lmKG4ubGVuZ3RoPjEpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJGb3VuZCBtb3JlIHRoYW4gb25lIChcIituLmxlbmd0aCtcIikgc2F2ZSBoYW5kbGVycyBmb3IgVVJMICdcIitlK1wiJ1wiKTtlPW5bMF19aWYobnVsbD09ZS5zYXZlKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiTW9kZWwuc2F2ZSgpIGNhbm5vdCBwcm9jZWVkIGJlY2F1c2UgdGhlIElPSGFuZGxlciBwcm92aWRlZCBkb2VzIG5vdCBoYXZlIHRoZSBgc2F2ZWAgYXR0cmlidXRlIGRlZmluZWQuXCIpO3JldHVybls0LGlvLmVuY29kZVdlaWdodHModGhpcy5nZXROYW1lZFdlaWdodHModCkpXTtjYXNlIDE6cmV0dXJuIHI9cy5zZW50KCksaT0hMSxhPW51bGwsbz10aGlzLnRvSlNPTihhLGkpLFsyLGUuc2F2ZSh7bW9kZWxUb3BvbG9neTpvLHdlaWdodERhdGE6ci5kYXRhLHdlaWdodFNwZWNzOnIuc3BlY3N9KV19fSl9KX0sdC5jbGFzc05hbWU9XCJNb2RlbFwiLHR9KENvbnRhaW5lcik7ZnVuY3Rpb24gbW9kZWxGcm9tSlNPTihlLHQpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIG4scixpLGEsbyxzLGwsdSxjLHA7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oaCl7c3dpdGNoKGgubGFiZWwpe2Nhc2UgMDpyZXR1cm5cIm1vZGVsVG9wb2xvZ3lcImluIGV8fChlPXttb2RlbFRvcG9sb2d5OmV9KSxudWxsIT0obj0oZT1lKS5tb2RlbFRvcG9sb2d5KS5tb2RlbF9jb25maWcmJihuPW4ubW9kZWxfY29uZmlnKSxyPWNvbnZlcnRQeXRob25pY1RvVHMobiksaT1kZXNlcmlhbGl6ZShyLHQpLG51bGw9PWUud2VpZ2h0c01hbmlmZXN0P1szLDJdOls0LGlvLmxvYWRXZWlnaHRzKGUud2VpZ2h0c01hbmlmZXN0LGUucGF0aFByZWZpeCxpLndlaWdodHMubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLm9yaWdpbmFsTmFtZX0pKV07Y2FzZSAxOmZvcihhPWguc2VudCgpLG89e30scz0wLGw9aS53ZWlnaHRzO3M8bC5sZW5ndGg7cysrKXU9bFtzXSxvW3Uub3JpZ2luYWxOYW1lXT1hW3Uub3JpZ2luYWxOYW1lXTtjPW51bGwscD0hMCxpLmxvYWRXZWlnaHRzKG8sYyxwKSxoLmxhYmVsPTI7Y2FzZSAyOnJldHVyblsyLGldfX0pfSl9ZnVuY3Rpb24gbG9hZE1vZGVsSW50ZXJuYWwoZSx0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9ITApLF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgbjtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihyKXtpZihcInN0cmluZ1wiPT10eXBlb2YgZSl7aWYoMD09PShuPWlvLmdldExvYWRIYW5kbGVycyhlKSkubGVuZ3RoKW4ucHVzaChpby5icm93c2VySFRUUFJlcXVlc3QoZSkpO2Vsc2UgaWYobi5sZW5ndGg+MSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkZvdW5kIG1vcmUgdGhhbiBvbmUgKFwiK24ubGVuZ3RoK1wiKSBsb2FkIGhhbmRsZXJzIGZvciBVUkwgJ1wiK2UrXCInXCIpO2U9blswXX1yZXR1cm5bMixsb2FkTW9kZWxGcm9tSU9IYW5kbGVyKGUsdm9pZCAwLHQpXX0pfSl9ZnVuY3Rpb24gbG9hZE1vZGVsRnJvbUlPSGFuZGxlcihlLHQsbil7cmV0dXJuIHZvaWQgMD09PW4mJihuPSEwKSxfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHIsaSxhLG8scztyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihsKXtzd2l0Y2gobC5sYWJlbCl7Y2FzZSAwOmlmKG51bGw9PWUubG9hZCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkNhbm5vdCBwcm9jZWVkIHdpdGggbW9kZWwgbG9hZGluZyBiZWNhdXNlIHRoZSBJT0hhbmRsZXIgcHJvdmlkZWQgZG9lcyBub3QgaGF2ZSB0aGUgYGxvYWRgIG1ldGhvZCBpbXBsZW1lbnRlZC5cIik7cmV0dXJuWzQsZS5sb2FkKCldO2Nhc2UgMTppZihyPWwuc2VudCgpLG51bGwhPShpPXIubW9kZWxUb3BvbG9neSkubW9kZWxfY29uZmlnJiYoaT1pLm1vZGVsX2NvbmZpZyksYT1kZXNlcmlhbGl6ZShjb252ZXJ0UHl0aG9uaWNUb1RzKGkpLHQpLG51bGwhPXIud2VpZ2h0RGF0YSl7aWYobnVsbD09ci53ZWlnaHRTcGVjcyl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIk1vZGVsIGFydGlmYWN0cyBjb250YWlucyB3ZWlnaHQgZGF0YSwgYnV0IG5vdCB3ZWlnaHQgc3BlY3MuIFRoZXJlZm9yZSBsb2FkaW5nIG9mIHdlaWdodHMgY2Fubm90IHByb2NlZWQuXCIpO289ITEscz0hMCxhLmxvYWRXZWlnaHRzKGlvLmRlY29kZVdlaWdodHMoci53ZWlnaHREYXRhLHIud2VpZ2h0U3BlY3MpLG8scyxuKX1yZXR1cm5bMixhXX19KX0pfXNlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhNb2RlbCk7dmFyIFNlcXVlbnRpYWw9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyx7aW5wdXRzOltdLG91dHB1dHM6W119KXx8dGhpcztpZih0PXR8fHt9LG4udHJhaW5hYmxlPSEwLG4uX3VwZGF0YWJsZT0hMCxuLmJ1aWx0PSExLG4ubmFtZT1udWxsIT10Lm5hbWU/dC5uYW1lOmdldFVpZChcInNlcXVlbnRpYWxfXCIpLG51bGwhPXQubGF5ZXJzKWZvcih2YXIgcj0wLGk9dC5sYXllcnM7cjxpLmxlbmd0aDtyKyspe3ZhciBhPWlbcl07bi5hZGQoYSl9cmV0dXJuIG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmNoZWNrU2hhcGU9ZnVuY3Rpb24oZSl7aWYoZS5pbmJvdW5kTm9kZXNbMF0ub3V0cHV0VGVuc29yc1swXS5zaGFwZS5zb21lKGZ1bmN0aW9uKGUpe3JldHVybiBlPDB9KSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIk5lZ2F0aXZlIGRpbWVuc2lvbiBzaXplIGNhdXNlZCBieSBhZGRpbmcgbGF5ZXIgXCIrZS5uYW1lK1wiIHdpdGggaW5wdXQgc2hhcGUgW1wiK2UuaW5ib3VuZE5vZGVzWzBdLmlucHV0VGVuc29yc1swXS5zaGFwZStcIl1cIil9LHQucHJvdG90eXBlLmFkZD1mdW5jdGlvbihlKXt2YXIgbixyPWUgaW5zdGFuY2VvZiB0fHxlIGluc3RhbmNlb2YgTW9kZWw7aWYocil7aWYoMSE9PShuPWUpLm91dHB1dHMubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiQWxsIGxheWVycyBpbiBhIFNlcXVlbnRpYWwgbW9kZWwgc2hvdWxkIGhhdmUgYSBzaW5nbGUgb3V0cHV0IHRlbnNvci4gRm9yIG11bHRpLW91dHB1dCBsYXllcnMsIHVzZSB0aGUgZnVuY3Rpb25hbCBBUEkuXCIpO2lmKDEhPT1uLmlucHV0cy5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJBbGwgbGF5ZXJzIGluIGEgU2VxdWVudGlhbCBtb2RlbCBzaG91bGQgaGF2ZSBhIHNpbmdsZSBpbnB1dCB0ZW5zb3IuIEZvciBtdWx0aS1pbnB1dCBsYXllcnMsIHVzZSB0aGUgZnVuY3Rpb25hbCBBUEkuXCIpfWlmKDA9PT10aGlzLm91dHB1dHMubGVuZ3RoKXtpZigwPT09ZS5pbmJvdW5kTm9kZXMubGVuZ3RoKXtpZihudWxsPT1lLmJhdGNoSW5wdXRTaGFwZSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlRoZSBmaXJzdCBsYXllciBpbiBhIFNlcXVlbnRpYWwgbW9kZWwgbXVzdCBnZXQgYW4gYGlucHV0U2hhcGVgIG9yIGBiYXRjaElucHV0U2hhcGVgIGFyZ3VtZW50LlwiKTt2YXIgaT1JbnB1dCh7YmF0Y2hTaGFwZTplLmJhdGNoSW5wdXRTaGFwZSxkdHlwZTplLmR0eXBlLG5hbWU6ZS5uYW1lK1wiX2lucHV0XCJ9KTtlLmFwcGx5KGkpfWlmKHIpdGhpcy5vdXRwdXRzPW4ub3V0cHV0cyx0aGlzLmlucHV0cz1uLmlucHV0cztlbHNle2lmKDEhPT1lLmluYm91bmROb2Rlcy5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJBIGxheWVyIGFkZGVkIHRvIGEgU2VxdWVudGlhbCBtb2RlbCBtdXN0IG5vdCBhbHJlYWR5IGJlIGNvbm5lY3RlZCBzb21ld2hlcmUgZWxzZS4gTW9kZWwgcmVjZWl2ZWQgbGF5ZXIgXCIrZS5uYW1lK1wiIHdoaWNoIGhhcyBcIitlLmluYm91bmROb2Rlcy5sZW5ndGgrXCIgcHJlLWV4aXN0aW5nIGluYm91bmQgY29ubmVjdGlvbnMuXCIpO2lmKDEhPT1lLmluYm91bmROb2Rlc1swXS5vdXRwdXRUZW5zb3JzLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkFsbCBsYXllcnMgaW4gYSBTZXF1ZW50aWFsIG1vZGVsIHNob3VsZCBoYXZlIGEgc2luZ2xlIG91dHB1dCB0ZW5zb3IuIEZvciBtdWx0aS1vdXRwdXQgbGF5ZXJzLCB1c2UgdGhlIGZ1bmN0aW9uYWwgQVBJLlwiKTt0aGlzLmNoZWNrU2hhcGUoZSksdGhpcy5vdXRwdXRzPVtlLmluYm91bmROb2Rlc1swXS5vdXRwdXRUZW5zb3JzWzBdXSx0aGlzLmlucHV0cz1nZXRTb3VyY2VJbnB1dHModGhpcy5vdXRwdXRzWzBdKX10aGlzLmluYm91bmROb2Rlcz1bXSxuZXcgTm9kZSh7b3V0Ym91bmRMYXllcjp0aGlzLGluYm91bmRMYXllcnM6W10sbm9kZUluZGljZXM6W10sdGVuc29ySW5kaWNlczpbXSxpbnB1dFRlbnNvcnM6dGhpcy5pbnB1dHMsb3V0cHV0VGVuc29yczp0aGlzLm91dHB1dHMsaW5wdXRNYXNrczpweUxpc3RSZXBlYXQobnVsbCx0aGlzLmlucHV0cy5sZW5ndGgpLG91dHB1dE1hc2tzOltudWxsXSxpbnB1dFNoYXBlczp0aGlzLmlucHV0cy5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUuc2hhcGV9KSxvdXRwdXRTaGFwZXM6dGhpcy5vdXRwdXRzWzBdLnNoYXBlfSl9ZWxzZXt2YXIgYT1lLmFwcGx5KHRoaXMub3V0cHV0c1swXSk7aWYoQXJyYXkuaXNBcnJheShhKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQWxsIGxheWVycyBpbiBhIFNlcXVlbnRpYWwgbW9kZWwgc2hvdWxkIGhhdmUgYSBzaW5nbGUgb3V0cHV0IHRlbnNvci4gRm9yIG11bHRpLW91dHB1dCBsYXllcnMsIHVzZSB0aGUgZnVuY3Rpb25hbCBBUEkuXCIpO3RoaXMuY2hlY2tTaGFwZShlKSx0aGlzLm91dHB1dHM9W2FdLHRoaXMuaW5ib3VuZE5vZGVzWzBdLm91dHB1dFRlbnNvcnM9dGhpcy5vdXRwdXRzLHRoaXMuaW5ib3VuZE5vZGVzWzBdLm91dHB1dFNoYXBlcz1bdGhpcy5vdXRwdXRzWzBdLnNoYXBlXX10aGlzLmxheWVycy5wdXNoKGUpLHRoaXMuYnVpbHQ9ITF9LHQucHJvdG90eXBlLnBvcD1mdW5jdGlvbigpe2lmKDA9PT10aGlzLmxheWVycy5sZW5ndGgpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZXJlIGFyZSBubyBsYXllcnMgaW4gdGhlIG1vZGVsLlwiKTtpZih0aGlzLmxheWVycy5wb3AoKSwwPT09dGhpcy5sYXllcnMubGVuZ3RoKXRoaXMub3V0cHV0cz1bXSx0aGlzLmluYm91bmROb2Rlcz1bXSx0aGlzLm91dGJvdW5kTm9kZXM9W107ZWxzZXt2YXIgZT10aGlzLmxheWVycy5sZW5ndGgtMTt0aGlzLmxheWVyc1tlXS5vdXRib3VuZE5vZGVzPVtdLHRoaXMub3V0cHV0cz1bdGhpcy5sYXllcnNbZV0ub3V0cHV0XSx0aGlzLmluYm91bmROb2Rlc1swXS5vdXRwdXRUZW5zb3JzPXRoaXMub3V0cHV0cyx0aGlzLmluYm91bmROb2Rlc1swXS5vdXRwdXRTaGFwZXM9W3RoaXMub3V0cHV0c1swXS5zaGFwZV19fSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIG51bGw9PXRoaXMubW9kZWwmJnRoaXMuYnVpbGQoKSx0aGlzLm1vZGVsLmNhbGwoZSx0KX0sdC5wcm90b3R5cGUuYnVpbGQ9ZnVuY3Rpb24oZSl7aWYoZ2V0RXhhY3RseU9uZVNoYXBlKGUpLDA9PT10aGlzLmlucHV0cy5sZW5ndGh8fDA9PT10aGlzLm91dHB1dHMubGVuZ3RoKXRocm93IG5ldyBUeXBlRXJyb3IoXCJTZXF1ZW50aWFsIG1vZGVsIGNhbm5vdCBiZSBidWlsdDogbW9kZWwgaXMgZW1wdHkuIEFkZCBzb21lIGxheWVycyBmaXJzdC5cIik7dGhpcy5tb2RlbD1uZXcgTW9kZWwoe2lucHV0czp0aGlzLmlucHV0cyxvdXRwdXRzOnRoaXMub3V0cHV0c1swXSxuYW1lOnRoaXMubmFtZStcIl9tb2RlbFwifSksdGhpcy5tb2RlbC50cmFpbmFibGU9dGhpcy50cmFpbmFibGUsdGhpcy5tb2RlbC51cGRhdGFibGU9dGhpcy51cGRhdGFibGUsdGhpcy5zdXBwb3J0c01hc2tpbmc9dGhpcy5tb2RlbC5zdXBwb3J0c01hc2tpbmcsdGhpcy5pbnB1dExheWVycz10aGlzLm1vZGVsLmlucHV0TGF5ZXJzLHRoaXMuaW5wdXRMYXllcnNOb2RlSW5kaWNlcz10aGlzLm1vZGVsLmlucHV0TGF5ZXJzTm9kZUluZGljZXMsdGhpcy5pbnB1dExheWVyc1RlbnNvckluZGljZXM9dGhpcy5tb2RlbC5pbnB1dExheWVyc1RlbnNvckluZGljZXMsdGhpcy5vdXRwdXRMYXllcnM9dGhpcy5tb2RlbC5vdXRwdXRMYXllcnMsdGhpcy5vdXRwdXRMYXllcnNOb2RlSW5kaWNlcz10aGlzLm1vZGVsLm91dHB1dExheWVyc05vZGVJbmRpY2VzLHRoaXMub3V0cHV0TGF5ZXJzVGVuc29ySW5kaWNlcz10aGlzLm1vZGVsLm91dHB1dExheWVyc1RlbnNvckluZGljZXMsdGhpcy5ub2Rlc0J5RGVwdGg9dGhpcy5tb2RlbC5ub2Rlc0J5RGVwdGgsdGhpcy5jb250YWluZXJOb2Rlcz10aGlzLm1vZGVsLmNvbnRhaW5lck5vZGVzLHRoaXMub3V0cHV0TmFtZXM9dGhpcy5tb2RlbC5vdXRwdXROYW1lcyx0aGlzLmlucHV0TmFtZXM9dGhpcy5tb2RlbC5pbnB1dE5hbWVzLHRoaXMuYnVpbHQ9ITB9LHQucHJvdG90eXBlLmNvdW50UGFyYW1zPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYnVpbHR8fHRoaXMuYnVpbGQoKSxlLnByb3RvdHlwZS5jb3VudFBhcmFtcy5jYWxsKHRoaXMpfSx0LnByb3RvdHlwZS5zdW1tYXJ5PWZ1bmN0aW9uKHQsbixyKXt2b2lkIDA9PT1yJiYocj1jb25zb2xlLmxvZyksdGhpcy5idWlsdHx8dGhpcy5idWlsZCgpLGUucHJvdG90eXBlLnN1bW1hcnkuY2FsbCh0aGlzLHQsbixyKX0sdC5wcm90b3R5cGUuc2V0V2VpZ2h0cz1mdW5jdGlvbihlKXtudWxsPT10aGlzLm1vZGVsJiZ0aGlzLmJ1aWxkKCksdGhpcy5tb2RlbC5zZXRXZWlnaHRzKGUpfSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJ1cGRhdGFibGVcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3VwZGF0YWJsZX0sc2V0OmZ1bmN0aW9uKGUpe3RoaXMuYnVpbHQmJih0aGlzLm1vZGVsLnVwZGF0YWJsZT1lKSx0aGlzLl91cGRhdGFibGU9ZX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSx0LnByb3RvdHlwZS5ldmFsdWF0ZT1mdW5jdGlvbihlLHQsbil7aWYodm9pZCAwPT09biYmKG49e30pLCF0aGlzLmJ1aWx0KXRocm93IG5ldyBSdW50aW1lRXJyb3IoXCJUaGUgbW9kZWwgbmVlZHMgdG8gYmUgY29tcGlsZWQgYmVmb3JlIGJlaW5nIHVzZWQuXCIpO3JldHVybiB0aGlzLm1vZGVsLmV2YWx1YXRlKGUsdCxuKX0sdC5wcm90b3R5cGUuZXZhbHVhdGVEYXRhc2V0PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihuKXtpZighdGhpcy5idWlsdCl0aHJvdyBuZXcgUnVudGltZUVycm9yKFwiVGhlIG1vZGVsIG5lZWRzIHRvIGJlIGNvbXBpbGVkIGJlZm9yZSBiZWluZyB1c2VkLlwiKTtyZXR1cm5bMix0aGlzLm1vZGVsLmV2YWx1YXRlRGF0YXNldChlLHQpXX0pfSl9LHQucHJvdG90eXBlLnByZWRpY3Q9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9e30pLG51bGw9PXRoaXMubW9kZWwmJnRoaXMuYnVpbGQoKSx0aGlzLm1vZGVsLnByZWRpY3QoZSx0KX0sdC5wcm90b3R5cGUucHJlZGljdE9uQmF0Y2g9ZnVuY3Rpb24oZSl7cmV0dXJuIG51bGw9PXRoaXMubW9kZWwmJnRoaXMuYnVpbGQoKSx0aGlzLm1vZGVsLnByZWRpY3RPbkJhdGNoKGUpfSx0LnByb3RvdHlwZS5jb21waWxlPWZ1bmN0aW9uKGUpe3RoaXMuYnVpbGQoKSx0aGlzLm1vZGVsLmNvbXBpbGUoZSksdGhpcy5vcHRpbWl6ZXI9dGhpcy5tb2RlbC5vcHRpbWl6ZXIsdGhpcy5sb3NzPXRoaXMubW9kZWwubG9zcyx0aGlzLm1ldHJpY3M9dGhpcy5tb2RlbC5tZXRyaWNzLHRoaXMubWV0cmljc1RlbnNvcnM9dGhpcy5tb2RlbC5tZXRyaWNzVGVuc29ycyx0aGlzLm1ldHJpY3NOYW1lcz10aGlzLm1vZGVsLm1ldHJpY3NOYW1lc30sdC5wcm90b3R5cGUuZml0PWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gdm9pZCAwPT09biYmKG49e30pLF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihyKXtpZighdGhpcy5idWlsdCl0aHJvdyBuZXcgUnVudGltZUVycm9yKFwiVGhlIG1vZGVsIG5lZWRzIHRvIGJlIGNvbXBpbGVkIGJlZm9yZSBiZWluZyB1c2VkLlwiKTtyZXR1cm5bMix0aGlzLm1vZGVsLmZpdChlLHQsbildfSl9KX0sdC5wcm90b3R5cGUuZml0RGF0YXNldD1mdW5jdGlvbihlLHQpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24obil7aWYoIXRoaXMuYnVpbHQpdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcihcIlRoZSBtb2RlbCBuZWVkcyB0byBiZSBjb21waWxlZCBiZWZvcmUgYmVpbmcgdXNlZC5cIik7cmV0dXJuWzIsdGhpcy5tb2RlbC5maXREYXRhc2V0KGUsdCldfSl9KX0sdC5mcm9tQ29uZmlnPWZ1bmN0aW9uKGUsbil7dmFyIHIsaT17fTtpZihuIGluc3RhbmNlb2YgQXJyYXkpe2lmKG51bGw9PW5bMF0uY2xhc3NOYW1lfHxcIk1lcmdlXCI9PT1uWzBdLmNsYXNzTmFtZSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkxlZ2FjeSBzZXJpYWxpemF0aW9uIGZvcm1hdCBub3Qgc3VwcG9ydGVkIHlldC5cIik7cj1ufWVsc2UgdXRpbC5hc3NlcnQobnVsbCE9bi5sYXllcnMsXCJXaGVuIHRoZSBjb25maWcgZGF0YSBmb3IgYSBTZXF1ZW50aWFsIG1vZGVsIGlzIG5vdCBhbiBBcnJheSwgaXQgbXVzdCBiZSBhbiBPYmplY3QgdGhhdCBjb250YWlucyB0aGUgJ2xheWVycycgZmllbGQuXCIpLHI9bi5sYXllcnMsZGVsZXRlIG4ubGF5ZXJzLGk9bjt2YXIgYT1uZXcgZShpKTtpZighKGEgaW5zdGFuY2VvZiB0KSl0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcIlNlcXVlbnRpYWwuZnJvbUNvbmZpZyBjYWxsZWQgb24gbm9uLVNlcXVlbnRpYWwgaW5wdXQ6IFwiK2EpO2Zvcih2YXIgbz0wLHM9cjtvPHMubGVuZ3RoO28rKyl7dmFyIGw9ZGVzZXJpYWxpemUoc1tvXSk7YS5hZGQobCl9cmV0dXJuIGF9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInN0b3BUcmFpbmluZ1wiLHtzZXQ6ZnVuY3Rpb24oZSl7dGhpcy5tb2RlbC5zdG9wVHJhaW5pbmc9ZX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXtmb3IodmFyIGU9W10sdD0wLG49dGhpcy5sYXllcnM7dDxuLmxlbmd0aDt0Kyspe3ZhciByPW5bdF07ZS5wdXNoKHtjbGFzc05hbWU6ci5nZXRDbGFzc05hbWUoKSxjb25maWc6ci5nZXRDb25maWcoKX0pfXJldHVybiBlfSx0LmNsYXNzTmFtZT1cIlNlcXVlbnRpYWxcIix0fShNb2RlbCk7ZnVuY3Rpb24gbW9kZWwoZSl7cmV0dXJuIG5ldyBNb2RlbChlKX1mdW5jdGlvbiBzZXF1ZW50aWFsKGUpe3JldHVybiBuZXcgU2VxdWVudGlhbChlKX1mdW5jdGlvbiBsb2FkTW9kZWwoZSx0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9ITApLGxvYWRNb2RlbEludGVybmFsKGUsdCl9ZnVuY3Rpb24gaW5wdXQoZSl7cmV0dXJuIElucHV0KGUpfWZ1bmN0aW9uIHJlZ2lzdGVyQ2FsbGJhY2tDb25zdHJ1Y3RvcihlLHQpe0NhbGxiYWNrQ29uc3RydWN0b3JSZWdpc3RyeS5yZWdpc3RlckNhbGxiYWNrQ29uc3RydWN0b3IoZSx0KX1zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoU2VxdWVudGlhbCk7dmFyIEFjdGl2YXRpb249ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe3JldHVybiBudWxsIT09ZSYmZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3JldHVybnt9fSx0fShzZXJpYWxpemF0aW9uLlNlcmlhbGl6YWJsZSksRWx1PWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoKXtyZXR1cm4gbnVsbCE9PWUmJmUuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbihlLHQpe3JldHVybiB2b2lkIDA9PT10JiYodD0xKSxlbHUkMShlLHQpfSx0LmNsYXNzTmFtZT1cImVsdVwiLHR9KEFjdGl2YXRpb24pO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhFbHUpO3ZhciBTZWx1PWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoKXtyZXR1cm4gbnVsbCE9PWUmJmUuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbihlKXtyZXR1cm4gc2VsdShlKX0sdC5jbGFzc05hbWU9XCJzZWx1XCIsdH0oQWN0aXZhdGlvbik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKFNlbHUpO3ZhciBSZWx1PWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoKXtyZXR1cm4gbnVsbCE9PWUmJmUuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbihlKXtyZXR1cm4gcmVsdShlKX0sdC5jbGFzc05hbWU9XCJyZWx1XCIsdH0oQWN0aXZhdGlvbik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKFJlbHUpO3ZhciBSZWx1Nj1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KCl7cmV0dXJuIG51bGwhPT1lJiZlLmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpc31yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuYXBwbHk9ZnVuY3Rpb24oZSl7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtyZXR1cm4gbWluaW11bShnZXRTY2FsYXIoNikscmVsdShlKSl9KX0sdC5jbGFzc05hbWU9XCJyZWx1NlwiLHR9KEFjdGl2YXRpb24pO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhSZWx1Nik7dmFyIExpbmVhcj1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KCl7cmV0dXJuIG51bGwhPT1lJiZlLmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpc31yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuYXBwbHk9ZnVuY3Rpb24oZSl7cmV0dXJuIGV9LHQuY2xhc3NOYW1lPVwibGluZWFyXCIsdH0oQWN0aXZhdGlvbik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKExpbmVhcik7dmFyIFNpZ21vaWQ9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe3JldHVybiBudWxsIT09ZSYmZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKGUpe3JldHVybiBzaWdtb2lkKGUpfSx0LmNsYXNzTmFtZT1cInNpZ21vaWRcIix0fShBY3RpdmF0aW9uKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoU2lnbW9pZCk7dmFyIEhhcmRTaWdtb2lkPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoKXtyZXR1cm4gbnVsbCE9PWUmJmUuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbihlKXtyZXR1cm4gaGFyZFNpZ21vaWQoZSl9LHQuY2xhc3NOYW1lPVwiaGFyZFNpZ21vaWRcIix0fShBY3RpdmF0aW9uKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoSGFyZFNpZ21vaWQpO3ZhciBTb2Z0cGx1cz1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KCl7cmV0dXJuIG51bGwhPT1lJiZlLmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpc31yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuYXBwbHk9ZnVuY3Rpb24oZSl7cmV0dXJuIHNvZnRwbHVzKGUpfSx0LmNsYXNzTmFtZT1cInNvZnRwbHVzXCIsdH0oQWN0aXZhdGlvbik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKFNvZnRwbHVzKTt2YXIgU29mdHNpZ249ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe3JldHVybiBudWxsIT09ZSYmZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKGUpe3JldHVybiBzb2Z0c2lnbihlKX0sdC5jbGFzc05hbWU9XCJzb2Z0c2lnblwiLHR9KEFjdGl2YXRpb24pO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhTb2Z0c2lnbik7dmFyIFRhbmg9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe3JldHVybiBudWxsIT09ZSYmZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKGUpe3JldHVybiB0YW5oKGUpfSx0LmNsYXNzTmFtZT1cInRhbmhcIix0fShBY3RpdmF0aW9uKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoVGFuaCk7dmFyIFNvZnRtYXg9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe3JldHVybiBudWxsIT09ZSYmZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PS0xKSxzb2Z0bWF4KGUsdCl9LHQuY2xhc3NOYW1lPVwic29mdG1heFwiLHR9KEFjdGl2YXRpb24pO2Z1bmN0aW9uIHNlcmlhbGl6ZUFjdGl2YXRpb24oZSl7cmV0dXJuIGUuZ2V0Q2xhc3NOYW1lKCl9ZnVuY3Rpb24gZGVzZXJpYWxpemVBY3RpdmF0aW9uKGUsdCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PXt9KSxkZXNlcmlhbGl6ZUtlcmFzT2JqZWN0KGUsc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLmdldE1hcCgpLmNsYXNzTmFtZU1hcCx0LFwiYWN0aXZhdGlvblwiKX1mdW5jdGlvbiBnZXRBY3RpdmF0aW9uKGUpe3JldHVybiBudWxsPT1lP2Rlc2VyaWFsaXplQWN0aXZhdGlvbih7Y2xhc3NOYW1lOlwibGluZWFyXCIsY29uZmlnOnt9fSk6XCJzdHJpbmdcIj09dHlwZW9mIGU/ZGVzZXJpYWxpemVBY3RpdmF0aW9uKHtjbGFzc05hbWU6ZSxjb25maWc6e319KTplIGluc3RhbmNlb2YgQWN0aXZhdGlvbj9lOmRlc2VyaWFsaXplQWN0aXZhdGlvbihlKX1zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoU29mdG1heCk7dmFyIFJlTFU9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyxudWxsPT10P3t9OnQpfHx0aGlzO3JldHVybiBuLnN1cHBvcnRzTWFza2luZz0hMCxudWxsIT10JiYobi5tYXhWYWx1ZT10Lm1heFZhbHVlKSxufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7ZT1nZXRFeGFjdGx5T25lVGVuc29yKGUpO3ZhciBuPXJlbHUoZSk7cmV0dXJuIG51bGwhPXRoaXMubWF4VmFsdWUmJihuPWNsaXBCeVZhbHVlKG4sMCx0aGlzLm1heFZhbHVlKSksbn0sdC5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlPWZ1bmN0aW9uKGUpe3JldHVybiBlfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD17bWF4VmFsdWU6dGhpcy5tYXhWYWx1ZX0sbj1lLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gT2JqZWN0LmFzc2lnbih0LG4pLHR9LHQuY2xhc3NOYW1lPVwiUmVMVVwiLHR9KExheWVyKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoUmVMVSk7dmFyIExlYWt5UmVMVT1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzLG51bGw9PXQ/e306dCl8fHRoaXM7cmV0dXJuIG4uREVGQVVMVF9BTFBIQT0uMyxudWxsPT10JiYodD17fSksbi5hbHBoYT1udWxsPT10LmFscGhhP24uREVGQVVMVF9BTFBIQTp0LmFscGhhLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oZSx0KXt2YXIgbj1nZXRFeGFjdGx5T25lVGVuc29yKGUpO3JldHVybiBsZWFreVJlbHUobix0aGlzLmFscGhhKX0sdC5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlPWZ1bmN0aW9uKGUpe3JldHVybiBlfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD17YWxwaGE6dGhpcy5hbHBoYX0sbj1lLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gT2JqZWN0LmFzc2lnbih0LG4pLHR9LHQuY2xhc3NOYW1lPVwiTGVha3lSZUxVXCIsdH0oTGF5ZXIpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhMZWFreVJlTFUpO3ZhciBFTFU9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyxudWxsPT10P3t9OnQpfHx0aGlzO2lmKG4uREVGQVVMVF9BTFBIQT0xLG51bGw9PXQmJih0PXt9KSxudWxsIT10LmFscGhhJiZ0LmFscGhhIT09bi5ERUZBVUxUX0FMUEhBKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwiTm9uLWRlZmF1bHQgYWxwaGEgdmFsdWUgKFwiK3QuYWxwaGErXCIpIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIEVMVSBsYXllciB5ZXQuXCIpO3JldHVybiBuLmFscGhhPW51bGw9PXQuYWxwaGE/bi5ERUZBVUxUX0FMUEhBOnQuYWxwaGEsbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihlLHQpe3ZhciBuPWdldEV4YWN0bHlPbmVUZW5zb3IoZSk7cmV0dXJuIGVsdShuKX0sdC5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlPWZ1bmN0aW9uKGUpe3JldHVybiBlfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD17YWxwaGE6dGhpcy5hbHBoYX0sbj1lLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gT2JqZWN0LmFzc2lnbih0LG4pLHR9LHQuY2xhc3NOYW1lPVwiRUxVXCIsdH0oTGF5ZXIpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhFTFUpO3ZhciBUaHJlc2hvbGRlZFJlTFU9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyxudWxsPT10P3t9OnQpfHx0aGlzO3JldHVybiBuLkRFRkFVTFRfVEhFVEE9MSxudWxsPT10JiYodD17fSksbi50aGV0YT1udWxsPT10LnRoZXRhP24uREVGQVVMVF9USEVUQTp0LnRoZXRhLG4udGhldGFUZW5zb3I9Z2V0U2NhbGFyKG4udGhldGEpLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oZSx0KXt2YXIgbj1nZXRFeGFjdGx5T25lVGVuc29yKGUpO3JldHVybiBuLm11bChjYXN0JDEobi5ncmVhdGVyKHRoaXMudGhldGFUZW5zb3IpLFwiZmxvYXQzMlwiKSl9LHQucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZT1mdW5jdGlvbihlKXtyZXR1cm4gZX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIHQ9e3RoZXRhOnRoaXMudGhldGF9LG49ZS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIE9iamVjdC5hc3NpZ24odCxuKSx0fSx0LmNsYXNzTmFtZT1cIlRocmVzaG9sZGVkUmVMVVwiLHR9KExheWVyKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoVGhyZXNob2xkZWRSZUxVKTt2YXIgU29mdG1heCQxPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49ZS5jYWxsKHRoaXMsbnVsbD09dD97fTp0KXx8dGhpcztyZXR1cm4gbi5ERUZBVUxUX0FYSVM9MSxudWxsPT10JiYodD17fSksbi5zb2Z0bWF4PShuZXcgU29mdG1heCkuYXBwbHksbi5heGlzPW51bGw9PXQuYXhpcz9uLkRFRkFVTFRfQVhJUzp0LmF4aXMsbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihlLHQpe3ZhciBuPWdldEV4YWN0bHlPbmVUZW5zb3IoZSk7cmV0dXJuIHRoaXMuc29mdG1heChuLHRoaXMuYXhpcyl9LHQucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZT1mdW5jdGlvbihlKXtyZXR1cm4gZX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIHQ9e2F4aXM6dGhpcy5heGlzfSxuPWUucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBPYmplY3QuYXNzaWduKHQsbiksdH0sdC5jbGFzc05hbWU9XCJTb2Z0bWF4XCIsdH0oTGF5ZXIpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhTb2Z0bWF4JDEpO3ZhciBSZWd1bGFyaXplcj1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KCl7cmV0dXJuIG51bGwhPT1lJiZlLmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpc31yZXR1cm4gX19leHRlbmRzKHQsZSksdH0oc2VyaWFsaXphdGlvbi5TZXJpYWxpemFibGUpLEwxTDI9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyl8fHRoaXMscj1udWxsPT10fHxudWxsPT10LmwxPy4wMTp0LmwxLGk9bnVsbD09dHx8bnVsbD09dC5sMj8uMDE6dC5sMjtyZXR1cm4gbi5oYXNMMT0wIT09cixuLmhhc0wyPTAhPT1pLG4ubDE9Z2V0U2NhbGFyKHIpLG4ubDI9Z2V0U2NhbGFyKGkpLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXt2YXIgbj16ZXJvcyhbMV0pO3JldHVybiB0Lmhhc0wxJiYobj1hZGQobixzdW0obXVsKHQubDEsYWJzKGUpKSkpKSx0Lmhhc0wyJiYobj1hZGQobixzdW0obXVsKHQubDIsc3F1YXJlKGUpKSkpKSxuLmFzU2NhbGFyKCl9KX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7cmV0dXJue2wxOnRoaXMubDEuZGF0YVN5bmMoKVswXSxsMjp0aGlzLmwyLmRhdGFTeW5jKClbMF19fSx0LmZyb21Db25maWc9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gbmV3IGUoe2wxOnQubDEsbDI6dC5sMn0pfSx0LmNsYXNzTmFtZT1cIkwxTDJcIix0fShSZWd1bGFyaXplcik7ZnVuY3Rpb24gbDEoZSl7cmV0dXJuIG5ldyBMMUwyKHtsMTpudWxsIT1lP2UubDE6bnVsbCxsMjowfSl9ZnVuY3Rpb24gbDIoZSl7cmV0dXJuIG5ldyBMMUwyKHtsMjpudWxsIT1lP2UubDI6bnVsbCxsMTowfSl9c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKEwxTDIpO3ZhciBSRUdVTEFSSVpFUl9JREVOVElGSUVSX1JFR0lTVFJZX1NZTUJPTF9NQVA9e2wxbDI6XCJMMUwyXCJ9O2Z1bmN0aW9uIHNlcmlhbGl6ZVJlZ3VsYXJpemVyKGUpe3JldHVybiBzZXJpYWxpemVLZXJhc09iamVjdChlKX1mdW5jdGlvbiBkZXNlcmlhbGl6ZVJlZ3VsYXJpemVyKGUsdCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PXt9KSxkZXNlcmlhbGl6ZUtlcmFzT2JqZWN0KGUsc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLmdldE1hcCgpLmNsYXNzTmFtZU1hcCx0LFwicmVndWxhcml6ZXJcIil9ZnVuY3Rpb24gZ2V0UmVndWxhcml6ZXIoZSl7cmV0dXJuIG51bGw9PWU/bnVsbDpcInN0cmluZ1wiPT10eXBlb2YgZT9kZXNlcmlhbGl6ZVJlZ3VsYXJpemVyKHtjbGFzc05hbWU6ZSBpbiBSRUdVTEFSSVpFUl9JREVOVElGSUVSX1JFR0lTVFJZX1NZTUJPTF9NQVA/UkVHVUxBUklaRVJfSURFTlRJRklFUl9SRUdJU1RSWV9TWU1CT0xfTUFQW2VdOmUsY29uZmlnOnt9fSk6ZSBpbnN0YW5jZW9mIFJlZ3VsYXJpemVyP2U6ZGVzZXJpYWxpemVSZWd1bGFyaXplcihlKX1mdW5jdGlvbiBub3JtYWxpemVBcnJheShlLHQsbil7aWYoXCJudW1iZXJcIj09dHlwZW9mIGUpcmV0dXJuIHB5TGlzdFJlcGVhdChlLHQpO2lmKGUubGVuZ3RoIT09dCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlRoZSBcIituK1wiIGFyZ3VtZW50IG11c3QgYmUgYSB0dXBsZSBvZiBcIit0K1wiIGludGVnZXJzLiBSZWNlaXZlZDogXCIrZS5sZW5ndGgrXCIgZWxlbWVudHMuXCIpO2Zvcih2YXIgcj0wO3I8dDsrK3Ipe3ZhciBpPWVbcl07aWYoIWlzSW50ZWdlcihpKSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlRoZSBcIituK1wiIGFyZ3VtZW50IG11c3QgYmUgYSB0dXBsZSBvZiBcIit0K1wiIGludGVnZXJzLiBSZWNlaXZlZDogXCIrSlNPTi5zdHJpbmdpZnkoZSkrXCIgaW5jbHVkaW5nIGEgbm9uLWludGVnZXIgbnVtYmVyIFwiK2kpfXJldHVybiBlfWZ1bmN0aW9uIGNvbnZPdXRwdXRMZW5ndGgoZSx0LG4scixpKXtyZXR1cm4gdm9pZCAwPT09aSYmKGk9MSksbnVsbD09ZT9lOihhPVwic2FtZVwiPT09bj9lOmUtKHQrKHQtMSkqKGktMSkpKzEsTWF0aC5mbG9vcigoYStyLTEpL3IpKTt2YXIgYX1mdW5jdGlvbiBkZWNvbnZMZW5ndGgoZSx0LG4scil7aWYobnVsbD09ZSlyZXR1cm4gbnVsbDtpZihcInZhbGlkXCI9PT1yKWU9ZSp0K21heCQxKFtuLXQsMF0pO2Vsc2V7aWYoXCJzYW1lXCIhPT1yKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiVW5zdXBwb3J0IHBhZGRpbmcgbW9kZTogXCIrcitcIi5cIik7ZSo9dH1yZXR1cm4gZX1mdW5jdGlvbiBwcmVwcm9jZXNzQ29udjJESW5wdXQoZSx0KXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3JldHVybiBjaGVja0RhdGFGb3JtYXQodCksXCJjaGFubmVsc0ZpcnN0XCI9PT10P3RyYW5zcG9zZShlLFswLDIsMywxXSk6ZX0pfWZ1bmN0aW9uIGNvbnYxZFdpdGhCaWFzKGUsdCxuLHIsaSxhLG8pe3JldHVybiB2b2lkIDA9PT1yJiYocj0xKSx2b2lkIDA9PT1pJiYoaT1cInZhbGlkXCIpLHZvaWQgMD09PW8mJihvPTEpLHRpZHkoZnVuY3Rpb24oKXtpZihudWxsPT1hJiYoYT1pbWFnZURhdGFGb3JtYXQoKSksY2hlY2tEYXRhRm9ybWF0KGEpLDMhPT1lLnNoYXBlLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlRoZSBpbnB1dCBvZiBhIGNvbnYxZFdpdGhCaWFzIG9wZXJhdGlvbiBzaG91bGQgYmUgMywgYnV0IGlzIFwiK2Uuc2hhcGUubGVuZ3RoK1wiIGluc3RlYWQuXCIpO2lmKDMhPT10LnNoYXBlLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlRoZSBrZXJuZWwgZm9yIGEgY29udjFkV2l0aEJpYXMgb3BlcmF0aW9uIHNob3VsZCBiZSAzLCBidXQgaXMgXCIrdC5zaGFwZS5sZW5ndGgrXCIgaW5zdGVhZFwiKTtpZihudWxsIT1uJiYxIT09bi5zaGFwZS5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJUaGUgYmlhcyBmb3IgYSBjb252MWRXaXRoQmlhcyBvcGVyYXRpb24gc2hvdWxkIGJlIDEsIGJ1dCBpcyBcIit0LnNoYXBlLmxlbmd0aCtcIiBpbnN0ZWFkXCIpO2lmKFwiY2hhbm5lbHNGaXJzdFwiPT09YSYmKGU9dHJhbnNwb3NlKGUsWzAsMiwxXSkpLFwiY2F1c2FsXCI9PT1pKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwiVGhlIHN1cHBvcnQgZm9yIENBVVNBTCBwYWRkaW5nIG1vZGUgaW4gY29udjFkV2l0aEJpYXMgaXMgbm90IGltcGxlbWVudGVkIHlldC5cIik7dmFyIHM9Y29udjFkKGUsdCxyLFwic2FtZVwiPT09aT9cInNhbWVcIjpcInZhbGlkXCIsXCJOV0NcIixvKTtyZXR1cm4gbnVsbCE9biYmKHM9Ymlhc0FkZChzLG4pKSxzfSl9ZnVuY3Rpb24gY29udjJkV2l0aEJpYXMoZSx0LG4scixpLGEsbyl7cmV0dXJuIHZvaWQgMD09PXImJihyPVsxLDFdKSx2b2lkIDA9PT1pJiYoaT1cInZhbGlkXCIpLHRpZHkoZnVuY3Rpb24oKXtpZihudWxsPT1hJiYoYT1pbWFnZURhdGFGb3JtYXQoKSksY2hlY2tEYXRhRm9ybWF0KGEpLDMhPT1lLnJhbmsmJjQhPT1lLnJhbmspdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJjb252MmRXaXRoQmlhcyBleHBlY3RzIGlucHV0IHRvIGJlIG9mIHJhbmsgMyBvciA0LCBidXQgcmVjZWl2ZWQgXCIrZS5yYW5rK1wiLlwiKTtpZigzIT09dC5yYW5rJiY0IT09dC5yYW5rKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiY29udjJkV2l0aEJpYXMgZXhwZWN0cyBrZXJuZWwgdG8gYmUgb2YgcmFuayAzIG9yIDQsIGJ1dCByZWNlaXZlZCBcIitlLnJhbmsrXCIuXCIpO3ZhciBzPXByZXByb2Nlc3NDb252MkRJbnB1dChlLGEpO2lmKFwiY2F1c2FsXCI9PT1pKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwiVGhlIHN1cHBvcnQgZm9yIENBVVNBTCBwYWRkaW5nIG1vZGUgaW4gY29udjFkV2l0aEJpYXMgaXMgbm90IGltcGxlbWVudGVkIHlldC5cIik7cmV0dXJuIHM9Y29udjJkKHMsdCxyLFwic2FtZVwiPT09aT9cInNhbWVcIjpcInZhbGlkXCIsXCJOSFdDXCIsbyksbnVsbCE9biYmKHM9Ymlhc0FkZChzLG4pKSxcImNoYW5uZWxzRmlyc3RcIj09PWEmJihzPXRyYW5zcG9zZShzLFswLDMsMSwyXSkpLHN9KX12YXIgQmFzZUNvbnY9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdChuLHIpe3ZhciBpPWUuY2FsbCh0aGlzLHIpfHx0aGlzO2lmKGkuYmlhcz1udWxsLGkuREVGQVVMVF9LRVJORUxfSU5JVElBTElaRVI9XCJnbG9yb3ROb3JtYWxcIixpLkRFRkFVTFRfQklBU19JTklUSUFMSVpFUj1cInplcm9zXCIsdC52ZXJpZnlDb25maWcociksaS5yYW5rPW4sMSE9PWkucmFuayYmMiE9PWkucmFuayl0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcIkNvbnZvbHV0aW9uIGxheWVyIGZvciByYW5rIG90aGVyIHRoYW4gMSBvciAyIChcIitpLnJhbmsrXCIpIGlzIG5vdCBpbXBsZW1lbnRlZCB5ZXQuXCIpO2lmKGkua2VybmVsU2l6ZT1ub3JtYWxpemVBcnJheShyLmtlcm5lbFNpemUsbixcImtlcm5lbFNpemVcIiksaS5zdHJpZGVzPW5vcm1hbGl6ZUFycmF5KG51bGw9PXIuc3RyaWRlcz8xOnIuc3RyaWRlcyxuLFwic3RyaWRlc1wiKSxpLnBhZGRpbmc9bnVsbD09ci5wYWRkaW5nP1widmFsaWRcIjpyLnBhZGRpbmcsY2hlY2tQYWRkaW5nTW9kZShpLnBhZGRpbmcpLGkuZGF0YUZvcm1hdD1udWxsPT1yLmRhdGFGb3JtYXQ/XCJjaGFubmVsc0xhc3RcIjpyLmRhdGFGb3JtYXQsY2hlY2tEYXRhRm9ybWF0KGkuZGF0YUZvcm1hdCksaS5hY3RpdmF0aW9uPWdldEFjdGl2YXRpb24oci5hY3RpdmF0aW9uKSxpLnVzZUJpYXM9bnVsbD09ci51c2VCaWFzfHxyLnVzZUJpYXMsaS5iaWFzSW5pdGlhbGl6ZXI9Z2V0SW5pdGlhbGl6ZXIoci5iaWFzSW5pdGlhbGl6ZXJ8fGkuREVGQVVMVF9CSUFTX0lOSVRJQUxJWkVSKSxpLmJpYXNDb25zdHJhaW50PWdldENvbnN0cmFpbnQoci5iaWFzQ29uc3RyYWludCksaS5iaWFzUmVndWxhcml6ZXI9Z2V0UmVndWxhcml6ZXIoci5iaWFzUmVndWxhcml6ZXIpLGkuYWN0aXZpdHlSZWd1bGFyaXplcj1nZXRSZWd1bGFyaXplcihyLmFjdGl2aXR5UmVndWxhcml6ZXIpLGkuZGlsYXRpb25SYXRlPW5vcm1hbGl6ZUFycmF5KG51bGw9PXIuZGlsYXRpb25SYXRlPzE6ci5kaWxhdGlvblJhdGUsbixcImRpbGF0aW9uUmF0ZVwiKSwxPT09aS5yYW5rJiZBcnJheS5pc0FycmF5KGkuZGlsYXRpb25SYXRlKSYmMSE9PWkuZGlsYXRpb25SYXRlLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcImRpbGF0aW9uUmF0ZSBtdXN0IGJlIGEgbnVtYmVyIG9yIGFuIGFycmF5IG9mIGEgc2luZ2xlIG51bWJlciBmb3IgMUQgY29udm9sdXRpb24sIGJ1dCByZWNlaXZlZCBcIitKU09OLnN0cmluZ2lmeShpLmRpbGF0aW9uUmF0ZSkpO2lmKDI9PT1pLnJhbmspaWYoXCJudW1iZXJcIj09dHlwZW9mIGkuZGlsYXRpb25SYXRlKWkuZGlsYXRpb25SYXRlPVtpLmRpbGF0aW9uUmF0ZSxpLmRpbGF0aW9uUmF0ZV07ZWxzZSBpZigyIT09aS5kaWxhdGlvblJhdGUubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiZGlsYXRpb25SYXRlIG11c3QgYmUgYSBudW1iZXIgb3IgYXJyYXkgb2YgdHdvIG51bWJlcnMgZm9yIDJEIGNvbnZvbHV0aW9uLCBidXQgcmVjZWl2ZWQgXCIrSlNPTi5zdHJpbmdpZnkoaS5kaWxhdGlvblJhdGUpKTtyZXR1cm4gaX1yZXR1cm4gX19leHRlbmRzKHQsZSksdC52ZXJpZnlDb25maWc9ZnVuY3Rpb24oZSl7aWYoYXNzZXJ0KFwia2VybmVsU2l6ZVwiaW4gZSxcInJlcXVpcmVkIGtleSAna2VybmVsU2l6ZScgbm90IGluIGNvbmZpZ1wiKSxcIm51bWJlclwiIT10eXBlb2YgZS5rZXJuZWxTaXplJiYhY2hlY2tBcnJheVR5cGVBbmRMZW5ndGgoZS5rZXJuZWxTaXplLFwibnVtYmVyXCIsMSwyKSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkJhc2VDb252IGV4cGVjdHMgY29uZmlnLmtlcm5lbFNpemUgdG8gYmUgbnVtYmVyIG9yIG51bWJlcltdIHdpdGggbGVuZ3RoIDEgb3IgMiwgYnV0IHJlY2VpdmVkIFwiK0pTT04uc3RyaW5naWZ5KGUua2VybmVsU2l6ZSkrXCIuXCIpfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD17a2VybmVsU2l6ZTp0aGlzLmtlcm5lbFNpemUsc3RyaWRlczp0aGlzLnN0cmlkZXMscGFkZGluZzp0aGlzLnBhZGRpbmcsZGF0YUZvcm1hdDp0aGlzLmRhdGFGb3JtYXQsZGlsYXRpb25SYXRlOnRoaXMuZGlsYXRpb25SYXRlLGFjdGl2YXRpb246c2VyaWFsaXplQWN0aXZhdGlvbih0aGlzLmFjdGl2YXRpb24pLHVzZUJpYXM6dGhpcy51c2VCaWFzLGJpYXNJbml0aWFsaXplcjpzZXJpYWxpemVJbml0aWFsaXplcih0aGlzLmJpYXNJbml0aWFsaXplciksYmlhc1JlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYmlhc1JlZ3VsYXJpemVyKSxhY3Rpdml0eVJlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYWN0aXZpdHlSZWd1bGFyaXplciksYmlhc0NvbnN0cmFpbnQ6c2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmJpYXNDb25zdHJhaW50KX0sbj1lLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gT2JqZWN0LmFzc2lnbih0LG4pLHR9LHR9KExheWVyKSxDb252PWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQobixyKXt2YXIgaT1lLmNhbGwodGhpcyxuLHIpfHx0aGlzO3JldHVybiBpLmtlcm5lbD1udWxsLHQudmVyaWZ5Q29uZmlnKHIpLGkuZmlsdGVycz1yLmZpbHRlcnMsaS5rZXJuZWxJbml0aWFsaXplcj1nZXRJbml0aWFsaXplcihyLmtlcm5lbEluaXRpYWxpemVyfHxpLkRFRkFVTFRfS0VSTkVMX0lOSVRJQUxJWkVSKSxpLmtlcm5lbENvbnN0cmFpbnQ9Z2V0Q29uc3RyYWludChyLmtlcm5lbENvbnN0cmFpbnQpLGkua2VybmVsUmVndWxhcml6ZXI9Z2V0UmVndWxhcml6ZXIoci5rZXJuZWxSZWd1bGFyaXplciksaX1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuYnVpbGQ9ZnVuY3Rpb24oZSl7ZT1nZXRFeGFjdGx5T25lU2hhcGUoZSk7dmFyIHQ9XCJjaGFubmVsc0ZpcnN0XCI9PT10aGlzLmRhdGFGb3JtYXQ/MTplLmxlbmd0aC0xO2lmKG51bGw9PWVbdF0pdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJUaGUgY2hhbm5lbCBkaW1lbnNpb24gb2YgdGhlIGlucHV0IHNob3VsZCBiZSBkZWZpbmVkLiBGb3VuZCBcIitlW3RdKTt2YXIgbixyPWVbdF0saT10aGlzLmtlcm5lbFNpemUuY29uY2F0KFtyLHRoaXMuZmlsdGVyc10pO3RoaXMua2VybmVsPXRoaXMuYWRkV2VpZ2h0KFwia2VybmVsXCIsaSxudWxsLHRoaXMua2VybmVsSW5pdGlhbGl6ZXIsdGhpcy5rZXJuZWxSZWd1bGFyaXplciwhMCx0aGlzLmtlcm5lbENvbnN0cmFpbnQpLHRoaXMudXNlQmlhcyYmKHRoaXMuYmlhcz10aGlzLmFkZFdlaWdodChcImJpYXNcIixbdGhpcy5maWx0ZXJzXSxudWxsLHRoaXMuYmlhc0luaXRpYWxpemVyLHRoaXMuYmlhc1JlZ3VsYXJpemVyLCEwLHRoaXMuYmlhc0NvbnN0cmFpbnQpKSx0aGlzLmlucHV0U3BlYz1be25kaW06dGhpcy5yYW5rKzIsYXhlczoobj17fSxuW3RdPXIsbil9XSx0aGlzLmJ1aWx0PSEwfSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciB0O2U9Z2V0RXhhY3RseU9uZVRlbnNvcihlKTt2YXIgcj1udWxsPT1uLmJpYXM/bnVsbDpuLmJpYXMucmVhZCgpO2lmKDE9PT1uLnJhbmspdD1jb252MWRXaXRoQmlhcyhlLG4ua2VybmVsLnJlYWQoKSxyLG4uc3RyaWRlc1swXSxuLnBhZGRpbmcsbi5kYXRhRm9ybWF0LG4uZGlsYXRpb25SYXRlWzBdKTtlbHNlIGlmKDI9PT1uLnJhbmspdD1jb252MmRXaXRoQmlhcyhlLG4ua2VybmVsLnJlYWQoKSxyLG4uc3RyaWRlcyxuLnBhZGRpbmcsbi5kYXRhRm9ybWF0LG4uZGlsYXRpb25SYXRlKTtlbHNlIGlmKDM9PT1uLnJhbmspdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCIzRCBjb252b2x1dGlvbiBpcyBub3QgaW1wbGVtZW50ZWQgeWV0LlwiKTtyZXR1cm4gbnVsbCE9bi5hY3RpdmF0aW9uJiYodD1uLmFjdGl2YXRpb24uYXBwbHkodCkpLHR9KX0sdC5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlPWZ1bmN0aW9uKGUpe2U9Z2V0RXhhY3RseU9uZVNoYXBlKGUpO2Zvcih2YXIgdD1bXSxuPVwiY2hhbm5lbHNMYXN0XCI9PT10aGlzLmRhdGFGb3JtYXQ/ZS5zbGljZSgxLGUubGVuZ3RoLTEpOmUuc2xpY2UoMikscj0wO3I8bi5sZW5ndGg7KytyKXt2YXIgaT1jb252T3V0cHV0TGVuZ3RoKG5bcl0sdGhpcy5rZXJuZWxTaXplW3JdLHRoaXMucGFkZGluZyx0aGlzLnN0cmlkZXNbcl0sXCJudW1iZXJcIj09dHlwZW9mIHRoaXMuZGlsYXRpb25SYXRlP3RoaXMuZGlsYXRpb25SYXRlOnRoaXMuZGlsYXRpb25SYXRlW3JdKTt0LnB1c2goaSl9dmFyIGE9W2VbMF1dO3JldHVyblwiY2hhbm5lbHNMYXN0XCI9PT10aGlzLmRhdGFGb3JtYXQ/KGE9YS5jb25jYXQodCkpLnB1c2godGhpcy5maWx0ZXJzKTooYS5wdXNoKHRoaXMuZmlsdGVycyksYT1hLmNvbmNhdCh0KSksYX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIHQ9e2ZpbHRlcnM6dGhpcy5maWx0ZXJzLGtlcm5lbEluaXRpYWxpemVyOnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMua2VybmVsSW5pdGlhbGl6ZXIpLGtlcm5lbFJlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMua2VybmVsUmVndWxhcml6ZXIpLGtlcm5lbENvbnN0cmFpbnQ6c2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmtlcm5lbENvbnN0cmFpbnQpfSxuPWUucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBPYmplY3QuYXNzaWduKHQsbiksdH0sdC52ZXJpZnlDb25maWc9ZnVuY3Rpb24oZSl7aWYoIShcImZpbHRlcnNcImluIGUpfHxcIm51bWJlclwiIT10eXBlb2YgZS5maWx0ZXJzfHxlLmZpbHRlcnM8MSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkNvbnZvbHV0aW9uIGxheWVyIGV4cGVjdGVkIGNvbmZpZy5maWx0ZXJzIHRvIGJlIGEgJ251bWJlcicgPiAwIGJ1dCBnb3QgXCIrSlNPTi5zdHJpbmdpZnkoZS5maWx0ZXJzKSl9LHR9KEJhc2VDb252KSxDb252MkQ9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdChuKXt2YXIgcj1lLmNhbGwodGhpcywyLG4pfHx0aGlzO3JldHVybiB0LnZlcmlmeUNvbmZpZyhuKSxyfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD1lLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gZGVsZXRlIHQucmFuayx0fSx0LnZlcmlmeUNvbmZpZz1mdW5jdGlvbihlKXtpZihcIm51bWJlclwiIT10eXBlb2YgZS5rZXJuZWxTaXplJiYhY2hlY2tBcnJheVR5cGVBbmRMZW5ndGgoZS5rZXJuZWxTaXplLFwibnVtYmVyXCIsMSwyKSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkNvbnYyRCBleHBlY3RzIGNvbmZpZy5rZXJuZWxTaXplIHRvIGJlIG51bWJlciBvciBudW1iZXJbXSB3aXRoIGxlbmd0aCAxIG9yIDIsIGJ1dCByZWNlaXZlZCBcIitKU09OLnN0cmluZ2lmeShlLmtlcm5lbFNpemUpK1wiLlwiKX0sdC5jbGFzc05hbWU9XCJDb252MkRcIix0fShDb252KTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoQ29udjJEKTt2YXIgQ29udjJEVHJhbnNwb3NlPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49ZS5jYWxsKHRoaXMsdCl8fHRoaXM7aWYobi5pbnB1dFNwZWM9W25ldyBJbnB1dFNwZWMoe25kaW06NH0pXSxcInNhbWVcIiE9PW4ucGFkZGluZyYmXCJ2YWxpZFwiIT09bi5wYWRkaW5nKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiQ29udjJEVHJhbnNwb3NlIGN1cnJlbnRseSBzdXBwb3J0cyBvbmx5IHBhZGRpbmcgbW9kZXMgJ3NhbWUnIGFuZCAndmFsaWQnLCBidXQgcmVjZWl2ZWQgcGFkZGluZyBtb2RlIFwiK24ucGFkZGluZyk7cmV0dXJuIG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmJ1aWxkPWZ1bmN0aW9uKGUpe2lmKDQhPT0oZT1nZXRFeGFjdGx5T25lU2hhcGUoZSkpLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIklucHV0IHNob3VsZCBoYXZlIHJhbmsgNDsgUmVjZWl2ZWQgaW5wdXQgc2hhcGU6IFwiK0pTT04uc3RyaW5naWZ5KGUpKTt2YXIgdD1cImNoYW5uZWxzRmlyc3RcIj09PXRoaXMuZGF0YUZvcm1hdD8xOmUubGVuZ3RoLTE7aWYobnVsbD09ZVt0XSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlRoZSBjaGFubmVsIGRpbWVuc2lvbiBvZiB0aGUgaW5wdXRzIHNob3VsZCBiZSBkZWZpbmVkLiBGb3VuZCBgTm9uZWAuXCIpO3ZhciBuLHI9ZVt0XSxpPXRoaXMua2VybmVsU2l6ZS5jb25jYXQoW3RoaXMuZmlsdGVycyxyXSk7dGhpcy5rZXJuZWw9dGhpcy5hZGRXZWlnaHQoXCJrZXJuZWxcIixpLFwiZmxvYXQzMlwiLHRoaXMua2VybmVsSW5pdGlhbGl6ZXIsdGhpcy5rZXJuZWxSZWd1bGFyaXplciwhMCx0aGlzLmtlcm5lbENvbnN0cmFpbnQpLHRoaXMudXNlQmlhcyYmKHRoaXMuYmlhcz10aGlzLmFkZFdlaWdodChcImJpYXNcIixbdGhpcy5maWx0ZXJzXSxcImZsb2F0MzJcIix0aGlzLmJpYXNJbml0aWFsaXplcix0aGlzLmJpYXNSZWd1bGFyaXplciwhMCx0aGlzLmJpYXNDb25zdHJhaW50KSksdGhpcy5pbnB1dFNwZWM9W25ldyBJbnB1dFNwZWMoe25kaW06NCxheGVzOihuPXt9LG5bdF09cixuKX0pXSx0aGlzLmJ1aWx0PSEwfSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciB0PWdldEV4YWN0bHlPbmVUZW5zb3IoZSk7aWYoNCE9PXQuc2hhcGUubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiQ29udjJEVHJhbnNwb3NlLmNhbGwoKSBleHBlY3RzIGlucHV0IHRlbnNvciB0byBiZSByYW5rLTQsIGJ1dCByZWNlaXZlZCBhIHRlbnNvciBvZiByYW5rLVwiK3Quc2hhcGUubGVuZ3RoKTt2YXIgcixpLGE9dC5zaGFwZSxvPWFbMF07XCJjaGFubmVsc0ZpcnN0XCI9PT1uLmRhdGFGb3JtYXQ/KHI9MixpPTMpOihyPTEsaT0yKTt2YXIgcz1hW3JdLGw9YVtpXSx1PW4ua2VybmVsU2l6ZVswXSxjPW4ua2VybmVsU2l6ZVsxXSxwPW4uc3RyaWRlc1swXSxoPW4uc3RyaWRlc1sxXSxkPVtvLGRlY29udkxlbmd0aChzLHAsdSxuLnBhZGRpbmcpLGRlY29udkxlbmd0aChsLGgsYyxuLnBhZGRpbmcpLG4uZmlsdGVyc107XCJjaGFubmVsc0xhc3RcIiE9PW4uZGF0YUZvcm1hdCYmKHQ9dHJhbnNwb3NlKHQsWzAsMiwzLDFdKSk7dmFyIGY9Y29udjJkVHJhbnNwb3NlKHQsbi5rZXJuZWwucmVhZCgpLGQsbi5zdHJpZGVzLG4ucGFkZGluZyk7cmV0dXJuXCJjaGFubmVsc0xhc3RcIiE9PW4uZGF0YUZvcm1hdCYmKGY9dHJhbnNwb3NlKGYsWzAsMywxLDJdKSksbnVsbCE9bi5iaWFzJiYoZj1iaWFzQWRkKGYsbi5iaWFzLnJlYWQoKSxuLmRhdGFGb3JtYXQpKSxudWxsIT1uLmFjdGl2YXRpb24mJihmPW4uYWN0aXZhdGlvbi5hcHBseShmKSksZn0pfSx0LnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGU9ZnVuY3Rpb24oZSl7dmFyIHQsbixyLGk9KGU9Z2V0RXhhY3RseU9uZVNoYXBlKGUpKS5zbGljZSgpO1wiY2hhbm5lbHNGaXJzdFwiPT09dGhpcy5kYXRhRm9ybWF0Pyh0PTEsbj0yLHI9Myk6KHQ9MyxuPTEscj0yKTt2YXIgYT10aGlzLmtlcm5lbFNpemVbMF0sbz10aGlzLmtlcm5lbFNpemVbMV0scz10aGlzLnN0cmlkZXNbMF0sbD10aGlzLnN0cmlkZXNbMV07cmV0dXJuIGlbdF09dGhpcy5maWx0ZXJzLGlbbl09ZGVjb252TGVuZ3RoKGlbbl0scyxhLHRoaXMucGFkZGluZyksaVtyXT1kZWNvbnZMZW5ndGgoaVtyXSxsLG8sdGhpcy5wYWRkaW5nKSxpfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD1lLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gZGVsZXRlIHQuZGlsYXRpb25SYXRlLHR9LHQuY2xhc3NOYW1lPVwiQ29udjJEVHJhbnNwb3NlXCIsdH0oQ29udjJEKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoQ29udjJEVHJhbnNwb3NlKTt2YXIgU2VwYXJhYmxlQ29udj1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQsbil7dmFyIHI9ZS5jYWxsKHRoaXMsdCxuKXx8dGhpcztpZihyLkRFRkFVTFRfREVQVEhXSVNFX0lOSVRJQUxJWkVSPVwiZ2xvcm90VW5pZm9ybVwiLHIuREVGQVVMVF9QT0lOVFdJU0VfSU5JVElBTElaRVI9XCJnbG9yb3RVbmlmb3JtXCIsci5kZXB0aHdpc2VLZXJuZWw9bnVsbCxyLnBvaW50d2lzZUtlcm5lbD1udWxsLG51bGw9PW4uZmlsdGVycyl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlRoZSBgZmlsdGVyc2AgY29uZmlndXJhdGlvbiBmaWVsZCBpcyByZXF1aXJlZCBieSBTZXBhcmFibGVDb252LCBidXQgaXMgdW5zcGVjaWZpZWQuXCIpO2lmKG51bGwhPW4ua2VybmVsSW5pdGlhbGl6ZXJ8fG51bGwhPW4ua2VybmVsUmVndWxhcml6ZXJ8fG51bGwhPW4ua2VybmVsQ29uc3RyYWludCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkZpZWxkcyBrZXJuZWxJbml0aWFsaXplciwga2VybmVsUmVndWxhcml6ZXIgYW5kIGtlcm5lbENvbnN0cmFpbnQgYXJlIGludmFsaWQgZm9yIFNlcGFyYWJsZUNvbnYyRC4gVXNlIGRlcHRod2lzZUluaXRpYWxpemVyLCBkZXB0aHdpc2VSZWd1bGFyaXplciwgZGVwdGh3aXNlQ29uc3RyYWludCwgcG9pbnR3aXNlSW5pdGlhbGl6ZXIsIHBvaW50d2lzZVJlZ3VsYXJpemVyIGFuZCBwb2ludHdpc2VDb25zdHJhaW50IGluc3RlYWQuXCIpO2lmKG51bGwhPW4ucGFkZGluZyYmXCJzYW1lXCIhPT1uLnBhZGRpbmcmJlwidmFsaWRcIiE9PW4ucGFkZGluZyl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlNlcGFyYWJsZUNvbnZcIityLnJhbmsrXCJEIHN1cHBvcnRzIG9ubHkgcGFkZGluZyBtb2RlczogJ3NhbWUnIGFuZCAndmFsaWQnLCBidXQgcmVjZWl2ZWQgXCIrSlNPTi5zdHJpbmdpZnkobi5wYWRkaW5nKSk7cmV0dXJuIHIuZGVwdGhNdWx0aXBsaWVyPW51bGw9PW4uZGVwdGhNdWx0aXBsaWVyPzE6bi5kZXB0aE11bHRpcGxpZXIsci5kZXB0aHdpc2VJbml0aWFsaXplcj1nZXRJbml0aWFsaXplcihuLmRlcHRod2lzZUluaXRpYWxpemVyfHxyLkRFRkFVTFRfREVQVEhXSVNFX0lOSVRJQUxJWkVSKSxyLmRlcHRod2lzZVJlZ3VsYXJpemVyPWdldFJlZ3VsYXJpemVyKG4uZGVwdGh3aXNlUmVndWxhcml6ZXIpLHIuZGVwdGh3aXNlQ29uc3RyYWludD1nZXRDb25zdHJhaW50KG4uZGVwdGh3aXNlQ29uc3RyYWludCksci5wb2ludHdpc2VJbml0aWFsaXplcj1nZXRJbml0aWFsaXplcihuLmRlcHRod2lzZUluaXRpYWxpemVyfHxyLkRFRkFVTFRfUE9JTlRXSVNFX0lOSVRJQUxJWkVSKSxyLnBvaW50d2lzZVJlZ3VsYXJpemVyPWdldFJlZ3VsYXJpemVyKG4ucG9pbnR3aXNlUmVndWxhcml6ZXIpLHIucG9pbnR3aXNlQ29uc3RyYWludD1nZXRDb25zdHJhaW50KG4ucG9pbnR3aXNlQ29uc3RyYWludCkscn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuYnVpbGQ9ZnVuY3Rpb24oZSl7aWYoKGU9Z2V0RXhhY3RseU9uZVNoYXBlKGUpKS5sZW5ndGg8dGhpcy5yYW5rKzIpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJJbnB1dHMgdG8gU2VwYXJhYmxlQ29udlwiK3RoaXMucmFuaytcIkQgc2hvdWxkIGhhdmUgcmFuayBcIisodGhpcy5yYW5rKzIpK1wiLCBidXQgcmVjZWl2ZWQgaW5wdXQgc2hhcGU6IFwiK0pTT04uc3RyaW5naWZ5KGUpKTt2YXIgdD1cImNoYW5uZWxzRmlyc3RcIj09PXRoaXMuZGF0YUZvcm1hdD8xOmUubGVuZ3RoLTE7aWYobnVsbD09ZVt0XXx8ZVt0XTwwKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiVGhlIGNoYW5uZWwgZGltZW5zaW9uIG9mIHRoZSBpbnB1dHMgc2hvdWxkIGJlIGRlZmluZWQsIGJ1dCBmb3VuZCBcIitKU09OLnN0cmluZ2lmeShlW3RdKSk7Zm9yKHZhciBuPWVbdF0scj10aGlzLmtlcm5lbFNpemUuY29uY2F0KFtuLHRoaXMuZGVwdGhNdWx0aXBsaWVyXSksaT1bXSxhPTA7YTx0aGlzLnJhbms7KythKWkucHVzaCgxKTtpLnB1c2gobip0aGlzLmRlcHRoTXVsdGlwbGllcix0aGlzLmZpbHRlcnMpO3ZhciBvO3RoaXMuZGVwdGh3aXNlS2VybmVsPXRoaXMuYWRkV2VpZ2h0KFwiZGVwdGh3aXNlX2tlcm5lbFwiLHIsXCJmbG9hdDMyXCIsdGhpcy5kZXB0aHdpc2VJbml0aWFsaXplcix0aGlzLmRlcHRod2lzZVJlZ3VsYXJpemVyLCEwLHRoaXMuZGVwdGh3aXNlQ29uc3RyYWludCksdGhpcy5wb2ludHdpc2VLZXJuZWw9dGhpcy5hZGRXZWlnaHQoXCJwb2ludHdpc2Vfa2VybmVsXCIsaSxcImZsb2F0MzJcIix0aGlzLnBvaW50d2lzZUluaXRpYWxpemVyLHRoaXMucG9pbnR3aXNlUmVndWxhcml6ZXIsITAsdGhpcy5wb2ludHdpc2VDb25zdHJhaW50KSx0aGlzLnVzZUJpYXM/dGhpcy5iaWFzPXRoaXMuYWRkV2VpZ2h0KFwiYmlhc1wiLFt0aGlzLmZpbHRlcnNdLFwiZmxvYXQzMlwiLHRoaXMuYmlhc0luaXRpYWxpemVyLHRoaXMuYmlhc1JlZ3VsYXJpemVyLCEwLHRoaXMuYmlhc0NvbnN0cmFpbnQpOnRoaXMuYmlhcz1udWxsLHRoaXMuaW5wdXRTcGVjPVtuZXcgSW5wdXRTcGVjKHtuZGltOnRoaXMucmFuaysyLGF4ZXM6KG89e30sb1t0XT1uLG8pfSldLHRoaXMuYnVpbHQ9ITB9LHQucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIHQ7aWYoZT1nZXRFeGFjdGx5T25lVGVuc29yKGUpLDE9PT1uLnJhbmspdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCIxRCBzZXBhcmFibGUgY29udm9sdXRpb24gaXMgbm90IGltcGxlbWVudGVkIHlldC5cIik7cmV0dXJuIDI9PT1uLnJhbmsmJihcImNoYW5uZWxzRmlyc3RcIj09PW4uZGF0YUZvcm1hdCYmKGU9dHJhbnNwb3NlKGUsWzAsMiwzLDFdKSksdD1zZXBhcmFibGVDb252MmQoZSxuLmRlcHRod2lzZUtlcm5lbC5yZWFkKCksbi5wb2ludHdpc2VLZXJuZWwucmVhZCgpLG4uc3RyaWRlcyxuLnBhZGRpbmcsbi5kaWxhdGlvblJhdGUsXCJOSFdDXCIpKSxuLnVzZUJpYXMmJih0PWJpYXNBZGQodCxuLmJpYXMucmVhZCgpLG4uZGF0YUZvcm1hdCkpLG51bGwhPW4uYWN0aXZhdGlvbiYmKHQ9bi5hY3RpdmF0aW9uLmFwcGx5KHQpKSxcImNoYW5uZWxzRmlyc3RcIj09PW4uZGF0YUZvcm1hdCYmKHQ9dHJhbnNwb3NlKHQsWzAsMywxLDJdKSksdH0pfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD1lLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gZGVsZXRlIHQucmFuayxkZWxldGUgdC5rZXJuZWxJbml0aWFsaXplcixkZWxldGUgdC5rZXJuZWxSZWd1bGFyaXplcixkZWxldGUgdC5rZXJuZWxDb25zdHJhaW50LHQuZGVwdGh3aXNlSW5pdGlhbGl6ZXI9c2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5kZXB0aHdpc2VJbml0aWFsaXplciksdC5wb2ludHdpc2VJbml0aWFsaXplcj1zZXJpYWxpemVJbml0aWFsaXplcih0aGlzLnBvaW50d2lzZUluaXRpYWxpemVyKSx0LmRlcHRod2lzZVJlZ3VsYXJpemVyPXNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuZGVwdGh3aXNlUmVndWxhcml6ZXIpLHQucG9pbnR3aXNlUmVndWxhcml6ZXI9c2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5wb2ludHdpc2VSZWd1bGFyaXplciksdC5kZXB0aHdpc2VDb25zdHJhaW50PXNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5kZXB0aHdpc2VDb25zdHJhaW50KSx0LnBvaW50d2lzZUNvbnN0cmFpbnQ9c2VyaWFsaXplQ29uc3RyYWludCh0aGlzLnBvaW50d2lzZUNvbnN0cmFpbnQpLHR9LHQuY2xhc3NOYW1lPVwiU2VwYXJhYmxlQ29udlwiLHR9KENvbnYpLFNlcGFyYWJsZUNvbnYyRD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3JldHVybiBlLmNhbGwodGhpcywyLHQpfHx0aGlzfXJldHVybiBfX2V4dGVuZHModCxlKSx0LmNsYXNzTmFtZT1cIlNlcGFyYWJsZUNvbnYyRFwiLHR9KFNlcGFyYWJsZUNvbnYpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhTZXBhcmFibGVDb252MkQpO3ZhciBDb252MUQ9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdChuKXt2YXIgcj1lLmNhbGwodGhpcywxLG4pfHx0aGlzO3JldHVybiB0LnZlcmlmeUNvbmZpZyhuKSxyLmlucHV0U3BlYz1be25kaW06M31dLHJ9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciB0PWUucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBkZWxldGUgdC5yYW5rLGRlbGV0ZSB0LmRhdGFGb3JtYXQsdH0sdC52ZXJpZnlDb25maWc9ZnVuY3Rpb24oZSl7aWYoXCJudW1iZXJcIiE9dHlwZW9mIGUua2VybmVsU2l6ZSYmIWNoZWNrQXJyYXlUeXBlQW5kTGVuZ3RoKGUua2VybmVsU2l6ZSxcIm51bWJlclwiLDEsMSkpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJDb252MUQgZXhwZWN0cyBjb25maWcua2VybmVsU2l6ZSB0byBiZSBudW1iZXIgb3IgbnVtYmVyW10gd2l0aCBsZW5ndGggMSwgYnV0IHJlY2VpdmVkIFwiK0pTT04uc3RyaW5naWZ5KGUua2VybmVsU2l6ZSkrXCIuXCIpfSx0LmNsYXNzTmFtZT1cIkNvbnYxRFwiLHR9KENvbnYpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhDb252MUQpO3ZhciBDcm9wcGluZzJEPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49ZS5jYWxsKHRoaXMsdCl8fHRoaXM7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIHQuY3JvcHBpbmc/bi5jcm9wcGluZz1bW3QuY3JvcHBpbmcsdC5jcm9wcGluZ10sW3QuY3JvcHBpbmcsdC5jcm9wcGluZ11dOlwibnVtYmVyXCI9PXR5cGVvZiB0LmNyb3BwaW5nWzBdP24uY3JvcHBpbmc9W1t0LmNyb3BwaW5nWzBdLHQuY3JvcHBpbmdbMF1dLFt0LmNyb3BwaW5nWzFdLHQuY3JvcHBpbmdbMV1dXTpuLmNyb3BwaW5nPXQuY3JvcHBpbmcsbi5kYXRhRm9ybWF0PXZvaWQgMD09PXQuZGF0YUZvcm1hdD9cImNoYW5uZWxzTGFzdFwiOnQuZGF0YUZvcm1hdCxuLmlucHV0U3BlYz1be25kaW06NH1dLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZT1mdW5jdGlvbihlKXtyZXR1cm5cImNoYW5uZWxzRmlyc3RcIj09PXRoaXMuZGF0YUZvcm1hdD9bZVswXSxlWzFdLGVbMl0tdGhpcy5jcm9wcGluZ1swXVswXS10aGlzLmNyb3BwaW5nWzBdWzFdLGVbM10tdGhpcy5jcm9wcGluZ1sxXVswXS10aGlzLmNyb3BwaW5nWzFdWzFdXTpbZVswXSxlWzFdLXRoaXMuY3JvcHBpbmdbMF1bMF0tdGhpcy5jcm9wcGluZ1swXVsxXSxlWzJdLXRoaXMuY3JvcHBpbmdbMV1bMF0tdGhpcy5jcm9wcGluZ1sxXVsxXSxlWzNdXX0sdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtyZXR1cm4gZT1nZXRFeGFjdGx5T25lVGVuc29yKGUpLFwiY2hhbm5lbHNMYXN0XCI9PT1uLmRhdGFGb3JtYXQ/c2xpY2VBbG9uZ0F4aXMoc2xpY2VBbG9uZ0F4aXMoZSxuLmNyb3BwaW5nWzBdWzBdLGUuc2hhcGVbMV0tbi5jcm9wcGluZ1swXVswXS1uLmNyb3BwaW5nWzBdWzFdLDIpLG4uY3JvcHBpbmdbMV1bMF0sZS5zaGFwZVsyXS1uLmNyb3BwaW5nWzFdWzFdLW4uY3JvcHBpbmdbMV1bMF0sMyk6c2xpY2VBbG9uZ0F4aXMoc2xpY2VBbG9uZ0F4aXMoZSxuLmNyb3BwaW5nWzBdWzBdLGUuc2hhcGVbMl0tbi5jcm9wcGluZ1swXVswXS1uLmNyb3BwaW5nWzBdWzFdLDMpLG4uY3JvcHBpbmdbMV1bMF0sZS5zaGFwZVszXS1uLmNyb3BwaW5nWzFdWzFdLW4uY3JvcHBpbmdbMV1bMF0sNCl9KX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIHQ9e2Nyb3BwaW5nOnRoaXMuY3JvcHBpbmcsZGF0YUZvcm1hdDp0aGlzLmRhdGFGb3JtYXR9LG49ZS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIE9iamVjdC5hc3NpZ24odCxuKSx0fSx0LmNsYXNzTmFtZT1cIkNyb3BwaW5nMkRcIix0fShMYXllcik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKENyb3BwaW5nMkQpO3ZhciBVcFNhbXBsaW5nMkQ9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyx0KXx8dGhpcztyZXR1cm4gbi5ERUZBVUxUX1NJWkU9WzIsMl0sbi5pbnB1dFNwZWM9W3tuZGltOjR9XSxuLnNpemU9bnVsbD09dC5zaXplP24uREVGQVVMVF9TSVpFOnQuc2l6ZSxuLmRhdGFGb3JtYXQ9bnVsbD09dC5kYXRhRm9ybWF0P1wiY2hhbm5lbHNMYXN0XCI6dC5kYXRhRm9ybWF0LG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZT1mdW5jdGlvbihlKXtpZihcImNoYW5uZWxzRmlyc3RcIj09PXRoaXMuZGF0YUZvcm1hdCl7dmFyIHQ9bnVsbD09ZVsyXT9udWxsOnRoaXMuc2l6ZVswXSplWzJdLG49bnVsbD09ZVszXT9udWxsOnRoaXMuc2l6ZVsxXSplWzNdO3JldHVybltlWzBdLGVbMV0sdCxuXX10PW51bGw9PWVbMV0/bnVsbDp0aGlzLnNpemVbMF0qZVsxXSxuPW51bGw9PWVbMl0/bnVsbDp0aGlzLnNpemVbMV0qZVsyXTtyZXR1cm5bZVswXSx0LG4sZVszXV19LHQucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIHQ9Z2V0RXhhY3RseU9uZVRlbnNvcihlKSxyPXQuc2hhcGU7aWYoXCJjaGFubmVsc0ZpcnN0XCI9PT1uLmRhdGFGb3JtYXQpe3Q9dHJhbnNwb3NlKHQsWzAsMiwzLDFdKTt2YXIgaT1uLnNpemVbMF0qclsyXSxhPW4uc2l6ZVsxXSpyWzNdLG89dC5yZXNpemVOZWFyZXN0TmVpZ2hib3IoW2ksYV0pO3JldHVybiB0cmFuc3Bvc2UobyxbMCwzLDEsMl0pfWk9bi5zaXplWzBdKnJbMV0sYT1uLnNpemVbMV0qclsyXTtyZXR1cm4gdC5yZXNpemVOZWFyZXN0TmVpZ2hib3IoW2ksYV0pfSl9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciB0PXtzaXplOnRoaXMuc2l6ZSxkYXRhRm9ybWF0OnRoaXMuZGF0YUZvcm1hdH0sbj1lLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gT2JqZWN0LmFzc2lnbih0LG4pLHR9LHQuY2xhc3NOYW1lPVwiVXBTYW1wbGluZzJEXCIsdH0oTGF5ZXIpO2Z1bmN0aW9uIGRlcHRod2lzZUNvbnYyZCQxKGUsdCxuLHIsaSxhKXtyZXR1cm4gdm9pZCAwPT09biYmKG49WzEsMV0pLHZvaWQgMD09PXImJihyPVwidmFsaWRcIiksdGlkeShmdW5jdGlvbigpe251bGw9PWkmJihpPWltYWdlRGF0YUZvcm1hdCgpKSxjaGVja0RhdGFGb3JtYXQoaSk7dmFyIG89cHJlcHJvY2Vzc0NvbnYyRElucHV0KGUsaSk7aWYoNCE9PWUucmFuayl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIklucHV0IGZvciBkZXB0aHdpc2VDb252MmQgaXMgcmVxdWlyZWQgdG8gYmUgNC1ELCBidXQgaXMgaW5zdGVhZCBcIitlLnJhbmsrXCItRFwiKTtpZig0IT09dC5yYW5rKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiZGVwdGh3aXNlS2VybmVsIGlzIHJlcXVpcmVkIHRvIGJlIDQtRCwgYnV0IGlzIGluc3RlYWQgXCIrdC5yYW5rK1wiLURcIik7cmV0dXJuIG89ZGVwdGh3aXNlQ29udjJkKG8sdCxuLFwic2FtZVwiPT09cj9cInNhbWVcIjpcInZhbGlkXCIsXCJOSFdDXCIsYSksXCJjaGFubmVsc0ZpcnN0XCI9PT1pJiYobz10cmFuc3Bvc2UobyxbMCwzLDEsMl0pKSxvfSl9c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKFVwU2FtcGxpbmcyRCk7dmFyIERlcHRod2lzZUNvbnYyRD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzLDIsdCl8fHRoaXM7cmV0dXJuIG4uZGVwdGh3aXNlS2VybmVsPW51bGwsbi5kZXB0aE11bHRpcGxpZXI9bnVsbD09dC5kZXB0aE11bHRpcGxpZXI/MTp0LmRlcHRoTXVsdGlwbGllcixuLmRlcHRod2lzZUluaXRpYWxpemVyPWdldEluaXRpYWxpemVyKHQuZGVwdGh3aXNlSW5pdGlhbGl6ZXJ8fG4uREVGQVVMVF9LRVJORUxfSU5JVElBTElaRVIpLG4uZGVwdGh3aXNlQ29uc3RyYWludD1nZXRDb25zdHJhaW50KHQuZGVwdGh3aXNlQ29uc3RyYWludCksbi5kZXB0aHdpc2VSZWd1bGFyaXplcj1nZXRSZWd1bGFyaXplcih0LmRlcHRod2lzZVJlZ3VsYXJpemVyKSxufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5idWlsZD1mdW5jdGlvbihlKXtpZigoZT1nZXRFeGFjdGx5T25lU2hhcGUoZSkpLmxlbmd0aDw0KXRocm93IG5ldyBWYWx1ZUVycm9yKFwiSW5wdXRzIHRvIERlcHRod2lzZUNvbnYyRCBzaG91bGQgaGF2ZSByYW5rIDQuIFJlY2VpdmVkIGlucHV0IHNoYXBlOiBcIitKU09OLnN0cmluZ2lmeShlKStcIi5cIik7dmFyIHQ9XCJjaGFubmVsc0ZpcnN0XCI9PT10aGlzLmRhdGFGb3JtYXQ/MTozO2lmKG51bGw9PWVbdF18fGVbdF08MCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlRoZSBjaGFubmVsIGRpbWVuc2lvbiBvZiB0aGUgaW5wdXRzIHRvIERlcHRod2lzZUNvbnYyRCBzaG91bGQgYmUgZGVmaW5lZCwgYnV0IGlzIG5vdCAoXCIrZVt0XStcIikuXCIpO3ZhciBuPWVbdF0scj1bdGhpcy5rZXJuZWxTaXplWzBdLHRoaXMua2VybmVsU2l6ZVsxXSxuLHRoaXMuZGVwdGhNdWx0aXBsaWVyXTt0aGlzLmRlcHRod2lzZUtlcm5lbD10aGlzLmFkZFdlaWdodChcImRlcHRod2lzZV9rZXJuZWxcIixyLG51bGwsdGhpcy5kZXB0aHdpc2VJbml0aWFsaXplcix0aGlzLmRlcHRod2lzZVJlZ3VsYXJpemVyLCEwLHRoaXMuZGVwdGh3aXNlQ29uc3RyYWludCksdGhpcy51c2VCaWFzP3RoaXMuYmlhcz10aGlzLmFkZFdlaWdodChcImJpYXNcIixbbip0aGlzLmRlcHRoTXVsdGlwbGllcl0sbnVsbCx0aGlzLmJpYXNJbml0aWFsaXplcix0aGlzLmJpYXNSZWd1bGFyaXplciwhMCx0aGlzLmJpYXNDb25zdHJhaW50KTp0aGlzLmJpYXM9bnVsbCx0aGlzLmJ1aWx0PSEwfSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciB0PWRlcHRod2lzZUNvbnYyZCQxKGU9Z2V0RXhhY3RseU9uZVRlbnNvcihlKSxuLmRlcHRod2lzZUtlcm5lbC5yZWFkKCksbi5zdHJpZGVzLG4ucGFkZGluZyxuLmRhdGFGb3JtYXQsbnVsbCk7cmV0dXJuIG4udXNlQmlhcyYmKHQ9Ymlhc0FkZCh0LG4uYmlhcy5yZWFkKCksbi5kYXRhRm9ybWF0KSksbnVsbCE9bi5hY3RpdmF0aW9uJiYodD1uLmFjdGl2YXRpb24uYXBwbHkodCkpLHR9KX0sdC5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlPWZ1bmN0aW9uKGUpe2U9Z2V0RXhhY3RseU9uZVNoYXBlKGUpO3ZhciB0PVwiY2hhbm5lbHNGaXJzdFwiPT09dGhpcy5kYXRhRm9ybWF0P2VbMl06ZVsxXSxuPVwiY2hhbm5lbHNGaXJzdFwiPT09dGhpcy5kYXRhRm9ybWF0P2VbM106ZVsyXSxyPVwiY2hhbm5lbHNGaXJzdFwiPT09dGhpcy5kYXRhRm9ybWF0P2VbMV0qdGhpcy5kZXB0aE11bHRpcGxpZXI6ZVszXSp0aGlzLmRlcHRoTXVsdGlwbGllcixpPWNvbnZPdXRwdXRMZW5ndGgodCx0aGlzLmtlcm5lbFNpemVbMF0sdGhpcy5wYWRkaW5nLHRoaXMuc3RyaWRlc1swXSksYT1jb252T3V0cHV0TGVuZ3RoKG4sdGhpcy5rZXJuZWxTaXplWzFdLHRoaXMucGFkZGluZyx0aGlzLnN0cmlkZXNbMV0pO3JldHVyblwiY2hhbm5lbHNGaXJzdFwiPT09dGhpcy5kYXRhRm9ybWF0P1tlWzBdLHIsaSxhXTpbZVswXSxpLGEscl19LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciB0PWUucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiB0LmRlcHRoTXVsdGlwbGllcj10aGlzLmRlcHRoTXVsdGlwbGllcix0LmRlcHRod2lzZUluaXRpYWxpemVyPXNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMuZGVwdGh3aXNlSW5pdGlhbGl6ZXIpLHQuZGVwdGh3aXNlUmVndWxhcml6ZXI9c2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5kZXB0aHdpc2VSZWd1bGFyaXplciksdC5kZXB0aHdpc2VDb25zdHJhaW50PXNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5kZXB0aHdpc2VSZWd1bGFyaXplciksdH0sdC5jbGFzc05hbWU9XCJEZXB0aHdpc2VDb252MkRcIix0fShCYXNlQ29udik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKERlcHRod2lzZUNvbnYyRCk7dmFyIERyb3BvdXQ9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyx0KXx8dGhpcztpZihuLnJhdGU9TWF0aC5tYXgoTWF0aC5taW4odC5yYXRlLDEpLDApLG4ucmF0ZVNjYWxhcj1nZXRTY2FsYXIobi5yYXRlKSxuLm5vaXNlU2hhcGU9dC5ub2lzZVNoYXBlLG4uc2VlZD10LnNlZWQsbnVsbCE9bi5zZWVkKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwiTm9uLWRlZmF1bHQgc2VlZCBpcyBub3QgaW1wbGVtZW50ZWQgaW4gRHJvcG91dCBsYXllciB5ZXQ6IFwiK24uc2VlZCk7cmV0dXJuIG4uc3VwcG9ydHNNYXNraW5nPSEwLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmdldE5vaXNlU2hhcGU9ZnVuY3Rpb24oZSl7aWYobnVsbD09dGhpcy5ub2lzZVNoYXBlKXJldHVybiB0aGlzLm5vaXNlU2hhcGU7Zm9yKHZhciB0PWUuc2hhcGUsbj1bXSxyPTA7cjx0aGlzLm5vaXNlU2hhcGUubGVuZ3RoOysrciluLnB1c2gobnVsbD09dGhpcy5ub2lzZVNoYXBlW3JdP3Rbcl06dGhpcy5ub2lzZVNoYXBlW3JdKTtyZXR1cm4gbn0sdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtuLmludm9rZUNhbGxIb29rKGUsdCk7dmFyIHI9Z2V0RXhhY3RseU9uZVRlbnNvcihlKTtpZihudWxsIT1uLm5vaXNlU2hhcGUmJiF1dGlsLmFycmF5c0VxdWFsKHIuc2hhcGUsbi5ub2lzZVNoYXBlKSl0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcIk5vbi1kZWZhdWx0IG5vaXNlIHNoYXBlIGlzIG5vdCBpbXBsZW1lbnRlZCBpbiBEcm9wb3V0IGxheWVyIHlldDogXCIrSlNPTi5zdHJpbmdpZnkobi5ub2lzZVNoYXBlKSk7aWYoMDxuLnJhdGUmJm4ucmF0ZTwxKXt2YXIgaT1udWxsIT10LnRyYWluaW5nJiZ0LnRyYWluaW5nLGE9bi5nZXROb2lzZVNoYXBlKHIpO3JldHVybiBpblRyYWluUGhhc2UoZnVuY3Rpb24oKXtyZXR1cm4gZHJvcG91dChyLG4ucmF0ZVNjYWxhcixhLG4uc2VlZCl9LGZ1bmN0aW9uKCl7cmV0dXJuIHJ9LGkpfXJldHVybiBlfSl9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciB0PXtyYXRlOnRoaXMucmF0ZSxub2lzZVNoYXBlOnRoaXMubm9pc2VTaGFwZSxzZWVkOnRoaXMuc2VlZH0sbj1lLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gT2JqZWN0LmFzc2lnbih0LG4pLHR9LHQuY2xhc3NOYW1lPVwiRHJvcG91dFwiLHR9KExheWVyKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoRHJvcG91dCk7dmFyIERlbnNlPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49ZS5jYWxsKHRoaXMsdCl8fHRoaXM7aWYobi5hY3RpdmF0aW9uPW51bGwsbi51c2VCaWFzPSEwLG4ua2VybmVsPW51bGwsbi5iaWFzPW51bGwsbi5ERUZBVUxUX0tFUk5FTF9JTklUSUFMSVpFUj1cImdsb3JvdE5vcm1hbFwiLG4uREVGQVVMVF9CSUFTX0lOSVRJQUxJWkVSPVwiemVyb3NcIixudWxsPT10LmJhdGNoSW5wdXRTaGFwZSYmbnVsbD09dC5pbnB1dFNoYXBlJiZudWxsIT10LmlucHV0RGltKXt2YXIgcj1udWxsO251bGwhPXQuYmF0Y2hTaXplJiYocj10LmJhdGNoU2l6ZSksbi5iYXRjaElucHV0U2hhcGU9W3IsdC5pbnB1dERpbV19cmV0dXJuIG4udW5pdHM9dC51bml0cyxuLmFjdGl2YXRpb249Z2V0QWN0aXZhdGlvbih0LmFjdGl2YXRpb24pLG51bGwhPXQudXNlQmlhcyYmKG4udXNlQmlhcz10LnVzZUJpYXMpLG4ua2VybmVsSW5pdGlhbGl6ZXI9Z2V0SW5pdGlhbGl6ZXIodC5rZXJuZWxJbml0aWFsaXplcnx8bi5ERUZBVUxUX0tFUk5FTF9JTklUSUFMSVpFUiksbi5iaWFzSW5pdGlhbGl6ZXI9Z2V0SW5pdGlhbGl6ZXIodC5iaWFzSW5pdGlhbGl6ZXJ8fG4uREVGQVVMVF9CSUFTX0lOSVRJQUxJWkVSKSxuLmtlcm5lbENvbnN0cmFpbnQ9Z2V0Q29uc3RyYWludCh0Lmtlcm5lbENvbnN0cmFpbnQpLG4uYmlhc0NvbnN0cmFpbnQ9Z2V0Q29uc3RyYWludCh0LmJpYXNDb25zdHJhaW50KSxuLmtlcm5lbFJlZ3VsYXJpemVyPWdldFJlZ3VsYXJpemVyKHQua2VybmVsUmVndWxhcml6ZXIpLG4uYmlhc1JlZ3VsYXJpemVyPWdldFJlZ3VsYXJpemVyKHQuYmlhc1JlZ3VsYXJpemVyKSxuLmFjdGl2aXR5UmVndWxhcml6ZXI9Z2V0UmVndWxhcml6ZXIodC5hY3Rpdml0eVJlZ3VsYXJpemVyKSxuLmlucHV0U3BlYz1be21pbk5EaW06Mn1dLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmJ1aWxkPWZ1bmN0aW9uKGUpe3ZhciB0LG49KGU9Z2V0RXhhY3RseU9uZVNoYXBlKGUpKVtlLmxlbmd0aC0xXTtudWxsPT10aGlzLmtlcm5lbCYmKHRoaXMua2VybmVsPXRoaXMuYWRkV2VpZ2h0KFwia2VybmVsXCIsW24sdGhpcy51bml0c10sbnVsbCx0aGlzLmtlcm5lbEluaXRpYWxpemVyLHRoaXMua2VybmVsUmVndWxhcml6ZXIsITAsdGhpcy5rZXJuZWxDb25zdHJhaW50KSx0aGlzLnVzZUJpYXMmJih0aGlzLmJpYXM9dGhpcy5hZGRXZWlnaHQoXCJiaWFzXCIsW3RoaXMudW5pdHNdLG51bGwsdGhpcy5iaWFzSW5pdGlhbGl6ZXIsdGhpcy5iaWFzUmVndWxhcml6ZXIsITAsdGhpcy5iaWFzQ29uc3RyYWludCkpKSx0aGlzLmlucHV0U3BlYz1be21pbk5EaW06MixheGVzOih0PXt9LHRbLTFdPW4sdCl9XSx0aGlzLmJ1aWx0PSEwfSx0LnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGU9ZnVuY3Rpb24oZSl7dmFyIHQ9KGU9Z2V0RXhhY3RseU9uZVNoYXBlKGUpKS5zbGljZSgpO3JldHVybiB0W3QubGVuZ3RoLTFdPXRoaXMudW5pdHMsdH0sdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtuLmludm9rZUNhbGxIb29rKGUsdCk7dmFyIHI9ZG90KGdldEV4YWN0bHlPbmVUZW5zb3IoZSksbi5rZXJuZWwucmVhZCgpKTtyZXR1cm4gbnVsbCE9bi5iaWFzJiYocj1iaWFzQWRkKHIsbi5iaWFzLnJlYWQoKSkpLG51bGwhPW4uYWN0aXZhdGlvbiYmKHI9bi5hY3RpdmF0aW9uLmFwcGx5KHIpKSxyfSl9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciB0PXt1bml0czp0aGlzLnVuaXRzLGFjdGl2YXRpb246c2VyaWFsaXplQWN0aXZhdGlvbih0aGlzLmFjdGl2YXRpb24pLHVzZUJpYXM6dGhpcy51c2VCaWFzLGtlcm5lbEluaXRpYWxpemVyOnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMua2VybmVsSW5pdGlhbGl6ZXIpLGJpYXNJbml0aWFsaXplcjpzZXJpYWxpemVJbml0aWFsaXplcih0aGlzLmJpYXNJbml0aWFsaXplciksa2VybmVsUmVndWxhcml6ZXI6c2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5rZXJuZWxSZWd1bGFyaXplciksYmlhc1JlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYmlhc1JlZ3VsYXJpemVyKSxhY3Rpdml0eVJlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYWN0aXZpdHlSZWd1bGFyaXplciksa2VybmVsQ29uc3RyYWludDpzZXJpYWxpemVDb25zdHJhaW50KHRoaXMua2VybmVsQ29uc3RyYWludCksYmlhc0NvbnN0cmFpbnQ6c2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmJpYXNDb25zdHJhaW50KX0sbj1lLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gT2JqZWN0LmFzc2lnbih0LG4pLHR9LHQuY2xhc3NOYW1lPVwiRGVuc2VcIix0fShMYXllcik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKERlbnNlKTt2YXIgRmxhdHRlbj1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzLHR8fHt9KXx8dGhpcztyZXR1cm4gbi5pbnB1dFNwZWM9W3ttaW5ORGltOjN9XSxufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGU9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PTAsbj0oZT1nZXRFeGFjdGx5T25lU2hhcGUoZSkpLnNsaWNlKDEpO3Q8bi5sZW5ndGg7dCsrKXtpZihudWxsPT1uW3RdKXRocm93IG5ldyBWYWx1ZUVycm9yKCdUaGUgc2hhcGUgb2YgdGhlIGlucHV0IHRvIFwiRmxhdHRlblwiIGlzIG5vdCBmdWxseSBkZWZpbmVkIChnb3QgJytlLnNsaWNlKDEpKycpLiBNYWtlIHN1cmUgdG8gcGFzcyBhIGNvbXBsZXRlIFwiaW5wdXRfc2hhcGVcIiBvciBcImJhdGNoX2lucHV0X3NoYXBlXCIgYXJndW1lbnQgdG8gdGhlIGZpcnN0IGxheWVyIGluIHlvdXIgbW9kZWwuJyl9cmV0dXJuW2VbMF0sYXJyYXlQcm9kKGUsMSldfSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe3JldHVybiBuLmludm9rZUNhbGxIb29rKGUsdCksYmF0Y2hGbGF0dGVuKGdldEV4YWN0bHlPbmVUZW5zb3IoZSkpfSl9LHQuY2xhc3NOYW1lPVwiRmxhdHRlblwiLHR9KExheWVyKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoRmxhdHRlbik7dmFyIEFjdGl2YXRpb24kMT1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzLHQpfHx0aGlzO3JldHVybiBuLnN1cHBvcnRzTWFza2luZz0hMCxuLmFjdGl2YXRpb249Z2V0QWN0aXZhdGlvbih0LmFjdGl2YXRpb24pLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7bi5pbnZva2VDYWxsSG9vayhlLHQpO3ZhciByPWdldEV4YWN0bHlPbmVUZW5zb3IoZSk7cmV0dXJuIG4uYWN0aXZhdGlvbi5hcHBseShyKX0pfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD17YWN0aXZhdGlvbjpzZXJpYWxpemVBY3RpdmF0aW9uKHRoaXMuYWN0aXZhdGlvbil9LG49ZS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIE9iamVjdC5hc3NpZ24odCxuKSx0fSx0LmNsYXNzTmFtZT1cIkFjdGl2YXRpb25cIix0fShMYXllcik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKEFjdGl2YXRpb24kMSk7dmFyIFJlcGVhdFZlY3Rvcj1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzLHQpfHx0aGlzO3JldHVybiBuLm49dC5uLG4uaW5wdXRTcGVjPVt7bmRpbToyfV0sbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlPWZ1bmN0aW9uKGUpe3JldHVybltlWzBdLHRoaXMubixlWzFdXX0sdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtyZXR1cm4gcmVwZWF0KGU9Z2V0RXhhY3RseU9uZVRlbnNvcihlKSxuLm4pfSl9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciB0PXtuOnRoaXMubn0sbj1lLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gT2JqZWN0LmFzc2lnbih0LG4pLHR9LHQuY2xhc3NOYW1lPVwiUmVwZWF0VmVjdG9yXCIsdH0oTGF5ZXIpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhSZXBlYXRWZWN0b3IpO3ZhciBSZXNoYXBlPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49ZS5jYWxsKHRoaXMsdCl8fHRoaXM7bi50YXJnZXRTaGFwZT10LnRhcmdldFNoYXBlO2Zvcih2YXIgcj0wO3I8bi50YXJnZXRTaGFwZS5sZW5ndGg7KytyKW4uaXNVbmtub3duKG4udGFyZ2V0U2hhcGVbcl0pJiYobi50YXJnZXRTaGFwZVtyXT1udWxsKTtyZXR1cm4gbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuaXNVbmtub3duPWZ1bmN0aW9uKGUpe3JldHVybiBlPDB8fG51bGw9PWV9LHQucHJvdG90eXBlLmZpeFVua25vd25EaW1lbnNpb249ZnVuY3Rpb24oZSx0KXtmb3IodmFyIG49XCJUb3RhbCBzaXplIG9mIG5ldyBhcnJheSBtdXN0IGJlIHVuY2hhbmdlZC5cIixyPXQuc2xpY2UoKSxpPTEsYT1udWxsLG89MDtvPHIubGVuZ3RoOysrbyl7dmFyIHM9cltvXTtpZih0aGlzLmlzVW5rbm93bihzKSl7aWYobnVsbCE9PWEpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJDYW4gb25seSBzcGVjaWZpeSBvbmUgdW5rbm93biBkaW1lbnNpb24uXCIpO2E9b31lbHNlIGkqPXN9dmFyIGw9YXJyYXlQcm9kKGUpO2lmKG51bGwhPT1hKXtpZigwPT09aXx8bCVpIT0wKXRocm93IG5ldyBWYWx1ZUVycm9yKG4pO3JbYV09bC9pfWVsc2UgaWYobCE9PWkpdGhyb3cgbmV3IFZhbHVlRXJyb3Iobik7cmV0dXJuIHJ9LHQucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZT1mdW5jdGlvbihlKXtmb3IodmFyIHQ9ITEsbj0wO248ZS5sZW5ndGg7KytuKWlmKHRoaXMuaXNVbmtub3duKGVbbl0pKXt0PSEwO2JyZWFrfXJldHVybiB0P2Uuc2xpY2UoMCwxKS5jb25jYXQodGhpcy50YXJnZXRTaGFwZSk6ZS5zbGljZSgwLDEpLmNvbmNhdCh0aGlzLmZpeFVua25vd25EaW1lbnNpb24oZS5zbGljZSgxKSx0aGlzLnRhcmdldFNoYXBlKSl9LHQucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7bi5pbnZva2VDYWxsSG9vayhlLHQpO3ZhciByPWdldEV4YWN0bHlPbmVUZW5zb3IoZSksaT1yLnNoYXBlLGE9aS5zbGljZSgwLDEpLmNvbmNhdChuLmZpeFVua25vd25EaW1lbnNpb24oaS5zbGljZSgxKSxuLnRhcmdldFNoYXBlKSk7cmV0dXJuIHIucmVzaGFwZShhKX0pfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD17dGFyZ2V0U2hhcGU6dGhpcy50YXJnZXRTaGFwZX0sbj1lLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gT2JqZWN0LmFzc2lnbih0LG4pLHR9LHQuY2xhc3NOYW1lPVwiUmVzaGFwZVwiLHR9KExheWVyKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoUmVzaGFwZSk7dmFyIFBlcm11dGU9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyx0KXx8dGhpcztpZihudWxsPT10LmRpbXMpdGhyb3cgbmV3IEVycm9yKFwiUmVxdWlyZWQgY29uZmlndXJhdGlvbiBmaWVsZCBgZGltc2AgaXMgbWlzc2luZyBkdXJpbmcgUGVybXV0ZSBjb25zdHJ1Y3RvciBjYWxsLlwiKTtpZighQXJyYXkuaXNBcnJheSh0LmRpbXMpKXRocm93IG5ldyBFcnJvcihcIlBlcm11dGUgY29uc3RydWN0b3IgcmVxdWlyZXMgYGRpbXNgIHRvIGJlIGFuIEFycmF5LCBidXQgcmVjZWl2ZWQgXCIrdC5kaW1zK1wiIGluc3RlYWQuXCIpO3ZhciByPXJhbmdlKDEsdC5kaW1zLmxlbmd0aCsxKTtpZighdXRpbC5hcnJheXNFcXVhbCh0LmRpbXMuc2xpY2UoKS5zb3J0KCkscikpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwZXJtdXRhdGlvbiBgZGltc2A6IFwiK0pTT04uc3RyaW5naWZ5KHQuZGltcykrXCIgYGRpbXNgIG11c3QgY29udGFpbiBjb25zZWN1dGl2ZSBpbnRlZ2VycyBzdGFydGluZyBmcm9tIDEuXCIpO3JldHVybiBuLmRpbXM9dC5kaW1zLG4uZGltc0luY2x1ZGluZ0JhdGNoPVswXS5jb25jYXQobi5kaW1zKSxuLmlucHV0U3BlYz1bbmV3IElucHV0U3BlYyh7bmRpbTpuLmRpbXMubGVuZ3RoKzF9KV0sbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlPWZ1bmN0aW9uKGUpe3ZhciB0PShlPWdldEV4YWN0bHlPbmVTaGFwZShlKSkuc2xpY2UoKTtyZXR1cm4gdGhpcy5kaW1zLmZvckVhY2goZnVuY3Rpb24obixyKXt0W3IrMV09ZVtuXX0pLHR9LHQucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdHJhbnNwb3NlKGdldEV4YWN0bHlPbmVUZW5zb3IoZSksdGhpcy5kaW1zSW5jbHVkaW5nQmF0Y2gpfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD17ZGltczp0aGlzLmRpbXN9LG49ZS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIE9iamVjdC5hc3NpZ24odCxuKSx0fSx0LmNsYXNzTmFtZT1cIlBlcm11dGVcIix0fShMYXllcik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKFBlcm11dGUpO3ZhciBFbWJlZGRpbmc9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyx0KXx8dGhpcztpZihuLmVtYmVkZGluZ3M9bnVsbCxuLkRFRkFVTFRfRU1CRURESU5HU19JTklUSUFMSVpFUj1cInJhbmRvbVVuaWZvcm1cIixudWxsPT10LmJhdGNoSW5wdXRTaGFwZSYmbnVsbD09dC5pbnB1dFNoYXBlKXt2YXIgcj1udWxsO251bGwhPXQuYmF0Y2hTaXplJiYocj10LmJhdGNoU2l6ZSksbnVsbD09dC5pbnB1dExlbmd0aD9uLmJhdGNoSW5wdXRTaGFwZT1bcixudWxsXTpuLmJhdGNoSW5wdXRTaGFwZT1bcl0uY29uY2F0KHRvTGlzdCh0LmlucHV0TGVuZ3RoKSl9cmV0dXJuIG4uaW5wdXREaW09dC5pbnB1dERpbSxuLm91dHB1dERpbT10Lm91dHB1dERpbSxuLmVtYmVkZGluZ3NJbml0aWFsaXplcj1nZXRJbml0aWFsaXplcih0LmVtYmVkZGluZ3NJbml0aWFsaXplcnx8bi5ERUZBVUxUX0VNQkVERElOR1NfSU5JVElBTElaRVIpLG4uZW1iZWRkaW5nc1JlZ3VsYXJpemVyPWdldFJlZ3VsYXJpemVyKHQuZW1iZWRkaW5nc1JlZ3VsYXJpemVyKSxuLmFjdGl2aXR5UmVndWxhcml6ZXI9Z2V0UmVndWxhcml6ZXIodC5hY3Rpdml0eVJlZ3VsYXJpemVyKSxuLmVtYmVkZGluZ3NDb25zdHJhaW50PWdldENvbnN0cmFpbnQodC5lbWJlZGRpbmdzQ29uc3RyYWludCksbi5tYXNrWmVybz10Lm1hc2taZXJvLG4uaW5wdXRMZW5ndGg9dC5pbnB1dExlbmd0aCxufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5idWlsZD1mdW5jdGlvbihlKXt0aGlzLmVtYmVkZGluZ3M9dGhpcy5hZGRXZWlnaHQoXCJlbWJlZGRpbmdzXCIsW3RoaXMuaW5wdXREaW0sdGhpcy5vdXRwdXREaW1dLHRoaXMuZHR5cGUsdGhpcy5lbWJlZGRpbmdzSW5pdGlhbGl6ZXIsdGhpcy5lbWJlZGRpbmdzUmVndWxhcml6ZXIsITAsdGhpcy5lbWJlZGRpbmdzQ29uc3RyYWludCksdGhpcy5idWlsdD0hMH0sdC5wcm90b3R5cGUud2Fybk9uSW5jb21wYXRpYmxlSW5wdXRTaGFwZT1mdW5jdGlvbihlKXt9LHQucHJvdG90eXBlLmNvbXB1dGVNYXNrPWZ1bmN0aW9uKGUsdCl7dGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJjb21wdXRlTWFzayBoYXMgbm90IGJlZW4gaW1wbGVtZW50ZWQgZm9yIEVtYmVkZGluZyB5ZXRcIil9LHQucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZT1mdW5jdGlvbihlKXtpZihlPWdldEV4YWN0bHlPbmVTaGFwZShlKSxudWxsPT10aGlzLmlucHV0TGVuZ3RoKXJldHVybiBlLmNvbmNhdChbdGhpcy5vdXRwdXREaW1dKTt2YXIgdD10b0xpc3QodGhpcy5pbnB1dExlbmd0aCk7aWYodC5sZW5ndGghPT1lLmxlbmd0aC0xKXRocm93IG5ldyBWYWx1ZUVycm9yKCdcImlucHV0TGVuZ3RoXCIgaXMgJyt0aGlzLmlucHV0TGVuZ3RoK1wiLCBidXQgcmVjZWl2ZWQgaW5wdXQgc2hhcGUgaGFzIHNoYXBlIFwiK2UpO2Zvcih2YXIgbj0wLHI9MDtyPHQubGVuZ3RoOysrcil7dmFyIGk9dFtyXSxhPWVbcisxXTtpZihudWxsIT1pJiZudWxsIT1hJiZpIT09YSl0aHJvdyBuZXcgVmFsdWVFcnJvcignXCJpbnB1dExlbmd0aFwiIGlzICcrdGhpcy5pbnB1dExlbmd0aCtcIiwgYnV0IHJlY2VpdmVkIGlucHV0IHNoYXBlIGhhcyBzaGFwZSBcIitlKTtudWxsPT1pJiYodFtuXT1hKSxuKyt9cmV0dXJuW2VbMF1dLmNvbmNhdCh0LFt0aGlzLm91dHB1dERpbV0pfSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe24uaW52b2tlQ2FsbEhvb2soZSx0KTt2YXIgcj1nZXRFeGFjdGx5T25lVGVuc29yKGUpO3JldHVyblwiaW50MzJcIiE9PXIuZHR5cGUmJihyPWNhc3QkMShyLFwiaW50MzJcIikpLGdhdGhlciQxKG4uZW1iZWRkaW5ncy5yZWFkKCksci5hczFEKCkpLnJlc2hhcGUoZ2V0RXhhY3RseU9uZVNoYXBlKG4uY29tcHV0ZU91dHB1dFNoYXBlKHIuc2hhcGUpKSl9KX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIHQ9e2lucHV0RGltOnRoaXMuaW5wdXREaW0sb3V0cHV0RGltOnRoaXMub3V0cHV0RGltLGVtYmVkZGluZ3NJbml0aWFsaXplcjpzZXJpYWxpemVJbml0aWFsaXplcih0aGlzLmVtYmVkZGluZ3NJbml0aWFsaXplciksZW1iZWRkaW5nc1JlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuZW1iZWRkaW5nc1JlZ3VsYXJpemVyKSxhY3Rpdml0eVJlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYWN0aXZpdHlSZWd1bGFyaXplciksZW1iZWRkaW5nc0NvbnN0cmFpbnQ6c2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmVtYmVkZGluZ3NDb25zdHJhaW50KSxtYXNrWmVybzp0aGlzLm1hc2taZXJvLGlucHV0TGVuZ3RoOnRoaXMuaW5wdXRMZW5ndGh9LG49ZS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIE9iamVjdC5hc3NpZ24odCxuKSx0fSx0LmNsYXNzTmFtZT1cIkVtYmVkZGluZ1wiLHR9KExheWVyKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoRW1iZWRkaW5nKTt2YXIgTWVyZ2U9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyx0fHx7fSl8fHRoaXM7cmV0dXJuIG4uc3VwcG9ydHNNYXNraW5nPSEwLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLm1lcmdlRnVuY3Rpb249ZnVuY3Rpb24oZSl7dGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3J9LHQucHJvdG90eXBlLmNvbXB1dGVFbGVtZW50d2lzZU9wT3V0cHV0U2hhcGU9ZnVuY3Rpb24oZSx0KXtpZihudWxsPT1lfHxudWxsPT10KXJldHVybiBudWxsO2lmKGUubGVuZ3RoPHQubGVuZ3RoKXJldHVybiB0aGlzLmNvbXB1dGVFbGVtZW50d2lzZU9wT3V0cHV0U2hhcGUodCxlKTtpZigwPT09dC5sZW5ndGgpcmV0dXJuIGU7Zm9yKHZhciBuPWUuc2xpY2UoMCxlLmxlbmd0aC10Lmxlbmd0aCkscj0wO3I8dC5sZW5ndGg7KytyKXt2YXIgaT1lW2UubGVuZ3RoLXQubGVuZ3RoK3JdLGE9dFtyXTtpZihudWxsPT1pfHxudWxsPT1hfHxpPDB8fGE8MCluLnB1c2gobnVsbCk7ZWxzZSBpZigxPT09aSluLnB1c2goYSk7ZWxzZSBpZigxPT09YSluLnB1c2goaSk7ZWxzZXtpZihpIT09YSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIk9wZXJhbmRzIGNvdWxkIG5vdCBiZSBicm9hZGNhc3QgdG9nZXRoZXIgd2l0aCBzaGFwZXMgXCIrSlNPTi5zdHJpbmdpZnkoZSkrXCIgXCIrSlNPTi5zdHJpbmdpZnkodCkpO24ucHVzaChpKX19cmV0dXJuIG59LHQucHJvdG90eXBlLmJ1aWxkPWZ1bmN0aW9uKGUpe2lmKEFycmF5LmlzQXJyYXkoZSkmJiFBcnJheS5pc0FycmF5KGVbMF0pJiYoZT1bZ2V0RXhhY3RseU9uZVNoYXBlKGUpXSksKGU9ZSkubGVuZ3RoPDIpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJBIG1lcmdlIGxheWVyIHNob3VsZCBiZSBjYWxsZWQgb24gYW4gQXJyYXkgb2YgYXQgbGVhc3QgMiBpbnB1dHMuIEdvdCBcIitlLmxlbmd0aCtcIiBpbnB1dChzKS5cIik7Zm9yKHZhciB0PVtdLG49MCxyPWU7bjxyLmxlbmd0aDtuKyspe251bGwhPShvPXJbbl0pJiZudWxsIT09b1swXSYmdC5wdXNoKG9bMF0pfWlmKCh0PXVuaXF1ZSh0KSkubGVuZ3RoPjEpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJDYW4gbm90IG1lcmdlIHRlbnNvcnMgd2l0aCBkaWZmZXJlbnQgYmF0Y2ggc2l6ZXMuIEdvdCB0ZW5zb3JzIHdpdGggc2hhcGVzOiBcIitKU09OLnN0cmluZ2lmeShlKStcIi5cIik7Zm9yKHZhciBpPW51bGw9PWVbMF0/bnVsbDplWzBdLnNsaWNlKDEpLGE9MTthPGUubGVuZ3RoOysrYSl7dmFyIG89bnVsbD09ZVthXT9udWxsOmVbYV0uc2xpY2UoMSk7aT10aGlzLmNvbXB1dGVFbGVtZW50d2lzZU9wT3V0cHV0U2hhcGUoaSxvKX12YXIgcz1lLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5sZW5ndGh9KTstMT09PWUuaW5kZXhPZihudWxsKSYmMT09PXVuaXF1ZShzKS5sZW5ndGg/dGhpcy5yZXNoYXBlUmVxdWlyZWQ9ITE6dGhpcy5yZXNoYXBlUmVxdWlyZWQ9ITB9LHQucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7aWYoZT1lLG4ucmVzaGFwZVJlcXVpcmVkKXt2YXIgdD1bXSxyPWUubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLnJhbmt9KTtpZigtMT09PXIuaW5kZXhPZihudWxsKSl7Zm9yKHZhciBpPW1heCQxKHIpLGE9MCxvPWU7YTxvLmxlbmd0aDthKyspe2Zvcih2YXIgcz0oaD1vW2FdKS5yYW5rLGw9MDtsPGktczsrK2wpaD1leHBhbmREaW1zKGgsMSk7dC5wdXNoKGgpfXJldHVybiBuLm1lcmdlRnVuY3Rpb24odCl9Zm9yKHZhciB1PSExLGM9MCxwPWU7YzxwLmxlbmd0aDtjKyspe3ZhciBoO2lmKG51bGw9PShzPShoPXBbY10pLnJhbmspKXt2YXIgZD1oLnNoYXBlLGY9ZFswXSxnPWQuc2xpY2UoMSkuY29uY2F0KFtmXSksbT1oLnJlc2hhcGUoW2ZdLmNvbmNhdChhcnJheVByb2QoZC5zbGljZSgxKSkpKTttPShtPXRyYW5zcG9zZShtLFsxLDBdKSkucmVzaGFwZShnKSx0LnB1c2gobSksdT0hMH1lbHNlIGlmKHM+MSl7dmFyIHk9cmFuZ2UoMSxzKS5jb25jYXQoWzBdKTt0LnB1c2godHJhbnNwb3NlKGgseSkpLHU9ITB9ZWxzZSB0LnB1c2goaCl9dmFyIHY9bi5tZXJnZUZ1bmN0aW9uKHQpLGI9di5yYW5rO2lmKHUpaWYobnVsbD09Yil7dmFyIHc9di5zaGFwZTtnPVtmPXdbdy5sZW5ndGgtMV1dLmNvbmNhdCh3LnNsaWNlKDAsdy5sZW5ndGgtMSkpO3Y9dHJhbnNwb3NlKHYucmVzaGFwZShbLTEsZl0pLFsxLDBdKS5yZXNoYXBlKGcpfWVsc2UgaWYoYj4xKXt5PVtiLTFdLmNvbmNhdChyYW5nZSgwLGItMSkpO3Y9dHJhbnNwb3NlKHYseSl9cmV0dXJuIHZ9cmV0dXJuIG4ubWVyZ2VGdW5jdGlvbihlKX0pfSx0LnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGU9ZnVuY3Rpb24oZSl7dmFyIHQ7dD1udWxsPT0oZT1lKVswXT9udWxsOmVbMF0uc2xpY2UoMSk7Zm9yKHZhciBuPTE7bjxlLmxlbmd0aDsrK24pe3ZhciByPW51bGw9PWVbbl0/bnVsbDplW25dLnNsaWNlKDEpO3Q9dGhpcy5jb21wdXRlRWxlbWVudHdpc2VPcE91dHB1dFNoYXBlKHQscil9Zm9yKHZhciBpPVtdLGE9MCxvPWU7YTxvLmxlbmd0aDthKyspe251bGwhPShyPW9bYV0pJiZudWxsIT09clswXSYmaS5wdXNoKHJbMF0pfXJldHVybiB0PTE9PT0oaT11bmlxdWUoaSkpLmxlbmd0aD9pLmNvbmNhdCh0KTpbbnVsbF0uY29uY2F0KHQpfSx0LnByb3RvdHlwZS5jb21wdXRlTWFzaz1mdW5jdGlvbihlLHQpe3Rocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwiY29tcHV0ZU1hc2sgaGFzIG5vdCBiZWVuIGltcGxlbWVudGVkIGZvciBNZXJnZSB5ZXRcIil9LHR9KExheWVyKSxBZGQ9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXtyZXR1cm4gZS5jYWxsKHRoaXMsdCl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLm1lcmdlRnVuY3Rpb249ZnVuY3Rpb24oZSl7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtmb3IodmFyIHQ9ZVswXS5jbG9uZSgpLG49MTtuPGUubGVuZ3RoOysrbil0PWFkZCh0LGVbbl0pO3JldHVybiB0fSl9LHQuY2xhc3NOYW1lPVwiQWRkXCIsdH0oTWVyZ2UpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhBZGQpO3ZhciBNdWx0aXBseT1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3JldHVybiBlLmNhbGwodGhpcyx0KXx8dGhpc31yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUubWVyZ2VGdW5jdGlvbj1mdW5jdGlvbihlKXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe2Zvcih2YXIgdD1lWzBdLmNsb25lKCksbj0xO248ZS5sZW5ndGg7KytuKXQ9bXVsKHQsZVtuXSk7cmV0dXJuIHR9KX0sdC5jbGFzc05hbWU9XCJNdWx0aXBseVwiLHR9KE1lcmdlKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoTXVsdGlwbHkpO3ZhciBBdmVyYWdlPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7cmV0dXJuIGUuY2FsbCh0aGlzLHQpfHx0aGlzfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5tZXJnZUZ1bmN0aW9uPWZ1bmN0aW9uKGUpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7Zm9yKHZhciB0PWVbMF0uY2xvbmUoKSxuPTE7bjxlLmxlbmd0aDsrK24pdD1hZGQodCxlW25dKTtyZXR1cm4gbXVsKGdldFNjYWxhcigxL2UubGVuZ3RoKSx0KX0pfSx0LmNsYXNzTmFtZT1cIkF2ZXJhZ2VcIix0fShNZXJnZSk7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKEF2ZXJhZ2UpO3ZhciBNYXhpbXVtPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7cmV0dXJuIGUuY2FsbCh0aGlzLHQpfHx0aGlzfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5tZXJnZUZ1bmN0aW9uPWZ1bmN0aW9uKGUpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7Zm9yKHZhciB0PWVbMF0sbj0xO248ZS5sZW5ndGg7KytuKXQ9bWF4aW11bSh0LGVbbl0pO3JldHVybiB0fSl9LHQuY2xhc3NOYW1lPVwiTWF4aW11bVwiLHR9KE1lcmdlKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoTWF4aW11bSk7dmFyIE1pbmltdW09ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXtyZXR1cm4gZS5jYWxsKHRoaXMsdCl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLm1lcmdlRnVuY3Rpb249ZnVuY3Rpb24oZSl7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtmb3IodmFyIHQ9ZVswXSxuPTE7bjxlLmxlbmd0aDsrK24pdD1taW5pbXVtKHQsZVtuXSk7cmV0dXJuIHR9KX0sdC5jbGFzc05hbWU9XCJNaW5pbXVtXCIsdH0oTWVyZ2UpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhNaW5pbXVtKTt2YXIgQ29uY2F0ZW5hdGU9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyx0KXx8dGhpcztyZXR1cm4gbi5ERUZBVUxUX0FYSVM9LTEsbnVsbD09dCYmKHQ9e30pLG4uYXhpcz1udWxsPT10LmF4aXM/bi5ERUZBVUxUX0FYSVM6dC5heGlzLG4uc3VwcG9ydHNNYXNraW5nPSEwLG4ucmVzaGFwZVJlcXVpcmVkPSExLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmJ1aWxkPWZ1bmN0aW9uKGUpe2lmKCFBcnJheS5pc0FycmF5KGUpfHwhQXJyYXkuaXNBcnJheShlWzBdKXx8MT09PWUubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiQSBgQ29uY2F0ZW5hdGVgIGxheWVyIHNob3VsZCBiZSBjYWxsZWQgb24gYSBsaXN0IG9mIGF0IGxlYXN0IDIgaW5wdXRzXCIpO2Zvcih2YXIgdD0hMCxuPTAscj1lPWU7bjxyLmxlbmd0aDtuKyspe2lmKG51bGwhPShjPXJbbl0pKXt0PSExO2JyZWFrfX1pZighdCl7Zm9yKHZhciBpPVtdLGE9MDthPGUubGVuZ3RoOysrYSl7dmFyIG89ZVthXS5zbGljZSgpO28uc3BsaWNlKHRoaXMuYXhpcywxKTtmb3IodmFyIHM9ITEsbD0wLHU9aTtsPHUubGVuZ3RoO2wrKyl7dmFyIGM9dVtsXTtpZih1dGlsLmFycmF5c0VxdWFsKGMsbykpe3M9ITA7YnJlYWt9fXN8fGkucHVzaChvKX1pZihpLmxlbmd0aD4xKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiQSBgQ29uY2F0ZW5hdGVgIGxheWVyIHJlcXVpcmVzIGlucHV0cyB3aXRoIG1hdGNoaW5nIHNoYXBlcyBleGNlcHQgZm9yIHRoZSBjb25jYXQgYXhpcy4gR290IGlucHV0IHNoYXBlczogXCIrSlNPTi5zdHJpbmdpZnkoZSkpfX0sdC5wcm90b3R5cGUubWVyZ2VGdW5jdGlvbj1mdW5jdGlvbihlKXt2YXIgdD10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7cmV0dXJuIGNvbmNhdGVuYXRlKGUsdC5heGlzKX0pfSx0LnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGU9ZnVuY3Rpb24oZSl7aWYoIUFycmF5LmlzQXJyYXkoZSl8fCFBcnJheS5pc0FycmF5KGVbMF0pKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiQSBgQ29uY2F0ZW5hdGVgIGxheWVyIHNob3VsZCBiZSBjYWxsZWQgb24gYSBsaXN0IG9mIGlucHV0cy5cIik7Zm9yKHZhciB0PWUsbj10WzBdLnNsaWNlKCkscj10aGlzLmF4aXM8MD9uLmxlbmd0aCt0aGlzLmF4aXM6dGhpcy5heGlzLGk9MCxhPXQuc2xpY2UoMSk7aTxhLmxlbmd0aDtpKyspe3ZhciBvPWFbaV07aWYobnVsbD09bltyXXx8bnVsbD09b1tyXSl7bltyXT1udWxsO2JyZWFrfW5bcl0rPW9bcl19cmV0dXJuIG59LHQucHJvdG90eXBlLmNvbXB1dGVNYXNrPWZ1bmN0aW9uKGUsdCl7dGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJjb21wdXRlTWFzayBoYXMgbm90IGJlZW4gaW1wbGVtZW50ZWQgZm9yIENvbmNhdGVuYXRlIHlldFwiKX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIHQ9e2F4aXM6dGhpcy5heGlzfSxuPWUucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBPYmplY3QuYXNzaWduKHQsbiksdH0sdC5jbGFzc05hbWU9XCJDb25jYXRlbmF0ZVwiLHR9KE1lcmdlKTtmdW5jdGlvbiBpbnRlcnByZXRBeGlzKGUsdCl7Zm9yKDtlPDA7KWUrPXQ7cmV0dXJuIGV9ZnVuY3Rpb24gYmF0Y2hEb3QoZSx0LG4pe2lmKGUuc2hhcGUubGVuZ3RoPjN8fHQuc2hhcGUubGVuZ3RoPjMpdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJiYXRjaERvdCBpcyBub3QgaW1wbGVtZW50ZWQgZm9yIHRlbnNvcnMgb2YgNEQgb3IgaGlnaGVyIHJhbmsgeWV0XCIpO2lmKHV0aWwuYXNzZXJ0KGUuc2hhcGUubGVuZ3RoPj0yLFwiYmF0Y2hEb3QgcmVxdWlyZXMgdGhlIHJhbmsgb2YgeCB0byBiZSA+PSAyLCBidXQgZ290IFwiK2Uuc2hhcGUubGVuZ3RoKSx1dGlsLmFzc2VydChlLnNoYXBlLmxlbmd0aD49MixcImJhdGNoRG90IHJlcXVpcmVzIHRoZSByYW5rIG9mIHkgdG8gYmUgPj0gMiwgYnV0IGdvdCBcIit0LnNoYXBlLmxlbmd0aCksXCJudW1iZXJcIj09dHlwZW9mIG4mJihuPVtuLG5dKSxcImNvbXBsZXg2NFwiPT09ZS5kdHlwZXx8XCJjb21wbGV4NjRcIj09PXQuZHR5cGUpdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJiYXRjaERvdCBpcyBub3QgaW1wbGVtZW50ZWQgZm9yIGNvbXBsZXg2NC10eXBlIFRlbnNvcnMgeWV0LlwiKTt2YXIgcj1lLnNoYXBlLmxlbmd0aCxpPXQuc2hhcGUubGVuZ3RoO251bGw9PW4mJihuPVtyLTEsaS0yXSk7dmFyIGE9bjtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciBuLG87aWYocj5pKXtuPXItaTtmb3IodmFyIHM9W10sbD0wO2w8bjsrK2wpcy5wdXNoKDEpO3Q9dC5yZXNoYXBlKHQuc2hhcGUuY29uY2F0KHMpKX1lbHNlIGlmKGk+cil7bj1pLXI7Zm9yKHM9W10sbD0wO2w8bjsrK2wpcy5wdXNoKDEpO2U9ZS5yZXNoYXBlKGUuc2hhcGUuY29uY2F0KHMpKX1lbHNlIG49MDtpZigyPT09ZS5zaGFwZS5sZW5ndGgmJjI9PT10LnNoYXBlLmxlbmd0aClvPWFbMF09PT1hWzFdP2UubXVsU3RyaWN0KHQpLnN1bShhWzBdKTplLnRyYW5zcG9zZShbMSwwXSkubXVsU3RyaWN0KHQpLnN1bShhWzFdKTtlbHNle3ZhciB1PWFbMF0hPT1lLnNoYXBlLmxlbmd0aC0xfHxudWxsLGM9YVsxXT09PXQuc2hhcGUubGVuZ3RoLTF8fG51bGw7bz1lLm1hdE11bCh0LHUsYyl9aWYobj4wKXt2YXIgcD12b2lkIDAsaD1bXTtmb3IobD1wPXI+aT9yK2ktMzpyLTE7bDxwK247KytsKWgucHVzaChsKTtvPW8uc3F1ZWV6ZShoKX1yZXR1cm4gMT09PW8uc2hhcGUubGVuZ3RoJiYobz1vLmV4cGFuZERpbXMoMSkpLG99KX1zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoQ29uY2F0ZW5hdGUpO3ZhciBEb3Q9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyx0KXx8dGhpcztyZXR1cm4gbi5heGVzPXQuYXhlcyxuLm5vcm1hbGl6ZT1udWxsIT10Lm5vcm1hbGl6ZSYmdC5ub3JtYWxpemUsbi5zdXBwb3J0c01hc2tpbmc9ITAsbi5yZXNoYXBlUmVxdWlyZWQ9ITEsbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuYnVpbGQ9ZnVuY3Rpb24oZSl7dXRpbC5hc3NlcnQoQXJyYXkuaXNBcnJheShlKSYmMj09PWUubGVuZ3RoJiZBcnJheS5pc0FycmF5KGVbMF0pJiZBcnJheS5pc0FycmF5KGVbMV0pLFwiQSBgRG90YCBsYXllciBzaG91bGQgYmUgY2FsbGVkIG9uIGEgbGlzdCBvZiBleGFjdGx5IDIgaW5wdXRzLlwiKTt2YXIgdD1lWzBdLG49ZVsxXTtpZih0Lmxlbmd0aD4zfHxuLmxlbmd0aD4zKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwiRG90IGxheWVyIGRvZXMgbm90IHN1cHBvcnQgdGVuc29ycyBvZiA0RCBvciBoaWdoZXIgcmFuayB5ZXQuXCIpO3ZhciByPXRoaXMuaW50ZXJwcmV0QXhlcyh0LG4pO2lmKHRbclswXV0hPT1uW3JbMV1dKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiRGltZW5zaW9uIGluY29tcGF0aWJpbGl0eTogXCIrdFtyWzBdXStcIiAhPT0gXCIrbltyWzFdXSl9LHQucHJvdG90eXBlLm1lcmdlRnVuY3Rpb249ZnVuY3Rpb24oZSl7aWYoMiE9PWUubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiQSBgRG90YCBsYXllciBtdXN0IGJlIGNhbGxlZCBvbiBleGFjdGx5IDIgaW5wdXRzLCBidXQgcmVjZWl2ZWQgXCIrZS5sZW5ndGgrXCIgaW5wdXQocykuXCIpO3ZhciB0LG49ZVswXSxyPWVbMV07cmV0dXJuIHQ9QXJyYXkuaXNBcnJheSh0aGlzLmF4ZXMpP3RoaXMuYXhlcy5tYXAoZnVuY3Rpb24odCxuKXtyZXR1cm4gaW50ZXJwcmV0QXhpcyh0LGVbbl0uc2hhcGUubGVuZ3RoKX0pOltpbnRlcnByZXRBeGlzKHRoaXMuYXhlcyxuLnNoYXBlLmxlbmd0aCksaW50ZXJwcmV0QXhpcyh0aGlzLmF4ZXMsci5zaGFwZS5sZW5ndGgpXSx0aGlzLm5vcm1hbGl6ZSYmKG49bDJOb3JtYWxpemUobix0WzBdKSxyPWwyTm9ybWFsaXplKHIsdFsxXSkpLGJhdGNoRG90KG4scix0KX0sdC5wcm90b3R5cGUuaW50ZXJwcmV0QXhlcz1mdW5jdGlvbihlLHQpe3JldHVybiBBcnJheS5pc0FycmF5KHRoaXMuYXhlcyk/dGhpcy5heGVzOltpbnRlcnByZXRBeGlzKHRoaXMuYXhlcyxlLmxlbmd0aCksaW50ZXJwcmV0QXhpcyh0aGlzLmF4ZXMsdC5sZW5ndGgpXX0sdC5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlPWZ1bmN0aW9uKGUpe3V0aWwuYXNzZXJ0KEFycmF5LmlzQXJyYXkoZSkmJjI9PT1lLmxlbmd0aCYmQXJyYXkuaXNBcnJheShlWzBdKSYmQXJyYXkuaXNBcnJheShlWzFdKSxcIkEgYERvdGAgbGF5ZXIgc2hvdWxkIGJlIGNhbGxlZCBvbiBhIGxpc3Qgb2YgZXhhY3RseSAyIGlucHV0cy5cIik7dmFyIHQ9ZVswXS5zbGljZSgpLG49ZVsxXS5zbGljZSgpO2lmKHQubGVuZ3RoPjN8fG4ubGVuZ3RoPjMpdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJEb3QgbGF5ZXIgZG9lcyBub3Qgc3VwcG9ydCB0ZW5zb3JzIG9mIDREIG9yIGhpZ2hlciByYW5rIHlldC5cIik7dmFyIHI9dGhpcy5pbnRlcnByZXRBeGVzKHQsbik7dC5zcGxpY2UoclswXSwxKSxuLnNwbGljZShyWzFdLDEpLG4uc3BsaWNlKDAsMSk7dmFyIGk9dC5jb25jYXQobik7cmV0dXJuIDE9PT1pLmxlbmd0aCYmaS5wdXNoKDEpLGl9LHQucHJvdG90eXBlLmNvbXB1dGVNYXNrPWZ1bmN0aW9uKGUsdCl7dGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJjb21wdXRlTWFzayBoYXMgbm90IGJlZW4gaW1wbGVtZW50ZWQgZm9yIERvdCB5ZXRcIil9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciB0PXtheGVzOnRoaXMuYXhlcyxub3JtYWxpemU6dGhpcy5ub3JtYWxpemV9LG49ZS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIE9iamVjdC5hc3NpZ24odCxuKSx0fSx0LmNsYXNzTmFtZT1cIkRvdFwiLHR9KE1lcmdlKTtmdW5jdGlvbiBiYXRjaE5vcm1hbGl6YXRpb24oZSx0LG4scixpLGEpe3ZhciBvO2lmKHZvaWQgMD09PWEmJihhPS4wMDEpLDI9PT1lLnJhbmspbz1iYXRjaE5vcm1hbGl6YXRpb24yZChlLHQsbixhLGkscik7ZWxzZSBpZigzPT09ZS5yYW5rKW89YmF0Y2hOb3JtYWxpemF0aW9uM2QoZSx0LG4sYSxpLHIpO2Vsc2V7aWYoNCE9PWUucmFuayl0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcImJhdGNoTm9ybWFsaXphdGlvbiBpcyBub3QgaW1wbGVtZW50ZWQgZm9yIGFycmF5IG9mIHJhbmsgXCIrZS5yYW5rK1wiIHlldFwiKTtvPWJhdGNoTm9ybWFsaXphdGlvbjRkKGUsdCxuLGEsaSxyKX1yZXR1cm4gb31mdW5jdGlvbiByZWd1bGFyTm9ybWFsaXplQmF0Y2hJblRyYWluaW5nKGUsdCxuLHIsaSl7cmV0dXJuIHZvaWQgMD09PWkmJihpPS4wMDEpLHRpZHkoZnVuY3Rpb24oKXt2YXIgYT1tb21lbnRzKGUsciksbz1hLm1lYW4scz1hLnZhcmlhbmNlO3JldHVybltiYXRjaE5vcm1hbGl6YXRpb24oZSxvLHMsbix0LGkpLG8sc119KX1mdW5jdGlvbiBicm9hZGNhc3ROb3JtYWxpemVCYXRjaEluVHJhaW5pbmcoZSx0LG4scixpKXtyZXR1cm4gdm9pZCAwPT09aSYmKGk9LjAwMSksdGlkeShmdW5jdGlvbigpe2Zvcih2YXIgYT1tb21lbnRzKGUsciksbz1hLm1lYW4scz1hLnZhcmlhbmNlLGw9W10sdT0wLGM9cmFuZ2UoMCxlLnJhbmspO3U8Yy5sZW5ndGg7dSsrKXt2YXIgcD1jW3VdOy0xIT09ci5pbmRleE9mKHApP2wucHVzaCgxKTpsLnB1c2goZS5zaGFwZVtwXSl9dmFyIGg9by5yZXNoYXBlKGwpLGQ9cy5yZXNoYXBlKGwpLGY9bnVsbD09dD9udWxsOnQucmVzaGFwZShsKSxnPW51bGw9PW4/bnVsbDpuLnJlc2hhcGUobCk7cmV0dXJuW2JhdGNoTm9ybWFsaXphdGlvbihlLGgsZCxnLGYsaSksbyxzXX0pfWZ1bmN0aW9uIG5vcm1hbGl6ZUJhdGNoSW5UcmFpbmluZyhlLHQsbixyLGkpe3JldHVybiB2b2lkIDA9PT1pJiYoaT0uMDAxKSx1dGlsLmFycmF5c0VxdWFsKHIuc2xpY2UoKS5zb3J0KCkscmFuZ2UoMCxlLnJhbmstMSkpP3JlZ3VsYXJOb3JtYWxpemVCYXRjaEluVHJhaW5pbmcoZSx0LG4scixpKTpicm9hZGNhc3ROb3JtYWxpemVCYXRjaEluVHJhaW5pbmcoZSx0LG4scixpKX1zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoRG90KTt2YXIgQmF0Y2hOb3JtYWxpemF0aW9uPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49dGhpcztyZXR1cm4gbnVsbD09dCYmKHQ9e30pLChuPWUuY2FsbCh0aGlzLHQpfHx0aGlzKS5zdXBwb3J0c01hc2tpbmc9ITAsbi5heGlzPW51bGw9PXQuYXhpcz8tMTp0LmF4aXMsbi5tb21lbnR1bT1udWxsPT10Lm1vbWVudHVtPy45OTp0Lm1vbWVudHVtLG4uZXBzaWxvbj1udWxsPT10LmVwc2lsb24/LjAwMTp0LmVwc2lsb24sbi5jZW50ZXI9bnVsbD09dC5jZW50ZXJ8fHQuY2VudGVyLG4uc2NhbGU9bnVsbD09dC5zY2FsZXx8dC5zY2FsZSxuLmJldGFJbml0aWFsaXplcj1nZXRJbml0aWFsaXplcih0LmJldGFJbml0aWFsaXplcnx8XCJ6ZXJvc1wiKSxuLmdhbW1hSW5pdGlhbGl6ZXI9Z2V0SW5pdGlhbGl6ZXIodC5nYW1tYUluaXRpYWxpemVyfHxcIm9uZXNcIiksbi5tb3ZpbmdNZWFuSW5pdGlhbGl6ZXI9Z2V0SW5pdGlhbGl6ZXIodC5tb3ZpbmdNZWFuSW5pdGlhbGl6ZXJ8fFwiemVyb3NcIiksbi5tb3ZpbmdWYXJpYW5jZUluaXRpYWxpemVyPWdldEluaXRpYWxpemVyKHQubW92aW5nVmFyaWFuY2VJbml0aWFsaXplcnx8XCJvbmVzXCIpLG4uYmV0YUNvbnN0cmFpbnQ9Z2V0Q29uc3RyYWludCh0LmJldGFDb25zdHJhaW50KSxuLmdhbW1hQ29uc3RyYWludD1nZXRDb25zdHJhaW50KHQuZ2FtbWFDb25zdHJhaW50KSxuLmJldGFSZWd1bGFyaXplcj1nZXRSZWd1bGFyaXplcih0LmJldGFSZWd1bGFyaXplciksbi5nYW1tYVJlZ3VsYXJpemVyPWdldFJlZ3VsYXJpemVyKHQuZ2FtbWFSZWd1bGFyaXplciksbi5zdGVwQ291bnQ9MCxufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5idWlsZD1mdW5jdGlvbihlKXtlPWdldEV4YWN0bHlPbmVTaGFwZShlKTt2YXIgdD10aGlzLmF4aXM+PTA/dGhpcy5heGlzOnRoaXMuYXhpcytlLmxlbmd0aCxuPWVbdF07aWYobnVsbD09bil0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkF4aXMgXCIrdCtcIiBvZiBpbnB1dCB0ZW5zb3Igc2hvdWxkIGhhdmUgYSBkZWZpbmVkIGRpbWVuc2lvbiBidXQgdGhlIGxheWVyIHJlY2VpdmVkIGFuIGlucHV0IHdpdGggc2hhcGUgXCIrSlNPTi5zdHJpbmdpZnkoZSkrXCIuXCIpO3RoaXMuaW5wdXRTcGVjPVtuZXcgSW5wdXRTcGVjKHtuZGltOmUubGVuZ3RoLGF4ZXM6KHI9e30sclt0XT1uLHIpfSldO3ZhciByLGk9W25dO3RoaXMuc2NhbGUmJih0aGlzLmdhbW1hPXRoaXMuYWRkV2VpZ2h0KFwiZ2FtbWFcIixpLG51bGwsdGhpcy5nYW1tYUluaXRpYWxpemVyLHRoaXMuZ2FtbWFSZWd1bGFyaXplciwhMCx0aGlzLmdhbW1hQ29uc3RyYWludCkpLHRoaXMuY2VudGVyJiYodGhpcy5iZXRhPXRoaXMuYWRkV2VpZ2h0KFwiYmV0YVwiLGksbnVsbCx0aGlzLmJldGFJbml0aWFsaXplcix0aGlzLmJldGFSZWd1bGFyaXplciwhMCx0aGlzLmJldGFDb25zdHJhaW50KSksdGhpcy5tb3ZpbmdNZWFuPXRoaXMuYWRkV2VpZ2h0KFwibW92aW5nX21lYW5cIixpLG51bGwsdGhpcy5tb3ZpbmdNZWFuSW5pdGlhbGl6ZXIsbnVsbCwhMSksdGhpcy5tb3ZpbmdWYXJpYW5jZT10aGlzLmFkZFdlaWdodChcIm1vdmluZ192YXJpYW5jZVwiLGksbnVsbCx0aGlzLm1vdmluZ1ZhcmlhbmNlSW5pdGlhbGl6ZXIsbnVsbCwhMSksdGhpcy5idWlsdD0hMH0sdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXt2YXIgcj1udWxsIT10LnRyYWluaW5nJiZ0LnRyYWluaW5nLGk9Z2V0RXhhY3RseU9uZVRlbnNvcihlKSxhPWkuc2hhcGUsbz1hLmxlbmd0aCxzPXJhbmdlKDAsbyksbD1uLmF4aXM+PTA/bi5heGlzOm4uYXhpcytvO3Muc3BsaWNlKGwsMSk7dmFyIHU9cHlMaXN0UmVwZWF0KDEsbyk7dVtsXT1hW2xdO3ZhciBjPXMuc2xpY2UoKTtjLnNvcnQoKTt2YXIgcD0hdXRpbC5hcnJheXNFcXVhbChjLHJhbmdlKDAsbykuc2xpY2UoMCxvLTEpKTtpZighcilyZXR1cm4gZnVuY3Rpb24oKXtpZihwKXt2YXIgZT1uLm1vdmluZ01lYW4ucmVhZCgpLnJlc2hhcGUodSksdD1uLm1vdmluZ1ZhcmlhbmNlLnJlYWQoKS5yZXNoYXBlKHUpLHI9bi5jZW50ZXI/bi5iZXRhLnJlYWQoKS5yZXNoYXBlKHUpOm51bGwsYT1uLnNjYWxlP24uZ2FtbWEucmVhZCgpLnJlc2hhcGUodSk6bnVsbDtyZXR1cm4gYmF0Y2hOb3JtYWxpemF0aW9uKGksZSx0LHIsYSxuLmVwc2lsb24pfXJldHVybiBiYXRjaE5vcm1hbGl6YXRpb24oaSxuLm1vdmluZ01lYW4ucmVhZCgpLG4ubW92aW5nVmFyaWFuY2UucmVhZCgpLG51bGw9PW4uYmV0YT9udWxsOm4uYmV0YS5yZWFkKCksbnVsbD09bi5nYW1tYT9udWxsOm4uZ2FtbWEucmVhZCgpLG4uZXBzaWxvbil9KCk7dmFyIGg9bm9ybWFsaXplQmF0Y2hJblRyYWluaW5nKGksbi5nYW1tYS5yZWFkKCksbi5iZXRhLnJlYWQoKSxzLG4uZXBzaWxvbiksZD1oWzBdLGY9aFsxXSxnPWhbMl0sbT1hcnJheVByb2Qocy5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGkuc2hhcGVbZV19KSkseT1nLm11bChnZXRTY2FsYXIobS8obS0oMStuLmVwc2lsb24pKSkpO3JldHVybiBmdW5jdGlvbigpe24uc3RlcENvdW50Kys7dmFyIGU9bW92aW5nQXZlcmFnZShuLm1vdmluZ01lYW4ucmVhZCgpLGYsbi5tb21lbnR1bSxuLnN0ZXBDb3VudCk7bi5tb3ZpbmdNZWFuLndyaXRlKGUpO3ZhciB0PW1vdmluZ0F2ZXJhZ2Uobi5tb3ZpbmdWYXJpYW5jZS5yZWFkKCkseSxuLm1vbWVudHVtLG4uc3RlcENvdW50KTtuLm1vdmluZ1ZhcmlhbmNlLndyaXRlKHQpfSgpLGR9KX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIHQ9e2F4aXM6dGhpcy5heGlzLG1vbWVudHVtOnRoaXMubW9tZW50dW0sZXBzaWxvbjp0aGlzLmVwc2lsb24sY2VudGVyOnRoaXMuY2VudGVyLHNjYWxlOnRoaXMuc2NhbGUsYmV0YUluaXRpYWxpemVyOnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMuYmV0YUluaXRpYWxpemVyKSxnYW1tYUluaXRpYWxpemVyOnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMuZ2FtbWFJbml0aWFsaXplciksbW92aW5nTWVhbkluaXRpYWxpemVyOnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMubW92aW5nTWVhbkluaXRpYWxpemVyKSxtb3ZpbmdWYXJpYW5jZUluaXRpYWxpemVyOnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMubW92aW5nVmFyaWFuY2VJbml0aWFsaXplciksYmV0YVJlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYmV0YVJlZ3VsYXJpemVyKSxnYW1tYVJlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuZ2FtbWFSZWd1bGFyaXplciksYmV0YUNvbnN0cmFpbnQ6c2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmJldGFDb25zdHJhaW50KSxnYW1tYUNvbnN0cmFpbnQ6c2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmdhbW1hQ29uc3RyYWludCl9LG49ZS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIE9iamVjdC5hc3NpZ24odCxuKSx0fSx0LmNsYXNzTmFtZT1cIkJhdGNoTm9ybWFsaXphdGlvblwiLHR9KExheWVyKTtmdW5jdGlvbiBzcGF0aWFsMmRQYWRkaW5nKGUsdCxuKXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe2lmKDQhPT1lLnJhbmspdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJ0ZW1wb3JhbFBhZGRpbmcgZXhwZWN0cyBpbnB1dCB0ZW5zb3IgdG8gYmUgNC1ELCBidXQgcmVjZWl2ZWQgYSBcIitlLnJhbmsrXCItRCB0ZW5zb3IuXCIpO2lmKG51bGw9PXQmJih0PVtbMSwxXSxbMSwxXV0pLDIhPT10Lmxlbmd0aHx8MiE9PXRbMF0ubGVuZ3RofHwyIT09dFsxXS5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJzcGF0aWFsMmRQYWRkaW5nIGV4cGVjdHMgYHBhZGRpbmdgIHRvIGJlIGFuIEFycmF5IG9mIHR3byBBcnJheXMsIGVhY2ggb2Ygd2hpY2ggaXMgYW4gQXJyYXkgb2YgdHdvIGludGVnZXJzLlwiKTtpZihudWxsPT1uJiYobj1pbWFnZURhdGFGb3JtYXQoKSksXCJjaGFubmVsc0xhc3RcIiE9PW4mJlwiY2hhbm5lbHNGaXJzdFwiIT09bil0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlVua25vd24gZGF0YSBmb3JtYXQ6IFwiK24rXCIuIFN1cHBvcnRlZCBkYXRhIGZvcm1hdHMgYXJlICdjaGFubmVsc0xhc3QnIGFuZCAnY2hhbm5lbHNGaXJzdC5cIik7dmFyIHI7cmV0dXJuIHI9XCJjaGFubmVsc0ZpcnN0XCI9PT1uP1tbMCwwXSxbMCwwXSx0WzBdLHRbMV1dOltbMCwwXSx0WzBdLHRbMV0sWzAsMF1dLHBhZChlLHIpfSl9c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKEJhdGNoTm9ybWFsaXphdGlvbik7dmFyIFplcm9QYWRkaW5nMkQ9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj10aGlzO2lmKG51bGw9PXQmJih0PXt9KSwobj1lLmNhbGwodGhpcyx0KXx8dGhpcykuZGF0YUZvcm1hdD1udWxsPT10LmRhdGFGb3JtYXQ/aW1hZ2VEYXRhRm9ybWF0KCk6dC5kYXRhRm9ybWF0LG51bGw9PXQucGFkZGluZyluLnBhZGRpbmc9W1sxLDFdLFsxLDFdXTtlbHNlIGlmKFwibnVtYmVyXCI9PXR5cGVvZiB0LnBhZGRpbmcpbi5wYWRkaW5nPVtbdC5wYWRkaW5nLHQucGFkZGluZ10sW3QucGFkZGluZyx0LnBhZGRpbmddXTtlbHNle2lmKHQucGFkZGluZz10LnBhZGRpbmcsMiE9PXQucGFkZGluZy5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJaZXJvUGFkZGluZzJEIGV4cGVjdHMgcGFkZGluZyB0byBiZSBhIGxlbmd0aC0yIGFycmF5LCBidXQgcmVjZWl2ZWQgYSBsZW5ndGgtXCIrdC5wYWRkaW5nLmxlbmd0aCtcIiBhcnJheS5cIik7dmFyIHI9dm9pZCAwLGk9dm9pZCAwO2lmKFwibnVtYmVyXCI9PXR5cGVvZiB0LnBhZGRpbmdbMF0pcj1bdC5wYWRkaW5nWzBdLHQucGFkZGluZ1swXV0saT1bdC5wYWRkaW5nWzFdLHQucGFkZGluZ1sxXV07ZWxzZXtpZih0LnBhZGRpbmc9dC5wYWRkaW5nLDIhPT10LnBhZGRpbmdbMF0ubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiWmVyb1BhZGRpbmcyRCBleHBlY3RzIGhlaWdodCBwYWRkaW5nIHRvIGJlIGEgbGVuZ3RoLTIgYXJyYXksIGJ1dCByZWNlaXZlZCBhIGxlbmd0aC1cIit0LnBhZGRpbmdbMF0ubGVuZ3RoK1wiIGFycmF5LlwiKTtpZihyPXQucGFkZGluZ1swXSwyIT09dC5wYWRkaW5nWzFdLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlplcm9QYWRkaW5nMkQgZXhwZWN0cyB3aWR0aCBwYWRkaW5nIHRvIGJlIGEgbGVuZ3RoLTIgYXJyYXksIGJ1dCByZWNlaXZlZCBhIGxlbmd0aC1cIit0LnBhZGRpbmdbMV0ubGVuZ3RoK1wiIGFycmF5LlwiKTtpPXQucGFkZGluZ1sxXX1uLnBhZGRpbmc9W3IsaV19cmV0dXJuIG4uaW5wdXRTcGVjPVtuZXcgSW5wdXRTcGVjKHtuZGltOjR9KV0sbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlPWZ1bmN0aW9uKGUpe3ZhciB0LG47cmV0dXJuIGU9Z2V0RXhhY3RseU9uZVNoYXBlKGUpLFwiY2hhbm5lbHNGaXJzdFwiPT09dGhpcy5kYXRhRm9ybWF0Pyh0PW51bGwhPWVbMl0mJmVbMl0+PTA/ZVsyXSt0aGlzLnBhZGRpbmdbMF1bMF0rdGhpcy5wYWRkaW5nWzBdWzFdOm51bGwsbj1udWxsIT1lWzNdJiZlWzNdPj0wP2VbM10rdGhpcy5wYWRkaW5nWzFdWzBdK3RoaXMucGFkZGluZ1sxXVsxXTpudWxsLFtlWzBdLGVbMV0sdCxuXSk6KHQ9bnVsbCE9ZVsxXSYmZVsxXT49MD9lWzFdK3RoaXMucGFkZGluZ1swXVswXSt0aGlzLnBhZGRpbmdbMF1bMV06bnVsbCxuPW51bGwhPWVbMl0mJmVbMl0+PTA/ZVsyXSt0aGlzLnBhZGRpbmdbMV1bMF0rdGhpcy5wYWRkaW5nWzFdWzFdOm51bGwsW2VbMF0sdCxuLGVbM11dKX0sdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtyZXR1cm4gc3BhdGlhbDJkUGFkZGluZyhnZXRFeGFjdGx5T25lVGVuc29yKGUpLG4ucGFkZGluZyxuLmRhdGFGb3JtYXQpfSl9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciB0PXtwYWRkaW5nOnRoaXMucGFkZGluZyxkYXRhRm9ybWF0OnRoaXMuZGF0YUZvcm1hdH0sbj1lLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gT2JqZWN0LmFzc2lnbih0LG4pLHR9LHQuY2xhc3NOYW1lPVwiWmVyb1BhZGRpbmcyRFwiLHR9KExheWVyKTtmdW5jdGlvbiBwb29sMmQoZSx0LG4scixpLGEpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIG87Y2hlY2tEYXRhRm9ybWF0KGkpLGNoZWNrUG9vbE1vZGUoYSksY2hlY2tQYWRkaW5nTW9kZShyKSxudWxsPT1uJiYobj1bMSwxXSksbnVsbD09ciYmKHI9XCJ2YWxpZFwiKSxudWxsPT1pJiYoaT1pbWFnZURhdGFGb3JtYXQoKSksbnVsbD09YSYmKGE9XCJtYXhcIiksZT1wcmVwcm9jZXNzQ29udjJESW5wdXQoZSxpKTt2YXIgcz1cInNhbWVcIj09PXI/XCJzYW1lXCI6XCJ2YWxpZFwiO3JldHVybiBvPVwibWF4XCI9PT1hP21heFBvb2woZSx0LG4scyk6YXZnUG9vbChlLHQsbixzKSxcImNoYW5uZWxzRmlyc3RcIj09PWkmJihvPXRyYW5zcG9zZShvLFswLDMsMSwyXSkpLG99KX1zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoWmVyb1BhZGRpbmcyRCk7dmFyIFBvb2xpbmcxRD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPXRoaXM7aWYobnVsbD09dC5wb29sU2l6ZSYmKHQucG9vbFNpemU9Miksbj1lLmNhbGwodGhpcyx0KXx8dGhpcyxcIm51bWJlclwiPT10eXBlb2YgdC5wb29sU2l6ZSluLnBvb2xTaXplPVt0LnBvb2xTaXplXTtlbHNle2lmKCFBcnJheS5pc0FycmF5KHQucG9vbFNpemUpfHwxIT09dC5wb29sU2l6ZS5sZW5ndGh8fFwibnVtYmVyXCIhPXR5cGVvZiB0LnBvb2xTaXplWzBdKXRocm93IG5ldyBWYWx1ZUVycm9yKFwicG9vbFNpemUgZm9yIDFEIGNvbnZvbHV0aW9uYWwgbGF5ZXIgbXVzdCBiZSBhIG51bWJlciBvciBhbiBBcnJheSBvZiBhIHNpbmdsZSBudW1iZXIsIGJ1dCByZWNlaXZlZCBcIitKU09OLnN0cmluZ2lmeSh0LnBvb2xTaXplKSk7bi5wb29sU2l6ZT10LnBvb2xTaXplfWlmKG51bGw9PXQuc3RyaWRlcyluLnN0cmlkZXM9bi5wb29sU2l6ZTtlbHNlIGlmKFwibnVtYmVyXCI9PXR5cGVvZiB0LnN0cmlkZXMpbi5zdHJpZGVzPVt0LnN0cmlkZXNdO2Vsc2V7aWYoIUFycmF5LmlzQXJyYXkodC5zdHJpZGVzKXx8MSE9PXQuc3RyaWRlcy5sZW5ndGh8fFwibnVtYmVyXCIhPXR5cGVvZiB0LnN0cmlkZXNbMF0pdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJzdHJpZGVzIGZvciAxRCBjb252b2x1dGlvbmFsIGxheWVyIG11c3QgYmUgYSBudW1iZXIgb3IgYW4gQXJyYXkgb2YgYSBzaW5nbGUgbnVtYmVyLCBidXQgcmVjZWl2ZWQgXCIrSlNPTi5zdHJpbmdpZnkodC5zdHJpZGVzKSk7bi5zdHJpZGVzPXQuc3RyaWRlc31yZXR1cm4gbi5wYWRkaW5nPW51bGw9PXQucGFkZGluZz9cInZhbGlkXCI6dC5wYWRkaW5nLGNoZWNrUGFkZGluZ01vZGUobi5wYWRkaW5nKSxuLmlucHV0U3BlYz1bbmV3IElucHV0U3BlYyh7bmRpbTozfSldLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZT1mdW5jdGlvbihlKXt2YXIgdD1jb252T3V0cHV0TGVuZ3RoKChlPWdldEV4YWN0bHlPbmVTaGFwZShlKSlbMV0sdGhpcy5wb29sU2l6ZVswXSx0aGlzLnBhZGRpbmcsdGhpcy5zdHJpZGVzWzBdKTtyZXR1cm5bZVswXSx0LGVbMl1dfSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe24uaW52b2tlQ2FsbEhvb2soZSx0KSxlPWV4cGFuZERpbXMoZ2V0RXhhY3RseU9uZVRlbnNvcihlKSwyKTt2YXIgcj1uLnBvb2xpbmdGdW5jdGlvbihnZXRFeGFjdGx5T25lVGVuc29yKGUpLFtuLnBvb2xTaXplWzBdLDFdLFtuLnN0cmlkZXNbMF0sMV0sbi5wYWRkaW5nLFwiY2hhbm5lbHNMYXN0XCIpO3JldHVybiBzcXVlZXplKHIsWzJdKX0pfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD17cG9vbFNpemU6dGhpcy5wb29sU2l6ZSxwYWRkaW5nOnRoaXMucGFkZGluZyxzdHJpZGVzOnRoaXMuc3RyaWRlc30sbj1lLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gT2JqZWN0LmFzc2lnbih0LG4pLHR9LHR9KExheWVyKSxNYXhQb29saW5nMUQ9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXtyZXR1cm4gZS5jYWxsKHRoaXMsdCl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLnBvb2xpbmdGdW5jdGlvbj1mdW5jdGlvbihlLHQsbixyLGkpe3JldHVybiBjaGVja0RhdGFGb3JtYXQoaSksY2hlY2tQYWRkaW5nTW9kZShyKSxwb29sMmQoZSx0LG4scixpLFwibWF4XCIpfSx0LmNsYXNzTmFtZT1cIk1heFBvb2xpbmcxRFwiLHR9KFBvb2xpbmcxRCk7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKE1heFBvb2xpbmcxRCk7dmFyIEF2ZXJhZ2VQb29saW5nMUQ9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXtyZXR1cm4gZS5jYWxsKHRoaXMsdCl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLnBvb2xpbmdGdW5jdGlvbj1mdW5jdGlvbihlLHQsbixyLGkpe3JldHVybiBjaGVja0RhdGFGb3JtYXQoaSksY2hlY2tQYWRkaW5nTW9kZShyKSxwb29sMmQoZSx0LG4scixpLFwiYXZnXCIpfSx0LmNsYXNzTmFtZT1cIkF2ZXJhZ2VQb29saW5nMURcIix0fShQb29saW5nMUQpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhBdmVyYWdlUG9vbGluZzFEKTt2YXIgUG9vbGluZzJEPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49dGhpcztpZihudWxsPT10LnBvb2xTaXplJiYodC5wb29sU2l6ZT1bMiwyXSksKG49ZS5jYWxsKHRoaXMsdCl8fHRoaXMpLnBvb2xTaXplPUFycmF5LmlzQXJyYXkodC5wb29sU2l6ZSk/dC5wb29sU2l6ZTpbdC5wb29sU2l6ZSx0LnBvb2xTaXplXSxudWxsPT10LnN0cmlkZXMpbi5zdHJpZGVzPW4ucG9vbFNpemU7ZWxzZSBpZihBcnJheS5pc0FycmF5KHQuc3RyaWRlcykpe2lmKDIhPT10LnN0cmlkZXMubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiSWYgdGhlIHN0cmlkZXMgcHJvcGVydHkgb2YgYSAyRCBwb29saW5nIGxheWVyIGlzIGFuIEFycmF5LCBpdCBpcyBleHBlY3RlZCB0byBoYXZlIGEgbGVuZ3RoIG9mIDIsIGJ1dCByZWNlaXZlZCBsZW5ndGggXCIrdC5zdHJpZGVzLmxlbmd0aCtcIi5cIik7bi5zdHJpZGVzPXQuc3RyaWRlc31lbHNlIG4uc3RyaWRlcz1bdC5zdHJpZGVzLHQuc3RyaWRlc107cmV0dXJuIG4ucGFkZGluZz1udWxsPT10LnBhZGRpbmc/XCJ2YWxpZFwiOnQucGFkZGluZyxuLmRhdGFGb3JtYXQ9bnVsbD09dC5kYXRhRm9ybWF0P1wiY2hhbm5lbHNMYXN0XCI6dC5kYXRhRm9ybWF0LGNoZWNrRGF0YUZvcm1hdChuLmRhdGFGb3JtYXQpLGNoZWNrUGFkZGluZ01vZGUobi5wYWRkaW5nKSxuLmlucHV0U3BlYz1bbmV3IElucHV0U3BlYyh7bmRpbTo0fSldLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZT1mdW5jdGlvbihlKXtlPWdldEV4YWN0bHlPbmVTaGFwZShlKTt2YXIgdD1cImNoYW5uZWxzRmlyc3RcIj09PXRoaXMuZGF0YUZvcm1hdD9lWzJdOmVbMV0sbj1cImNoYW5uZWxzRmlyc3RcIj09PXRoaXMuZGF0YUZvcm1hdD9lWzNdOmVbMl07cmV0dXJuIHQ9Y29udk91dHB1dExlbmd0aCh0LHRoaXMucG9vbFNpemVbMF0sdGhpcy5wYWRkaW5nLHRoaXMuc3RyaWRlc1swXSksbj1jb252T3V0cHV0TGVuZ3RoKG4sdGhpcy5wb29sU2l6ZVsxXSx0aGlzLnBhZGRpbmcsdGhpcy5zdHJpZGVzWzFdKSxcImNoYW5uZWxzRmlyc3RcIj09PXRoaXMuZGF0YUZvcm1hdD9bZVswXSxlWzFdLHQsbl06W2VbMF0sdCxuLGVbM11dfSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe3JldHVybiBuLmludm9rZUNhbGxIb29rKGUsdCksbi5wb29saW5nRnVuY3Rpb24oZ2V0RXhhY3RseU9uZVRlbnNvcihlKSxuLnBvb2xTaXplLG4uc3RyaWRlcyxuLnBhZGRpbmcsbi5kYXRhRm9ybWF0KX0pfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD17cG9vbFNpemU6dGhpcy5wb29sU2l6ZSxwYWRkaW5nOnRoaXMucGFkZGluZyxzdHJpZGVzOnRoaXMuc3RyaWRlcyxkYXRhRm9ybWF0OnRoaXMuZGF0YUZvcm1hdH0sbj1lLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gT2JqZWN0LmFzc2lnbih0LG4pLHR9LHR9KExheWVyKSxNYXhQb29saW5nMkQ9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXtyZXR1cm4gZS5jYWxsKHRoaXMsdCl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLnBvb2xpbmdGdW5jdGlvbj1mdW5jdGlvbihlLHQsbixyLGkpe3JldHVybiBjaGVja0RhdGFGb3JtYXQoaSksY2hlY2tQYWRkaW5nTW9kZShyKSxwb29sMmQoZSx0LG4scixpLFwibWF4XCIpfSx0LmNsYXNzTmFtZT1cIk1heFBvb2xpbmcyRFwiLHR9KFBvb2xpbmcyRCk7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKE1heFBvb2xpbmcyRCk7dmFyIEF2ZXJhZ2VQb29saW5nMkQ9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXtyZXR1cm4gZS5jYWxsKHRoaXMsdCl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLnBvb2xpbmdGdW5jdGlvbj1mdW5jdGlvbihlLHQsbixyLGkpe3JldHVybiBjaGVja0RhdGFGb3JtYXQoaSksY2hlY2tQYWRkaW5nTW9kZShyKSxwb29sMmQoZSx0LG4scixpLFwiYXZnXCIpfSx0LmNsYXNzTmFtZT1cIkF2ZXJhZ2VQb29saW5nMkRcIix0fShQb29saW5nMkQpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhBdmVyYWdlUG9vbGluZzJEKTt2YXIgR2xvYmFsUG9vbGluZzFEPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49ZS5jYWxsKHRoaXMsdCl8fHRoaXM7cmV0dXJuIG4uaW5wdXRTcGVjPVtuZXcgSW5wdXRTcGVjKHtuZGltOjN9KV0sbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlPWZ1bmN0aW9uKGUpe3JldHVybltlWzBdLGVbMl1dfSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7dGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3J9LHR9KExheWVyKSxHbG9iYWxBdmVyYWdlUG9vbGluZzFEPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7cmV0dXJuIGUuY2FsbCh0aGlzLHQpfHx0aGlzfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXt2YXIgdD1nZXRFeGFjdGx5T25lVGVuc29yKGUpO3JldHVybiBtZWFuKHQsMSl9KX0sdC5jbGFzc05hbWU9XCJHbG9iYWxBdmVyYWdlUG9vbGluZzFEXCIsdH0oR2xvYmFsUG9vbGluZzFEKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoR2xvYmFsQXZlcmFnZVBvb2xpbmcxRCk7dmFyIEdsb2JhbE1heFBvb2xpbmcxRD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3JldHVybiBlLmNhbGwodGhpcyx0KXx8dGhpc31yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihlLHQpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIHQ9Z2V0RXhhY3RseU9uZVRlbnNvcihlKTtyZXR1cm4gbWF4KHQsMSl9KX0sdC5jbGFzc05hbWU9XCJHbG9iYWxNYXhQb29saW5nMURcIix0fShHbG9iYWxQb29saW5nMUQpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhHbG9iYWxNYXhQb29saW5nMUQpO3ZhciBHbG9iYWxQb29saW5nMkQ9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyx0KXx8dGhpcztyZXR1cm4gbi5kYXRhRm9ybWF0PW51bGw9PXQuZGF0YUZvcm1hdD9cImNoYW5uZWxzTGFzdFwiOnQuZGF0YUZvcm1hdCxjaGVja0RhdGFGb3JtYXQobi5kYXRhRm9ybWF0KSxuLmlucHV0U3BlYz1bbmV3IElucHV0U3BlYyh7bmRpbTo0fSldLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZT1mdW5jdGlvbihlKXtyZXR1cm4gZT1lLFwiY2hhbm5lbHNMYXN0XCI9PT10aGlzLmRhdGFGb3JtYXQ/W2VbMF0sZVszXV06W2VbMF0sZVsxXV19LHQucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oZSx0KXt0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcn0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIHQ9e2RhdGFGb3JtYXQ6dGhpcy5kYXRhRm9ybWF0fSxuPWUucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBPYmplY3QuYXNzaWduKHQsbiksdH0sdH0oTGF5ZXIpLEdsb2JhbEF2ZXJhZ2VQb29saW5nMkQ9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe3JldHVybiBudWxsIT09ZSYmZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIHQ9Z2V0RXhhY3RseU9uZVRlbnNvcihlKTtyZXR1cm5cImNoYW5uZWxzTGFzdFwiPT09bi5kYXRhRm9ybWF0P21lYW4odCxbMSwyXSk6bWVhbih0LFsyLDNdKX0pfSx0LmNsYXNzTmFtZT1cIkdsb2JhbEF2ZXJhZ2VQb29saW5nMkRcIix0fShHbG9iYWxQb29saW5nMkQpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhHbG9iYWxBdmVyYWdlUG9vbGluZzJEKTt2YXIgR2xvYmFsTWF4UG9vbGluZzJEPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoKXtyZXR1cm4gbnVsbCE9PWUmJmUuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciB0PWdldEV4YWN0bHlPbmVUZW5zb3IoZSk7cmV0dXJuXCJjaGFubmVsc0xhc3RcIj09PW4uZGF0YUZvcm1hdD9tYXgodCxbMSwyXSk6bWF4KHQsWzIsM10pfSl9LHQuY2xhc3NOYW1lPVwiR2xvYmFsTWF4UG9vbGluZzJEXCIsdH0oR2xvYmFsUG9vbGluZzJEKTtmdW5jdGlvbiBzdGFuZGFyZGl6ZUFyZ3MoZSx0LG4scil7aWYoQXJyYXkuaXNBcnJheShlKSl7aWYobnVsbCE9dHx8bnVsbCE9bil0aHJvdyBuZXcgVmFsdWVFcnJvcihcIldoZW4gaW5wdXRzIGlzIGFuIGFycmF5LCBuZWl0aGVyIGluaXRpYWxTdGF0ZSBvciBjb25zdGFudHMgc2hvdWxkIGJlIHByb3ZpZGVkXCIpO251bGwhPXImJihuPWUuc2xpY2UoZS5sZW5ndGgtcixlLmxlbmd0aCksZT1lLnNsaWNlKDAsZS5sZW5ndGgtcikpLGUubGVuZ3RoPjEmJih0PWUuc2xpY2UoMSxlLmxlbmd0aCkpLGU9ZVswXX1mdW5jdGlvbiBpKGUpe3JldHVybiBudWxsPT1lfHxBcnJheS5pc0FycmF5KGUpP2U6W2VdfXJldHVybntpbnB1dHM6ZSxpbml0aWFsU3RhdGU6dD1pKHQpLGNvbnN0YW50czpuPWkobil9fWZ1bmN0aW9uIHJubihlLHQsbixyLGksYSxvLHMpe3ZvaWQgMD09PXImJihyPSExKSx2b2lkIDA9PT1vJiYobz0hMSksdm9pZCAwPT09cyYmKHM9ITEpO3ZhciBsPXQuc2hhcGUubGVuZ3RoO2lmKGw8Myl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIklucHV0IHNob3VsZCBiZSBhdCBsZWFzdCAzRCwgYnV0IGlzIFwiK2wrXCJELlwiKTt2YXIgdSxjLHA9WzEsMF0uY29uY2F0KHJhbmdlKDIsbCkpO2lmKHQ9dHJhbnNwb3NlKHQscCksbnVsbCE9aSl0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcIlRoZSBybm4oKSBmdW5jdGlvbiBvZiB0aGUgZGVlcGxlYXJuLmpzIGJhY2tlbmQgZG9lcyBub3Qgc3VwcG9ydCBtYXNraW5nIHlldC5cIik7aWYobnVsbCE9YSl0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcIlRoZSBybm4oKSBmdW5jdG9pbiBvZiB0aGUgZGVlcGxlYXJuLmpzIGJhY2tlbmQgZG9lcyBub3Qgc3VwcG9ydCBjb25zdGFudHMgeWV0LlwiKTtvJiZjb25zb2xlLndhcm4oXCJCYWNrZW5kIHJubigpOiB0aGUgdW5yb2xsID0gdHJ1ZSBvcHRpb24gaXMgbm90IGFwcGxpY2FibGUgdG8gdGhlIGltcGVyYXRpdmUgZGVlcGxlYXJuLmpzIGJhY2tlbmQuXCIpLHImJih0PXJldmVyc2UodCwwKSk7Zm9yKHZhciBoPW4sZD10LnNoYXBlWzBdLGY9ZnVuY3Rpb24obil7dmFyIHI9c2xpY2VBbG9uZ0ZpcnN0QXhpcyh0LG4sMSk7cj1yLnJlc2hhcGUoci5zaGFwZS5zbGljZSgxKSk7dmFyIGk9dGlkeShmdW5jdGlvbigpe3JldHVybiBlKHIsaCl9KTtpZihjPWlbMF0scylpZigwPT09bil1PWMuZXhwYW5kRGltcygxKTtlbHNle3ZhciBhPWNvbmNhdChbdSxjLmV4cGFuZERpbXMoMSldLDEpO3UuZGlzcG9zZSgpLHU9YX1oPWlbMV19LGc9MDtnPGQ7KytnKWYoZyk7cmV0dXJuW2MsdSxoXX1zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoR2xvYmFsTWF4UG9vbGluZzJEKTt2YXIgUk5OPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG4scj1lLmNhbGwodGhpcyx0KXx8dGhpcztpZihudWxsPT10LmNlbGwpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJjZWxsIHByb3BlcnR5IGlzIG1pc3NpbmcgZm9yIHRoZSBjb25zdHJ1Y3RvciBvZiBSTk4uXCIpO2lmKG51bGw9PShuPUFycmF5LmlzQXJyYXkodC5jZWxsKT9uZXcgU3RhY2tlZFJOTkNlbGxzKHtjZWxsczp0LmNlbGx9KTp0LmNlbGwpLnN0YXRlU2l6ZSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlRoZSBSTk4gY2VsbCBzaG91bGQgaGF2ZSBhbiBhdHRyaWJ1dGUgYHN0YXRlU2l6ZWAgKHR1cGxlIG9mIGludGVnZXJzLCBvbmUgaW50ZWdlciBwZXIgUk5OIHN0YXRlKS5cIik7cmV0dXJuIHIuY2VsbD1uLHIucmV0dXJuU2VxdWVuY2VzPW51bGwhPXQucmV0dXJuU2VxdWVuY2VzJiZ0LnJldHVyblNlcXVlbmNlcyxyLnJldHVyblN0YXRlPW51bGwhPXQucmV0dXJuU3RhdGUmJnQucmV0dXJuU3RhdGUsci5nb0JhY2t3YXJkcz1udWxsIT10LmdvQmFja3dhcmRzJiZ0LmdvQmFja3dhcmRzLHIuX3N0YXRlZnVsPW51bGwhPXQuc3RhdGVmdWwmJnQuc3RhdGVmdWwsci51bnJvbGw9bnVsbCE9dC51bnJvbGwmJnQudW5yb2xsLHIuc3VwcG9ydHNNYXNraW5nPSEwLHIuaW5wdXRTcGVjPVtuZXcgSW5wdXRTcGVjKHtuZGltOjN9KV0sci5zdGF0ZVNwZWM9bnVsbCxyLnN0YXRlcz1udWxsLHIubnVtQ29uc3RhbnRzPW51bGwsci5rZXB0U3RhdGVzPVtdLHJ9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmdldFN0YXRlcz1mdW5jdGlvbigpe3JldHVybiBudWxsPT10aGlzLnN0YXRlcz9yYW5nZSgwLEFycmF5LmlzQXJyYXkodGhpcy5jZWxsLnN0YXRlU2l6ZSk/dGhpcy5jZWxsLnN0YXRlU2l6ZS5sZW5ndGg6MSkubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBudWxsfSk6dGhpcy5zdGF0ZXN9LHQucHJvdG90eXBlLnNldFN0YXRlcz1mdW5jdGlvbihlKXt0aGlzLnN0YXRlcz1lfSx0LnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGU9ZnVuY3Rpb24oZSl7aXNBcnJheU9mU2hhcGVzKGUpJiYoZT1lWzBdKSxlPWU7dmFyIHQ9dGhpcy5jZWxsLnN0YXRlU2l6ZTtBcnJheS5pc0FycmF5KHQpfHwodD1bdF0pO3ZhciBuLHI9dFswXTtpZihuPXRoaXMucmV0dXJuU2VxdWVuY2VzP1tlWzBdLGVbMV0scl06W2VbMF0scl0sdGhpcy5yZXR1cm5TdGF0ZSl7Zm9yKHZhciBpPVtdLGE9MCxvPXQ7YTxvLmxlbmd0aDthKyspe3ZhciBzPW9bYV07aS5wdXNoKFtlWzBdLHNdKX1yZXR1cm5bbl0uY29uY2F0KGkpfXJldHVybiBufSx0LnByb3RvdHlwZS5jb21wdXRlTWFzaz1mdW5jdGlvbihlLHQpe3Rocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwiY29tcHV0ZU1hc2sgaGFzIG5vdCBiZWVuIGltcGxlbWVudGVkIGZvciBSTk4geWV0XCIpfSx0LnByb3RvdHlwZS5idWlsZD1mdW5jdGlvbihlKXtpZihudWxsIT10aGlzLm51bUNvbnN0YW50cyl0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcIkNvbnN0YW50cyBzdXBwb3J0IGlzIG5vdCBpbXBsZW1lbnRlZCBpbiBSTk4geWV0LlwiKTtpc0FycmF5T2ZTaGFwZXMoZSkmJihlPWVbMF0pLGU9ZTt2YXIgdD10aGlzLnN0YXRlZnVsP2VbMF06bnVsbCxuPWVbZS5sZW5ndGgtMV07dGhpcy5pbnB1dFNwZWNbMF09bmV3IElucHV0U3BlYyh7c2hhcGU6W3QsbnVsbCxuXX0pO3ZhciByLGk9W2VbMF1dLmNvbmNhdChlLnNsaWNlKDIpKTtpZih0aGlzLmNlbGwuYnVpbGQoaSkscj1BcnJheS5pc0FycmF5KHRoaXMuY2VsbC5zdGF0ZVNpemUpP3RoaXMuY2VsbC5zdGF0ZVNpemU6W3RoaXMuY2VsbC5zdGF0ZVNpemVdLG51bGwhPXRoaXMuc3RhdGVTcGVjKXtpZighdXRpbC5hcnJheXNFcXVhbCh0aGlzLnN0YXRlU3BlYy5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUuc2hhcGVbZS5zaGFwZS5sZW5ndGgtMV19KSxyKSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkFuIGluaXRpYWxTdGF0ZSB3YXMgcGFzc2VkIHRoYXQgaXMgbm90IGNvbXBhdGlibGUgd2l0aCBjZWxsLnN0YXRlU2l6ZS4gUmVjZWl2ZWQgc3RhdGVTcGVjPVwiK3RoaXMuc3RhdGVTcGVjK1wiOyBIb3dldmVyIGNlbGwuc3RhdGVTaXplIGlzIFwiK3RoaXMuY2VsbC5zdGF0ZVNpemUpfWVsc2UgdGhpcy5zdGF0ZVNwZWM9ci5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBJbnB1dFNwZWMoe3NoYXBlOltudWxsLGVdfSl9KTt0aGlzLnN0YXRlZnVsJiZ0aGlzLnJlc2V0U3RhdGVzKCl9LHQucHJvdG90eXBlLnJlc2V0U3RhdGVzPWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpczt2b2lkIDA9PT10JiYodD0hMSksdGlkeShmdW5jdGlvbigpe2lmKCFuLnN0YXRlZnVsKXRocm93IG5ldyBBdHRyaWJ1dGVFcnJvcihcIkNhbm5vdCBjYWxsIHJlc2V0U3RhdGVzKCkgb24gYW4gUk5OIExheWVyIHRoYXQgaXMgbm90IHN0YXRlZnVsLlwiKTt2YXIgcj1uLmlucHV0U3BlY1swXS5zaGFwZVswXTtpZihudWxsPT1yKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiSWYgYW4gUk5OIGlzIHN0YXRlZnVsLCBpdCBuZWVkcyB0byBrbm93IGl0cyBiYXRjaCBzaXplLiBTcGVjaWZ5IHRoZSBiYXRjaCBzaXplIG9mIHlvdXIgaW5wdXQgdGVuc29yczogXFxuLSBJZiB1c2luZyBhIFNlcXVlbnRpYWwgbW9kZWwsIHNwZWNpZnkgdGhlIGJhdGNoIHNpemUgYnkgcGFzc2luZyBhIGBiYXRjaElucHV0U2hhcGVgIG9wdGlvbiB0byB5b3VyIGZpcnN0IGxheWVyLlxcbi0gSWYgdXNpbmcgdGhlIGZ1bmN0aW9uYWwgQVBJLCBzcGVjaWZ5IHRoZSBiYXRjaCBzaXplIGJ5IHBhc3NpbmcgYSBgYmF0Y2hTaGFwZWAgb3B0aW9uIHRvIHlvdXIgSW5wdXQgbGF5ZXIuXCIpO2lmKG51bGw9PW4uc3RhdGVzKUFycmF5LmlzQXJyYXkobi5jZWxsLnN0YXRlU2l6ZSk/bi5zdGF0ZXM9bi5jZWxsLnN0YXRlU2l6ZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIHplcm9zKFtyLGVdKX0pOm4uc3RhdGVzPVt6ZXJvcyhbcixuLmNlbGwuc3RhdGVTaXplXSldO2Vsc2UgaWYobnVsbD09ZSlkaXNwb3NlKG4uc3RhdGVzKSxudWxsIT1uLmtlcHRTdGF0ZXMmJihkaXNwb3NlKG4ua2VwdFN0YXRlcyksbi5rZXB0U3RhdGVzPVtdKSxBcnJheS5pc0FycmF5KG4uY2VsbC5zdGF0ZVNpemUpP24uc3RhdGVzPW4uY2VsbC5zdGF0ZVNpemUubWFwKGZ1bmN0aW9uKGUpe3JldHVybiB6ZXJvcyhbcixlXSl9KTpuLnN0YXRlc1swXT16ZXJvcyhbcixuLmNlbGwuc3RhdGVTaXplXSk7ZWxzZXtpZihBcnJheS5pc0FycmF5KGUpfHwoZT1bZV0pLGUubGVuZ3RoIT09bi5zdGF0ZXMubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiTGF5ZXIgXCIrbi5uYW1lK1wiIGV4cGVjdHMgXCIrbi5zdGF0ZXMubGVuZ3RoK1wiIHN0YXRlKHMpLCBidXQgaXQgcmVjZWl2ZWQgXCIrZS5sZW5ndGgrXCIgc3RhdGUgdmFsdWUocykuIElucHV0IHJlY2VpdmVkOiBcIitlKTshMD09PXQ/bi5rZXB0U3RhdGVzLnB1c2gobi5zdGF0ZXMuc2xpY2UoKSk6ZGlzcG9zZShuLnN0YXRlcyk7Zm9yKHZhciBpPTA7aTxuLnN0YXRlcy5sZW5ndGg7KytpKXt2YXIgYT1lW2ldLG89QXJyYXkuaXNBcnJheShuLmNlbGwuc3RhdGVTaXplKT9uLmNlbGwuc3RhdGVTaXplW2ldOm4uY2VsbC5zdGF0ZVNpemUscz1bcixvXTtpZighdXRpbC5hcnJheXNFcXVhbChhLnNoYXBlLHMpKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiU3RhdGUgXCIraStcIiBpcyBpbmNvbXBhdGlibGUgd2l0aCBsYXllciBcIituLm5hbWUrXCI6IGV4cGVjdGVkIHNoYXBlPVwiK3MrXCIsIHJlY2VpdmVkIHNoYXBlPVwiK2Euc2hhcGUpO24uc3RhdGVzW2ldPWF9fW4uc3RhdGVzLmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIGtlZXAoZSl9KX0pfSx0LnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbih0LG4pe3ZhciByPW51bGw9PW4/bnVsbDpuLmluaXRpYWxTdGF0ZSxpPW51bGw9PW4/bnVsbDpuLmNvbnN0YW50cztudWxsPT1uJiYobj17fSk7dmFyIGE9c3RhbmRhcmRpemVBcmdzKHQscixpLHRoaXMubnVtQ29uc3RhbnRzKTt0PWEuaW5wdXRzLHI9YS5pbml0aWFsU3RhdGUsaT1hLmNvbnN0YW50czt2YXIgbz1bXSxzPVtdO2lmKG51bGwhPXIpe24uaW5pdGlhbFN0YXRlPXIsbz1vLmNvbmNhdChyKSx0aGlzLnN0YXRlU3BlYz1bXTtmb3IodmFyIGw9MCx1PXI7bDx1Lmxlbmd0aDtsKyspe3ZhciBjPXVbbF07dGhpcy5zdGF0ZVNwZWMucHVzaChuZXcgSW5wdXRTcGVjKHtzaGFwZTpjLnNoYXBlfSkpfXM9cy5jb25jYXQodGhpcy5zdGF0ZVNwZWMpfWlmKG51bGwhPWkmJihuLmNvbnN0YW50cz1pLG89by5jb25jYXQoaSksdGhpcy5udW1Db25zdGFudHM9aS5sZW5ndGgpLG9bMF1pbnN0YW5jZW9mIFN5bWJvbGljVGVuc29yKXt2YXIgcD1bdF0uY29uY2F0KG8pLGg9dGhpcy5pbnB1dFNwZWMuY29uY2F0KHMpLGQ9dGhpcy5pbnB1dFNwZWM7dGhpcy5pbnB1dFNwZWM9aDt2YXIgZj1lLnByb3RvdHlwZS5hcHBseS5jYWxsKHRoaXMscCxuKTtyZXR1cm4gdGhpcy5pbnB1dFNwZWM9ZCxmfXJldHVybiBlLnByb3RvdHlwZS5hcHBseS5jYWxsKHRoaXMsdCxuKX0sdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXt2YXIgcj1udWxsPT10P251bGw6dC5tYXNrLGk9bnVsbD09dD9udWxsOnQudHJhaW5pbmcsYT1udWxsPT10P251bGw6dC5pbml0aWFsU3RhdGU7aWYoZT1nZXRFeGFjdGx5T25lVGVuc29yKGUpLG51bGw9PWEmJihhPW4uc3RhdGVmdWw/bi5zdGF0ZXM6bi5nZXRJbml0aWFsU3RhdGUoZSkpLG51bGwhPXIpdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJNYXNraW5nIGlzIG5vdCBpbXBsZW1lbnRlZCBmb3IgUk5OIHlldFwiKTt2YXIgbz1BcnJheS5pc0FycmF5KG4uY2VsbC5zdGF0ZVNpemUpP24uY2VsbC5zdGF0ZVNpemUubGVuZ3RoOjE7aWYoYS5sZW5ndGghPT1vKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiUk5OIExheWVyIGhhcyBcIitvK1wiIHN0YXRlKHMpIGJ1dCB3YXMgcGFzc2VkIFwiK2EubGVuZ3RoK1wiIGluaXRpYWwgc3RhdGUocykuXCIpO24udW5yb2xsJiZjb25zb2xlLndhcm4oXCJJZ25vcmluZyB1bnJvbGwgPSB0cnVlIGZvciBSTk4gbGF5ZXIsIGR1ZSB0byBpbXBlcmF0aXZlIGJhY2tlbmQuXCIpO3ZhciBzPXt0cmFpbmluZzppfSxsPXJubihmdW5jdGlvbihlLHQpe3ZhciByPW4uY2VsbC5jYWxsKFtlXS5jb25jYXQodCkscyk7cmV0dXJuW3JbMF0sci5zbGljZSgxKV19LGUsYSxuLmdvQmFja3dhcmRzLG51bGwsbnVsbCxuLnVucm9sbCxuLnJldHVyblNlcXVlbmNlcyksdT1sWzBdLGM9bFsxXSxwPWxbMl07bi5zdGF0ZWZ1bCYmbi5yZXNldFN0YXRlcyhwLGkpO3ZhciBoPW4ucmV0dXJuU2VxdWVuY2VzP2M6dTtyZXR1cm4gbi5yZXR1cm5TdGF0ZT9baF0uY29uY2F0KHApOmh9KX0sdC5wcm90b3R5cGUuZ2V0SW5pdGlhbFN0YXRlPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXt2YXIgbj16ZXJvcyhlLnNoYXBlKTtyZXR1cm4gbj1leHBhbmREaW1zKG49c3VtKG4sWzEsMl0pKSxBcnJheS5pc0FycmF5KHQuY2VsbC5zdGF0ZVNpemUpP3QuY2VsbC5zdGF0ZVNpemUubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlPjE/dGlsZSQxKG4sWzEsZV0pOm59KTp0LmNlbGwuc3RhdGVTaXplPjE/W3RpbGUkMShuLFsxLHQuY2VsbC5zdGF0ZVNpemVdKV06W25dfSl9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInRyYWluYWJsZVdlaWdodHNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudHJhaW5hYmxlP3RoaXMuY2VsbC50cmFpbmFibGVXZWlnaHRzOltdfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcIm5vblRyYWluYWJsZVdlaWdodHNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudHJhaW5hYmxlP3RoaXMuY2VsbC5ub25UcmFpbmFibGVXZWlnaHRzOnRoaXMuY2VsbC53ZWlnaHRzfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciB0PXtyZXR1cm5TZXF1ZW5jZXM6dGhpcy5yZXR1cm5TZXF1ZW5jZXMscmV0dXJuU3RhdGU6dGhpcy5yZXR1cm5TdGF0ZSxnb0JhY2t3YXJkczp0aGlzLmdvQmFja3dhcmRzLHN0YXRlZnVsOnRoaXMuc3RhdGVmdWwsdW5yb2xsOnRoaXMudW5yb2xsfTtudWxsIT10aGlzLm51bUNvbnN0YW50cyYmKHQubnVtQ29uc3RhbnRzPXRoaXMubnVtQ29uc3RhbnRzKTt2YXIgbj10aGlzLmNlbGwuZ2V0Q29uZmlnKCk7dC5jZWxsPXtjbGFzc05hbWU6dGhpcy5jZWxsLmdldENsYXNzTmFtZSgpLGNvbmZpZzpufTt2YXIgcj1lLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gT2JqZWN0LmFzc2lnbih0LHIpLHR9LHQuY2xhc3NOYW1lPVwiUk5OXCIsdH0oTGF5ZXIpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhSTk4pO3ZhciBSTk5DZWxsPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoKXtyZXR1cm4gbnVsbCE9PWUmJmUuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXJldHVybiBfX2V4dGVuZHModCxlKSx0fShMYXllciksU2ltcGxlUk5OQ2VsbD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzLHQpfHx0aGlzO3JldHVybiBuLkRFRkFVTFRfQUNUSVZBVElPTj1cInRhbmhcIixuLkRFRkFVTFRfS0VSTkVMX0lOSVRJQUxJWkVSPVwiZ2xvcm90Tm9ybWFsXCIsbi5ERUZBVUxUX1JFQ1VSUkVOVF9JTklUSUFMSVpFUj1cIm9ydGhvZ29uYWxcIixuLkRFRkFVTFRfQklBU19JTklUSUFMSVpFUj1cInplcm9zXCIsbi51bml0cz10LnVuaXRzLG4uYWN0aXZhdGlvbj1nZXRBY3RpdmF0aW9uKG51bGw9PXQuYWN0aXZhdGlvbj9uLkRFRkFVTFRfQUNUSVZBVElPTjp0LmFjdGl2YXRpb24pLG4udXNlQmlhcz1udWxsPT10LnVzZUJpYXN8fHQudXNlQmlhcyxuLmtlcm5lbEluaXRpYWxpemVyPWdldEluaXRpYWxpemVyKHQua2VybmVsSW5pdGlhbGl6ZXJ8fG4uREVGQVVMVF9LRVJORUxfSU5JVElBTElaRVIpLG4ucmVjdXJyZW50SW5pdGlhbGl6ZXI9Z2V0SW5pdGlhbGl6ZXIodC5yZWN1cnJlbnRJbml0aWFsaXplcnx8bi5ERUZBVUxUX1JFQ1VSUkVOVF9JTklUSUFMSVpFUiksbi5iaWFzSW5pdGlhbGl6ZXI9Z2V0SW5pdGlhbGl6ZXIodC5iaWFzSW5pdGlhbGl6ZXJ8fG4uREVGQVVMVF9CSUFTX0lOSVRJQUxJWkVSKSxuLmtlcm5lbFJlZ3VsYXJpemVyPWdldFJlZ3VsYXJpemVyKHQua2VybmVsUmVndWxhcml6ZXIpLG4ucmVjdXJyZW50UmVndWxhcml6ZXI9Z2V0UmVndWxhcml6ZXIodC5yZWN1cnJlbnRSZWd1bGFyaXplciksbi5iaWFzUmVndWxhcml6ZXI9Z2V0UmVndWxhcml6ZXIodC5iaWFzUmVndWxhcml6ZXIpLG4ua2VybmVsQ29uc3RyYWludD1nZXRDb25zdHJhaW50KHQua2VybmVsQ29uc3RyYWludCksbi5yZWN1cnJlbnRDb25zdHJhaW50PWdldENvbnN0cmFpbnQodC5yZWN1cnJlbnRDb25zdHJhaW50KSxuLmJpYXNDb25zdHJhaW50PWdldENvbnN0cmFpbnQodC5iaWFzQ29uc3RyYWludCksbi5kcm9wb3V0PW1pbiQxKFsxLG1heCQxKFswLG51bGw9PXQuZHJvcG91dD8wOnQuZHJvcG91dF0pXSksbi5yZWN1cnJlbnREcm9wb3V0PW1pbiQxKFsxLG1heCQxKFswLG51bGw9PXQucmVjdXJyZW50RHJvcG91dD8wOnQucmVjdXJyZW50RHJvcG91dF0pXSksbi5zdGF0ZVNpemU9bi51bml0cyxuLmRyb3BvdXRNYXNrPW51bGwsbi5yZWN1cnJlbnREcm9wb3V0TWFzaz1udWxsLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmJ1aWxkPWZ1bmN0aW9uKGUpe2U9Z2V0RXhhY3RseU9uZVNoYXBlKGUpLHRoaXMua2VybmVsPXRoaXMuYWRkV2VpZ2h0KFwia2VybmVsXCIsW2VbZS5sZW5ndGgtMV0sdGhpcy51bml0c10sbnVsbCx0aGlzLmtlcm5lbEluaXRpYWxpemVyLHRoaXMua2VybmVsUmVndWxhcml6ZXIsITAsdGhpcy5rZXJuZWxDb25zdHJhaW50KSx0aGlzLnJlY3VycmVudEtlcm5lbD10aGlzLmFkZFdlaWdodChcInJlY3VycmVudF9rZXJuZWxcIixbdGhpcy51bml0cyx0aGlzLnVuaXRzXSxudWxsLHRoaXMucmVjdXJyZW50SW5pdGlhbGl6ZXIsdGhpcy5yZWN1cnJlbnRSZWd1bGFyaXplciwhMCx0aGlzLnJlY3VycmVudENvbnN0cmFpbnQpLHRoaXMudXNlQmlhcz90aGlzLmJpYXM9dGhpcy5hZGRXZWlnaHQoXCJiaWFzXCIsW3RoaXMudW5pdHNdLG51bGwsdGhpcy5iaWFzSW5pdGlhbGl6ZXIsdGhpcy5iaWFzUmVndWxhcml6ZXIsITAsdGhpcy5iaWFzQ29uc3RyYWludCk6dGhpcy5iaWFzPW51bGwsdGhpcy5idWlsdD0hMH0sdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtpZigyIT09KGU9ZSkubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiU2ltcGxlUk5OQ2VsbCBleHBlY3RzIDIgaW5wdXQgVGVuc29ycywgZ290IFwiK2UubGVuZ3RoK1wiLlwiKTt2YXIgcj1lWzFdO2U9ZVswXTt2YXIgaSxhPW51bGwhPXQudHJhaW5pbmcmJnQudHJhaW5pbmc7MDxuLmRyb3BvdXQmJm4uZHJvcG91dDwxJiZudWxsPT1uLmRyb3BvdXRNYXNrJiYobi5kcm9wb3V0TWFzaz1nZW5lcmF0ZURyb3BvdXRNYXNrKGZ1bmN0aW9uKCl7cmV0dXJuIG9uZXNMaWtlKGUpfSxuLmRyb3BvdXQsYSkpLDA8bi5yZWN1cnJlbnREcm9wb3V0JiZuLnJlY3VycmVudERyb3BvdXQ8MSYmbnVsbD09bi5yZWN1cnJlbnREcm9wb3V0TWFzayYmKG4ucmVjdXJyZW50RHJvcG91dE1hc2s9Z2VuZXJhdGVEcm9wb3V0TWFzayhmdW5jdGlvbigpe3JldHVybiBvbmVzTGlrZShyKX0sbi5yZWN1cnJlbnREcm9wb3V0LGEpKTt2YXIgbz1uLmRyb3BvdXRNYXNrLHM9bi5yZWN1cnJlbnREcm9wb3V0TWFzaztpPWRvdChudWxsIT1vP211bChlLG8pOmUsbi5rZXJuZWwucmVhZCgpKSxudWxsIT1uLmJpYXMmJihpPWJpYXNBZGQoaSxuLmJpYXMucmVhZCgpKSksbnVsbCE9cyYmKHI9bXVsKHIscykpO3ZhciBsPWFkZChpLGRvdChyLG4ucmVjdXJyZW50S2VybmVsLnJlYWQoKSkpO3JldHVybiBudWxsIT1uLmFjdGl2YXRpb24mJihsPW4uYWN0aXZhdGlvbi5hcHBseShsKSksW2wsbF19KX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIHQ9e3VuaXRzOnRoaXMudW5pdHMsYWN0aXZhdGlvbjpzZXJpYWxpemVBY3RpdmF0aW9uKHRoaXMuYWN0aXZhdGlvbiksdXNlQmlhczp0aGlzLnVzZUJpYXMsa2VybmVsSW5pdGlhbGl6ZXI6c2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5rZXJuZWxJbml0aWFsaXplcikscmVjdXJyZW50SW5pdGlhbGl6ZXI6c2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5yZWN1cnJlbnRJbml0aWFsaXplciksYmlhc0luaXRpYWxpemVyOnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMuYmlhc0luaXRpYWxpemVyKSxrZXJuZWxSZWd1bGFyaXplcjpzZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmtlcm5lbFJlZ3VsYXJpemVyKSxyZWN1cnJlbnRSZWd1bGFyaXplcjpzZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLnJlY3VycmVudFJlZ3VsYXJpemVyKSxiaWFzUmVndWxhcml6ZXI6c2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5iaWFzUmVndWxhcml6ZXIpLGFjdGl2aXR5UmVndWxhcml6ZXI6c2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5hY3Rpdml0eVJlZ3VsYXJpemVyKSxrZXJuZWxDb25zdHJhaW50OnNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5rZXJuZWxDb25zdHJhaW50KSxyZWN1cnJlbnRDb25zdHJhaW50OnNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5yZWN1cnJlbnRDb25zdHJhaW50KSxiaWFzQ29uc3RyYWludDpzZXJpYWxpemVDb25zdHJhaW50KHRoaXMuYmlhc0NvbnN0cmFpbnQpLGRyb3BvdXQ6dGhpcy5kcm9wb3V0LHJlY3VycmVudERyb3BvdXQ6dGhpcy5yZWN1cnJlbnREcm9wb3V0fSxuPWUucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBPYmplY3QuYXNzaWduKHQsbiksdH0sdC5jbGFzc05hbWU9XCJTaW1wbGVSTk5DZWxsXCIsdH0oUk5OQ2VsbCk7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKFNpbXBsZVJOTkNlbGwpO3ZhciBTaW1wbGVSTk49ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXtyZXR1cm4gdC5jZWxsPW5ldyBTaW1wbGVSTk5DZWxsKHQpLGUuY2FsbCh0aGlzLHQpfHx0aGlzfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKHQsbil7dmFyIHI9dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe251bGwhPXIuY2VsbC5kcm9wb3V0TWFzayYmKGRpc3Bvc2Uoci5jZWxsLmRyb3BvdXRNYXNrKSxyLmNlbGwuZHJvcG91dE1hc2s9bnVsbCksbnVsbCE9ci5jZWxsLnJlY3VycmVudERyb3BvdXRNYXNrJiYoZGlzcG9zZShyLmNlbGwucmVjdXJyZW50RHJvcG91dE1hc2spLHIuY2VsbC5yZWN1cnJlbnREcm9wb3V0TWFzaz1udWxsKTt2YXIgaT1udWxsPT1uP251bGw6bi5tYXNrLGE9bnVsbD09bj9udWxsOm4udHJhaW5pbmcsbz1udWxsPT1uP251bGw6bi5pbml0aWFsU3RhdGU7cmV0dXJuIGUucHJvdG90eXBlLmNhbGwuY2FsbChyLHQse21hc2s6aSx0cmFpbmluZzphLGluaXRpYWxTdGF0ZTpvfSl9KX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwidW5pdHNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC51bml0c30sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJhY3RpdmF0aW9uXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwuYWN0aXZhdGlvbn0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJ1c2VCaWFzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwudXNlQmlhc30sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJrZXJuZWxJbml0aWFsaXplclwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLmtlcm5lbEluaXRpYWxpemVyfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInJlY3VycmVudEluaXRpYWxpemVyXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwucmVjdXJyZW50SW5pdGlhbGl6ZXJ9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwiYmlhc0luaXRpYWxpemVyXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwuYmlhc0luaXRpYWxpemVyfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImtlcm5lbFJlZ3VsYXJpemVyXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwua2VybmVsUmVndWxhcml6ZXJ9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwicmVjdXJyZW50UmVndWxhcml6ZXJcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5yZWN1cnJlbnRSZWd1bGFyaXplcn0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJiaWFzUmVndWxhcml6ZXJcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5iaWFzUmVndWxhcml6ZXJ9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwia2VybmVsQ29uc3RyYWludFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLmtlcm5lbENvbnN0cmFpbnR9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwicmVjdXJyZW50Q29uc3RyYWludFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLnJlY3VycmVudENvbnN0cmFpbnR9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwiYmlhc0NvbnN0cmFpbnRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5iaWFzQ29uc3RyYWludH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJkcm9wb3V0XCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwuZHJvcG91dH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJyZWN1cnJlbnREcm9wb3V0XCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwucmVjdXJyZW50RHJvcG91dH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD17dW5pdHM6dGhpcy51bml0cyxhY3RpdmF0aW9uOnNlcmlhbGl6ZUFjdGl2YXRpb24odGhpcy5hY3RpdmF0aW9uKSx1c2VCaWFzOnRoaXMudXNlQmlhcyxrZXJuZWxJbml0aWFsaXplcjpzZXJpYWxpemVJbml0aWFsaXplcih0aGlzLmtlcm5lbEluaXRpYWxpemVyKSxyZWN1cnJlbnRJbml0aWFsaXplcjpzZXJpYWxpemVJbml0aWFsaXplcih0aGlzLnJlY3VycmVudEluaXRpYWxpemVyKSxiaWFzSW5pdGlhbGl6ZXI6c2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5iaWFzSW5pdGlhbGl6ZXIpLGtlcm5lbFJlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMua2VybmVsUmVndWxhcml6ZXIpLHJlY3VycmVudFJlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMucmVjdXJyZW50UmVndWxhcml6ZXIpLGJpYXNSZWd1bGFyaXplcjpzZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmJpYXNSZWd1bGFyaXplciksYWN0aXZpdHlSZWd1bGFyaXplcjpzZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmFjdGl2aXR5UmVndWxhcml6ZXIpLGtlcm5lbENvbnN0cmFpbnQ6c2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmtlcm5lbENvbnN0cmFpbnQpLHJlY3VycmVudENvbnN0cmFpbnQ6c2VyaWFsaXplQ29uc3RyYWludCh0aGlzLnJlY3VycmVudENvbnN0cmFpbnQpLGJpYXNDb25zdHJhaW50OnNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5iaWFzQ29uc3RyYWludCksZHJvcG91dDp0aGlzLmRyb3BvdXQscmVjdXJyZW50RHJvcG91dDp0aGlzLnJlY3VycmVudERyb3BvdXR9LG49ZS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIGRlbGV0ZSBuLmNlbGwsT2JqZWN0LmFzc2lnbih0LG4pLHR9LHQuY2xhc3NOYW1lPVwiU2ltcGxlUk5OXCIsdH0oUk5OKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoU2ltcGxlUk5OKTt2YXIgR1JVQ2VsbD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzLHQpfHx0aGlzO3JldHVybiBuLkRFRkFVTFRfQUNUSVZBVElPTj1cInRhbmhcIixuLkRFRkFVTFRfUkVDVVJSRU5UX0FDVElWQVRJT049XCJoYXJkU2lnbW9pZFwiLG4uREVGQVVMVF9LRVJORUxfSU5JVElBTElaRVI9XCJnbG9yb3ROb3JtYWxcIixuLkRFRkFVTFRfUkVDVVJSRU5UX0lOSVRJQUxJWkVSPVwib3J0aG9nb25hbFwiLG4uREVGQVVMVF9CSUFTX0lOSVRJQUxJWkVSPVwiemVyb3NcIixuLnVuaXRzPXQudW5pdHMsbi5hY3RpdmF0aW9uPWdldEFjdGl2YXRpb24odm9pZCAwPT09dC5hY3RpdmF0aW9uP24uREVGQVVMVF9BQ1RJVkFUSU9OOnQuYWN0aXZhdGlvbiksbi5yZWN1cnJlbnRBY3RpdmF0aW9uPWdldEFjdGl2YXRpb24odm9pZCAwPT09dC5yZWN1cnJlbnRBY3RpdmF0aW9uP24uREVGQVVMVF9SRUNVUlJFTlRfQUNUSVZBVElPTjp0LnJlY3VycmVudEFjdGl2YXRpb24pLG4udXNlQmlhcz1udWxsPT10LnVzZUJpYXN8fHQudXNlQmlhcyxuLmtlcm5lbEluaXRpYWxpemVyPWdldEluaXRpYWxpemVyKHQua2VybmVsSW5pdGlhbGl6ZXJ8fG4uREVGQVVMVF9LRVJORUxfSU5JVElBTElaRVIpLG4ucmVjdXJyZW50SW5pdGlhbGl6ZXI9Z2V0SW5pdGlhbGl6ZXIodC5yZWN1cnJlbnRJbml0aWFsaXplcnx8bi5ERUZBVUxUX1JFQ1VSUkVOVF9JTklUSUFMSVpFUiksbi5iaWFzSW5pdGlhbGl6ZXI9Z2V0SW5pdGlhbGl6ZXIodC5iaWFzSW5pdGlhbGl6ZXJ8fG4uREVGQVVMVF9CSUFTX0lOSVRJQUxJWkVSKSxuLmtlcm5lbFJlZ3VsYXJpemVyPWdldFJlZ3VsYXJpemVyKHQua2VybmVsUmVndWxhcml6ZXIpLG4ucmVjdXJyZW50UmVndWxhcml6ZXI9Z2V0UmVndWxhcml6ZXIodC5yZWN1cnJlbnRSZWd1bGFyaXplciksbi5iaWFzUmVndWxhcml6ZXI9Z2V0UmVndWxhcml6ZXIodC5iaWFzUmVndWxhcml6ZXIpLG4ua2VybmVsQ29uc3RyYWludD1nZXRDb25zdHJhaW50KHQua2VybmVsQ29uc3RyYWludCksbi5yZWN1cnJlbnRDb25zdHJhaW50PWdldENvbnN0cmFpbnQodC5yZWN1cnJlbnRDb25zdHJhaW50KSxuLmJpYXNDb25zdHJhaW50PWdldENvbnN0cmFpbnQodC5iaWFzQ29uc3RyYWludCksbi5kcm9wb3V0PW1pbiQxKFsxLG1heCQxKFswLG51bGw9PXQuZHJvcG91dD8wOnQuZHJvcG91dF0pXSksbi5yZWN1cnJlbnREcm9wb3V0PW1pbiQxKFsxLG1heCQxKFswLG51bGw9PXQucmVjdXJyZW50RHJvcG91dD8wOnQucmVjdXJyZW50RHJvcG91dF0pXSksbi5pbXBsZW1lbnRhdGlvbj10LmltcGxlbWVudGF0aW9uLG4uc3RhdGVTaXplPW4udW5pdHMsbi5kcm9wb3V0TWFzaz1udWxsLG4ucmVjdXJyZW50RHJvcG91dE1hc2s9bnVsbCxufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5idWlsZD1mdW5jdGlvbihlKXt2YXIgdD0oZT1nZXRFeGFjdGx5T25lU2hhcGUoZSkpW2UubGVuZ3RoLTFdO3RoaXMua2VybmVsPXRoaXMuYWRkV2VpZ2h0KFwia2VybmVsXCIsW3QsMyp0aGlzLnVuaXRzXSxudWxsLHRoaXMua2VybmVsSW5pdGlhbGl6ZXIsdGhpcy5rZXJuZWxSZWd1bGFyaXplciwhMCx0aGlzLmtlcm5lbENvbnN0cmFpbnQpLHRoaXMucmVjdXJyZW50S2VybmVsPXRoaXMuYWRkV2VpZ2h0KFwicmVjdXJyZW50X2tlcm5lbFwiLFt0aGlzLnVuaXRzLDMqdGhpcy51bml0c10sbnVsbCx0aGlzLnJlY3VycmVudEluaXRpYWxpemVyLHRoaXMucmVjdXJyZW50UmVndWxhcml6ZXIsITAsdGhpcy5yZWN1cnJlbnRDb25zdHJhaW50KSx0aGlzLnVzZUJpYXM/dGhpcy5iaWFzPXRoaXMuYWRkV2VpZ2h0KFwiYmlhc1wiLFszKnRoaXMudW5pdHNdLG51bGwsdGhpcy5iaWFzSW5pdGlhbGl6ZXIsdGhpcy5iaWFzUmVndWxhcml6ZXIsITAsdGhpcy5iaWFzQ29uc3RyYWludCk6dGhpcy5iaWFzPW51bGwsdGhpcy5idWlsdD0hMH0sdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtpZigyIT09KGU9ZSkubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiR1JVQ2VsbCBleHBlY3RzIDIgaW5wdXQgVGVuc29ycyAoaW5wdXRzLCBoLCBjKSwgZ290IFwiK2UubGVuZ3RoK1wiLlwiKTt2YXIgcj1udWxsIT10LnRyYWluaW5nJiZ0LnRyYWluaW5nLGk9ZVsxXTtlPWVbMF0sMDxuLmRyb3BvdXQmJm4uZHJvcG91dDwxJiZudWxsPT1uLmRyb3BvdXRNYXNrJiYobi5kcm9wb3V0TWFzaz1nZW5lcmF0ZURyb3BvdXRNYXNrKGZ1bmN0aW9uKCl7cmV0dXJuIG9uZXNMaWtlKGUpfSxuLmRyb3BvdXQsciwzKSksMDxuLnJlY3VycmVudERyb3BvdXQmJm4ucmVjdXJyZW50RHJvcG91dDwxJiZudWxsPT1uLnJlY3VycmVudERyb3BvdXRNYXNrJiYobi5yZWN1cnJlbnREcm9wb3V0TWFzaz1nZW5lcmF0ZURyb3BvdXRNYXNrKGZ1bmN0aW9uKCl7cmV0dXJuIG9uZXNMaWtlKGkpfSxuLnJlY3VycmVudERyb3BvdXQsciwzKSk7dmFyIGEsbyxzLGw9bi5kcm9wb3V0TWFzayx1PW4ucmVjdXJyZW50RHJvcG91dE1hc2s7MDxuLmRyb3BvdXQmJm4uZHJvcG91dDwxJiYoZT1tdWwoZSxsWzBdKSk7dmFyIGM9ZG90KGUsbi5rZXJuZWwucmVhZCgpKTtuLnVzZUJpYXMmJihjPWJpYXNBZGQoYyxuLmJpYXMucmVhZCgpKSksMDxuLnJlY3VycmVudERyb3BvdXQmJm4ucmVjdXJyZW50RHJvcG91dDwxJiYoaT1tdWwoaSx1WzBdKSk7dmFyIHA9bi5yZWN1cnJlbnRLZXJuZWwucmVhZCgpLGg9c3BsaXQocCxbMipuLnVuaXRzLG4udW5pdHNdLHAucmFuay0xKSxkPWhbMF0sZj1oWzFdLGc9ZG90KGksZCksbT1zcGxpdChjLDMsYy5yYW5rLTEpLHk9bVswXSx2PW1bMV0sYj1tWzJdLHc9c3BsaXQoZywyLGcucmFuay0xKSx6PXdbMF0sUz13WzFdO2E9bi5yZWN1cnJlbnRBY3RpdmF0aW9uLmFwcGx5KGFkZCh5LHopKSxvPW4ucmVjdXJyZW50QWN0aXZhdGlvbi5hcHBseShhZGQodixTKSk7dmFyIEk9ZG90KG11bChvLGkpLGYpO3M9bi5hY3RpdmF0aW9uLmFwcGx5KGFkZChiLEkpKTt2YXIgTj1hZGQobXVsKGEsaSksbXVsKGFkZChnZXRTY2FsYXIoMSksbmVnKGEpKSxzKSk7cmV0dXJuW04sTl19KX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIHQ9e3VuaXRzOnRoaXMudW5pdHMsYWN0aXZhdGlvbjpzZXJpYWxpemVBY3RpdmF0aW9uKHRoaXMuYWN0aXZhdGlvbikscmVjdXJyZW50QWN0aXZhdGlvbjpzZXJpYWxpemVBY3RpdmF0aW9uKHRoaXMucmVjdXJyZW50QWN0aXZhdGlvbiksdXNlQmlhczp0aGlzLnVzZUJpYXMsa2VybmVsSW5pdGlhbGl6ZXI6c2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5rZXJuZWxJbml0aWFsaXplcikscmVjdXJyZW50SW5pdGlhbGl6ZXI6c2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5yZWN1cnJlbnRJbml0aWFsaXplciksYmlhc0luaXRpYWxpemVyOnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMuYmlhc0luaXRpYWxpemVyKSxrZXJuZWxSZWd1bGFyaXplcjpzZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmtlcm5lbFJlZ3VsYXJpemVyKSxyZWN1cnJlbnRSZWd1bGFyaXplcjpzZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLnJlY3VycmVudFJlZ3VsYXJpemVyKSxiaWFzUmVndWxhcml6ZXI6c2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5iaWFzUmVndWxhcml6ZXIpLGFjdGl2aXR5UmVndWxhcml6ZXI6c2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5hY3Rpdml0eVJlZ3VsYXJpemVyKSxrZXJuZWxDb25zdHJhaW50OnNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5rZXJuZWxDb25zdHJhaW50KSxyZWN1cnJlbnRDb25zdHJhaW50OnNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5yZWN1cnJlbnRDb25zdHJhaW50KSxiaWFzQ29uc3RyYWludDpzZXJpYWxpemVDb25zdHJhaW50KHRoaXMuYmlhc0NvbnN0cmFpbnQpLGRyb3BvdXQ6dGhpcy5kcm9wb3V0LHJlY3VycmVudERyb3BvdXQ6dGhpcy5yZWN1cnJlbnREcm9wb3V0LGltcGxlbWVudGF0aW9uOnRoaXMuaW1wbGVtZW50YXRpb259LG49ZS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIE9iamVjdC5hc3NpZ24odCxuKSx0fSx0LmNsYXNzTmFtZT1cIkdSVUNlbGxcIix0fShSTk5DZWxsKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoR1JVQ2VsbCk7dmFyIEdSVT1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3JldHVybiAwPT09dC5pbXBsZW1lbnRhdGlvbiYmY29uc29sZS53YXJuKFwiYGltcGxlbWVudGF0aW9uPTBgIGhhcyBiZWVuIGRlcHJlY2F0ZWQsIGFuZCBub3cgZGVmYXVsdHMgdG8gYGltcGxlbWVudGF0aW9uPTFgLiBQbGVhc2UgdXBkYXRlIHlvdXIgbGF5ZXIgY2FsbC5cIiksdC5jZWxsPW5ldyBHUlVDZWxsKHQpLGUuY2FsbCh0aGlzLHQpfHx0aGlzfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKHQsbil7dmFyIHI9dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe251bGwhPXIuY2VsbC5kcm9wb3V0TWFzayYmKGRpc3Bvc2Uoci5jZWxsLmRyb3BvdXRNYXNrKSxyLmNlbGwuZHJvcG91dE1hc2s9bnVsbCksbnVsbCE9ci5jZWxsLnJlY3VycmVudERyb3BvdXRNYXNrJiYoZGlzcG9zZShyLmNlbGwucmVjdXJyZW50RHJvcG91dE1hc2spLHIuY2VsbC5yZWN1cnJlbnREcm9wb3V0TWFzaz1udWxsKTt2YXIgaT1udWxsPT1uP251bGw6bi5tYXNrLGE9bnVsbD09bj9udWxsOm4udHJhaW5pbmcsbz1udWxsPT1uP251bGw6bi5pbml0aWFsU3RhdGU7cmV0dXJuIGUucHJvdG90eXBlLmNhbGwuY2FsbChyLHQse21hc2s6aSx0cmFpbmluZzphLGluaXRpYWxTdGF0ZTpvfSl9KX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwidW5pdHNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC51bml0c30sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJhY3RpdmF0aW9uXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwuYWN0aXZhdGlvbn0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJyZWN1cnJlbnRBY3RpdmF0aW9uXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwucmVjdXJyZW50QWN0aXZhdGlvbn0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJ1c2VCaWFzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwudXNlQmlhc30sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJrZXJuZWxJbml0aWFsaXplclwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLmtlcm5lbEluaXRpYWxpemVyfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInJlY3VycmVudEluaXRpYWxpemVyXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwucmVjdXJyZW50SW5pdGlhbGl6ZXJ9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwiYmlhc0luaXRpYWxpemVyXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwuYmlhc0luaXRpYWxpemVyfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImtlcm5lbFJlZ3VsYXJpemVyXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwua2VybmVsUmVndWxhcml6ZXJ9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwicmVjdXJyZW50UmVndWxhcml6ZXJcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5yZWN1cnJlbnRSZWd1bGFyaXplcn0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJiaWFzUmVndWxhcml6ZXJcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5iaWFzUmVndWxhcml6ZXJ9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwia2VybmVsQ29uc3RyYWludFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLmtlcm5lbENvbnN0cmFpbnR9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwicmVjdXJyZW50Q29uc3RyYWludFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLnJlY3VycmVudENvbnN0cmFpbnR9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwiYmlhc0NvbnN0cmFpbnRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5iaWFzQ29uc3RyYWludH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJkcm9wb3V0XCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwuZHJvcG91dH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJyZWN1cnJlbnREcm9wb3V0XCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwucmVjdXJyZW50RHJvcG91dH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJpbXBsZW1lbnRhdGlvblwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLmltcGxlbWVudGF0aW9ufSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciB0PXt1bml0czp0aGlzLnVuaXRzLGFjdGl2YXRpb246c2VyaWFsaXplQWN0aXZhdGlvbih0aGlzLmFjdGl2YXRpb24pLHJlY3VycmVudEFjdGl2YXRpb246c2VyaWFsaXplQWN0aXZhdGlvbih0aGlzLnJlY3VycmVudEFjdGl2YXRpb24pLHVzZUJpYXM6dGhpcy51c2VCaWFzLGtlcm5lbEluaXRpYWxpemVyOnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMua2VybmVsSW5pdGlhbGl6ZXIpLHJlY3VycmVudEluaXRpYWxpemVyOnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMucmVjdXJyZW50SW5pdGlhbGl6ZXIpLGJpYXNJbml0aWFsaXplcjpzZXJpYWxpemVJbml0aWFsaXplcih0aGlzLmJpYXNJbml0aWFsaXplciksa2VybmVsUmVndWxhcml6ZXI6c2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5rZXJuZWxSZWd1bGFyaXplcikscmVjdXJyZW50UmVndWxhcml6ZXI6c2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5yZWN1cnJlbnRSZWd1bGFyaXplciksYmlhc1JlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYmlhc1JlZ3VsYXJpemVyKSxhY3Rpdml0eVJlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYWN0aXZpdHlSZWd1bGFyaXplciksa2VybmVsQ29uc3RyYWludDpzZXJpYWxpemVDb25zdHJhaW50KHRoaXMua2VybmVsQ29uc3RyYWludCkscmVjdXJyZW50Q29uc3RyYWludDpzZXJpYWxpemVDb25zdHJhaW50KHRoaXMucmVjdXJyZW50Q29uc3RyYWludCksYmlhc0NvbnN0cmFpbnQ6c2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmJpYXNDb25zdHJhaW50KSxkcm9wb3V0OnRoaXMuZHJvcG91dCxyZWN1cnJlbnREcm9wb3V0OnRoaXMucmVjdXJyZW50RHJvcG91dCxpbXBsZW1lbnRhdGlvbjp0aGlzLmltcGxlbWVudGF0aW9ufSxuPWUucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBkZWxldGUgbi5jZWxsLE9iamVjdC5hc3NpZ24odCxuKSx0fSx0LmZyb21Db25maWc9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gMD09PXQuaW1wbG1lbnRhdGlvbiYmKHQuaW1wbGVtZW50YXRpb249MSksbmV3IGUodCl9LHQuY2xhc3NOYW1lPVwiR1JVXCIsdH0oUk5OKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoR1JVKTt2YXIgTFNUTUNlbGw9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyx0KXx8dGhpcztyZXR1cm4gbi5ERUZBVUxUX0FDVElWQVRJT049XCJ0YW5oXCIsbi5ERUZBVUxUX1JFQ1VSUkVOVF9BQ1RJVkFUSU9OPVwiaGFyZFNpZ21vaWRcIixuLkRFRkFVTFRfS0VSTkVMX0lOSVRJQUxJWkVSPVwiZ2xvcm90Tm9ybWFsXCIsbi5ERUZBVUxUX1JFQ1VSUkVOVF9JTklUSUFMSVpFUj1cIm9ydGhvZ29uYWxcIixuLkRFRkFVTFRfQklBU19JTklUSUFMSVpFUj1cInplcm9zXCIsbi51bml0cz10LnVuaXRzLG4uYWN0aXZhdGlvbj1nZXRBY3RpdmF0aW9uKHZvaWQgMD09PXQuYWN0aXZhdGlvbj9uLkRFRkFVTFRfQUNUSVZBVElPTjp0LmFjdGl2YXRpb24pLG4ucmVjdXJyZW50QWN0aXZhdGlvbj1nZXRBY3RpdmF0aW9uKHZvaWQgMD09PXQucmVjdXJyZW50QWN0aXZhdGlvbj9uLkRFRkFVTFRfUkVDVVJSRU5UX0FDVElWQVRJT046dC5yZWN1cnJlbnRBY3RpdmF0aW9uKSxuLnVzZUJpYXM9bnVsbD09dC51c2VCaWFzfHx0LnVzZUJpYXMsbi5rZXJuZWxJbml0aWFsaXplcj1nZXRJbml0aWFsaXplcih0Lmtlcm5lbEluaXRpYWxpemVyfHxuLkRFRkFVTFRfS0VSTkVMX0lOSVRJQUxJWkVSKSxuLnJlY3VycmVudEluaXRpYWxpemVyPWdldEluaXRpYWxpemVyKHQucmVjdXJyZW50SW5pdGlhbGl6ZXJ8fG4uREVGQVVMVF9SRUNVUlJFTlRfSU5JVElBTElaRVIpLG4uYmlhc0luaXRpYWxpemVyPWdldEluaXRpYWxpemVyKHQuYmlhc0luaXRpYWxpemVyfHxuLkRFRkFVTFRfQklBU19JTklUSUFMSVpFUiksbi51bml0Rm9yZ2V0Qmlhcz10LnVuaXRGb3JnZXRCaWFzLG4ua2VybmVsUmVndWxhcml6ZXI9Z2V0UmVndWxhcml6ZXIodC5rZXJuZWxSZWd1bGFyaXplciksbi5yZWN1cnJlbnRSZWd1bGFyaXplcj1nZXRSZWd1bGFyaXplcih0LnJlY3VycmVudFJlZ3VsYXJpemVyKSxuLmJpYXNSZWd1bGFyaXplcj1nZXRSZWd1bGFyaXplcih0LmJpYXNSZWd1bGFyaXplciksbi5rZXJuZWxDb25zdHJhaW50PWdldENvbnN0cmFpbnQodC5rZXJuZWxDb25zdHJhaW50KSxuLnJlY3VycmVudENvbnN0cmFpbnQ9Z2V0Q29uc3RyYWludCh0LnJlY3VycmVudENvbnN0cmFpbnQpLG4uYmlhc0NvbnN0cmFpbnQ9Z2V0Q29uc3RyYWludCh0LmJpYXNDb25zdHJhaW50KSxuLmRyb3BvdXQ9bWluJDEoWzEsbWF4JDEoWzAsbnVsbD09dC5kcm9wb3V0PzA6dC5kcm9wb3V0XSldKSxuLnJlY3VycmVudERyb3BvdXQ9bWluJDEoWzEsbWF4JDEoWzAsbnVsbD09dC5yZWN1cnJlbnREcm9wb3V0PzA6dC5yZWN1cnJlbnREcm9wb3V0XSldKSxuLmltcGxlbWVudGF0aW9uPXQuaW1wbGVtZW50YXRpb24sbi5zdGF0ZVNpemU9W24udW5pdHMsbi51bml0c10sbi5kcm9wb3V0TWFzaz1udWxsLG4ucmVjdXJyZW50RHJvcG91dE1hc2s9bnVsbCxufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5idWlsZD1mdW5jdGlvbihlKXt2YXIgdCxuLHI9KGU9Z2V0RXhhY3RseU9uZVNoYXBlKGUpKVtlLmxlbmd0aC0xXTtpZih0aGlzLmtlcm5lbD10aGlzLmFkZFdlaWdodChcImtlcm5lbFwiLFtyLDQqdGhpcy51bml0c10sbnVsbCx0aGlzLmtlcm5lbEluaXRpYWxpemVyLHRoaXMua2VybmVsUmVndWxhcml6ZXIsITAsdGhpcy5rZXJuZWxDb25zdHJhaW50KSx0aGlzLnJlY3VycmVudEtlcm5lbD10aGlzLmFkZFdlaWdodChcInJlY3VycmVudF9rZXJuZWxcIixbdGhpcy51bml0cyw0KnRoaXMudW5pdHNdLG51bGwsdGhpcy5yZWN1cnJlbnRJbml0aWFsaXplcix0aGlzLnJlY3VycmVudFJlZ3VsYXJpemVyLCEwLHRoaXMucmVjdXJyZW50Q29uc3RyYWludCksdGhpcy51c2VCaWFzKXtpZih0aGlzLnVuaXRGb3JnZXRCaWFzKXt2YXIgaT10aGlzLmJpYXNJbml0aWFsaXplcixhPXRoaXMudW5pdHM7dD1uZXcoKG49ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe3JldHVybiBudWxsIT09ZSYmZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKGUsdCl7dmFyIG49aS5hcHBseShbYV0pLHI9KG5ldyBPbmVzKS5hcHBseShbYV0pLG89aS5hcHBseShbMiphXSk7cmV0dXJuIGNvbmNhdEFsb25nRmlyc3RBeGlzKGNvbmNhdEFsb25nRmlyc3RBeGlzKG4sciksbyl9LHR9KEluaXRpYWxpemVyKSkuY2xhc3NOYW1lPVwiQ3VzdG9tSW5pdFwiLG4pfWVsc2UgdD10aGlzLmJpYXNJbml0aWFsaXplcjt0aGlzLmJpYXM9dGhpcy5hZGRXZWlnaHQoXCJiaWFzXCIsWzQqdGhpcy51bml0c10sbnVsbCx0LHRoaXMuYmlhc1JlZ3VsYXJpemVyLCEwLHRoaXMuYmlhc0NvbnN0cmFpbnQpfWVsc2UgdGhpcy5iaWFzPW51bGw7dGhpcy5idWlsdD0hMH0sdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXt2YXIgcj1udWxsIT10LnRyYWluaW5nJiZ0LnRyYWluaW5nO2lmKDMhPT0oZT1lKS5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJMU1RNQ2VsbCBleHBlY3RzIDMgaW5wdXQgVGVuc29ycyAoaW5wdXRzLCBoLCBjKSwgZ290IFwiK2UubGVuZ3RoK1wiLlwiKTt2YXIgaT1lWzFdLGE9ZVsyXTtlPWVbMF0sMDxuLmRyb3BvdXQmJm4uZHJvcG91dDwxJiZudWxsPT1uLmRyb3BvdXRNYXNrJiYobi5kcm9wb3V0TWFzaz1nZW5lcmF0ZURyb3BvdXRNYXNrKGZ1bmN0aW9uKCl7cmV0dXJuIG9uZXNMaWtlKGUpfSxuLmRyb3BvdXQsciw0KSksMDxuLnJlY3VycmVudERyb3BvdXQmJm4ucmVjdXJyZW50RHJvcG91dDwxJiZudWxsPT1uLnJlY3VycmVudERyb3BvdXRNYXNrJiYobi5yZWN1cnJlbnREcm9wb3V0TWFzaz1nZW5lcmF0ZURyb3BvdXRNYXNrKGZ1bmN0aW9uKCl7cmV0dXJuIG9uZXNMaWtlKGkpfSxuLnJlY3VycmVudERyb3BvdXQsciw0KSk7dmFyIG8scyxsLHUsYz1uLmRyb3BvdXRNYXNrLHA9bi5yZWN1cnJlbnREcm9wb3V0TWFzazswPG4uZHJvcG91dCYmbi5kcm9wb3V0PDEmJihlPW11bChlLGNbMF0pKTt2YXIgaD1kb3QoZSxuLmtlcm5lbC5yZWFkKCkpOzA8bi5yZWN1cnJlbnREcm9wb3V0JiZuLnJlY3VycmVudERyb3BvdXQ8MSYmKGk9bXVsKGkscFswXSkpLGg9YWRkKGgsZG90KGksbi5yZWN1cnJlbnRLZXJuZWwucmVhZCgpKSksbi51c2VCaWFzJiYoaD1iaWFzQWRkKGgsbi5iaWFzLnJlYWQoKSkpO3ZhciBkPXNwbGl0KGgsNCxoLnJhbmstMSksZj1kWzBdLGc9ZFsxXSxtPWRbMl0seT1kWzNdO289bi5yZWN1cnJlbnRBY3RpdmF0aW9uLmFwcGx5KGYpLHM9bi5yZWN1cnJlbnRBY3RpdmF0aW9uLmFwcGx5KGcpLGw9YWRkKG11bChzLGEpLG11bChvLG4uYWN0aXZhdGlvbi5hcHBseShtKSkpLHU9bi5yZWN1cnJlbnRBY3RpdmF0aW9uLmFwcGx5KHkpO3ZhciB2PW11bCh1LG4uYWN0aXZhdGlvbi5hcHBseShsKSk7cmV0dXJuW3YsdixsXX0pfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD17dW5pdHM6dGhpcy51bml0cyxhY3RpdmF0aW9uOnNlcmlhbGl6ZUFjdGl2YXRpb24odGhpcy5hY3RpdmF0aW9uKSxyZWN1cnJlbnRBY3RpdmF0aW9uOnNlcmlhbGl6ZUFjdGl2YXRpb24odGhpcy5yZWN1cnJlbnRBY3RpdmF0aW9uKSx1c2VCaWFzOnRoaXMudXNlQmlhcyxrZXJuZWxJbml0aWFsaXplcjpzZXJpYWxpemVJbml0aWFsaXplcih0aGlzLmtlcm5lbEluaXRpYWxpemVyKSxyZWN1cnJlbnRJbml0aWFsaXplcjpzZXJpYWxpemVJbml0aWFsaXplcih0aGlzLnJlY3VycmVudEluaXRpYWxpemVyKSxiaWFzSW5pdGlhbGl6ZXI6c2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5iaWFzSW5pdGlhbGl6ZXIpLHVuaXRGb3JnZXRCaWFzOnRoaXMudW5pdEZvcmdldEJpYXMsa2VybmVsUmVndWxhcml6ZXI6c2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5rZXJuZWxSZWd1bGFyaXplcikscmVjdXJyZW50UmVndWxhcml6ZXI6c2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5yZWN1cnJlbnRSZWd1bGFyaXplciksYmlhc1JlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYmlhc1JlZ3VsYXJpemVyKSxhY3Rpdml0eVJlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYWN0aXZpdHlSZWd1bGFyaXplciksa2VybmVsQ29uc3RyYWludDpzZXJpYWxpemVDb25zdHJhaW50KHRoaXMua2VybmVsQ29uc3RyYWludCkscmVjdXJyZW50Q29uc3RyYWludDpzZXJpYWxpemVDb25zdHJhaW50KHRoaXMucmVjdXJyZW50Q29uc3RyYWludCksYmlhc0NvbnN0cmFpbnQ6c2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmJpYXNDb25zdHJhaW50KSxkcm9wb3V0OnRoaXMuZHJvcG91dCxyZWN1cnJlbnREcm9wb3V0OnRoaXMucmVjdXJyZW50RHJvcG91dCxpbXBsZW1lbnRhdGlvbjp0aGlzLmltcGxlbWVudGF0aW9ufSxuPWUucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBPYmplY3QuYXNzaWduKHQsbiksdH0sdC5jbGFzc05hbWU9XCJMU1RNQ2VsbFwiLHR9KFJOTkNlbGwpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhMU1RNQ2VsbCk7dmFyIExTVE09ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXtyZXR1cm4gMD09PXQuaW1wbGVtZW50YXRpb24mJmNvbnNvbGUud2FybihcImBpbXBsZW1lbnRhdGlvbj0wYCBoYXMgYmVlbiBkZXByZWNhdGVkLCBhbmQgbm93IGRlZmF1bHRzIHRvIGBpbXBsZW1lbnRhdGlvbj0xYC4gUGxlYXNlIHVwZGF0ZSB5b3VyIGxheWVyIGNhbGwuXCIpLHQuY2VsbD1uZXcgTFNUTUNlbGwodCksZS5jYWxsKHRoaXMsdCl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24odCxuKXt2YXIgcj10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7bnVsbCE9ci5jZWxsLmRyb3BvdXRNYXNrJiYoZGlzcG9zZShyLmNlbGwuZHJvcG91dE1hc2spLHIuY2VsbC5kcm9wb3V0TWFzaz1udWxsKSxudWxsIT1yLmNlbGwucmVjdXJyZW50RHJvcG91dE1hc2smJihkaXNwb3NlKHIuY2VsbC5yZWN1cnJlbnREcm9wb3V0TWFzayksci5jZWxsLnJlY3VycmVudERyb3BvdXRNYXNrPW51bGwpO3ZhciBpPW51bGw9PW4/bnVsbDpuLm1hc2ssYT1udWxsPT1uP251bGw6bi50cmFpbmluZyxvPW51bGw9PW4/bnVsbDpuLmluaXRpYWxTdGF0ZTtyZXR1cm4gZS5wcm90b3R5cGUuY2FsbC5jYWxsKHIsdCx7bWFzazppLHRyYWluaW5nOmEsaW5pdGlhbFN0YXRlOm99KX0pfSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJ1bml0c1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLnVuaXRzfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImFjdGl2YXRpb25cIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5hY3RpdmF0aW9ufSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInJlY3VycmVudEFjdGl2YXRpb25cIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5yZWN1cnJlbnRBY3RpdmF0aW9ufSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInVzZUJpYXNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC51c2VCaWFzfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImtlcm5lbEluaXRpYWxpemVyXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwua2VybmVsSW5pdGlhbGl6ZXJ9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwicmVjdXJyZW50SW5pdGlhbGl6ZXJcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5yZWN1cnJlbnRJbml0aWFsaXplcn0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJiaWFzSW5pdGlhbGl6ZXJcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5iaWFzSW5pdGlhbGl6ZXJ9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwidW5pdEZvcmdldEJpYXNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC51bml0Rm9yZ2V0Qmlhc30sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJrZXJuZWxSZWd1bGFyaXplclwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLmtlcm5lbFJlZ3VsYXJpemVyfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInJlY3VycmVudFJlZ3VsYXJpemVyXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwucmVjdXJyZW50UmVndWxhcml6ZXJ9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwiYmlhc1JlZ3VsYXJpemVyXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwuYmlhc1JlZ3VsYXJpemVyfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImtlcm5lbENvbnN0cmFpbnRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5rZXJuZWxDb25zdHJhaW50fSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInJlY3VycmVudENvbnN0cmFpbnRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5yZWN1cnJlbnRDb25zdHJhaW50fSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImJpYXNDb25zdHJhaW50XCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwuYmlhc0NvbnN0cmFpbnR9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwiZHJvcG91dFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLmRyb3BvdXR9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwicmVjdXJyZW50RHJvcG91dFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLnJlY3VycmVudERyb3BvdXR9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwiaW1wbGVtZW50YXRpb25cIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5pbXBsZW1lbnRhdGlvbn0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD17dW5pdHM6dGhpcy51bml0cyxhY3RpdmF0aW9uOnNlcmlhbGl6ZUFjdGl2YXRpb24odGhpcy5hY3RpdmF0aW9uKSxyZWN1cnJlbnRBY3RpdmF0aW9uOnNlcmlhbGl6ZUFjdGl2YXRpb24odGhpcy5yZWN1cnJlbnRBY3RpdmF0aW9uKSx1c2VCaWFzOnRoaXMudXNlQmlhcyxrZXJuZWxJbml0aWFsaXplcjpzZXJpYWxpemVJbml0aWFsaXplcih0aGlzLmtlcm5lbEluaXRpYWxpemVyKSxyZWN1cnJlbnRJbml0aWFsaXplcjpzZXJpYWxpemVJbml0aWFsaXplcih0aGlzLnJlY3VycmVudEluaXRpYWxpemVyKSxiaWFzSW5pdGlhbGl6ZXI6c2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5iaWFzSW5pdGlhbGl6ZXIpLHVuaXRGb3JnZXRCaWFzOnRoaXMudW5pdEZvcmdldEJpYXMsa2VybmVsUmVndWxhcml6ZXI6c2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5rZXJuZWxSZWd1bGFyaXplcikscmVjdXJyZW50UmVndWxhcml6ZXI6c2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5yZWN1cnJlbnRSZWd1bGFyaXplciksYmlhc1JlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYmlhc1JlZ3VsYXJpemVyKSxhY3Rpdml0eVJlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYWN0aXZpdHlSZWd1bGFyaXplciksa2VybmVsQ29uc3RyYWludDpzZXJpYWxpemVDb25zdHJhaW50KHRoaXMua2VybmVsQ29uc3RyYWludCkscmVjdXJyZW50Q29uc3RyYWludDpzZXJpYWxpemVDb25zdHJhaW50KHRoaXMucmVjdXJyZW50Q29uc3RyYWludCksYmlhc0NvbnN0cmFpbnQ6c2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmJpYXNDb25zdHJhaW50KSxkcm9wb3V0OnRoaXMuZHJvcG91dCxyZWN1cnJlbnREcm9wb3V0OnRoaXMucmVjdXJyZW50RHJvcG91dCxpbXBsZW1lbnRhdGlvbjp0aGlzLmltcGxlbWVudGF0aW9ufSxuPWUucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBkZWxldGUgbi5jZWxsLE9iamVjdC5hc3NpZ24odCxuKSx0fSx0LmZyb21Db25maWc9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gMD09PXQuaW1wbG1lbnRhdGlvbiYmKHQuaW1wbGVtZW50YXRpb249MSksbmV3IGUodCl9LHQuY2xhc3NOYW1lPVwiTFNUTVwiLHR9KFJOTik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKExTVE0pO3ZhciBTdGFja2VkUk5OQ2VsbHM9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyx0KXx8dGhpcztyZXR1cm4gbi5jZWxscz10LmNlbGxzLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInN0YXRlU2l6ZVwiLHtnZXQ6ZnVuY3Rpb24oKXtmb3IodmFyIGU9W10sdD0wLG49dGhpcy5jZWxscy5zbGljZSgpLnJldmVyc2UoKTt0PG4ubGVuZ3RoO3QrKyl7dmFyIHI9blt0XTtBcnJheS5pc0FycmF5KHIuc3RhdGVTaXplKT9lLnB1c2guYXBwbHkoZSxyLnN0YXRlU2l6ZSk6ZS5wdXNoKHIuc3RhdGVTaXplKX1yZXR1cm4gZX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe2Zvcih2YXIgcj0oZT1lKS5zbGljZSgxKSxpPVtdLGE9MCxvPW4uY2VsbHMuc2xpY2UoKS5yZXZlcnNlKCk7YTxvLmxlbmd0aDthKyspe3ZhciBzPW9bYV07QXJyYXkuaXNBcnJheShzLnN0YXRlU2l6ZSk/aS5wdXNoKHIuc3BsaWNlKDAscy5zdGF0ZVNpemUubGVuZ3RoKSk6aS5wdXNoKHIuc3BsaWNlKDAsMSkpfWkucmV2ZXJzZSgpO2Zvcih2YXIgbCx1PVtdLGM9MDtjPG4uY2VsbHMubGVuZ3RoOysrYyl7cz1uLmNlbGxzW2NdO3I9aVtjXSxsPTA9PT1jP1tlWzBdXS5jb25jYXQocik6W2xbMF1dLmNvbmNhdChyKSxsPXMuY2FsbChsLHQpLHUucHVzaChsLnNsaWNlKDEpKX1yPVtdO2Zvcih2YXIgcD0wLGg9dS5zbGljZSgpLnJldmVyc2UoKTtwPGgubGVuZ3RoO3ArKyl7dmFyIGQ9aFtwXTtyLnB1c2guYXBwbHkocixkKX1yZXR1cm5bbFswXV0uY29uY2F0KHIpfSl9LHQucHJvdG90eXBlLmJ1aWxkPWZ1bmN0aW9uKGUpe3ZhciB0O2lzQXJyYXlPZlNoYXBlcyhlKSYmKGU9ZVswXSksZT1lO2Zvcih2YXIgbj0wLHI9dGhpcy5jZWxscztuPHIubGVuZ3RoO24rKyl7dmFyIGk9cltuXTtpLmJ1aWxkKGUpLHQ9QXJyYXkuaXNBcnJheShpLnN0YXRlU2l6ZSk/aS5zdGF0ZVNpemVbMF06aS5zdGF0ZVNpemUsZT1bZVswXSx0XX10aGlzLmJ1aWx0PSEwfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9W10sbj0wLHI9dGhpcy5jZWxscztuPHIubGVuZ3RoO24rKyl7dmFyIGk9cltuXTt0LnB1c2goe2NsYXNzTmFtZTp0aGlzLmdldENsYXNzTmFtZSgpLGNvbmZpZzppLmdldENvbmZpZygpfSl9dmFyIGE9e2NlbGxzOnR9LG89ZS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIE9iamVjdC5hc3NpZ24oYSxvKSxhfSx0LmZyb21Db25maWc9ZnVuY3Rpb24oZSx0LG4pe3ZvaWQgMD09PW4mJihuPXt9KTtmb3IodmFyIHI9W10saT0wLGE9dC5jZWxscztpPGEubGVuZ3RoO2krKyl7dmFyIG89YVtpXTtyLnB1c2goZGVzZXJpYWxpemUobyxuKSl9cmV0dXJuIG5ldyBlKHtjZWxsczpyfSl9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInRyYWluYWJsZVdlaWdodHNcIix7Z2V0OmZ1bmN0aW9uKCl7aWYoIXRoaXMudHJhaW5hYmxlKXJldHVybltdO2Zvcih2YXIgZT1bXSx0PTAsbj10aGlzLmNlbGxzO3Q8bi5sZW5ndGg7dCsrKXt2YXIgcj1uW3RdO2UucHVzaC5hcHBseShlLHIudHJhaW5hYmxlV2VpZ2h0cyl9cmV0dXJuIGV9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwibm9uVHJhaW5hYmxlV2VpZ2h0c1wiLHtnZXQ6ZnVuY3Rpb24oKXtmb3IodmFyIGU9W10sdD0wLG49dGhpcy5jZWxsczt0PG4ubGVuZ3RoO3QrKyl7dmFyIHI9blt0XTtlLnB1c2guYXBwbHkoZSxyLm5vblRyYWluYWJsZVdlaWdodHMpfWlmKCF0aGlzLnRyYWluYWJsZSl7Zm9yKHZhciBpPVtdLGE9MCxvPXRoaXMuY2VsbHM7YTxvLmxlbmd0aDthKyspe3I9b1thXTtpLnB1c2guYXBwbHkoaSxyLnRyYWluYWJsZVdlaWdodHMpfXJldHVybiBpLmNvbmNhdChlKX1yZXR1cm4gZX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSx0LnByb3RvdHlwZS5nZXRXZWlnaHRzPWZ1bmN0aW9uKCl7Zm9yKHZhciBlPVtdLHQ9MCxuPXRoaXMuY2VsbHM7dDxuLmxlbmd0aDt0Kyspe3ZhciByPW5bdF07ZS5wdXNoLmFwcGx5KGUsci53ZWlnaHRzKX1yZXR1cm4gYmF0Y2hHZXRWYWx1ZShlKX0sdC5wcm90b3R5cGUuc2V0V2VpZ2h0cz1mdW5jdGlvbihlKXtmb3IodmFyIHQ9W10sbj0wLHI9dGhpcy5jZWxscztuPHIubGVuZ3RoO24rKylmb3IodmFyIGk9cltuXSxhPWkud2VpZ2h0cy5sZW5ndGgsbz1lLnNwbGljZShhKSxzPTA7czxpLndlaWdodHMubGVuZ3RoOysrcyl0LnB1c2goW2kud2VpZ2h0c1tzXSxvW3NdXSk7YmF0Y2hTZXRWYWx1ZSh0KX0sdC5jbGFzc05hbWU9XCJTdGFja2VkUk5OQ2VsbHNcIix0fShSTk5DZWxsKTtmdW5jdGlvbiBnZW5lcmF0ZURyb3BvdXRNYXNrKGUsdCxuLHIpe2Z1bmN0aW9uIGkoKXtyZXR1cm4gZHJvcG91dChlKCksZ2V0U2NhbGFyKHQpKX1pZih2b2lkIDA9PT1uJiYobj1udWxsKSx2b2lkIDA9PT1yJiYocj0xKSxyPjEpe2Zvcih2YXIgYT1bXSxvPTA7bzxyO28rKylhLnB1c2goaW5UcmFpblBoYXNlKGksZSxuKSk7cmV0dXJuIGEuZm9yRWFjaChmdW5jdGlvbihlKXtyZXR1cm4ga2VlcChlKX0pLGF9cmV0dXJuIGtlZXAoaW5UcmFpblBoYXNlKGksZSxuKSl9c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKFN0YWNrZWRSTk5DZWxscyk7dmFyIFdyYXBwZXI9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyx0KXx8dGhpcztyZXR1cm4gbi5sYXllcj10LmxheWVyLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmJ1aWxkPWZ1bmN0aW9uKGUpe3RoaXMuYnVpbHQ9ITB9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInRyYWluYWJsZVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9dGhpcy5sYXllciYmdGhpcy5sYXllci50cmFpbmFibGV9LHNldDpmdW5jdGlvbihlKXtudWxsIT10aGlzLmxheWVyJiYodGhpcy5sYXllci50cmFpbmFibGU9ZSl9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwidHJhaW5hYmxlV2VpZ2h0c1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sYXllci50cmFpbmFibGVXZWlnaHRzfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcIm5vblRyYWluYWJsZVdlaWdodHNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGF5ZXIubm9uVHJhaW5hYmxlV2VpZ2h0c30sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJ1cGRhdGVzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxheWVyLl91cGRhdGVzfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImxvc3Nlc1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sYXllci5sb3NzZXN9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksdC5wcm90b3R5cGUuZ2V0V2VpZ2h0cz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmxheWVyLmdldFdlaWdodHMoKX0sdC5wcm90b3R5cGUuc2V0V2VpZ2h0cz1mdW5jdGlvbihlKXt0aGlzLmxheWVyLnNldFdlaWdodHMoZSl9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciB0PXtsYXllcjp7Y2xhc3NOYW1lOnRoaXMubGF5ZXIuZ2V0Q2xhc3NOYW1lKCksY29uZmlnOnRoaXMubGF5ZXIuZ2V0Q29uZmlnKCl9fSxuPWUucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBPYmplY3QuYXNzaWduKHQsbiksdH0sdC5mcm9tQ29uZmlnPWZ1bmN0aW9uKGUsdCxuKXt2b2lkIDA9PT1uJiYobj17fSk7dmFyIHI9ZGVzZXJpYWxpemUodC5sYXllcixuKTtkZWxldGUgdC5sYXllcjt2YXIgaT17bGF5ZXI6cn07cmV0dXJuIE9iamVjdC5hc3NpZ24oaSx0KSxuZXcgZShpKX0sdH0oTGF5ZXIpLFRpbWVEaXN0cmlidXRlZD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzLHQpfHx0aGlzO3JldHVybiBuLnN1cHBvcnRzTWFza2luZz0hMCxufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5idWlsZD1mdW5jdGlvbih0KXtpZigodD1nZXRFeGFjdGx5T25lU2hhcGUodCkpLmxlbmd0aDwzKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiVGltZURpc3RyaWJ1dGVkIGxheWVyIGV4cGVjdHMgYW4gaW5wdXQgc2hhcGUgPj0gM0QsIGJ1dCByZWNlaXZlZCBpbnB1dCBzaGFwZSBcIitKU09OLnN0cmluZ2lmeSh0KSk7dGhpcy5pbnB1dFNwZWM9W3tzaGFwZTp0fV07dmFyIG49W3RbMF1dLmNvbmNhdCh0LnNsaWNlKDIpKTt0aGlzLmxheWVyLmJ1aWx0fHwodGhpcy5sYXllci5idWlsZChuKSx0aGlzLmxheWVyLmJ1aWx0PSEwKSxlLnByb3RvdHlwZS5idWlsZC5jYWxsKHRoaXMsdCl9LHQucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZT1mdW5jdGlvbihlKXt2YXIgdD1bKGU9Z2V0RXhhY3RseU9uZVNoYXBlKGUpKVswXV0uY29uY2F0KGUuc2xpY2UoMikpLG49dGhpcy5sYXllci5jb21wdXRlT3V0cHV0U2hhcGUodCkscj1lWzFdO3JldHVybltuWzBdLHJdLmNvbmNhdChuLnNsaWNlKDEpKX0sdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtyZXR1cm4gcm5uKGZ1bmN0aW9uKGUscil7cmV0dXJuW2dldEV4YWN0bHlPbmVUZW5zb3Iobi5sYXllci5jYWxsKGUsdCkpLFtdXX0sZT1nZXRFeGFjdGx5T25lVGVuc29yKGUpLFtdLCExLG51bGwsbnVsbCwhMSwhMClbMV19KX0sdC5jbGFzc05hbWU9XCJUaW1lRGlzdHJpYnV0ZWRcIix0fShXcmFwcGVyKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoVGltZURpc3RyaWJ1dGVkKTt2YXIgVkFMSURfQklESVJFQ1RJT05BTF9NRVJHRV9NT0RFUz1bXCJzdW1cIixcIm11bFwiLFwiY29uY2F0XCIsXCJhdmVcIl07ZnVuY3Rpb24gY2hlY2tCaWRpcmVjdGlvbmFsTWVyZ2VNb2RlKGUpe2NoZWNrU3RyaW5nVHlwZVVuaW9uVmFsdWUoVkFMSURfQklESVJFQ1RJT05BTF9NRVJHRV9NT0RFUyxcIkJpZGlyZWN0aW9uYWxNZXJnZU1vZGVcIixlKX12YXIgQmlkaXJlY3Rpb25hbD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzLHQpfHx0aGlzLHI9dC5sYXllci5nZXRDb25maWcoKTtpZihuLmZvcndhcmRMYXllcj1kZXNlcmlhbGl6ZSh7Y2xhc3NOYW1lOnQubGF5ZXIuZ2V0Q2xhc3NOYW1lKCksY29uZmlnOnJ9KSxyLmdvQmFja3dhcmRzPSEwIT09ci5nb0JhY2t3YXJkcyxuLmJhY2t3YXJkTGF5ZXI9ZGVzZXJpYWxpemUoe2NsYXNzTmFtZTp0LmxheWVyLmdldENsYXNzTmFtZSgpLGNvbmZpZzpyfSksbi5mb3J3YXJkTGF5ZXIubmFtZT1cImZvcndhcmRfXCIrbi5mb3J3YXJkTGF5ZXIubmFtZSxuLmJhY2t3YXJkTGF5ZXIubmFtZT1cImJhY2t3YXJkX1wiK24uYmFja3dhcmRMYXllci5uYW1lLGNoZWNrQmlkaXJlY3Rpb25hbE1lcmdlTW9kZSh0Lm1lcmdlTW9kZSksbi5tZXJnZU1vZGU9dC5tZXJnZU1vZGUsdC53ZWlnaHRzKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwid2VpZ2h0cyBzdXBwb3J0IGlzIG5vdCBpbXBsZW1lbnRlZCBmb3IgQmlkaXJlY3Rpb25hbCBsYXllciB5ZXQuXCIpO3JldHVybiBuLl9zdGF0ZWZ1bD10LmxheWVyLnN0YXRlZnVsLG4ucmV0dXJuU2VxdWVuY2VzPXQubGF5ZXIucmV0dXJuU2VxdWVuY2VzLG4ucmV0dXJuU3RhdGU9dC5sYXllci5yZXR1cm5TdGF0ZSxuLnN1cHBvcnRzTWFza2luZz0hMCxuLl90cmFpbmFibGU9ITAsbi5pbnB1dFNwZWM9dC5sYXllci5pbnB1dFNwZWMsbi5udW1Db25zdGFudHM9bnVsbCxufXJldHVybiBfX2V4dGVuZHModCxlKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJ0cmFpbmFibGVcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3RyYWluYWJsZX0sc2V0OmZ1bmN0aW9uKGUpe3RoaXMuX3RyYWluYWJsZT1lLG51bGwhPXRoaXMuZm9yd2FyZExheWVyJiYodGhpcy5mb3J3YXJkTGF5ZXIudHJhaW5hYmxlPWUpLG51bGwhPXRoaXMuYmFja3dhcmRMYXllciYmKHRoaXMuYmFja3dhcmRMYXllci50cmFpbmFibGU9ZSl9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksdC5wcm90b3R5cGUuZ2V0V2VpZ2h0cz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmZvcndhcmRMYXllci5nZXRXZWlnaHRzKCkuY29uY2F0KHRoaXMuYmFja3dhcmRMYXllci5nZXRXZWlnaHRzKCkpfSx0LnByb3RvdHlwZS5zZXRXZWlnaHRzPWZ1bmN0aW9uKGUpe3ZhciB0PWUubGVuZ3RoLG49TWF0aC5mbG9vcih0LzIpO3RoaXMuZm9yd2FyZExheWVyLnNldFdlaWdodHMoZS5zbGljZSgwLG4pKSx0aGlzLmJhY2t3YXJkTGF5ZXIuc2V0V2VpZ2h0cyhlLnNsaWNlKG4pKX0sdC5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlPWZ1bmN0aW9uKGUpe3ZhciB0LG4scixpPXRoaXMuZm9yd2FyZExheWVyLmNvbXB1dGVPdXRwdXRTaGFwZShlKTtyZXR1cm4gQXJyYXkuaXNBcnJheShpKSYmQXJyYXkuaXNBcnJheShpWzBdKXx8KGk9W2ldKSxpPWksdGhpcy5yZXR1cm5TdGF0ZT8ocj1pLnNsaWNlKDEpLHQ9aVswXSk6dD1pWzBdLHQ9dCxcImNvbmNhdFwiPT09dGhpcy5tZXJnZU1vZGU/KHRbdC5sZW5ndGgtMV0qPTIsbj1bdF0pOm49bnVsbD09dGhpcy5tZXJnZU1vZGU/W3QsdC5zbGljZSgpXTpbdF0sdGhpcy5yZXR1cm5TdGF0ZT9udWxsPT10aGlzLm1lcmdlTW9kZT9uLmNvbmNhdChyKS5jb25jYXQoci5zbGljZSgpKTpbdF0uY29uY2F0KHIpLmNvbmNhdChyLnNsaWNlKCkpOnNpbmdsZXRvbk9yQXJyYXkobil9LHQucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKHQsbil7dmFyIHI9bnVsbD09bj9udWxsOm4uaW5pdGlhbFN0YXRlLGk9bnVsbD09bj9udWxsOm4uY29uc3RhbnRzO251bGw9PW4mJihuPXt9KTt2YXIgYT1zdGFuZGFyZGl6ZUFyZ3ModCxyLGksdGhpcy5udW1Db25zdGFudHMpO2lmKHQ9YS5pbnB1dHMscj1hLmluaXRpYWxTdGF0ZSxpPWEuY29uc3RhbnRzLEFycmF5LmlzQXJyYXkodCkmJihyPXQuc2xpY2UoMSksdD10WzBdKSwobnVsbD09cnx8MD09PXIubGVuZ3RoKSYmbnVsbD09aSlyZXR1cm4gZS5wcm90b3R5cGUuYXBwbHkuY2FsbCh0aGlzLHQsbik7dmFyIG89W10scz1bXTtpZihudWxsIT1yKXt2YXIgbD1yLmxlbmd0aDtpZihsJTI+MCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIldoZW4gcGFzc2luZyBgaW5pdGlhbFN0YXRlYCB0byBhIEJpZHJlY3Rpb25hbCBSTk4sIHRoZSBzdGF0ZSBzaG91bGQgYmUgYW4gQXJyYXkgY29udGFpbmluZyB0aGUgc3RhdGVzIG9mIHRoZSB1bmRlcmx5aW5nIFJOTnMuXCIpO24uaW5pdGlhbFN0YXRlPXIsby5wdXNoLmFwcGx5KG8scik7dmFyIHU9ci5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBJbnB1dFNwZWMoe3NoYXBlOmUuc2hhcGV9KX0pO3RoaXMuZm9yd2FyZExheWVyLnN0YXRlU3BlYz11LnNsaWNlKDAsbC8yKSx0aGlzLmJhY2t3YXJkTGF5ZXIuc3RhdGVTcGVjPXUuc2xpY2UobC8yKSxzLnB1c2guYXBwbHkocyx1KX1pZihudWxsIT1pKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwiU3VwcG9ydCBmb3IgY29uc3RhbnRzIGluIEJpZGlyZWN0aW9uYWwgbGF5ZXJzIGlzIG5vdCBpbXBsZW1lbnRlZCB5ZXQuXCIpO2Zvcih2YXIgYz1vWzBdaW5zdGFuY2VvZiBTeW1ib2xpY1RlbnNvcixwPTAsaD1vO3A8aC5sZW5ndGg7cCsrKXtpZihoW3BdaW5zdGFuY2VvZiBTeW1ib2xpY1RlbnNvciE9PWMpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJUaGUgaW5pdGlhbCBzdGF0ZSBvZiBhIEJpZGlyZWN0aW9uYWwgbGF5ZXIgY2Fubm90IGJlIHNwZWNpZmllZCBhcyBhIG1peCBvZiBzeW1ib2xpYyBhbmQgbm9uLXN5bWJvbGljIHRlbnNvcnNcIil9aWYoYyl7dmFyIGQ9W3RdLmNvbmNhdChvKSxmPXRoaXMuaW5wdXRTcGVjLmNvbmNhdChzKSxnPXRoaXMuaW5wdXRTcGVjO3RoaXMuaW5wdXRTcGVjPWY7dmFyIG09ZS5wcm90b3R5cGUuYXBwbHkuY2FsbCh0aGlzLGQsbik7cmV0dXJuIHRoaXMuaW5wdXRTcGVjPWcsbX1yZXR1cm4gZS5wcm90b3R5cGUuYXBwbHkuY2FsbCh0aGlzLHQsbil9LHQucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7aWYobnVsbCE9dC5tYXNrKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwiVGhlIHN1cHBvcnQgZm9yIG1hc2tpbmcgaXMgbm90IGltcGxlbWVudGVkIGZvciBCaWRpcmVjdGlvbmFsIGxheWVycyB5ZXQuXCIpO3ZhciByLGksYSxvLHM9dC5pbml0aWFsU3RhdGU7aWYobnVsbD09cylyPW4uZm9yd2FyZExheWVyLmNhbGwoZSx0KSxpPW4uYmFja3dhcmRMYXllci5jYWxsKGUsdCk7ZWxzZXt2YXIgbD1zLnNsaWNlKDAscy5sZW5ndGgvMiksdT1zLnNsaWNlKHMubGVuZ3RoLzIpO3I9bi5mb3J3YXJkTGF5ZXIuY2FsbChlLE9iamVjdC5hc3NpZ24odCx7aW5pdGlhbFN0YXRlOmx9KSksaT1uLmJhY2t3YXJkTGF5ZXIuY2FsbChlLE9iamVjdC5hc3NpZ24odCx7aW5pdGlhbFN0YXRlOnV9KSl9cmV0dXJuIG4ucmV0dXJuU3RhdGUmJihBcnJheS5pc0FycmF5KHIpJiYoYT1yLnNsaWNlKDEpLmNvbmNhdChpLnNsaWNlKDEpKSkscj1yWzBdLGk9aVswXSksbi5yZXR1cm5TZXF1ZW5jZXMmJihpPXJldmVyc2UoaSwxKSksXCJjb25jYXRcIj09PW4ubWVyZ2VNb2RlP289Y29uY2F0ZW5hdGUoW3IsaV0pOlwic3VtXCI9PT1uLm1lcmdlTW9kZT9vPWFkZChyLGkpOlwiYXZlXCI9PT1uLm1lcmdlTW9kZT9vPW11bChnZXRTY2FsYXIoLjUpLGFkZChyLGkpKTpcIm11bFwiPT09bi5tZXJnZU1vZGU/bz1tdWwocixpKTpudWxsPT1uLm1lcmdlTW9kZSYmKG89W3IsaV0pLG4ucmV0dXJuU3RhdGU/bnVsbD09bi5tZXJnZU1vZGU/by5jb25jYXQoYSk6W29dLmNvbmNhdChhKTpvfSl9LHQucHJvdG90eXBlLnJlc2V0U3RhdGVzPWZ1bmN0aW9uKGUpe3RoaXMuZm9yd2FyZExheWVyLnJlc2V0U3RhdGVzKCksdGhpcy5iYWNrd2FyZExheWVyLnJlc2V0U3RhdGVzKCl9LHQucHJvdG90eXBlLmJ1aWxkPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7bmFtZVNjb3BlKHRoaXMuZm9yd2FyZExheWVyLm5hbWUsZnVuY3Rpb24oKXt0LmZvcndhcmRMYXllci5idWlsZChlKX0pLG5hbWVTY29wZSh0aGlzLmJhY2t3YXJkTGF5ZXIubmFtZSxmdW5jdGlvbigpe3QuYmFja3dhcmRMYXllci5idWlsZChlKX0pLHRoaXMuYnVpbHQ9ITB9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInRyYWluYWJsZVdlaWdodHNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZm9yd2FyZExheWVyLnRyYWluYWJsZVdlaWdodHMuY29uY2F0KHRoaXMuYmFja3dhcmRMYXllci50cmFpbmFibGVXZWlnaHRzKX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJub25UcmFpbmFibGVXZWlnaHRzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmZvcndhcmRMYXllci5ub25UcmFpbmFibGVXZWlnaHRzLmNvbmNhdCh0aGlzLmJhY2t3YXJkTGF5ZXIubm9uVHJhaW5hYmxlV2VpZ2h0cyl9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIHQ9e21lcmdlTW9kZTp0aGlzLm1lcmdlTW9kZX0sbj1lLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gT2JqZWN0LmFzc2lnbih0LG4pLHR9LHQuZnJvbUNvbmZpZz1mdW5jdGlvbihlLHQpe3ZhciBuPWRlc2VyaWFsaXplKHQubGF5ZXIpO2lmKGRlbGV0ZSB0LmxheWVyLG51bGwhPXQubnVtQ29uc3RhbnRzKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwiRGVzZXJpYWxpemF0aW9uIG9mIGEgQmlkaXJlY3Rpb25hbCBsYXllciB3aXRoIG51bUNvbnN0YW50cyBwcmVzZW50IGlzIG5vdCBzdXBwb3J0ZWQgeWV0LlwiKTt2YXIgcj10O3JldHVybiByLmxheWVyPW4sbmV3IGUocil9LHQuY2xhc3NOYW1lPVwiQmlkaXJlY3Rpb25hbFwiLHR9KFdyYXBwZXIpO2Z1bmN0aW9uIGlucHV0TGF5ZXIoZSl7cmV0dXJuIG5ldyBJbnB1dExheWVyKGUpfWZ1bmN0aW9uIGVsdSQyKGUpe3JldHVybiBuZXcgRUxVKGUpfWZ1bmN0aW9uIHJlTFUoZSl7cmV0dXJuIG5ldyBSZUxVKGUpfWZ1bmN0aW9uIGxlYWt5UmVMVShlKXtyZXR1cm4gbmV3IExlYWt5UmVMVShlKX1mdW5jdGlvbiBzb2Z0bWF4JDEoZSl7cmV0dXJuIG5ldyBTb2Z0bWF4JDEoZSl9ZnVuY3Rpb24gdGhyZXNob2xkZWRSZUxVKGUpe3JldHVybiBuZXcgVGhyZXNob2xkZWRSZUxVKGUpfWZ1bmN0aW9uIGNvbnYxZCQyKGUpe3JldHVybiBuZXcgQ29udjFEKGUpfWZ1bmN0aW9uIGNvbnYyZCQyKGUpe3JldHVybiBuZXcgQ29udjJEKGUpfWZ1bmN0aW9uIGNvbnYyZFRyYW5zcG9zZSQxKGUpe3JldHVybiBuZXcgQ29udjJEVHJhbnNwb3NlKGUpfWZ1bmN0aW9uIHNlcGFyYWJsZUNvbnYyZCQxKGUpe3JldHVybiBuZXcgU2VwYXJhYmxlQ29udjJEKGUpfWZ1bmN0aW9uIGNyb3BwaW5nMkQoZSl7cmV0dXJuIG5ldyBDcm9wcGluZzJEKGUpfWZ1bmN0aW9uIHVwU2FtcGxpbmcyZChlKXtyZXR1cm4gbmV3IFVwU2FtcGxpbmcyRChlKX1mdW5jdGlvbiBkZXB0aHdpc2VDb252MmQkMihlKXtyZXR1cm4gbmV3IERlcHRod2lzZUNvbnYyRChlKX1mdW5jdGlvbiBhY3RpdmF0aW9uKGUpe3JldHVybiBuZXcgQWN0aXZhdGlvbiQxKGUpfWZ1bmN0aW9uIGRlbnNlKGUpe3JldHVybiBuZXcgRGVuc2UoZSl9ZnVuY3Rpb24gZHJvcG91dCQxKGUpe3JldHVybiBuZXcgRHJvcG91dChlKX1mdW5jdGlvbiBmbGF0dGVuJDEoZSl7cmV0dXJuIG5ldyBGbGF0dGVuKGUpfWZ1bmN0aW9uIHJlcGVhdFZlY3RvcihlKXtyZXR1cm4gbmV3IFJlcGVhdFZlY3RvcihlKX1mdW5jdGlvbiByZXNoYXBlKGUpe3JldHVybiBuZXcgUmVzaGFwZShlKX1mdW5jdGlvbiBwZXJtdXRlKGUpe3JldHVybiBuZXcgUGVybXV0ZShlKX1mdW5jdGlvbiBlbWJlZGRpbmcoZSl7cmV0dXJuIG5ldyBFbWJlZGRpbmcoZSl9ZnVuY3Rpb24gYWRkJDIoZSl7cmV0dXJuIG5ldyBBZGQoZSl9ZnVuY3Rpb24gYXZlcmFnZSQxKGUpe3JldHVybiBuZXcgQXZlcmFnZShlKX1mdW5jdGlvbiBjb25jYXRlbmF0ZSQyKGUpe3JldHVybiBuZXcgQ29uY2F0ZW5hdGUoZSl9ZnVuY3Rpb24gbWF4aW11bSQyKGUpe3JldHVybiBuZXcgTWF4aW11bShlKX1mdW5jdGlvbiBtaW5pbXVtJDIoZSl7cmV0dXJuIG5ldyBNaW5pbXVtKGUpfWZ1bmN0aW9uIG11bHRpcGx5JDEoZSl7cmV0dXJuIG5ldyBNdWx0aXBseShlKX1mdW5jdGlvbiBkb3QkMShlKXtyZXR1cm4gbmV3IERvdChlKX1mdW5jdGlvbiBiYXRjaE5vcm1hbGl6YXRpb24kMShlKXtyZXR1cm4gbmV3IEJhdGNoTm9ybWFsaXphdGlvbihlKX1mdW5jdGlvbiB6ZXJvUGFkZGluZzJkKGUpe3JldHVybiBuZXcgWmVyb1BhZGRpbmcyRChlKX1mdW5jdGlvbiBhdmVyYWdlUG9vbGluZzFkKGUpe3JldHVybiBuZXcgQXZlcmFnZVBvb2xpbmcxRChlKX1mdW5jdGlvbiBhdmdQb29sMWQoZSl7cmV0dXJuIGF2ZXJhZ2VQb29saW5nMWQoZSl9ZnVuY3Rpb24gYXZnUG9vbGluZzFkKGUpe3JldHVybiBhdmVyYWdlUG9vbGluZzFkKGUpfWZ1bmN0aW9uIGF2ZXJhZ2VQb29saW5nMmQoZSl7cmV0dXJuIG5ldyBBdmVyYWdlUG9vbGluZzJEKGUpfWZ1bmN0aW9uIGF2Z1Bvb2wyZChlKXtyZXR1cm4gYXZlcmFnZVBvb2xpbmcyZChlKX1mdW5jdGlvbiBhdmdQb29saW5nMmQoZSl7cmV0dXJuIGF2ZXJhZ2VQb29saW5nMmQoZSl9ZnVuY3Rpb24gZ2xvYmFsQXZlcmFnZVBvb2xpbmcxZChlKXtyZXR1cm4gbmV3IEdsb2JhbEF2ZXJhZ2VQb29saW5nMUQoZSl9ZnVuY3Rpb24gZ2xvYmFsQXZlcmFnZVBvb2xpbmcyZChlKXtyZXR1cm4gbmV3IEdsb2JhbEF2ZXJhZ2VQb29saW5nMkQoZSl9ZnVuY3Rpb24gZ2xvYmFsTWF4UG9vbGluZzFkKGUpe3JldHVybiBuZXcgR2xvYmFsTWF4UG9vbGluZzFEKGUpfWZ1bmN0aW9uIGdsb2JhbE1heFBvb2xpbmcyZChlKXtyZXR1cm4gbmV3IEdsb2JhbE1heFBvb2xpbmcyRChlKX1mdW5jdGlvbiBtYXhQb29saW5nMWQoZSl7cmV0dXJuIG5ldyBNYXhQb29saW5nMUQoZSl9ZnVuY3Rpb24gbWF4UG9vbGluZzJkKGUpe3JldHVybiBuZXcgTWF4UG9vbGluZzJEKGUpfWZ1bmN0aW9uIGdydShlKXtyZXR1cm4gbmV3IEdSVShlKX1mdW5jdGlvbiBncnVDZWxsKGUpe3JldHVybiBuZXcgR1JVQ2VsbChlKX1mdW5jdGlvbiBsc3RtKGUpe3JldHVybiBuZXcgTFNUTShlKX1mdW5jdGlvbiBsc3RtQ2VsbChlKXtyZXR1cm4gbmV3IExTVE1DZWxsKGUpfWZ1bmN0aW9uIHNpbXBsZVJOTihlKXtyZXR1cm4gbmV3IFNpbXBsZVJOTihlKX1mdW5jdGlvbiBzaW1wbGVSTk5DZWxsKGUpe3JldHVybiBuZXcgU2ltcGxlUk5OQ2VsbChlKX1mdW5jdGlvbiBybm4kMShlKXtyZXR1cm4gbmV3IFJOTihlKX1mdW5jdGlvbiBzdGFja2VkUk5OQ2VsbHMoZSl7cmV0dXJuIG5ldyBTdGFja2VkUk5OQ2VsbHMoZSl9ZnVuY3Rpb24gYmlkaXJlY3Rpb25hbChlKXtyZXR1cm4gbmV3IEJpZGlyZWN0aW9uYWwoZSl9ZnVuY3Rpb24gdGltZURpc3RyaWJ1dGVkKGUpe3JldHVybiBuZXcgVGltZURpc3RyaWJ1dGVkKGUpfXNlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhCaWRpcmVjdGlvbmFsKTt2YXIgZ2xvYmFsTWF4UG9vbDFkPWdsb2JhbE1heFBvb2xpbmcxZCxnbG9iYWxNYXhQb29sMmQ9Z2xvYmFsTWF4UG9vbGluZzJkLG1heFBvb2wxZD1tYXhQb29saW5nMWQsbWF4UG9vbDJkPW1heFBvb2xpbmcyZCxleHBvcnRzX2xheWVycz1PYmplY3QuZnJlZXplKHtpbnB1dExheWVyOmlucHV0TGF5ZXIsZWx1OmVsdSQyLHJlTFU6cmVMVSxsZWFreVJlTFU6bGVha3lSZUxVLHNvZnRtYXg6c29mdG1heCQxLHRocmVzaG9sZGVkUmVMVTp0aHJlc2hvbGRlZFJlTFUsY29udjFkOmNvbnYxZCQyLGNvbnYyZDpjb252MmQkMixjb252MmRUcmFuc3Bvc2U6Y29udjJkVHJhbnNwb3NlJDEsc2VwYXJhYmxlQ29udjJkOnNlcGFyYWJsZUNvbnYyZCQxLGNyb3BwaW5nMkQ6Y3JvcHBpbmcyRCx1cFNhbXBsaW5nMmQ6dXBTYW1wbGluZzJkLGRlcHRod2lzZUNvbnYyZDpkZXB0aHdpc2VDb252MmQkMixhY3RpdmF0aW9uOmFjdGl2YXRpb24sZGVuc2U6ZGVuc2UsZHJvcG91dDpkcm9wb3V0JDEsZmxhdHRlbjpmbGF0dGVuJDEscmVwZWF0VmVjdG9yOnJlcGVhdFZlY3RvcixyZXNoYXBlOnJlc2hhcGUscGVybXV0ZTpwZXJtdXRlLGVtYmVkZGluZzplbWJlZGRpbmcsYWRkOmFkZCQyLGF2ZXJhZ2U6YXZlcmFnZSQxLGNvbmNhdGVuYXRlOmNvbmNhdGVuYXRlJDIsbWF4aW11bTptYXhpbXVtJDIsbWluaW11bTptaW5pbXVtJDIsbXVsdGlwbHk6bXVsdGlwbHkkMSxkb3Q6ZG90JDEsYmF0Y2hOb3JtYWxpemF0aW9uOmJhdGNoTm9ybWFsaXphdGlvbiQxLHplcm9QYWRkaW5nMmQ6emVyb1BhZGRpbmcyZCxhdmVyYWdlUG9vbGluZzFkOmF2ZXJhZ2VQb29saW5nMWQsYXZnUG9vbDFkOmF2Z1Bvb2wxZCxhdmdQb29saW5nMWQ6YXZnUG9vbGluZzFkLGF2ZXJhZ2VQb29saW5nMmQ6YXZlcmFnZVBvb2xpbmcyZCxhdmdQb29sMmQ6YXZnUG9vbDJkLGF2Z1Bvb2xpbmcyZDphdmdQb29saW5nMmQsZ2xvYmFsQXZlcmFnZVBvb2xpbmcxZDpnbG9iYWxBdmVyYWdlUG9vbGluZzFkLGdsb2JhbEF2ZXJhZ2VQb29saW5nMmQ6Z2xvYmFsQXZlcmFnZVBvb2xpbmcyZCxnbG9iYWxNYXhQb29saW5nMWQ6Z2xvYmFsTWF4UG9vbGluZzFkLGdsb2JhbE1heFBvb2xpbmcyZDpnbG9iYWxNYXhQb29saW5nMmQsbWF4UG9vbGluZzFkOm1heFBvb2xpbmcxZCxtYXhQb29saW5nMmQ6bWF4UG9vbGluZzJkLGdydTpncnUsZ3J1Q2VsbDpncnVDZWxsLGxzdG06bHN0bSxsc3RtQ2VsbDpsc3RtQ2VsbCxzaW1wbGVSTk46c2ltcGxlUk5OLHNpbXBsZVJOTkNlbGw6c2ltcGxlUk5OQ2VsbCxybm46cm5uJDEsc3RhY2tlZFJOTkNlbGxzOnN0YWNrZWRSTk5DZWxscyxiaWRpcmVjdGlvbmFsOmJpZGlyZWN0aW9uYWwsdGltZURpc3RyaWJ1dGVkOnRpbWVEaXN0cmlidXRlZCxnbG9iYWxNYXhQb29sMWQ6Z2xvYmFsTWF4UG9vbDFkLGdsb2JhbE1heFBvb2wyZDpnbG9iYWxNYXhQb29sMmQsbWF4UG9vbDFkOm1heFBvb2wxZCxtYXhQb29sMmQ6bWF4UG9vbDJkLExheWVyOkxheWVyLFJOTjpSTk4sUk5OQ2VsbDpSTk5DZWxsLGlucHV0OmlucHV0fSksZXhwb3J0c19tb2RlbHM9T2JqZWN0LmZyZWV6ZSh7bW9kZWxGcm9tSlNPTjptb2RlbEZyb21KU09OfSk7ZnVuY3Rpb24gYmluYXJ5QWNjdXJhY3kkMShlLHQpe3JldHVybiBiaW5hcnlBY2N1cmFjeShlLHQpfWZ1bmN0aW9uIGJpbmFyeUNyb3NzZW50cm9weSQyKGUsdCl7cmV0dXJuIGJpbmFyeUNyb3NzZW50cm9weSQxKGUsdCl9ZnVuY3Rpb24gY2F0ZWdvcmljYWxBY2N1cmFjeSQxKGUsdCl7cmV0dXJuIGNhdGVnb3JpY2FsQWNjdXJhY3koZSx0KX1mdW5jdGlvbiBjYXRlZ29yaWNhbENyb3NzZW50cm9weSQyKGUsdCl7cmV0dXJuIGNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5JDEoZSx0KX1mdW5jdGlvbiBwcmVjaXNpb24kMShlLHQpe3JldHVybiBwcmVjaXNpb24oZSx0KX1mdW5jdGlvbiByZWNhbGwkMShlLHQpe3JldHVybiByZWNhbGwoZSx0KX1mdW5jdGlvbiBjb3NpbmVQcm94aW1pdHkkMShlLHQpe3JldHVybiBjb3NpbmVQcm94aW1pdHkoZSx0KX1mdW5jdGlvbiBtZWFuQWJzb2x1dGVFcnJvciQxKGUsdCl7cmV0dXJuIG1lYW5BYnNvbHV0ZUVycm9yKGUsdCl9ZnVuY3Rpb24gbWVhbkFic29sdXRlUGVyY2VudGFnZUVycm9yJDEoZSx0KXtyZXR1cm4gbWVhbkFic29sdXRlUGVyY2VudGFnZUVycm9yKGUsdCl9ZnVuY3Rpb24gTUFQRSQyKGUsdCl7cmV0dXJuIG1lYW5BYnNvbHV0ZVBlcmNlbnRhZ2VFcnJvcihlLHQpfWZ1bmN0aW9uIG1hcGUkMihlLHQpe3JldHVybiBtZWFuQWJzb2x1dGVQZXJjZW50YWdlRXJyb3IoZSx0KX1mdW5jdGlvbiBtZWFuU3F1YXJlZEVycm9yJDEoZSx0KXtyZXR1cm4gbWVhblNxdWFyZWRFcnJvcihlLHQpfWZ1bmN0aW9uIE1TRSQyKGUsdCl7cmV0dXJuIG1lYW5TcXVhcmVkRXJyb3IoZSx0KX1mdW5jdGlvbiBtc2UkMihlLHQpe3JldHVybiBtZWFuU3F1YXJlZEVycm9yKGUsdCl9dmFyIGV4cG9ydHNfbWV0cmljcz1PYmplY3QuZnJlZXplKHtiaW5hcnlBY2N1cmFjeTpiaW5hcnlBY2N1cmFjeSQxLGJpbmFyeUNyb3NzZW50cm9weTpiaW5hcnlDcm9zc2VudHJvcHkkMixjYXRlZ29yaWNhbEFjY3VyYWN5OmNhdGVnb3JpY2FsQWNjdXJhY3kkMSxjYXRlZ29yaWNhbENyb3NzZW50cm9weTpjYXRlZ29yaWNhbENyb3NzZW50cm9weSQyLHByZWNpc2lvbjpwcmVjaXNpb24kMSxyZWNhbGw6cmVjYWxsJDEsY29zaW5lUHJveGltaXR5OmNvc2luZVByb3hpbWl0eSQxLG1lYW5BYnNvbHV0ZUVycm9yOm1lYW5BYnNvbHV0ZUVycm9yJDEsbWVhbkFic29sdXRlUGVyY2VudGFnZUVycm9yOm1lYW5BYnNvbHV0ZVBlcmNlbnRhZ2VFcnJvciQxLE1BUEU6TUFQRSQyLG1hcGU6bWFwZSQyLG1lYW5TcXVhcmVkRXJyb3I6bWVhblNxdWFyZWRFcnJvciQxLE1TRTpNU0UkMixtc2U6bXNlJDJ9KTtmdW5jdGlvbiBsMWwyKGUpe3JldHVybiBuZXcgTDFMMihlKX1mdW5jdGlvbiBsMSQxKGUpe3JldHVybiBsMShlKX1mdW5jdGlvbiBsMiQxKGUpe3JldHVybiBsMihlKX12YXIgZXhwb3J0c19yZWd1bGFyaXplcnM9T2JqZWN0LmZyZWV6ZSh7bDFsMjpsMWwyLGwxOmwxJDEsbDI6bDIkMX0pLENhbGxiYWNrPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoKXt2YXIgdD1udWxsIT09ZSYmZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXM7cmV0dXJuIHQubW9kZWw9bnVsbCx0fXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5zZXRNb2RlbD1mdW5jdGlvbihlKXtpZighKGUgaW5zdGFuY2VvZiBNb2RlbCkpdGhyb3cgbmV3IEVycm9yKFwibW9kZWwgbXVzdCBiZSBhIE1vZGVsLCBub3Qgc29tZSBvdGhlciBDb250YWluZXJcIik7dGhpcy5tb2RlbD1lfSx0fShCYXNlQ2FsbGJhY2spO2V4cG9ydHtleHBvcnRzX2NvbnN0cmFpbnRzIGFzIGNvbnN0cmFpbnRzLGV4cG9ydHNfaW5pdGlhbGl6ZXJzIGFzIGluaXRpYWxpemVycyxleHBvcnRzX2xheWVycyBhcyBsYXllcnMsZXhwb3J0c19tb2RlbHMgYXMgbW9kZWxzLGV4cG9ydHNfbWV0cmljcyBhcyBtZXRyaWNzLGV4cG9ydHNfcmVndWxhcml6ZXJzIGFzIHJlZ3VsYXJpemVycyxDYWxsYmFja0xpc3QsQ3VzdG9tQ2FsbGJhY2ssSGlzdG9yeSxDYWxsYmFjayxJbnB1dFNwZWMsU3ltYm9saWNUZW5zb3IsTW9kZWwsaW5wdXQsbG9hZE1vZGVsLG1vZGVsLHJlZ2lzdGVyQ2FsbGJhY2tDb25zdHJ1Y3RvcixzZXF1ZW50aWFsLFJOTixTZXF1ZW50aWFsLExheWVyVmFyaWFibGUsdmVyc2lvbiBhcyB2ZXJzaW9uX2xheWVyc307XG4vLyMgc291cmNlTWFwcGluZ1VSTD10Zi1sYXllcnMuZXNtLmpzLm1hcFxuIiwiLy8gQHRlbnNvcmZsb3cvdGZqcyBDb3B5cmlnaHQgMjAxOCBHb29nbGVcbmltcG9ydHt2ZXJzaW9uX2NvcmV9ZnJvbVwiQHRlbnNvcmZsb3cvdGZqcy1jb3JlXCI7ZXhwb3J0KmZyb21cIkB0ZW5zb3JmbG93L3RmanMtY29yZVwiO2ltcG9ydHt2ZXJzaW9uX2xheWVyc31mcm9tXCJAdGVuc29yZmxvdy90ZmpzLWxheWVyc1wiO2V4cG9ydCpmcm9tXCJAdGVuc29yZmxvdy90ZmpzLWxheWVyc1wiO2ltcG9ydHt2ZXJzaW9uX2NvbnZlcnRlcn1mcm9tXCJAdGVuc29yZmxvdy90ZmpzLWNvbnZlcnRlclwiO2V4cG9ydCpmcm9tXCJAdGVuc29yZmxvdy90ZmpzLWNvbnZlcnRlclwiO3ZhciB2ZXJzaW9uPVwiMC4xMy41XCIsdmVyc2lvbiQxPXtcInRmanMtY29yZVwiOnZlcnNpb25fY29yZSxcInRmanMtbGF5ZXJzXCI6dmVyc2lvbl9sYXllcnMsXCJ0ZmpzLWNvbnZlcnRlclwiOnZlcnNpb25fY29udmVydGVyLHRmanM6dmVyc2lvbn07ZXhwb3J0e3ZlcnNpb24kMSBhcyB2ZXJzaW9ufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRmLmVzbS5qcy5tYXBcbiIsInZhciBhc24xID0gZXhwb3J0cztcblxuYXNuMS5iaWdudW0gPSByZXF1aXJlKCdibi5qcycpO1xuXG5hc24xLmRlZmluZSA9IHJlcXVpcmUoJy4vYXNuMS9hcGknKS5kZWZpbmU7XG5hc24xLmJhc2UgPSByZXF1aXJlKCcuL2FzbjEvYmFzZScpO1xuYXNuMS5jb25zdGFudHMgPSByZXF1aXJlKCcuL2FzbjEvY29uc3RhbnRzJyk7XG5hc24xLmRlY29kZXJzID0gcmVxdWlyZSgnLi9hc24xL2RlY29kZXJzJyk7XG5hc24xLmVuY29kZXJzID0gcmVxdWlyZSgnLi9hc24xL2VuY29kZXJzJyk7XG4iLCJ2YXIgYXNuMSA9IHJlcXVpcmUoJy4uL2FzbjEnKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbnZhciBhcGkgPSBleHBvcnRzO1xuXG5hcGkuZGVmaW5lID0gZnVuY3Rpb24gZGVmaW5lKG5hbWUsIGJvZHkpIHtcbiAgcmV0dXJuIG5ldyBFbnRpdHkobmFtZSwgYm9keSk7XG59O1xuXG5mdW5jdGlvbiBFbnRpdHkobmFtZSwgYm9keSkge1xuICB0aGlzLm5hbWUgPSBuYW1lO1xuICB0aGlzLmJvZHkgPSBib2R5O1xuXG4gIHRoaXMuZGVjb2RlcnMgPSB7fTtcbiAgdGhpcy5lbmNvZGVycyA9IHt9O1xufTtcblxuRW50aXR5LnByb3RvdHlwZS5fY3JlYXRlTmFtZWQgPSBmdW5jdGlvbiBjcmVhdGVOYW1lZChiYXNlKSB7XG4gIHZhciBuYW1lZDtcbiAgdHJ5IHtcbiAgICBuYW1lZCA9IHJlcXVpcmUoJ3ZtJykucnVuSW5UaGlzQ29udGV4dChcbiAgICAgICcoZnVuY3Rpb24gJyArIHRoaXMubmFtZSArICcoZW50aXR5KSB7XFxuJyArXG4gICAgICAnICB0aGlzLl9pbml0TmFtZWQoZW50aXR5KTtcXG4nICtcbiAgICAgICd9KSdcbiAgICApO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbmFtZWQgPSBmdW5jdGlvbiAoZW50aXR5KSB7XG4gICAgICB0aGlzLl9pbml0TmFtZWQoZW50aXR5KTtcbiAgICB9O1xuICB9XG4gIGluaGVyaXRzKG5hbWVkLCBiYXNlKTtcbiAgbmFtZWQucHJvdG90eXBlLl9pbml0TmFtZWQgPSBmdW5jdGlvbiBpbml0bmFtZWQoZW50aXR5KSB7XG4gICAgYmFzZS5jYWxsKHRoaXMsIGVudGl0eSk7XG4gIH07XG5cbiAgcmV0dXJuIG5ldyBuYW1lZCh0aGlzKTtcbn07XG5cbkVudGl0eS5wcm90b3R5cGUuX2dldERlY29kZXIgPSBmdW5jdGlvbiBfZ2V0RGVjb2RlcihlbmMpIHtcbiAgZW5jID0gZW5jIHx8ICdkZXInO1xuICAvLyBMYXppbHkgY3JlYXRlIGRlY29kZXJcbiAgaWYgKCF0aGlzLmRlY29kZXJzLmhhc093blByb3BlcnR5KGVuYykpXG4gICAgdGhpcy5kZWNvZGVyc1tlbmNdID0gdGhpcy5fY3JlYXRlTmFtZWQoYXNuMS5kZWNvZGVyc1tlbmNdKTtcbiAgcmV0dXJuIHRoaXMuZGVjb2RlcnNbZW5jXTtcbn07XG5cbkVudGl0eS5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKGRhdGEsIGVuYywgb3B0aW9ucykge1xuICByZXR1cm4gdGhpcy5fZ2V0RGVjb2RlcihlbmMpLmRlY29kZShkYXRhLCBvcHRpb25zKTtcbn07XG5cbkVudGl0eS5wcm90b3R5cGUuX2dldEVuY29kZXIgPSBmdW5jdGlvbiBfZ2V0RW5jb2RlcihlbmMpIHtcbiAgZW5jID0gZW5jIHx8ICdkZXInO1xuICAvLyBMYXppbHkgY3JlYXRlIGVuY29kZXJcbiAgaWYgKCF0aGlzLmVuY29kZXJzLmhhc093blByb3BlcnR5KGVuYykpXG4gICAgdGhpcy5lbmNvZGVyc1tlbmNdID0gdGhpcy5fY3JlYXRlTmFtZWQoYXNuMS5lbmNvZGVyc1tlbmNdKTtcbiAgcmV0dXJuIHRoaXMuZW5jb2RlcnNbZW5jXTtcbn07XG5cbkVudGl0eS5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKGRhdGEsIGVuYywgLyogaW50ZXJuYWwgKi8gcmVwb3J0ZXIpIHtcbiAgcmV0dXJuIHRoaXMuX2dldEVuY29kZXIoZW5jKS5lbmNvZGUoZGF0YSwgcmVwb3J0ZXIpO1xufTtcbiIsInZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG52YXIgUmVwb3J0ZXIgPSByZXF1aXJlKCcuLi9iYXNlJykuUmVwb3J0ZXI7XG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG5mdW5jdGlvbiBEZWNvZGVyQnVmZmVyKGJhc2UsIG9wdGlvbnMpIHtcbiAgUmVwb3J0ZXIuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYmFzZSkpIHtcbiAgICB0aGlzLmVycm9yKCdJbnB1dCBub3QgQnVmZmVyJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5iYXNlID0gYmFzZTtcbiAgdGhpcy5vZmZzZXQgPSAwO1xuICB0aGlzLmxlbmd0aCA9IGJhc2UubGVuZ3RoO1xufVxuaW5oZXJpdHMoRGVjb2RlckJ1ZmZlciwgUmVwb3J0ZXIpO1xuZXhwb3J0cy5EZWNvZGVyQnVmZmVyID0gRGVjb2RlckJ1ZmZlcjtcblxuRGVjb2RlckJ1ZmZlci5wcm90b3R5cGUuc2F2ZSA9IGZ1bmN0aW9uIHNhdmUoKSB7XG4gIHJldHVybiB7IG9mZnNldDogdGhpcy5vZmZzZXQsIHJlcG9ydGVyOiBSZXBvcnRlci5wcm90b3R5cGUuc2F2ZS5jYWxsKHRoaXMpIH07XG59O1xuXG5EZWNvZGVyQnVmZmVyLnByb3RvdHlwZS5yZXN0b3JlID0gZnVuY3Rpb24gcmVzdG9yZShzYXZlKSB7XG4gIC8vIFJldHVybiBza2lwcGVkIGRhdGFcbiAgdmFyIHJlcyA9IG5ldyBEZWNvZGVyQnVmZmVyKHRoaXMuYmFzZSk7XG4gIHJlcy5vZmZzZXQgPSBzYXZlLm9mZnNldDtcbiAgcmVzLmxlbmd0aCA9IHRoaXMub2Zmc2V0O1xuXG4gIHRoaXMub2Zmc2V0ID0gc2F2ZS5vZmZzZXQ7XG4gIFJlcG9ydGVyLnByb3RvdHlwZS5yZXN0b3JlLmNhbGwodGhpcywgc2F2ZS5yZXBvcnRlcik7XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbkRlY29kZXJCdWZmZXIucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiBpc0VtcHR5KCkge1xuICByZXR1cm4gdGhpcy5vZmZzZXQgPT09IHRoaXMubGVuZ3RoO1xufTtcblxuRGVjb2RlckJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4KGZhaWwpIHtcbiAgaWYgKHRoaXMub2Zmc2V0ICsgMSA8PSB0aGlzLmxlbmd0aClcbiAgICByZXR1cm4gdGhpcy5iYXNlLnJlYWRVSW50OCh0aGlzLm9mZnNldCsrLCB0cnVlKTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLmVycm9yKGZhaWwgfHwgJ0RlY29kZXJCdWZmZXIgb3ZlcnJ1bicpO1xufVxuXG5EZWNvZGVyQnVmZmVyLnByb3RvdHlwZS5za2lwID0gZnVuY3Rpb24gc2tpcChieXRlcywgZmFpbCkge1xuICBpZiAoISh0aGlzLm9mZnNldCArIGJ5dGVzIDw9IHRoaXMubGVuZ3RoKSlcbiAgICByZXR1cm4gdGhpcy5lcnJvcihmYWlsIHx8ICdEZWNvZGVyQnVmZmVyIG92ZXJydW4nKTtcblxuICB2YXIgcmVzID0gbmV3IERlY29kZXJCdWZmZXIodGhpcy5iYXNlKTtcblxuICAvLyBTaGFyZSByZXBvcnRlciBzdGF0ZVxuICByZXMuX3JlcG9ydGVyU3RhdGUgPSB0aGlzLl9yZXBvcnRlclN0YXRlO1xuXG4gIHJlcy5vZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgcmVzLmxlbmd0aCA9IHRoaXMub2Zmc2V0ICsgYnl0ZXM7XG4gIHRoaXMub2Zmc2V0ICs9IGJ5dGVzO1xuICByZXR1cm4gcmVzO1xufVxuXG5EZWNvZGVyQnVmZmVyLnByb3RvdHlwZS5yYXcgPSBmdW5jdGlvbiByYXcoc2F2ZSkge1xuICByZXR1cm4gdGhpcy5iYXNlLnNsaWNlKHNhdmUgPyBzYXZlLm9mZnNldCA6IHRoaXMub2Zmc2V0LCB0aGlzLmxlbmd0aCk7XG59XG5cbmZ1bmN0aW9uIEVuY29kZXJCdWZmZXIodmFsdWUsIHJlcG9ydGVyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWUubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgIGlmICghKGl0ZW0gaW5zdGFuY2VvZiBFbmNvZGVyQnVmZmVyKSlcbiAgICAgICAgaXRlbSA9IG5ldyBFbmNvZGVyQnVmZmVyKGl0ZW0sIHJlcG9ydGVyKTtcbiAgICAgIHRoaXMubGVuZ3RoICs9IGl0ZW0ubGVuZ3RoO1xuICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfSwgdGhpcyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIGlmICghKDAgPD0gdmFsdWUgJiYgdmFsdWUgPD0gMHhmZikpXG4gICAgICByZXR1cm4gcmVwb3J0ZXIuZXJyb3IoJ25vbi1ieXRlIEVuY29kZXJCdWZmZXIgdmFsdWUnKTtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5sZW5ndGggPSAxO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5sZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLmxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVwb3J0ZXIuZXJyb3IoJ1Vuc3VwcG9ydGVkIHR5cGU6ICcgKyB0eXBlb2YgdmFsdWUpO1xuICB9XG59XG5leHBvcnRzLkVuY29kZXJCdWZmZXIgPSBFbmNvZGVyQnVmZmVyO1xuXG5FbmNvZGVyQnVmZmVyLnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gam9pbihvdXQsIG9mZnNldCkge1xuICBpZiAoIW91dClcbiAgICBvdXQgPSBuZXcgQnVmZmVyKHRoaXMubGVuZ3RoKTtcbiAgaWYgKCFvZmZzZXQpXG4gICAgb2Zmc2V0ID0gMDtcblxuICBpZiAodGhpcy5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIG91dDtcblxuICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLnZhbHVlKSkge1xuICAgIHRoaXMudmFsdWUuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICBpdGVtLmpvaW4ob3V0LCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0ICs9IGl0ZW0ubGVuZ3RoO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgdGhpcy52YWx1ZSA9PT0gJ251bWJlcicpXG4gICAgICBvdXRbb2Zmc2V0XSA9IHRoaXMudmFsdWU7XG4gICAgZWxzZSBpZiAodHlwZW9mIHRoaXMudmFsdWUgPT09ICdzdHJpbmcnKVxuICAgICAgb3V0LndyaXRlKHRoaXMudmFsdWUsIG9mZnNldCk7XG4gICAgZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKHRoaXMudmFsdWUpKVxuICAgICAgdGhpcy52YWx1ZS5jb3B5KG91dCwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gdGhpcy5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufTtcbiIsInZhciBiYXNlID0gZXhwb3J0cztcblxuYmFzZS5SZXBvcnRlciA9IHJlcXVpcmUoJy4vcmVwb3J0ZXInKS5SZXBvcnRlcjtcbmJhc2UuRGVjb2RlckJ1ZmZlciA9IHJlcXVpcmUoJy4vYnVmZmVyJykuRGVjb2RlckJ1ZmZlcjtcbmJhc2UuRW5jb2RlckJ1ZmZlciA9IHJlcXVpcmUoJy4vYnVmZmVyJykuRW5jb2RlckJ1ZmZlcjtcbmJhc2UuTm9kZSA9IHJlcXVpcmUoJy4vbm9kZScpO1xuIiwidmFyIFJlcG9ydGVyID0gcmVxdWlyZSgnLi4vYmFzZScpLlJlcG9ydGVyO1xudmFyIEVuY29kZXJCdWZmZXIgPSByZXF1aXJlKCcuLi9iYXNlJykuRW5jb2RlckJ1ZmZlcjtcbnZhciBEZWNvZGVyQnVmZmVyID0gcmVxdWlyZSgnLi4vYmFzZScpLkRlY29kZXJCdWZmZXI7XG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnbWluaW1hbGlzdGljLWFzc2VydCcpO1xuXG4vLyBTdXBwb3J0ZWQgdGFnc1xudmFyIHRhZ3MgPSBbXG4gICdzZXEnLCAnc2Vxb2YnLCAnc2V0JywgJ3NldG9mJywgJ29iamlkJywgJ2Jvb2wnLFxuICAnZ2VudGltZScsICd1dGN0aW1lJywgJ251bGxfJywgJ2VudW0nLCAnaW50JywgJ29iakRlc2MnLFxuICAnYml0c3RyJywgJ2JtcHN0cicsICdjaGFyc3RyJywgJ2dlbnN0cicsICdncmFwaHN0cicsICdpYTVzdHInLCAnaXNvNjQ2c3RyJyxcbiAgJ251bXN0cicsICdvY3RzdHInLCAncHJpbnRzdHInLCAndDYxc3RyJywgJ3VuaXN0cicsICd1dGY4c3RyJywgJ3ZpZGVvc3RyJ1xuXTtcblxuLy8gUHVibGljIG1ldGhvZHMgbGlzdFxudmFyIG1ldGhvZHMgPSBbXG4gICdrZXknLCAnb2JqJywgJ3VzZScsICdvcHRpb25hbCcsICdleHBsaWNpdCcsICdpbXBsaWNpdCcsICdkZWYnLCAnY2hvaWNlJyxcbiAgJ2FueScsICdjb250YWlucydcbl0uY29uY2F0KHRhZ3MpO1xuXG4vLyBPdmVycmlkZWQgbWV0aG9kcyBsaXN0XG52YXIgb3ZlcnJpZGVkID0gW1xuICAnX3BlZWtUYWcnLCAnX2RlY29kZVRhZycsICdfdXNlJyxcbiAgJ19kZWNvZGVTdHInLCAnX2RlY29kZU9iamlkJywgJ19kZWNvZGVUaW1lJyxcbiAgJ19kZWNvZGVOdWxsJywgJ19kZWNvZGVJbnQnLCAnX2RlY29kZUJvb2wnLCAnX2RlY29kZUxpc3QnLFxuXG4gICdfZW5jb2RlQ29tcG9zaXRlJywgJ19lbmNvZGVTdHInLCAnX2VuY29kZU9iamlkJywgJ19lbmNvZGVUaW1lJyxcbiAgJ19lbmNvZGVOdWxsJywgJ19lbmNvZGVJbnQnLCAnX2VuY29kZUJvb2wnXG5dO1xuXG5mdW5jdGlvbiBOb2RlKGVuYywgcGFyZW50KSB7XG4gIHZhciBzdGF0ZSA9IHt9O1xuICB0aGlzLl9iYXNlU3RhdGUgPSBzdGF0ZTtcblxuICBzdGF0ZS5lbmMgPSBlbmM7XG5cbiAgc3RhdGUucGFyZW50ID0gcGFyZW50IHx8IG51bGw7XG4gIHN0YXRlLmNoaWxkcmVuID0gbnVsbDtcblxuICAvLyBTdGF0ZVxuICBzdGF0ZS50YWcgPSBudWxsO1xuICBzdGF0ZS5hcmdzID0gbnVsbDtcbiAgc3RhdGUucmV2ZXJzZUFyZ3MgPSBudWxsO1xuICBzdGF0ZS5jaG9pY2UgPSBudWxsO1xuICBzdGF0ZS5vcHRpb25hbCA9IGZhbHNlO1xuICBzdGF0ZS5hbnkgPSBmYWxzZTtcbiAgc3RhdGUub2JqID0gZmFsc2U7XG4gIHN0YXRlLnVzZSA9IG51bGw7XG4gIHN0YXRlLnVzZURlY29kZXIgPSBudWxsO1xuICBzdGF0ZS5rZXkgPSBudWxsO1xuICBzdGF0ZVsnZGVmYXVsdCddID0gbnVsbDtcbiAgc3RhdGUuZXhwbGljaXQgPSBudWxsO1xuICBzdGF0ZS5pbXBsaWNpdCA9IG51bGw7XG4gIHN0YXRlLmNvbnRhaW5zID0gbnVsbDtcblxuICAvLyBTaG91bGQgY3JlYXRlIG5ldyBpbnN0YW5jZSBvbiBlYWNoIG1ldGhvZFxuICBpZiAoIXN0YXRlLnBhcmVudCkge1xuICAgIHN0YXRlLmNoaWxkcmVuID0gW107XG4gICAgdGhpcy5fd3JhcCgpO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IE5vZGU7XG5cbnZhciBzdGF0ZVByb3BzID0gW1xuICAnZW5jJywgJ3BhcmVudCcsICdjaGlsZHJlbicsICd0YWcnLCAnYXJncycsICdyZXZlcnNlQXJncycsICdjaG9pY2UnLFxuICAnb3B0aW9uYWwnLCAnYW55JywgJ29iaicsICd1c2UnLCAnYWx0ZXJlZFVzZScsICdrZXknLCAnZGVmYXVsdCcsICdleHBsaWNpdCcsXG4gICdpbXBsaWNpdCcsICdjb250YWlucydcbl07XG5cbk5vZGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcbiAgdmFyIGNzdGF0ZSA9IHt9O1xuICBzdGF0ZVByb3BzLmZvckVhY2goZnVuY3Rpb24ocHJvcCkge1xuICAgIGNzdGF0ZVtwcm9wXSA9IHN0YXRlW3Byb3BdO1xuICB9KTtcbiAgdmFyIHJlcyA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKGNzdGF0ZS5wYXJlbnQpO1xuICByZXMuX2Jhc2VTdGF0ZSA9IGNzdGF0ZTtcbiAgcmV0dXJuIHJlcztcbn07XG5cbk5vZGUucHJvdG90eXBlLl93cmFwID0gZnVuY3Rpb24gd3JhcCgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuICBtZXRob2RzLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgdGhpc1ttZXRob2RdID0gZnVuY3Rpb24gX3dyYXBwZWRNZXRob2QoKSB7XG4gICAgICB2YXIgY2xvbmUgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzKTtcbiAgICAgIHN0YXRlLmNoaWxkcmVuLnB1c2goY2xvbmUpO1xuICAgICAgcmV0dXJuIGNsb25lW21ldGhvZF0uYXBwbHkoY2xvbmUsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfSwgdGhpcyk7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIGluaXQoYm9keSkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgYXNzZXJ0KHN0YXRlLnBhcmVudCA9PT0gbnVsbCk7XG4gIGJvZHkuY2FsbCh0aGlzKTtcblxuICAvLyBGaWx0ZXIgY2hpbGRyZW5cbiAgc3RhdGUuY2hpbGRyZW4gPSBzdGF0ZS5jaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24oY2hpbGQpIHtcbiAgICByZXR1cm4gY2hpbGQuX2Jhc2VTdGF0ZS5wYXJlbnQgPT09IHRoaXM7XG4gIH0sIHRoaXMpO1xuICBhc3NlcnQuZXF1YWwoc3RhdGUuY2hpbGRyZW4ubGVuZ3RoLCAxLCAnUm9vdCBub2RlIGNhbiBoYXZlIG9ubHkgb25lIGNoaWxkJyk7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5fdXNlQXJncyA9IGZ1bmN0aW9uIHVzZUFyZ3MoYXJncykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgLy8gRmlsdGVyIGNoaWxkcmVuIGFuZCBhcmdzXG4gIHZhciBjaGlsZHJlbiA9IGFyZ3MuZmlsdGVyKGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBhcmcgaW5zdGFuY2VvZiB0aGlzLmNvbnN0cnVjdG9yO1xuICB9LCB0aGlzKTtcbiAgYXJncyA9IGFyZ3MuZmlsdGVyKGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiAhKGFyZyBpbnN0YW5jZW9mIHRoaXMuY29uc3RydWN0b3IpO1xuICB9LCB0aGlzKTtcblxuICBpZiAoY2hpbGRyZW4ubGVuZ3RoICE9PSAwKSB7XG4gICAgYXNzZXJ0KHN0YXRlLmNoaWxkcmVuID09PSBudWxsKTtcbiAgICBzdGF0ZS5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuXG4gICAgLy8gUmVwbGFjZSBwYXJlbnQgdG8gbWFpbnRhaW4gYmFja3dhcmQgbGlua1xuICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgIGNoaWxkLl9iYXNlU3RhdGUucGFyZW50ID0gdGhpcztcbiAgICB9LCB0aGlzKTtcbiAgfVxuICBpZiAoYXJncy5sZW5ndGggIT09IDApIHtcbiAgICBhc3NlcnQoc3RhdGUuYXJncyA9PT0gbnVsbCk7XG4gICAgc3RhdGUuYXJncyA9IGFyZ3M7XG4gICAgc3RhdGUucmV2ZXJzZUFyZ3MgPSBhcmdzLm1hcChmdW5jdGlvbihhcmcpIHtcbiAgICAgIGlmICh0eXBlb2YgYXJnICE9PSAnb2JqZWN0JyB8fCBhcmcuY29uc3RydWN0b3IgIT09IE9iamVjdClcbiAgICAgICAgcmV0dXJuIGFyZztcblxuICAgICAgdmFyIHJlcyA9IHt9O1xuICAgICAgT2JqZWN0LmtleXMoYXJnKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICBpZiAoa2V5ID09IChrZXkgfCAwKSlcbiAgICAgICAgICBrZXkgfD0gMDtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJnW2tleV07XG4gICAgICAgIHJlc1t2YWx1ZV0gPSBrZXk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfSk7XG4gIH1cbn07XG5cbi8vXG4vLyBPdmVycmlkZWQgbWV0aG9kc1xuLy9cblxub3ZlcnJpZGVkLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gIE5vZGUucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiBfb3ZlcnJpZGVkKCkge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWV0aG9kICsgJyBub3QgaW1wbGVtZW50ZWQgZm9yIGVuY29kaW5nOiAnICsgc3RhdGUuZW5jKTtcbiAgfTtcbn0pO1xuXG4vL1xuLy8gUHVibGljIG1ldGhvZHNcbi8vXG5cbnRhZ3MuZm9yRWFjaChmdW5jdGlvbih0YWcpIHtcbiAgTm9kZS5wcm90b3R5cGVbdGFnXSA9IGZ1bmN0aW9uIF90YWdNZXRob2QoKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuICAgIGFzc2VydChzdGF0ZS50YWcgPT09IG51bGwpO1xuICAgIHN0YXRlLnRhZyA9IHRhZztcblxuICAgIHRoaXMuX3VzZUFyZ3MoYXJncyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbn0pO1xuXG5Ob2RlLnByb3RvdHlwZS51c2UgPSBmdW5jdGlvbiB1c2UoaXRlbSkge1xuICBhc3NlcnQoaXRlbSk7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICBhc3NlcnQoc3RhdGUudXNlID09PSBudWxsKTtcbiAgc3RhdGUudXNlID0gaXRlbTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbk5vZGUucHJvdG90eXBlLm9wdGlvbmFsID0gZnVuY3Rpb24gb3B0aW9uYWwoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICBzdGF0ZS5vcHRpb25hbCA9IHRydWU7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5kZWYgPSBmdW5jdGlvbiBkZWYodmFsKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICBhc3NlcnQoc3RhdGVbJ2RlZmF1bHQnXSA9PT0gbnVsbCk7XG4gIHN0YXRlWydkZWZhdWx0J10gPSB2YWw7XG4gIHN0YXRlLm9wdGlvbmFsID0gdHJ1ZTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbk5vZGUucHJvdG90eXBlLmV4cGxpY2l0ID0gZnVuY3Rpb24gZXhwbGljaXQobnVtKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICBhc3NlcnQoc3RhdGUuZXhwbGljaXQgPT09IG51bGwgJiYgc3RhdGUuaW1wbGljaXQgPT09IG51bGwpO1xuICBzdGF0ZS5leHBsaWNpdCA9IG51bTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbk5vZGUucHJvdG90eXBlLmltcGxpY2l0ID0gZnVuY3Rpb24gaW1wbGljaXQobnVtKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICBhc3NlcnQoc3RhdGUuZXhwbGljaXQgPT09IG51bGwgJiYgc3RhdGUuaW1wbGljaXQgPT09IG51bGwpO1xuICBzdGF0ZS5pbXBsaWNpdCA9IG51bTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbk5vZGUucHJvdG90eXBlLm9iaiA9IGZ1bmN0aW9uIG9iaigpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgc3RhdGUub2JqID0gdHJ1ZTtcblxuICBpZiAoYXJncy5sZW5ndGggIT09IDApXG4gICAgdGhpcy5fdXNlQXJncyhhcmdzKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbk5vZGUucHJvdG90eXBlLmtleSA9IGZ1bmN0aW9uIGtleShuZXdLZXkpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIGFzc2VydChzdGF0ZS5rZXkgPT09IG51bGwpO1xuICBzdGF0ZS5rZXkgPSBuZXdLZXk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5hbnkgPSBmdW5jdGlvbiBhbnkoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICBzdGF0ZS5hbnkgPSB0cnVlO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuTm9kZS5wcm90b3R5cGUuY2hvaWNlID0gZnVuY3Rpb24gY2hvaWNlKG9iaikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgYXNzZXJ0KHN0YXRlLmNob2ljZSA9PT0gbnVsbCk7XG4gIHN0YXRlLmNob2ljZSA9IG9iajtcbiAgdGhpcy5fdXNlQXJncyhPYmplY3Qua2V5cyhvYmopLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gb2JqW2tleV07XG4gIH0pKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbk5vZGUucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gY29udGFpbnMoaXRlbSkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgYXNzZXJ0KHN0YXRlLnVzZSA9PT0gbnVsbCk7XG4gIHN0YXRlLmNvbnRhaW5zID0gaXRlbTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vXG4vLyBEZWNvZGluZ1xuLy9cblxuTm9kZS5wcm90b3R5cGUuX2RlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShpbnB1dCwgb3B0aW9ucykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgLy8gRGVjb2RlIHJvb3Qgbm9kZVxuICBpZiAoc3RhdGUucGFyZW50ID09PSBudWxsKVxuICAgIHJldHVybiBpbnB1dC53cmFwUmVzdWx0KHN0YXRlLmNoaWxkcmVuWzBdLl9kZWNvZGUoaW5wdXQsIG9wdGlvbnMpKTtcblxuICB2YXIgcmVzdWx0ID0gc3RhdGVbJ2RlZmF1bHQnXTtcbiAgdmFyIHByZXNlbnQgPSB0cnVlO1xuXG4gIHZhciBwcmV2S2V5ID0gbnVsbDtcbiAgaWYgKHN0YXRlLmtleSAhPT0gbnVsbClcbiAgICBwcmV2S2V5ID0gaW5wdXQuZW50ZXJLZXkoc3RhdGUua2V5KTtcblxuICAvLyBDaGVjayBpZiB0YWcgaXMgdGhlcmVcbiAgaWYgKHN0YXRlLm9wdGlvbmFsKSB7XG4gICAgdmFyIHRhZyA9IG51bGw7XG4gICAgaWYgKHN0YXRlLmV4cGxpY2l0ICE9PSBudWxsKVxuICAgICAgdGFnID0gc3RhdGUuZXhwbGljaXQ7XG4gICAgZWxzZSBpZiAoc3RhdGUuaW1wbGljaXQgIT09IG51bGwpXG4gICAgICB0YWcgPSBzdGF0ZS5pbXBsaWNpdDtcbiAgICBlbHNlIGlmIChzdGF0ZS50YWcgIT09IG51bGwpXG4gICAgICB0YWcgPSBzdGF0ZS50YWc7XG5cbiAgICBpZiAodGFnID09PSBudWxsICYmICFzdGF0ZS5hbnkpIHtcbiAgICAgIC8vIFRyaWFsIGFuZCBFcnJvclxuICAgICAgdmFyIHNhdmUgPSBpbnB1dC5zYXZlKCk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoc3RhdGUuY2hvaWNlID09PSBudWxsKVxuICAgICAgICAgIHRoaXMuX2RlY29kZUdlbmVyaWMoc3RhdGUudGFnLCBpbnB1dCwgb3B0aW9ucyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0aGlzLl9kZWNvZGVDaG9pY2UoaW5wdXQsIG9wdGlvbnMpO1xuICAgICAgICBwcmVzZW50ID0gdHJ1ZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcHJlc2VudCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaW5wdXQucmVzdG9yZShzYXZlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJlc2VudCA9IHRoaXMuX3BlZWtUYWcoaW5wdXQsIHRhZywgc3RhdGUuYW55KTtcblxuICAgICAgaWYgKGlucHV0LmlzRXJyb3IocHJlc2VudCkpXG4gICAgICAgIHJldHVybiBwcmVzZW50O1xuICAgIH1cbiAgfVxuXG4gIC8vIFB1c2ggb2JqZWN0IG9uIHN0YWNrXG4gIHZhciBwcmV2T2JqO1xuICBpZiAoc3RhdGUub2JqICYmIHByZXNlbnQpXG4gICAgcHJldk9iaiA9IGlucHV0LmVudGVyT2JqZWN0KCk7XG5cbiAgaWYgKHByZXNlbnQpIHtcbiAgICAvLyBVbndyYXAgZXhwbGljaXQgdmFsdWVzXG4gICAgaWYgKHN0YXRlLmV4cGxpY2l0ICE9PSBudWxsKSB7XG4gICAgICB2YXIgZXhwbGljaXQgPSB0aGlzLl9kZWNvZGVUYWcoaW5wdXQsIHN0YXRlLmV4cGxpY2l0KTtcbiAgICAgIGlmIChpbnB1dC5pc0Vycm9yKGV4cGxpY2l0KSlcbiAgICAgICAgcmV0dXJuIGV4cGxpY2l0O1xuICAgICAgaW5wdXQgPSBleHBsaWNpdDtcbiAgICB9XG5cbiAgICB2YXIgc3RhcnQgPSBpbnB1dC5vZmZzZXQ7XG5cbiAgICAvLyBVbndyYXAgaW1wbGljaXQgYW5kIG5vcm1hbCB2YWx1ZXNcbiAgICBpZiAoc3RhdGUudXNlID09PSBudWxsICYmIHN0YXRlLmNob2ljZSA9PT0gbnVsbCkge1xuICAgICAgaWYgKHN0YXRlLmFueSlcbiAgICAgICAgdmFyIHNhdmUgPSBpbnB1dC5zYXZlKCk7XG4gICAgICB2YXIgYm9keSA9IHRoaXMuX2RlY29kZVRhZyhcbiAgICAgICAgaW5wdXQsXG4gICAgICAgIHN0YXRlLmltcGxpY2l0ICE9PSBudWxsID8gc3RhdGUuaW1wbGljaXQgOiBzdGF0ZS50YWcsXG4gICAgICAgIHN0YXRlLmFueVxuICAgICAgKTtcbiAgICAgIGlmIChpbnB1dC5pc0Vycm9yKGJvZHkpKVxuICAgICAgICByZXR1cm4gYm9keTtcblxuICAgICAgaWYgKHN0YXRlLmFueSlcbiAgICAgICAgcmVzdWx0ID0gaW5wdXQucmF3KHNhdmUpO1xuICAgICAgZWxzZVxuICAgICAgICBpbnB1dCA9IGJvZHk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy50cmFjayAmJiBzdGF0ZS50YWcgIT09IG51bGwpXG4gICAgICBvcHRpb25zLnRyYWNrKGlucHV0LnBhdGgoKSwgc3RhcnQsIGlucHV0Lmxlbmd0aCwgJ3RhZ2dlZCcpO1xuXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy50cmFjayAmJiBzdGF0ZS50YWcgIT09IG51bGwpXG4gICAgICBvcHRpb25zLnRyYWNrKGlucHV0LnBhdGgoKSwgaW5wdXQub2Zmc2V0LCBpbnB1dC5sZW5ndGgsICdjb250ZW50Jyk7XG5cbiAgICAvLyBTZWxlY3QgcHJvcGVyIG1ldGhvZCBmb3IgdGFnXG4gICAgaWYgKHN0YXRlLmFueSlcbiAgICAgIHJlc3VsdCA9IHJlc3VsdDtcbiAgICBlbHNlIGlmIChzdGF0ZS5jaG9pY2UgPT09IG51bGwpXG4gICAgICByZXN1bHQgPSB0aGlzLl9kZWNvZGVHZW5lcmljKHN0YXRlLnRhZywgaW5wdXQsIG9wdGlvbnMpO1xuICAgIGVsc2VcbiAgICAgIHJlc3VsdCA9IHRoaXMuX2RlY29kZUNob2ljZShpbnB1dCwgb3B0aW9ucyk7XG5cbiAgICBpZiAoaW5wdXQuaXNFcnJvcihyZXN1bHQpKVxuICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIC8vIERlY29kZSBjaGlsZHJlblxuICAgIGlmICghc3RhdGUuYW55ICYmIHN0YXRlLmNob2ljZSA9PT0gbnVsbCAmJiBzdGF0ZS5jaGlsZHJlbiAhPT0gbnVsbCkge1xuICAgICAgc3RhdGUuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiBkZWNvZGVDaGlsZHJlbihjaGlsZCkge1xuICAgICAgICAvLyBOT1RFOiBXZSBhcmUgaWdub3JpbmcgZXJyb3JzIGhlcmUsIHRvIGxldCBwYXJzZXIgY29udGludWUgd2l0aCBvdGhlclxuICAgICAgICAvLyBwYXJ0cyBvZiBlbmNvZGVkIGRhdGFcbiAgICAgICAgY2hpbGQuX2RlY29kZShpbnB1dCwgb3B0aW9ucyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBEZWNvZGUgY29udGFpbmVkL2VuY29kZWQgYnkgc2NoZW1hLCBvbmx5IGluIGJpdCBvciBvY3RldCBzdHJpbmdzXG4gICAgaWYgKHN0YXRlLmNvbnRhaW5zICYmIChzdGF0ZS50YWcgPT09ICdvY3RzdHInIHx8IHN0YXRlLnRhZyA9PT0gJ2JpdHN0cicpKSB7XG4gICAgICB2YXIgZGF0YSA9IG5ldyBEZWNvZGVyQnVmZmVyKHJlc3VsdCk7XG4gICAgICByZXN1bHQgPSB0aGlzLl9nZXRVc2Uoc3RhdGUuY29udGFpbnMsIGlucHV0Ll9yZXBvcnRlclN0YXRlLm9iailcbiAgICAgICAgICAuX2RlY29kZShkYXRhLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICAvLyBQb3Agb2JqZWN0XG4gIGlmIChzdGF0ZS5vYmogJiYgcHJlc2VudClcbiAgICByZXN1bHQgPSBpbnB1dC5sZWF2ZU9iamVjdChwcmV2T2JqKTtcblxuICAvLyBTZXQga2V5XG4gIGlmIChzdGF0ZS5rZXkgIT09IG51bGwgJiYgKHJlc3VsdCAhPT0gbnVsbCB8fCBwcmVzZW50ID09PSB0cnVlKSlcbiAgICBpbnB1dC5sZWF2ZUtleShwcmV2S2V5LCBzdGF0ZS5rZXksIHJlc3VsdCk7XG4gIGVsc2UgaWYgKHByZXZLZXkgIT09IG51bGwpXG4gICAgaW5wdXQuZXhpdEtleShwcmV2S2V5KTtcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuTm9kZS5wcm90b3R5cGUuX2RlY29kZUdlbmVyaWMgPSBmdW5jdGlvbiBkZWNvZGVHZW5lcmljKHRhZywgaW5wdXQsIG9wdGlvbnMpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIGlmICh0YWcgPT09ICdzZXEnIHx8IHRhZyA9PT0gJ3NldCcpXG4gICAgcmV0dXJuIG51bGw7XG4gIGlmICh0YWcgPT09ICdzZXFvZicgfHwgdGFnID09PSAnc2V0b2YnKVxuICAgIHJldHVybiB0aGlzLl9kZWNvZGVMaXN0KGlucHV0LCB0YWcsIHN0YXRlLmFyZ3NbMF0sIG9wdGlvbnMpO1xuICBlbHNlIGlmICgvc3RyJC8udGVzdCh0YWcpKVxuICAgIHJldHVybiB0aGlzLl9kZWNvZGVTdHIoaW5wdXQsIHRhZywgb3B0aW9ucyk7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ29iamlkJyAmJiBzdGF0ZS5hcmdzKVxuICAgIHJldHVybiB0aGlzLl9kZWNvZGVPYmppZChpbnB1dCwgc3RhdGUuYXJnc1swXSwgc3RhdGUuYXJnc1sxXSwgb3B0aW9ucyk7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ29iamlkJylcbiAgICByZXR1cm4gdGhpcy5fZGVjb2RlT2JqaWQoaW5wdXQsIG51bGwsIG51bGwsIG9wdGlvbnMpO1xuICBlbHNlIGlmICh0YWcgPT09ICdnZW50aW1lJyB8fCB0YWcgPT09ICd1dGN0aW1lJylcbiAgICByZXR1cm4gdGhpcy5fZGVjb2RlVGltZShpbnB1dCwgdGFnLCBvcHRpb25zKTtcbiAgZWxzZSBpZiAodGFnID09PSAnbnVsbF8nKVxuICAgIHJldHVybiB0aGlzLl9kZWNvZGVOdWxsKGlucHV0LCBvcHRpb25zKTtcbiAgZWxzZSBpZiAodGFnID09PSAnYm9vbCcpXG4gICAgcmV0dXJuIHRoaXMuX2RlY29kZUJvb2woaW5wdXQsIG9wdGlvbnMpO1xuICBlbHNlIGlmICh0YWcgPT09ICdvYmpEZXNjJylcbiAgICByZXR1cm4gdGhpcy5fZGVjb2RlU3RyKGlucHV0LCB0YWcsIG9wdGlvbnMpO1xuICBlbHNlIGlmICh0YWcgPT09ICdpbnQnIHx8IHRhZyA9PT0gJ2VudW0nKVxuICAgIHJldHVybiB0aGlzLl9kZWNvZGVJbnQoaW5wdXQsIHN0YXRlLmFyZ3MgJiYgc3RhdGUuYXJnc1swXSwgb3B0aW9ucyk7XG5cbiAgaWYgKHN0YXRlLnVzZSAhPT0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRVc2Uoc3RhdGUudXNlLCBpbnB1dC5fcmVwb3J0ZXJTdGF0ZS5vYmopXG4gICAgICAgIC5fZGVjb2RlKGlucHV0LCBvcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gaW5wdXQuZXJyb3IoJ3Vua25vd24gdGFnOiAnICsgdGFnKTtcbiAgfVxufTtcblxuTm9kZS5wcm90b3R5cGUuX2dldFVzZSA9IGZ1bmN0aW9uIF9nZXRVc2UoZW50aXR5LCBvYmopIHtcblxuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG4gIC8vIENyZWF0ZSBhbHRlcmVkIHVzZSBkZWNvZGVyIGlmIGltcGxpY2l0IGlzIHNldFxuICBzdGF0ZS51c2VEZWNvZGVyID0gdGhpcy5fdXNlKGVudGl0eSwgb2JqKTtcbiAgYXNzZXJ0KHN0YXRlLnVzZURlY29kZXIuX2Jhc2VTdGF0ZS5wYXJlbnQgPT09IG51bGwpO1xuICBzdGF0ZS51c2VEZWNvZGVyID0gc3RhdGUudXNlRGVjb2Rlci5fYmFzZVN0YXRlLmNoaWxkcmVuWzBdO1xuICBpZiAoc3RhdGUuaW1wbGljaXQgIT09IHN0YXRlLnVzZURlY29kZXIuX2Jhc2VTdGF0ZS5pbXBsaWNpdCkge1xuICAgIHN0YXRlLnVzZURlY29kZXIgPSBzdGF0ZS51c2VEZWNvZGVyLmNsb25lKCk7XG4gICAgc3RhdGUudXNlRGVjb2Rlci5fYmFzZVN0YXRlLmltcGxpY2l0ID0gc3RhdGUuaW1wbGljaXQ7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLnVzZURlY29kZXI7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5fZGVjb2RlQ2hvaWNlID0gZnVuY3Rpb24gZGVjb2RlQ2hvaWNlKGlucHV0LCBvcHRpb25zKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcbiAgdmFyIHJlc3VsdCA9IG51bGw7XG4gIHZhciBtYXRjaCA9IGZhbHNlO1xuXG4gIE9iamVjdC5rZXlzKHN0YXRlLmNob2ljZSkuc29tZShmdW5jdGlvbihrZXkpIHtcbiAgICB2YXIgc2F2ZSA9IGlucHV0LnNhdmUoKTtcbiAgICB2YXIgbm9kZSA9IHN0YXRlLmNob2ljZVtrZXldO1xuICAgIHRyeSB7XG4gICAgICB2YXIgdmFsdWUgPSBub2RlLl9kZWNvZGUoaW5wdXQsIG9wdGlvbnMpO1xuICAgICAgaWYgKGlucHV0LmlzRXJyb3IodmFsdWUpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgIHJlc3VsdCA9IHsgdHlwZToga2V5LCB2YWx1ZTogdmFsdWUgfTtcbiAgICAgIG1hdGNoID0gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpbnB1dC5yZXN0b3JlKHNhdmUpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgdGhpcyk7XG5cbiAgaWYgKCFtYXRjaClcbiAgICByZXR1cm4gaW5wdXQuZXJyb3IoJ0Nob2ljZSBub3QgbWF0Y2hlZCcpO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vL1xuLy8gRW5jb2Rpbmdcbi8vXG5cbk5vZGUucHJvdG90eXBlLl9jcmVhdGVFbmNvZGVyQnVmZmVyID0gZnVuY3Rpb24gY3JlYXRlRW5jb2RlckJ1ZmZlcihkYXRhKSB7XG4gIHJldHVybiBuZXcgRW5jb2RlckJ1ZmZlcihkYXRhLCB0aGlzLnJlcG9ydGVyKTtcbn07XG5cbk5vZGUucHJvdG90eXBlLl9lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUoZGF0YSwgcmVwb3J0ZXIsIHBhcmVudCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG4gIGlmIChzdGF0ZVsnZGVmYXVsdCddICE9PSBudWxsICYmIHN0YXRlWydkZWZhdWx0J10gPT09IGRhdGEpXG4gICAgcmV0dXJuO1xuXG4gIHZhciByZXN1bHQgPSB0aGlzLl9lbmNvZGVWYWx1ZShkYXRhLCByZXBvcnRlciwgcGFyZW50KTtcbiAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybjtcblxuICBpZiAodGhpcy5fc2tpcERlZmF1bHQocmVzdWx0LCByZXBvcnRlciwgcGFyZW50KSlcbiAgICByZXR1cm47XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbk5vZGUucHJvdG90eXBlLl9lbmNvZGVWYWx1ZSA9IGZ1bmN0aW9uIGVuY29kZShkYXRhLCByZXBvcnRlciwgcGFyZW50KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICAvLyBEZWNvZGUgcm9vdCBub2RlXG4gIGlmIChzdGF0ZS5wYXJlbnQgPT09IG51bGwpXG4gICAgcmV0dXJuIHN0YXRlLmNoaWxkcmVuWzBdLl9lbmNvZGUoZGF0YSwgcmVwb3J0ZXIgfHwgbmV3IFJlcG9ydGVyKCkpO1xuXG4gIHZhciByZXN1bHQgPSBudWxsO1xuXG4gIC8vIFNldCByZXBvcnRlciB0byBzaGFyZSBpdCB3aXRoIGEgY2hpbGQgY2xhc3NcbiAgdGhpcy5yZXBvcnRlciA9IHJlcG9ydGVyO1xuXG4gIC8vIENoZWNrIGlmIGRhdGEgaXMgdGhlcmVcbiAgaWYgKHN0YXRlLm9wdGlvbmFsICYmIGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChzdGF0ZVsnZGVmYXVsdCddICE9PSBudWxsKVxuICAgICAgZGF0YSA9IHN0YXRlWydkZWZhdWx0J11cbiAgICBlbHNlXG4gICAgICByZXR1cm47XG4gIH1cblxuICAvLyBFbmNvZGUgY2hpbGRyZW4gZmlyc3RcbiAgdmFyIGNvbnRlbnQgPSBudWxsO1xuICB2YXIgcHJpbWl0aXZlID0gZmFsc2U7XG4gIGlmIChzdGF0ZS5hbnkpIHtcbiAgICAvLyBBbnl0aGluZyB0aGF0IHdhcyBnaXZlbiBpcyB0cmFuc2xhdGVkIHRvIGJ1ZmZlclxuICAgIHJlc3VsdCA9IHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIoZGF0YSk7XG4gIH0gZWxzZSBpZiAoc3RhdGUuY2hvaWNlKSB7XG4gICAgcmVzdWx0ID0gdGhpcy5fZW5jb2RlQ2hvaWNlKGRhdGEsIHJlcG9ydGVyKTtcbiAgfSBlbHNlIGlmIChzdGF0ZS5jb250YWlucykge1xuICAgIGNvbnRlbnQgPSB0aGlzLl9nZXRVc2Uoc3RhdGUuY29udGFpbnMsIHBhcmVudCkuX2VuY29kZShkYXRhLCByZXBvcnRlcik7XG4gICAgcHJpbWl0aXZlID0gdHJ1ZTtcbiAgfSBlbHNlIGlmIChzdGF0ZS5jaGlsZHJlbikge1xuICAgIGNvbnRlbnQgPSBzdGF0ZS5jaGlsZHJlbi5tYXAoZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgIGlmIChjaGlsZC5fYmFzZVN0YXRlLnRhZyA9PT0gJ251bGxfJylcbiAgICAgICAgcmV0dXJuIGNoaWxkLl9lbmNvZGUobnVsbCwgcmVwb3J0ZXIsIGRhdGEpO1xuXG4gICAgICBpZiAoY2hpbGQuX2Jhc2VTdGF0ZS5rZXkgPT09IG51bGwpXG4gICAgICAgIHJldHVybiByZXBvcnRlci5lcnJvcignQ2hpbGQgc2hvdWxkIGhhdmUgYSBrZXknKTtcbiAgICAgIHZhciBwcmV2S2V5ID0gcmVwb3J0ZXIuZW50ZXJLZXkoY2hpbGQuX2Jhc2VTdGF0ZS5rZXkpO1xuXG4gICAgICBpZiAodHlwZW9mIGRhdGEgIT09ICdvYmplY3QnKVxuICAgICAgICByZXR1cm4gcmVwb3J0ZXIuZXJyb3IoJ0NoaWxkIGV4cGVjdGVkLCBidXQgaW5wdXQgaXMgbm90IG9iamVjdCcpO1xuXG4gICAgICB2YXIgcmVzID0gY2hpbGQuX2VuY29kZShkYXRhW2NoaWxkLl9iYXNlU3RhdGUua2V5XSwgcmVwb3J0ZXIsIGRhdGEpO1xuICAgICAgcmVwb3J0ZXIubGVhdmVLZXkocHJldktleSk7XG5cbiAgICAgIHJldHVybiByZXM7XG4gICAgfSwgdGhpcykuZmlsdGVyKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfSk7XG4gICAgY29udGVudCA9IHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIoY29udGVudCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHN0YXRlLnRhZyA9PT0gJ3NlcW9mJyB8fCBzdGF0ZS50YWcgPT09ICdzZXRvZicpIHtcbiAgICAgIC8vIFRPRE8oaW5kdXRueSk6IHRoaXMgc2hvdWxkIGJlIHRocm93biBvbiBEU0wgbGV2ZWxcbiAgICAgIGlmICghKHN0YXRlLmFyZ3MgJiYgc3RhdGUuYXJncy5sZW5ndGggPT09IDEpKVxuICAgICAgICByZXR1cm4gcmVwb3J0ZXIuZXJyb3IoJ1RvbyBtYW55IGFyZ3MgZm9yIDogJyArIHN0YXRlLnRhZyk7XG5cbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSlcbiAgICAgICAgcmV0dXJuIHJlcG9ydGVyLmVycm9yKCdzZXFvZi9zZXRvZiwgYnV0IGRhdGEgaXMgbm90IEFycmF5Jyk7XG5cbiAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2xvbmUoKTtcbiAgICAgIGNoaWxkLl9iYXNlU3RhdGUuaW1wbGljaXQgPSBudWxsO1xuICAgICAgY29udGVudCA9IHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIoZGF0YS5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFVzZShzdGF0ZS5hcmdzWzBdLCBkYXRhKS5fZW5jb2RlKGl0ZW0sIHJlcG9ydGVyKTtcbiAgICAgIH0sIGNoaWxkKSk7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS51c2UgIT09IG51bGwpIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMuX2dldFVzZShzdGF0ZS51c2UsIHBhcmVudCkuX2VuY29kZShkYXRhLCByZXBvcnRlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRlbnQgPSB0aGlzLl9lbmNvZGVQcmltaXRpdmUoc3RhdGUudGFnLCBkYXRhKTtcbiAgICAgIHByaW1pdGl2ZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLy8gRW5jb2RlIGRhdGEgaXRzZWxmXG4gIHZhciByZXN1bHQ7XG4gIGlmICghc3RhdGUuYW55ICYmIHN0YXRlLmNob2ljZSA9PT0gbnVsbCkge1xuICAgIHZhciB0YWcgPSBzdGF0ZS5pbXBsaWNpdCAhPT0gbnVsbCA/IHN0YXRlLmltcGxpY2l0IDogc3RhdGUudGFnO1xuICAgIHZhciBjbHMgPSBzdGF0ZS5pbXBsaWNpdCA9PT0gbnVsbCA/ICd1bml2ZXJzYWwnIDogJ2NvbnRleHQnO1xuXG4gICAgaWYgKHRhZyA9PT0gbnVsbCkge1xuICAgICAgaWYgKHN0YXRlLnVzZSA9PT0gbnVsbClcbiAgICAgICAgcmVwb3J0ZXIuZXJyb3IoJ1RhZyBjb3VsZCBiZSBvbWl0dGVkIG9ubHkgZm9yIC51c2UoKScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3RhdGUudXNlID09PSBudWxsKVxuICAgICAgICByZXN1bHQgPSB0aGlzLl9lbmNvZGVDb21wb3NpdGUodGFnLCBwcmltaXRpdmUsIGNscywgY29udGVudCk7XG4gICAgfVxuICB9XG5cbiAgLy8gV3JhcCBpbiBleHBsaWNpdFxuICBpZiAoc3RhdGUuZXhwbGljaXQgIT09IG51bGwpXG4gICAgcmVzdWx0ID0gdGhpcy5fZW5jb2RlQ29tcG9zaXRlKHN0YXRlLmV4cGxpY2l0LCBmYWxzZSwgJ2NvbnRleHQnLCByZXN1bHQpO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5fZW5jb2RlQ2hvaWNlID0gZnVuY3Rpb24gZW5jb2RlQ2hvaWNlKGRhdGEsIHJlcG9ydGVyKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICB2YXIgbm9kZSA9IHN0YXRlLmNob2ljZVtkYXRhLnR5cGVdO1xuICBpZiAoIW5vZGUpIHtcbiAgICBhc3NlcnQoXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBkYXRhLnR5cGUgKyAnIG5vdCBmb3VuZCBpbiAnICtcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KE9iamVjdC5rZXlzKHN0YXRlLmNob2ljZSkpKTtcbiAgfVxuICByZXR1cm4gbm9kZS5fZW5jb2RlKGRhdGEudmFsdWUsIHJlcG9ydGVyKTtcbn07XG5cbk5vZGUucHJvdG90eXBlLl9lbmNvZGVQcmltaXRpdmUgPSBmdW5jdGlvbiBlbmNvZGVQcmltaXRpdmUodGFnLCBkYXRhKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICBpZiAoL3N0ciQvLnRlc3QodGFnKSlcbiAgICByZXR1cm4gdGhpcy5fZW5jb2RlU3RyKGRhdGEsIHRhZyk7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ29iamlkJyAmJiBzdGF0ZS5hcmdzKVxuICAgIHJldHVybiB0aGlzLl9lbmNvZGVPYmppZChkYXRhLCBzdGF0ZS5yZXZlcnNlQXJnc1swXSwgc3RhdGUuYXJnc1sxXSk7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ29iamlkJylcbiAgICByZXR1cm4gdGhpcy5fZW5jb2RlT2JqaWQoZGF0YSwgbnVsbCwgbnVsbCk7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ2dlbnRpbWUnIHx8IHRhZyA9PT0gJ3V0Y3RpbWUnKVxuICAgIHJldHVybiB0aGlzLl9lbmNvZGVUaW1lKGRhdGEsIHRhZyk7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ251bGxfJylcbiAgICByZXR1cm4gdGhpcy5fZW5jb2RlTnVsbCgpO1xuICBlbHNlIGlmICh0YWcgPT09ICdpbnQnIHx8IHRhZyA9PT0gJ2VudW0nKVxuICAgIHJldHVybiB0aGlzLl9lbmNvZGVJbnQoZGF0YSwgc3RhdGUuYXJncyAmJiBzdGF0ZS5yZXZlcnNlQXJnc1swXSk7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ2Jvb2wnKVxuICAgIHJldHVybiB0aGlzLl9lbmNvZGVCb29sKGRhdGEpO1xuICBlbHNlIGlmICh0YWcgPT09ICdvYmpEZXNjJylcbiAgICByZXR1cm4gdGhpcy5fZW5jb2RlU3RyKGRhdGEsIHRhZyk7XG4gIGVsc2VcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHRhZzogJyArIHRhZyk7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5faXNOdW1zdHIgPSBmdW5jdGlvbiBpc051bXN0cihzdHIpIHtcbiAgcmV0dXJuIC9eWzAtOSBdKiQvLnRlc3Qoc3RyKTtcbn07XG5cbk5vZGUucHJvdG90eXBlLl9pc1ByaW50c3RyID0gZnVuY3Rpb24gaXNQcmludHN0cihzdHIpIHtcbiAgcmV0dXJuIC9eW0EtWmEtejAtOSAnXFwoXFwpXFwrLFxcLVxcLlxcLzo9XFw/XSokLy50ZXN0KHN0cik7XG59O1xuIiwidmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuZnVuY3Rpb24gUmVwb3J0ZXIob3B0aW9ucykge1xuICB0aGlzLl9yZXBvcnRlclN0YXRlID0ge1xuICAgIG9iajogbnVsbCxcbiAgICBwYXRoOiBbXSxcbiAgICBvcHRpb25zOiBvcHRpb25zIHx8IHt9LFxuICAgIGVycm9yczogW11cbiAgfTtcbn1cbmV4cG9ydHMuUmVwb3J0ZXIgPSBSZXBvcnRlcjtcblxuUmVwb3J0ZXIucHJvdG90eXBlLmlzRXJyb3IgPSBmdW5jdGlvbiBpc0Vycm9yKG9iaikge1xuICByZXR1cm4gb2JqIGluc3RhbmNlb2YgUmVwb3J0ZXJFcnJvcjtcbn07XG5cblJlcG9ydGVyLnByb3RvdHlwZS5zYXZlID0gZnVuY3Rpb24gc2F2ZSgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVwb3J0ZXJTdGF0ZTtcblxuICByZXR1cm4geyBvYmo6IHN0YXRlLm9iaiwgcGF0aExlbjogc3RhdGUucGF0aC5sZW5ndGggfTtcbn07XG5cblJlcG9ydGVyLnByb3RvdHlwZS5yZXN0b3JlID0gZnVuY3Rpb24gcmVzdG9yZShkYXRhKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlcG9ydGVyU3RhdGU7XG5cbiAgc3RhdGUub2JqID0gZGF0YS5vYmo7XG4gIHN0YXRlLnBhdGggPSBzdGF0ZS5wYXRoLnNsaWNlKDAsIGRhdGEucGF0aExlbik7XG59O1xuXG5SZXBvcnRlci5wcm90b3R5cGUuZW50ZXJLZXkgPSBmdW5jdGlvbiBlbnRlcktleShrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX3JlcG9ydGVyU3RhdGUucGF0aC5wdXNoKGtleSk7XG59O1xuXG5SZXBvcnRlci5wcm90b3R5cGUuZXhpdEtleSA9IGZ1bmN0aW9uIGV4aXRLZXkoaW5kZXgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVwb3J0ZXJTdGF0ZTtcblxuICBzdGF0ZS5wYXRoID0gc3RhdGUucGF0aC5zbGljZSgwLCBpbmRleCAtIDEpO1xufTtcblxuUmVwb3J0ZXIucHJvdG90eXBlLmxlYXZlS2V5ID0gZnVuY3Rpb24gbGVhdmVLZXkoaW5kZXgsIGtleSwgdmFsdWUpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVwb3J0ZXJTdGF0ZTtcblxuICB0aGlzLmV4aXRLZXkoaW5kZXgpO1xuICBpZiAoc3RhdGUub2JqICE9PSBudWxsKVxuICAgIHN0YXRlLm9ialtrZXldID0gdmFsdWU7XG59O1xuXG5SZXBvcnRlci5wcm90b3R5cGUucGF0aCA9IGZ1bmN0aW9uIHBhdGgoKSB7XG4gIHJldHVybiB0aGlzLl9yZXBvcnRlclN0YXRlLnBhdGguam9pbignLycpO1xufTtcblxuUmVwb3J0ZXIucHJvdG90eXBlLmVudGVyT2JqZWN0ID0gZnVuY3Rpb24gZW50ZXJPYmplY3QoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlcG9ydGVyU3RhdGU7XG5cbiAgdmFyIHByZXYgPSBzdGF0ZS5vYmo7XG4gIHN0YXRlLm9iaiA9IHt9O1xuICByZXR1cm4gcHJldjtcbn07XG5cblJlcG9ydGVyLnByb3RvdHlwZS5sZWF2ZU9iamVjdCA9IGZ1bmN0aW9uIGxlYXZlT2JqZWN0KHByZXYpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVwb3J0ZXJTdGF0ZTtcblxuICB2YXIgbm93ID0gc3RhdGUub2JqO1xuICBzdGF0ZS5vYmogPSBwcmV2O1xuICByZXR1cm4gbm93O1xufTtcblxuUmVwb3J0ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gZXJyb3IobXNnKSB7XG4gIHZhciBlcnI7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlcG9ydGVyU3RhdGU7XG5cbiAgdmFyIGluaGVyaXRlZCA9IG1zZyBpbnN0YW5jZW9mIFJlcG9ydGVyRXJyb3I7XG4gIGlmIChpbmhlcml0ZWQpIHtcbiAgICBlcnIgPSBtc2c7XG4gIH0gZWxzZSB7XG4gICAgZXJyID0gbmV3IFJlcG9ydGVyRXJyb3Ioc3RhdGUucGF0aC5tYXAoZnVuY3Rpb24oZWxlbSkge1xuICAgICAgcmV0dXJuICdbJyArIEpTT04uc3RyaW5naWZ5KGVsZW0pICsgJ10nO1xuICAgIH0pLmpvaW4oJycpLCBtc2cubWVzc2FnZSB8fCBtc2csIG1zZy5zdGFjayk7XG4gIH1cblxuICBpZiAoIXN0YXRlLm9wdGlvbnMucGFydGlhbClcbiAgICB0aHJvdyBlcnI7XG5cbiAgaWYgKCFpbmhlcml0ZWQpXG4gICAgc3RhdGUuZXJyb3JzLnB1c2goZXJyKTtcblxuICByZXR1cm4gZXJyO1xufTtcblxuUmVwb3J0ZXIucHJvdG90eXBlLndyYXBSZXN1bHQgPSBmdW5jdGlvbiB3cmFwUmVzdWx0KHJlc3VsdCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZXBvcnRlclN0YXRlO1xuICBpZiAoIXN0YXRlLm9wdGlvbnMucGFydGlhbClcbiAgICByZXR1cm4gcmVzdWx0O1xuXG4gIHJldHVybiB7XG4gICAgcmVzdWx0OiB0aGlzLmlzRXJyb3IocmVzdWx0KSA/IG51bGwgOiByZXN1bHQsXG4gICAgZXJyb3JzOiBzdGF0ZS5lcnJvcnNcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIFJlcG9ydGVyRXJyb3IocGF0aCwgbXNnKSB7XG4gIHRoaXMucGF0aCA9IHBhdGg7XG4gIHRoaXMucmV0aHJvdyhtc2cpO1xufTtcbmluaGVyaXRzKFJlcG9ydGVyRXJyb3IsIEVycm9yKTtcblxuUmVwb3J0ZXJFcnJvci5wcm90b3R5cGUucmV0aHJvdyA9IGZ1bmN0aW9uIHJldGhyb3cobXNnKSB7XG4gIHRoaXMubWVzc2FnZSA9IG1zZyArICcgYXQ6ICcgKyAodGhpcy5wYXRoIHx8ICcoc2hhbGxvdyknKTtcbiAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKVxuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIFJlcG9ydGVyRXJyb3IpO1xuXG4gIGlmICghdGhpcy5zdGFjaykge1xuICAgIHRyeSB7XG4gICAgICAvLyBJRSBvbmx5IGFkZHMgc3RhY2sgd2hlbiB0aHJvd25cbiAgICAgIHRocm93IG5ldyBFcnJvcih0aGlzLm1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMuc3RhY2sgPSBlLnN0YWNrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG4iLCJ2YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJyk7XG5cbmV4cG9ydHMudGFnQ2xhc3MgPSB7XG4gIDA6ICd1bml2ZXJzYWwnLFxuICAxOiAnYXBwbGljYXRpb24nLFxuICAyOiAnY29udGV4dCcsXG4gIDM6ICdwcml2YXRlJ1xufTtcbmV4cG9ydHMudGFnQ2xhc3NCeU5hbWUgPSBjb25zdGFudHMuX3JldmVyc2UoZXhwb3J0cy50YWdDbGFzcyk7XG5cbmV4cG9ydHMudGFnID0ge1xuICAweDAwOiAnZW5kJyxcbiAgMHgwMTogJ2Jvb2wnLFxuICAweDAyOiAnaW50JyxcbiAgMHgwMzogJ2JpdHN0cicsXG4gIDB4MDQ6ICdvY3RzdHInLFxuICAweDA1OiAnbnVsbF8nLFxuICAweDA2OiAnb2JqaWQnLFxuICAweDA3OiAnb2JqRGVzYycsXG4gIDB4MDg6ICdleHRlcm5hbCcsXG4gIDB4MDk6ICdyZWFsJyxcbiAgMHgwYTogJ2VudW0nLFxuICAweDBiOiAnZW1iZWQnLFxuICAweDBjOiAndXRmOHN0cicsXG4gIDB4MGQ6ICdyZWxhdGl2ZU9pZCcsXG4gIDB4MTA6ICdzZXEnLFxuICAweDExOiAnc2V0JyxcbiAgMHgxMjogJ251bXN0cicsXG4gIDB4MTM6ICdwcmludHN0cicsXG4gIDB4MTQ6ICd0NjFzdHInLFxuICAweDE1OiAndmlkZW9zdHInLFxuICAweDE2OiAnaWE1c3RyJyxcbiAgMHgxNzogJ3V0Y3RpbWUnLFxuICAweDE4OiAnZ2VudGltZScsXG4gIDB4MTk6ICdncmFwaHN0cicsXG4gIDB4MWE6ICdpc282NDZzdHInLFxuICAweDFiOiAnZ2Vuc3RyJyxcbiAgMHgxYzogJ3VuaXN0cicsXG4gIDB4MWQ6ICdjaGFyc3RyJyxcbiAgMHgxZTogJ2JtcHN0cidcbn07XG5leHBvcnRzLnRhZ0J5TmFtZSA9IGNvbnN0YW50cy5fcmV2ZXJzZShleHBvcnRzLnRhZyk7XG4iLCJ2YXIgY29uc3RhbnRzID0gZXhwb3J0cztcblxuLy8gSGVscGVyXG5jb25zdGFudHMuX3JldmVyc2UgPSBmdW5jdGlvbiByZXZlcnNlKG1hcCkge1xuICB2YXIgcmVzID0ge307XG5cbiAgT2JqZWN0LmtleXMobWFwKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIC8vIENvbnZlcnQga2V5IHRvIGludGVnZXIgaWYgaXQgaXMgc3RyaW5naWZpZWRcbiAgICBpZiAoKGtleSB8IDApID09IGtleSlcbiAgICAgIGtleSA9IGtleSB8IDA7XG5cbiAgICB2YXIgdmFsdWUgPSBtYXBba2V5XTtcbiAgICByZXNbdmFsdWVdID0ga2V5O1xuICB9KTtcblxuICByZXR1cm4gcmVzO1xufTtcblxuY29uc3RhbnRzLmRlciA9IHJlcXVpcmUoJy4vZGVyJyk7XG4iLCJ2YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG52YXIgYXNuMSA9IHJlcXVpcmUoJy4uLy4uL2FzbjEnKTtcbnZhciBiYXNlID0gYXNuMS5iYXNlO1xudmFyIGJpZ251bSA9IGFzbjEuYmlnbnVtO1xuXG4vLyBJbXBvcnQgREVSIGNvbnN0YW50c1xudmFyIGRlciA9IGFzbjEuY29uc3RhbnRzLmRlcjtcblxuZnVuY3Rpb24gREVSRGVjb2RlcihlbnRpdHkpIHtcbiAgdGhpcy5lbmMgPSAnZGVyJztcbiAgdGhpcy5uYW1lID0gZW50aXR5Lm5hbWU7XG4gIHRoaXMuZW50aXR5ID0gZW50aXR5O1xuXG4gIC8vIENvbnN0cnVjdCBiYXNlIHRyZWVcbiAgdGhpcy50cmVlID0gbmV3IERFUk5vZGUoKTtcbiAgdGhpcy50cmVlLl9pbml0KGVudGl0eS5ib2R5KTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IERFUkRlY29kZXI7XG5cbkRFUkRlY29kZXIucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShkYXRhLCBvcHRpb25zKSB7XG4gIGlmICghKGRhdGEgaW5zdGFuY2VvZiBiYXNlLkRlY29kZXJCdWZmZXIpKVxuICAgIGRhdGEgPSBuZXcgYmFzZS5EZWNvZGVyQnVmZmVyKGRhdGEsIG9wdGlvbnMpO1xuXG4gIHJldHVybiB0aGlzLnRyZWUuX2RlY29kZShkYXRhLCBvcHRpb25zKTtcbn07XG5cbi8vIFRyZWUgbWV0aG9kc1xuXG5mdW5jdGlvbiBERVJOb2RlKHBhcmVudCkge1xuICBiYXNlLk5vZGUuY2FsbCh0aGlzLCAnZGVyJywgcGFyZW50KTtcbn1cbmluaGVyaXRzKERFUk5vZGUsIGJhc2UuTm9kZSk7XG5cbkRFUk5vZGUucHJvdG90eXBlLl9wZWVrVGFnID0gZnVuY3Rpb24gcGVla1RhZyhidWZmZXIsIHRhZywgYW55KSB7XG4gIGlmIChidWZmZXIuaXNFbXB0eSgpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICB2YXIgc3RhdGUgPSBidWZmZXIuc2F2ZSgpO1xuICB2YXIgZGVjb2RlZFRhZyA9IGRlckRlY29kZVRhZyhidWZmZXIsICdGYWlsZWQgdG8gcGVlayB0YWc6IFwiJyArIHRhZyArICdcIicpO1xuICBpZiAoYnVmZmVyLmlzRXJyb3IoZGVjb2RlZFRhZykpXG4gICAgcmV0dXJuIGRlY29kZWRUYWc7XG5cbiAgYnVmZmVyLnJlc3RvcmUoc3RhdGUpO1xuXG4gIHJldHVybiBkZWNvZGVkVGFnLnRhZyA9PT0gdGFnIHx8IGRlY29kZWRUYWcudGFnU3RyID09PSB0YWcgfHxcbiAgICAoZGVjb2RlZFRhZy50YWdTdHIgKyAnb2YnKSA9PT0gdGFnIHx8IGFueTtcbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9kZWNvZGVUYWcgPSBmdW5jdGlvbiBkZWNvZGVUYWcoYnVmZmVyLCB0YWcsIGFueSkge1xuICB2YXIgZGVjb2RlZFRhZyA9IGRlckRlY29kZVRhZyhidWZmZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdGYWlsZWQgdG8gZGVjb2RlIHRhZyBvZiBcIicgKyB0YWcgKyAnXCInKTtcbiAgaWYgKGJ1ZmZlci5pc0Vycm9yKGRlY29kZWRUYWcpKVxuICAgIHJldHVybiBkZWNvZGVkVGFnO1xuXG4gIHZhciBsZW4gPSBkZXJEZWNvZGVMZW4oYnVmZmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRUYWcucHJpbWl0aXZlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICdGYWlsZWQgdG8gZ2V0IGxlbmd0aCBvZiBcIicgKyB0YWcgKyAnXCInKTtcblxuICAvLyBGYWlsdXJlXG4gIGlmIChidWZmZXIuaXNFcnJvcihsZW4pKVxuICAgIHJldHVybiBsZW47XG5cbiAgaWYgKCFhbnkgJiZcbiAgICAgIGRlY29kZWRUYWcudGFnICE9PSB0YWcgJiZcbiAgICAgIGRlY29kZWRUYWcudGFnU3RyICE9PSB0YWcgJiZcbiAgICAgIGRlY29kZWRUYWcudGFnU3RyICsgJ29mJyAhPT0gdGFnKSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5lcnJvcignRmFpbGVkIHRvIG1hdGNoIHRhZzogXCInICsgdGFnICsgJ1wiJyk7XG4gIH1cblxuICBpZiAoZGVjb2RlZFRhZy5wcmltaXRpdmUgfHwgbGVuICE9PSBudWxsKVxuICAgIHJldHVybiBidWZmZXIuc2tpcChsZW4sICdGYWlsZWQgdG8gbWF0Y2ggYm9keSBvZjogXCInICsgdGFnICsgJ1wiJyk7XG5cbiAgLy8gSW5kZWZpbml0ZSBsZW5ndGguLi4gZmluZCBFTkQgdGFnXG4gIHZhciBzdGF0ZSA9IGJ1ZmZlci5zYXZlKCk7XG4gIHZhciByZXMgPSB0aGlzLl9za2lwVW50aWxFbmQoXG4gICAgICBidWZmZXIsXG4gICAgICAnRmFpbGVkIHRvIHNraXAgaW5kZWZpbml0ZSBsZW5ndGggYm9keTogXCInICsgdGhpcy50YWcgKyAnXCInKTtcbiAgaWYgKGJ1ZmZlci5pc0Vycm9yKHJlcykpXG4gICAgcmV0dXJuIHJlcztcblxuICBsZW4gPSBidWZmZXIub2Zmc2V0IC0gc3RhdGUub2Zmc2V0O1xuICBidWZmZXIucmVzdG9yZShzdGF0ZSk7XG4gIHJldHVybiBidWZmZXIuc2tpcChsZW4sICdGYWlsZWQgdG8gbWF0Y2ggYm9keSBvZjogXCInICsgdGFnICsgJ1wiJyk7XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fc2tpcFVudGlsRW5kID0gZnVuY3Rpb24gc2tpcFVudGlsRW5kKGJ1ZmZlciwgZmFpbCkge1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHZhciB0YWcgPSBkZXJEZWNvZGVUYWcoYnVmZmVyLCBmYWlsKTtcbiAgICBpZiAoYnVmZmVyLmlzRXJyb3IodGFnKSlcbiAgICAgIHJldHVybiB0YWc7XG4gICAgdmFyIGxlbiA9IGRlckRlY29kZUxlbihidWZmZXIsIHRhZy5wcmltaXRpdmUsIGZhaWwpO1xuICAgIGlmIChidWZmZXIuaXNFcnJvcihsZW4pKVxuICAgICAgcmV0dXJuIGxlbjtcblxuICAgIHZhciByZXM7XG4gICAgaWYgKHRhZy5wcmltaXRpdmUgfHwgbGVuICE9PSBudWxsKVxuICAgICAgcmVzID0gYnVmZmVyLnNraXAobGVuKVxuICAgIGVsc2VcbiAgICAgIHJlcyA9IHRoaXMuX3NraXBVbnRpbEVuZChidWZmZXIsIGZhaWwpO1xuXG4gICAgLy8gRmFpbHVyZVxuICAgIGlmIChidWZmZXIuaXNFcnJvcihyZXMpKVxuICAgICAgcmV0dXJuIHJlcztcblxuICAgIGlmICh0YWcudGFnU3RyID09PSAnZW5kJylcbiAgICAgIGJyZWFrO1xuICB9XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fZGVjb2RlTGlzdCA9IGZ1bmN0aW9uIGRlY29kZUxpc3QoYnVmZmVyLCB0YWcsIGRlY29kZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucykge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHdoaWxlICghYnVmZmVyLmlzRW1wdHkoKSkge1xuICAgIHZhciBwb3NzaWJsZUVuZCA9IHRoaXMuX3BlZWtUYWcoYnVmZmVyLCAnZW5kJyk7XG4gICAgaWYgKGJ1ZmZlci5pc0Vycm9yKHBvc3NpYmxlRW5kKSlcbiAgICAgIHJldHVybiBwb3NzaWJsZUVuZDtcblxuICAgIHZhciByZXMgPSBkZWNvZGVyLmRlY29kZShidWZmZXIsICdkZXInLCBvcHRpb25zKTtcbiAgICBpZiAoYnVmZmVyLmlzRXJyb3IocmVzKSAmJiBwb3NzaWJsZUVuZClcbiAgICAgIGJyZWFrO1xuICAgIHJlc3VsdC5wdXNoKHJlcyk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9kZWNvZGVTdHIgPSBmdW5jdGlvbiBkZWNvZGVTdHIoYnVmZmVyLCB0YWcpIHtcbiAgaWYgKHRhZyA9PT0gJ2JpdHN0cicpIHtcbiAgICB2YXIgdW51c2VkID0gYnVmZmVyLnJlYWRVSW50OCgpO1xuICAgIGlmIChidWZmZXIuaXNFcnJvcih1bnVzZWQpKVxuICAgICAgcmV0dXJuIHVudXNlZDtcbiAgICByZXR1cm4geyB1bnVzZWQ6IHVudXNlZCwgZGF0YTogYnVmZmVyLnJhdygpIH07XG4gIH0gZWxzZSBpZiAodGFnID09PSAnYm1wc3RyJykge1xuICAgIHZhciByYXcgPSBidWZmZXIucmF3KCk7XG4gICAgaWYgKHJhdy5sZW5ndGggJSAyID09PSAxKVxuICAgICAgcmV0dXJuIGJ1ZmZlci5lcnJvcignRGVjb2Rpbmcgb2Ygc3RyaW5nIHR5cGU6IGJtcHN0ciBsZW5ndGggbWlzbWF0Y2gnKTtcblxuICAgIHZhciBzdHIgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhdy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHJhdy5yZWFkVUludDE2QkUoaSAqIDIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdudW1zdHInKSB7XG4gICAgdmFyIG51bXN0ciA9IGJ1ZmZlci5yYXcoKS50b1N0cmluZygnYXNjaWknKTtcbiAgICBpZiAoIXRoaXMuX2lzTnVtc3RyKG51bXN0cikpIHtcbiAgICAgIHJldHVybiBidWZmZXIuZXJyb3IoJ0RlY29kaW5nIG9mIHN0cmluZyB0eXBlOiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ251bXN0ciB1bnN1cHBvcnRlZCBjaGFyYWN0ZXJzJyk7XG4gICAgfVxuICAgIHJldHVybiBudW1zdHI7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnb2N0c3RyJykge1xuICAgIHJldHVybiBidWZmZXIucmF3KCk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnb2JqRGVzYycpIHtcbiAgICByZXR1cm4gYnVmZmVyLnJhdygpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ3ByaW50c3RyJykge1xuICAgIHZhciBwcmludHN0ciA9IGJ1ZmZlci5yYXcoKS50b1N0cmluZygnYXNjaWknKTtcbiAgICBpZiAoIXRoaXMuX2lzUHJpbnRzdHIocHJpbnRzdHIpKSB7XG4gICAgICByZXR1cm4gYnVmZmVyLmVycm9yKCdEZWNvZGluZyBvZiBzdHJpbmcgdHlwZTogJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdwcmludHN0ciB1bnN1cHBvcnRlZCBjaGFyYWN0ZXJzJyk7XG4gICAgfVxuICAgIHJldHVybiBwcmludHN0cjtcbiAgfSBlbHNlIGlmICgvc3RyJC8udGVzdCh0YWcpKSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5yYXcoKS50b1N0cmluZygpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBidWZmZXIuZXJyb3IoJ0RlY29kaW5nIG9mIHN0cmluZyB0eXBlOiAnICsgdGFnICsgJyB1bnN1cHBvcnRlZCcpO1xuICB9XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fZGVjb2RlT2JqaWQgPSBmdW5jdGlvbiBkZWNvZGVPYmppZChidWZmZXIsIHZhbHVlcywgcmVsYXRpdmUpIHtcbiAgdmFyIHJlc3VsdDtcbiAgdmFyIGlkZW50aWZpZXJzID0gW107XG4gIHZhciBpZGVudCA9IDA7XG4gIHdoaWxlICghYnVmZmVyLmlzRW1wdHkoKSkge1xuICAgIHZhciBzdWJpZGVudCA9IGJ1ZmZlci5yZWFkVUludDgoKTtcbiAgICBpZGVudCA8PD0gNztcbiAgICBpZGVudCB8PSBzdWJpZGVudCAmIDB4N2Y7XG4gICAgaWYgKChzdWJpZGVudCAmIDB4ODApID09PSAwKSB7XG4gICAgICBpZGVudGlmaWVycy5wdXNoKGlkZW50KTtcbiAgICAgIGlkZW50ID0gMDtcbiAgICB9XG4gIH1cbiAgaWYgKHN1YmlkZW50ICYgMHg4MClcbiAgICBpZGVudGlmaWVycy5wdXNoKGlkZW50KTtcblxuICB2YXIgZmlyc3QgPSAoaWRlbnRpZmllcnNbMF0gLyA0MCkgfCAwO1xuICB2YXIgc2Vjb25kID0gaWRlbnRpZmllcnNbMF0gJSA0MDtcblxuICBpZiAocmVsYXRpdmUpXG4gICAgcmVzdWx0ID0gaWRlbnRpZmllcnM7XG4gIGVsc2VcbiAgICByZXN1bHQgPSBbZmlyc3QsIHNlY29uZF0uY29uY2F0KGlkZW50aWZpZXJzLnNsaWNlKDEpKTtcblxuICBpZiAodmFsdWVzKSB7XG4gICAgdmFyIHRtcCA9IHZhbHVlc1tyZXN1bHQuam9pbignICcpXTtcbiAgICBpZiAodG1wID09PSB1bmRlZmluZWQpXG4gICAgICB0bXAgPSB2YWx1ZXNbcmVzdWx0LmpvaW4oJy4nKV07XG4gICAgaWYgKHRtcCAhPT0gdW5kZWZpbmVkKVxuICAgICAgcmVzdWx0ID0gdG1wO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9kZWNvZGVUaW1lID0gZnVuY3Rpb24gZGVjb2RlVGltZShidWZmZXIsIHRhZykge1xuICB2YXIgc3RyID0gYnVmZmVyLnJhdygpLnRvU3RyaW5nKCk7XG4gIGlmICh0YWcgPT09ICdnZW50aW1lJykge1xuICAgIHZhciB5ZWFyID0gc3RyLnNsaWNlKDAsIDQpIHwgMDtcbiAgICB2YXIgbW9uID0gc3RyLnNsaWNlKDQsIDYpIHwgMDtcbiAgICB2YXIgZGF5ID0gc3RyLnNsaWNlKDYsIDgpIHwgMDtcbiAgICB2YXIgaG91ciA9IHN0ci5zbGljZSg4LCAxMCkgfCAwO1xuICAgIHZhciBtaW4gPSBzdHIuc2xpY2UoMTAsIDEyKSB8IDA7XG4gICAgdmFyIHNlYyA9IHN0ci5zbGljZSgxMiwgMTQpIHwgMDtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICd1dGN0aW1lJykge1xuICAgIHZhciB5ZWFyID0gc3RyLnNsaWNlKDAsIDIpIHwgMDtcbiAgICB2YXIgbW9uID0gc3RyLnNsaWNlKDIsIDQpIHwgMDtcbiAgICB2YXIgZGF5ID0gc3RyLnNsaWNlKDQsIDYpIHwgMDtcbiAgICB2YXIgaG91ciA9IHN0ci5zbGljZSg2LCA4KSB8IDA7XG4gICAgdmFyIG1pbiA9IHN0ci5zbGljZSg4LCAxMCkgfCAwO1xuICAgIHZhciBzZWMgPSBzdHIuc2xpY2UoMTAsIDEyKSB8IDA7XG4gICAgaWYgKHllYXIgPCA3MClcbiAgICAgIHllYXIgPSAyMDAwICsgeWVhcjtcbiAgICBlbHNlXG4gICAgICB5ZWFyID0gMTkwMCArIHllYXI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5lcnJvcignRGVjb2RpbmcgJyArIHRhZyArICcgdGltZSBpcyBub3Qgc3VwcG9ydGVkIHlldCcpO1xuICB9XG5cbiAgcmV0dXJuIERhdGUuVVRDKHllYXIsIG1vbiAtIDEsIGRheSwgaG91ciwgbWluLCBzZWMsIDApO1xufTtcblxuREVSTm9kZS5wcm90b3R5cGUuX2RlY29kZU51bGwgPSBmdW5jdGlvbiBkZWNvZGVOdWxsKGJ1ZmZlcikge1xuICByZXR1cm4gbnVsbDtcbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9kZWNvZGVCb29sID0gZnVuY3Rpb24gZGVjb2RlQm9vbChidWZmZXIpIHtcbiAgdmFyIHJlcyA9IGJ1ZmZlci5yZWFkVUludDgoKTtcbiAgaWYgKGJ1ZmZlci5pc0Vycm9yKHJlcykpXG4gICAgcmV0dXJuIHJlcztcbiAgZWxzZVxuICAgIHJldHVybiByZXMgIT09IDA7XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fZGVjb2RlSW50ID0gZnVuY3Rpb24gZGVjb2RlSW50KGJ1ZmZlciwgdmFsdWVzKSB7XG4gIC8vIEJpZ2ludCwgcmV0dXJuIGFzIGl0IGlzIChhc3N1bWUgYmlnIGVuZGlhbilcbiAgdmFyIHJhdyA9IGJ1ZmZlci5yYXcoKTtcbiAgdmFyIHJlcyA9IG5ldyBiaWdudW0ocmF3KTtcblxuICBpZiAodmFsdWVzKVxuICAgIHJlcyA9IHZhbHVlc1tyZXMudG9TdHJpbmcoMTApXSB8fCByZXM7XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl91c2UgPSBmdW5jdGlvbiB1c2UoZW50aXR5LCBvYmopIHtcbiAgaWYgKHR5cGVvZiBlbnRpdHkgPT09ICdmdW5jdGlvbicpXG4gICAgZW50aXR5ID0gZW50aXR5KG9iaik7XG4gIHJldHVybiBlbnRpdHkuX2dldERlY29kZXIoJ2RlcicpLnRyZWU7XG59O1xuXG4vLyBVdGlsaXR5IG1ldGhvZHNcblxuZnVuY3Rpb24gZGVyRGVjb2RlVGFnKGJ1ZiwgZmFpbCkge1xuICB2YXIgdGFnID0gYnVmLnJlYWRVSW50OChmYWlsKTtcbiAgaWYgKGJ1Zi5pc0Vycm9yKHRhZykpXG4gICAgcmV0dXJuIHRhZztcblxuICB2YXIgY2xzID0gZGVyLnRhZ0NsYXNzW3RhZyA+PiA2XTtcbiAgdmFyIHByaW1pdGl2ZSA9ICh0YWcgJiAweDIwKSA9PT0gMDtcblxuICAvLyBNdWx0aS1vY3RldCB0YWcgLSBsb2FkXG4gIGlmICgodGFnICYgMHgxZikgPT09IDB4MWYpIHtcbiAgICB2YXIgb2N0ID0gdGFnO1xuICAgIHRhZyA9IDA7XG4gICAgd2hpbGUgKChvY3QgJiAweDgwKSA9PT0gMHg4MCkge1xuICAgICAgb2N0ID0gYnVmLnJlYWRVSW50OChmYWlsKTtcbiAgICAgIGlmIChidWYuaXNFcnJvcihvY3QpKVxuICAgICAgICByZXR1cm4gb2N0O1xuXG4gICAgICB0YWcgPDw9IDc7XG4gICAgICB0YWcgfD0gb2N0ICYgMHg3ZjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGFnICY9IDB4MWY7XG4gIH1cbiAgdmFyIHRhZ1N0ciA9IGRlci50YWdbdGFnXTtcblxuICByZXR1cm4ge1xuICAgIGNsczogY2xzLFxuICAgIHByaW1pdGl2ZTogcHJpbWl0aXZlLFxuICAgIHRhZzogdGFnLFxuICAgIHRhZ1N0cjogdGFnU3RyXG4gIH07XG59XG5cbmZ1bmN0aW9uIGRlckRlY29kZUxlbihidWYsIHByaW1pdGl2ZSwgZmFpbCkge1xuICB2YXIgbGVuID0gYnVmLnJlYWRVSW50OChmYWlsKTtcbiAgaWYgKGJ1Zi5pc0Vycm9yKGxlbikpXG4gICAgcmV0dXJuIGxlbjtcblxuICAvLyBJbmRlZmluaXRlIGZvcm1cbiAgaWYgKCFwcmltaXRpdmUgJiYgbGVuID09PSAweDgwKVxuICAgIHJldHVybiBudWxsO1xuXG4gIC8vIERlZmluaXRlIGZvcm1cbiAgaWYgKChsZW4gJiAweDgwKSA9PT0gMCkge1xuICAgIC8vIFNob3J0IGZvcm1cbiAgICByZXR1cm4gbGVuO1xuICB9XG5cbiAgLy8gTG9uZyBmb3JtXG4gIHZhciBudW0gPSBsZW4gJiAweDdmO1xuICBpZiAobnVtID4gNClcbiAgICByZXR1cm4gYnVmLmVycm9yKCdsZW5ndGggb2N0ZWN0IGlzIHRvbyBsb25nJyk7XG5cbiAgbGVuID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW07IGkrKykge1xuICAgIGxlbiA8PD0gODtcbiAgICB2YXIgaiA9IGJ1Zi5yZWFkVUludDgoZmFpbCk7XG4gICAgaWYgKGJ1Zi5pc0Vycm9yKGopKVxuICAgICAgcmV0dXJuIGo7XG4gICAgbGVuIHw9IGo7XG4gIH1cblxuICByZXR1cm4gbGVuO1xufVxuIiwidmFyIGRlY29kZXJzID0gZXhwb3J0cztcblxuZGVjb2RlcnMuZGVyID0gcmVxdWlyZSgnLi9kZXInKTtcbmRlY29kZXJzLnBlbSA9IHJlcXVpcmUoJy4vcGVtJyk7XG4iLCJ2YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcblxudmFyIERFUkRlY29kZXIgPSByZXF1aXJlKCcuL2RlcicpO1xuXG5mdW5jdGlvbiBQRU1EZWNvZGVyKGVudGl0eSkge1xuICBERVJEZWNvZGVyLmNhbGwodGhpcywgZW50aXR5KTtcbiAgdGhpcy5lbmMgPSAncGVtJztcbn07XG5pbmhlcml0cyhQRU1EZWNvZGVyLCBERVJEZWNvZGVyKTtcbm1vZHVsZS5leHBvcnRzID0gUEVNRGVjb2RlcjtcblxuUEVNRGVjb2Rlci5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKGRhdGEsIG9wdGlvbnMpIHtcbiAgdmFyIGxpbmVzID0gZGF0YS50b1N0cmluZygpLnNwbGl0KC9bXFxyXFxuXSsvZyk7XG5cbiAgdmFyIGxhYmVsID0gb3B0aW9ucy5sYWJlbC50b1VwcGVyQ2FzZSgpO1xuXG4gIHZhciByZSA9IC9eLS0tLS0oQkVHSU58RU5EKSAoW14tXSspLS0tLS0kLztcbiAgdmFyIHN0YXJ0ID0gLTE7XG4gIHZhciBlbmQgPSAtMTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBtYXRjaCA9IGxpbmVzW2ldLm1hdGNoKHJlKTtcbiAgICBpZiAobWF0Y2ggPT09IG51bGwpXG4gICAgICBjb250aW51ZTtcblxuICAgIGlmIChtYXRjaFsyXSAhPT0gbGFiZWwpXG4gICAgICBjb250aW51ZTtcblxuICAgIGlmIChzdGFydCA9PT0gLTEpIHtcbiAgICAgIGlmIChtYXRjaFsxXSAhPT0gJ0JFR0lOJylcbiAgICAgICAgYnJlYWs7XG4gICAgICBzdGFydCA9IGk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChtYXRjaFsxXSAhPT0gJ0VORCcpXG4gICAgICAgIGJyZWFrO1xuICAgICAgZW5kID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoc3RhcnQgPT09IC0xIHx8IGVuZCA9PT0gLTEpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdQRU0gc2VjdGlvbiBub3QgZm91bmQgZm9yOiAnICsgbGFiZWwpO1xuXG4gIHZhciBiYXNlNjQgPSBsaW5lcy5zbGljZShzdGFydCArIDEsIGVuZCkuam9pbignJyk7XG4gIC8vIFJlbW92ZSBleGNlc3NpdmUgc3ltYm9sc1xuICBiYXNlNjQucmVwbGFjZSgvW15hLXowLTlcXCtcXC89XSsvZ2ksICcnKTtcblxuICB2YXIgaW5wdXQgPSBuZXcgQnVmZmVyKGJhc2U2NCwgJ2Jhc2U2NCcpO1xuICByZXR1cm4gREVSRGVjb2Rlci5wcm90b3R5cGUuZGVjb2RlLmNhbGwodGhpcywgaW5wdXQsIG9wdGlvbnMpO1xufTtcbiIsInZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG52YXIgYXNuMSA9IHJlcXVpcmUoJy4uLy4uL2FzbjEnKTtcbnZhciBiYXNlID0gYXNuMS5iYXNlO1xuXG4vLyBJbXBvcnQgREVSIGNvbnN0YW50c1xudmFyIGRlciA9IGFzbjEuY29uc3RhbnRzLmRlcjtcblxuZnVuY3Rpb24gREVSRW5jb2RlcihlbnRpdHkpIHtcbiAgdGhpcy5lbmMgPSAnZGVyJztcbiAgdGhpcy5uYW1lID0gZW50aXR5Lm5hbWU7XG4gIHRoaXMuZW50aXR5ID0gZW50aXR5O1xuXG4gIC8vIENvbnN0cnVjdCBiYXNlIHRyZWVcbiAgdGhpcy50cmVlID0gbmV3IERFUk5vZGUoKTtcbiAgdGhpcy50cmVlLl9pbml0KGVudGl0eS5ib2R5KTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IERFUkVuY29kZXI7XG5cbkRFUkVuY29kZXIucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShkYXRhLCByZXBvcnRlcikge1xuICByZXR1cm4gdGhpcy50cmVlLl9lbmNvZGUoZGF0YSwgcmVwb3J0ZXIpLmpvaW4oKTtcbn07XG5cbi8vIFRyZWUgbWV0aG9kc1xuXG5mdW5jdGlvbiBERVJOb2RlKHBhcmVudCkge1xuICBiYXNlLk5vZGUuY2FsbCh0aGlzLCAnZGVyJywgcGFyZW50KTtcbn1cbmluaGVyaXRzKERFUk5vZGUsIGJhc2UuTm9kZSk7XG5cbkRFUk5vZGUucHJvdG90eXBlLl9lbmNvZGVDb21wb3NpdGUgPSBmdW5jdGlvbiBlbmNvZGVDb21wb3NpdGUodGFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmltaXRpdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNscyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudCkge1xuICB2YXIgZW5jb2RlZFRhZyA9IGVuY29kZVRhZyh0YWcsIHByaW1pdGl2ZSwgY2xzLCB0aGlzLnJlcG9ydGVyKTtcblxuICAvLyBTaG9ydCBmb3JtXG4gIGlmIChjb250ZW50Lmxlbmd0aCA8IDB4ODApIHtcbiAgICB2YXIgaGVhZGVyID0gbmV3IEJ1ZmZlcigyKTtcbiAgICBoZWFkZXJbMF0gPSBlbmNvZGVkVGFnO1xuICAgIGhlYWRlclsxXSA9IGNvbnRlbnQubGVuZ3RoO1xuICAgIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKFsgaGVhZGVyLCBjb250ZW50IF0pO1xuICB9XG5cbiAgLy8gTG9uZyBmb3JtXG4gIC8vIENvdW50IG9jdGV0cyByZXF1aXJlZCB0byBzdG9yZSBsZW5ndGhcbiAgdmFyIGxlbk9jdGV0cyA9IDE7XG4gIGZvciAodmFyIGkgPSBjb250ZW50Lmxlbmd0aDsgaSA+PSAweDEwMDsgaSA+Pj0gOClcbiAgICBsZW5PY3RldHMrKztcblxuICB2YXIgaGVhZGVyID0gbmV3IEJ1ZmZlcigxICsgMSArIGxlbk9jdGV0cyk7XG4gIGhlYWRlclswXSA9IGVuY29kZWRUYWc7XG4gIGhlYWRlclsxXSA9IDB4ODAgfCBsZW5PY3RldHM7XG5cbiAgZm9yICh2YXIgaSA9IDEgKyBsZW5PY3RldHMsIGogPSBjb250ZW50Lmxlbmd0aDsgaiA+IDA7IGktLSwgaiA+Pj0gOClcbiAgICBoZWFkZXJbaV0gPSBqICYgMHhmZjtcblxuICByZXR1cm4gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihbIGhlYWRlciwgY29udGVudCBdKTtcbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9lbmNvZGVTdHIgPSBmdW5jdGlvbiBlbmNvZGVTdHIoc3RyLCB0YWcpIHtcbiAgaWYgKHRhZyA9PT0gJ2JpdHN0cicpIHtcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihbIHN0ci51bnVzZWQgfCAwLCBzdHIuZGF0YSBdKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdibXBzdHInKSB7XG4gICAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoc3RyLmxlbmd0aCAqIDIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBidWYud3JpdGVVSW50MTZCRShzdHIuY2hhckNvZGVBdChpKSwgaSAqIDIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihidWYpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ251bXN0cicpIHtcbiAgICBpZiAoIXRoaXMuX2lzTnVtc3RyKHN0cikpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlcG9ydGVyLmVycm9yKCdFbmNvZGluZyBvZiBzdHJpbmcgdHlwZTogbnVtc3RyIHN1cHBvcnRzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29ubHkgZGlnaXRzIGFuZCBzcGFjZScpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihzdHIpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ3ByaW50c3RyJykge1xuICAgIGlmICghdGhpcy5faXNQcmludHN0cihzdHIpKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXBvcnRlci5lcnJvcignRW5jb2Rpbmcgb2Ygc3RyaW5nIHR5cGU6IHByaW50c3RyIHN1cHBvcnRzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29ubHkgbGF0aW4gdXBwZXIgYW5kIGxvd2VyIGNhc2UgbGV0dGVycywgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGlnaXRzLCBzcGFjZSwgYXBvc3Ryb3BoZSwgbGVmdCBhbmQgcmlndGggJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncGFyZW50aGVzaXMsIHBsdXMgc2lnbiwgY29tbWEsIGh5cGhlbiwgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZG90LCBzbGFzaCwgY29sb24sIGVxdWFsIHNpZ24sICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3F1ZXN0aW9uIG1hcmsnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIoc3RyKTtcbiAgfSBlbHNlIGlmICgvc3RyJC8udGVzdCh0YWcpKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIoc3RyKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdvYmpEZXNjJykge1xuICAgIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKHN0cik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMucmVwb3J0ZXIuZXJyb3IoJ0VuY29kaW5nIG9mIHN0cmluZyB0eXBlOiAnICsgdGFnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIHVuc3VwcG9ydGVkJyk7XG4gIH1cbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9lbmNvZGVPYmppZCA9IGZ1bmN0aW9uIGVuY29kZU9iamlkKGlkLCB2YWx1ZXMsIHJlbGF0aXZlKSB7XG4gIGlmICh0eXBlb2YgaWQgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKCF2YWx1ZXMpXG4gICAgICByZXR1cm4gdGhpcy5yZXBvcnRlci5lcnJvcignc3RyaW5nIG9iamlkIGdpdmVuLCBidXQgbm8gdmFsdWVzIG1hcCBmb3VuZCcpO1xuICAgIGlmICghdmFsdWVzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgIHJldHVybiB0aGlzLnJlcG9ydGVyLmVycm9yKCdvYmppZCBub3QgZm91bmQgaW4gdmFsdWVzIG1hcCcpO1xuICAgIGlkID0gdmFsdWVzW2lkXS5zcGxpdCgvW1xcc1xcLl0rL2cpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWQubGVuZ3RoOyBpKyspXG4gICAgICBpZFtpXSB8PSAwO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaWQpKSB7XG4gICAgaWQgPSBpZC5zbGljZSgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWQubGVuZ3RoOyBpKyspXG4gICAgICBpZFtpXSB8PSAwO1xuICB9XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KGlkKSkge1xuICAgIHJldHVybiB0aGlzLnJlcG9ydGVyLmVycm9yKCdvYmppZCgpIHNob3VsZCBiZSBlaXRoZXIgYXJyYXkgb3Igc3RyaW5nLCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZ290OiAnICsgSlNPTi5zdHJpbmdpZnkoaWQpKTtcbiAgfVxuXG4gIGlmICghcmVsYXRpdmUpIHtcbiAgICBpZiAoaWRbMV0gPj0gNDApXG4gICAgICByZXR1cm4gdGhpcy5yZXBvcnRlci5lcnJvcignU2Vjb25kIG9iamlkIGlkZW50aWZpZXIgT09CJyk7XG4gICAgaWQuc3BsaWNlKDAsIDIsIGlkWzBdICogNDAgKyBpZFsxXSk7XG4gIH1cblxuICAvLyBDb3VudCBudW1iZXIgb2Ygb2N0ZXRzXG4gIHZhciBzaXplID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpZGVudCA9IGlkW2ldO1xuICAgIGZvciAoc2l6ZSsrOyBpZGVudCA+PSAweDgwOyBpZGVudCA+Pj0gNylcbiAgICAgIHNpemUrKztcbiAgfVxuXG4gIHZhciBvYmppZCA9IG5ldyBCdWZmZXIoc2l6ZSk7XG4gIHZhciBvZmZzZXQgPSBvYmppZC5sZW5ndGggLSAxO1xuICBmb3IgKHZhciBpID0gaWQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgaWRlbnQgPSBpZFtpXTtcbiAgICBvYmppZFtvZmZzZXQtLV0gPSBpZGVudCAmIDB4N2Y7XG4gICAgd2hpbGUgKChpZGVudCA+Pj0gNykgPiAwKVxuICAgICAgb2JqaWRbb2Zmc2V0LS1dID0gMHg4MCB8IChpZGVudCAmIDB4N2YpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIob2JqaWQpO1xufTtcblxuZnVuY3Rpb24gdHdvKG51bSkge1xuICBpZiAobnVtIDwgMTApXG4gICAgcmV0dXJuICcwJyArIG51bTtcbiAgZWxzZVxuICAgIHJldHVybiBudW07XG59XG5cbkRFUk5vZGUucHJvdG90eXBlLl9lbmNvZGVUaW1lID0gZnVuY3Rpb24gZW5jb2RlVGltZSh0aW1lLCB0YWcpIHtcbiAgdmFyIHN0cjtcbiAgdmFyIGRhdGUgPSBuZXcgRGF0ZSh0aW1lKTtcblxuICBpZiAodGFnID09PSAnZ2VudGltZScpIHtcbiAgICBzdHIgPSBbXG4gICAgICB0d28oZGF0ZS5nZXRGdWxsWWVhcigpKSxcbiAgICAgIHR3byhkYXRlLmdldFVUQ01vbnRoKCkgKyAxKSxcbiAgICAgIHR3byhkYXRlLmdldFVUQ0RhdGUoKSksXG4gICAgICB0d28oZGF0ZS5nZXRVVENIb3VycygpKSxcbiAgICAgIHR3byhkYXRlLmdldFVUQ01pbnV0ZXMoKSksXG4gICAgICB0d28oZGF0ZS5nZXRVVENTZWNvbmRzKCkpLFxuICAgICAgJ1onXG4gICAgXS5qb2luKCcnKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICd1dGN0aW1lJykge1xuICAgIHN0ciA9IFtcbiAgICAgIHR3byhkYXRlLmdldEZ1bGxZZWFyKCkgJSAxMDApLFxuICAgICAgdHdvKGRhdGUuZ2V0VVRDTW9udGgoKSArIDEpLFxuICAgICAgdHdvKGRhdGUuZ2V0VVRDRGF0ZSgpKSxcbiAgICAgIHR3byhkYXRlLmdldFVUQ0hvdXJzKCkpLFxuICAgICAgdHdvKGRhdGUuZ2V0VVRDTWludXRlcygpKSxcbiAgICAgIHR3byhkYXRlLmdldFVUQ1NlY29uZHMoKSksXG4gICAgICAnWidcbiAgICBdLmpvaW4oJycpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucmVwb3J0ZXIuZXJyb3IoJ0VuY29kaW5nICcgKyB0YWcgKyAnIHRpbWUgaXMgbm90IHN1cHBvcnRlZCB5ZXQnKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9lbmNvZGVTdHIoc3RyLCAnb2N0c3RyJyk7XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fZW5jb2RlTnVsbCA9IGZ1bmN0aW9uIGVuY29kZU51bGwoKSB7XG4gIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKCcnKTtcbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9lbmNvZGVJbnQgPSBmdW5jdGlvbiBlbmNvZGVJbnQobnVtLCB2YWx1ZXMpIHtcbiAgaWYgKHR5cGVvZiBudW0gPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKCF2YWx1ZXMpXG4gICAgICByZXR1cm4gdGhpcy5yZXBvcnRlci5lcnJvcignU3RyaW5nIGludCBvciBlbnVtIGdpdmVuLCBidXQgbm8gdmFsdWVzIG1hcCcpO1xuICAgIGlmICghdmFsdWVzLmhhc093blByb3BlcnR5KG51bSkpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlcG9ydGVyLmVycm9yKCdWYWx1ZXMgbWFwIGRvZXNuXFwndCBjb250YWluOiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KG51bSkpO1xuICAgIH1cbiAgICBudW0gPSB2YWx1ZXNbbnVtXTtcbiAgfVxuXG4gIC8vIEJpZ251bSwgYXNzdW1lIGJpZyBlbmRpYW5cbiAgaWYgKHR5cGVvZiBudW0gIT09ICdudW1iZXInICYmICFCdWZmZXIuaXNCdWZmZXIobnVtKSkge1xuICAgIHZhciBudW1BcnJheSA9IG51bS50b0FycmF5KCk7XG4gICAgaWYgKCFudW0uc2lnbiAmJiBudW1BcnJheVswXSAmIDB4ODApIHtcbiAgICAgIG51bUFycmF5LnVuc2hpZnQoMCk7XG4gICAgfVxuICAgIG51bSA9IG5ldyBCdWZmZXIobnVtQXJyYXkpO1xuICB9XG5cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihudW0pKSB7XG4gICAgdmFyIHNpemUgPSBudW0ubGVuZ3RoO1xuICAgIGlmIChudW0ubGVuZ3RoID09PSAwKVxuICAgICAgc2l6ZSsrO1xuXG4gICAgdmFyIG91dCA9IG5ldyBCdWZmZXIoc2l6ZSk7XG4gICAgbnVtLmNvcHkob3V0KTtcbiAgICBpZiAobnVtLmxlbmd0aCA9PT0gMClcbiAgICAgIG91dFswXSA9IDBcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihvdXQpO1xuICB9XG5cbiAgaWYgKG51bSA8IDB4ODApXG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIobnVtKTtcblxuICBpZiAobnVtIDwgMHgxMDApXG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIoWzAsIG51bV0pO1xuXG4gIHZhciBzaXplID0gMTtcbiAgZm9yICh2YXIgaSA9IG51bTsgaSA+PSAweDEwMDsgaSA+Pj0gOClcbiAgICBzaXplKys7XG5cbiAgdmFyIG91dCA9IG5ldyBBcnJheShzaXplKTtcbiAgZm9yICh2YXIgaSA9IG91dC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIG91dFtpXSA9IG51bSAmIDB4ZmY7XG4gICAgbnVtID4+PSA4O1xuICB9XG4gIGlmKG91dFswXSAmIDB4ODApIHtcbiAgICBvdXQudW5zaGlmdCgwKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKG5ldyBCdWZmZXIob3V0KSk7XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fZW5jb2RlQm9vbCA9IGZ1bmN0aW9uIGVuY29kZUJvb2wodmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIodmFsdWUgPyAweGZmIDogMCk7XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fdXNlID0gZnVuY3Rpb24gdXNlKGVudGl0eSwgb2JqKSB7XG4gIGlmICh0eXBlb2YgZW50aXR5ID09PSAnZnVuY3Rpb24nKVxuICAgIGVudGl0eSA9IGVudGl0eShvYmopO1xuICByZXR1cm4gZW50aXR5Ll9nZXRFbmNvZGVyKCdkZXInKS50cmVlO1xufTtcblxuREVSTm9kZS5wcm90b3R5cGUuX3NraXBEZWZhdWx0ID0gZnVuY3Rpb24gc2tpcERlZmF1bHQoZGF0YUJ1ZmZlciwgcmVwb3J0ZXIsIHBhcmVudCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG4gIHZhciBpO1xuICBpZiAoc3RhdGVbJ2RlZmF1bHQnXSA9PT0gbnVsbClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGRhdGEgPSBkYXRhQnVmZmVyLmpvaW4oKTtcbiAgaWYgKHN0YXRlLmRlZmF1bHRCdWZmZXIgPT09IHVuZGVmaW5lZClcbiAgICBzdGF0ZS5kZWZhdWx0QnVmZmVyID0gdGhpcy5fZW5jb2RlVmFsdWUoc3RhdGVbJ2RlZmF1bHQnXSwgcmVwb3J0ZXIsIHBhcmVudCkuam9pbigpO1xuXG4gIGlmIChkYXRhLmxlbmd0aCAhPT0gc3RhdGUuZGVmYXVsdEJ1ZmZlci5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGZvciAoaT0wOyBpIDwgZGF0YS5sZW5ndGg7IGkrKylcbiAgICBpZiAoZGF0YVtpXSAhPT0gc3RhdGUuZGVmYXVsdEJ1ZmZlcltpXSlcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIFV0aWxpdHkgbWV0aG9kc1xuXG5mdW5jdGlvbiBlbmNvZGVUYWcodGFnLCBwcmltaXRpdmUsIGNscywgcmVwb3J0ZXIpIHtcbiAgdmFyIHJlcztcblxuICBpZiAodGFnID09PSAnc2Vxb2YnKVxuICAgIHRhZyA9ICdzZXEnO1xuICBlbHNlIGlmICh0YWcgPT09ICdzZXRvZicpXG4gICAgdGFnID0gJ3NldCc7XG5cbiAgaWYgKGRlci50YWdCeU5hbWUuaGFzT3duUHJvcGVydHkodGFnKSlcbiAgICByZXMgPSBkZXIudGFnQnlOYW1lW3RhZ107XG4gIGVsc2UgaWYgKHR5cGVvZiB0YWcgPT09ICdudW1iZXInICYmICh0YWcgfCAwKSA9PT0gdGFnKVxuICAgIHJlcyA9IHRhZztcbiAgZWxzZVxuICAgIHJldHVybiByZXBvcnRlci5lcnJvcignVW5rbm93biB0YWc6ICcgKyB0YWcpO1xuXG4gIGlmIChyZXMgPj0gMHgxZilcbiAgICByZXR1cm4gcmVwb3J0ZXIuZXJyb3IoJ011bHRpLW9jdGV0IHRhZyBlbmNvZGluZyB1bnN1cHBvcnRlZCcpO1xuXG4gIGlmICghcHJpbWl0aXZlKVxuICAgIHJlcyB8PSAweDIwO1xuXG4gIHJlcyB8PSAoZGVyLnRhZ0NsYXNzQnlOYW1lW2NscyB8fCAndW5pdmVyc2FsJ10gPDwgNik7XG5cbiAgcmV0dXJuIHJlcztcbn1cbiIsInZhciBlbmNvZGVycyA9IGV4cG9ydHM7XG5cbmVuY29kZXJzLmRlciA9IHJlcXVpcmUoJy4vZGVyJyk7XG5lbmNvZGVycy5wZW0gPSByZXF1aXJlKCcuL3BlbScpO1xuIiwidmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxudmFyIERFUkVuY29kZXIgPSByZXF1aXJlKCcuL2RlcicpO1xuXG5mdW5jdGlvbiBQRU1FbmNvZGVyKGVudGl0eSkge1xuICBERVJFbmNvZGVyLmNhbGwodGhpcywgZW50aXR5KTtcbiAgdGhpcy5lbmMgPSAncGVtJztcbn07XG5pbmhlcml0cyhQRU1FbmNvZGVyLCBERVJFbmNvZGVyKTtcbm1vZHVsZS5leHBvcnRzID0gUEVNRW5jb2RlcjtcblxuUEVNRW5jb2Rlci5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKGRhdGEsIG9wdGlvbnMpIHtcbiAgdmFyIGJ1ZiA9IERFUkVuY29kZXIucHJvdG90eXBlLmVuY29kZS5jYWxsKHRoaXMsIGRhdGEpO1xuXG4gIHZhciBwID0gYnVmLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgdmFyIG91dCA9IFsgJy0tLS0tQkVHSU4gJyArIG9wdGlvbnMubGFiZWwgKyAnLS0tLS0nIF07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcC5sZW5ndGg7IGkgKz0gNjQpXG4gICAgb3V0LnB1c2gocC5zbGljZShpLCBpICsgNjQpKTtcbiAgb3V0LnB1c2goJy0tLS0tRU5EICcgKyBvcHRpb25zLmxhYmVsICsgJy0tLS0tJyk7XG4gIHJldHVybiBvdXQuam9pbignXFxuJyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gZ2V0TGVucyAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoJz0nKVxuICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlblxuXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuXG4gICAgPyAwXG4gICAgOiA0IC0gKHZhbGlkTGVuICUgNClcblxuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dXG59XG5cbi8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIF9ieXRlTGVuZ3RoIChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG5cbiAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSlcblxuICB2YXIgY3VyQnl0ZSA9IDBcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIHZhciBsZW4gPSBwbGFjZUhvbGRlcnNMZW4gPiAwXG4gICAgPyB2YWxpZExlbiAtIDRcbiAgICA6IHZhbGlkTGVuXG5cbiAgdmFyIGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8XG4gICAgICByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMikge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDEpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPVxuICAgICAgKCh1aW50OFtpXSA8PCAxNikgJiAweEZGMDAwMCkgK1xuICAgICAgKCh1aW50OFtpICsgMV0gPDwgOCkgJiAweEZGMDApICtcbiAgICAgICh1aW50OFtpICsgMl0gJiAweEZGKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKFxuICAgICAgdWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKVxuICAgICkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAyXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdICtcbiAgICAgICc9PSdcbiAgICApXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArIHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMTBdICtcbiAgICAgIGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXSArXG4gICAgICAnPSdcbiAgICApXG4gIH1cblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cbiIsIihmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBVdGlsc1xuICBmdW5jdGlvbiBhc3NlcnQgKHZhbCwgbXNnKSB7XG4gICAgaWYgKCF2YWwpIHRocm93IG5ldyBFcnJvcihtc2cgfHwgJ0Fzc2VydGlvbiBmYWlsZWQnKTtcbiAgfVxuXG4gIC8vIENvdWxkIHVzZSBgaW5oZXJpdHNgIG1vZHVsZSwgYnV0IGRvbid0IHdhbnQgdG8gbW92ZSBmcm9tIHNpbmdsZSBmaWxlXG4gIC8vIGFyY2hpdGVjdHVyZSB5ZXQuXG4gIGZ1bmN0aW9uIGluaGVyaXRzIChjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvcjtcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlO1xuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKCk7XG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yO1xuICB9XG5cbiAgLy8gQk5cblxuICBmdW5jdGlvbiBCTiAobnVtYmVyLCBiYXNlLCBlbmRpYW4pIHtcbiAgICBpZiAoQk4uaXNCTihudW1iZXIpKSB7XG4gICAgICByZXR1cm4gbnVtYmVyO1xuICAgIH1cblxuICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgIHRoaXMud29yZHMgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcblxuICAgIC8vIFJlZHVjdGlvbiBjb250ZXh0XG4gICAgdGhpcy5yZWQgPSBudWxsO1xuXG4gICAgaWYgKG51bWJlciAhPT0gbnVsbCkge1xuICAgICAgaWYgKGJhc2UgPT09ICdsZScgfHwgYmFzZSA9PT0gJ2JlJykge1xuICAgICAgICBlbmRpYW4gPSBiYXNlO1xuICAgICAgICBiYXNlID0gMTA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2luaXQobnVtYmVyIHx8IDAsIGJhc2UgfHwgMTAsIGVuZGlhbiB8fCAnYmUnKTtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBCTjtcbiAgfSBlbHNlIHtcbiAgICBleHBvcnRzLkJOID0gQk47XG4gIH1cblxuICBCTi5CTiA9IEJOO1xuICBCTi53b3JkU2l6ZSA9IDI2O1xuXG4gIHZhciBCdWZmZXI7XG4gIHRyeSB7XG4gICAgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuICB9IGNhdGNoIChlKSB7XG4gIH1cblxuICBCTi5pc0JOID0gZnVuY3Rpb24gaXNCTiAobnVtKSB7XG4gICAgaWYgKG51bSBpbnN0YW5jZW9mIEJOKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVtICE9PSBudWxsICYmIHR5cGVvZiBudW0gPT09ICdvYmplY3QnICYmXG4gICAgICBudW0uY29uc3RydWN0b3Iud29yZFNpemUgPT09IEJOLndvcmRTaXplICYmIEFycmF5LmlzQXJyYXkobnVtLndvcmRzKTtcbiAgfTtcblxuICBCTi5tYXggPSBmdW5jdGlvbiBtYXggKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQuY21wKHJpZ2h0KSA+IDApIHJldHVybiBsZWZ0O1xuICAgIHJldHVybiByaWdodDtcbiAgfTtcblxuICBCTi5taW4gPSBmdW5jdGlvbiBtaW4gKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQuY21wKHJpZ2h0KSA8IDApIHJldHVybiBsZWZ0O1xuICAgIHJldHVybiByaWdodDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiBpbml0IChudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuICAgIGlmICh0eXBlb2YgbnVtYmVyID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIHRoaXMuX2luaXROdW1iZXIobnVtYmVyLCBiYXNlLCBlbmRpYW4pO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbnVtYmVyID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIHRoaXMuX2luaXRBcnJheShudW1iZXIsIGJhc2UsIGVuZGlhbik7XG4gICAgfVxuXG4gICAgaWYgKGJhc2UgPT09ICdoZXgnKSB7XG4gICAgICBiYXNlID0gMTY7XG4gICAgfVxuICAgIGFzc2VydChiYXNlID09PSAoYmFzZSB8IDApICYmIGJhc2UgPj0gMiAmJiBiYXNlIDw9IDM2KTtcblxuICAgIG51bWJlciA9IG51bWJlci50b1N0cmluZygpLnJlcGxhY2UoL1xccysvZywgJycpO1xuICAgIHZhciBzdGFydCA9IDA7XG4gICAgaWYgKG51bWJlclswXSA9PT0gJy0nKSB7XG4gICAgICBzdGFydCsrO1xuICAgIH1cblxuICAgIGlmIChiYXNlID09PSAxNikge1xuICAgICAgdGhpcy5fcGFyc2VIZXgobnVtYmVyLCBzdGFydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3BhcnNlQmFzZShudW1iZXIsIGJhc2UsIHN0YXJ0KTtcbiAgICB9XG5cbiAgICBpZiAobnVtYmVyWzBdID09PSAnLScpIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgIH1cblxuICAgIHRoaXMuc3RyaXAoKTtcblxuICAgIGlmIChlbmRpYW4gIT09ICdsZScpIHJldHVybjtcblxuICAgIHRoaXMuX2luaXRBcnJheSh0aGlzLnRvQXJyYXkoKSwgYmFzZSwgZW5kaWFuKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2luaXROdW1iZXIgPSBmdW5jdGlvbiBfaW5pdE51bWJlciAobnVtYmVyLCBiYXNlLCBlbmRpYW4pIHtcbiAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgICBudW1iZXIgPSAtbnVtYmVyO1xuICAgIH1cbiAgICBpZiAobnVtYmVyIDwgMHg0MDAwMDAwKSB7XG4gICAgICB0aGlzLndvcmRzID0gWyBudW1iZXIgJiAweDNmZmZmZmYgXTtcbiAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICB9IGVsc2UgaWYgKG51bWJlciA8IDB4MTAwMDAwMDAwMDAwMDApIHtcbiAgICAgIHRoaXMud29yZHMgPSBbXG4gICAgICAgIG51bWJlciAmIDB4M2ZmZmZmZixcbiAgICAgICAgKG51bWJlciAvIDB4NDAwMDAwMCkgJiAweDNmZmZmZmZcbiAgICAgIF07XG4gICAgICB0aGlzLmxlbmd0aCA9IDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChudW1iZXIgPCAweDIwMDAwMDAwMDAwMDAwKTsgLy8gMiBeIDUzICh1bnNhZmUpXG4gICAgICB0aGlzLndvcmRzID0gW1xuICAgICAgICBudW1iZXIgJiAweDNmZmZmZmYsXG4gICAgICAgIChudW1iZXIgLyAweDQwMDAwMDApICYgMHgzZmZmZmZmLFxuICAgICAgICAxXG4gICAgICBdO1xuICAgICAgdGhpcy5sZW5ndGggPSAzO1xuICAgIH1cblxuICAgIGlmIChlbmRpYW4gIT09ICdsZScpIHJldHVybjtcblxuICAgIC8vIFJldmVyc2UgdGhlIGJ5dGVzXG4gICAgdGhpcy5faW5pdEFycmF5KHRoaXMudG9BcnJheSgpLCBiYXNlLCBlbmRpYW4pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5faW5pdEFycmF5ID0gZnVuY3Rpb24gX2luaXRBcnJheSAobnVtYmVyLCBiYXNlLCBlbmRpYW4pIHtcbiAgICAvLyBQZXJoYXBzIGEgVWludDhBcnJheVxuICAgIGFzc2VydCh0eXBlb2YgbnVtYmVyLmxlbmd0aCA9PT0gJ251bWJlcicpO1xuICAgIGlmIChudW1iZXIubGVuZ3RoIDw9IDApIHtcbiAgICAgIHRoaXMud29yZHMgPSBbIDAgXTtcbiAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5jZWlsKG51bWJlci5sZW5ndGggLyAzKTtcbiAgICB0aGlzLndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSAwO1xuICAgIH1cblxuICAgIHZhciBqLCB3O1xuICAgIHZhciBvZmYgPSAwO1xuICAgIGlmIChlbmRpYW4gPT09ICdiZScpIHtcbiAgICAgIGZvciAoaSA9IG51bWJlci5sZW5ndGggLSAxLCBqID0gMDsgaSA+PSAwOyBpIC09IDMpIHtcbiAgICAgICAgdyA9IG51bWJlcltpXSB8IChudW1iZXJbaSAtIDFdIDw8IDgpIHwgKG51bWJlcltpIC0gMl0gPDwgMTYpO1xuICAgICAgICB0aGlzLndvcmRzW2pdIHw9ICh3IDw8IG9mZikgJiAweDNmZmZmZmY7XG4gICAgICAgIHRoaXMud29yZHNbaiArIDFdID0gKHcgPj4+ICgyNiAtIG9mZikpICYgMHgzZmZmZmZmO1xuICAgICAgICBvZmYgKz0gMjQ7XG4gICAgICAgIGlmIChvZmYgPj0gMjYpIHtcbiAgICAgICAgICBvZmYgLT0gMjY7XG4gICAgICAgICAgaisrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbmRpYW4gPT09ICdsZScpIHtcbiAgICAgIGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbnVtYmVyLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIHcgPSBudW1iZXJbaV0gfCAobnVtYmVyW2kgKyAxXSA8PCA4KSB8IChudW1iZXJbaSArIDJdIDw8IDE2KTtcbiAgICAgICAgdGhpcy53b3Jkc1tqXSB8PSAodyA8PCBvZmYpICYgMHgzZmZmZmZmO1xuICAgICAgICB0aGlzLndvcmRzW2ogKyAxXSA9ICh3ID4+PiAoMjYgLSBvZmYpKSAmIDB4M2ZmZmZmZjtcbiAgICAgICAgb2ZmICs9IDI0O1xuICAgICAgICBpZiAob2ZmID49IDI2KSB7XG4gICAgICAgICAgb2ZmIC09IDI2O1xuICAgICAgICAgIGorKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHBhcnNlSGV4IChzdHIsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgciA9IDA7XG4gICAgdmFyIGxlbiA9IE1hdGgubWluKHN0ci5sZW5ndGgsIGVuZCk7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSkgLSA0ODtcblxuICAgICAgciA8PD0gNDtcblxuICAgICAgLy8gJ2EnIC0gJ2YnXG4gICAgICBpZiAoYyA+PSA0OSAmJiBjIDw9IDU0KSB7XG4gICAgICAgIHIgfD0gYyAtIDQ5ICsgMHhhO1xuXG4gICAgICAvLyAnQScgLSAnRidcbiAgICAgIH0gZWxzZSBpZiAoYyA+PSAxNyAmJiBjIDw9IDIyKSB7XG4gICAgICAgIHIgfD0gYyAtIDE3ICsgMHhhO1xuXG4gICAgICAvLyAnMCcgLSAnOSdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHIgfD0gYyAmIDB4ZjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cblxuICBCTi5wcm90b3R5cGUuX3BhcnNlSGV4ID0gZnVuY3Rpb24gX3BhcnNlSGV4IChudW1iZXIsIHN0YXJ0KSB7XG4gICAgLy8gQ3JlYXRlIHBvc3NpYmx5IGJpZ2dlciBhcnJheSB0byBlbnN1cmUgdGhhdCBpdCBmaXRzIHRoZSBudW1iZXJcbiAgICB0aGlzLmxlbmd0aCA9IE1hdGguY2VpbCgobnVtYmVyLmxlbmd0aCAtIHN0YXJ0KSAvIDYpO1xuICAgIHRoaXMud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IDA7XG4gICAgfVxuXG4gICAgdmFyIGosIHc7XG4gICAgLy8gU2NhbiAyNC1iaXQgY2h1bmtzIGFuZCBhZGQgdGhlbSB0byB0aGUgbnVtYmVyXG4gICAgdmFyIG9mZiA9IDA7XG4gICAgZm9yIChpID0gbnVtYmVyLmxlbmd0aCAtIDYsIGogPSAwOyBpID49IHN0YXJ0OyBpIC09IDYpIHtcbiAgICAgIHcgPSBwYXJzZUhleChudW1iZXIsIGksIGkgKyA2KTtcbiAgICAgIHRoaXMud29yZHNbal0gfD0gKHcgPDwgb2ZmKSAmIDB4M2ZmZmZmZjtcbiAgICAgIC8vIE5PVEU6IGAweDNmZmZmZmAgaXMgaW50ZW50aW9uYWwgaGVyZSwgMjZiaXRzIG1heCBzaGlmdCArIDI0Yml0IGhleCBsaW1iXG4gICAgICB0aGlzLndvcmRzW2ogKyAxXSB8PSB3ID4+PiAoMjYgLSBvZmYpICYgMHgzZmZmZmY7XG4gICAgICBvZmYgKz0gMjQ7XG4gICAgICBpZiAob2ZmID49IDI2KSB7XG4gICAgICAgIG9mZiAtPSAyNjtcbiAgICAgICAgaisrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaSArIDYgIT09IHN0YXJ0KSB7XG4gICAgICB3ID0gcGFyc2VIZXgobnVtYmVyLCBzdGFydCwgaSArIDYpO1xuICAgICAgdGhpcy53b3Jkc1tqXSB8PSAodyA8PCBvZmYpICYgMHgzZmZmZmZmO1xuICAgICAgdGhpcy53b3Jkc1tqICsgMV0gfD0gdyA+Pj4gKDI2IC0gb2ZmKSAmIDB4M2ZmZmZmO1xuICAgIH1cbiAgICB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gcGFyc2VCYXNlIChzdHIsIHN0YXJ0LCBlbmQsIG11bCkge1xuICAgIHZhciByID0gMDtcbiAgICB2YXIgbGVuID0gTWF0aC5taW4oc3RyLmxlbmd0aCwgZW5kKTtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKSAtIDQ4O1xuXG4gICAgICByICo9IG11bDtcblxuICAgICAgLy8gJ2EnXG4gICAgICBpZiAoYyA+PSA0OSkge1xuICAgICAgICByICs9IGMgLSA0OSArIDB4YTtcblxuICAgICAgLy8gJ0EnXG4gICAgICB9IGVsc2UgaWYgKGMgPj0gMTcpIHtcbiAgICAgICAgciArPSBjIC0gMTcgKyAweGE7XG5cbiAgICAgIC8vICcwJyAtICc5J1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgciArPSBjO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuXG4gIEJOLnByb3RvdHlwZS5fcGFyc2VCYXNlID0gZnVuY3Rpb24gX3BhcnNlQmFzZSAobnVtYmVyLCBiYXNlLCBzdGFydCkge1xuICAgIC8vIEluaXRpYWxpemUgYXMgemVyb1xuICAgIHRoaXMud29yZHMgPSBbIDAgXTtcbiAgICB0aGlzLmxlbmd0aCA9IDE7XG5cbiAgICAvLyBGaW5kIGxlbmd0aCBvZiBsaW1iIGluIGJhc2VcbiAgICBmb3IgKHZhciBsaW1iTGVuID0gMCwgbGltYlBvdyA9IDE7IGxpbWJQb3cgPD0gMHgzZmZmZmZmOyBsaW1iUG93ICo9IGJhc2UpIHtcbiAgICAgIGxpbWJMZW4rKztcbiAgICB9XG4gICAgbGltYkxlbi0tO1xuICAgIGxpbWJQb3cgPSAobGltYlBvdyAvIGJhc2UpIHwgMDtcblxuICAgIHZhciB0b3RhbCA9IG51bWJlci5sZW5ndGggLSBzdGFydDtcbiAgICB2YXIgbW9kID0gdG90YWwgJSBsaW1iTGVuO1xuICAgIHZhciBlbmQgPSBNYXRoLm1pbih0b3RhbCwgdG90YWwgLSBtb2QpICsgc3RhcnQ7XG5cbiAgICB2YXIgd29yZCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IGxpbWJMZW4pIHtcbiAgICAgIHdvcmQgPSBwYXJzZUJhc2UobnVtYmVyLCBpLCBpICsgbGltYkxlbiwgYmFzZSk7XG5cbiAgICAgIHRoaXMuaW11bG4obGltYlBvdyk7XG4gICAgICBpZiAodGhpcy53b3Jkc1swXSArIHdvcmQgPCAweDQwMDAwMDApIHtcbiAgICAgICAgdGhpcy53b3Jkc1swXSArPSB3b3JkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faWFkZG4od29yZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1vZCAhPT0gMCkge1xuICAgICAgdmFyIHBvdyA9IDE7XG4gICAgICB3b3JkID0gcGFyc2VCYXNlKG51bWJlciwgaSwgbnVtYmVyLmxlbmd0aCwgYmFzZSk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBtb2Q7IGkrKykge1xuICAgICAgICBwb3cgKj0gYmFzZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pbXVsbihwb3cpO1xuICAgICAgaWYgKHRoaXMud29yZHNbMF0gKyB3b3JkIDwgMHg0MDAwMDAwKSB7XG4gICAgICAgIHRoaXMud29yZHNbMF0gKz0gd29yZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2lhZGRuKHdvcmQpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBCTi5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKGRlc3QpIHtcbiAgICBkZXN0LndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlc3Qud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldO1xuICAgIH1cbiAgICBkZXN0Lmxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgIGRlc3QubmVnYXRpdmUgPSB0aGlzLm5lZ2F0aXZlO1xuICAgIGRlc3QucmVkID0gdGhpcy5yZWQ7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUgKCkge1xuICAgIHZhciByID0gbmV3IEJOKG51bGwpO1xuICAgIHRoaXMuY29weShyKTtcbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2V4cGFuZCA9IGZ1bmN0aW9uIF9leHBhbmQgKHNpemUpIHtcbiAgICB3aGlsZSAodGhpcy5sZW5ndGggPCBzaXplKSB7XG4gICAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoKytdID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gUmVtb3ZlIGxlYWRpbmcgYDBgIGZyb20gYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5zdHJpcCA9IGZ1bmN0aW9uIHN0cmlwICgpIHtcbiAgICB3aGlsZSAodGhpcy5sZW5ndGggPiAxICYmIHRoaXMud29yZHNbdGhpcy5sZW5ndGggLSAxXSA9PT0gMCkge1xuICAgICAgdGhpcy5sZW5ndGgtLTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX25vcm1TaWduKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9ub3JtU2lnbiA9IGZ1bmN0aW9uIF9ub3JtU2lnbiAoKSB7XG4gICAgLy8gLTAgPSAwXG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxICYmIHRoaXMud29yZHNbMF0gPT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICAgIHJldHVybiAodGhpcy5yZWQgPyAnPEJOLVI6ICcgOiAnPEJOOiAnKSArIHRoaXMudG9TdHJpbmcoMTYpICsgJz4nO1xuICB9O1xuXG4gIC8qXG5cbiAgdmFyIHplcm9zID0gW107XG4gIHZhciBncm91cFNpemVzID0gW107XG4gIHZhciBncm91cEJhc2VzID0gW107XG5cbiAgdmFyIHMgPSAnJztcbiAgdmFyIGkgPSAtMTtcbiAgd2hpbGUgKCsraSA8IEJOLndvcmRTaXplKSB7XG4gICAgemVyb3NbaV0gPSBzO1xuICAgIHMgKz0gJzAnO1xuICB9XG4gIGdyb3VwU2l6ZXNbMF0gPSAwO1xuICBncm91cFNpemVzWzFdID0gMDtcbiAgZ3JvdXBCYXNlc1swXSA9IDA7XG4gIGdyb3VwQmFzZXNbMV0gPSAwO1xuICB2YXIgYmFzZSA9IDIgLSAxO1xuICB3aGlsZSAoKytiYXNlIDwgMzYgKyAxKSB7XG4gICAgdmFyIGdyb3VwU2l6ZSA9IDA7XG4gICAgdmFyIGdyb3VwQmFzZSA9IDE7XG4gICAgd2hpbGUgKGdyb3VwQmFzZSA8ICgxIDw8IEJOLndvcmRTaXplKSAvIGJhc2UpIHtcbiAgICAgIGdyb3VwQmFzZSAqPSBiYXNlO1xuICAgICAgZ3JvdXBTaXplICs9IDE7XG4gICAgfVxuICAgIGdyb3VwU2l6ZXNbYmFzZV0gPSBncm91cFNpemU7XG4gICAgZ3JvdXBCYXNlc1tiYXNlXSA9IGdyb3VwQmFzZTtcbiAgfVxuXG4gICovXG5cbiAgdmFyIHplcm9zID0gW1xuICAgICcnLFxuICAgICcwJyxcbiAgICAnMDAnLFxuICAgICcwMDAnLFxuICAgICcwMDAwJyxcbiAgICAnMDAwMDAnLFxuICAgICcwMDAwMDAnLFxuICAgICcwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJ1xuICBdO1xuXG4gIHZhciBncm91cFNpemVzID0gW1xuICAgIDAsIDAsXG4gICAgMjUsIDE2LCAxMiwgMTEsIDEwLCA5LCA4LFxuICAgIDgsIDcsIDcsIDcsIDcsIDYsIDYsXG4gICAgNiwgNiwgNiwgNiwgNiwgNSwgNSxcbiAgICA1LCA1LCA1LCA1LCA1LCA1LCA1LFxuICAgIDUsIDUsIDUsIDUsIDUsIDUsIDVcbiAgXTtcblxuICB2YXIgZ3JvdXBCYXNlcyA9IFtcbiAgICAwLCAwLFxuICAgIDMzNTU0NDMyLCA0MzA0NjcyMSwgMTY3NzcyMTYsIDQ4ODI4MTI1LCA2MDQ2NjE3NiwgNDAzNTM2MDcsIDE2Nzc3MjE2LFxuICAgIDQzMDQ2NzIxLCAxMDAwMDAwMCwgMTk0ODcxNzEsIDM1ODMxODA4LCA2Mjc0ODUxNywgNzUyOTUzNiwgMTEzOTA2MjUsXG4gICAgMTY3NzcyMTYsIDI0MTM3NTY5LCAzNDAxMjIyNCwgNDcwNDU4ODEsIDY0MDAwMDAwLCA0MDg0MTAxLCA1MTUzNjMyLFxuICAgIDY0MzYzNDMsIDc5NjI2MjQsIDk3NjU2MjUsIDExODgxMzc2LCAxNDM0ODkwNywgMTcyMTAzNjgsIDIwNTExMTQ5LFxuICAgIDI0MzAwMDAwLCAyODYyOTE1MSwgMzM1NTQ0MzIsIDM5MTM1MzkzLCA0NTQzNTQyNCwgNTI1MjE4NzUsIDYwNDY2MTc2XG4gIF07XG5cbiAgQk4ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKGJhc2UsIHBhZGRpbmcpIHtcbiAgICBiYXNlID0gYmFzZSB8fCAxMDtcbiAgICBwYWRkaW5nID0gcGFkZGluZyB8IDAgfHwgMTtcblxuICAgIHZhciBvdXQ7XG4gICAgaWYgKGJhc2UgPT09IDE2IHx8IGJhc2UgPT09ICdoZXgnKSB7XG4gICAgICBvdXQgPSAnJztcbiAgICAgIHZhciBvZmYgPSAwO1xuICAgICAgdmFyIGNhcnJ5ID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdyA9IHRoaXMud29yZHNbaV07XG4gICAgICAgIHZhciB3b3JkID0gKCgodyA8PCBvZmYpIHwgY2FycnkpICYgMHhmZmZmZmYpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgY2FycnkgPSAodyA+Pj4gKDI0IC0gb2ZmKSkgJiAweGZmZmZmZjtcbiAgICAgICAgaWYgKGNhcnJ5ICE9PSAwIHx8IGkgIT09IHRoaXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIG91dCA9IHplcm9zWzYgLSB3b3JkLmxlbmd0aF0gKyB3b3JkICsgb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCA9IHdvcmQgKyBvdXQ7XG4gICAgICAgIH1cbiAgICAgICAgb2ZmICs9IDI7XG4gICAgICAgIGlmIChvZmYgPj0gMjYpIHtcbiAgICAgICAgICBvZmYgLT0gMjY7XG4gICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgICAgb3V0ID0gY2FycnkudG9TdHJpbmcoMTYpICsgb3V0O1xuICAgICAgfVxuICAgICAgd2hpbGUgKG91dC5sZW5ndGggJSBwYWRkaW5nICE9PSAwKSB7XG4gICAgICAgIG91dCA9ICcwJyArIG91dDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgIG91dCA9ICctJyArIG91dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgaWYgKGJhc2UgPT09IChiYXNlIHwgMCkgJiYgYmFzZSA+PSAyICYmIGJhc2UgPD0gMzYpIHtcbiAgICAgIC8vIHZhciBncm91cFNpemUgPSBNYXRoLmZsb29yKEJOLndvcmRTaXplICogTWF0aC5MTjIgLyBNYXRoLmxvZyhiYXNlKSk7XG4gICAgICB2YXIgZ3JvdXBTaXplID0gZ3JvdXBTaXplc1tiYXNlXTtcbiAgICAgIC8vIHZhciBncm91cEJhc2UgPSBNYXRoLnBvdyhiYXNlLCBncm91cFNpemUpO1xuICAgICAgdmFyIGdyb3VwQmFzZSA9IGdyb3VwQmFzZXNbYmFzZV07XG4gICAgICBvdXQgPSAnJztcbiAgICAgIHZhciBjID0gdGhpcy5jbG9uZSgpO1xuICAgICAgYy5uZWdhdGl2ZSA9IDA7XG4gICAgICB3aGlsZSAoIWMuaXNaZXJvKCkpIHtcbiAgICAgICAgdmFyIHIgPSBjLm1vZG4oZ3JvdXBCYXNlKS50b1N0cmluZyhiYXNlKTtcbiAgICAgICAgYyA9IGMuaWRpdm4oZ3JvdXBCYXNlKTtcblxuICAgICAgICBpZiAoIWMuaXNaZXJvKCkpIHtcbiAgICAgICAgICBvdXQgPSB6ZXJvc1tncm91cFNpemUgLSByLmxlbmd0aF0gKyByICsgb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCA9IHIgKyBvdXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlzWmVybygpKSB7XG4gICAgICAgIG91dCA9ICcwJyArIG91dDtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChvdXQubGVuZ3RoICUgcGFkZGluZyAhPT0gMCkge1xuICAgICAgICBvdXQgPSAnMCcgKyBvdXQ7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICBvdXQgPSAnLScgKyBvdXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIGFzc2VydChmYWxzZSwgJ0Jhc2Ugc2hvdWxkIGJlIGJldHdlZW4gMiBhbmQgMzYnKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbiB0b051bWJlciAoKSB7XG4gICAgdmFyIHJldCA9IHRoaXMud29yZHNbMF07XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAyKSB7XG4gICAgICByZXQgKz0gdGhpcy53b3Jkc1sxXSAqIDB4NDAwMDAwMDtcbiAgICB9IGVsc2UgaWYgKHRoaXMubGVuZ3RoID09PSAzICYmIHRoaXMud29yZHNbMl0gPT09IDB4MDEpIHtcbiAgICAgIC8vIE5PVEU6IGF0IHRoaXMgc3RhZ2UgaXQgaXMga25vd24gdGhhdCB0aGUgdG9wIGJpdCBpcyBzZXRcbiAgICAgIHJldCArPSAweDEwMDAwMDAwMDAwMDAwICsgKHRoaXMud29yZHNbMV0gKiAweDQwMDAwMDApO1xuICAgIH0gZWxzZSBpZiAodGhpcy5sZW5ndGggPiAyKSB7XG4gICAgICBhc3NlcnQoZmFsc2UsICdOdW1iZXIgY2FuIG9ubHkgc2FmZWx5IHN0b3JlIHVwIHRvIDUzIGJpdHMnKTtcbiAgICB9XG4gICAgcmV0dXJuICh0aGlzLm5lZ2F0aXZlICE9PSAwKSA/IC1yZXQgOiByZXQ7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoMTYpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b0J1ZmZlciA9IGZ1bmN0aW9uIHRvQnVmZmVyIChlbmRpYW4sIGxlbmd0aCkge1xuICAgIGFzc2VydCh0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJyk7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheUxpa2UoQnVmZmVyLCBlbmRpYW4sIGxlbmd0aCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiB0b0FycmF5IChlbmRpYW4sIGxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXlMaWtlKEFycmF5LCBlbmRpYW4sIGxlbmd0aCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvQXJyYXlMaWtlID0gZnVuY3Rpb24gdG9BcnJheUxpa2UgKEFycmF5VHlwZSwgZW5kaWFuLCBsZW5ndGgpIHtcbiAgICB2YXIgYnl0ZUxlbmd0aCA9IHRoaXMuYnl0ZUxlbmd0aCgpO1xuICAgIHZhciByZXFMZW5ndGggPSBsZW5ndGggfHwgTWF0aC5tYXgoMSwgYnl0ZUxlbmd0aCk7XG4gICAgYXNzZXJ0KGJ5dGVMZW5ndGggPD0gcmVxTGVuZ3RoLCAnYnl0ZSBhcnJheSBsb25nZXIgdGhhbiBkZXNpcmVkIGxlbmd0aCcpO1xuICAgIGFzc2VydChyZXFMZW5ndGggPiAwLCAnUmVxdWVzdGVkIGFycmF5IGxlbmd0aCA8PSAwJyk7XG5cbiAgICB0aGlzLnN0cmlwKCk7XG4gICAgdmFyIGxpdHRsZUVuZGlhbiA9IGVuZGlhbiA9PT0gJ2xlJztcbiAgICB2YXIgcmVzID0gbmV3IEFycmF5VHlwZShyZXFMZW5ndGgpO1xuXG4gICAgdmFyIGIsIGk7XG4gICAgdmFyIHEgPSB0aGlzLmNsb25lKCk7XG4gICAgaWYgKCFsaXR0bGVFbmRpYW4pIHtcbiAgICAgIC8vIEFzc3VtZSBiaWctZW5kaWFuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgcmVxTGVuZ3RoIC0gYnl0ZUxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc1tpXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDA7ICFxLmlzWmVybygpOyBpKyspIHtcbiAgICAgICAgYiA9IHEuYW5kbG4oMHhmZik7XG4gICAgICAgIHEuaXVzaHJuKDgpO1xuXG4gICAgICAgIHJlc1tyZXFMZW5ndGggLSBpIC0gMV0gPSBiO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSAwOyAhcS5pc1plcm8oKTsgaSsrKSB7XG4gICAgICAgIGIgPSBxLmFuZGxuKDB4ZmYpO1xuICAgICAgICBxLml1c2hybig4KTtcblxuICAgICAgICByZXNbaV0gPSBiO1xuICAgICAgfVxuXG4gICAgICBmb3IgKDsgaSA8IHJlcUxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc1tpXSA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBpZiAoTWF0aC5jbHozMikge1xuICAgIEJOLnByb3RvdHlwZS5fY291bnRCaXRzID0gZnVuY3Rpb24gX2NvdW50Qml0cyAodykge1xuICAgICAgcmV0dXJuIDMyIC0gTWF0aC5jbHozMih3KTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIEJOLnByb3RvdHlwZS5fY291bnRCaXRzID0gZnVuY3Rpb24gX2NvdW50Qml0cyAodykge1xuICAgICAgdmFyIHQgPSB3O1xuICAgICAgdmFyIHIgPSAwO1xuICAgICAgaWYgKHQgPj0gMHgxMDAwKSB7XG4gICAgICAgIHIgKz0gMTM7XG4gICAgICAgIHQgPj4+PSAxMztcbiAgICAgIH1cbiAgICAgIGlmICh0ID49IDB4NDApIHtcbiAgICAgICAgciArPSA3O1xuICAgICAgICB0ID4+Pj0gNztcbiAgICAgIH1cbiAgICAgIGlmICh0ID49IDB4OCkge1xuICAgICAgICByICs9IDQ7XG4gICAgICAgIHQgPj4+PSA0O1xuICAgICAgfVxuICAgICAgaWYgKHQgPj0gMHgwMikge1xuICAgICAgICByICs9IDI7XG4gICAgICAgIHQgPj4+PSAyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHIgKyB0O1xuICAgIH07XG4gIH1cblxuICBCTi5wcm90b3R5cGUuX3plcm9CaXRzID0gZnVuY3Rpb24gX3plcm9CaXRzICh3KSB7XG4gICAgLy8gU2hvcnQtY3V0XG4gICAgaWYgKHcgPT09IDApIHJldHVybiAyNjtcblxuICAgIHZhciB0ID0gdztcbiAgICB2YXIgciA9IDA7XG4gICAgaWYgKCh0ICYgMHgxZmZmKSA9PT0gMCkge1xuICAgICAgciArPSAxMztcbiAgICAgIHQgPj4+PSAxMztcbiAgICB9XG4gICAgaWYgKCh0ICYgMHg3ZikgPT09IDApIHtcbiAgICAgIHIgKz0gNztcbiAgICAgIHQgPj4+PSA3O1xuICAgIH1cbiAgICBpZiAoKHQgJiAweGYpID09PSAwKSB7XG4gICAgICByICs9IDQ7XG4gICAgICB0ID4+Pj0gNDtcbiAgICB9XG4gICAgaWYgKCh0ICYgMHgzKSA9PT0gMCkge1xuICAgICAgciArPSAyO1xuICAgICAgdCA+Pj49IDI7XG4gICAgfVxuICAgIGlmICgodCAmIDB4MSkgPT09IDApIHtcbiAgICAgIHIrKztcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgLy8gUmV0dXJuIG51bWJlciBvZiB1c2VkIGJpdHMgaW4gYSBCTlxuICBCTi5wcm90b3R5cGUuYml0TGVuZ3RoID0gZnVuY3Rpb24gYml0TGVuZ3RoICgpIHtcbiAgICB2YXIgdyA9IHRoaXMud29yZHNbdGhpcy5sZW5ndGggLSAxXTtcbiAgICB2YXIgaGkgPSB0aGlzLl9jb3VudEJpdHModyk7XG4gICAgcmV0dXJuICh0aGlzLmxlbmd0aCAtIDEpICogMjYgKyBoaTtcbiAgfTtcblxuICBmdW5jdGlvbiB0b0JpdEFycmF5IChudW0pIHtcbiAgICB2YXIgdyA9IG5ldyBBcnJheShudW0uYml0TGVuZ3RoKCkpO1xuXG4gICAgZm9yICh2YXIgYml0ID0gMDsgYml0IDwgdy5sZW5ndGg7IGJpdCsrKSB7XG4gICAgICB2YXIgb2ZmID0gKGJpdCAvIDI2KSB8IDA7XG4gICAgICB2YXIgd2JpdCA9IGJpdCAlIDI2O1xuXG4gICAgICB3W2JpdF0gPSAobnVtLndvcmRzW29mZl0gJiAoMSA8PCB3Yml0KSkgPj4+IHdiaXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHc7XG4gIH1cblxuICAvLyBOdW1iZXIgb2YgdHJhaWxpbmcgemVybyBiaXRzXG4gIEJOLnByb3RvdHlwZS56ZXJvQml0cyA9IGZ1bmN0aW9uIHplcm9CaXRzICgpIHtcbiAgICBpZiAodGhpcy5pc1plcm8oKSkgcmV0dXJuIDA7XG5cbiAgICB2YXIgciA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYiA9IHRoaXMuX3plcm9CaXRzKHRoaXMud29yZHNbaV0pO1xuICAgICAgciArPSBiO1xuICAgICAgaWYgKGIgIT09IDI2KSBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmJ5dGVMZW5ndGggPSBmdW5jdGlvbiBieXRlTGVuZ3RoICgpIHtcbiAgICByZXR1cm4gTWF0aC5jZWlsKHRoaXMuYml0TGVuZ3RoKCkgLyA4KTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9Ud29zID0gZnVuY3Rpb24gdG9Ud29zICh3aWR0aCkge1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5hYnMoKS5pbm90bih3aWR0aCkuaWFkZG4oMSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNsb25lKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmZyb21Ud29zID0gZnVuY3Rpb24gZnJvbVR3b3MgKHdpZHRoKSB7XG4gICAgaWYgKHRoaXMudGVzdG4od2lkdGggLSAxKSkge1xuICAgICAgcmV0dXJuIHRoaXMubm90bih3aWR0aCkuaWFkZG4oMSkuaW5lZygpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pc05lZyA9IGZ1bmN0aW9uIGlzTmVnICgpIHtcbiAgICByZXR1cm4gdGhpcy5uZWdhdGl2ZSAhPT0gMDtcbiAgfTtcblxuICAvLyBSZXR1cm4gbmVnYXRpdmUgY2xvbmUgb2YgYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbiBuZWcgKCkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaW5lZygpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pbmVnID0gZnVuY3Rpb24gaW5lZyAoKSB7XG4gICAgaWYgKCF0aGlzLmlzWmVybygpKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlIF49IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gT3IgYG51bWAgd2l0aCBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLml1b3IgPSBmdW5jdGlvbiBpdW9yIChudW0pIHtcbiAgICB3aGlsZSAodGhpcy5sZW5ndGggPCBudW0ubGVuZ3RoKSB7XG4gICAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoKytdID0gMDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV0gfCBudW0ud29yZHNbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaW9yID0gZnVuY3Rpb24gaW9yIChudW0pIHtcbiAgICBhc3NlcnQoKHRoaXMubmVnYXRpdmUgfCBudW0ubmVnYXRpdmUpID09PSAwKTtcbiAgICByZXR1cm4gdGhpcy5pdW9yKG51bSk7XG4gIH07XG5cbiAgLy8gT3IgYG51bWAgd2l0aCBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLm9yID0gZnVuY3Rpb24gb3IgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaW9yKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLmlvcih0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudW9yID0gZnVuY3Rpb24gdW9yIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLml1b3IobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaXVvcih0aGlzKTtcbiAgfTtcblxuICAvLyBBbmQgYG51bWAgd2l0aCBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLml1YW5kID0gZnVuY3Rpb24gaXVhbmQgKG51bSkge1xuICAgIC8vIGIgPSBtaW4tbGVuZ3RoKG51bSwgdGhpcylcbiAgICB2YXIgYjtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSB7XG4gICAgICBiID0gbnVtO1xuICAgIH0gZWxzZSB7XG4gICAgICBiID0gdGhpcztcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldICYgbnVtLndvcmRzW2ldO1xuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gYi5sZW5ndGg7XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pYW5kID0gZnVuY3Rpb24gaWFuZCAobnVtKSB7XG4gICAgYXNzZXJ0KCh0aGlzLm5lZ2F0aXZlIHwgbnVtLm5lZ2F0aXZlKSA9PT0gMCk7XG4gICAgcmV0dXJuIHRoaXMuaXVhbmQobnVtKTtcbiAgfTtcblxuICAvLyBBbmQgYG51bWAgd2l0aCBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uIGFuZCAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYW5kKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLmlhbmQodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnVhbmQgPSBmdW5jdGlvbiB1YW5kIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLml1YW5kKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLml1YW5kKHRoaXMpO1xuICB9O1xuXG4gIC8vIFhvciBgbnVtYCB3aXRoIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXV4b3IgPSBmdW5jdGlvbiBpdXhvciAobnVtKSB7XG4gICAgLy8gYS5sZW5ndGggPiBiLmxlbmd0aFxuICAgIHZhciBhO1xuICAgIHZhciBiO1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHtcbiAgICAgIGEgPSB0aGlzO1xuICAgICAgYiA9IG51bTtcbiAgICB9IGVsc2Uge1xuICAgICAgYSA9IG51bTtcbiAgICAgIGIgPSB0aGlzO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV0gXiBiLndvcmRzW2ldO1xuICAgIH1cblxuICAgIGlmICh0aGlzICE9PSBhKSB7XG4gICAgICBmb3IgKDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBhLmxlbmd0aDtcblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLml4b3IgPSBmdW5jdGlvbiBpeG9yIChudW0pIHtcbiAgICBhc3NlcnQoKHRoaXMubmVnYXRpdmUgfCBudW0ubmVnYXRpdmUpID09PSAwKTtcbiAgICByZXR1cm4gdGhpcy5pdXhvcihudW0pO1xuICB9O1xuXG4gIC8vIFhvciBgbnVtYCB3aXRoIGB0aGlzYFxuICBCTi5wcm90b3R5cGUueG9yID0gZnVuY3Rpb24geG9yIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLml4b3IobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaXhvcih0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudXhvciA9IGZ1bmN0aW9uIHV4b3IgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaXV4b3IobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaXV4b3IodGhpcyk7XG4gIH07XG5cbiAgLy8gTm90IGBgdGhpc2BgIHdpdGggYGB3aWR0aGBgIGJpdHdpZHRoXG4gIEJOLnByb3RvdHlwZS5pbm90biA9IGZ1bmN0aW9uIGlub3RuICh3aWR0aCkge1xuICAgIGFzc2VydCh0eXBlb2Ygd2lkdGggPT09ICdudW1iZXInICYmIHdpZHRoID49IDApO1xuXG4gICAgdmFyIGJ5dGVzTmVlZGVkID0gTWF0aC5jZWlsKHdpZHRoIC8gMjYpIHwgMDtcbiAgICB2YXIgYml0c0xlZnQgPSB3aWR0aCAlIDI2O1xuXG4gICAgLy8gRXh0ZW5kIHRoZSBidWZmZXIgd2l0aCBsZWFkaW5nIHplcm9lc1xuICAgIHRoaXMuX2V4cGFuZChieXRlc05lZWRlZCk7XG5cbiAgICBpZiAoYml0c0xlZnQgPiAwKSB7XG4gICAgICBieXRlc05lZWRlZC0tO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBjb21wbGV0ZSB3b3Jkc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXNOZWVkZWQ7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IH50aGlzLndvcmRzW2ldICYgMHgzZmZmZmZmO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSB0aGUgcmVzaWR1ZVxuICAgIGlmIChiaXRzTGVmdCA+IDApIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSB+dGhpcy53b3Jkc1tpXSAmICgweDNmZmZmZmYgPj4gKDI2IC0gYml0c0xlZnQpKTtcbiAgICB9XG5cbiAgICAvLyBBbmQgcmVtb3ZlIGxlYWRpbmcgemVyb2VzXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubm90biA9IGZ1bmN0aW9uIG5vdG4gKHdpZHRoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbm90bih3aWR0aCk7XG4gIH07XG5cbiAgLy8gU2V0IGBiaXRgIG9mIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuc2V0biA9IGZ1bmN0aW9uIHNldG4gKGJpdCwgdmFsKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXQgPT09ICdudW1iZXInICYmIGJpdCA+PSAwKTtcblxuICAgIHZhciBvZmYgPSAoYml0IC8gMjYpIHwgMDtcbiAgICB2YXIgd2JpdCA9IGJpdCAlIDI2O1xuXG4gICAgdGhpcy5fZXhwYW5kKG9mZiArIDEpO1xuXG4gICAgaWYgKHZhbCkge1xuICAgICAgdGhpcy53b3Jkc1tvZmZdID0gdGhpcy53b3Jkc1tvZmZdIHwgKDEgPDwgd2JpdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud29yZHNbb2ZmXSA9IHRoaXMud29yZHNbb2ZmXSAmIH4oMSA8PCB3Yml0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIC8vIEFkZCBgbnVtYCB0byBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLmlhZGQgPSBmdW5jdGlvbiBpYWRkIChudW0pIHtcbiAgICB2YXIgcjtcblxuICAgIC8vIG5lZ2F0aXZlICsgcG9zaXRpdmVcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiBudW0ubmVnYXRpdmUgPT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgciA9IHRoaXMuaXN1YihudW0pO1xuICAgICAgdGhpcy5uZWdhdGl2ZSBePSAxO1xuICAgICAgcmV0dXJuIHRoaXMuX25vcm1TaWduKCk7XG5cbiAgICAvLyBwb3NpdGl2ZSArIG5lZ2F0aXZlXG4gICAgfSBlbHNlIGlmICh0aGlzLm5lZ2F0aXZlID09PSAwICYmIG51bS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgbnVtLm5lZ2F0aXZlID0gMDtcbiAgICAgIHIgPSB0aGlzLmlzdWIobnVtKTtcbiAgICAgIG51bS5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gci5fbm9ybVNpZ24oKTtcbiAgICB9XG5cbiAgICAvLyBhLmxlbmd0aCA+IGIubGVuZ3RoXG4gICAgdmFyIGEsIGI7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkge1xuICAgICAgYSA9IHRoaXM7XG4gICAgICBiID0gbnVtO1xuICAgIH0gZWxzZSB7XG4gICAgICBhID0gbnVtO1xuICAgICAgYiA9IHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHIgPSAoYS53b3Jkc1tpXSB8IDApICsgKGIud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHIgJiAweDNmZmZmZmY7XG4gICAgICBjYXJyeSA9IHIgPj4+IDI2O1xuICAgIH1cbiAgICBmb3IgKDsgY2FycnkgIT09IDAgJiYgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIHIgPSAoYS53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcbiAgICAgIGNhcnJ5ID0gciA+Pj4gMjY7XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBhLmxlbmd0aDtcbiAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGhdID0gY2Fycnk7XG4gICAgICB0aGlzLmxlbmd0aCsrO1xuICAgIC8vIENvcHkgdGhlIHJlc3Qgb2YgdGhlIHdvcmRzXG4gICAgfSBlbHNlIGlmIChhICE9PSB0aGlzKSB7XG4gICAgICBmb3IgKDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gQWRkIGBudW1gIHRvIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChudW0pIHtcbiAgICB2YXIgcmVzO1xuICAgIGlmIChudW0ubmVnYXRpdmUgIT09IDAgJiYgdGhpcy5uZWdhdGl2ZSA9PT0gMCkge1xuICAgICAgbnVtLm5lZ2F0aXZlID0gMDtcbiAgICAgIHJlcyA9IHRoaXMuc3ViKG51bSk7XG4gICAgICBudW0ubmVnYXRpdmUgXj0gMTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfSBlbHNlIGlmIChudW0ubmVnYXRpdmUgPT09IDAgJiYgdGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICByZXMgPSBudW0uc3ViKHRoaXMpO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaWFkZChudW0pO1xuXG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLmlhZGQodGhpcyk7XG4gIH07XG5cbiAgLy8gU3VidHJhY3QgYG51bWAgZnJvbSBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLmlzdWIgPSBmdW5jdGlvbiBpc3ViIChudW0pIHtcbiAgICAvLyB0aGlzIC0gKC1udW0pID0gdGhpcyArIG51bVxuICAgIGlmIChudW0ubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIG51bS5uZWdhdGl2ZSA9IDA7XG4gICAgICB2YXIgciA9IHRoaXMuaWFkZChudW0pO1xuICAgICAgbnVtLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiByLl9ub3JtU2lnbigpO1xuXG4gICAgLy8gLXRoaXMgLSBudW0gPSAtKHRoaXMgKyBudW0pXG4gICAgfSBlbHNlIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHRoaXMuaWFkZChudW0pO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gdGhpcy5fbm9ybVNpZ24oKTtcbiAgICB9XG5cbiAgICAvLyBBdCB0aGlzIHBvaW50IGJvdGggbnVtYmVycyBhcmUgcG9zaXRpdmVcbiAgICB2YXIgY21wID0gdGhpcy5jbXAobnVtKTtcblxuICAgIC8vIE9wdGltaXphdGlvbiAtIHplcm9pZnlcbiAgICBpZiAoY21wID09PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICAgIHRoaXMud29yZHNbMF0gPSAwO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gYSA+IGJcbiAgICB2YXIgYSwgYjtcbiAgICBpZiAoY21wID4gMCkge1xuICAgICAgYSA9IHRoaXM7XG4gICAgICBiID0gbnVtO1xuICAgIH0gZWxzZSB7XG4gICAgICBhID0gbnVtO1xuICAgICAgYiA9IHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHIgPSAoYS53b3Jkc1tpXSB8IDApIC0gKGIud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgICAgY2FycnkgPSByID4+IDI2O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHIgJiAweDNmZmZmZmY7XG4gICAgfVxuICAgIGZvciAoOyBjYXJyeSAhPT0gMCAmJiBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgciA9IChhLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcbiAgICAgIGNhcnJ5ID0gciA+PiAyNjtcbiAgICAgIHRoaXMud29yZHNbaV0gPSByICYgMHgzZmZmZmZmO1xuICAgIH1cblxuICAgIC8vIENvcHkgcmVzdCBvZiB0aGUgd29yZHNcbiAgICBpZiAoY2FycnkgPT09IDAgJiYgaSA8IGEubGVuZ3RoICYmIGEgIT09IHRoaXMpIHtcbiAgICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IE1hdGgubWF4KHRoaXMubGVuZ3RoLCBpKTtcblxuICAgIGlmIChhICE9PSB0aGlzKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIC8vIFN1YnRyYWN0IGBudW1gIGZyb20gYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbiBzdWIgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXN1YihudW0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHNtYWxsTXVsVG8gKHNlbGYsIG51bSwgb3V0KSB7XG4gICAgb3V0Lm5lZ2F0aXZlID0gbnVtLm5lZ2F0aXZlIF4gc2VsZi5uZWdhdGl2ZTtcbiAgICB2YXIgbGVuID0gKHNlbGYubGVuZ3RoICsgbnVtLmxlbmd0aCkgfCAwO1xuICAgIG91dC5sZW5ndGggPSBsZW47XG4gICAgbGVuID0gKGxlbiAtIDEpIHwgMDtcblxuICAgIC8vIFBlZWwgb25lIGl0ZXJhdGlvbiAoY29tcGlsZXIgY2FuJ3QgZG8gaXQsIGJlY2F1c2Ugb2YgY29kZSBjb21wbGV4aXR5KVxuICAgIHZhciBhID0gc2VsZi53b3Jkc1swXSB8IDA7XG4gICAgdmFyIGIgPSBudW0ud29yZHNbMF0gfCAwO1xuICAgIHZhciByID0gYSAqIGI7XG5cbiAgICB2YXIgbG8gPSByICYgMHgzZmZmZmZmO1xuICAgIHZhciBjYXJyeSA9IChyIC8gMHg0MDAwMDAwKSB8IDA7XG4gICAgb3V0LndvcmRzWzBdID0gbG87XG5cbiAgICBmb3IgKHZhciBrID0gMTsgayA8IGxlbjsgaysrKSB7XG4gICAgICAvLyBTdW0gYWxsIHdvcmRzIHdpdGggdGhlIHNhbWUgYGkgKyBqID0ga2AgYW5kIGFjY3VtdWxhdGUgYG5jYXJyeWAsXG4gICAgICAvLyBub3RlIHRoYXQgbmNhcnJ5IGNvdWxkIGJlID49IDB4M2ZmZmZmZlxuICAgICAgdmFyIG5jYXJyeSA9IGNhcnJ5ID4+PiAyNjtcbiAgICAgIHZhciByd29yZCA9IGNhcnJ5ICYgMHgzZmZmZmZmO1xuICAgICAgdmFyIG1heEogPSBNYXRoLm1pbihrLCBudW0ubGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKHZhciBqID0gTWF0aC5tYXgoMCwgayAtIHNlbGYubGVuZ3RoICsgMSk7IGogPD0gbWF4SjsgaisrKSB7XG4gICAgICAgIHZhciBpID0gKGsgLSBqKSB8IDA7XG4gICAgICAgIGEgPSBzZWxmLndvcmRzW2ldIHwgMDtcbiAgICAgICAgYiA9IG51bS53b3Jkc1tqXSB8IDA7XG4gICAgICAgIHIgPSBhICogYiArIHJ3b3JkO1xuICAgICAgICBuY2FycnkgKz0gKHIgLyAweDQwMDAwMDApIHwgMDtcbiAgICAgICAgcndvcmQgPSByICYgMHgzZmZmZmZmO1xuICAgICAgfVxuICAgICAgb3V0LndvcmRzW2tdID0gcndvcmQgfCAwO1xuICAgICAgY2FycnkgPSBuY2FycnkgfCAwO1xuICAgIH1cbiAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgIG91dC53b3Jkc1trXSA9IGNhcnJ5IHwgMDtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0Lmxlbmd0aC0tO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQuc3RyaXAoKTtcbiAgfVxuXG4gIC8vIFRPRE8oaW5kdXRueSk6IGl0IG1heSBiZSByZWFzb25hYmxlIHRvIG9taXQgaXQgZm9yIHVzZXJzIHdobyBkb24ndCBuZWVkXG4gIC8vIHRvIHdvcmsgd2l0aCAyNTYtYml0IG51bWJlcnMsIG90aGVyd2lzZSBpdCBnaXZlcyAyMCUgaW1wcm92ZW1lbnQgZm9yIDI1Ni1iaXRcbiAgLy8gbXVsdGlwbGljYXRpb24gKGxpa2UgZWxsaXB0aWMgc2VjcDI1NmsxKS5cbiAgdmFyIGNvbWIxME11bFRvID0gZnVuY3Rpb24gY29tYjEwTXVsVG8gKHNlbGYsIG51bSwgb3V0KSB7XG4gICAgdmFyIGEgPSBzZWxmLndvcmRzO1xuICAgIHZhciBiID0gbnVtLndvcmRzO1xuICAgIHZhciBvID0gb3V0LndvcmRzO1xuICAgIHZhciBjID0gMDtcbiAgICB2YXIgbG87XG4gICAgdmFyIG1pZDtcbiAgICB2YXIgaGk7XG4gICAgdmFyIGEwID0gYVswXSB8IDA7XG4gICAgdmFyIGFsMCA9IGEwICYgMHgxZmZmO1xuICAgIHZhciBhaDAgPSBhMCA+Pj4gMTM7XG4gICAgdmFyIGExID0gYVsxXSB8IDA7XG4gICAgdmFyIGFsMSA9IGExICYgMHgxZmZmO1xuICAgIHZhciBhaDEgPSBhMSA+Pj4gMTM7XG4gICAgdmFyIGEyID0gYVsyXSB8IDA7XG4gICAgdmFyIGFsMiA9IGEyICYgMHgxZmZmO1xuICAgIHZhciBhaDIgPSBhMiA+Pj4gMTM7XG4gICAgdmFyIGEzID0gYVszXSB8IDA7XG4gICAgdmFyIGFsMyA9IGEzICYgMHgxZmZmO1xuICAgIHZhciBhaDMgPSBhMyA+Pj4gMTM7XG4gICAgdmFyIGE0ID0gYVs0XSB8IDA7XG4gICAgdmFyIGFsNCA9IGE0ICYgMHgxZmZmO1xuICAgIHZhciBhaDQgPSBhNCA+Pj4gMTM7XG4gICAgdmFyIGE1ID0gYVs1XSB8IDA7XG4gICAgdmFyIGFsNSA9IGE1ICYgMHgxZmZmO1xuICAgIHZhciBhaDUgPSBhNSA+Pj4gMTM7XG4gICAgdmFyIGE2ID0gYVs2XSB8IDA7XG4gICAgdmFyIGFsNiA9IGE2ICYgMHgxZmZmO1xuICAgIHZhciBhaDYgPSBhNiA+Pj4gMTM7XG4gICAgdmFyIGE3ID0gYVs3XSB8IDA7XG4gICAgdmFyIGFsNyA9IGE3ICYgMHgxZmZmO1xuICAgIHZhciBhaDcgPSBhNyA+Pj4gMTM7XG4gICAgdmFyIGE4ID0gYVs4XSB8IDA7XG4gICAgdmFyIGFsOCA9IGE4ICYgMHgxZmZmO1xuICAgIHZhciBhaDggPSBhOCA+Pj4gMTM7XG4gICAgdmFyIGE5ID0gYVs5XSB8IDA7XG4gICAgdmFyIGFsOSA9IGE5ICYgMHgxZmZmO1xuICAgIHZhciBhaDkgPSBhOSA+Pj4gMTM7XG4gICAgdmFyIGIwID0gYlswXSB8IDA7XG4gICAgdmFyIGJsMCA9IGIwICYgMHgxZmZmO1xuICAgIHZhciBiaDAgPSBiMCA+Pj4gMTM7XG4gICAgdmFyIGIxID0gYlsxXSB8IDA7XG4gICAgdmFyIGJsMSA9IGIxICYgMHgxZmZmO1xuICAgIHZhciBiaDEgPSBiMSA+Pj4gMTM7XG4gICAgdmFyIGIyID0gYlsyXSB8IDA7XG4gICAgdmFyIGJsMiA9IGIyICYgMHgxZmZmO1xuICAgIHZhciBiaDIgPSBiMiA+Pj4gMTM7XG4gICAgdmFyIGIzID0gYlszXSB8IDA7XG4gICAgdmFyIGJsMyA9IGIzICYgMHgxZmZmO1xuICAgIHZhciBiaDMgPSBiMyA+Pj4gMTM7XG4gICAgdmFyIGI0ID0gYls0XSB8IDA7XG4gICAgdmFyIGJsNCA9IGI0ICYgMHgxZmZmO1xuICAgIHZhciBiaDQgPSBiNCA+Pj4gMTM7XG4gICAgdmFyIGI1ID0gYls1XSB8IDA7XG4gICAgdmFyIGJsNSA9IGI1ICYgMHgxZmZmO1xuICAgIHZhciBiaDUgPSBiNSA+Pj4gMTM7XG4gICAgdmFyIGI2ID0gYls2XSB8IDA7XG4gICAgdmFyIGJsNiA9IGI2ICYgMHgxZmZmO1xuICAgIHZhciBiaDYgPSBiNiA+Pj4gMTM7XG4gICAgdmFyIGI3ID0gYls3XSB8IDA7XG4gICAgdmFyIGJsNyA9IGI3ICYgMHgxZmZmO1xuICAgIHZhciBiaDcgPSBiNyA+Pj4gMTM7XG4gICAgdmFyIGI4ID0gYls4XSB8IDA7XG4gICAgdmFyIGJsOCA9IGI4ICYgMHgxZmZmO1xuICAgIHZhciBiaDggPSBiOCA+Pj4gMTM7XG4gICAgdmFyIGI5ID0gYls5XSB8IDA7XG4gICAgdmFyIGJsOSA9IGI5ICYgMHgxZmZmO1xuICAgIHZhciBiaDkgPSBiOSA+Pj4gMTM7XG5cbiAgICBvdXQubmVnYXRpdmUgPSBzZWxmLm5lZ2F0aXZlIF4gbnVtLm5lZ2F0aXZlO1xuICAgIG91dC5sZW5ndGggPSAxOTtcbiAgICAvKiBrID0gMCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsMCwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWwwLCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWgwLCBiaDApO1xuICAgIHZhciB3MCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzAgPj4+IDI2KSkgfCAwO1xuICAgIHcwICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMSAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsMSwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWwxLCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWgxLCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoMSkpIHwgMDtcbiAgICB2YXIgdzEgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxID4+PiAyNikpIHwgMDtcbiAgICB3MSAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDIgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDIsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsMiwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoMiwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmgyKSkgfCAwO1xuICAgIHZhciB3MiA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzIgPj4+IDI2KSkgfCAwO1xuICAgIHcyICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMyAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsMywgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWwzLCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWgzLCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmgzKSkgfCAwO1xuICAgIHZhciB3MyA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzMgPj4+IDI2KSkgfCAwO1xuICAgIHczICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gNCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsNCwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw0LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg0LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoNCkpIHwgMDtcbiAgICB2YXIgdzQgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc0ID4+PiAyNikpIHwgMDtcbiAgICB3NCAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDUgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDUsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsNSwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoNSwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg1KSkgfCAwO1xuICAgIHZhciB3NSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzUgPj4+IDI2KSkgfCAwO1xuICAgIHc1ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gNiAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsNiwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw2LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg2LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg2KSkgfCAwO1xuICAgIHZhciB3NiA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzYgPj4+IDI2KSkgfCAwO1xuICAgIHc2ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gNyAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsNywgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw3LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg3LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoNykpIHwgMDtcbiAgICB2YXIgdzcgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc3ID4+PiAyNikpIHwgMDtcbiAgICB3NyAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDggKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDgsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOCwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOCwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg4KSkgfCAwO1xuICAgIHZhciB3OCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzggPj4+IDI2KSkgfCAwO1xuICAgIHc4ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gOSAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg5KSkgfCAwO1xuICAgIHZhciB3OSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzkgPj4+IDI2KSkgfCAwO1xuICAgIHc5ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTAgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsMSk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmgxKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmwxKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmgxKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg5KSkgfCAwO1xuICAgIHZhciB3MTAgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxMCA+Pj4gMjYpKSB8IDA7XG4gICAgdzEwICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTEgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsMik7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmgyKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmwyKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmgyKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxMSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzExID4+PiAyNikpIHwgMDtcbiAgICB3MTEgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxMiAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwzKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDMpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDMpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDMpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg5KSkgfCAwO1xuICAgIHZhciB3MTIgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxMiA+Pj4gMjYpKSB8IDA7XG4gICAgdzEyICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTMgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsNCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg0KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw0KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg0KTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg5KSkgfCAwO1xuICAgIHZhciB3MTMgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxMyA+Pj4gMjYpKSB8IDA7XG4gICAgdzEzICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTQgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsNSk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg1KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw1KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg1KTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxNCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE0ID4+PiAyNikpIHwgMDtcbiAgICB3MTQgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxNSAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw2KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDYpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDYpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDYpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg5KSkgfCAwO1xuICAgIHZhciB3MTUgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxNSA+Pj4gMjYpKSB8IDA7XG4gICAgdzE1ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTYgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsNyk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg3KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw3KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg3KTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg5KSkgfCAwO1xuICAgIHZhciB3MTYgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxNiA+Pj4gMjYpKSB8IDA7XG4gICAgdzE2ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTcgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsOCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg4KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw4KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg4KTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxNyA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE3ID4+PiAyNikpIHwgMDtcbiAgICB3MTcgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxOCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw5KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDkpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDkpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDkpO1xuICAgIHZhciB3MTggPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxOCA+Pj4gMjYpKSB8IDA7XG4gICAgdzE4ICY9IDB4M2ZmZmZmZjtcbiAgICBvWzBdID0gdzA7XG4gICAgb1sxXSA9IHcxO1xuICAgIG9bMl0gPSB3MjtcbiAgICBvWzNdID0gdzM7XG4gICAgb1s0XSA9IHc0O1xuICAgIG9bNV0gPSB3NTtcbiAgICBvWzZdID0gdzY7XG4gICAgb1s3XSA9IHc3O1xuICAgIG9bOF0gPSB3ODtcbiAgICBvWzldID0gdzk7XG4gICAgb1sxMF0gPSB3MTA7XG4gICAgb1sxMV0gPSB3MTE7XG4gICAgb1sxMl0gPSB3MTI7XG4gICAgb1sxM10gPSB3MTM7XG4gICAgb1sxNF0gPSB3MTQ7XG4gICAgb1sxNV0gPSB3MTU7XG4gICAgb1sxNl0gPSB3MTY7XG4gICAgb1sxN10gPSB3MTc7XG4gICAgb1sxOF0gPSB3MTg7XG4gICAgaWYgKGMgIT09IDApIHtcbiAgICAgIG9bMTldID0gYztcbiAgICAgIG91dC5sZW5ndGgrKztcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfTtcblxuICAvLyBQb2x5ZmlsbCBjb21iXG4gIGlmICghTWF0aC5pbXVsKSB7XG4gICAgY29tYjEwTXVsVG8gPSBzbWFsbE11bFRvO1xuICB9XG5cbiAgZnVuY3Rpb24gYmlnTXVsVG8gKHNlbGYsIG51bSwgb3V0KSB7XG4gICAgb3V0Lm5lZ2F0aXZlID0gbnVtLm5lZ2F0aXZlIF4gc2VsZi5uZWdhdGl2ZTtcbiAgICBvdXQubGVuZ3RoID0gc2VsZi5sZW5ndGggKyBudW0ubGVuZ3RoO1xuXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICB2YXIgaG5jYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBvdXQubGVuZ3RoIC0gMTsgaysrKSB7XG4gICAgICAvLyBTdW0gYWxsIHdvcmRzIHdpdGggdGhlIHNhbWUgYGkgKyBqID0ga2AgYW5kIGFjY3VtdWxhdGUgYG5jYXJyeWAsXG4gICAgICAvLyBub3RlIHRoYXQgbmNhcnJ5IGNvdWxkIGJlID49IDB4M2ZmZmZmZlxuICAgICAgdmFyIG5jYXJyeSA9IGhuY2Fycnk7XG4gICAgICBobmNhcnJ5ID0gMDtcbiAgICAgIHZhciByd29yZCA9IGNhcnJ5ICYgMHgzZmZmZmZmO1xuICAgICAgdmFyIG1heEogPSBNYXRoLm1pbihrLCBudW0ubGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKHZhciBqID0gTWF0aC5tYXgoMCwgayAtIHNlbGYubGVuZ3RoICsgMSk7IGogPD0gbWF4SjsgaisrKSB7XG4gICAgICAgIHZhciBpID0gayAtIGo7XG4gICAgICAgIHZhciBhID0gc2VsZi53b3Jkc1tpXSB8IDA7XG4gICAgICAgIHZhciBiID0gbnVtLndvcmRzW2pdIHwgMDtcbiAgICAgICAgdmFyIHIgPSBhICogYjtcblxuICAgICAgICB2YXIgbG8gPSByICYgMHgzZmZmZmZmO1xuICAgICAgICBuY2FycnkgPSAobmNhcnJ5ICsgKChyIC8gMHg0MDAwMDAwKSB8IDApKSB8IDA7XG4gICAgICAgIGxvID0gKGxvICsgcndvcmQpIHwgMDtcbiAgICAgICAgcndvcmQgPSBsbyAmIDB4M2ZmZmZmZjtcbiAgICAgICAgbmNhcnJ5ID0gKG5jYXJyeSArIChsbyA+Pj4gMjYpKSB8IDA7XG5cbiAgICAgICAgaG5jYXJyeSArPSBuY2FycnkgPj4+IDI2O1xuICAgICAgICBuY2FycnkgJj0gMHgzZmZmZmZmO1xuICAgICAgfVxuICAgICAgb3V0LndvcmRzW2tdID0gcndvcmQ7XG4gICAgICBjYXJyeSA9IG5jYXJyeTtcbiAgICAgIG5jYXJyeSA9IGhuY2Fycnk7XG4gICAgfVxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgb3V0LndvcmRzW2tdID0gY2Fycnk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dC5sZW5ndGgtLTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0LnN0cmlwKCk7XG4gIH1cblxuICBmdW5jdGlvbiBqdW1ib011bFRvIChzZWxmLCBudW0sIG91dCkge1xuICAgIHZhciBmZnRtID0gbmV3IEZGVE0oKTtcbiAgICByZXR1cm4gZmZ0bS5tdWxwKHNlbGYsIG51bSwgb3V0KTtcbiAgfVxuXG4gIEJOLnByb3RvdHlwZS5tdWxUbyA9IGZ1bmN0aW9uIG11bFRvIChudW0sIG91dCkge1xuICAgIHZhciByZXM7XG4gICAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoICsgbnVtLmxlbmd0aDtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEwICYmIG51bS5sZW5ndGggPT09IDEwKSB7XG4gICAgICByZXMgPSBjb21iMTBNdWxUbyh0aGlzLCBudW0sIG91dCk7XG4gICAgfSBlbHNlIGlmIChsZW4gPCA2Mykge1xuICAgICAgcmVzID0gc21hbGxNdWxUbyh0aGlzLCBudW0sIG91dCk7XG4gICAgfSBlbHNlIGlmIChsZW4gPCAxMDI0KSB7XG4gICAgICByZXMgPSBiaWdNdWxUbyh0aGlzLCBudW0sIG91dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcyA9IGp1bWJvTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLy8gQ29vbGV5LVR1a2V5IGFsZ29yaXRobSBmb3IgRkZUXG4gIC8vIHNsaWdodGx5IHJldmlzaXRlZCB0byByZWx5IG9uIGxvb3BpbmcgaW5zdGVhZCBvZiByZWN1cnNpb25cblxuICBmdW5jdGlvbiBGRlRNICh4LCB5KSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICB9XG5cbiAgRkZUTS5wcm90b3R5cGUubWFrZVJCVCA9IGZ1bmN0aW9uIG1ha2VSQlQgKE4pIHtcbiAgICB2YXIgdCA9IG5ldyBBcnJheShOKTtcbiAgICB2YXIgbCA9IEJOLnByb3RvdHlwZS5fY291bnRCaXRzKE4pIC0gMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgdFtpXSA9IHRoaXMucmV2QmluKGksIGwsIE4pO1xuICAgIH1cblxuICAgIHJldHVybiB0O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYmluYXJ5LXJldmVyc2VkIHJlcHJlc2VudGF0aW9uIG9mIGB4YFxuICBGRlRNLnByb3RvdHlwZS5yZXZCaW4gPSBmdW5jdGlvbiByZXZCaW4gKHgsIGwsIE4pIHtcbiAgICBpZiAoeCA9PT0gMCB8fCB4ID09PSBOIC0gMSkgcmV0dXJuIHg7XG5cbiAgICB2YXIgcmIgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICByYiB8PSAoeCAmIDEpIDw8IChsIC0gaSAtIDEpO1xuICAgICAgeCA+Pj0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmI7XG4gIH07XG5cbiAgLy8gUGVyZm9ybXMgXCJ0d2VlZGxpbmdcIiBwaGFzZSwgdGhlcmVmb3JlICdlbXVsYXRpbmcnXG4gIC8vIGJlaGF2aW91ciBvZiB0aGUgcmVjdXJzaXZlIGFsZ29yaXRobVxuICBGRlRNLnByb3RvdHlwZS5wZXJtdXRlID0gZnVuY3Rpb24gcGVybXV0ZSAocmJ0LCByd3MsIGl3cywgcnR3cywgaXR3cywgTikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICBydHdzW2ldID0gcndzW3JidFtpXV07XG4gICAgICBpdHdzW2ldID0gaXdzW3JidFtpXV07XG4gICAgfVxuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uIHRyYW5zZm9ybSAocndzLCBpd3MsIHJ0d3MsIGl0d3MsIE4sIHJidCkge1xuICAgIHRoaXMucGVybXV0ZShyYnQsIHJ3cywgaXdzLCBydHdzLCBpdHdzLCBOKTtcblxuICAgIGZvciAodmFyIHMgPSAxOyBzIDwgTjsgcyA8PD0gMSkge1xuICAgICAgdmFyIGwgPSBzIDw8IDE7XG5cbiAgICAgIHZhciBydHdkZiA9IE1hdGguY29zKDIgKiBNYXRoLlBJIC8gbCk7XG4gICAgICB2YXIgaXR3ZGYgPSBNYXRoLnNpbigyICogTWF0aC5QSSAvIGwpO1xuXG4gICAgICBmb3IgKHZhciBwID0gMDsgcCA8IE47IHAgKz0gbCkge1xuICAgICAgICB2YXIgcnR3ZGZfID0gcnR3ZGY7XG4gICAgICAgIHZhciBpdHdkZl8gPSBpdHdkZjtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHM7IGorKykge1xuICAgICAgICAgIHZhciByZSA9IHJ0d3NbcCArIGpdO1xuICAgICAgICAgIHZhciBpZSA9IGl0d3NbcCArIGpdO1xuXG4gICAgICAgICAgdmFyIHJvID0gcnR3c1twICsgaiArIHNdO1xuICAgICAgICAgIHZhciBpbyA9IGl0d3NbcCArIGogKyBzXTtcblxuICAgICAgICAgIHZhciByeCA9IHJ0d2RmXyAqIHJvIC0gaXR3ZGZfICogaW87XG5cbiAgICAgICAgICBpbyA9IHJ0d2RmXyAqIGlvICsgaXR3ZGZfICogcm87XG4gICAgICAgICAgcm8gPSByeDtcblxuICAgICAgICAgIHJ0d3NbcCArIGpdID0gcmUgKyBybztcbiAgICAgICAgICBpdHdzW3AgKyBqXSA9IGllICsgaW87XG5cbiAgICAgICAgICBydHdzW3AgKyBqICsgc10gPSByZSAtIHJvO1xuICAgICAgICAgIGl0d3NbcCArIGogKyBzXSA9IGllIC0gaW87XG5cbiAgICAgICAgICAvKiBqc2hpbnQgbWF4ZGVwdGggOiBmYWxzZSAqL1xuICAgICAgICAgIGlmIChqICE9PSBsKSB7XG4gICAgICAgICAgICByeCA9IHJ0d2RmICogcnR3ZGZfIC0gaXR3ZGYgKiBpdHdkZl87XG5cbiAgICAgICAgICAgIGl0d2RmXyA9IHJ0d2RmICogaXR3ZGZfICsgaXR3ZGYgKiBydHdkZl87XG4gICAgICAgICAgICBydHdkZl8gPSByeDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUuZ3Vlc3NMZW4xM2IgPSBmdW5jdGlvbiBndWVzc0xlbjEzYiAobiwgbSkge1xuICAgIHZhciBOID0gTWF0aC5tYXgobSwgbikgfCAxO1xuICAgIHZhciBvZGQgPSBOICYgMTtcbiAgICB2YXIgaSA9IDA7XG4gICAgZm9yIChOID0gTiAvIDIgfCAwOyBOOyBOID0gTiA+Pj4gMSkge1xuICAgICAgaSsrO1xuICAgIH1cblxuICAgIHJldHVybiAxIDw8IGkgKyAxICsgb2RkO1xuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLmNvbmp1Z2F0ZSA9IGZ1bmN0aW9uIGNvbmp1Z2F0ZSAocndzLCBpd3MsIE4pIHtcbiAgICBpZiAoTiA8PSAxKSByZXR1cm47XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE4gLyAyOyBpKyspIHtcbiAgICAgIHZhciB0ID0gcndzW2ldO1xuXG4gICAgICByd3NbaV0gPSByd3NbTiAtIGkgLSAxXTtcbiAgICAgIHJ3c1tOIC0gaSAtIDFdID0gdDtcblxuICAgICAgdCA9IGl3c1tpXTtcblxuICAgICAgaXdzW2ldID0gLWl3c1tOIC0gaSAtIDFdO1xuICAgICAgaXdzW04gLSBpIC0gMV0gPSAtdDtcbiAgICB9XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUubm9ybWFsaXplMTNiID0gZnVuY3Rpb24gbm9ybWFsaXplMTNiICh3cywgTikge1xuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOIC8gMjsgaSsrKSB7XG4gICAgICB2YXIgdyA9IE1hdGgucm91bmQod3NbMiAqIGkgKyAxXSAvIE4pICogMHgyMDAwICtcbiAgICAgICAgTWF0aC5yb3VuZCh3c1syICogaV0gLyBOKSArXG4gICAgICAgIGNhcnJ5O1xuXG4gICAgICB3c1tpXSA9IHcgJiAweDNmZmZmZmY7XG5cbiAgICAgIGlmICh3IDwgMHg0MDAwMDAwKSB7XG4gICAgICAgIGNhcnJ5ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhcnJ5ID0gdyAvIDB4NDAwMDAwMCB8IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHdzO1xuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLmNvbnZlcnQxM2IgPSBmdW5jdGlvbiBjb252ZXJ0MTNiICh3cywgbGVuLCByd3MsIE4pIHtcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNhcnJ5ID0gY2FycnkgKyAod3NbaV0gfCAwKTtcblxuICAgICAgcndzWzIgKiBpXSA9IGNhcnJ5ICYgMHgxZmZmOyBjYXJyeSA9IGNhcnJ5ID4+PiAxMztcbiAgICAgIHJ3c1syICogaSArIDFdID0gY2FycnkgJiAweDFmZmY7IGNhcnJ5ID0gY2FycnkgPj4+IDEzO1xuICAgIH1cblxuICAgIC8vIFBhZCB3aXRoIHplcm9lc1xuICAgIGZvciAoaSA9IDIgKiBsZW47IGkgPCBOOyArK2kpIHtcbiAgICAgIHJ3c1tpXSA9IDA7XG4gICAgfVxuXG4gICAgYXNzZXJ0KGNhcnJ5ID09PSAwKTtcbiAgICBhc3NlcnQoKGNhcnJ5ICYgfjB4MWZmZikgPT09IDApO1xuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLnN0dWIgPSBmdW5jdGlvbiBzdHViIChOKSB7XG4gICAgdmFyIHBoID0gbmV3IEFycmF5KE4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICBwaFtpXSA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBoO1xuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLm11bHAgPSBmdW5jdGlvbiBtdWxwICh4LCB5LCBvdXQpIHtcbiAgICB2YXIgTiA9IDIgKiB0aGlzLmd1ZXNzTGVuMTNiKHgubGVuZ3RoLCB5Lmxlbmd0aCk7XG5cbiAgICB2YXIgcmJ0ID0gdGhpcy5tYWtlUkJUKE4pO1xuXG4gICAgdmFyIF8gPSB0aGlzLnN0dWIoTik7XG5cbiAgICB2YXIgcndzID0gbmV3IEFycmF5KE4pO1xuICAgIHZhciByd3N0ID0gbmV3IEFycmF5KE4pO1xuICAgIHZhciBpd3N0ID0gbmV3IEFycmF5KE4pO1xuXG4gICAgdmFyIG5yd3MgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIG5yd3N0ID0gbmV3IEFycmF5KE4pO1xuICAgIHZhciBuaXdzdCA9IG5ldyBBcnJheShOKTtcblxuICAgIHZhciBybXdzID0gb3V0LndvcmRzO1xuICAgIHJtd3MubGVuZ3RoID0gTjtcblxuICAgIHRoaXMuY29udmVydDEzYih4LndvcmRzLCB4Lmxlbmd0aCwgcndzLCBOKTtcbiAgICB0aGlzLmNvbnZlcnQxM2IoeS53b3JkcywgeS5sZW5ndGgsIG5yd3MsIE4pO1xuXG4gICAgdGhpcy50cmFuc2Zvcm0ocndzLCBfLCByd3N0LCBpd3N0LCBOLCByYnQpO1xuICAgIHRoaXMudHJhbnNmb3JtKG5yd3MsIF8sIG5yd3N0LCBuaXdzdCwgTiwgcmJ0KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICB2YXIgcnggPSByd3N0W2ldICogbnJ3c3RbaV0gLSBpd3N0W2ldICogbml3c3RbaV07XG4gICAgICBpd3N0W2ldID0gcndzdFtpXSAqIG5pd3N0W2ldICsgaXdzdFtpXSAqIG5yd3N0W2ldO1xuICAgICAgcndzdFtpXSA9IHJ4O1xuICAgIH1cblxuICAgIHRoaXMuY29uanVnYXRlKHJ3c3QsIGl3c3QsIE4pO1xuICAgIHRoaXMudHJhbnNmb3JtKHJ3c3QsIGl3c3QsIHJtd3MsIF8sIE4sIHJidCk7XG4gICAgdGhpcy5jb25qdWdhdGUocm13cywgXywgTik7XG4gICAgdGhpcy5ub3JtYWxpemUxM2Iocm13cywgTik7XG5cbiAgICBvdXQubmVnYXRpdmUgPSB4Lm5lZ2F0aXZlIF4geS5uZWdhdGl2ZTtcbiAgICBvdXQubGVuZ3RoID0geC5sZW5ndGggKyB5Lmxlbmd0aDtcbiAgICByZXR1cm4gb3V0LnN0cmlwKCk7XG4gIH07XG5cbiAgLy8gTXVsdGlwbHkgYHRoaXNgIGJ5IGBudW1gXG4gIEJOLnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwgKG51bSkge1xuICAgIHZhciBvdXQgPSBuZXcgQk4obnVsbCk7XG4gICAgb3V0LndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoICsgbnVtLmxlbmd0aCk7XG4gICAgcmV0dXJuIHRoaXMubXVsVG8obnVtLCBvdXQpO1xuICB9O1xuXG4gIC8vIE11bHRpcGx5IGVtcGxveWluZyBGRlRcbiAgQk4ucHJvdG90eXBlLm11bGYgPSBmdW5jdGlvbiBtdWxmIChudW0pIHtcbiAgICB2YXIgb3V0ID0gbmV3IEJOKG51bGwpO1xuICAgIG91dC53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCArIG51bS5sZW5ndGgpO1xuICAgIHJldHVybiBqdW1ib011bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgfTtcblxuICAvLyBJbi1wbGFjZSBNdWx0aXBsaWNhdGlvblxuICBCTi5wcm90b3R5cGUuaW11bCA9IGZ1bmN0aW9uIGltdWwgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkubXVsVG8obnVtLCB0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaW11bG4gPSBmdW5jdGlvbiBpbXVsbiAobnVtKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBudW0gPT09ICdudW1iZXInKTtcbiAgICBhc3NlcnQobnVtIDwgMHg0MDAwMDAwKTtcblxuICAgIC8vIENhcnJ5XG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3ID0gKHRoaXMud29yZHNbaV0gfCAwKSAqIG51bTtcbiAgICAgIHZhciBsbyA9ICh3ICYgMHgzZmZmZmZmKSArIChjYXJyeSAmIDB4M2ZmZmZmZik7XG4gICAgICBjYXJyeSA+Pj0gMjY7XG4gICAgICBjYXJyeSArPSAodyAvIDB4NDAwMDAwMCkgfCAwO1xuICAgICAgLy8gTk9URTogbG8gaXMgMjdiaXQgbWF4aW11bVxuICAgICAgY2FycnkgKz0gbG8gPj4+IDI2O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IGxvICYgMHgzZmZmZmZmO1xuICAgIH1cblxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IGNhcnJ5O1xuICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubXVsbiA9IGZ1bmN0aW9uIG11bG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaW11bG4obnVtKTtcbiAgfTtcblxuICAvLyBgdGhpc2AgKiBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLnNxciA9IGZ1bmN0aW9uIHNxciAoKSB7XG4gICAgcmV0dXJuIHRoaXMubXVsKHRoaXMpO1xuICB9O1xuXG4gIC8vIGB0aGlzYCAqIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXNxciA9IGZ1bmN0aW9uIGlzcXIgKCkge1xuICAgIHJldHVybiB0aGlzLmltdWwodGhpcy5jbG9uZSgpKTtcbiAgfTtcblxuICAvLyBNYXRoLnBvdyhgdGhpc2AsIGBudW1gKVxuICBCTi5wcm90b3R5cGUucG93ID0gZnVuY3Rpb24gcG93IChudW0pIHtcbiAgICB2YXIgdyA9IHRvQml0QXJyYXkobnVtKTtcbiAgICBpZiAody5sZW5ndGggPT09IDApIHJldHVybiBuZXcgQk4oMSk7XG5cbiAgICAvLyBTa2lwIGxlYWRpbmcgemVyb2VzXG4gICAgdmFyIHJlcyA9IHRoaXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3Lmxlbmd0aDsgaSsrLCByZXMgPSByZXMuc3FyKCkpIHtcbiAgICAgIGlmICh3W2ldICE9PSAwKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoKytpIDwgdy5sZW5ndGgpIHtcbiAgICAgIGZvciAodmFyIHEgPSByZXMuc3FyKCk7IGkgPCB3Lmxlbmd0aDsgaSsrLCBxID0gcS5zcXIoKSkge1xuICAgICAgICBpZiAod1tpXSA9PT0gMCkgY29udGludWU7XG5cbiAgICAgICAgcmVzID0gcmVzLm11bChxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8vIFNoaWZ0LWxlZnQgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLml1c2hsbiA9IGZ1bmN0aW9uIGl1c2hsbiAoYml0cykge1xuICAgIGFzc2VydCh0eXBlb2YgYml0cyA9PT0gJ251bWJlcicgJiYgYml0cyA+PSAwKTtcbiAgICB2YXIgciA9IGJpdHMgJSAyNjtcbiAgICB2YXIgcyA9IChiaXRzIC0gcikgLyAyNjtcbiAgICB2YXIgY2FycnlNYXNrID0gKDB4M2ZmZmZmZiA+Pj4gKDI2IC0gcikpIDw8ICgyNiAtIHIpO1xuICAgIHZhciBpO1xuXG4gICAgaWYgKHIgIT09IDApIHtcbiAgICAgIHZhciBjYXJyeSA9IDA7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBuZXdDYXJyeSA9IHRoaXMud29yZHNbaV0gJiBjYXJyeU1hc2s7XG4gICAgICAgIHZhciBjID0gKCh0aGlzLndvcmRzW2ldIHwgMCkgLSBuZXdDYXJyeSkgPDwgcjtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGMgfCBjYXJyeTtcbiAgICAgICAgY2FycnkgPSBuZXdDYXJyeSA+Pj4gKDI2IC0gcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChjYXJyeSkge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gY2Fycnk7XG4gICAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHMgIT09IDApIHtcbiAgICAgIGZvciAoaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpICsgc10gPSB0aGlzLndvcmRzW2ldO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSAwO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxlbmd0aCArPSBzO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzaGxuID0gZnVuY3Rpb24gaXNobG4gKGJpdHMpIHtcbiAgICAvLyBUT0RPKGluZHV0bnkpOiBpbXBsZW1lbnQgbWVcbiAgICBhc3NlcnQodGhpcy5uZWdhdGl2ZSA9PT0gMCk7XG4gICAgcmV0dXJuIHRoaXMuaXVzaGxuKGJpdHMpO1xuICB9O1xuXG4gIC8vIFNoaWZ0LXJpZ2h0IGluLXBsYWNlXG4gIC8vIE5PVEU6IGBoaW50YCBpcyBhIGxvd2VzdCBiaXQgYmVmb3JlIHRyYWlsaW5nIHplcm9lc1xuICAvLyBOT1RFOiBpZiBgZXh0ZW5kZWRgIGlzIHByZXNlbnQgLSBpdCB3aWxsIGJlIGZpbGxlZCB3aXRoIGRlc3Ryb3llZCBiaXRzXG4gIEJOLnByb3RvdHlwZS5pdXNocm4gPSBmdW5jdGlvbiBpdXNocm4gKGJpdHMsIGhpbnQsIGV4dGVuZGVkKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXRzID09PSAnbnVtYmVyJyAmJiBiaXRzID49IDApO1xuICAgIHZhciBoO1xuICAgIGlmIChoaW50KSB7XG4gICAgICBoID0gKGhpbnQgLSAoaGludCAlIDI2KSkgLyAyNjtcbiAgICB9IGVsc2Uge1xuICAgICAgaCA9IDA7XG4gICAgfVxuXG4gICAgdmFyIHIgPSBiaXRzICUgMjY7XG4gICAgdmFyIHMgPSBNYXRoLm1pbigoYml0cyAtIHIpIC8gMjYsIHRoaXMubGVuZ3RoKTtcbiAgICB2YXIgbWFzayA9IDB4M2ZmZmZmZiBeICgoMHgzZmZmZmZmID4+PiByKSA8PCByKTtcbiAgICB2YXIgbWFza2VkV29yZHMgPSBleHRlbmRlZDtcblxuICAgIGggLT0gcztcbiAgICBoID0gTWF0aC5tYXgoMCwgaCk7XG5cbiAgICAvLyBFeHRlbmRlZCBtb2RlLCBjb3B5IG1hc2tlZCBwYXJ0XG4gICAgaWYgKG1hc2tlZFdvcmRzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuICAgICAgICBtYXNrZWRXb3Jkcy53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV07XG4gICAgICB9XG4gICAgICBtYXNrZWRXb3Jkcy5sZW5ndGggPSBzO1xuICAgIH1cblxuICAgIGlmIChzID09PSAwKSB7XG4gICAgICAvLyBOby1vcCwgd2Ugc2hvdWxkIG5vdCBtb3ZlIGFueXRoaW5nIGF0IGFsbFxuICAgIH0gZWxzZSBpZiAodGhpcy5sZW5ndGggPiBzKSB7XG4gICAgICB0aGlzLmxlbmd0aCAtPSBzO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IHRoaXMud29yZHNbaSArIHNdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndvcmRzWzBdID0gMDtcbiAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICB9XG5cbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAoaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwICYmIChjYXJyeSAhPT0gMCB8fCBpID49IGgpOyBpLS0pIHtcbiAgICAgIHZhciB3b3JkID0gdGhpcy53b3Jkc1tpXSB8IDA7XG4gICAgICB0aGlzLndvcmRzW2ldID0gKGNhcnJ5IDw8ICgyNiAtIHIpKSB8ICh3b3JkID4+PiByKTtcbiAgICAgIGNhcnJ5ID0gd29yZCAmIG1hc2s7XG4gICAgfVxuXG4gICAgLy8gUHVzaCBjYXJyaWVkIGJpdHMgYXMgYSBtYXNrXG4gICAgaWYgKG1hc2tlZFdvcmRzICYmIGNhcnJ5ICE9PSAwKSB7XG4gICAgICBtYXNrZWRXb3Jkcy53b3Jkc1ttYXNrZWRXb3Jkcy5sZW5ndGgrK10gPSBjYXJyeTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMud29yZHNbMF0gPSAwO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzaHJuID0gZnVuY3Rpb24gaXNocm4gKGJpdHMsIGhpbnQsIGV4dGVuZGVkKSB7XG4gICAgLy8gVE9ETyhpbmR1dG55KTogaW1wbGVtZW50IG1lXG4gICAgYXNzZXJ0KHRoaXMubmVnYXRpdmUgPT09IDApO1xuICAgIHJldHVybiB0aGlzLml1c2hybihiaXRzLCBoaW50LCBleHRlbmRlZCk7XG4gIH07XG5cbiAgLy8gU2hpZnQtbGVmdFxuICBCTi5wcm90b3R5cGUuc2hsbiA9IGZ1bmN0aW9uIHNobG4gKGJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzaGxuKGJpdHMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51c2hsbiA9IGZ1bmN0aW9uIHVzaGxuIChiaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdXNobG4oYml0cyk7XG4gIH07XG5cbiAgLy8gU2hpZnQtcmlnaHRcbiAgQk4ucHJvdG90eXBlLnNocm4gPSBmdW5jdGlvbiBzaHJuIChiaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc2hybihiaXRzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudXNocm4gPSBmdW5jdGlvbiB1c2hybiAoYml0cykge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXVzaHJuKGJpdHMpO1xuICB9O1xuXG4gIC8vIFRlc3QgaWYgbiBiaXQgaXMgc2V0XG4gIEJOLnByb3RvdHlwZS50ZXN0biA9IGZ1bmN0aW9uIHRlc3RuIChiaXQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdCA9PT0gJ251bWJlcicgJiYgYml0ID49IDApO1xuICAgIHZhciByID0gYml0ICUgMjY7XG4gICAgdmFyIHMgPSAoYml0IC0gcikgLyAyNjtcbiAgICB2YXIgcSA9IDEgPDwgcjtcblxuICAgIC8vIEZhc3QgY2FzZTogYml0IGlzIG11Y2ggaGlnaGVyIHRoYW4gYWxsIGV4aXN0aW5nIHdvcmRzXG4gICAgaWYgKHRoaXMubGVuZ3RoIDw9IHMpIHJldHVybiBmYWxzZTtcblxuICAgIC8vIENoZWNrIGJpdCBhbmQgcmV0dXJuXG4gICAgdmFyIHcgPSB0aGlzLndvcmRzW3NdO1xuXG4gICAgcmV0dXJuICEhKHcgJiBxKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gb25seSBsb3dlcnMgYml0cyBvZiBudW1iZXIgKGluLXBsYWNlKVxuICBCTi5wcm90b3R5cGUuaW1hc2tuID0gZnVuY3Rpb24gaW1hc2tuIChiaXRzKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXRzID09PSAnbnVtYmVyJyAmJiBiaXRzID49IDApO1xuICAgIHZhciByID0gYml0cyAlIDI2O1xuICAgIHZhciBzID0gKGJpdHMgLSByKSAvIDI2O1xuXG4gICAgYXNzZXJ0KHRoaXMubmVnYXRpdmUgPT09IDAsICdpbWFza24gd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlIG51bWJlcnMnKTtcblxuICAgIGlmICh0aGlzLmxlbmd0aCA8PSBzKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAociAhPT0gMCkge1xuICAgICAgcysrO1xuICAgIH1cbiAgICB0aGlzLmxlbmd0aCA9IE1hdGgubWluKHMsIHRoaXMubGVuZ3RoKTtcblxuICAgIGlmIChyICE9PSAwKSB7XG4gICAgICB2YXIgbWFzayA9IDB4M2ZmZmZmZiBeICgoMHgzZmZmZmZmID4+PiByKSA8PCByKTtcbiAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGggLSAxXSAmPSBtYXNrO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIG9ubHkgbG93ZXJzIGJpdHMgb2YgbnVtYmVyXG4gIEJOLnByb3RvdHlwZS5tYXNrbiA9IGZ1bmN0aW9uIG1hc2tuIChiaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbWFza24oYml0cyk7XG4gIH07XG5cbiAgLy8gQWRkIHBsYWluIG51bWJlciBgbnVtYCB0byBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLmlhZGRuID0gZnVuY3Rpb24gaWFkZG4gKG51bSkge1xuICAgIGFzc2VydCh0eXBlb2YgbnVtID09PSAnbnVtYmVyJyk7XG4gICAgYXNzZXJ0KG51bSA8IDB4NDAwMDAwMCk7XG4gICAgaWYgKG51bSA8IDApIHJldHVybiB0aGlzLmlzdWJuKC1udW0pO1xuXG4gICAgLy8gUG9zc2libGUgc2lnbiBjaGFuZ2VcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAxICYmICh0aGlzLndvcmRzWzBdIHwgMCkgPCBudW0pIHtcbiAgICAgICAgdGhpcy53b3Jkc1swXSA9IG51bSAtICh0aGlzLndvcmRzWzBdIHwgMCk7XG4gICAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICB0aGlzLmlzdWJuKG51bSk7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZCB3aXRob3V0IGNoZWNrc1xuICAgIHJldHVybiB0aGlzLl9pYWRkbihudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5faWFkZG4gPSBmdW5jdGlvbiBfaWFkZG4gKG51bSkge1xuICAgIHRoaXMud29yZHNbMF0gKz0gbnVtO1xuXG4gICAgLy8gQ2FycnlcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoICYmIHRoaXMud29yZHNbaV0gPj0gMHg0MDAwMDAwOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gLT0gMHg0MDAwMDAwO1xuICAgICAgaWYgKGkgPT09IHRoaXMubGVuZ3RoIC0gMSkge1xuICAgICAgICB0aGlzLndvcmRzW2kgKyAxXSA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLndvcmRzW2kgKyAxXSsrO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmxlbmd0aCA9IE1hdGgubWF4KHRoaXMubGVuZ3RoLCBpICsgMSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBTdWJ0cmFjdCBwbGFpbiBudW1iZXIgYG51bWAgZnJvbSBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLmlzdWJuID0gZnVuY3Rpb24gaXN1Ym4gKG51bSkge1xuICAgIGFzc2VydCh0eXBlb2YgbnVtID09PSAnbnVtYmVyJyk7XG4gICAgYXNzZXJ0KG51bSA8IDB4NDAwMDAwMCk7XG4gICAgaWYgKG51bSA8IDApIHJldHVybiB0aGlzLmlhZGRuKC1udW0pO1xuXG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgdGhpcy5pYWRkbihudW0pO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB0aGlzLndvcmRzWzBdIC09IG51bTtcblxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLndvcmRzWzBdIDwgMCkge1xuICAgICAgdGhpcy53b3Jkc1swXSA9IC10aGlzLndvcmRzWzBdO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENhcnJ5XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoICYmIHRoaXMud29yZHNbaV0gPCAwOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSArPSAweDQwMDAwMDA7XG4gICAgICAgIHRoaXMud29yZHNbaSArIDFdIC09IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuYWRkbiA9IGZ1bmN0aW9uIGFkZG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaWFkZG4obnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuc3VibiA9IGZ1bmN0aW9uIHN1Ym4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXN1Ym4obnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaWFicyA9IGZ1bmN0aW9uIGlhYnMgKCkge1xuICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmFicyA9IGZ1bmN0aW9uIGFicyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYWJzKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pc2hsbnN1Ym11bCA9IGZ1bmN0aW9uIF9pc2hsbnN1Ym11bCAobnVtLCBtdWwsIHNoaWZ0KSB7XG4gICAgdmFyIGxlbiA9IG51bS5sZW5ndGggKyBzaGlmdDtcbiAgICB2YXIgaTtcblxuICAgIHRoaXMuX2V4cGFuZChsZW4pO1xuXG4gICAgdmFyIHc7XG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG4gICAgICB3ID0gKHRoaXMud29yZHNbaSArIHNoaWZ0XSB8IDApICsgY2Fycnk7XG4gICAgICB2YXIgcmlnaHQgPSAobnVtLndvcmRzW2ldIHwgMCkgKiBtdWw7XG4gICAgICB3IC09IHJpZ2h0ICYgMHgzZmZmZmZmO1xuICAgICAgY2FycnkgPSAodyA+PiAyNikgLSAoKHJpZ2h0IC8gMHg0MDAwMDAwKSB8IDApO1xuICAgICAgdGhpcy53b3Jkc1tpICsgc2hpZnRdID0gdyAmIDB4M2ZmZmZmZjtcbiAgICB9XG4gICAgZm9yICg7IGkgPCB0aGlzLmxlbmd0aCAtIHNoaWZ0OyBpKyspIHtcbiAgICAgIHcgPSAodGhpcy53b3Jkc1tpICsgc2hpZnRdIHwgMCkgKyBjYXJyeTtcbiAgICAgIGNhcnJ5ID0gdyA+PiAyNjtcbiAgICAgIHRoaXMud29yZHNbaSArIHNoaWZ0XSA9IHcgJiAweDNmZmZmZmY7XG4gICAgfVxuXG4gICAgaWYgKGNhcnJ5ID09PSAwKSByZXR1cm4gdGhpcy5zdHJpcCgpO1xuXG4gICAgLy8gU3VidHJhY3Rpb24gb3ZlcmZsb3dcbiAgICBhc3NlcnQoY2FycnkgPT09IC0xKTtcbiAgICBjYXJyeSA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHcgPSAtKHRoaXMud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgICAgY2FycnkgPSB3ID4+IDI2O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHcgJiAweDNmZmZmZmY7XG4gICAgfVxuICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX3dvcmREaXYgPSBmdW5jdGlvbiBfd29yZERpdiAobnVtLCBtb2RlKSB7XG4gICAgdmFyIHNoaWZ0ID0gdGhpcy5sZW5ndGggLSBudW0ubGVuZ3RoO1xuXG4gICAgdmFyIGEgPSB0aGlzLmNsb25lKCk7XG4gICAgdmFyIGIgPSBudW07XG5cbiAgICAvLyBOb3JtYWxpemVcbiAgICB2YXIgYmhpID0gYi53b3Jkc1tiLmxlbmd0aCAtIDFdIHwgMDtcbiAgICB2YXIgYmhpQml0cyA9IHRoaXMuX2NvdW50Qml0cyhiaGkpO1xuICAgIHNoaWZ0ID0gMjYgLSBiaGlCaXRzO1xuICAgIGlmIChzaGlmdCAhPT0gMCkge1xuICAgICAgYiA9IGIudXNobG4oc2hpZnQpO1xuICAgICAgYS5pdXNobG4oc2hpZnQpO1xuICAgICAgYmhpID0gYi53b3Jkc1tiLmxlbmd0aCAtIDFdIHwgMDtcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXplIHF1b3RpZW50XG4gICAgdmFyIG0gPSBhLmxlbmd0aCAtIGIubGVuZ3RoO1xuICAgIHZhciBxO1xuXG4gICAgaWYgKG1vZGUgIT09ICdtb2QnKSB7XG4gICAgICBxID0gbmV3IEJOKG51bGwpO1xuICAgICAgcS5sZW5ndGggPSBtICsgMTtcbiAgICAgIHEud29yZHMgPSBuZXcgQXJyYXkocS5sZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHEud29yZHNbaV0gPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkaWZmID0gYS5jbG9uZSgpLl9pc2hsbnN1Ym11bChiLCAxLCBtKTtcbiAgICBpZiAoZGlmZi5uZWdhdGl2ZSA9PT0gMCkge1xuICAgICAgYSA9IGRpZmY7XG4gICAgICBpZiAocSkge1xuICAgICAgICBxLndvcmRzW21dID0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBqID0gbSAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICB2YXIgcWogPSAoYS53b3Jkc1tiLmxlbmd0aCArIGpdIHwgMCkgKiAweDQwMDAwMDAgK1xuICAgICAgICAoYS53b3Jkc1tiLmxlbmd0aCArIGogLSAxXSB8IDApO1xuXG4gICAgICAvLyBOT1RFOiAocWogLyBiaGkpIGlzICgweDNmZmZmZmYgKiAweDQwMDAwMDAgKyAweDNmZmZmZmYpIC8gMHgyMDAwMDAwIG1heFxuICAgICAgLy8gKDB4N2ZmZmZmZilcbiAgICAgIHFqID0gTWF0aC5taW4oKHFqIC8gYmhpKSB8IDAsIDB4M2ZmZmZmZik7XG5cbiAgICAgIGEuX2lzaGxuc3VibXVsKGIsIHFqLCBqKTtcbiAgICAgIHdoaWxlIChhLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgIHFqLS07XG4gICAgICAgIGEubmVnYXRpdmUgPSAwO1xuICAgICAgICBhLl9pc2hsbnN1Ym11bChiLCAxLCBqKTtcbiAgICAgICAgaWYgKCFhLmlzWmVybygpKSB7XG4gICAgICAgICAgYS5uZWdhdGl2ZSBePSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocSkge1xuICAgICAgICBxLndvcmRzW2pdID0gcWo7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChxKSB7XG4gICAgICBxLnN0cmlwKCk7XG4gICAgfVxuICAgIGEuc3RyaXAoKTtcblxuICAgIC8vIERlbm9ybWFsaXplXG4gICAgaWYgKG1vZGUgIT09ICdkaXYnICYmIHNoaWZ0ICE9PSAwKSB7XG4gICAgICBhLml1c2hybihzaGlmdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRpdjogcSB8fCBudWxsLFxuICAgICAgbW9kOiBhXG4gICAgfTtcbiAgfTtcblxuICAvLyBOT1RFOiAxKSBgbW9kZWAgY2FuIGJlIHNldCB0byBgbW9kYCB0byByZXF1ZXN0IG1vZCBvbmx5LFxuICAvLyAgICAgICB0byBgZGl2YCB0byByZXF1ZXN0IGRpdiBvbmx5LCBvciBiZSBhYnNlbnQgdG9cbiAgLy8gICAgICAgcmVxdWVzdCBib3RoIGRpdiAmIG1vZFxuICAvLyAgICAgICAyKSBgcG9zaXRpdmVgIGlzIHRydWUgaWYgdW5zaWduZWQgbW9kIGlzIHJlcXVlc3RlZFxuICBCTi5wcm90b3R5cGUuZGl2bW9kID0gZnVuY3Rpb24gZGl2bW9kIChudW0sIG1vZGUsIHBvc2l0aXZlKSB7XG4gICAgYXNzZXJ0KCFudW0uaXNaZXJvKCkpO1xuXG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogbmV3IEJOKDApLFxuICAgICAgICBtb2Q6IG5ldyBCTigwKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgZGl2LCBtb2QsIHJlcztcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiBudW0ubmVnYXRpdmUgPT09IDApIHtcbiAgICAgIHJlcyA9IHRoaXMubmVnKCkuZGl2bW9kKG51bSwgbW9kZSk7XG5cbiAgICAgIGlmIChtb2RlICE9PSAnbW9kJykge1xuICAgICAgICBkaXYgPSByZXMuZGl2Lm5lZygpO1xuICAgICAgfVxuXG4gICAgICBpZiAobW9kZSAhPT0gJ2RpdicpIHtcbiAgICAgICAgbW9kID0gcmVzLm1vZC5uZWcoKTtcbiAgICAgICAgaWYgKHBvc2l0aXZlICYmIG1vZC5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICAgIG1vZC5pYWRkKG51bSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiBkaXYsXG4gICAgICAgIG1vZDogbW9kXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICh0aGlzLm5lZ2F0aXZlID09PSAwICYmIG51bS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgcmVzID0gdGhpcy5kaXZtb2QobnVtLm5lZygpLCBtb2RlKTtcblxuICAgICAgaWYgKG1vZGUgIT09ICdtb2QnKSB7XG4gICAgICAgIGRpdiA9IHJlcy5kaXYubmVnKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogZGl2LFxuICAgICAgICBtb2Q6IHJlcy5tb2RcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCh0aGlzLm5lZ2F0aXZlICYgbnVtLm5lZ2F0aXZlKSAhPT0gMCkge1xuICAgICAgcmVzID0gdGhpcy5uZWcoKS5kaXZtb2QobnVtLm5lZygpLCBtb2RlKTtcblxuICAgICAgaWYgKG1vZGUgIT09ICdkaXYnKSB7XG4gICAgICAgIG1vZCA9IHJlcy5tb2QubmVnKCk7XG4gICAgICAgIGlmIChwb3NpdGl2ZSAmJiBtb2QubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgICBtb2QuaXN1YihudW0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogcmVzLmRpdixcbiAgICAgICAgbW9kOiBtb2RcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQm90aCBudW1iZXJzIGFyZSBwb3NpdGl2ZSBhdCB0aGlzIHBvaW50XG5cbiAgICAvLyBTdHJpcCBib3RoIG51bWJlcnMgdG8gYXBwcm94aW1hdGUgc2hpZnQgdmFsdWVcbiAgICBpZiAobnVtLmxlbmd0aCA+IHRoaXMubGVuZ3RoIHx8IHRoaXMuY21wKG51bSkgPCAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IG5ldyBCTigwKSxcbiAgICAgICAgbW9kOiB0aGlzXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIFZlcnkgc2hvcnQgcmVkdWN0aW9uXG4gICAgaWYgKG51bS5sZW5ndGggPT09IDEpIHtcbiAgICAgIGlmIChtb2RlID09PSAnZGl2Jykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRpdjogdGhpcy5kaXZuKG51bS53b3Jkc1swXSksXG4gICAgICAgICAgbW9kOiBudWxsXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChtb2RlID09PSAnbW9kJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRpdjogbnVsbCxcbiAgICAgICAgICBtb2Q6IG5ldyBCTih0aGlzLm1vZG4obnVtLndvcmRzWzBdKSlcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiB0aGlzLmRpdm4obnVtLndvcmRzWzBdKSxcbiAgICAgICAgbW9kOiBuZXcgQk4odGhpcy5tb2RuKG51bS53b3Jkc1swXSkpXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl93b3JkRGl2KG51bSwgbW9kZSk7XG4gIH07XG5cbiAgLy8gRmluZCBgdGhpc2AgLyBgbnVtYFxuICBCTi5wcm90b3R5cGUuZGl2ID0gZnVuY3Rpb24gZGl2IChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5kaXZtb2QobnVtLCAnZGl2JywgZmFsc2UpLmRpdjtcbiAgfTtcblxuICAvLyBGaW5kIGB0aGlzYCAlIGBudW1gXG4gIEJOLnByb3RvdHlwZS5tb2QgPSBmdW5jdGlvbiBtb2QgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmRpdm1vZChudW0sICdtb2QnLCBmYWxzZSkubW9kO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51bW9kID0gZnVuY3Rpb24gdW1vZCAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2bW9kKG51bSwgJ21vZCcsIHRydWUpLm1vZDtcbiAgfTtcblxuICAvLyBGaW5kIFJvdW5kKGB0aGlzYCAvIGBudW1gKVxuICBCTi5wcm90b3R5cGUuZGl2Um91bmQgPSBmdW5jdGlvbiBkaXZSb3VuZCAobnVtKSB7XG4gICAgdmFyIGRtID0gdGhpcy5kaXZtb2QobnVtKTtcblxuICAgIC8vIEZhc3QgY2FzZSAtIGV4YWN0IGRpdmlzaW9uXG4gICAgaWYgKGRtLm1vZC5pc1plcm8oKSkgcmV0dXJuIGRtLmRpdjtcblxuICAgIHZhciBtb2QgPSBkbS5kaXYubmVnYXRpdmUgIT09IDAgPyBkbS5tb2QuaXN1YihudW0pIDogZG0ubW9kO1xuXG4gICAgdmFyIGhhbGYgPSBudW0udXNocm4oMSk7XG4gICAgdmFyIHIyID0gbnVtLmFuZGxuKDEpO1xuICAgIHZhciBjbXAgPSBtb2QuY21wKGhhbGYpO1xuXG4gICAgLy8gUm91bmQgZG93blxuICAgIGlmIChjbXAgPCAwIHx8IHIyID09PSAxICYmIGNtcCA9PT0gMCkgcmV0dXJuIGRtLmRpdjtcblxuICAgIC8vIFJvdW5kIHVwXG4gICAgcmV0dXJuIGRtLmRpdi5uZWdhdGl2ZSAhPT0gMCA/IGRtLmRpdi5pc3VibigxKSA6IGRtLmRpdi5pYWRkbigxKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubW9kbiA9IGZ1bmN0aW9uIG1vZG4gKG51bSkge1xuICAgIGFzc2VydChudW0gPD0gMHgzZmZmZmZmKTtcbiAgICB2YXIgcCA9ICgxIDw8IDI2KSAlIG51bTtcblxuICAgIHZhciBhY2MgPSAwO1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBhY2MgPSAocCAqIGFjYyArICh0aGlzLndvcmRzW2ldIHwgMCkpICUgbnVtO1xuICAgIH1cblxuICAgIHJldHVybiBhY2M7XG4gIH07XG5cbiAgLy8gSW4tcGxhY2UgZGl2aXNpb24gYnkgbnVtYmVyXG4gIEJOLnByb3RvdHlwZS5pZGl2biA9IGZ1bmN0aW9uIGlkaXZuIChudW0pIHtcbiAgICBhc3NlcnQobnVtIDw9IDB4M2ZmZmZmZik7XG5cbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgdyA9ICh0aGlzLndvcmRzW2ldIHwgMCkgKyBjYXJyeSAqIDB4NDAwMDAwMDtcbiAgICAgIHRoaXMud29yZHNbaV0gPSAodyAvIG51bSkgfCAwO1xuICAgICAgY2FycnkgPSB3ICUgbnVtO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmRpdm4gPSBmdW5jdGlvbiBkaXZuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlkaXZuKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmVnY2QgPSBmdW5jdGlvbiBlZ2NkIChwKSB7XG4gICAgYXNzZXJ0KHAubmVnYXRpdmUgPT09IDApO1xuICAgIGFzc2VydCghcC5pc1plcm8oKSk7XG5cbiAgICB2YXIgeCA9IHRoaXM7XG4gICAgdmFyIHkgPSBwLmNsb25lKCk7XG5cbiAgICBpZiAoeC5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgeCA9IHgudW1vZChwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IHguY2xvbmUoKTtcbiAgICB9XG5cbiAgICAvLyBBICogeCArIEIgKiB5ID0geFxuICAgIHZhciBBID0gbmV3IEJOKDEpO1xuICAgIHZhciBCID0gbmV3IEJOKDApO1xuXG4gICAgLy8gQyAqIHggKyBEICogeSA9IHlcbiAgICB2YXIgQyA9IG5ldyBCTigwKTtcbiAgICB2YXIgRCA9IG5ldyBCTigxKTtcblxuICAgIHZhciBnID0gMDtcblxuICAgIHdoaWxlICh4LmlzRXZlbigpICYmIHkuaXNFdmVuKCkpIHtcbiAgICAgIHguaXVzaHJuKDEpO1xuICAgICAgeS5pdXNocm4oMSk7XG4gICAgICArK2c7XG4gICAgfVxuXG4gICAgdmFyIHlwID0geS5jbG9uZSgpO1xuICAgIHZhciB4cCA9IHguY2xvbmUoKTtcblxuICAgIHdoaWxlICgheC5pc1plcm8oKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGltID0gMTsgKHgud29yZHNbMF0gJiBpbSkgPT09IDAgJiYgaSA8IDI2OyArK2ksIGltIDw8PSAxKTtcbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICB4Lml1c2hybihpKTtcbiAgICAgICAgd2hpbGUgKGktLSA+IDApIHtcbiAgICAgICAgICBpZiAoQS5pc09kZCgpIHx8IEIuaXNPZGQoKSkge1xuICAgICAgICAgICAgQS5pYWRkKHlwKTtcbiAgICAgICAgICAgIEIuaXN1Yih4cCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgQS5pdXNocm4oMSk7XG4gICAgICAgICAgQi5pdXNocm4oMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaiA9IDAsIGptID0gMTsgKHkud29yZHNbMF0gJiBqbSkgPT09IDAgJiYgaiA8IDI2OyArK2osIGptIDw8PSAxKTtcbiAgICAgIGlmIChqID4gMCkge1xuICAgICAgICB5Lml1c2hybihqKTtcbiAgICAgICAgd2hpbGUgKGotLSA+IDApIHtcbiAgICAgICAgICBpZiAoQy5pc09kZCgpIHx8IEQuaXNPZGQoKSkge1xuICAgICAgICAgICAgQy5pYWRkKHlwKTtcbiAgICAgICAgICAgIEQuaXN1Yih4cCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgQy5pdXNocm4oMSk7XG4gICAgICAgICAgRC5pdXNocm4oMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHguY21wKHkpID49IDApIHtcbiAgICAgICAgeC5pc3ViKHkpO1xuICAgICAgICBBLmlzdWIoQyk7XG4gICAgICAgIEIuaXN1YihEKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHkuaXN1Yih4KTtcbiAgICAgICAgQy5pc3ViKEEpO1xuICAgICAgICBELmlzdWIoQik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGE6IEMsXG4gICAgICBiOiBELFxuICAgICAgZ2NkOiB5Lml1c2hsbihnKVxuICAgIH07XG4gIH07XG5cbiAgLy8gVGhpcyBpcyByZWR1Y2VkIGluY2FybmF0aW9uIG9mIHRoZSBiaW5hcnkgRUVBXG4gIC8vIGFib3ZlLCBkZXNpZ25hdGVkIHRvIGludmVydCBtZW1iZXJzIG9mIHRoZVxuICAvLyBfcHJpbWVfIGZpZWxkcyBGKHApIGF0IGEgbWF4aW1hbCBzcGVlZFxuICBCTi5wcm90b3R5cGUuX2ludm1wID0gZnVuY3Rpb24gX2ludm1wIChwKSB7XG4gICAgYXNzZXJ0KHAubmVnYXRpdmUgPT09IDApO1xuICAgIGFzc2VydCghcC5pc1plcm8oKSk7XG5cbiAgICB2YXIgYSA9IHRoaXM7XG4gICAgdmFyIGIgPSBwLmNsb25lKCk7XG5cbiAgICBpZiAoYS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgYSA9IGEudW1vZChwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYSA9IGEuY2xvbmUoKTtcbiAgICB9XG5cbiAgICB2YXIgeDEgPSBuZXcgQk4oMSk7XG4gICAgdmFyIHgyID0gbmV3IEJOKDApO1xuXG4gICAgdmFyIGRlbHRhID0gYi5jbG9uZSgpO1xuXG4gICAgd2hpbGUgKGEuY21wbigxKSA+IDAgJiYgYi5jbXBuKDEpID4gMCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGltID0gMTsgKGEud29yZHNbMF0gJiBpbSkgPT09IDAgJiYgaSA8IDI2OyArK2ksIGltIDw8PSAxKTtcbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICBhLml1c2hybihpKTtcbiAgICAgICAgd2hpbGUgKGktLSA+IDApIHtcbiAgICAgICAgICBpZiAoeDEuaXNPZGQoKSkge1xuICAgICAgICAgICAgeDEuaWFkZChkZWx0YSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgeDEuaXVzaHJuKDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGogPSAwLCBqbSA9IDE7IChiLndvcmRzWzBdICYgam0pID09PSAwICYmIGogPCAyNjsgKytqLCBqbSA8PD0gMSk7XG4gICAgICBpZiAoaiA+IDApIHtcbiAgICAgICAgYi5pdXNocm4oaik7XG4gICAgICAgIHdoaWxlIChqLS0gPiAwKSB7XG4gICAgICAgICAgaWYgKHgyLmlzT2RkKCkpIHtcbiAgICAgICAgICAgIHgyLmlhZGQoZGVsdGEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHgyLml1c2hybigxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYS5jbXAoYikgPj0gMCkge1xuICAgICAgICBhLmlzdWIoYik7XG4gICAgICAgIHgxLmlzdWIoeDIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYi5pc3ViKGEpO1xuICAgICAgICB4Mi5pc3ViKHgxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVzO1xuICAgIGlmIChhLmNtcG4oMSkgPT09IDApIHtcbiAgICAgIHJlcyA9IHgxO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXMgPSB4MjtcbiAgICB9XG5cbiAgICBpZiAocmVzLmNtcG4oMCkgPCAwKSB7XG4gICAgICByZXMuaWFkZChwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5nY2QgPSBmdW5jdGlvbiBnY2QgKG51bSkge1xuICAgIGlmICh0aGlzLmlzWmVybygpKSByZXR1cm4gbnVtLmFicygpO1xuICAgIGlmIChudW0uaXNaZXJvKCkpIHJldHVybiB0aGlzLmFicygpO1xuXG4gICAgdmFyIGEgPSB0aGlzLmNsb25lKCk7XG4gICAgdmFyIGIgPSBudW0uY2xvbmUoKTtcbiAgICBhLm5lZ2F0aXZlID0gMDtcbiAgICBiLm5lZ2F0aXZlID0gMDtcblxuICAgIC8vIFJlbW92ZSBjb21tb24gZmFjdG9yIG9mIHR3b1xuICAgIGZvciAodmFyIHNoaWZ0ID0gMDsgYS5pc0V2ZW4oKSAmJiBiLmlzRXZlbigpOyBzaGlmdCsrKSB7XG4gICAgICBhLml1c2hybigxKTtcbiAgICAgIGIuaXVzaHJuKDEpO1xuICAgIH1cblxuICAgIGRvIHtcbiAgICAgIHdoaWxlIChhLmlzRXZlbigpKSB7XG4gICAgICAgIGEuaXVzaHJuKDEpO1xuICAgICAgfVxuICAgICAgd2hpbGUgKGIuaXNFdmVuKCkpIHtcbiAgICAgICAgYi5pdXNocm4oMSk7XG4gICAgICB9XG5cbiAgICAgIHZhciByID0gYS5jbXAoYik7XG4gICAgICBpZiAociA8IDApIHtcbiAgICAgICAgLy8gU3dhcCBgYWAgYW5kIGBiYCB0byBtYWtlIGBhYCBhbHdheXMgYmlnZ2VyIHRoYW4gYGJgXG4gICAgICAgIHZhciB0ID0gYTtcbiAgICAgICAgYSA9IGI7XG4gICAgICAgIGIgPSB0O1xuICAgICAgfSBlbHNlIGlmIChyID09PSAwIHx8IGIuY21wbigxKSA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgYS5pc3ViKGIpO1xuICAgIH0gd2hpbGUgKHRydWUpO1xuXG4gICAgcmV0dXJuIGIuaXVzaGxuKHNoaWZ0KTtcbiAgfTtcblxuICAvLyBJbnZlcnQgbnVtYmVyIGluIHRoZSBmaWVsZCBGKG51bSlcbiAgQk4ucHJvdG90eXBlLmludm0gPSBmdW5jdGlvbiBpbnZtIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5lZ2NkKG51bSkuYS51bW9kKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzRXZlbiA9IGZ1bmN0aW9uIGlzRXZlbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLndvcmRzWzBdICYgMSkgPT09IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzT2RkID0gZnVuY3Rpb24gaXNPZGQgKCkge1xuICAgIHJldHVybiAodGhpcy53b3Jkc1swXSAmIDEpID09PSAxO1xuICB9O1xuXG4gIC8vIEFuZCBmaXJzdCB3b3JkIGFuZCBudW1cbiAgQk4ucHJvdG90eXBlLmFuZGxuID0gZnVuY3Rpb24gYW5kbG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLndvcmRzWzBdICYgbnVtO1xuICB9O1xuXG4gIC8vIEluY3JlbWVudCBhdCB0aGUgYml0IHBvc2l0aW9uIGluLWxpbmVcbiAgQk4ucHJvdG90eXBlLmJpbmNuID0gZnVuY3Rpb24gYmluY24gKGJpdCkge1xuICAgIGFzc2VydCh0eXBlb2YgYml0ID09PSAnbnVtYmVyJyk7XG4gICAgdmFyIHIgPSBiaXQgJSAyNjtcbiAgICB2YXIgcyA9IChiaXQgLSByKSAvIDI2O1xuICAgIHZhciBxID0gMSA8PCByO1xuXG4gICAgLy8gRmFzdCBjYXNlOiBiaXQgaXMgbXVjaCBoaWdoZXIgdGhhbiBhbGwgZXhpc3Rpbmcgd29yZHNcbiAgICBpZiAodGhpcy5sZW5ndGggPD0gcykge1xuICAgICAgdGhpcy5fZXhwYW5kKHMgKyAxKTtcbiAgICAgIHRoaXMud29yZHNbc10gfD0gcTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZCBiaXQgYW5kIHByb3BhZ2F0ZSwgaWYgbmVlZGVkXG4gICAgdmFyIGNhcnJ5ID0gcTtcbiAgICBmb3IgKHZhciBpID0gczsgY2FycnkgIT09IDAgJiYgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3ID0gdGhpcy53b3Jkc1tpXSB8IDA7XG4gICAgICB3ICs9IGNhcnJ5O1xuICAgICAgY2FycnkgPSB3ID4+PiAyNjtcbiAgICAgIHcgJj0gMHgzZmZmZmZmO1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHc7XG4gICAgfVxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IGNhcnJ5O1xuICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uIGlzWmVybyAoKSB7XG4gICAgcmV0dXJuIHRoaXMubGVuZ3RoID09PSAxICYmIHRoaXMud29yZHNbMF0gPT09IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmNtcG4gPSBmdW5jdGlvbiBjbXBuIChudW0pIHtcbiAgICB2YXIgbmVnYXRpdmUgPSBudW0gPCAwO1xuXG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDAgJiYgIW5lZ2F0aXZlKSByZXR1cm4gLTE7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbmVnYXRpdmUpIHJldHVybiAxO1xuXG4gICAgdGhpcy5zdHJpcCgpO1xuXG4gICAgdmFyIHJlcztcbiAgICBpZiAodGhpcy5sZW5ndGggPiAxKSB7XG4gICAgICByZXMgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobmVnYXRpdmUpIHtcbiAgICAgICAgbnVtID0gLW51bTtcbiAgICAgIH1cblxuICAgICAgYXNzZXJ0KG51bSA8PSAweDNmZmZmZmYsICdOdW1iZXIgaXMgdG9vIGJpZycpO1xuXG4gICAgICB2YXIgdyA9IHRoaXMud29yZHNbMF0gfCAwO1xuICAgICAgcmVzID0gdyA9PT0gbnVtID8gMCA6IHcgPCBudW0gPyAtMSA6IDE7XG4gICAgfVxuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSByZXR1cm4gLXJlcyB8IDA7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvLyBDb21wYXJlIHR3byBudW1iZXJzIGFuZCByZXR1cm46XG4gIC8vIDEgLSBpZiBgdGhpc2AgPiBgbnVtYFxuICAvLyAwIC0gaWYgYHRoaXNgID09IGBudW1gXG4gIC8vIC0xIC0gaWYgYHRoaXNgIDwgYG51bWBcbiAgQk4ucHJvdG90eXBlLmNtcCA9IGZ1bmN0aW9uIGNtcCAobnVtKSB7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDAgJiYgbnVtLm5lZ2F0aXZlID09PSAwKSByZXR1cm4gLTE7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbnVtLm5lZ2F0aXZlICE9PSAwKSByZXR1cm4gMTtcblxuICAgIHZhciByZXMgPSB0aGlzLnVjbXAobnVtKTtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkgcmV0dXJuIC1yZXMgfCAwO1xuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLy8gVW5zaWduZWQgY29tcGFyaXNvblxuICBCTi5wcm90b3R5cGUudWNtcCA9IGZ1bmN0aW9uIHVjbXAgKG51bSkge1xuICAgIC8vIEF0IHRoaXMgcG9pbnQgYm90aCBudW1iZXJzIGhhdmUgdGhlIHNhbWUgc2lnblxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiAxO1xuICAgIGlmICh0aGlzLmxlbmd0aCA8IG51bS5sZW5ndGgpIHJldHVybiAtMTtcblxuICAgIHZhciByZXMgPSAwO1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgYSA9IHRoaXMud29yZHNbaV0gfCAwO1xuICAgICAgdmFyIGIgPSBudW0ud29yZHNbaV0gfCAwO1xuXG4gICAgICBpZiAoYSA9PT0gYikgY29udGludWU7XG4gICAgICBpZiAoYSA8IGIpIHtcbiAgICAgICAgcmVzID0gLTE7XG4gICAgICB9IGVsc2UgaWYgKGEgPiBiKSB7XG4gICAgICAgIHJlcyA9IDE7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZ3RuID0gZnVuY3Rpb24gZ3RuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPT09IDE7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmd0ID0gZnVuY3Rpb24gZ3QgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcChudW0pID09PSAxO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ndGVuID0gZnVuY3Rpb24gZ3RlbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wbihudW0pID49IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmd0ZSA9IGZ1bmN0aW9uIGd0ZSAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPj0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubHRuID0gZnVuY3Rpb24gbHRuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPT09IC0xO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5sdCA9IGZ1bmN0aW9uIGx0IChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA9PT0gLTE7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmx0ZW4gPSBmdW5jdGlvbiBsdGVuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPD0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubHRlID0gZnVuY3Rpb24gbHRlIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA8PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5lcW4gPSBmdW5jdGlvbiBlcW4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA9PT0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiBlcSAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPT09IDA7XG4gIH07XG5cbiAgLy9cbiAgLy8gQSByZWR1Y2UgY29udGV4dCwgY291bGQgYmUgdXNpbmcgbW9udGdvbWVyeSBvciBzb21ldGhpbmcgYmV0dGVyLCBkZXBlbmRpbmdcbiAgLy8gb24gdGhlIGBtYCBpdHNlbGYuXG4gIC8vXG4gIEJOLnJlZCA9IGZ1bmN0aW9uIHJlZCAobnVtKSB7XG4gICAgcmV0dXJuIG5ldyBSZWQobnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9SZWQgPSBmdW5jdGlvbiB0b1JlZCAoY3R4KSB7XG4gICAgYXNzZXJ0KCF0aGlzLnJlZCwgJ0FscmVhZHkgYSBudW1iZXIgaW4gcmVkdWN0aW9uIGNvbnRleHQnKTtcbiAgICBhc3NlcnQodGhpcy5uZWdhdGl2ZSA9PT0gMCwgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmVzJyk7XG4gICAgcmV0dXJuIGN0eC5jb252ZXJ0VG8odGhpcykuX2ZvcmNlUmVkKGN0eCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmZyb21SZWQgPSBmdW5jdGlvbiBmcm9tUmVkICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdmcm9tUmVkIHdvcmtzIG9ubHkgd2l0aCBudW1iZXJzIGluIHJlZHVjdGlvbiBjb250ZXh0Jyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmNvbnZlcnRGcm9tKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5fZm9yY2VSZWQgPSBmdW5jdGlvbiBfZm9yY2VSZWQgKGN0eCkge1xuICAgIHRoaXMucmVkID0gY3R4O1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5mb3JjZVJlZCA9IGZ1bmN0aW9uIGZvcmNlUmVkIChjdHgpIHtcbiAgICBhc3NlcnQoIXRoaXMucmVkLCAnQWxyZWFkeSBhIG51bWJlciBpbiByZWR1Y3Rpb24gY29udGV4dCcpO1xuICAgIHJldHVybiB0aGlzLl9mb3JjZVJlZChjdHgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRBZGQgPSBmdW5jdGlvbiByZWRBZGQgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZEFkZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuYWRkKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZElBZGQgPSBmdW5jdGlvbiByZWRJQWRkIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRJQWRkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHJldHVybiB0aGlzLnJlZC5pYWRkKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZFN1YiA9IGZ1bmN0aW9uIHJlZFN1YiAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU3ViIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHJldHVybiB0aGlzLnJlZC5zdWIodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSVN1YiA9IGZ1bmN0aW9uIHJlZElTdWIgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZElTdWIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmlzdWIodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkU2hsID0gZnVuY3Rpb24gcmVkU2hsIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRTaGwgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLnNobCh0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRNdWwgPSBmdW5jdGlvbiByZWRNdWwgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZE11bCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5Mih0aGlzLCBudW0pO1xuICAgIHJldHVybiB0aGlzLnJlZC5tdWwodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSU11bCA9IGZ1bmN0aW9uIHJlZElNdWwgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZE11bCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5Mih0aGlzLCBudW0pO1xuICAgIHJldHVybiB0aGlzLnJlZC5pbXVsKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZFNxciA9IGZ1bmN0aW9uIHJlZFNxciAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU3FyIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5zcXIodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZElTcXIgPSBmdW5jdGlvbiByZWRJU3FyICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRJU3FyIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5pc3FyKHRoaXMpO1xuICB9O1xuXG4gIC8vIFNxdWFyZSByb290IG92ZXIgcFxuICBCTi5wcm90b3R5cGUucmVkU3FydCA9IGZ1bmN0aW9uIHJlZFNxcnQgKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZFNxcnQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLnNxcnQodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZEludm0gPSBmdW5jdGlvbiByZWRJbnZtICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRJbnZtIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5pbnZtKHRoaXMpO1xuICB9O1xuXG4gIC8vIFJldHVybiBuZWdhdGl2ZSBjbG9uZSBvZiBgdGhpc2AgJSBgcmVkIG1vZHVsb2BcbiAgQk4ucHJvdG90eXBlLnJlZE5lZyA9IGZ1bmN0aW9uIHJlZE5lZyAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkTmVnIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5uZWcodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZFBvdyA9IGZ1bmN0aW9uIHJlZFBvdyAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkICYmICFudW0ucmVkLCAncmVkUG93KG5vcm1hbE51bSknKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWQucG93KHRoaXMsIG51bSk7XG4gIH07XG5cbiAgLy8gUHJpbWUgbnVtYmVycyB3aXRoIGVmZmljaWVudCByZWR1Y3Rpb25cbiAgdmFyIHByaW1lcyA9IHtcbiAgICBrMjU2OiBudWxsLFxuICAgIHAyMjQ6IG51bGwsXG4gICAgcDE5MjogbnVsbCxcbiAgICBwMjU1MTk6IG51bGxcbiAgfTtcblxuICAvLyBQc2V1ZG8tTWVyc2VubmUgcHJpbWVcbiAgZnVuY3Rpb24gTVByaW1lIChuYW1lLCBwKSB7XG4gICAgLy8gUCA9IDIgXiBOIC0gS1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5wID0gbmV3IEJOKHAsIDE2KTtcbiAgICB0aGlzLm4gPSB0aGlzLnAuYml0TGVuZ3RoKCk7XG4gICAgdGhpcy5rID0gbmV3IEJOKDEpLml1c2hsbih0aGlzLm4pLmlzdWIodGhpcy5wKTtcblxuICAgIHRoaXMudG1wID0gdGhpcy5fdG1wKCk7XG4gIH1cblxuICBNUHJpbWUucHJvdG90eXBlLl90bXAgPSBmdW5jdGlvbiBfdG1wICgpIHtcbiAgICB2YXIgdG1wID0gbmV3IEJOKG51bGwpO1xuICAgIHRtcC53b3JkcyA9IG5ldyBBcnJheShNYXRoLmNlaWwodGhpcy5uIC8gMTMpKTtcbiAgICByZXR1cm4gdG1wO1xuICB9O1xuXG4gIE1QcmltZS5wcm90b3R5cGUuaXJlZHVjZSA9IGZ1bmN0aW9uIGlyZWR1Y2UgKG51bSkge1xuICAgIC8vIEFzc3VtZXMgdGhhdCBgbnVtYCBpcyBsZXNzIHRoYW4gYFBeMmBcbiAgICAvLyBudW0gPSBISSAqICgyIF4gTiAtIEspICsgSEkgKiBLICsgTE8gPSBISSAqIEsgKyBMTyAobW9kIFApXG4gICAgdmFyIHIgPSBudW07XG4gICAgdmFyIHJsZW47XG5cbiAgICBkbyB7XG4gICAgICB0aGlzLnNwbGl0KHIsIHRoaXMudG1wKTtcbiAgICAgIHIgPSB0aGlzLmltdWxLKHIpO1xuICAgICAgciA9IHIuaWFkZCh0aGlzLnRtcCk7XG4gICAgICBybGVuID0gci5iaXRMZW5ndGgoKTtcbiAgICB9IHdoaWxlIChybGVuID4gdGhpcy5uKTtcblxuICAgIHZhciBjbXAgPSBybGVuIDwgdGhpcy5uID8gLTEgOiByLnVjbXAodGhpcy5wKTtcbiAgICBpZiAoY21wID09PSAwKSB7XG4gICAgICByLndvcmRzWzBdID0gMDtcbiAgICAgIHIubGVuZ3RoID0gMTtcbiAgICB9IGVsc2UgaWYgKGNtcCA+IDApIHtcbiAgICAgIHIuaXN1Yih0aGlzLnApO1xuICAgIH0gZWxzZSB7XG4gICAgICByLnN0cmlwKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgTVByaW1lLnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIHNwbGl0IChpbnB1dCwgb3V0KSB7XG4gICAgaW5wdXQuaXVzaHJuKHRoaXMubiwgMCwgb3V0KTtcbiAgfTtcblxuICBNUHJpbWUucHJvdG90eXBlLmltdWxLID0gZnVuY3Rpb24gaW11bEsgKG51bSkge1xuICAgIHJldHVybiBudW0uaW11bCh0aGlzLmspO1xuICB9O1xuXG4gIGZ1bmN0aW9uIEsyNTYgKCkge1xuICAgIE1QcmltZS5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgICdrMjU2JyxcbiAgICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmMyZicpO1xuICB9XG4gIGluaGVyaXRzKEsyNTYsIE1QcmltZSk7XG5cbiAgSzI1Ni5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiBzcGxpdCAoaW5wdXQsIG91dHB1dCkge1xuICAgIC8vIDI1NiA9IDkgKiAyNiArIDIyXG4gICAgdmFyIG1hc2sgPSAweDNmZmZmZjtcblxuICAgIHZhciBvdXRMZW4gPSBNYXRoLm1pbihpbnB1dC5sZW5ndGgsIDkpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3V0TGVuOyBpKyspIHtcbiAgICAgIG91dHB1dC53b3Jkc1tpXSA9IGlucHV0LndvcmRzW2ldO1xuICAgIH1cbiAgICBvdXRwdXQubGVuZ3RoID0gb3V0TGVuO1xuXG4gICAgaWYgKGlucHV0Lmxlbmd0aCA8PSA5KSB7XG4gICAgICBpbnB1dC53b3Jkc1swXSA9IDA7XG4gICAgICBpbnB1dC5sZW5ndGggPSAxO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFNoaWZ0IGJ5IDkgbGltYnNcbiAgICB2YXIgcHJldiA9IGlucHV0LndvcmRzWzldO1xuICAgIG91dHB1dC53b3Jkc1tvdXRwdXQubGVuZ3RoKytdID0gcHJldiAmIG1hc2s7XG5cbiAgICBmb3IgKGkgPSAxMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbmV4dCA9IGlucHV0LndvcmRzW2ldIHwgMDtcbiAgICAgIGlucHV0LndvcmRzW2kgLSAxMF0gPSAoKG5leHQgJiBtYXNrKSA8PCA0KSB8IChwcmV2ID4+PiAyMik7XG4gICAgICBwcmV2ID0gbmV4dDtcbiAgICB9XG4gICAgcHJldiA+Pj49IDIyO1xuICAgIGlucHV0LndvcmRzW2kgLSAxMF0gPSBwcmV2O1xuICAgIGlmIChwcmV2ID09PSAwICYmIGlucHV0Lmxlbmd0aCA+IDEwKSB7XG4gICAgICBpbnB1dC5sZW5ndGggLT0gMTA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlucHV0Lmxlbmd0aCAtPSA5O1xuICAgIH1cbiAgfTtcblxuICBLMjU2LnByb3RvdHlwZS5pbXVsSyA9IGZ1bmN0aW9uIGltdWxLIChudW0pIHtcbiAgICAvLyBLID0gMHgxMDAwMDAzZDEgPSBbIDB4NDAsIDB4M2QxIF1cbiAgICBudW0ud29yZHNbbnVtLmxlbmd0aF0gPSAwO1xuICAgIG51bS53b3Jkc1tudW0ubGVuZ3RoICsgMV0gPSAwO1xuICAgIG51bS5sZW5ndGggKz0gMjtcblxuICAgIC8vIGJvdW5kZWQgYXQ6IDB4NDAgKiAweDNmZmZmZmYgKyAweDNkMCA9IDB4MTAwMDAwMzkwXG4gICAgdmFyIGxvID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHcgPSBudW0ud29yZHNbaV0gfCAwO1xuICAgICAgbG8gKz0gdyAqIDB4M2QxO1xuICAgICAgbnVtLndvcmRzW2ldID0gbG8gJiAweDNmZmZmZmY7XG4gICAgICBsbyA9IHcgKiAweDQwICsgKChsbyAvIDB4NDAwMDAwMCkgfCAwKTtcbiAgICB9XG5cbiAgICAvLyBGYXN0IGxlbmd0aCByZWR1Y3Rpb25cbiAgICBpZiAobnVtLndvcmRzW251bS5sZW5ndGggLSAxXSA9PT0gMCkge1xuICAgICAgbnVtLmxlbmd0aC0tO1xuICAgICAgaWYgKG51bS53b3Jkc1tudW0ubGVuZ3RoIC0gMV0gPT09IDApIHtcbiAgICAgICAgbnVtLmxlbmd0aC0tO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVtO1xuICB9O1xuXG4gIGZ1bmN0aW9uIFAyMjQgKCkge1xuICAgIE1QcmltZS5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgICdwMjI0JyxcbiAgICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMScpO1xuICB9XG4gIGluaGVyaXRzKFAyMjQsIE1QcmltZSk7XG5cbiAgZnVuY3Rpb24gUDE5MiAoKSB7XG4gICAgTVByaW1lLmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgJ3AxOTInLFxuICAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmZmZmIGZmZmZmZmZmJyk7XG4gIH1cbiAgaW5oZXJpdHMoUDE5MiwgTVByaW1lKTtcblxuICBmdW5jdGlvbiBQMjU1MTkgKCkge1xuICAgIC8vIDIgXiAyNTUgLSAxOVxuICAgIE1QcmltZS5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgICcyNTUxOScsXG4gICAgICAnN2ZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZlZCcpO1xuICB9XG4gIGluaGVyaXRzKFAyNTUxOSwgTVByaW1lKTtcblxuICBQMjU1MTkucHJvdG90eXBlLmltdWxLID0gZnVuY3Rpb24gaW11bEsgKG51bSkge1xuICAgIC8vIEsgPSAweDEzXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhpID0gKG51bS53b3Jkc1tpXSB8IDApICogMHgxMyArIGNhcnJ5O1xuICAgICAgdmFyIGxvID0gaGkgJiAweDNmZmZmZmY7XG4gICAgICBoaSA+Pj49IDI2O1xuXG4gICAgICBudW0ud29yZHNbaV0gPSBsbztcbiAgICAgIGNhcnJ5ID0gaGk7XG4gICAgfVxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgbnVtLndvcmRzW251bS5sZW5ndGgrK10gPSBjYXJyeTtcbiAgICB9XG4gICAgcmV0dXJuIG51bTtcbiAgfTtcblxuICAvLyBFeHBvcnRlZCBtb3N0bHkgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHVzZSBwbGFpbiBuYW1lIGluc3RlYWRcbiAgQk4uX3ByaW1lID0gZnVuY3Rpb24gcHJpbWUgKG5hbWUpIHtcbiAgICAvLyBDYWNoZWQgdmVyc2lvbiBvZiBwcmltZVxuICAgIGlmIChwcmltZXNbbmFtZV0pIHJldHVybiBwcmltZXNbbmFtZV07XG5cbiAgICB2YXIgcHJpbWU7XG4gICAgaWYgKG5hbWUgPT09ICdrMjU2Jykge1xuICAgICAgcHJpbWUgPSBuZXcgSzI1NigpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3AyMjQnKSB7XG4gICAgICBwcmltZSA9IG5ldyBQMjI0KCk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAncDE5MicpIHtcbiAgICAgIHByaW1lID0gbmV3IFAxOTIoKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdwMjU1MTknKSB7XG4gICAgICBwcmltZSA9IG5ldyBQMjU1MTkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHByaW1lICcgKyBuYW1lKTtcbiAgICB9XG4gICAgcHJpbWVzW25hbWVdID0gcHJpbWU7XG5cbiAgICByZXR1cm4gcHJpbWU7XG4gIH07XG5cbiAgLy9cbiAgLy8gQmFzZSByZWR1Y3Rpb24gZW5naW5lXG4gIC8vXG4gIGZ1bmN0aW9uIFJlZCAobSkge1xuICAgIGlmICh0eXBlb2YgbSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBwcmltZSA9IEJOLl9wcmltZShtKTtcbiAgICAgIHRoaXMubSA9IHByaW1lLnA7XG4gICAgICB0aGlzLnByaW1lID0gcHJpbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChtLmd0bigxKSwgJ21vZHVsdXMgbXVzdCBiZSBncmVhdGVyIHRoYW4gMScpO1xuICAgICAgdGhpcy5tID0gbTtcbiAgICAgIHRoaXMucHJpbWUgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIFJlZC5wcm90b3R5cGUuX3ZlcmlmeTEgPSBmdW5jdGlvbiBfdmVyaWZ5MSAoYSkge1xuICAgIGFzc2VydChhLm5lZ2F0aXZlID09PSAwLCAncmVkIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZXMnKTtcbiAgICBhc3NlcnQoYS5yZWQsICdyZWQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5fdmVyaWZ5MiA9IGZ1bmN0aW9uIF92ZXJpZnkyIChhLCBiKSB7XG4gICAgYXNzZXJ0KChhLm5lZ2F0aXZlIHwgYi5uZWdhdGl2ZSkgPT09IDAsICdyZWQgd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlcycpO1xuICAgIGFzc2VydChhLnJlZCAmJiBhLnJlZCA9PT0gYi5yZWQsXG4gICAgICAncmVkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaW1vZCA9IGZ1bmN0aW9uIGltb2QgKGEpIHtcbiAgICBpZiAodGhpcy5wcmltZSkgcmV0dXJuIHRoaXMucHJpbWUuaXJlZHVjZShhKS5fZm9yY2VSZWQodGhpcyk7XG4gICAgcmV0dXJuIGEudW1vZCh0aGlzLm0pLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uIG5lZyAoYSkge1xuICAgIGlmIChhLmlzWmVybygpKSB7XG4gICAgICByZXR1cm4gYS5jbG9uZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLm0uc3ViKGEpLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cbiAgICB2YXIgcmVzID0gYS5hZGQoYik7XG4gICAgaWYgKHJlcy5jbXAodGhpcy5tKSA+PSAwKSB7XG4gICAgICByZXMuaXN1Yih0aGlzLm0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmlhZGQgPSBmdW5jdGlvbiBpYWRkIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuICAgIHZhciByZXMgPSBhLmlhZGQoYik7XG4gICAgaWYgKHJlcy5jbXAodGhpcy5tKSA+PSAwKSB7XG4gICAgICByZXMuaXN1Yih0aGlzLm0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24gc3ViIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuICAgIHZhciByZXMgPSBhLnN1YihiKTtcbiAgICBpZiAocmVzLmNtcG4oMCkgPCAwKSB7XG4gICAgICByZXMuaWFkZCh0aGlzLm0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmlzdWIgPSBmdW5jdGlvbiBpc3ViIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuICAgIHZhciByZXMgPSBhLmlzdWIoYik7XG4gICAgaWYgKHJlcy5jbXBuKDApIDwgMCkge1xuICAgICAgcmVzLmlhZGQodGhpcy5tKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLnNobCA9IGZ1bmN0aW9uIHNobCAoYSwgbnVtKSB7XG4gICAgdGhpcy5fdmVyaWZ5MShhKTtcbiAgICByZXR1cm4gdGhpcy5pbW9kKGEudXNobG4obnVtKSk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pbXVsID0gZnVuY3Rpb24gaW11bCAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG4gICAgcmV0dXJuIHRoaXMuaW1vZChhLmltdWwoYikpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcbiAgICByZXR1cm4gdGhpcy5pbW9kKGEubXVsKGIpKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmlzcXIgPSBmdW5jdGlvbiBpc3FyIChhKSB7XG4gICAgcmV0dXJuIHRoaXMuaW11bChhLCBhLmNsb25lKCkpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuc3FyID0gZnVuY3Rpb24gc3FyIChhKSB7XG4gICAgcmV0dXJuIHRoaXMubXVsKGEsIGEpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuc3FydCA9IGZ1bmN0aW9uIHNxcnQgKGEpIHtcbiAgICBpZiAoYS5pc1plcm8oKSkgcmV0dXJuIGEuY2xvbmUoKTtcblxuICAgIHZhciBtb2QzID0gdGhpcy5tLmFuZGxuKDMpO1xuICAgIGFzc2VydChtb2QzICUgMiA9PT0gMSk7XG5cbiAgICAvLyBGYXN0IGNhc2VcbiAgICBpZiAobW9kMyA9PT0gMykge1xuICAgICAgdmFyIHBvdyA9IHRoaXMubS5hZGQobmV3IEJOKDEpKS5pdXNocm4oMik7XG4gICAgICByZXR1cm4gdGhpcy5wb3coYSwgcG93KTtcbiAgICB9XG5cbiAgICAvLyBUb25lbGxpLVNoYW5rcyBhbGdvcml0aG0gKFRvdGFsbHkgdW5vcHRpbWl6ZWQgYW5kIHNsb3cpXG4gICAgLy9cbiAgICAvLyBGaW5kIFEgYW5kIFMsIHRoYXQgUSAqIDIgXiBTID0gKFAgLSAxKVxuICAgIHZhciBxID0gdGhpcy5tLnN1Ym4oMSk7XG4gICAgdmFyIHMgPSAwO1xuICAgIHdoaWxlICghcS5pc1plcm8oKSAmJiBxLmFuZGxuKDEpID09PSAwKSB7XG4gICAgICBzKys7XG4gICAgICBxLml1c2hybigxKTtcbiAgICB9XG4gICAgYXNzZXJ0KCFxLmlzWmVybygpKTtcblxuICAgIHZhciBvbmUgPSBuZXcgQk4oMSkudG9SZWQodGhpcyk7XG4gICAgdmFyIG5PbmUgPSBvbmUucmVkTmVnKCk7XG5cbiAgICAvLyBGaW5kIHF1YWRyYXRpYyBub24tcmVzaWR1ZVxuICAgIC8vIE5PVEU6IE1heCBpcyBzdWNoIGJlY2F1c2Ugb2YgZ2VuZXJhbGl6ZWQgUmllbWFubiBoeXBvdGhlc2lzLlxuICAgIHZhciBscG93ID0gdGhpcy5tLnN1Ym4oMSkuaXVzaHJuKDEpO1xuICAgIHZhciB6ID0gdGhpcy5tLmJpdExlbmd0aCgpO1xuICAgIHogPSBuZXcgQk4oMiAqIHogKiB6KS50b1JlZCh0aGlzKTtcblxuICAgIHdoaWxlICh0aGlzLnBvdyh6LCBscG93KS5jbXAobk9uZSkgIT09IDApIHtcbiAgICAgIHoucmVkSUFkZChuT25lKTtcbiAgICB9XG5cbiAgICB2YXIgYyA9IHRoaXMucG93KHosIHEpO1xuICAgIHZhciByID0gdGhpcy5wb3coYSwgcS5hZGRuKDEpLml1c2hybigxKSk7XG4gICAgdmFyIHQgPSB0aGlzLnBvdyhhLCBxKTtcbiAgICB2YXIgbSA9IHM7XG4gICAgd2hpbGUgKHQuY21wKG9uZSkgIT09IDApIHtcbiAgICAgIHZhciB0bXAgPSB0O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IHRtcC5jbXAob25lKSAhPT0gMDsgaSsrKSB7XG4gICAgICAgIHRtcCA9IHRtcC5yZWRTcXIoKTtcbiAgICAgIH1cbiAgICAgIGFzc2VydChpIDwgbSk7XG4gICAgICB2YXIgYiA9IHRoaXMucG93KGMsIG5ldyBCTigxKS5pdXNobG4obSAtIGkgLSAxKSk7XG5cbiAgICAgIHIgPSByLnJlZE11bChiKTtcbiAgICAgIGMgPSBiLnJlZFNxcigpO1xuICAgICAgdCA9IHQucmVkTXVsKGMpO1xuICAgICAgbSA9IGk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pbnZtID0gZnVuY3Rpb24gaW52bSAoYSkge1xuICAgIHZhciBpbnYgPSBhLl9pbnZtcCh0aGlzLm0pO1xuICAgIGlmIChpbnYubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIGludi5uZWdhdGl2ZSA9IDA7XG4gICAgICByZXR1cm4gdGhpcy5pbW9kKGludikucmVkTmVnKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmltb2QoaW52KTtcbiAgICB9XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5wb3cgPSBmdW5jdGlvbiBwb3cgKGEsIG51bSkge1xuICAgIGlmIChudW0uaXNaZXJvKCkpIHJldHVybiBuZXcgQk4oMSkudG9SZWQodGhpcyk7XG4gICAgaWYgKG51bS5jbXBuKDEpID09PSAwKSByZXR1cm4gYS5jbG9uZSgpO1xuXG4gICAgdmFyIHdpbmRvd1NpemUgPSA0O1xuICAgIHZhciB3bmQgPSBuZXcgQXJyYXkoMSA8PCB3aW5kb3dTaXplKTtcbiAgICB3bmRbMF0gPSBuZXcgQk4oMSkudG9SZWQodGhpcyk7XG4gICAgd25kWzFdID0gYTtcbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IHduZC5sZW5ndGg7IGkrKykge1xuICAgICAgd25kW2ldID0gdGhpcy5tdWwod25kW2kgLSAxXSwgYSk7XG4gICAgfVxuXG4gICAgdmFyIHJlcyA9IHduZFswXTtcbiAgICB2YXIgY3VycmVudCA9IDA7XG4gICAgdmFyIGN1cnJlbnRMZW4gPSAwO1xuICAgIHZhciBzdGFydCA9IG51bS5iaXRMZW5ndGgoKSAlIDI2O1xuICAgIGlmIChzdGFydCA9PT0gMCkge1xuICAgICAgc3RhcnQgPSAyNjtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSBudW0ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciB3b3JkID0gbnVtLndvcmRzW2ldO1xuICAgICAgZm9yICh2YXIgaiA9IHN0YXJ0IC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgdmFyIGJpdCA9ICh3b3JkID4+IGopICYgMTtcbiAgICAgICAgaWYgKHJlcyAhPT0gd25kWzBdKSB7XG4gICAgICAgICAgcmVzID0gdGhpcy5zcXIocmVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChiaXQgPT09IDAgJiYgY3VycmVudCA9PT0gMCkge1xuICAgICAgICAgIGN1cnJlbnRMZW4gPSAwO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudCA8PD0gMTtcbiAgICAgICAgY3VycmVudCB8PSBiaXQ7XG4gICAgICAgIGN1cnJlbnRMZW4rKztcbiAgICAgICAgaWYgKGN1cnJlbnRMZW4gIT09IHdpbmRvd1NpemUgJiYgKGkgIT09IDAgfHwgaiAhPT0gMCkpIGNvbnRpbnVlO1xuXG4gICAgICAgIHJlcyA9IHRoaXMubXVsKHJlcywgd25kW2N1cnJlbnRdKTtcbiAgICAgICAgY3VycmVudExlbiA9IDA7XG4gICAgICAgIGN1cnJlbnQgPSAwO1xuICAgICAgfVxuICAgICAgc3RhcnQgPSAyNjtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuY29udmVydFRvID0gZnVuY3Rpb24gY29udmVydFRvIChudW0pIHtcbiAgICB2YXIgciA9IG51bS51bW9kKHRoaXMubSk7XG5cbiAgICByZXR1cm4gciA9PT0gbnVtID8gci5jbG9uZSgpIDogcjtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmNvbnZlcnRGcm9tID0gZnVuY3Rpb24gY29udmVydEZyb20gKG51bSkge1xuICAgIHZhciByZXMgPSBudW0uY2xvbmUoKTtcbiAgICByZXMucmVkID0gbnVsbDtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8vXG4gIC8vIE1vbnRnb21lcnkgbWV0aG9kIGVuZ2luZVxuICAvL1xuXG4gIEJOLm1vbnQgPSBmdW5jdGlvbiBtb250IChudW0pIHtcbiAgICByZXR1cm4gbmV3IE1vbnQobnVtKTtcbiAgfTtcblxuICBmdW5jdGlvbiBNb250IChtKSB7XG4gICAgUmVkLmNhbGwodGhpcywgbSk7XG5cbiAgICB0aGlzLnNoaWZ0ID0gdGhpcy5tLmJpdExlbmd0aCgpO1xuICAgIGlmICh0aGlzLnNoaWZ0ICUgMjYgIT09IDApIHtcbiAgICAgIHRoaXMuc2hpZnQgKz0gMjYgLSAodGhpcy5zaGlmdCAlIDI2KTtcbiAgICB9XG5cbiAgICB0aGlzLnIgPSBuZXcgQk4oMSkuaXVzaGxuKHRoaXMuc2hpZnQpO1xuICAgIHRoaXMucjIgPSB0aGlzLmltb2QodGhpcy5yLnNxcigpKTtcbiAgICB0aGlzLnJpbnYgPSB0aGlzLnIuX2ludm1wKHRoaXMubSk7XG5cbiAgICB0aGlzLm1pbnYgPSB0aGlzLnJpbnYubXVsKHRoaXMucikuaXN1Ym4oMSkuZGl2KHRoaXMubSk7XG4gICAgdGhpcy5taW52ID0gdGhpcy5taW52LnVtb2QodGhpcy5yKTtcbiAgICB0aGlzLm1pbnYgPSB0aGlzLnIuc3ViKHRoaXMubWludik7XG4gIH1cbiAgaW5oZXJpdHMoTW9udCwgUmVkKTtcblxuICBNb250LnByb3RvdHlwZS5jb252ZXJ0VG8gPSBmdW5jdGlvbiBjb252ZXJ0VG8gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmltb2QobnVtLnVzaGxuKHRoaXMuc2hpZnQpKTtcbiAgfTtcblxuICBNb250LnByb3RvdHlwZS5jb252ZXJ0RnJvbSA9IGZ1bmN0aW9uIGNvbnZlcnRGcm9tIChudW0pIHtcbiAgICB2YXIgciA9IHRoaXMuaW1vZChudW0ubXVsKHRoaXMucmludikpO1xuICAgIHIucmVkID0gbnVsbDtcbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBNb250LnByb3RvdHlwZS5pbXVsID0gZnVuY3Rpb24gaW11bCAoYSwgYikge1xuICAgIGlmIChhLmlzWmVybygpIHx8IGIuaXNaZXJvKCkpIHtcbiAgICAgIGEud29yZHNbMF0gPSAwO1xuICAgICAgYS5sZW5ndGggPSAxO1xuICAgICAgcmV0dXJuIGE7XG4gICAgfVxuXG4gICAgdmFyIHQgPSBhLmltdWwoYik7XG4gICAgdmFyIGMgPSB0Lm1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm1pbnYpLmltYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5tKTtcbiAgICB2YXIgdSA9IHQuaXN1YihjKS5pdXNocm4odGhpcy5zaGlmdCk7XG4gICAgdmFyIHJlcyA9IHU7XG5cbiAgICBpZiAodS5jbXAodGhpcy5tKSA+PSAwKSB7XG4gICAgICByZXMgPSB1LmlzdWIodGhpcy5tKTtcbiAgICB9IGVsc2UgaWYgKHUuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcyA9IHUuaWFkZCh0aGlzLm0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIE1vbnQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bCAoYSwgYikge1xuICAgIGlmIChhLmlzWmVybygpIHx8IGIuaXNaZXJvKCkpIHJldHVybiBuZXcgQk4oMCkuX2ZvcmNlUmVkKHRoaXMpO1xuXG4gICAgdmFyIHQgPSBhLm11bChiKTtcbiAgICB2YXIgYyA9IHQubWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubWludikuaW1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm0pO1xuICAgIHZhciB1ID0gdC5pc3ViKGMpLml1c2hybih0aGlzLnNoaWZ0KTtcbiAgICB2YXIgcmVzID0gdTtcbiAgICBpZiAodS5jbXAodGhpcy5tKSA+PSAwKSB7XG4gICAgICByZXMgPSB1LmlzdWIodGhpcy5tKTtcbiAgICB9IGVsc2UgaWYgKHUuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcyA9IHUuaWFkZCh0aGlzLm0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIE1vbnQucHJvdG90eXBlLmludm0gPSBmdW5jdGlvbiBpbnZtIChhKSB7XG4gICAgLy8gKEFSKV4tMSAqIFJeMiA9IChBXi0xICogUl4tMSkgKiBSXjIgPSBBXi0xICogUlxuICAgIHZhciByZXMgPSB0aGlzLmltb2QoYS5faW52bXAodGhpcy5tKS5tdWwodGhpcy5yMikpO1xuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xufSkodHlwZW9mIG1vZHVsZSA9PT0gJ3VuZGVmaW5lZCcgfHwgbW9kdWxlLCB0aGlzKTtcbiIsInZhciByO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJhbmQobGVuKSB7XG4gIGlmICghcilcbiAgICByID0gbmV3IFJhbmQobnVsbCk7XG5cbiAgcmV0dXJuIHIuZ2VuZXJhdGUobGVuKTtcbn07XG5cbmZ1bmN0aW9uIFJhbmQocmFuZCkge1xuICB0aGlzLnJhbmQgPSByYW5kO1xufVxubW9kdWxlLmV4cG9ydHMuUmFuZCA9IFJhbmQ7XG5cblJhbmQucHJvdG90eXBlLmdlbmVyYXRlID0gZnVuY3Rpb24gZ2VuZXJhdGUobGVuKSB7XG4gIHJldHVybiB0aGlzLl9yYW5kKGxlbik7XG59O1xuXG4vLyBFbXVsYXRlIGNyeXB0byBBUEkgdXNpbmcgcmFuZHlcblJhbmQucHJvdG90eXBlLl9yYW5kID0gZnVuY3Rpb24gX3JhbmQobikge1xuICBpZiAodGhpcy5yYW5kLmdldEJ5dGVzKVxuICAgIHJldHVybiB0aGlzLnJhbmQuZ2V0Qnl0ZXMobik7XG5cbiAgdmFyIHJlcyA9IG5ldyBVaW50OEFycmF5KG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcy5sZW5ndGg7IGkrKylcbiAgICByZXNbaV0gPSB0aGlzLnJhbmQuZ2V0Qnl0ZSgpO1xuICByZXR1cm4gcmVzO1xufTtcblxuaWYgKHR5cGVvZiBzZWxmID09PSAnb2JqZWN0Jykge1xuICBpZiAoc2VsZi5jcnlwdG8gJiYgc2VsZi5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgLy8gTW9kZXJuIGJyb3dzZXJzXG4gICAgUmFuZC5wcm90b3R5cGUuX3JhbmQgPSBmdW5jdGlvbiBfcmFuZChuKSB7XG4gICAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkobik7XG4gICAgICBzZWxmLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYXJyKTtcbiAgICAgIHJldHVybiBhcnI7XG4gICAgfTtcbiAgfSBlbHNlIGlmIChzZWxmLm1zQ3J5cHRvICYmIHNlbGYubXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgLy8gSUVcbiAgICBSYW5kLnByb3RvdHlwZS5fcmFuZCA9IGZ1bmN0aW9uIF9yYW5kKG4pIHtcbiAgICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheShuKTtcbiAgICAgIHNlbGYubXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGFycik7XG4gICAgICByZXR1cm4gYXJyO1xuICAgIH07XG5cbiAgLy8gU2FmYXJpJ3MgV2ViV29ya2VycyBkbyBub3QgaGF2ZSBgY3J5cHRvYFxuICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSB7XG4gICAgLy8gT2xkIGp1bmtcbiAgICBSYW5kLnByb3RvdHlwZS5fcmFuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQgeWV0Jyk7XG4gICAgfTtcbiAgfVxufSBlbHNlIHtcbiAgLy8gTm9kZS5qcyBvciBXZWIgd29ya2VyIHdpdGggbm8gY3J5cHRvIHN1cHBvcnRcbiAgdHJ5IHtcbiAgICB2YXIgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG4gICAgaWYgKHR5cGVvZiBjcnlwdG8ucmFuZG9tQnl0ZXMgIT09ICdmdW5jdGlvbicpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBzdXBwb3J0ZWQnKTtcblxuICAgIFJhbmQucHJvdG90eXBlLl9yYW5kID0gZnVuY3Rpb24gX3JhbmQobikge1xuICAgICAgcmV0dXJuIGNyeXB0by5yYW5kb21CeXRlcyhuKTtcbiAgICB9O1xuICB9IGNhdGNoIChlKSB7XG4gIH1cbn1cbiIsIi8vIGJhc2VkIG9uIHRoZSBhZXMgaW1wbGltZW50YXRpb24gaW4gdHJpcGxlIHNlY1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2tleWJhc2UvdHJpcGxlc2VjXG4vLyB3aGljaCBpcyBpbiB0dXJuIGJhc2VkIG9uIHRoZSBvbmUgZnJvbSBjcnlwdG8tanNcbi8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY3J5cHRvLWpzL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxuZnVuY3Rpb24gYXNVSW50MzJBcnJheSAoYnVmKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIGJ1ZiA9IEJ1ZmZlci5mcm9tKGJ1ZilcblxuICB2YXIgbGVuID0gKGJ1Zi5sZW5ndGggLyA0KSB8IDBcbiAgdmFyIG91dCA9IG5ldyBBcnJheShsZW4pXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG91dFtpXSA9IGJ1Zi5yZWFkVUludDMyQkUoaSAqIDQpXG4gIH1cblxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHNjcnViVmVjICh2KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdi5sZW5ndGg7IHYrKykge1xuICAgIHZbaV0gPSAwXG4gIH1cbn1cblxuZnVuY3Rpb24gY3J5cHRCbG9jayAoTSwga2V5U2NoZWR1bGUsIFNVQl9NSVgsIFNCT1gsIG5Sb3VuZHMpIHtcbiAgdmFyIFNVQl9NSVgwID0gU1VCX01JWFswXVxuICB2YXIgU1VCX01JWDEgPSBTVUJfTUlYWzFdXG4gIHZhciBTVUJfTUlYMiA9IFNVQl9NSVhbMl1cbiAgdmFyIFNVQl9NSVgzID0gU1VCX01JWFszXVxuXG4gIHZhciBzMCA9IE1bMF0gXiBrZXlTY2hlZHVsZVswXVxuICB2YXIgczEgPSBNWzFdIF4ga2V5U2NoZWR1bGVbMV1cbiAgdmFyIHMyID0gTVsyXSBeIGtleVNjaGVkdWxlWzJdXG4gIHZhciBzMyA9IE1bM10gXiBrZXlTY2hlZHVsZVszXVxuICB2YXIgdDAsIHQxLCB0MiwgdDNcbiAgdmFyIGtzUm93ID0gNFxuXG4gIGZvciAodmFyIHJvdW5kID0gMTsgcm91bmQgPCBuUm91bmRzOyByb3VuZCsrKSB7XG4gICAgdDAgPSBTVUJfTUlYMFtzMCA+Pj4gMjRdIF4gU1VCX01JWDFbKHMxID4+PiAxNikgJiAweGZmXSBeIFNVQl9NSVgyWyhzMiA+Pj4gOCkgJiAweGZmXSBeIFNVQl9NSVgzW3MzICYgMHhmZl0gXiBrZXlTY2hlZHVsZVtrc1JvdysrXVxuICAgIHQxID0gU1VCX01JWDBbczEgPj4+IDI0XSBeIFNVQl9NSVgxWyhzMiA+Pj4gMTYpICYgMHhmZl0gXiBTVUJfTUlYMlsoczMgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYM1tzMCAmIDB4ZmZdIF4ga2V5U2NoZWR1bGVba3NSb3crK11cbiAgICB0MiA9IFNVQl9NSVgwW3MyID4+PiAyNF0gXiBTVUJfTUlYMVsoczMgPj4+IDE2KSAmIDB4ZmZdIF4gU1VCX01JWDJbKHMwID4+PiA4KSAmIDB4ZmZdIF4gU1VCX01JWDNbczEgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdXG4gICAgdDMgPSBTVUJfTUlYMFtzMyA+Pj4gMjRdIF4gU1VCX01JWDFbKHMwID4+PiAxNikgJiAweGZmXSBeIFNVQl9NSVgyWyhzMSA+Pj4gOCkgJiAweGZmXSBeIFNVQl9NSVgzW3MyICYgMHhmZl0gXiBrZXlTY2hlZHVsZVtrc1JvdysrXVxuICAgIHMwID0gdDBcbiAgICBzMSA9IHQxXG4gICAgczIgPSB0MlxuICAgIHMzID0gdDNcbiAgfVxuXG4gIHQwID0gKChTQk9YW3MwID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHMxID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsoczIgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3MzICYgMHhmZl0pIF4ga2V5U2NoZWR1bGVba3NSb3crK11cbiAgdDEgPSAoKFNCT1hbczEgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsoczIgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyhzMyA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbczAgJiAweGZmXSkgXiBrZXlTY2hlZHVsZVtrc1JvdysrXVxuICB0MiA9ICgoU0JPWFtzMiA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyhzMyA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHMwID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFtzMSAmIDB4ZmZdKSBeIGtleVNjaGVkdWxlW2tzUm93KytdXG4gIHQzID0gKChTQk9YW3MzID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHMwID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsoczEgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3MyICYgMHhmZl0pIF4ga2V5U2NoZWR1bGVba3NSb3crK11cbiAgdDAgPSB0MCA+Pj4gMFxuICB0MSA9IHQxID4+PiAwXG4gIHQyID0gdDIgPj4+IDBcbiAgdDMgPSB0MyA+Pj4gMFxuXG4gIHJldHVybiBbdDAsIHQxLCB0MiwgdDNdXG59XG5cbi8vIEFFUyBjb25zdGFudHNcbnZhciBSQ09OID0gWzB4MDAsIDB4MDEsIDB4MDIsIDB4MDQsIDB4MDgsIDB4MTAsIDB4MjAsIDB4NDAsIDB4ODAsIDB4MWIsIDB4MzZdXG52YXIgRyA9IChmdW5jdGlvbiAoKSB7XG4gIC8vIENvbXB1dGUgZG91YmxlIHRhYmxlXG4gIHZhciBkID0gbmV3IEFycmF5KDI1NilcbiAgZm9yICh2YXIgaiA9IDA7IGogPCAyNTY7IGorKykge1xuICAgIGlmIChqIDwgMTI4KSB7XG4gICAgICBkW2pdID0gaiA8PCAxXG4gICAgfSBlbHNlIHtcbiAgICAgIGRbal0gPSAoaiA8PCAxKSBeIDB4MTFiXG4gICAgfVxuICB9XG5cbiAgdmFyIFNCT1ggPSBbXVxuICB2YXIgSU5WX1NCT1ggPSBbXVxuICB2YXIgU1VCX01JWCA9IFtbXSwgW10sIFtdLCBbXV1cbiAgdmFyIElOVl9TVUJfTUlYID0gW1tdLCBbXSwgW10sIFtdXVxuXG4gIC8vIFdhbGsgR0YoMl44KVxuICB2YXIgeCA9IDBcbiAgdmFyIHhpID0gMFxuICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gICAgLy8gQ29tcHV0ZSBzYm94XG4gICAgdmFyIHN4ID0geGkgXiAoeGkgPDwgMSkgXiAoeGkgPDwgMikgXiAoeGkgPDwgMykgXiAoeGkgPDwgNClcbiAgICBzeCA9IChzeCA+Pj4gOCkgXiAoc3ggJiAweGZmKSBeIDB4NjNcbiAgICBTQk9YW3hdID0gc3hcbiAgICBJTlZfU0JPWFtzeF0gPSB4XG5cbiAgICAvLyBDb21wdXRlIG11bHRpcGxpY2F0aW9uXG4gICAgdmFyIHgyID0gZFt4XVxuICAgIHZhciB4NCA9IGRbeDJdXG4gICAgdmFyIHg4ID0gZFt4NF1cblxuICAgIC8vIENvbXB1dGUgc3ViIGJ5dGVzLCBtaXggY29sdW1ucyB0YWJsZXNcbiAgICB2YXIgdCA9IChkW3N4XSAqIDB4MTAxKSBeIChzeCAqIDB4MTAxMDEwMClcbiAgICBTVUJfTUlYWzBdW3hdID0gKHQgPDwgMjQpIHwgKHQgPj4+IDgpXG4gICAgU1VCX01JWFsxXVt4XSA9ICh0IDw8IDE2KSB8ICh0ID4+PiAxNilcbiAgICBTVUJfTUlYWzJdW3hdID0gKHQgPDwgOCkgfCAodCA+Pj4gMjQpXG4gICAgU1VCX01JWFszXVt4XSA9IHRcblxuICAgIC8vIENvbXB1dGUgaW52IHN1YiBieXRlcywgaW52IG1peCBjb2x1bW5zIHRhYmxlc1xuICAgIHQgPSAoeDggKiAweDEwMTAxMDEpIF4gKHg0ICogMHgxMDAwMSkgXiAoeDIgKiAweDEwMSkgXiAoeCAqIDB4MTAxMDEwMClcbiAgICBJTlZfU1VCX01JWFswXVtzeF0gPSAodCA8PCAyNCkgfCAodCA+Pj4gOClcbiAgICBJTlZfU1VCX01JWFsxXVtzeF0gPSAodCA8PCAxNikgfCAodCA+Pj4gMTYpXG4gICAgSU5WX1NVQl9NSVhbMl1bc3hdID0gKHQgPDwgOCkgfCAodCA+Pj4gMjQpXG4gICAgSU5WX1NVQl9NSVhbM11bc3hdID0gdFxuXG4gICAgaWYgKHggPT09IDApIHtcbiAgICAgIHggPSB4aSA9IDFcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IHgyIF4gZFtkW2RbeDggXiB4Ml1dXVxuICAgICAgeGkgXj0gZFtkW3hpXV1cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIFNCT1g6IFNCT1gsXG4gICAgSU5WX1NCT1g6IElOVl9TQk9YLFxuICAgIFNVQl9NSVg6IFNVQl9NSVgsXG4gICAgSU5WX1NVQl9NSVg6IElOVl9TVUJfTUlYXG4gIH1cbn0pKClcblxuZnVuY3Rpb24gQUVTIChrZXkpIHtcbiAgdGhpcy5fa2V5ID0gYXNVSW50MzJBcnJheShrZXkpXG4gIHRoaXMuX3Jlc2V0KClcbn1cblxuQUVTLmJsb2NrU2l6ZSA9IDQgKiA0XG5BRVMua2V5U2l6ZSA9IDI1NiAvIDhcbkFFUy5wcm90b3R5cGUuYmxvY2tTaXplID0gQUVTLmJsb2NrU2l6ZVxuQUVTLnByb3RvdHlwZS5rZXlTaXplID0gQUVTLmtleVNpemVcbkFFUy5wcm90b3R5cGUuX3Jlc2V0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIga2V5V29yZHMgPSB0aGlzLl9rZXlcbiAgdmFyIGtleVNpemUgPSBrZXlXb3Jkcy5sZW5ndGhcbiAgdmFyIG5Sb3VuZHMgPSBrZXlTaXplICsgNlxuICB2YXIga3NSb3dzID0gKG5Sb3VuZHMgKyAxKSAqIDRcblxuICB2YXIga2V5U2NoZWR1bGUgPSBbXVxuICBmb3IgKHZhciBrID0gMDsgayA8IGtleVNpemU7IGsrKykge1xuICAgIGtleVNjaGVkdWxlW2tdID0ga2V5V29yZHNba11cbiAgfVxuXG4gIGZvciAoayA9IGtleVNpemU7IGsgPCBrc1Jvd3M7IGsrKykge1xuICAgIHZhciB0ID0ga2V5U2NoZWR1bGVbayAtIDFdXG5cbiAgICBpZiAoayAlIGtleVNpemUgPT09IDApIHtcbiAgICAgIHQgPSAodCA8PCA4KSB8ICh0ID4+PiAyNClcbiAgICAgIHQgPVxuICAgICAgICAoRy5TQk9YW3QgPj4+IDI0XSA8PCAyNCkgfFxuICAgICAgICAoRy5TQk9YWyh0ID4+PiAxNikgJiAweGZmXSA8PCAxNikgfFxuICAgICAgICAoRy5TQk9YWyh0ID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHxcbiAgICAgICAgKEcuU0JPWFt0ICYgMHhmZl0pXG5cbiAgICAgIHQgXj0gUkNPTlsoayAvIGtleVNpemUpIHwgMF0gPDwgMjRcbiAgICB9IGVsc2UgaWYgKGtleVNpemUgPiA2ICYmIGsgJSBrZXlTaXplID09PSA0KSB7XG4gICAgICB0ID1cbiAgICAgICAgKEcuU0JPWFt0ID4+PiAyNF0gPDwgMjQpIHxcbiAgICAgICAgKEcuU0JPWFsodCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHxcbiAgICAgICAgKEcuU0JPWFsodCA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8XG4gICAgICAgIChHLlNCT1hbdCAmIDB4ZmZdKVxuICAgIH1cblxuICAgIGtleVNjaGVkdWxlW2tdID0ga2V5U2NoZWR1bGVbayAtIGtleVNpemVdIF4gdFxuICB9XG5cbiAgdmFyIGludktleVNjaGVkdWxlID0gW11cbiAgZm9yICh2YXIgaWsgPSAwOyBpayA8IGtzUm93czsgaWsrKykge1xuICAgIHZhciBrc1IgPSBrc1Jvd3MgLSBpa1xuICAgIHZhciB0dCA9IGtleVNjaGVkdWxlW2tzUiAtIChpayAlIDQgPyAwIDogNCldXG5cbiAgICBpZiAoaWsgPCA0IHx8IGtzUiA8PSA0KSB7XG4gICAgICBpbnZLZXlTY2hlZHVsZVtpa10gPSB0dFxuICAgIH0gZWxzZSB7XG4gICAgICBpbnZLZXlTY2hlZHVsZVtpa10gPVxuICAgICAgICBHLklOVl9TVUJfTUlYWzBdW0cuU0JPWFt0dCA+Pj4gMjRdXSBeXG4gICAgICAgIEcuSU5WX1NVQl9NSVhbMV1bRy5TQk9YWyh0dCA+Pj4gMTYpICYgMHhmZl1dIF5cbiAgICAgICAgRy5JTlZfU1VCX01JWFsyXVtHLlNCT1hbKHR0ID4+PiA4KSAmIDB4ZmZdXSBeXG4gICAgICAgIEcuSU5WX1NVQl9NSVhbM11bRy5TQk9YW3R0ICYgMHhmZl1dXG4gICAgfVxuICB9XG5cbiAgdGhpcy5fblJvdW5kcyA9IG5Sb3VuZHNcbiAgdGhpcy5fa2V5U2NoZWR1bGUgPSBrZXlTY2hlZHVsZVxuICB0aGlzLl9pbnZLZXlTY2hlZHVsZSA9IGludktleVNjaGVkdWxlXG59XG5cbkFFUy5wcm90b3R5cGUuZW5jcnlwdEJsb2NrUmF3ID0gZnVuY3Rpb24gKE0pIHtcbiAgTSA9IGFzVUludDMyQXJyYXkoTSlcbiAgcmV0dXJuIGNyeXB0QmxvY2soTSwgdGhpcy5fa2V5U2NoZWR1bGUsIEcuU1VCX01JWCwgRy5TQk9YLCB0aGlzLl9uUm91bmRzKVxufVxuXG5BRVMucHJvdG90eXBlLmVuY3J5cHRCbG9jayA9IGZ1bmN0aW9uIChNKSB7XG4gIHZhciBvdXQgPSB0aGlzLmVuY3J5cHRCbG9ja1JhdyhNKVxuICB2YXIgYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKDE2KVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbMF0sIDApXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFsxXSwgNClcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzJdLCA4KVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbM10sIDEyKVxuICByZXR1cm4gYnVmXG59XG5cbkFFUy5wcm90b3R5cGUuZGVjcnlwdEJsb2NrID0gZnVuY3Rpb24gKE0pIHtcbiAgTSA9IGFzVUludDMyQXJyYXkoTSlcblxuICAvLyBzd2FwXG4gIHZhciBtMSA9IE1bMV1cbiAgTVsxXSA9IE1bM11cbiAgTVszXSA9IG0xXG5cbiAgdmFyIG91dCA9IGNyeXB0QmxvY2soTSwgdGhpcy5faW52S2V5U2NoZWR1bGUsIEcuSU5WX1NVQl9NSVgsIEcuSU5WX1NCT1gsIHRoaXMuX25Sb3VuZHMpXG4gIHZhciBidWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMTYpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFswXSwgMClcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzNdLCA0KVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbMl0sIDgpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFsxXSwgMTIpXG4gIHJldHVybiBidWZcbn1cblxuQUVTLnByb3RvdHlwZS5zY3J1YiA9IGZ1bmN0aW9uICgpIHtcbiAgc2NydWJWZWModGhpcy5fa2V5U2NoZWR1bGUpXG4gIHNjcnViVmVjKHRoaXMuX2ludktleVNjaGVkdWxlKVxuICBzY3J1YlZlYyh0aGlzLl9rZXkpXG59XG5cbm1vZHVsZS5leHBvcnRzLkFFUyA9IEFFU1xuIiwidmFyIGFlcyA9IHJlcXVpcmUoJy4vYWVzJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ2NpcGhlci1iYXNlJylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBHSEFTSCA9IHJlcXVpcmUoJy4vZ2hhc2gnKVxudmFyIHhvciA9IHJlcXVpcmUoJ2J1ZmZlci14b3InKVxudmFyIGluY3IzMiA9IHJlcXVpcmUoJy4vaW5jcjMyJylcblxuZnVuY3Rpb24geG9yVGVzdCAoYSwgYikge1xuICB2YXIgb3V0ID0gMFxuICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSBvdXQrK1xuXG4gIHZhciBsZW4gPSBNYXRoLm1pbihhLmxlbmd0aCwgYi5sZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBvdXQgKz0gKGFbaV0gXiBiW2ldKVxuICB9XG5cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiBjYWxjSXYgKHNlbGYsIGl2LCBjaykge1xuICBpZiAoaXYubGVuZ3RoID09PSAxMikge1xuICAgIHNlbGYuX2ZpbklEID0gQnVmZmVyLmNvbmNhdChbaXYsIEJ1ZmZlci5mcm9tKFswLCAwLCAwLCAxXSldKVxuICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFtpdiwgQnVmZmVyLmZyb20oWzAsIDAsIDAsIDJdKV0pXG4gIH1cbiAgdmFyIGdoYXNoID0gbmV3IEdIQVNIKGNrKVxuICB2YXIgbGVuID0gaXYubGVuZ3RoXG4gIHZhciB0b1BhZCA9IGxlbiAlIDE2XG4gIGdoYXNoLnVwZGF0ZShpdilcbiAgaWYgKHRvUGFkKSB7XG4gICAgdG9QYWQgPSAxNiAtIHRvUGFkXG4gICAgZ2hhc2gudXBkYXRlKEJ1ZmZlci5hbGxvYyh0b1BhZCwgMCkpXG4gIH1cbiAgZ2hhc2gudXBkYXRlKEJ1ZmZlci5hbGxvYyg4LCAwKSlcbiAgdmFyIGl2Qml0cyA9IGxlbiAqIDhcbiAgdmFyIHRhaWwgPSBCdWZmZXIuYWxsb2MoOClcbiAgdGFpbC53cml0ZVVJbnRCRShpdkJpdHMsIDAsIDgpXG4gIGdoYXNoLnVwZGF0ZSh0YWlsKVxuICBzZWxmLl9maW5JRCA9IGdoYXNoLnN0YXRlXG4gIHZhciBvdXQgPSBCdWZmZXIuZnJvbShzZWxmLl9maW5JRClcbiAgaW5jcjMyKG91dClcbiAgcmV0dXJuIG91dFxufVxuZnVuY3Rpb24gU3RyZWFtQ2lwaGVyIChtb2RlLCBrZXksIGl2LCBkZWNyeXB0KSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMpXG5cbiAgdmFyIGggPSBCdWZmZXIuYWxsb2MoNCwgMClcblxuICB0aGlzLl9jaXBoZXIgPSBuZXcgYWVzLkFFUyhrZXkpXG4gIHZhciBjayA9IHRoaXMuX2NpcGhlci5lbmNyeXB0QmxvY2soaClcbiAgdGhpcy5fZ2hhc2ggPSBuZXcgR0hBU0goY2spXG4gIGl2ID0gY2FsY0l2KHRoaXMsIGl2LCBjaylcblxuICB0aGlzLl9wcmV2ID0gQnVmZmVyLmZyb20oaXYpXG4gIHRoaXMuX2NhY2hlID0gQnVmZmVyLmFsbG9jVW5zYWZlKDApXG4gIHRoaXMuX3NlY0NhY2hlID0gQnVmZmVyLmFsbG9jVW5zYWZlKDApXG4gIHRoaXMuX2RlY3J5cHQgPSBkZWNyeXB0XG4gIHRoaXMuX2FsZW4gPSAwXG4gIHRoaXMuX2xlbiA9IDBcbiAgdGhpcy5fbW9kZSA9IG1vZGVcblxuICB0aGlzLl9hdXRoVGFnID0gbnVsbFxuICB0aGlzLl9jYWxsZWQgPSBmYWxzZVxufVxuXG5pbmhlcml0cyhTdHJlYW1DaXBoZXIsIFRyYW5zZm9ybSlcblxuU3RyZWFtQ2lwaGVyLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIGlmICghdGhpcy5fY2FsbGVkICYmIHRoaXMuX2FsZW4pIHtcbiAgICB2YXIgcnVtcCA9IDE2IC0gKHRoaXMuX2FsZW4gJSAxNilcbiAgICBpZiAocnVtcCA8IDE2KSB7XG4gICAgICBydW1wID0gQnVmZmVyLmFsbG9jKHJ1bXAsIDApXG4gICAgICB0aGlzLl9naGFzaC51cGRhdGUocnVtcClcbiAgICB9XG4gIH1cblxuICB0aGlzLl9jYWxsZWQgPSB0cnVlXG4gIHZhciBvdXQgPSB0aGlzLl9tb2RlLmVuY3J5cHQodGhpcywgY2h1bmspXG4gIGlmICh0aGlzLl9kZWNyeXB0KSB7XG4gICAgdGhpcy5fZ2hhc2gudXBkYXRlKGNodW5rKVxuICB9IGVsc2Uge1xuICAgIHRoaXMuX2doYXNoLnVwZGF0ZShvdXQpXG4gIH1cbiAgdGhpcy5fbGVuICs9IGNodW5rLmxlbmd0aFxuICByZXR1cm4gb3V0XG59XG5cblN0cmVhbUNpcGhlci5wcm90b3R5cGUuX2ZpbmFsID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5fZGVjcnlwdCAmJiAhdGhpcy5fYXV0aFRhZykgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBzdGF0ZSBvciB1bmFibGUgdG8gYXV0aGVudGljYXRlIGRhdGEnKVxuXG4gIHZhciB0YWcgPSB4b3IodGhpcy5fZ2hhc2guZmluYWwodGhpcy5fYWxlbiAqIDgsIHRoaXMuX2xlbiAqIDgpLCB0aGlzLl9jaXBoZXIuZW5jcnlwdEJsb2NrKHRoaXMuX2ZpbklEKSlcbiAgaWYgKHRoaXMuX2RlY3J5cHQgJiYgeG9yVGVzdCh0YWcsIHRoaXMuX2F1dGhUYWcpKSB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHN0YXRlIG9yIHVuYWJsZSB0byBhdXRoZW50aWNhdGUgZGF0YScpXG5cbiAgdGhpcy5fYXV0aFRhZyA9IHRhZ1xuICB0aGlzLl9jaXBoZXIuc2NydWIoKVxufVxuXG5TdHJlYW1DaXBoZXIucHJvdG90eXBlLmdldEF1dGhUYWcgPSBmdW5jdGlvbiBnZXRBdXRoVGFnICgpIHtcbiAgaWYgKHRoaXMuX2RlY3J5cHQgfHwgIUJ1ZmZlci5pc0J1ZmZlcih0aGlzLl9hdXRoVGFnKSkgdGhyb3cgbmV3IEVycm9yKCdBdHRlbXB0aW5nIHRvIGdldCBhdXRoIHRhZyBpbiB1bnN1cHBvcnRlZCBzdGF0ZScpXG5cbiAgcmV0dXJuIHRoaXMuX2F1dGhUYWdcbn1cblxuU3RyZWFtQ2lwaGVyLnByb3RvdHlwZS5zZXRBdXRoVGFnID0gZnVuY3Rpb24gc2V0QXV0aFRhZyAodGFnKSB7XG4gIGlmICghdGhpcy5fZGVjcnlwdCkgdGhyb3cgbmV3IEVycm9yKCdBdHRlbXB0aW5nIHRvIHNldCBhdXRoIHRhZyBpbiB1bnN1cHBvcnRlZCBzdGF0ZScpXG5cbiAgdGhpcy5fYXV0aFRhZyA9IHRhZ1xufVxuXG5TdHJlYW1DaXBoZXIucHJvdG90eXBlLnNldEFBRCA9IGZ1bmN0aW9uIHNldEFBRCAoYnVmKSB7XG4gIGlmICh0aGlzLl9jYWxsZWQpIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGluZyB0byBzZXQgQUFEIGluIHVuc3VwcG9ydGVkIHN0YXRlJylcblxuICB0aGlzLl9naGFzaC51cGRhdGUoYnVmKVxuICB0aGlzLl9hbGVuICs9IGJ1Zi5sZW5ndGhcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW1DaXBoZXJcbiIsInZhciBjaXBoZXJzID0gcmVxdWlyZSgnLi9lbmNyeXB0ZXInKVxudmFyIGRlY2lwaGVycyA9IHJlcXVpcmUoJy4vZGVjcnlwdGVyJylcbnZhciBtb2RlcyA9IHJlcXVpcmUoJy4vbW9kZXMvbGlzdC5qc29uJylcblxuZnVuY3Rpb24gZ2V0Q2lwaGVycyAoKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhtb2Rlcylcbn1cblxuZXhwb3J0cy5jcmVhdGVDaXBoZXIgPSBleHBvcnRzLkNpcGhlciA9IGNpcGhlcnMuY3JlYXRlQ2lwaGVyXG5leHBvcnRzLmNyZWF0ZUNpcGhlcml2ID0gZXhwb3J0cy5DaXBoZXJpdiA9IGNpcGhlcnMuY3JlYXRlQ2lwaGVyaXZcbmV4cG9ydHMuY3JlYXRlRGVjaXBoZXIgPSBleHBvcnRzLkRlY2lwaGVyID0gZGVjaXBoZXJzLmNyZWF0ZURlY2lwaGVyXG5leHBvcnRzLmNyZWF0ZURlY2lwaGVyaXYgPSBleHBvcnRzLkRlY2lwaGVyaXYgPSBkZWNpcGhlcnMuY3JlYXRlRGVjaXBoZXJpdlxuZXhwb3J0cy5saXN0Q2lwaGVycyA9IGV4cG9ydHMuZ2V0Q2lwaGVycyA9IGdldENpcGhlcnNcbiIsInZhciBBdXRoQ2lwaGVyID0gcmVxdWlyZSgnLi9hdXRoQ2lwaGVyJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxudmFyIE1PREVTID0gcmVxdWlyZSgnLi9tb2RlcycpXG52YXIgU3RyZWFtQ2lwaGVyID0gcmVxdWlyZSgnLi9zdHJlYW1DaXBoZXInKVxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ2NpcGhlci1iYXNlJylcbnZhciBhZXMgPSByZXF1aXJlKCcuL2FlcycpXG52YXIgZWJ0ayA9IHJlcXVpcmUoJ2V2cF9ieXRlc3Rva2V5JylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcblxuZnVuY3Rpb24gRGVjaXBoZXIgKG1vZGUsIGtleSwgaXYpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcylcblxuICB0aGlzLl9jYWNoZSA9IG5ldyBTcGxpdHRlcigpXG4gIHRoaXMuX2xhc3QgPSB2b2lkIDBcbiAgdGhpcy5fY2lwaGVyID0gbmV3IGFlcy5BRVMoa2V5KVxuICB0aGlzLl9wcmV2ID0gQnVmZmVyLmZyb20oaXYpXG4gIHRoaXMuX21vZGUgPSBtb2RlXG4gIHRoaXMuX2F1dG9wYWRkaW5nID0gdHJ1ZVxufVxuXG5pbmhlcml0cyhEZWNpcGhlciwgVHJhbnNmb3JtKVxuXG5EZWNpcGhlci5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuX2NhY2hlLmFkZChkYXRhKVxuICB2YXIgY2h1bmtcbiAgdmFyIHRoaW5nXG4gIHZhciBvdXQgPSBbXVxuICB3aGlsZSAoKGNodW5rID0gdGhpcy5fY2FjaGUuZ2V0KHRoaXMuX2F1dG9wYWRkaW5nKSkpIHtcbiAgICB0aGluZyA9IHRoaXMuX21vZGUuZGVjcnlwdCh0aGlzLCBjaHVuaylcbiAgICBvdXQucHVzaCh0aGluZylcbiAgfVxuICByZXR1cm4gQnVmZmVyLmNvbmNhdChvdXQpXG59XG5cbkRlY2lwaGVyLnByb3RvdHlwZS5fZmluYWwgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjaHVuayA9IHRoaXMuX2NhY2hlLmZsdXNoKClcbiAgaWYgKHRoaXMuX2F1dG9wYWRkaW5nKSB7XG4gICAgcmV0dXJuIHVucGFkKHRoaXMuX21vZGUuZGVjcnlwdCh0aGlzLCBjaHVuaykpXG4gIH0gZWxzZSBpZiAoY2h1bmspIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2RhdGEgbm90IG11bHRpcGxlIG9mIGJsb2NrIGxlbmd0aCcpXG4gIH1cbn1cblxuRGVjaXBoZXIucHJvdG90eXBlLnNldEF1dG9QYWRkaW5nID0gZnVuY3Rpb24gKHNldFRvKSB7XG4gIHRoaXMuX2F1dG9wYWRkaW5nID0gISFzZXRUb1xuICByZXR1cm4gdGhpc1xufVxuXG5mdW5jdGlvbiBTcGxpdHRlciAoKSB7XG4gIHRoaXMuY2FjaGUgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMClcbn1cblxuU3BsaXR0ZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuY2FjaGUgPSBCdWZmZXIuY29uY2F0KFt0aGlzLmNhY2hlLCBkYXRhXSlcbn1cblxuU3BsaXR0ZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChhdXRvUGFkZGluZykge1xuICB2YXIgb3V0XG4gIGlmIChhdXRvUGFkZGluZykge1xuICAgIGlmICh0aGlzLmNhY2hlLmxlbmd0aCA+IDE2KSB7XG4gICAgICBvdXQgPSB0aGlzLmNhY2hlLnNsaWNlKDAsIDE2KVxuICAgICAgdGhpcy5jYWNoZSA9IHRoaXMuY2FjaGUuc2xpY2UoMTYpXG4gICAgICByZXR1cm4gb3V0XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh0aGlzLmNhY2hlLmxlbmd0aCA+PSAxNikge1xuICAgICAgb3V0ID0gdGhpcy5jYWNoZS5zbGljZSgwLCAxNilcbiAgICAgIHRoaXMuY2FjaGUgPSB0aGlzLmNhY2hlLnNsaWNlKDE2KVxuICAgICAgcmV0dXJuIG91dFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG5cblNwbGl0dGVyLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuY2FjaGUubGVuZ3RoKSByZXR1cm4gdGhpcy5jYWNoZVxufVxuXG5mdW5jdGlvbiB1bnBhZCAobGFzdCkge1xuICB2YXIgcGFkZGVkID0gbGFzdFsxNV1cbiAgaWYgKHBhZGRlZCA8IDEgfHwgcGFkZGVkID4gMTYpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuYWJsZSB0byBkZWNyeXB0IGRhdGEnKVxuICB9XG4gIHZhciBpID0gLTFcbiAgd2hpbGUgKCsraSA8IHBhZGRlZCkge1xuICAgIGlmIChsYXN0WyhpICsgKDE2IC0gcGFkZGVkKSldICE9PSBwYWRkZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndW5hYmxlIHRvIGRlY3J5cHQgZGF0YScpXG4gICAgfVxuICB9XG4gIGlmIChwYWRkZWQgPT09IDE2KSByZXR1cm5cblxuICByZXR1cm4gbGFzdC5zbGljZSgwLCAxNiAtIHBhZGRlZClcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGVjaXBoZXJpdiAoc3VpdGUsIHBhc3N3b3JkLCBpdikge1xuICB2YXIgY29uZmlnID0gTU9ERVNbc3VpdGUudG9Mb3dlckNhc2UoKV1cbiAgaWYgKCFjb25maWcpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgc3VpdGUgdHlwZScpXG5cbiAgaWYgKHR5cGVvZiBpdiA9PT0gJ3N0cmluZycpIGl2ID0gQnVmZmVyLmZyb20oaXYpXG4gIGlmIChjb25maWcubW9kZSAhPT0gJ0dDTScgJiYgaXYubGVuZ3RoICE9PSBjb25maWcuaXYpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgaXYgbGVuZ3RoICcgKyBpdi5sZW5ndGgpXG5cbiAgaWYgKHR5cGVvZiBwYXNzd29yZCA9PT0gJ3N0cmluZycpIHBhc3N3b3JkID0gQnVmZmVyLmZyb20ocGFzc3dvcmQpXG4gIGlmIChwYXNzd29yZC5sZW5ndGggIT09IGNvbmZpZy5rZXkgLyA4KSB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGtleSBsZW5ndGggJyArIHBhc3N3b3JkLmxlbmd0aClcblxuICBpZiAoY29uZmlnLnR5cGUgPT09ICdzdHJlYW0nKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJlYW1DaXBoZXIoY29uZmlnLm1vZHVsZSwgcGFzc3dvcmQsIGl2LCB0cnVlKVxuICB9IGVsc2UgaWYgKGNvbmZpZy50eXBlID09PSAnYXV0aCcpIHtcbiAgICByZXR1cm4gbmV3IEF1dGhDaXBoZXIoY29uZmlnLm1vZHVsZSwgcGFzc3dvcmQsIGl2LCB0cnVlKVxuICB9XG5cbiAgcmV0dXJuIG5ldyBEZWNpcGhlcihjb25maWcubW9kdWxlLCBwYXNzd29yZCwgaXYpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURlY2lwaGVyIChzdWl0ZSwgcGFzc3dvcmQpIHtcbiAgdmFyIGNvbmZpZyA9IE1PREVTW3N1aXRlLnRvTG93ZXJDYXNlKCldXG4gIGlmICghY29uZmlnKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHN1aXRlIHR5cGUnKVxuXG4gIHZhciBrZXlzID0gZWJ0ayhwYXNzd29yZCwgZmFsc2UsIGNvbmZpZy5rZXksIGNvbmZpZy5pdilcbiAgcmV0dXJuIGNyZWF0ZURlY2lwaGVyaXYoc3VpdGUsIGtleXMua2V5LCBrZXlzLml2KVxufVxuXG5leHBvcnRzLmNyZWF0ZURlY2lwaGVyID0gY3JlYXRlRGVjaXBoZXJcbmV4cG9ydHMuY3JlYXRlRGVjaXBoZXJpdiA9IGNyZWF0ZURlY2lwaGVyaXZcbiIsInZhciBNT0RFUyA9IHJlcXVpcmUoJy4vbW9kZXMnKVxudmFyIEF1dGhDaXBoZXIgPSByZXF1aXJlKCcuL2F1dGhDaXBoZXInKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG52YXIgU3RyZWFtQ2lwaGVyID0gcmVxdWlyZSgnLi9zdHJlYW1DaXBoZXInKVxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ2NpcGhlci1iYXNlJylcbnZhciBhZXMgPSByZXF1aXJlKCcuL2FlcycpXG52YXIgZWJ0ayA9IHJlcXVpcmUoJ2V2cF9ieXRlc3Rva2V5JylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcblxuZnVuY3Rpb24gQ2lwaGVyIChtb2RlLCBrZXksIGl2KSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMpXG5cbiAgdGhpcy5fY2FjaGUgPSBuZXcgU3BsaXR0ZXIoKVxuICB0aGlzLl9jaXBoZXIgPSBuZXcgYWVzLkFFUyhrZXkpXG4gIHRoaXMuX3ByZXYgPSBCdWZmZXIuZnJvbShpdilcbiAgdGhpcy5fbW9kZSA9IG1vZGVcbiAgdGhpcy5fYXV0b3BhZGRpbmcgPSB0cnVlXG59XG5cbmluaGVyaXRzKENpcGhlciwgVHJhbnNmb3JtKVxuXG5DaXBoZXIucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB0aGlzLl9jYWNoZS5hZGQoZGF0YSlcbiAgdmFyIGNodW5rXG4gIHZhciB0aGluZ1xuICB2YXIgb3V0ID0gW11cblxuICB3aGlsZSAoKGNodW5rID0gdGhpcy5fY2FjaGUuZ2V0KCkpKSB7XG4gICAgdGhpbmcgPSB0aGlzLl9tb2RlLmVuY3J5cHQodGhpcywgY2h1bmspXG4gICAgb3V0LnB1c2godGhpbmcpXG4gIH1cblxuICByZXR1cm4gQnVmZmVyLmNvbmNhdChvdXQpXG59XG5cbnZhciBQQURESU5HID0gQnVmZmVyLmFsbG9jKDE2LCAweDEwKVxuXG5DaXBoZXIucHJvdG90eXBlLl9maW5hbCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNodW5rID0gdGhpcy5fY2FjaGUuZmx1c2goKVxuICBpZiAodGhpcy5fYXV0b3BhZGRpbmcpIHtcbiAgICBjaHVuayA9IHRoaXMuX21vZGUuZW5jcnlwdCh0aGlzLCBjaHVuaylcbiAgICB0aGlzLl9jaXBoZXIuc2NydWIoKVxuICAgIHJldHVybiBjaHVua1xuICB9XG5cbiAgaWYgKCFjaHVuay5lcXVhbHMoUEFERElORykpIHtcbiAgICB0aGlzLl9jaXBoZXIuc2NydWIoKVxuICAgIHRocm93IG5ldyBFcnJvcignZGF0YSBub3QgbXVsdGlwbGUgb2YgYmxvY2sgbGVuZ3RoJylcbiAgfVxufVxuXG5DaXBoZXIucHJvdG90eXBlLnNldEF1dG9QYWRkaW5nID0gZnVuY3Rpb24gKHNldFRvKSB7XG4gIHRoaXMuX2F1dG9wYWRkaW5nID0gISFzZXRUb1xuICByZXR1cm4gdGhpc1xufVxuXG5mdW5jdGlvbiBTcGxpdHRlciAoKSB7XG4gIHRoaXMuY2FjaGUgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMClcbn1cblxuU3BsaXR0ZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuY2FjaGUgPSBCdWZmZXIuY29uY2F0KFt0aGlzLmNhY2hlLCBkYXRhXSlcbn1cblxuU3BsaXR0ZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuY2FjaGUubGVuZ3RoID4gMTUpIHtcbiAgICB2YXIgb3V0ID0gdGhpcy5jYWNoZS5zbGljZSgwLCAxNilcbiAgICB0aGlzLmNhY2hlID0gdGhpcy5jYWNoZS5zbGljZSgxNilcbiAgICByZXR1cm4gb3V0XG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblxuU3BsaXR0ZXIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbGVuID0gMTYgLSB0aGlzLmNhY2hlLmxlbmd0aFxuICB2YXIgcGFkQnVmZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW4pXG5cbiAgdmFyIGkgPSAtMVxuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgcGFkQnVmZi53cml0ZVVJbnQ4KGxlbiwgaSlcbiAgfVxuXG4gIHJldHVybiBCdWZmZXIuY29uY2F0KFt0aGlzLmNhY2hlLCBwYWRCdWZmXSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ2lwaGVyaXYgKHN1aXRlLCBwYXNzd29yZCwgaXYpIHtcbiAgdmFyIGNvbmZpZyA9IE1PREVTW3N1aXRlLnRvTG93ZXJDYXNlKCldXG4gIGlmICghY29uZmlnKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHN1aXRlIHR5cGUnKVxuXG4gIGlmICh0eXBlb2YgcGFzc3dvcmQgPT09ICdzdHJpbmcnKSBwYXNzd29yZCA9IEJ1ZmZlci5mcm9tKHBhc3N3b3JkKVxuICBpZiAocGFzc3dvcmQubGVuZ3RoICE9PSBjb25maWcua2V5IC8gOCkgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBrZXkgbGVuZ3RoICcgKyBwYXNzd29yZC5sZW5ndGgpXG5cbiAgaWYgKHR5cGVvZiBpdiA9PT0gJ3N0cmluZycpIGl2ID0gQnVmZmVyLmZyb20oaXYpXG4gIGlmIChjb25maWcubW9kZSAhPT0gJ0dDTScgJiYgaXYubGVuZ3RoICE9PSBjb25maWcuaXYpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgaXYgbGVuZ3RoICcgKyBpdi5sZW5ndGgpXG5cbiAgaWYgKGNvbmZpZy50eXBlID09PSAnc3RyZWFtJykge1xuICAgIHJldHVybiBuZXcgU3RyZWFtQ2lwaGVyKGNvbmZpZy5tb2R1bGUsIHBhc3N3b3JkLCBpdilcbiAgfSBlbHNlIGlmIChjb25maWcudHlwZSA9PT0gJ2F1dGgnKSB7XG4gICAgcmV0dXJuIG5ldyBBdXRoQ2lwaGVyKGNvbmZpZy5tb2R1bGUsIHBhc3N3b3JkLCBpdilcbiAgfVxuXG4gIHJldHVybiBuZXcgQ2lwaGVyKGNvbmZpZy5tb2R1bGUsIHBhc3N3b3JkLCBpdilcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ2lwaGVyIChzdWl0ZSwgcGFzc3dvcmQpIHtcbiAgdmFyIGNvbmZpZyA9IE1PREVTW3N1aXRlLnRvTG93ZXJDYXNlKCldXG4gIGlmICghY29uZmlnKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHN1aXRlIHR5cGUnKVxuXG4gIHZhciBrZXlzID0gZWJ0ayhwYXNzd29yZCwgZmFsc2UsIGNvbmZpZy5rZXksIGNvbmZpZy5pdilcbiAgcmV0dXJuIGNyZWF0ZUNpcGhlcml2KHN1aXRlLCBrZXlzLmtleSwga2V5cy5pdilcbn1cblxuZXhwb3J0cy5jcmVhdGVDaXBoZXJpdiA9IGNyZWF0ZUNpcGhlcml2XG5leHBvcnRzLmNyZWF0ZUNpcGhlciA9IGNyZWF0ZUNpcGhlclxuIiwidmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG52YXIgWkVST0VTID0gQnVmZmVyLmFsbG9jKDE2LCAwKVxuXG5mdW5jdGlvbiB0b0FycmF5IChidWYpIHtcbiAgcmV0dXJuIFtcbiAgICBidWYucmVhZFVJbnQzMkJFKDApLFxuICAgIGJ1Zi5yZWFkVUludDMyQkUoNCksXG4gICAgYnVmLnJlYWRVSW50MzJCRSg4KSxcbiAgICBidWYucmVhZFVJbnQzMkJFKDEyKVxuICBdXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheSAob3V0KSB7XG4gIHZhciBidWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMTYpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFswXSA+Pj4gMCwgMClcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzFdID4+PiAwLCA0KVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbMl0gPj4+IDAsIDgpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFszXSA+Pj4gMCwgMTIpXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gR0hBU0ggKGtleSkge1xuICB0aGlzLmggPSBrZXlcbiAgdGhpcy5zdGF0ZSA9IEJ1ZmZlci5hbGxvYygxNiwgMClcbiAgdGhpcy5jYWNoZSA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgwKVxufVxuXG4vLyBmcm9tIGh0dHA6Ly9iaXR3aXNlc2hpZnRsZWZ0LmdpdGh1Yi5pby9zamNsL2RvYy9zeW1ib2xzL3NyYy9jb3JlX2djbS5qcy5odG1sXG4vLyBieSBKdWhvIFbDpGjDpC1IZXJ0dHVhXG5HSEFTSC5wcm90b3R5cGUuZ2hhc2ggPSBmdW5jdGlvbiAoYmxvY2spIHtcbiAgdmFyIGkgPSAtMVxuICB3aGlsZSAoKytpIDwgYmxvY2subGVuZ3RoKSB7XG4gICAgdGhpcy5zdGF0ZVtpXSBePSBibG9ja1tpXVxuICB9XG4gIHRoaXMuX211bHRpcGx5KClcbn1cblxuR0hBU0gucHJvdG90eXBlLl9tdWx0aXBseSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIFZpID0gdG9BcnJheSh0aGlzLmgpXG4gIHZhciBaaSA9IFswLCAwLCAwLCAwXVxuICB2YXIgaiwgeGksIGxzYlZpXG4gIHZhciBpID0gLTFcbiAgd2hpbGUgKCsraSA8IDEyOCkge1xuICAgIHhpID0gKHRoaXMuc3RhdGVbfn4oaSAvIDgpXSAmICgxIDw8ICg3IC0gKGkgJSA4KSkpKSAhPT0gMFxuICAgIGlmICh4aSkge1xuICAgICAgLy8gWl9pKzEgPSBaX2kgXiBWX2lcbiAgICAgIFppWzBdIF49IFZpWzBdXG4gICAgICBaaVsxXSBePSBWaVsxXVxuICAgICAgWmlbMl0gXj0gVmlbMl1cbiAgICAgIFppWzNdIF49IFZpWzNdXG4gICAgfVxuXG4gICAgLy8gU3RvcmUgdGhlIHZhbHVlIG9mIExTQihWX2kpXG4gICAgbHNiVmkgPSAoVmlbM10gJiAxKSAhPT0gMFxuXG4gICAgLy8gVl9pKzEgPSBWX2kgPj4gMVxuICAgIGZvciAoaiA9IDM7IGogPiAwOyBqLS0pIHtcbiAgICAgIFZpW2pdID0gKFZpW2pdID4+PiAxKSB8ICgoVmlbaiAtIDFdICYgMSkgPDwgMzEpXG4gICAgfVxuICAgIFZpWzBdID0gVmlbMF0gPj4+IDFcblxuICAgIC8vIElmIExTQihWX2kpIGlzIDEsIFZfaSsxID0gKFZfaSA+PiAxKSBeIFJcbiAgICBpZiAobHNiVmkpIHtcbiAgICAgIFZpWzBdID0gVmlbMF0gXiAoMHhlMSA8PCAyNClcbiAgICB9XG4gIH1cbiAgdGhpcy5zdGF0ZSA9IGZyb21BcnJheShaaSlcbn1cblxuR0hBU0gucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChidWYpIHtcbiAgdGhpcy5jYWNoZSA9IEJ1ZmZlci5jb25jYXQoW3RoaXMuY2FjaGUsIGJ1Zl0pXG4gIHZhciBjaHVua1xuICB3aGlsZSAodGhpcy5jYWNoZS5sZW5ndGggPj0gMTYpIHtcbiAgICBjaHVuayA9IHRoaXMuY2FjaGUuc2xpY2UoMCwgMTYpXG4gICAgdGhpcy5jYWNoZSA9IHRoaXMuY2FjaGUuc2xpY2UoMTYpXG4gICAgdGhpcy5naGFzaChjaHVuaylcbiAgfVxufVxuXG5HSEFTSC5wcm90b3R5cGUuZmluYWwgPSBmdW5jdGlvbiAoYWJsLCBibCkge1xuICBpZiAodGhpcy5jYWNoZS5sZW5ndGgpIHtcbiAgICB0aGlzLmdoYXNoKEJ1ZmZlci5jb25jYXQoW3RoaXMuY2FjaGUsIFpFUk9FU10sIDE2KSlcbiAgfVxuXG4gIHRoaXMuZ2hhc2goZnJvbUFycmF5KFswLCBhYmwsIDAsIGJsXSkpXG4gIHJldHVybiB0aGlzLnN0YXRlXG59XG5cbm1vZHVsZS5leHBvcnRzID0gR0hBU0hcbiIsImZ1bmN0aW9uIGluY3IzMiAoaXYpIHtcbiAgdmFyIGxlbiA9IGl2Lmxlbmd0aFxuICB2YXIgaXRlbVxuICB3aGlsZSAobGVuLS0pIHtcbiAgICBpdGVtID0gaXYucmVhZFVJbnQ4KGxlbilcbiAgICBpZiAoaXRlbSA9PT0gMjU1KSB7XG4gICAgICBpdi53cml0ZVVJbnQ4KDAsIGxlbilcbiAgICB9IGVsc2Uge1xuICAgICAgaXRlbSsrXG4gICAgICBpdi53cml0ZVVJbnQ4KGl0ZW0sIGxlbilcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IGluY3IzMlxuIiwidmFyIHhvciA9IHJlcXVpcmUoJ2J1ZmZlci14b3InKVxuXG5leHBvcnRzLmVuY3J5cHQgPSBmdW5jdGlvbiAoc2VsZiwgYmxvY2spIHtcbiAgdmFyIGRhdGEgPSB4b3IoYmxvY2ssIHNlbGYuX3ByZXYpXG5cbiAgc2VsZi5fcHJldiA9IHNlbGYuX2NpcGhlci5lbmNyeXB0QmxvY2soZGF0YSlcbiAgcmV0dXJuIHNlbGYuX3ByZXZcbn1cblxuZXhwb3J0cy5kZWNyeXB0ID0gZnVuY3Rpb24gKHNlbGYsIGJsb2NrKSB7XG4gIHZhciBwYWQgPSBzZWxmLl9wcmV2XG5cbiAgc2VsZi5fcHJldiA9IGJsb2NrXG4gIHZhciBvdXQgPSBzZWxmLl9jaXBoZXIuZGVjcnlwdEJsb2NrKGJsb2NrKVxuXG4gIHJldHVybiB4b3Iob3V0LCBwYWQpXG59XG4iLCJ2YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbnZhciB4b3IgPSByZXF1aXJlKCdidWZmZXIteG9yJylcblxuZnVuY3Rpb24gZW5jcnlwdFN0YXJ0IChzZWxmLCBkYXRhLCBkZWNyeXB0KSB7XG4gIHZhciBsZW4gPSBkYXRhLmxlbmd0aFxuICB2YXIgb3V0ID0geG9yKGRhdGEsIHNlbGYuX2NhY2hlKVxuICBzZWxmLl9jYWNoZSA9IHNlbGYuX2NhY2hlLnNsaWNlKGxlbilcbiAgc2VsZi5fcHJldiA9IEJ1ZmZlci5jb25jYXQoW3NlbGYuX3ByZXYsIGRlY3J5cHQgPyBkYXRhIDogb3V0XSlcbiAgcmV0dXJuIG91dFxufVxuXG5leHBvcnRzLmVuY3J5cHQgPSBmdW5jdGlvbiAoc2VsZiwgZGF0YSwgZGVjcnlwdCkge1xuICB2YXIgb3V0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKDApXG4gIHZhciBsZW5cblxuICB3aGlsZSAoZGF0YS5sZW5ndGgpIHtcbiAgICBpZiAoc2VsZi5fY2FjaGUubGVuZ3RoID09PSAwKSB7XG4gICAgICBzZWxmLl9jYWNoZSA9IHNlbGYuX2NpcGhlci5lbmNyeXB0QmxvY2soc2VsZi5fcHJldilcbiAgICAgIHNlbGYuX3ByZXYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMClcbiAgICB9XG5cbiAgICBpZiAoc2VsZi5fY2FjaGUubGVuZ3RoIDw9IGRhdGEubGVuZ3RoKSB7XG4gICAgICBsZW4gPSBzZWxmLl9jYWNoZS5sZW5ndGhcbiAgICAgIG91dCA9IEJ1ZmZlci5jb25jYXQoW291dCwgZW5jcnlwdFN0YXJ0KHNlbGYsIGRhdGEuc2xpY2UoMCwgbGVuKSwgZGVjcnlwdCldKVxuICAgICAgZGF0YSA9IGRhdGEuc2xpY2UobGVuKVxuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgPSBCdWZmZXIuY29uY2F0KFtvdXQsIGVuY3J5cHRTdGFydChzZWxmLCBkYXRhLCBkZWNyeXB0KV0pXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvdXRcbn1cbiIsInZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG5mdW5jdGlvbiBlbmNyeXB0Qnl0ZSAoc2VsZiwgYnl0ZVBhcmFtLCBkZWNyeXB0KSB7XG4gIHZhciBwYWRcbiAgdmFyIGkgPSAtMVxuICB2YXIgbGVuID0gOFxuICB2YXIgb3V0ID0gMFxuICB2YXIgYml0LCB2YWx1ZVxuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgcGFkID0gc2VsZi5fY2lwaGVyLmVuY3J5cHRCbG9jayhzZWxmLl9wcmV2KVxuICAgIGJpdCA9IChieXRlUGFyYW0gJiAoMSA8PCAoNyAtIGkpKSkgPyAweDgwIDogMFxuICAgIHZhbHVlID0gcGFkWzBdIF4gYml0XG4gICAgb3V0ICs9ICgodmFsdWUgJiAweDgwKSA+PiAoaSAlIDgpKVxuICAgIHNlbGYuX3ByZXYgPSBzaGlmdEluKHNlbGYuX3ByZXYsIGRlY3J5cHQgPyBiaXQgOiB2YWx1ZSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHNoaWZ0SW4gKGJ1ZmZlciwgdmFsdWUpIHtcbiAgdmFyIGxlbiA9IGJ1ZmZlci5sZW5ndGhcbiAgdmFyIGkgPSAtMVxuICB2YXIgb3V0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKGJ1ZmZlci5sZW5ndGgpXG4gIGJ1ZmZlciA9IEJ1ZmZlci5jb25jYXQoW2J1ZmZlciwgQnVmZmVyLmZyb20oW3ZhbHVlXSldKVxuXG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICBvdXRbaV0gPSBidWZmZXJbaV0gPDwgMSB8IGJ1ZmZlcltpICsgMV0gPj4gKDcpXG4gIH1cblxuICByZXR1cm4gb3V0XG59XG5cbmV4cG9ydHMuZW5jcnlwdCA9IGZ1bmN0aW9uIChzZWxmLCBjaHVuaywgZGVjcnlwdCkge1xuICB2YXIgbGVuID0gY2h1bmsubGVuZ3RoXG4gIHZhciBvdXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuKVxuICB2YXIgaSA9IC0xXG5cbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIG91dFtpXSA9IGVuY3J5cHRCeXRlKHNlbGYsIGNodW5rW2ldLCBkZWNyeXB0KVxuICB9XG5cbiAgcmV0dXJuIG91dFxufVxuIiwidmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbmZ1bmN0aW9uIGVuY3J5cHRCeXRlIChzZWxmLCBieXRlUGFyYW0sIGRlY3J5cHQpIHtcbiAgdmFyIHBhZCA9IHNlbGYuX2NpcGhlci5lbmNyeXB0QmxvY2soc2VsZi5fcHJldilcbiAgdmFyIG91dCA9IHBhZFswXSBeIGJ5dGVQYXJhbVxuXG4gIHNlbGYuX3ByZXYgPSBCdWZmZXIuY29uY2F0KFtcbiAgICBzZWxmLl9wcmV2LnNsaWNlKDEpLFxuICAgIEJ1ZmZlci5mcm9tKFtkZWNyeXB0ID8gYnl0ZVBhcmFtIDogb3V0XSlcbiAgXSlcblxuICByZXR1cm4gb3V0XG59XG5cbmV4cG9ydHMuZW5jcnlwdCA9IGZ1bmN0aW9uIChzZWxmLCBjaHVuaywgZGVjcnlwdCkge1xuICB2YXIgbGVuID0gY2h1bmsubGVuZ3RoXG4gIHZhciBvdXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuKVxuICB2YXIgaSA9IC0xXG5cbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIG91dFtpXSA9IGVuY3J5cHRCeXRlKHNlbGYsIGNodW5rW2ldLCBkZWNyeXB0KVxuICB9XG5cbiAgcmV0dXJuIG91dFxufVxuIiwidmFyIHhvciA9IHJlcXVpcmUoJ2J1ZmZlci14b3InKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG52YXIgaW5jcjMyID0gcmVxdWlyZSgnLi4vaW5jcjMyJylcblxuZnVuY3Rpb24gZ2V0QmxvY2sgKHNlbGYpIHtcbiAgdmFyIG91dCA9IHNlbGYuX2NpcGhlci5lbmNyeXB0QmxvY2tSYXcoc2VsZi5fcHJldilcbiAgaW5jcjMyKHNlbGYuX3ByZXYpXG4gIHJldHVybiBvdXRcbn1cblxudmFyIGJsb2NrU2l6ZSA9IDE2XG5leHBvcnRzLmVuY3J5cHQgPSBmdW5jdGlvbiAoc2VsZiwgY2h1bmspIHtcbiAgdmFyIGNodW5rTnVtID0gTWF0aC5jZWlsKGNodW5rLmxlbmd0aCAvIGJsb2NrU2l6ZSlcbiAgdmFyIHN0YXJ0ID0gc2VsZi5fY2FjaGUubGVuZ3RoXG4gIHNlbGYuX2NhY2hlID0gQnVmZmVyLmNvbmNhdChbXG4gICAgc2VsZi5fY2FjaGUsXG4gICAgQnVmZmVyLmFsbG9jVW5zYWZlKGNodW5rTnVtICogYmxvY2tTaXplKVxuICBdKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNodW5rTnVtOyBpKyspIHtcbiAgICB2YXIgb3V0ID0gZ2V0QmxvY2soc2VsZilcbiAgICB2YXIgb2Zmc2V0ID0gc3RhcnQgKyBpICogYmxvY2tTaXplXG4gICAgc2VsZi5fY2FjaGUud3JpdGVVSW50MzJCRShvdXRbMF0sIG9mZnNldCArIDApXG4gICAgc2VsZi5fY2FjaGUud3JpdGVVSW50MzJCRShvdXRbMV0sIG9mZnNldCArIDQpXG4gICAgc2VsZi5fY2FjaGUud3JpdGVVSW50MzJCRShvdXRbMl0sIG9mZnNldCArIDgpXG4gICAgc2VsZi5fY2FjaGUud3JpdGVVSW50MzJCRShvdXRbM10sIG9mZnNldCArIDEyKVxuICB9XG4gIHZhciBwYWQgPSBzZWxmLl9jYWNoZS5zbGljZSgwLCBjaHVuay5sZW5ndGgpXG4gIHNlbGYuX2NhY2hlID0gc2VsZi5fY2FjaGUuc2xpY2UoY2h1bmsubGVuZ3RoKVxuICByZXR1cm4geG9yKGNodW5rLCBwYWQpXG59XG4iLCJleHBvcnRzLmVuY3J5cHQgPSBmdW5jdGlvbiAoc2VsZiwgYmxvY2spIHtcbiAgcmV0dXJuIHNlbGYuX2NpcGhlci5lbmNyeXB0QmxvY2soYmxvY2spXG59XG5cbmV4cG9ydHMuZGVjcnlwdCA9IGZ1bmN0aW9uIChzZWxmLCBibG9jaykge1xuICByZXR1cm4gc2VsZi5fY2lwaGVyLmRlY3J5cHRCbG9jayhibG9jaylcbn1cbiIsInZhciBtb2RlTW9kdWxlcyA9IHtcbiAgRUNCOiByZXF1aXJlKCcuL2VjYicpLFxuICBDQkM6IHJlcXVpcmUoJy4vY2JjJyksXG4gIENGQjogcmVxdWlyZSgnLi9jZmInKSxcbiAgQ0ZCODogcmVxdWlyZSgnLi9jZmI4JyksXG4gIENGQjE6IHJlcXVpcmUoJy4vY2ZiMScpLFxuICBPRkI6IHJlcXVpcmUoJy4vb2ZiJyksXG4gIENUUjogcmVxdWlyZSgnLi9jdHInKSxcbiAgR0NNOiByZXF1aXJlKCcuL2N0cicpXG59XG5cbnZhciBtb2RlcyA9IHJlcXVpcmUoJy4vbGlzdC5qc29uJylcblxuZm9yICh2YXIga2V5IGluIG1vZGVzKSB7XG4gIG1vZGVzW2tleV0ubW9kdWxlID0gbW9kZU1vZHVsZXNbbW9kZXNba2V5XS5tb2RlXVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1vZGVzXG4iLCJ2YXIgeG9yID0gcmVxdWlyZSgnYnVmZmVyLXhvcicpXG5cbmZ1bmN0aW9uIGdldEJsb2NrIChzZWxmKSB7XG4gIHNlbGYuX3ByZXYgPSBzZWxmLl9jaXBoZXIuZW5jcnlwdEJsb2NrKHNlbGYuX3ByZXYpXG4gIHJldHVybiBzZWxmLl9wcmV2XG59XG5cbmV4cG9ydHMuZW5jcnlwdCA9IGZ1bmN0aW9uIChzZWxmLCBjaHVuaykge1xuICB3aGlsZSAoc2VsZi5fY2FjaGUubGVuZ3RoIDwgY2h1bmsubGVuZ3RoKSB7XG4gICAgc2VsZi5fY2FjaGUgPSBCdWZmZXIuY29uY2F0KFtzZWxmLl9jYWNoZSwgZ2V0QmxvY2soc2VsZildKVxuICB9XG5cbiAgdmFyIHBhZCA9IHNlbGYuX2NhY2hlLnNsaWNlKDAsIGNodW5rLmxlbmd0aClcbiAgc2VsZi5fY2FjaGUgPSBzZWxmLl9jYWNoZS5zbGljZShjaHVuay5sZW5ndGgpXG4gIHJldHVybiB4b3IoY2h1bmssIHBhZClcbn1cbiIsInZhciBhZXMgPSByZXF1aXJlKCcuL2FlcycpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCdjaXBoZXItYmFzZScpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG5cbmZ1bmN0aW9uIFN0cmVhbUNpcGhlciAobW9kZSwga2V5LCBpdiwgZGVjcnlwdCkge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzKVxuXG4gIHRoaXMuX2NpcGhlciA9IG5ldyBhZXMuQUVTKGtleSlcbiAgdGhpcy5fcHJldiA9IEJ1ZmZlci5mcm9tKGl2KVxuICB0aGlzLl9jYWNoZSA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgwKVxuICB0aGlzLl9zZWNDYWNoZSA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgwKVxuICB0aGlzLl9kZWNyeXB0ID0gZGVjcnlwdFxuICB0aGlzLl9tb2RlID0gbW9kZVxufVxuXG5pbmhlcml0cyhTdHJlYW1DaXBoZXIsIFRyYW5zZm9ybSlcblxuU3RyZWFtQ2lwaGVyLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHJldHVybiB0aGlzLl9tb2RlLmVuY3J5cHQodGhpcywgY2h1bmssIHRoaXMuX2RlY3J5cHQpXG59XG5cblN0cmVhbUNpcGhlci5wcm90b3R5cGUuX2ZpbmFsID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9jaXBoZXIuc2NydWIoKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmVhbUNpcGhlclxuIiwidmFyIERFUyA9IHJlcXVpcmUoJ2Jyb3dzZXJpZnktZGVzJylcbnZhciBhZXMgPSByZXF1aXJlKCdicm93c2VyaWZ5LWFlcy9icm93c2VyJylcbnZhciBhZXNNb2RlcyA9IHJlcXVpcmUoJ2Jyb3dzZXJpZnktYWVzL21vZGVzJylcbnZhciBkZXNNb2RlcyA9IHJlcXVpcmUoJ2Jyb3dzZXJpZnktZGVzL21vZGVzJylcbnZhciBlYnRrID0gcmVxdWlyZSgnZXZwX2J5dGVzdG9rZXknKVxuXG5mdW5jdGlvbiBjcmVhdGVDaXBoZXIgKHN1aXRlLCBwYXNzd29yZCkge1xuICBzdWl0ZSA9IHN1aXRlLnRvTG93ZXJDYXNlKClcblxuICB2YXIga2V5TGVuLCBpdkxlblxuICBpZiAoYWVzTW9kZXNbc3VpdGVdKSB7XG4gICAga2V5TGVuID0gYWVzTW9kZXNbc3VpdGVdLmtleVxuICAgIGl2TGVuID0gYWVzTW9kZXNbc3VpdGVdLml2XG4gIH0gZWxzZSBpZiAoZGVzTW9kZXNbc3VpdGVdKSB7XG4gICAga2V5TGVuID0gZGVzTW9kZXNbc3VpdGVdLmtleSAqIDhcbiAgICBpdkxlbiA9IGRlc01vZGVzW3N1aXRlXS5pdlxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgc3VpdGUgdHlwZScpXG4gIH1cblxuICB2YXIga2V5cyA9IGVidGsocGFzc3dvcmQsIGZhbHNlLCBrZXlMZW4sIGl2TGVuKVxuICByZXR1cm4gY3JlYXRlQ2lwaGVyaXYoc3VpdGUsIGtleXMua2V5LCBrZXlzLml2KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVEZWNpcGhlciAoc3VpdGUsIHBhc3N3b3JkKSB7XG4gIHN1aXRlID0gc3VpdGUudG9Mb3dlckNhc2UoKVxuXG4gIHZhciBrZXlMZW4sIGl2TGVuXG4gIGlmIChhZXNNb2Rlc1tzdWl0ZV0pIHtcbiAgICBrZXlMZW4gPSBhZXNNb2Rlc1tzdWl0ZV0ua2V5XG4gICAgaXZMZW4gPSBhZXNNb2Rlc1tzdWl0ZV0uaXZcbiAgfSBlbHNlIGlmIChkZXNNb2Rlc1tzdWl0ZV0pIHtcbiAgICBrZXlMZW4gPSBkZXNNb2Rlc1tzdWl0ZV0ua2V5ICogOFxuICAgIGl2TGVuID0gZGVzTW9kZXNbc3VpdGVdLml2XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBzdWl0ZSB0eXBlJylcbiAgfVxuXG4gIHZhciBrZXlzID0gZWJ0ayhwYXNzd29yZCwgZmFsc2UsIGtleUxlbiwgaXZMZW4pXG4gIHJldHVybiBjcmVhdGVEZWNpcGhlcml2KHN1aXRlLCBrZXlzLmtleSwga2V5cy5pdilcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ2lwaGVyaXYgKHN1aXRlLCBrZXksIGl2KSB7XG4gIHN1aXRlID0gc3VpdGUudG9Mb3dlckNhc2UoKVxuICBpZiAoYWVzTW9kZXNbc3VpdGVdKSByZXR1cm4gYWVzLmNyZWF0ZUNpcGhlcml2KHN1aXRlLCBrZXksIGl2KVxuICBpZiAoZGVzTW9kZXNbc3VpdGVdKSByZXR1cm4gbmV3IERFUyh7IGtleToga2V5LCBpdjogaXYsIG1vZGU6IHN1aXRlIH0pXG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBzdWl0ZSB0eXBlJylcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGVjaXBoZXJpdiAoc3VpdGUsIGtleSwgaXYpIHtcbiAgc3VpdGUgPSBzdWl0ZS50b0xvd2VyQ2FzZSgpXG4gIGlmIChhZXNNb2Rlc1tzdWl0ZV0pIHJldHVybiBhZXMuY3JlYXRlRGVjaXBoZXJpdihzdWl0ZSwga2V5LCBpdilcbiAgaWYgKGRlc01vZGVzW3N1aXRlXSkgcmV0dXJuIG5ldyBERVMoeyBrZXk6IGtleSwgaXY6IGl2LCBtb2RlOiBzdWl0ZSwgZGVjcnlwdDogdHJ1ZSB9KVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgc3VpdGUgdHlwZScpXG59XG5cbmZ1bmN0aW9uIGdldENpcGhlcnMgKCkge1xuICByZXR1cm4gT2JqZWN0LmtleXMoZGVzTW9kZXMpLmNvbmNhdChhZXMuZ2V0Q2lwaGVycygpKVxufVxuXG5leHBvcnRzLmNyZWF0ZUNpcGhlciA9IGV4cG9ydHMuQ2lwaGVyID0gY3JlYXRlQ2lwaGVyXG5leHBvcnRzLmNyZWF0ZUNpcGhlcml2ID0gZXhwb3J0cy5DaXBoZXJpdiA9IGNyZWF0ZUNpcGhlcml2XG5leHBvcnRzLmNyZWF0ZURlY2lwaGVyID0gZXhwb3J0cy5EZWNpcGhlciA9IGNyZWF0ZURlY2lwaGVyXG5leHBvcnRzLmNyZWF0ZURlY2lwaGVyaXYgPSBleHBvcnRzLkRlY2lwaGVyaXYgPSBjcmVhdGVEZWNpcGhlcml2XG5leHBvcnRzLmxpc3RDaXBoZXJzID0gZXhwb3J0cy5nZXRDaXBoZXJzID0gZ2V0Q2lwaGVyc1xuIiwidmFyIENpcGhlckJhc2UgPSByZXF1aXJlKCdjaXBoZXItYmFzZScpXG52YXIgZGVzID0gcmVxdWlyZSgnZGVzLmpzJylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG52YXIgbW9kZXMgPSB7XG4gICdkZXMtZWRlMy1jYmMnOiBkZXMuQ0JDLmluc3RhbnRpYXRlKGRlcy5FREUpLFxuICAnZGVzLWVkZTMnOiBkZXMuRURFLFxuICAnZGVzLWVkZS1jYmMnOiBkZXMuQ0JDLmluc3RhbnRpYXRlKGRlcy5FREUpLFxuICAnZGVzLWVkZSc6IGRlcy5FREUsXG4gICdkZXMtY2JjJzogZGVzLkNCQy5pbnN0YW50aWF0ZShkZXMuREVTKSxcbiAgJ2Rlcy1lY2InOiBkZXMuREVTXG59XG5tb2Rlcy5kZXMgPSBtb2Rlc1snZGVzLWNiYyddXG5tb2Rlcy5kZXMzID0gbW9kZXNbJ2Rlcy1lZGUzLWNiYyddXG5tb2R1bGUuZXhwb3J0cyA9IERFU1xuaW5oZXJpdHMoREVTLCBDaXBoZXJCYXNlKVxuZnVuY3Rpb24gREVTIChvcHRzKSB7XG4gIENpcGhlckJhc2UuY2FsbCh0aGlzKVxuICB2YXIgbW9kZU5hbWUgPSBvcHRzLm1vZGUudG9Mb3dlckNhc2UoKVxuICB2YXIgbW9kZSA9IG1vZGVzW21vZGVOYW1lXVxuICB2YXIgdHlwZVxuICBpZiAob3B0cy5kZWNyeXB0KSB7XG4gICAgdHlwZSA9ICdkZWNyeXB0J1xuICB9IGVsc2Uge1xuICAgIHR5cGUgPSAnZW5jcnlwdCdcbiAgfVxuICB2YXIga2V5ID0gb3B0cy5rZXlcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoa2V5KSkge1xuICAgIGtleSA9IEJ1ZmZlci5mcm9tKGtleSlcbiAgfVxuICBpZiAobW9kZU5hbWUgPT09ICdkZXMtZWRlJyB8fCBtb2RlTmFtZSA9PT0gJ2Rlcy1lZGUtY2JjJykge1xuICAgIGtleSA9IEJ1ZmZlci5jb25jYXQoW2tleSwga2V5LnNsaWNlKDAsIDgpXSlcbiAgfVxuICB2YXIgaXYgPSBvcHRzLml2XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGl2KSkge1xuICAgIGl2ID0gQnVmZmVyLmZyb20oaXYpXG4gIH1cbiAgdGhpcy5fZGVzID0gbW9kZS5jcmVhdGUoe1xuICAgIGtleToga2V5LFxuICAgIGl2OiBpdixcbiAgICB0eXBlOiB0eXBlXG4gIH0pXG59XG5ERVMucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICByZXR1cm4gQnVmZmVyLmZyb20odGhpcy5fZGVzLnVwZGF0ZShkYXRhKSlcbn1cbkRFUy5wcm90b3R5cGUuX2ZpbmFsID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gQnVmZmVyLmZyb20odGhpcy5fZGVzLmZpbmFsKCkpXG59XG4iLCJleHBvcnRzWydkZXMtZWNiJ10gPSB7XG4gIGtleTogOCxcbiAgaXY6IDBcbn1cbmV4cG9ydHNbJ2Rlcy1jYmMnXSA9IGV4cG9ydHMuZGVzID0ge1xuICBrZXk6IDgsXG4gIGl2OiA4XG59XG5leHBvcnRzWydkZXMtZWRlMy1jYmMnXSA9IGV4cG9ydHMuZGVzMyA9IHtcbiAga2V5OiAyNCxcbiAgaXY6IDhcbn1cbmV4cG9ydHNbJ2Rlcy1lZGUzJ10gPSB7XG4gIGtleTogMjQsXG4gIGl2OiAwXG59XG5leHBvcnRzWydkZXMtZWRlLWNiYyddID0ge1xuICBrZXk6IDE2LFxuICBpdjogOFxufVxuZXhwb3J0c1snZGVzLWVkZSddID0ge1xuICBrZXk6IDE2LFxuICBpdjogMFxufVxuIiwidmFyIGJuID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciByYW5kb21CeXRlcyA9IHJlcXVpcmUoJ3JhbmRvbWJ5dGVzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGNydDtcbmZ1bmN0aW9uIGJsaW5kKHByaXYpIHtcbiAgdmFyIHIgPSBnZXRyKHByaXYpO1xuICB2YXIgYmxpbmRlciA9IHIudG9SZWQoYm4ubW9udChwcml2Lm1vZHVsdXMpKVxuICAucmVkUG93KG5ldyBibihwcml2LnB1YmxpY0V4cG9uZW50KSkuZnJvbVJlZCgpO1xuICByZXR1cm4ge1xuICAgIGJsaW5kZXI6IGJsaW5kZXIsXG4gICAgdW5ibGluZGVyOnIuaW52bShwcml2Lm1vZHVsdXMpXG4gIH07XG59XG5mdW5jdGlvbiBjcnQobXNnLCBwcml2KSB7XG4gIHZhciBibGluZHMgPSBibGluZChwcml2KTtcbiAgdmFyIGxlbiA9IHByaXYubW9kdWx1cy5ieXRlTGVuZ3RoKCk7XG4gIHZhciBtb2QgPSBibi5tb250KHByaXYubW9kdWx1cyk7XG4gIHZhciBibGluZGVkID0gbmV3IGJuKG1zZykubXVsKGJsaW5kcy5ibGluZGVyKS51bW9kKHByaXYubW9kdWx1cyk7XG4gIHZhciBjMSA9IGJsaW5kZWQudG9SZWQoYm4ubW9udChwcml2LnByaW1lMSkpO1xuICB2YXIgYzIgPSBibGluZGVkLnRvUmVkKGJuLm1vbnQocHJpdi5wcmltZTIpKTtcbiAgdmFyIHFpbnYgPSBwcml2LmNvZWZmaWNpZW50O1xuICB2YXIgcCA9IHByaXYucHJpbWUxO1xuICB2YXIgcSA9IHByaXYucHJpbWUyO1xuICB2YXIgbTEgPSBjMS5yZWRQb3cocHJpdi5leHBvbmVudDEpO1xuICB2YXIgbTIgPSBjMi5yZWRQb3cocHJpdi5leHBvbmVudDIpO1xuICBtMSA9IG0xLmZyb21SZWQoKTtcbiAgbTIgPSBtMi5mcm9tUmVkKCk7XG4gIHZhciBoID0gbTEuaXN1YihtMikuaW11bChxaW52KS51bW9kKHApO1xuICBoLmltdWwocSk7XG4gIG0yLmlhZGQoaCk7XG4gIHJldHVybiBuZXcgQnVmZmVyKG0yLmltdWwoYmxpbmRzLnVuYmxpbmRlcikudW1vZChwcml2Lm1vZHVsdXMpLnRvQXJyYXkoZmFsc2UsIGxlbikpO1xufVxuY3J0LmdldHIgPSBnZXRyO1xuZnVuY3Rpb24gZ2V0cihwcml2KSB7XG4gIHZhciBsZW4gPSBwcml2Lm1vZHVsdXMuYnl0ZUxlbmd0aCgpO1xuICB2YXIgciA9IG5ldyBibihyYW5kb21CeXRlcyhsZW4pKTtcbiAgd2hpbGUgKHIuY21wKHByaXYubW9kdWx1cykgPj0gIDAgfHwgIXIudW1vZChwcml2LnByaW1lMSkgfHwgIXIudW1vZChwcml2LnByaW1lMikpIHtcbiAgICByID0gbmV3IGJuKHJhbmRvbUJ5dGVzKGxlbikpO1xuICB9XG4gIHJldHVybiByO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Jyb3dzZXIvYWxnb3JpdGhtcy5qc29uJylcbiIsInZhciBjcmVhdGVIYXNoID0gcmVxdWlyZSgnY3JlYXRlLWhhc2gnKVxudmFyIHN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgc2lnbiA9IHJlcXVpcmUoJy4vc2lnbicpXG52YXIgdmVyaWZ5ID0gcmVxdWlyZSgnLi92ZXJpZnknKVxuXG52YXIgYWxnb3JpdGhtcyA9IHJlcXVpcmUoJy4vYWxnb3JpdGhtcy5qc29uJylcbk9iamVjdC5rZXlzKGFsZ29yaXRobXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBhbGdvcml0aG1zW2tleV0uaWQgPSBuZXcgQnVmZmVyKGFsZ29yaXRobXNba2V5XS5pZCwgJ2hleCcpXG4gIGFsZ29yaXRobXNba2V5LnRvTG93ZXJDYXNlKCldID0gYWxnb3JpdGhtc1trZXldXG59KVxuXG5mdW5jdGlvbiBTaWduIChhbGdvcml0aG0pIHtcbiAgc3RyZWFtLldyaXRhYmxlLmNhbGwodGhpcylcblxuICB2YXIgZGF0YSA9IGFsZ29yaXRobXNbYWxnb3JpdGhtXVxuICBpZiAoIWRhdGEpIHRocm93IG5ldyBFcnJvcignVW5rbm93biBtZXNzYWdlIGRpZ2VzdCcpXG5cbiAgdGhpcy5faGFzaFR5cGUgPSBkYXRhLmhhc2hcbiAgdGhpcy5faGFzaCA9IGNyZWF0ZUhhc2goZGF0YS5oYXNoKVxuICB0aGlzLl90YWcgPSBkYXRhLmlkXG4gIHRoaXMuX3NpZ25UeXBlID0gZGF0YS5zaWduXG59XG5pbmhlcml0cyhTaWduLCBzdHJlYW0uV3JpdGFibGUpXG5cblNpZ24ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIF93cml0ZSAoZGF0YSwgXywgZG9uZSkge1xuICB0aGlzLl9oYXNoLnVwZGF0ZShkYXRhKVxuICBkb25lKClcbn1cblxuU2lnbi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlIChkYXRhLCBlbmMpIHtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykgZGF0YSA9IG5ldyBCdWZmZXIoZGF0YSwgZW5jKVxuXG4gIHRoaXMuX2hhc2gudXBkYXRlKGRhdGEpXG4gIHJldHVybiB0aGlzXG59XG5cblNpZ24ucHJvdG90eXBlLnNpZ24gPSBmdW5jdGlvbiBzaWduTWV0aG9kIChrZXksIGVuYykge1xuICB0aGlzLmVuZCgpXG4gIHZhciBoYXNoID0gdGhpcy5faGFzaC5kaWdlc3QoKVxuICB2YXIgc2lnID0gc2lnbihoYXNoLCBrZXksIHRoaXMuX2hhc2hUeXBlLCB0aGlzLl9zaWduVHlwZSwgdGhpcy5fdGFnKVxuXG4gIHJldHVybiBlbmMgPyBzaWcudG9TdHJpbmcoZW5jKSA6IHNpZ1xufVxuXG5mdW5jdGlvbiBWZXJpZnkgKGFsZ29yaXRobSkge1xuICBzdHJlYW0uV3JpdGFibGUuY2FsbCh0aGlzKVxuXG4gIHZhciBkYXRhID0gYWxnb3JpdGhtc1thbGdvcml0aG1dXG4gIGlmICghZGF0YSkgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIG1lc3NhZ2UgZGlnZXN0JylcblxuICB0aGlzLl9oYXNoID0gY3JlYXRlSGFzaChkYXRhLmhhc2gpXG4gIHRoaXMuX3RhZyA9IGRhdGEuaWRcbiAgdGhpcy5fc2lnblR5cGUgPSBkYXRhLnNpZ25cbn1cbmluaGVyaXRzKFZlcmlmeSwgc3RyZWFtLldyaXRhYmxlKVxuXG5WZXJpZnkucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIF93cml0ZSAoZGF0YSwgXywgZG9uZSkge1xuICB0aGlzLl9oYXNoLnVwZGF0ZShkYXRhKVxuICBkb25lKClcbn1cblxuVmVyaWZ5LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKGRhdGEsIGVuYykge1xuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSBkYXRhID0gbmV3IEJ1ZmZlcihkYXRhLCBlbmMpXG5cbiAgdGhpcy5faGFzaC51cGRhdGUoZGF0YSlcbiAgcmV0dXJuIHRoaXNcbn1cblxuVmVyaWZ5LnByb3RvdHlwZS52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnlNZXRob2QgKGtleSwgc2lnLCBlbmMpIHtcbiAgaWYgKHR5cGVvZiBzaWcgPT09ICdzdHJpbmcnKSBzaWcgPSBuZXcgQnVmZmVyKHNpZywgZW5jKVxuXG4gIHRoaXMuZW5kKClcbiAgdmFyIGhhc2ggPSB0aGlzLl9oYXNoLmRpZ2VzdCgpXG4gIHJldHVybiB2ZXJpZnkoc2lnLCBoYXNoLCBrZXksIHRoaXMuX3NpZ25UeXBlLCB0aGlzLl90YWcpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVNpZ24gKGFsZ29yaXRobSkge1xuICByZXR1cm4gbmV3IFNpZ24oYWxnb3JpdGhtKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVWZXJpZnkgKGFsZ29yaXRobSkge1xuICByZXR1cm4gbmV3IFZlcmlmeShhbGdvcml0aG0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBTaWduOiBjcmVhdGVTaWduLFxuICBWZXJpZnk6IGNyZWF0ZVZlcmlmeSxcbiAgY3JlYXRlU2lnbjogY3JlYXRlU2lnbixcbiAgY3JlYXRlVmVyaWZ5OiBjcmVhdGVWZXJpZnlcbn1cbiIsIi8vIG11Y2ggb2YgdGhpcyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9zZWxmLXNpZ25lZC9ibG9iL2doLXBhZ2VzL2xpYi9yc2EuanNcbnZhciBjcmVhdGVIbWFjID0gcmVxdWlyZSgnY3JlYXRlLWhtYWMnKVxudmFyIGNydCA9IHJlcXVpcmUoJ2Jyb3dzZXJpZnktcnNhJylcbnZhciBFQyA9IHJlcXVpcmUoJ2VsbGlwdGljJykuZWNcbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJylcbnZhciBwYXJzZUtleXMgPSByZXF1aXJlKCdwYXJzZS1hc24xJylcbnZhciBjdXJ2ZXMgPSByZXF1aXJlKCcuL2N1cnZlcy5qc29uJylcblxuZnVuY3Rpb24gc2lnbiAoaGFzaCwga2V5LCBoYXNoVHlwZSwgc2lnblR5cGUsIHRhZykge1xuICB2YXIgcHJpdiA9IHBhcnNlS2V5cyhrZXkpXG4gIGlmIChwcml2LmN1cnZlKSB7XG4gICAgLy8gcnNhIGtleXMgY2FuIGJlIGludGVycHJldGVkIGFzIGVjZHNhIG9uZXMgaW4gb3BlbnNzbFxuICAgIGlmIChzaWduVHlwZSAhPT0gJ2VjZHNhJyAmJiBzaWduVHlwZSAhPT0gJ2VjZHNhL3JzYScpIHRocm93IG5ldyBFcnJvcignd3JvbmcgcHJpdmF0ZSBrZXkgdHlwZScpXG4gICAgcmV0dXJuIGVjU2lnbihoYXNoLCBwcml2KVxuICB9IGVsc2UgaWYgKHByaXYudHlwZSA9PT0gJ2RzYScpIHtcbiAgICBpZiAoc2lnblR5cGUgIT09ICdkc2EnKSB0aHJvdyBuZXcgRXJyb3IoJ3dyb25nIHByaXZhdGUga2V5IHR5cGUnKVxuICAgIHJldHVybiBkc2FTaWduKGhhc2gsIHByaXYsIGhhc2hUeXBlKVxuICB9IGVsc2Uge1xuICAgIGlmIChzaWduVHlwZSAhPT0gJ3JzYScgJiYgc2lnblR5cGUgIT09ICdlY2RzYS9yc2EnKSB0aHJvdyBuZXcgRXJyb3IoJ3dyb25nIHByaXZhdGUga2V5IHR5cGUnKVxuICB9XG4gIGhhc2ggPSBCdWZmZXIuY29uY2F0KFt0YWcsIGhhc2hdKVxuICB2YXIgbGVuID0gcHJpdi5tb2R1bHVzLmJ5dGVMZW5ndGgoKVxuICB2YXIgcGFkID0gWyAwLCAxIF1cbiAgd2hpbGUgKGhhc2gubGVuZ3RoICsgcGFkLmxlbmd0aCArIDEgPCBsZW4pIHBhZC5wdXNoKDB4ZmYpXG4gIHBhZC5wdXNoKDB4MDApXG4gIHZhciBpID0gLTFcbiAgd2hpbGUgKCsraSA8IGhhc2gubGVuZ3RoKSBwYWQucHVzaChoYXNoW2ldKVxuXG4gIHZhciBvdXQgPSBjcnQocGFkLCBwcml2KVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIGVjU2lnbiAoaGFzaCwgcHJpdikge1xuICB2YXIgY3VydmVJZCA9IGN1cnZlc1twcml2LmN1cnZlLmpvaW4oJy4nKV1cbiAgaWYgKCFjdXJ2ZUlkKSB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gY3VydmUgJyArIHByaXYuY3VydmUuam9pbignLicpKVxuXG4gIHZhciBjdXJ2ZSA9IG5ldyBFQyhjdXJ2ZUlkKVxuICB2YXIga2V5ID0gY3VydmUua2V5RnJvbVByaXZhdGUocHJpdi5wcml2YXRlS2V5KVxuICB2YXIgb3V0ID0ga2V5LnNpZ24oaGFzaClcblxuICByZXR1cm4gbmV3IEJ1ZmZlcihvdXQudG9ERVIoKSlcbn1cblxuZnVuY3Rpb24gZHNhU2lnbiAoaGFzaCwgcHJpdiwgYWxnbykge1xuICB2YXIgeCA9IHByaXYucGFyYW1zLnByaXZfa2V5XG4gIHZhciBwID0gcHJpdi5wYXJhbXMucFxuICB2YXIgcSA9IHByaXYucGFyYW1zLnFcbiAgdmFyIGcgPSBwcml2LnBhcmFtcy5nXG4gIHZhciByID0gbmV3IEJOKDApXG4gIHZhciBrXG4gIHZhciBIID0gYml0czJpbnQoaGFzaCwgcSkubW9kKHEpXG4gIHZhciBzID0gZmFsc2VcbiAgdmFyIGt2ID0gZ2V0S2V5KHgsIHEsIGhhc2gsIGFsZ28pXG4gIHdoaWxlIChzID09PSBmYWxzZSkge1xuICAgIGsgPSBtYWtlS2V5KHEsIGt2LCBhbGdvKVxuICAgIHIgPSBtYWtlUihnLCBrLCBwLCBxKVxuICAgIHMgPSBrLmludm0ocSkuaW11bChILmFkZCh4Lm11bChyKSkpLm1vZChxKVxuICAgIGlmIChzLmNtcG4oMCkgPT09IDApIHtcbiAgICAgIHMgPSBmYWxzZVxuICAgICAgciA9IG5ldyBCTigwKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdG9ERVIociwgcylcbn1cblxuZnVuY3Rpb24gdG9ERVIgKHIsIHMpIHtcbiAgciA9IHIudG9BcnJheSgpXG4gIHMgPSBzLnRvQXJyYXkoKVxuXG4gIC8vIFBhZCB2YWx1ZXNcbiAgaWYgKHJbMF0gJiAweDgwKSByID0gWyAwIF0uY29uY2F0KHIpXG4gIGlmIChzWzBdICYgMHg4MCkgcyA9IFsgMCBdLmNvbmNhdChzKVxuXG4gIHZhciB0b3RhbCA9IHIubGVuZ3RoICsgcy5sZW5ndGggKyA0XG4gIHZhciByZXMgPSBbIDB4MzAsIHRvdGFsLCAweDAyLCByLmxlbmd0aCBdXG4gIHJlcyA9IHJlcy5jb25jYXQociwgWyAweDAyLCBzLmxlbmd0aCBdLCBzKVxuICByZXR1cm4gbmV3IEJ1ZmZlcihyZXMpXG59XG5cbmZ1bmN0aW9uIGdldEtleSAoeCwgcSwgaGFzaCwgYWxnbykge1xuICB4ID0gbmV3IEJ1ZmZlcih4LnRvQXJyYXkoKSlcbiAgaWYgKHgubGVuZ3RoIDwgcS5ieXRlTGVuZ3RoKCkpIHtcbiAgICB2YXIgemVyb3MgPSBuZXcgQnVmZmVyKHEuYnl0ZUxlbmd0aCgpIC0geC5sZW5ndGgpXG4gICAgemVyb3MuZmlsbCgwKVxuICAgIHggPSBCdWZmZXIuY29uY2F0KFsgemVyb3MsIHggXSlcbiAgfVxuICB2YXIgaGxlbiA9IGhhc2gubGVuZ3RoXG4gIHZhciBoYml0cyA9IGJpdHMyb2N0ZXRzKGhhc2gsIHEpXG4gIHZhciB2ID0gbmV3IEJ1ZmZlcihobGVuKVxuICB2LmZpbGwoMSlcbiAgdmFyIGsgPSBuZXcgQnVmZmVyKGhsZW4pXG4gIGsuZmlsbCgwKVxuICBrID0gY3JlYXRlSG1hYyhhbGdvLCBrKS51cGRhdGUodikudXBkYXRlKG5ldyBCdWZmZXIoWyAwIF0pKS51cGRhdGUoeCkudXBkYXRlKGhiaXRzKS5kaWdlc3QoKVxuICB2ID0gY3JlYXRlSG1hYyhhbGdvLCBrKS51cGRhdGUodikuZGlnZXN0KClcbiAgayA9IGNyZWF0ZUhtYWMoYWxnbywgaykudXBkYXRlKHYpLnVwZGF0ZShuZXcgQnVmZmVyKFsgMSBdKSkudXBkYXRlKHgpLnVwZGF0ZShoYml0cykuZGlnZXN0KClcbiAgdiA9IGNyZWF0ZUhtYWMoYWxnbywgaykudXBkYXRlKHYpLmRpZ2VzdCgpXG4gIHJldHVybiB7IGs6IGssIHY6IHYgfVxufVxuXG5mdW5jdGlvbiBiaXRzMmludCAob2JpdHMsIHEpIHtcbiAgdmFyIGJpdHMgPSBuZXcgQk4ob2JpdHMpXG4gIHZhciBzaGlmdCA9IChvYml0cy5sZW5ndGggPDwgMykgLSBxLmJpdExlbmd0aCgpXG4gIGlmIChzaGlmdCA+IDApIGJpdHMuaXNocm4oc2hpZnQpXG4gIHJldHVybiBiaXRzXG59XG5cbmZ1bmN0aW9uIGJpdHMyb2N0ZXRzIChiaXRzLCBxKSB7XG4gIGJpdHMgPSBiaXRzMmludChiaXRzLCBxKVxuICBiaXRzID0gYml0cy5tb2QocSlcbiAgdmFyIG91dCA9IG5ldyBCdWZmZXIoYml0cy50b0FycmF5KCkpXG4gIGlmIChvdXQubGVuZ3RoIDwgcS5ieXRlTGVuZ3RoKCkpIHtcbiAgICB2YXIgemVyb3MgPSBuZXcgQnVmZmVyKHEuYnl0ZUxlbmd0aCgpIC0gb3V0Lmxlbmd0aClcbiAgICB6ZXJvcy5maWxsKDApXG4gICAgb3V0ID0gQnVmZmVyLmNvbmNhdChbIHplcm9zLCBvdXQgXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIG1ha2VLZXkgKHEsIGt2LCBhbGdvKSB7XG4gIHZhciB0XG4gIHZhciBrXG5cbiAgZG8ge1xuICAgIHQgPSBuZXcgQnVmZmVyKDApXG5cbiAgICB3aGlsZSAodC5sZW5ndGggKiA4IDwgcS5iaXRMZW5ndGgoKSkge1xuICAgICAga3YudiA9IGNyZWF0ZUhtYWMoYWxnbywga3YuaykudXBkYXRlKGt2LnYpLmRpZ2VzdCgpXG4gICAgICB0ID0gQnVmZmVyLmNvbmNhdChbIHQsIGt2LnYgXSlcbiAgICB9XG5cbiAgICBrID0gYml0czJpbnQodCwgcSlcbiAgICBrdi5rID0gY3JlYXRlSG1hYyhhbGdvLCBrdi5rKS51cGRhdGUoa3YudikudXBkYXRlKG5ldyBCdWZmZXIoWyAwIF0pKS5kaWdlc3QoKVxuICAgIGt2LnYgPSBjcmVhdGVIbWFjKGFsZ28sIGt2LmspLnVwZGF0ZShrdi52KS5kaWdlc3QoKVxuICB9IHdoaWxlIChrLmNtcChxKSAhPT0gLTEpXG5cbiAgcmV0dXJuIGtcbn1cblxuZnVuY3Rpb24gbWFrZVIgKGcsIGssIHAsIHEpIHtcbiAgcmV0dXJuIGcudG9SZWQoQk4ubW9udChwKSkucmVkUG93KGspLmZyb21SZWQoKS5tb2QocSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaWduXG5tb2R1bGUuZXhwb3J0cy5nZXRLZXkgPSBnZXRLZXlcbm1vZHVsZS5leHBvcnRzLm1ha2VLZXkgPSBtYWtlS2V5XG4iLCIvLyBtdWNoIG9mIHRoaXMgYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvc2VsZi1zaWduZWQvYmxvYi9naC1wYWdlcy9saWIvcnNhLmpzXG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpXG52YXIgRUMgPSByZXF1aXJlKCdlbGxpcHRpYycpLmVjXG52YXIgcGFyc2VLZXlzID0gcmVxdWlyZSgncGFyc2UtYXNuMScpXG52YXIgY3VydmVzID0gcmVxdWlyZSgnLi9jdXJ2ZXMuanNvbicpXG5cbmZ1bmN0aW9uIHZlcmlmeSAoc2lnLCBoYXNoLCBrZXksIHNpZ25UeXBlLCB0YWcpIHtcbiAgdmFyIHB1YiA9IHBhcnNlS2V5cyhrZXkpXG4gIGlmIChwdWIudHlwZSA9PT0gJ2VjJykge1xuICAgIC8vIHJzYSBrZXlzIGNhbiBiZSBpbnRlcnByZXRlZCBhcyBlY2RzYSBvbmVzIGluIG9wZW5zc2xcbiAgICBpZiAoc2lnblR5cGUgIT09ICdlY2RzYScgJiYgc2lnblR5cGUgIT09ICdlY2RzYS9yc2EnKSB0aHJvdyBuZXcgRXJyb3IoJ3dyb25nIHB1YmxpYyBrZXkgdHlwZScpXG4gICAgcmV0dXJuIGVjVmVyaWZ5KHNpZywgaGFzaCwgcHViKVxuICB9IGVsc2UgaWYgKHB1Yi50eXBlID09PSAnZHNhJykge1xuICAgIGlmIChzaWduVHlwZSAhPT0gJ2RzYScpIHRocm93IG5ldyBFcnJvcignd3JvbmcgcHVibGljIGtleSB0eXBlJylcbiAgICByZXR1cm4gZHNhVmVyaWZ5KHNpZywgaGFzaCwgcHViKVxuICB9IGVsc2Uge1xuICAgIGlmIChzaWduVHlwZSAhPT0gJ3JzYScgJiYgc2lnblR5cGUgIT09ICdlY2RzYS9yc2EnKSB0aHJvdyBuZXcgRXJyb3IoJ3dyb25nIHB1YmxpYyBrZXkgdHlwZScpXG4gIH1cbiAgaGFzaCA9IEJ1ZmZlci5jb25jYXQoW3RhZywgaGFzaF0pXG4gIHZhciBsZW4gPSBwdWIubW9kdWx1cy5ieXRlTGVuZ3RoKClcbiAgdmFyIHBhZCA9IFsgMSBdXG4gIHZhciBwYWROdW0gPSAwXG4gIHdoaWxlIChoYXNoLmxlbmd0aCArIHBhZC5sZW5ndGggKyAyIDwgbGVuKSB7XG4gICAgcGFkLnB1c2goMHhmZilcbiAgICBwYWROdW0rK1xuICB9XG4gIHBhZC5wdXNoKDB4MDApXG4gIHZhciBpID0gLTFcbiAgd2hpbGUgKCsraSA8IGhhc2gubGVuZ3RoKSB7XG4gICAgcGFkLnB1c2goaGFzaFtpXSlcbiAgfVxuICBwYWQgPSBuZXcgQnVmZmVyKHBhZClcbiAgdmFyIHJlZCA9IEJOLm1vbnQocHViLm1vZHVsdXMpXG4gIHNpZyA9IG5ldyBCTihzaWcpLnRvUmVkKHJlZClcblxuICBzaWcgPSBzaWcucmVkUG93KG5ldyBCTihwdWIucHVibGljRXhwb25lbnQpKVxuICBzaWcgPSBuZXcgQnVmZmVyKHNpZy5mcm9tUmVkKCkudG9BcnJheSgpKVxuICB2YXIgb3V0ID0gcGFkTnVtIDwgOCA/IDEgOiAwXG4gIGxlbiA9IE1hdGgubWluKHNpZy5sZW5ndGgsIHBhZC5sZW5ndGgpXG4gIGlmIChzaWcubGVuZ3RoICE9PSBwYWQubGVuZ3RoKSBvdXQgPSAxXG5cbiAgaSA9IC0xXG4gIHdoaWxlICgrK2kgPCBsZW4pIG91dCB8PSBzaWdbaV0gXiBwYWRbaV1cbiAgcmV0dXJuIG91dCA9PT0gMFxufVxuXG5mdW5jdGlvbiBlY1ZlcmlmeSAoc2lnLCBoYXNoLCBwdWIpIHtcbiAgdmFyIGN1cnZlSWQgPSBjdXJ2ZXNbcHViLmRhdGEuYWxnb3JpdGhtLmN1cnZlLmpvaW4oJy4nKV1cbiAgaWYgKCFjdXJ2ZUlkKSB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gY3VydmUgJyArIHB1Yi5kYXRhLmFsZ29yaXRobS5jdXJ2ZS5qb2luKCcuJykpXG5cbiAgdmFyIGN1cnZlID0gbmV3IEVDKGN1cnZlSWQpXG4gIHZhciBwdWJrZXkgPSBwdWIuZGF0YS5zdWJqZWN0UHJpdmF0ZUtleS5kYXRhXG5cbiAgcmV0dXJuIGN1cnZlLnZlcmlmeShoYXNoLCBzaWcsIHB1YmtleSlcbn1cblxuZnVuY3Rpb24gZHNhVmVyaWZ5IChzaWcsIGhhc2gsIHB1Yikge1xuICB2YXIgcCA9IHB1Yi5kYXRhLnBcbiAgdmFyIHEgPSBwdWIuZGF0YS5xXG4gIHZhciBnID0gcHViLmRhdGEuZ1xuICB2YXIgeSA9IHB1Yi5kYXRhLnB1Yl9rZXlcbiAgdmFyIHVucGFja2VkID0gcGFyc2VLZXlzLnNpZ25hdHVyZS5kZWNvZGUoc2lnLCAnZGVyJylcbiAgdmFyIHMgPSB1bnBhY2tlZC5zXG4gIHZhciByID0gdW5wYWNrZWQuclxuICBjaGVja1ZhbHVlKHMsIHEpXG4gIGNoZWNrVmFsdWUociwgcSlcbiAgdmFyIG1vbnRwID0gQk4ubW9udChwKVxuICB2YXIgdyA9IHMuaW52bShxKVxuICB2YXIgdiA9IGcudG9SZWQobW9udHApXG4gICAgLnJlZFBvdyhuZXcgQk4oaGFzaCkubXVsKHcpLm1vZChxKSlcbiAgICAuZnJvbVJlZCgpXG4gICAgLm11bCh5LnRvUmVkKG1vbnRwKS5yZWRQb3coci5tdWwodykubW9kKHEpKS5mcm9tUmVkKCkpXG4gICAgLm1vZChwKVxuICAgIC5tb2QocSlcbiAgcmV0dXJuIHYuY21wKHIpID09PSAwXG59XG5cbmZ1bmN0aW9uIGNoZWNrVmFsdWUgKGIsIHEpIHtcbiAgaWYgKGIuY21wbigwKSA8PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2lnJylcbiAgaWYgKGIuY21wKHEpID49IHEpIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzaWcnKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHZlcmlmeVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB4b3IgKGEsIGIpIHtcbiAgdmFyIGxlbmd0aCA9IE1hdGgubWluKGEubGVuZ3RoLCBiLmxlbmd0aClcbiAgdmFyIGJ1ZmZlciA9IG5ldyBCdWZmZXIobGVuZ3RoKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBidWZmZXJbaV0gPSBhW2ldIF4gYltpXVxuICB9XG5cbiAgcmV0dXJuIGJ1ZmZlclxufVxuIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogRHVlIHRvIHZhcmlvdXMgYnJvd3NlciBidWdzLCBzb21ldGltZXMgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIHVzZWQgZXZlblxuICogd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0eXBlZCBhcnJheXMuXG4gKlxuICogTm90ZTpcbiAqXG4gKiAgIC0gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLFxuICogICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXG4gKiAgICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG5cbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5XG4gKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCBiZWhhdmVzIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVCAhPT0gdW5kZWZpbmVkXG4gID8gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgOiB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbi8qXG4gKiBFeHBvcnQga01heExlbmd0aCBhZnRlciB0eXBlZCBhcnJheSBzdXBwb3J0IGlzIGRldGVybWluZWQuXG4gKi9cbmV4cG9ydHMua01heExlbmd0aCA9IGtNYXhMZW5ndGgoKVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLl9fcHJvdG9fXyA9IHtfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH19XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDIgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgYXJyLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGtNYXhMZW5ndGggKCkge1xuICByZXR1cm4gQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgICA/IDB4N2ZmZmZmZmZcbiAgICA6IDB4M2ZmZmZmZmZcbn1cblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyICh0aGF0LCBsZW5ndGgpIHtcbiAgaWYgKGtNYXhMZW5ndGgoKSA8IGxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHR5cGVkIGFycmF5IGxlbmd0aCcpXG4gIH1cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgaWYgKHRoYXQgPT09IG51bGwpIHtcbiAgICAgIHRoYXQgPSBuZXcgQnVmZmVyKGxlbmd0aClcbiAgICB9XG4gICAgdGhhdC5sZW5ndGggPSBsZW5ndGhcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZydcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKHRoaXMsIGFyZylcbiAgfVxuICByZXR1cm4gZnJvbSh0aGlzLCBhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbi8vIFRPRE86IExlZ2FjeSwgbm90IG5lZWRlZCBhbnltb3JlLiBSZW1vdmUgaW4gbmV4dCBtYWpvciB2ZXJzaW9uLlxuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIGZyb20gKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICByZXR1cm4gZnJvbU9iamVjdCh0aGF0LCB2YWx1ZSlcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbShudWxsLCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5pZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuICBCdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgJiZcbiAgICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICAgIC8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHRoYXQsIHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKG51bGwsIHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAodGhhdCwgc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7ICsraSkge1xuICAgICAgdGhhdFtpXSA9IDBcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nICh0aGF0LCBzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gdGhhdC53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgdGhhdCA9IHRoYXQuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAodGhhdCwgYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBhcnJheS5ieXRlTGVuZ3RoIC8vIHRoaXMgdGhyb3dzIGlmIGBhcnJheWAgaXMgbm90IGEgdmFsaWQgQXJyYXlCdWZmZXJcblxuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnb2Zmc2V0XFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdsZW5ndGhcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IGFycmF5XG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQgPSBmcm9tQXJyYXlMaWtlKHRoYXQsIGFycmF5KVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKHRoYXQsIG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbilcblxuICAgIGlmICh0aGF0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoYXRcbiAgICB9XG5cbiAgICBvYmouY29weSh0aGF0LCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIHRoYXRcbiAgfVxuXG4gIGlmIChvYmopIHtcbiAgICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgb2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fCAnbGVuZ3RoJyBpbiBvYmopIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgaXNuYW4ob2JqLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCAwKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqKVxuICAgIH1cblxuICAgIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iai5kYXRhKVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwga01heExlbmd0aCgpYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IGtNYXhMZW5ndGgoKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoKCkudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFpc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBzdHJpbmcgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICBzdHJpbmcgPSAnJyArIHN0cmluZ1xuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGUgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCBhbmQgYGlzLWJ1ZmZlcmAgKGluIFNhZmFyaSA1LTcpIHRvIGRldGVjdFxuLy8gQnVmZmVyIGluc3RhbmNlcy5cbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggfCAwXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKGlzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiZcbiAgICAgICAgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChpc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggfCAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgLy8gbGVnYWN5IHdyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKSAtIHJlbW92ZSBpbiB2MC4xM1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZlxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gICAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyArK2kpIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG4gIHZhciBpXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoY29kZSA8IDI1Nikge1xuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogdXRmOFRvQnl0ZXMobmV3IEJ1ZmZlcih2YWwsIGVuY29kaW5nKS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBpc25hbiAodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IHZhbCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuIiwidmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnc3RyZWFtJykuVHJhbnNmb3JtXG52YXIgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyJykuU3RyaW5nRGVjb2RlclxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuXG5mdW5jdGlvbiBDaXBoZXJCYXNlIChoYXNoTW9kZSkge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzKVxuICB0aGlzLmhhc2hNb2RlID0gdHlwZW9mIGhhc2hNb2RlID09PSAnc3RyaW5nJ1xuICBpZiAodGhpcy5oYXNoTW9kZSkge1xuICAgIHRoaXNbaGFzaE1vZGVdID0gdGhpcy5fZmluYWxPckRpZ2VzdFxuICB9IGVsc2Uge1xuICAgIHRoaXMuZmluYWwgPSB0aGlzLl9maW5hbE9yRGlnZXN0XG4gIH1cbiAgaWYgKHRoaXMuX2ZpbmFsKSB7XG4gICAgdGhpcy5fX2ZpbmFsID0gdGhpcy5fZmluYWxcbiAgICB0aGlzLl9maW5hbCA9IG51bGxcbiAgfVxuICB0aGlzLl9kZWNvZGVyID0gbnVsbFxuICB0aGlzLl9lbmNvZGluZyA9IG51bGxcbn1cbmluaGVyaXRzKENpcGhlckJhc2UsIFRyYW5zZm9ybSlcblxuQ2lwaGVyQmFzZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRhdGEsIGlucHV0RW5jLCBvdXRwdXRFbmMpIHtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhLCBpbnB1dEVuYylcbiAgfVxuXG4gIHZhciBvdXREYXRhID0gdGhpcy5fdXBkYXRlKGRhdGEpXG4gIGlmICh0aGlzLmhhc2hNb2RlKSByZXR1cm4gdGhpc1xuXG4gIGlmIChvdXRwdXRFbmMpIHtcbiAgICBvdXREYXRhID0gdGhpcy5fdG9TdHJpbmcob3V0RGF0YSwgb3V0cHV0RW5jKVxuICB9XG5cbiAgcmV0dXJuIG91dERhdGFcbn1cblxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuc2V0QXV0b1BhZGRpbmcgPSBmdW5jdGlvbiAoKSB7fVxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuZ2V0QXV0aFRhZyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCd0cnlpbmcgdG8gZ2V0IGF1dGggdGFnIGluIHVuc3VwcG9ydGVkIHN0YXRlJylcbn1cblxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuc2V0QXV0aFRhZyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCd0cnlpbmcgdG8gc2V0IGF1dGggdGFnIGluIHVuc3VwcG9ydGVkIHN0YXRlJylcbn1cblxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuc2V0QUFEID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ3RyeWluZyB0byBzZXQgYWFkIGluIHVuc3VwcG9ydGVkIHN0YXRlJylcbn1cblxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChkYXRhLCBfLCBuZXh0KSB7XG4gIHZhciBlcnJcbiAgdHJ5IHtcbiAgICBpZiAodGhpcy5oYXNoTW9kZSkge1xuICAgICAgdGhpcy5fdXBkYXRlKGRhdGEpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHVzaCh0aGlzLl91cGRhdGUoZGF0YSkpXG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgZXJyID0gZVxuICB9IGZpbmFsbHkge1xuICAgIG5leHQoZXJyKVxuICB9XG59XG5DaXBoZXJCYXNlLnByb3RvdHlwZS5fZmx1c2ggPSBmdW5jdGlvbiAoZG9uZSkge1xuICB2YXIgZXJyXG4gIHRyeSB7XG4gICAgdGhpcy5wdXNoKHRoaXMuX19maW5hbCgpKVxuICB9IGNhdGNoIChlKSB7XG4gICAgZXJyID0gZVxuICB9XG5cbiAgZG9uZShlcnIpXG59XG5DaXBoZXJCYXNlLnByb3RvdHlwZS5fZmluYWxPckRpZ2VzdCA9IGZ1bmN0aW9uIChvdXRwdXRFbmMpIHtcbiAgdmFyIG91dERhdGEgPSB0aGlzLl9fZmluYWwoKSB8fCBCdWZmZXIuYWxsb2MoMClcbiAgaWYgKG91dHB1dEVuYykge1xuICAgIG91dERhdGEgPSB0aGlzLl90b1N0cmluZyhvdXREYXRhLCBvdXRwdXRFbmMsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG91dERhdGFcbn1cblxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuX3RvU3RyaW5nID0gZnVuY3Rpb24gKHZhbHVlLCBlbmMsIGZpbikge1xuICBpZiAoIXRoaXMuX2RlY29kZXIpIHtcbiAgICB0aGlzLl9kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKVxuICAgIHRoaXMuX2VuY29kaW5nID0gZW5jXG4gIH1cblxuICBpZiAodGhpcy5fZW5jb2RpbmcgIT09IGVuYykgdGhyb3cgbmV3IEVycm9yKCdjYW5cXCd0IHN3aXRjaCBlbmNvZGluZ3MnKVxuXG4gIHZhciBvdXQgPSB0aGlzLl9kZWNvZGVyLndyaXRlKHZhbHVlKVxuICBpZiAoZmluKSB7XG4gICAgb3V0ICs9IHRoaXMuX2RlY29kZXIuZW5kKClcbiAgfVxuXG4gIHJldHVybiBvdXRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDaXBoZXJCYXNlXG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cblxuZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcmcpO1xuICB9XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhhcmcpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gQnVmZmVyLmlzQnVmZmVyO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG4iLCJ2YXIgZWxsaXB0aWMgPSByZXF1aXJlKCdlbGxpcHRpYycpXG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlRUNESCAoY3VydmUpIHtcbiAgcmV0dXJuIG5ldyBFQ0RIKGN1cnZlKVxufVxuXG52YXIgYWxpYXNlcyA9IHtcbiAgc2VjcDI1NmsxOiB7XG4gICAgbmFtZTogJ3NlY3AyNTZrMScsXG4gICAgYnl0ZUxlbmd0aDogMzJcbiAgfSxcbiAgc2VjcDIyNHIxOiB7XG4gICAgbmFtZTogJ3AyMjQnLFxuICAgIGJ5dGVMZW5ndGg6IDI4XG4gIH0sXG4gIHByaW1lMjU2djE6IHtcbiAgICBuYW1lOiAncDI1NicsXG4gICAgYnl0ZUxlbmd0aDogMzJcbiAgfSxcbiAgcHJpbWUxOTJ2MToge1xuICAgIG5hbWU6ICdwMTkyJyxcbiAgICBieXRlTGVuZ3RoOiAyNFxuICB9LFxuICBlZDI1NTE5OiB7XG4gICAgbmFtZTogJ2VkMjU1MTknLFxuICAgIGJ5dGVMZW5ndGg6IDMyXG4gIH0sXG4gIHNlY3AzODRyMToge1xuICAgIG5hbWU6ICdwMzg0JyxcbiAgICBieXRlTGVuZ3RoOiA0OFxuICB9LFxuICBzZWNwNTIxcjE6IHtcbiAgICBuYW1lOiAncDUyMScsXG4gICAgYnl0ZUxlbmd0aDogNjZcbiAgfVxufVxuXG5hbGlhc2VzLnAyMjQgPSBhbGlhc2VzLnNlY3AyMjRyMVxuYWxpYXNlcy5wMjU2ID0gYWxpYXNlcy5zZWNwMjU2cjEgPSBhbGlhc2VzLnByaW1lMjU2djFcbmFsaWFzZXMucDE5MiA9IGFsaWFzZXMuc2VjcDE5MnIxID0gYWxpYXNlcy5wcmltZTE5MnYxXG5hbGlhc2VzLnAzODQgPSBhbGlhc2VzLnNlY3AzODRyMVxuYWxpYXNlcy5wNTIxID0gYWxpYXNlcy5zZWNwNTIxcjFcblxuZnVuY3Rpb24gRUNESCAoY3VydmUpIHtcbiAgdGhpcy5jdXJ2ZVR5cGUgPSBhbGlhc2VzW2N1cnZlXVxuICBpZiAoIXRoaXMuY3VydmVUeXBlKSB7XG4gICAgdGhpcy5jdXJ2ZVR5cGUgPSB7XG4gICAgICBuYW1lOiBjdXJ2ZVxuICAgIH1cbiAgfVxuICB0aGlzLmN1cnZlID0gbmV3IGVsbGlwdGljLmVjKHRoaXMuY3VydmVUeXBlLm5hbWUpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbmV3LWNhcFxuICB0aGlzLmtleXMgPSB2b2lkIDBcbn1cblxuRUNESC5wcm90b3R5cGUuZ2VuZXJhdGVLZXlzID0gZnVuY3Rpb24gKGVuYywgZm9ybWF0KSB7XG4gIHRoaXMua2V5cyA9IHRoaXMuY3VydmUuZ2VuS2V5UGFpcigpXG4gIHJldHVybiB0aGlzLmdldFB1YmxpY0tleShlbmMsIGZvcm1hdClcbn1cblxuRUNESC5wcm90b3R5cGUuY29tcHV0ZVNlY3JldCA9IGZ1bmN0aW9uIChvdGhlciwgaW5lbmMsIGVuYykge1xuICBpbmVuYyA9IGluZW5jIHx8ICd1dGY4J1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihvdGhlcikpIHtcbiAgICBvdGhlciA9IG5ldyBCdWZmZXIob3RoZXIsIGluZW5jKVxuICB9XG4gIHZhciBvdGhlclB1YiA9IHRoaXMuY3VydmUua2V5RnJvbVB1YmxpYyhvdGhlcikuZ2V0UHVibGljKClcbiAgdmFyIG91dCA9IG90aGVyUHViLm11bCh0aGlzLmtleXMuZ2V0UHJpdmF0ZSgpKS5nZXRYKClcbiAgcmV0dXJuIGZvcm1hdFJldHVyblZhbHVlKG91dCwgZW5jLCB0aGlzLmN1cnZlVHlwZS5ieXRlTGVuZ3RoKVxufVxuXG5FQ0RILnByb3RvdHlwZS5nZXRQdWJsaWNLZXkgPSBmdW5jdGlvbiAoZW5jLCBmb3JtYXQpIHtcbiAgdmFyIGtleSA9IHRoaXMua2V5cy5nZXRQdWJsaWMoZm9ybWF0ID09PSAnY29tcHJlc3NlZCcsIHRydWUpXG4gIGlmIChmb3JtYXQgPT09ICdoeWJyaWQnKSB7XG4gICAgaWYgKGtleVtrZXkubGVuZ3RoIC0gMV0gJSAyKSB7XG4gICAgICBrZXlbMF0gPSA3XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleVswXSA9IDZcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZvcm1hdFJldHVyblZhbHVlKGtleSwgZW5jKVxufVxuXG5FQ0RILnByb3RvdHlwZS5nZXRQcml2YXRlS2V5ID0gZnVuY3Rpb24gKGVuYykge1xuICByZXR1cm4gZm9ybWF0UmV0dXJuVmFsdWUodGhpcy5rZXlzLmdldFByaXZhdGUoKSwgZW5jKVxufVxuXG5FQ0RILnByb3RvdHlwZS5zZXRQdWJsaWNLZXkgPSBmdW5jdGlvbiAocHViLCBlbmMpIHtcbiAgZW5jID0gZW5jIHx8ICd1dGY4J1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihwdWIpKSB7XG4gICAgcHViID0gbmV3IEJ1ZmZlcihwdWIsIGVuYylcbiAgfVxuICB0aGlzLmtleXMuX2ltcG9ydFB1YmxpYyhwdWIpXG4gIHJldHVybiB0aGlzXG59XG5cbkVDREgucHJvdG90eXBlLnNldFByaXZhdGVLZXkgPSBmdW5jdGlvbiAocHJpdiwgZW5jKSB7XG4gIGVuYyA9IGVuYyB8fCAndXRmOCdcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIocHJpdikpIHtcbiAgICBwcml2ID0gbmV3IEJ1ZmZlcihwcml2LCBlbmMpXG4gIH1cblxuICB2YXIgX3ByaXYgPSBuZXcgQk4ocHJpdilcbiAgX3ByaXYgPSBfcHJpdi50b1N0cmluZygxNilcbiAgdGhpcy5rZXlzID0gdGhpcy5jdXJ2ZS5nZW5LZXlQYWlyKClcbiAgdGhpcy5rZXlzLl9pbXBvcnRQcml2YXRlKF9wcml2KVxuICByZXR1cm4gdGhpc1xufVxuXG5mdW5jdGlvbiBmb3JtYXRSZXR1cm5WYWx1ZSAoYm4sIGVuYywgbGVuKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShibikpIHtcbiAgICBibiA9IGJuLnRvQXJyYXkoKVxuICB9XG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKGJuKVxuICBpZiAobGVuICYmIGJ1Zi5sZW5ndGggPCBsZW4pIHtcbiAgICB2YXIgemVyb3MgPSBuZXcgQnVmZmVyKGxlbiAtIGJ1Zi5sZW5ndGgpXG4gICAgemVyb3MuZmlsbCgwKVxuICAgIGJ1ZiA9IEJ1ZmZlci5jb25jYXQoW3plcm9zLCBidWZdKVxuICB9XG4gIGlmICghZW5jKSB7XG4gICAgcmV0dXJuIGJ1ZlxuICB9IGVsc2Uge1xuICAgIHJldHVybiBidWYudG9TdHJpbmcoZW5jKVxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBNRDUgPSByZXF1aXJlKCdtZDUuanMnKVxudmFyIFJJUEVNRDE2MCA9IHJlcXVpcmUoJ3JpcGVtZDE2MCcpXG52YXIgc2hhID0gcmVxdWlyZSgnc2hhLmpzJylcbnZhciBCYXNlID0gcmVxdWlyZSgnY2lwaGVyLWJhc2UnKVxuXG5mdW5jdGlvbiBIYXNoIChoYXNoKSB7XG4gIEJhc2UuY2FsbCh0aGlzLCAnZGlnZXN0JylcblxuICB0aGlzLl9oYXNoID0gaGFzaFxufVxuXG5pbmhlcml0cyhIYXNoLCBCYXNlKVxuXG5IYXNoLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdGhpcy5faGFzaC51cGRhdGUoZGF0YSlcbn1cblxuSGFzaC5wcm90b3R5cGUuX2ZpbmFsID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5faGFzaC5kaWdlc3QoKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZUhhc2ggKGFsZykge1xuICBhbGcgPSBhbGcudG9Mb3dlckNhc2UoKVxuICBpZiAoYWxnID09PSAnbWQ1JykgcmV0dXJuIG5ldyBNRDUoKVxuICBpZiAoYWxnID09PSAncm1kMTYwJyB8fCBhbGcgPT09ICdyaXBlbWQxNjAnKSByZXR1cm4gbmV3IFJJUEVNRDE2MCgpXG5cbiAgcmV0dXJuIG5ldyBIYXNoKHNoYShhbGcpKVxufVxuIiwidmFyIE1ENSA9IHJlcXVpcmUoJ21kNS5qcycpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuICByZXR1cm4gbmV3IE1ENSgpLnVwZGF0ZShidWZmZXIpLmRpZ2VzdCgpXG59XG4iLCIndXNlIHN0cmljdCdcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBMZWdhY3kgPSByZXF1aXJlKCcuL2xlZ2FjeScpXG52YXIgQmFzZSA9IHJlcXVpcmUoJ2NpcGhlci1iYXNlJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxudmFyIG1kNSA9IHJlcXVpcmUoJ2NyZWF0ZS1oYXNoL21kNScpXG52YXIgUklQRU1EMTYwID0gcmVxdWlyZSgncmlwZW1kMTYwJylcblxudmFyIHNoYSA9IHJlcXVpcmUoJ3NoYS5qcycpXG5cbnZhciBaRVJPUyA9IEJ1ZmZlci5hbGxvYygxMjgpXG5cbmZ1bmN0aW9uIEhtYWMgKGFsZywga2V5KSB7XG4gIEJhc2UuY2FsbCh0aGlzLCAnZGlnZXN0JylcbiAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAga2V5ID0gQnVmZmVyLmZyb20oa2V5KVxuICB9XG5cbiAgdmFyIGJsb2Nrc2l6ZSA9IChhbGcgPT09ICdzaGE1MTInIHx8IGFsZyA9PT0gJ3NoYTM4NCcpID8gMTI4IDogNjRcblxuICB0aGlzLl9hbGcgPSBhbGdcbiAgdGhpcy5fa2V5ID0ga2V5XG4gIGlmIChrZXkubGVuZ3RoID4gYmxvY2tzaXplKSB7XG4gICAgdmFyIGhhc2ggPSBhbGcgPT09ICdybWQxNjAnID8gbmV3IFJJUEVNRDE2MCgpIDogc2hhKGFsZylcbiAgICBrZXkgPSBoYXNoLnVwZGF0ZShrZXkpLmRpZ2VzdCgpXG4gIH0gZWxzZSBpZiAoa2V5Lmxlbmd0aCA8IGJsb2Nrc2l6ZSkge1xuICAgIGtleSA9IEJ1ZmZlci5jb25jYXQoW2tleSwgWkVST1NdLCBibG9ja3NpemUpXG4gIH1cblxuICB2YXIgaXBhZCA9IHRoaXMuX2lwYWQgPSBCdWZmZXIuYWxsb2NVbnNhZmUoYmxvY2tzaXplKVxuICB2YXIgb3BhZCA9IHRoaXMuX29wYWQgPSBCdWZmZXIuYWxsb2NVbnNhZmUoYmxvY2tzaXplKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYmxvY2tzaXplOyBpKyspIHtcbiAgICBpcGFkW2ldID0ga2V5W2ldIF4gMHgzNlxuICAgIG9wYWRbaV0gPSBrZXlbaV0gXiAweDVDXG4gIH1cbiAgdGhpcy5faGFzaCA9IGFsZyA9PT0gJ3JtZDE2MCcgPyBuZXcgUklQRU1EMTYwKCkgOiBzaGEoYWxnKVxuICB0aGlzLl9oYXNoLnVwZGF0ZShpcGFkKVxufVxuXG5pbmhlcml0cyhIbWFjLCBCYXNlKVxuXG5IbWFjLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdGhpcy5faGFzaC51cGRhdGUoZGF0YSlcbn1cblxuSG1hYy5wcm90b3R5cGUuX2ZpbmFsID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaCA9IHRoaXMuX2hhc2guZGlnZXN0KClcbiAgdmFyIGhhc2ggPSB0aGlzLl9hbGcgPT09ICdybWQxNjAnID8gbmV3IFJJUEVNRDE2MCgpIDogc2hhKHRoaXMuX2FsZylcbiAgcmV0dXJuIGhhc2gudXBkYXRlKHRoaXMuX29wYWQpLnVwZGF0ZShoKS5kaWdlc3QoKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZUhtYWMgKGFsZywga2V5KSB7XG4gIGFsZyA9IGFsZy50b0xvd2VyQ2FzZSgpXG4gIGlmIChhbGcgPT09ICdybWQxNjAnIHx8IGFsZyA9PT0gJ3JpcGVtZDE2MCcpIHtcbiAgICByZXR1cm4gbmV3IEhtYWMoJ3JtZDE2MCcsIGtleSlcbiAgfVxuICBpZiAoYWxnID09PSAnbWQ1Jykge1xuICAgIHJldHVybiBuZXcgTGVnYWN5KG1kNSwga2V5KVxuICB9XG4gIHJldHVybiBuZXcgSG1hYyhhbGcsIGtleSlcbn1cbiIsIid1c2Ugc3RyaWN0J1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbnZhciBCYXNlID0gcmVxdWlyZSgnY2lwaGVyLWJhc2UnKVxuXG52YXIgWkVST1MgPSBCdWZmZXIuYWxsb2MoMTI4KVxudmFyIGJsb2Nrc2l6ZSA9IDY0XG5cbmZ1bmN0aW9uIEhtYWMgKGFsZywga2V5KSB7XG4gIEJhc2UuY2FsbCh0aGlzLCAnZGlnZXN0JylcbiAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAga2V5ID0gQnVmZmVyLmZyb20oa2V5KVxuICB9XG5cbiAgdGhpcy5fYWxnID0gYWxnXG4gIHRoaXMuX2tleSA9IGtleVxuXG4gIGlmIChrZXkubGVuZ3RoID4gYmxvY2tzaXplKSB7XG4gICAga2V5ID0gYWxnKGtleSlcbiAgfSBlbHNlIGlmIChrZXkubGVuZ3RoIDwgYmxvY2tzaXplKSB7XG4gICAga2V5ID0gQnVmZmVyLmNvbmNhdChba2V5LCBaRVJPU10sIGJsb2Nrc2l6ZSlcbiAgfVxuXG4gIHZhciBpcGFkID0gdGhpcy5faXBhZCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShibG9ja3NpemUpXG4gIHZhciBvcGFkID0gdGhpcy5fb3BhZCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShibG9ja3NpemUpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBibG9ja3NpemU7IGkrKykge1xuICAgIGlwYWRbaV0gPSBrZXlbaV0gXiAweDM2XG4gICAgb3BhZFtpXSA9IGtleVtpXSBeIDB4NUNcbiAgfVxuXG4gIHRoaXMuX2hhc2ggPSBbaXBhZF1cbn1cblxuaW5oZXJpdHMoSG1hYywgQmFzZSlcblxuSG1hYy5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuX2hhc2gucHVzaChkYXRhKVxufVxuXG5IbWFjLnByb3RvdHlwZS5fZmluYWwgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBoID0gdGhpcy5fYWxnKEJ1ZmZlci5jb25jYXQodGhpcy5faGFzaCkpXG4gIHJldHVybiB0aGlzLl9hbGcoQnVmZmVyLmNvbmNhdChbdGhpcy5fb3BhZCwgaF0pKVxufVxubW9kdWxlLmV4cG9ydHMgPSBIbWFjXG4iLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5yYW5kb21CeXRlcyA9IGV4cG9ydHMucm5nID0gZXhwb3J0cy5wc2V1ZG9SYW5kb21CeXRlcyA9IGV4cG9ydHMucHJuZyA9IHJlcXVpcmUoJ3JhbmRvbWJ5dGVzJylcbmV4cG9ydHMuY3JlYXRlSGFzaCA9IGV4cG9ydHMuSGFzaCA9IHJlcXVpcmUoJ2NyZWF0ZS1oYXNoJylcbmV4cG9ydHMuY3JlYXRlSG1hYyA9IGV4cG9ydHMuSG1hYyA9IHJlcXVpcmUoJ2NyZWF0ZS1obWFjJylcblxudmFyIGFsZ29zID0gcmVxdWlyZSgnYnJvd3NlcmlmeS1zaWduL2FsZ29zJylcbnZhciBhbGdvS2V5cyA9IE9iamVjdC5rZXlzKGFsZ29zKVxudmFyIGhhc2hlcyA9IFsnc2hhMScsICdzaGEyMjQnLCAnc2hhMjU2JywgJ3NoYTM4NCcsICdzaGE1MTInLCAnbWQ1JywgJ3JtZDE2MCddLmNvbmNhdChhbGdvS2V5cylcbmV4cG9ydHMuZ2V0SGFzaGVzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gaGFzaGVzXG59XG5cbnZhciBwID0gcmVxdWlyZSgncGJrZGYyJylcbmV4cG9ydHMucGJrZGYyID0gcC5wYmtkZjJcbmV4cG9ydHMucGJrZGYyU3luYyA9IHAucGJrZGYyU3luY1xuXG52YXIgYWVzID0gcmVxdWlyZSgnYnJvd3NlcmlmeS1jaXBoZXInKVxuXG5leHBvcnRzLkNpcGhlciA9IGFlcy5DaXBoZXJcbmV4cG9ydHMuY3JlYXRlQ2lwaGVyID0gYWVzLmNyZWF0ZUNpcGhlclxuZXhwb3J0cy5DaXBoZXJpdiA9IGFlcy5DaXBoZXJpdlxuZXhwb3J0cy5jcmVhdGVDaXBoZXJpdiA9IGFlcy5jcmVhdGVDaXBoZXJpdlxuZXhwb3J0cy5EZWNpcGhlciA9IGFlcy5EZWNpcGhlclxuZXhwb3J0cy5jcmVhdGVEZWNpcGhlciA9IGFlcy5jcmVhdGVEZWNpcGhlclxuZXhwb3J0cy5EZWNpcGhlcml2ID0gYWVzLkRlY2lwaGVyaXZcbmV4cG9ydHMuY3JlYXRlRGVjaXBoZXJpdiA9IGFlcy5jcmVhdGVEZWNpcGhlcml2XG5leHBvcnRzLmdldENpcGhlcnMgPSBhZXMuZ2V0Q2lwaGVyc1xuZXhwb3J0cy5saXN0Q2lwaGVycyA9IGFlcy5saXN0Q2lwaGVyc1xuXG52YXIgZGggPSByZXF1aXJlKCdkaWZmaWUtaGVsbG1hbicpXG5cbmV4cG9ydHMuRGlmZmllSGVsbG1hbkdyb3VwID0gZGguRGlmZmllSGVsbG1hbkdyb3VwXG5leHBvcnRzLmNyZWF0ZURpZmZpZUhlbGxtYW5Hcm91cCA9IGRoLmNyZWF0ZURpZmZpZUhlbGxtYW5Hcm91cFxuZXhwb3J0cy5nZXREaWZmaWVIZWxsbWFuID0gZGguZ2V0RGlmZmllSGVsbG1hblxuZXhwb3J0cy5jcmVhdGVEaWZmaWVIZWxsbWFuID0gZGguY3JlYXRlRGlmZmllSGVsbG1hblxuZXhwb3J0cy5EaWZmaWVIZWxsbWFuID0gZGguRGlmZmllSGVsbG1hblxuXG52YXIgc2lnbiA9IHJlcXVpcmUoJ2Jyb3dzZXJpZnktc2lnbicpXG5cbmV4cG9ydHMuY3JlYXRlU2lnbiA9IHNpZ24uY3JlYXRlU2lnblxuZXhwb3J0cy5TaWduID0gc2lnbi5TaWduXG5leHBvcnRzLmNyZWF0ZVZlcmlmeSA9IHNpZ24uY3JlYXRlVmVyaWZ5XG5leHBvcnRzLlZlcmlmeSA9IHNpZ24uVmVyaWZ5XG5cbmV4cG9ydHMuY3JlYXRlRUNESCA9IHJlcXVpcmUoJ2NyZWF0ZS1lY2RoJylcblxudmFyIHB1YmxpY0VuY3J5cHQgPSByZXF1aXJlKCdwdWJsaWMtZW5jcnlwdCcpXG5cbmV4cG9ydHMucHVibGljRW5jcnlwdCA9IHB1YmxpY0VuY3J5cHQucHVibGljRW5jcnlwdFxuZXhwb3J0cy5wcml2YXRlRW5jcnlwdCA9IHB1YmxpY0VuY3J5cHQucHJpdmF0ZUVuY3J5cHRcbmV4cG9ydHMucHVibGljRGVjcnlwdCA9IHB1YmxpY0VuY3J5cHQucHVibGljRGVjcnlwdFxuZXhwb3J0cy5wcml2YXRlRGVjcnlwdCA9IHB1YmxpY0VuY3J5cHQucHJpdmF0ZURlY3J5cHRcblxuLy8gdGhlIGxlYXN0IEkgY2FuIGRvIGlzIG1ha2UgZXJyb3IgbWVzc2FnZXMgZm9yIHRoZSByZXN0IG9mIHRoZSBub2RlLmpzL2NyeXB0byBhcGkuXG4vLyA7W1xuLy8gICAnY3JlYXRlQ3JlZGVudGlhbHMnXG4vLyBdLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbi8vICAgZXhwb3J0c1tuYW1lXSA9IGZ1bmN0aW9uICgpIHtcbi8vICAgICB0aHJvdyBuZXcgRXJyb3IoW1xuLy8gICAgICAgJ3NvcnJ5LCAnICsgbmFtZSArICcgaXMgbm90IGltcGxlbWVudGVkIHlldCcsXG4vLyAgICAgICAnd2UgYWNjZXB0IHB1bGwgcmVxdWVzdHMnLFxuLy8gICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9jcnlwdG8tYnJvd3NlcmlmeS9jcnlwdG8tYnJvd3NlcmlmeSdcbi8vICAgICBdLmpvaW4oJ1xcbicpKVxuLy8gICB9XG4vLyB9KVxuXG52YXIgcmYgPSByZXF1aXJlKCdyYW5kb21maWxsJylcblxuZXhwb3J0cy5yYW5kb21GaWxsID0gcmYucmFuZG9tRmlsbFxuZXhwb3J0cy5yYW5kb21GaWxsU3luYyA9IHJmLnJhbmRvbUZpbGxTeW5jXG5cbmV4cG9ydHMuY3JlYXRlQ3JlZGVudGlhbHMgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcihbXG4gICAgJ3NvcnJ5LCBjcmVhdGVDcmVkZW50aWFscyBpcyBub3QgaW1wbGVtZW50ZWQgeWV0JyxcbiAgICAnd2UgYWNjZXB0IHB1bGwgcmVxdWVzdHMnLFxuICAgICdodHRwczovL2dpdGh1Yi5jb20vY3J5cHRvLWJyb3dzZXJpZnkvY3J5cHRvLWJyb3dzZXJpZnknXG4gIF0uam9pbignXFxuJykpXG59XG5cbmV4cG9ydHMuY29uc3RhbnRzID0ge1xuICAnREhfQ0hFQ0tfUF9OT1RfU0FGRV9QUklNRSc6IDIsXG4gICdESF9DSEVDS19QX05PVF9QUklNRSc6IDEsXG4gICdESF9VTkFCTEVfVE9fQ0hFQ0tfR0VORVJBVE9SJzogNCxcbiAgJ0RIX05PVF9TVUlUQUJMRV9HRU5FUkFUT1InOiA4LFxuICAnTlBOX0VOQUJMRUQnOiAxLFxuICAnQUxQTl9FTkFCTEVEJzogMSxcbiAgJ1JTQV9QS0NTMV9QQURESU5HJzogMSxcbiAgJ1JTQV9TU0xWMjNfUEFERElORyc6IDIsXG4gICdSU0FfTk9fUEFERElORyc6IDMsXG4gICdSU0FfUEtDUzFfT0FFUF9QQURESU5HJzogNCxcbiAgJ1JTQV9YOTMxX1BBRERJTkcnOiA1LFxuICAnUlNBX1BLQ1MxX1BTU19QQURESU5HJzogNixcbiAgJ1BPSU5UX0NPTlZFUlNJT05fQ09NUFJFU1NFRCc6IDIsXG4gICdQT0lOVF9DT05WRVJTSU9OX1VOQ09NUFJFU1NFRCc6IDQsXG4gICdQT0lOVF9DT05WRVJTSU9OX0hZQlJJRCc6IDZcbn1cbiIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCIpKGZhbHNlKTtcbi8vIE1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiYm9keSB7XFxuICAgIG1pbi1oZWlnaHQ6IDEwMHZoO1xcbn1cXG4uYm9hcmQge1xcbiAgIG1pbi1oZWlnaHQ6IDMwMHB4O1xcbiAgIG1pbi13aWR0aDogNjAwcHg7XFxuICAgYmFja2dyb3VuZC1jb2xvcjogYXF1YTtcXG59XFxuXFxuI3BvaW50ZXIge1xcbiAgICB3aWR0aDogMC41ZW07XFxuICAgIGhlaWdodDogMC41ZW07XFxuICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmVkO1xcbiAgICBib3JkZXI6IDRweCBzb2xpZCAjZmZmO1xcbiAgICBib3gtc2hhZG93OiAwIDAgMCA1cHggcmVkO1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHRvcDogLTEwMHB4O1xcbiAgICBsZWZ0OiAtMTAwcHg7XFxufVxcblxcbiNzcmN2aWRlbyB7XFxuICAgIGRpc3BsYXk6IG5vbmU7XFxufVwiLCBcIlwiXSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLypcbiAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAgQXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodXNlU291cmNlTWFwKSB7XG4gIHZhciBsaXN0ID0gW107IC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblxuICBsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgcmV0dXJuIFwiQG1lZGlhIFwiLmNvbmNhdChpdGVtWzJdLCBcIntcIikuY29uY2F0KGNvbnRlbnQsIFwifVwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfSkuam9pbignJyk7XG4gIH07IC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5cblxuICBsaXN0LmkgPSBmdW5jdGlvbiAobW9kdWxlcywgbWVkaWFRdWVyeSkge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgbW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgJyddXTtcbiAgICB9XG5cbiAgICB2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICAgIHZhciBpZCA9IHRoaXNbaV1bMF07XG5cbiAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbW9kdWxlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBpdGVtID0gbW9kdWxlc1tfaV07IC8vIHNraXAgYWxyZWFkeSBpbXBvcnRlZCBtb2R1bGVcbiAgICAgIC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgbm90IDEwMCUgcGVyZmVjdCBmb3Igd2VpcmQgbWVkaWEgcXVlcnkgY29tYmluYXRpb25zXG4gICAgICAvLyB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXG4gICAgICAvLyBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXG5cbiAgICAgIGlmIChpdGVtWzBdID09IG51bGwgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcbiAgICAgICAgaWYgKG1lZGlhUXVlcnkgJiYgIWl0ZW1bMl0pIHtcbiAgICAgICAgICBpdGVtWzJdID0gbWVkaWFRdWVyeTtcbiAgICAgICAgfSBlbHNlIGlmIChtZWRpYVF1ZXJ5KSB7XG4gICAgICAgICAgaXRlbVsyXSA9IFwiKFwiLmNvbmNhdChpdGVtWzJdLCBcIikgYW5kIChcIikuY29uY2F0KG1lZGlhUXVlcnksIFwiKVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxpc3QucHVzaChpdGVtKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGxpc3Q7XG59O1xuXG5mdW5jdGlvbiBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCkge1xuICB2YXIgY29udGVudCA9IGl0ZW1bMV0gfHwgJyc7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuXG4gIHZhciBjc3NNYXBwaW5nID0gaXRlbVszXTtcblxuICBpZiAoIWNzc01hcHBpbmcpIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuXG4gIGlmICh1c2VTb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgc291cmNlTWFwcGluZyA9IHRvQ29tbWVudChjc3NNYXBwaW5nKTtcbiAgICB2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgcmV0dXJuIFwiLyojIHNvdXJjZVVSTD1cIi5jb25jYXQoY3NzTWFwcGluZy5zb3VyY2VSb290KS5jb25jYXQoc291cmNlLCBcIiAqL1wiKTtcbiAgICB9KTtcbiAgICByZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXG4nKTtcbiAgfVxuXG4gIHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59IC8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcblxuXG5mdW5jdGlvbiB0b0NvbW1lbnQoc291cmNlTWFwKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICB2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcbiAgdmFyIGRhdGEgPSBcInNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LFwiLmNvbmNhdChiYXNlNjQpO1xuICByZXR1cm4gXCIvKiMgXCIuY29uY2F0KGRhdGEsIFwiICovXCIpO1xufSIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy51dGlscyA9IHJlcXVpcmUoJy4vZGVzL3V0aWxzJyk7XG5leHBvcnRzLkNpcGhlciA9IHJlcXVpcmUoJy4vZGVzL2NpcGhlcicpO1xuZXhwb3J0cy5ERVMgPSByZXF1aXJlKCcuL2Rlcy9kZXMnKTtcbmV4cG9ydHMuQ0JDID0gcmVxdWlyZSgnLi9kZXMvY2JjJyk7XG5leHBvcnRzLkVERSA9IHJlcXVpcmUoJy4vZGVzL2VkZScpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnbWluaW1hbGlzdGljLWFzc2VydCcpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxudmFyIHByb3RvID0ge307XG5cbmZ1bmN0aW9uIENCQ1N0YXRlKGl2KSB7XG4gIGFzc2VydC5lcXVhbChpdi5sZW5ndGgsIDgsICdJbnZhbGlkIElWIGxlbmd0aCcpO1xuXG4gIHRoaXMuaXYgPSBuZXcgQXJyYXkoOCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pdi5sZW5ndGg7IGkrKylcbiAgICB0aGlzLml2W2ldID0gaXZbaV07XG59XG5cbmZ1bmN0aW9uIGluc3RhbnRpYXRlKEJhc2UpIHtcbiAgZnVuY3Rpb24gQ0JDKG9wdGlvbnMpIHtcbiAgICBCYXNlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgdGhpcy5fY2JjSW5pdCgpO1xuICB9XG4gIGluaGVyaXRzKENCQywgQmFzZSk7XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm90byk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIENCQy5wcm90b3R5cGVba2V5XSA9IHByb3RvW2tleV07XG4gIH1cblxuICBDQkMuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IENCQyhvcHRpb25zKTtcbiAgfTtcblxuICByZXR1cm4gQ0JDO1xufVxuXG5leHBvcnRzLmluc3RhbnRpYXRlID0gaW5zdGFudGlhdGU7XG5cbnByb3RvLl9jYmNJbml0ID0gZnVuY3Rpb24gX2NiY0luaXQoKSB7XG4gIHZhciBzdGF0ZSA9IG5ldyBDQkNTdGF0ZSh0aGlzLm9wdGlvbnMuaXYpO1xuICB0aGlzLl9jYmNTdGF0ZSA9IHN0YXRlO1xufTtcblxucHJvdG8uX3VwZGF0ZSA9IGZ1bmN0aW9uIF91cGRhdGUoaW5wLCBpbk9mZiwgb3V0LCBvdXRPZmYpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fY2JjU3RhdGU7XG4gIHZhciBzdXBlclByb3RvID0gdGhpcy5jb25zdHJ1Y3Rvci5zdXBlcl8ucHJvdG90eXBlO1xuXG4gIHZhciBpdiA9IHN0YXRlLml2O1xuICBpZiAodGhpcy50eXBlID09PSAnZW5jcnlwdCcpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYmxvY2tTaXplOyBpKyspXG4gICAgICBpdltpXSBePSBpbnBbaW5PZmYgKyBpXTtcblxuICAgIHN1cGVyUHJvdG8uX3VwZGF0ZS5jYWxsKHRoaXMsIGl2LCAwLCBvdXQsIG91dE9mZik7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYmxvY2tTaXplOyBpKyspXG4gICAgICBpdltpXSA9IG91dFtvdXRPZmYgKyBpXTtcbiAgfSBlbHNlIHtcbiAgICBzdXBlclByb3RvLl91cGRhdGUuY2FsbCh0aGlzLCBpbnAsIGluT2ZmLCBvdXQsIG91dE9mZik7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYmxvY2tTaXplOyBpKyspXG4gICAgICBvdXRbb3V0T2ZmICsgaV0gXj0gaXZbaV07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYmxvY2tTaXplOyBpKyspXG4gICAgICBpdltpXSA9IGlucFtpbk9mZiArIGldO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnbWluaW1hbGlzdGljLWFzc2VydCcpO1xuXG5mdW5jdGlvbiBDaXBoZXIob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXG4gIHRoaXMudHlwZSA9IHRoaXMub3B0aW9ucy50eXBlO1xuICB0aGlzLmJsb2NrU2l6ZSA9IDg7XG4gIHRoaXMuX2luaXQoKTtcblxuICB0aGlzLmJ1ZmZlciA9IG5ldyBBcnJheSh0aGlzLmJsb2NrU2l6ZSk7XG4gIHRoaXMuYnVmZmVyT2ZmID0gMDtcbn1cbm1vZHVsZS5leHBvcnRzID0gQ2lwaGVyO1xuXG5DaXBoZXIucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gX2luaXQoKSB7XG4gIC8vIE1pZ2h0IGJlIG92ZXJyaWRlZFxufTtcblxuQ2lwaGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoZGF0YSkge1xuICBpZiAoZGF0YS5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIFtdO1xuXG4gIGlmICh0aGlzLnR5cGUgPT09ICdkZWNyeXB0JylcbiAgICByZXR1cm4gdGhpcy5fdXBkYXRlRGVjcnlwdChkYXRhKTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLl91cGRhdGVFbmNyeXB0KGRhdGEpO1xufTtcblxuQ2lwaGVyLnByb3RvdHlwZS5fYnVmZmVyID0gZnVuY3Rpb24gX2J1ZmZlcihkYXRhLCBvZmYpIHtcbiAgLy8gQXBwZW5kIGRhdGEgdG8gYnVmZmVyXG4gIHZhciBtaW4gPSBNYXRoLm1pbih0aGlzLmJ1ZmZlci5sZW5ndGggLSB0aGlzLmJ1ZmZlck9mZiwgZGF0YS5sZW5ndGggLSBvZmYpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1pbjsgaSsrKVxuICAgIHRoaXMuYnVmZmVyW3RoaXMuYnVmZmVyT2ZmICsgaV0gPSBkYXRhW29mZiArIGldO1xuICB0aGlzLmJ1ZmZlck9mZiArPSBtaW47XG5cbiAgLy8gU2hpZnQgbmV4dFxuICByZXR1cm4gbWluO1xufTtcblxuQ2lwaGVyLnByb3RvdHlwZS5fZmx1c2hCdWZmZXIgPSBmdW5jdGlvbiBfZmx1c2hCdWZmZXIob3V0LCBvZmYpIHtcbiAgdGhpcy5fdXBkYXRlKHRoaXMuYnVmZmVyLCAwLCBvdXQsIG9mZik7XG4gIHRoaXMuYnVmZmVyT2ZmID0gMDtcbiAgcmV0dXJuIHRoaXMuYmxvY2tTaXplO1xufTtcblxuQ2lwaGVyLnByb3RvdHlwZS5fdXBkYXRlRW5jcnlwdCA9IGZ1bmN0aW9uIF91cGRhdGVFbmNyeXB0KGRhdGEpIHtcbiAgdmFyIGlucHV0T2ZmID0gMDtcbiAgdmFyIG91dHB1dE9mZiA9IDA7XG5cbiAgdmFyIGNvdW50ID0gKCh0aGlzLmJ1ZmZlck9mZiArIGRhdGEubGVuZ3RoKSAvIHRoaXMuYmxvY2tTaXplKSB8IDA7XG4gIHZhciBvdXQgPSBuZXcgQXJyYXkoY291bnQgKiB0aGlzLmJsb2NrU2l6ZSk7XG5cbiAgaWYgKHRoaXMuYnVmZmVyT2ZmICE9PSAwKSB7XG4gICAgaW5wdXRPZmYgKz0gdGhpcy5fYnVmZmVyKGRhdGEsIGlucHV0T2ZmKTtcblxuICAgIGlmICh0aGlzLmJ1ZmZlck9mZiA9PT0gdGhpcy5idWZmZXIubGVuZ3RoKVxuICAgICAgb3V0cHV0T2ZmICs9IHRoaXMuX2ZsdXNoQnVmZmVyKG91dCwgb3V0cHV0T2ZmKTtcbiAgfVxuXG4gIC8vIFdyaXRlIGJsb2Nrc1xuICB2YXIgbWF4ID0gZGF0YS5sZW5ndGggLSAoKGRhdGEubGVuZ3RoIC0gaW5wdXRPZmYpICUgdGhpcy5ibG9ja1NpemUpO1xuICBmb3IgKDsgaW5wdXRPZmYgPCBtYXg7IGlucHV0T2ZmICs9IHRoaXMuYmxvY2tTaXplKSB7XG4gICAgdGhpcy5fdXBkYXRlKGRhdGEsIGlucHV0T2ZmLCBvdXQsIG91dHB1dE9mZik7XG4gICAgb3V0cHV0T2ZmICs9IHRoaXMuYmxvY2tTaXplO1xuICB9XG5cbiAgLy8gUXVldWUgcmVzdFxuICBmb3IgKDsgaW5wdXRPZmYgPCBkYXRhLmxlbmd0aDsgaW5wdXRPZmYrKywgdGhpcy5idWZmZXJPZmYrKylcbiAgICB0aGlzLmJ1ZmZlclt0aGlzLmJ1ZmZlck9mZl0gPSBkYXRhW2lucHV0T2ZmXTtcblxuICByZXR1cm4gb3V0O1xufTtcblxuQ2lwaGVyLnByb3RvdHlwZS5fdXBkYXRlRGVjcnlwdCA9IGZ1bmN0aW9uIF91cGRhdGVEZWNyeXB0KGRhdGEpIHtcbiAgdmFyIGlucHV0T2ZmID0gMDtcbiAgdmFyIG91dHB1dE9mZiA9IDA7XG5cbiAgdmFyIGNvdW50ID0gTWF0aC5jZWlsKCh0aGlzLmJ1ZmZlck9mZiArIGRhdGEubGVuZ3RoKSAvIHRoaXMuYmxvY2tTaXplKSAtIDE7XG4gIHZhciBvdXQgPSBuZXcgQXJyYXkoY291bnQgKiB0aGlzLmJsb2NrU2l6ZSk7XG5cbiAgLy8gVE9ETyhpbmR1dG55KTogb3B0aW1pemUgaXQsIHRoaXMgaXMgZmFyIGZyb20gb3B0aW1hbFxuICBmb3IgKDsgY291bnQgPiAwOyBjb3VudC0tKSB7XG4gICAgaW5wdXRPZmYgKz0gdGhpcy5fYnVmZmVyKGRhdGEsIGlucHV0T2ZmKTtcbiAgICBvdXRwdXRPZmYgKz0gdGhpcy5fZmx1c2hCdWZmZXIob3V0LCBvdXRwdXRPZmYpO1xuICB9XG5cbiAgLy8gQnVmZmVyIHJlc3Qgb2YgdGhlIGlucHV0XG4gIGlucHV0T2ZmICs9IHRoaXMuX2J1ZmZlcihkYXRhLCBpbnB1dE9mZik7XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cbkNpcGhlci5wcm90b3R5cGUuZmluYWwgPSBmdW5jdGlvbiBmaW5hbChidWZmZXIpIHtcbiAgdmFyIGZpcnN0O1xuICBpZiAoYnVmZmVyKVxuICAgIGZpcnN0ID0gdGhpcy51cGRhdGUoYnVmZmVyKTtcblxuICB2YXIgbGFzdDtcbiAgaWYgKHRoaXMudHlwZSA9PT0gJ2VuY3J5cHQnKVxuICAgIGxhc3QgPSB0aGlzLl9maW5hbEVuY3J5cHQoKTtcbiAgZWxzZVxuICAgIGxhc3QgPSB0aGlzLl9maW5hbERlY3J5cHQoKTtcblxuICBpZiAoZmlyc3QpXG4gICAgcmV0dXJuIGZpcnN0LmNvbmNhdChsYXN0KTtcbiAgZWxzZVxuICAgIHJldHVybiBsYXN0O1xufTtcblxuQ2lwaGVyLnByb3RvdHlwZS5fcGFkID0gZnVuY3Rpb24gX3BhZChidWZmZXIsIG9mZikge1xuICBpZiAob2ZmID09PSAwKVxuICAgIHJldHVybiBmYWxzZTtcblxuICB3aGlsZSAob2ZmIDwgYnVmZmVyLmxlbmd0aClcbiAgICBidWZmZXJbb2ZmKytdID0gMDtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkNpcGhlci5wcm90b3R5cGUuX2ZpbmFsRW5jcnlwdCA9IGZ1bmN0aW9uIF9maW5hbEVuY3J5cHQoKSB7XG4gIGlmICghdGhpcy5fcGFkKHRoaXMuYnVmZmVyLCB0aGlzLmJ1ZmZlck9mZikpXG4gICAgcmV0dXJuIFtdO1xuXG4gIHZhciBvdXQgPSBuZXcgQXJyYXkodGhpcy5ibG9ja1NpemUpO1xuICB0aGlzLl91cGRhdGUodGhpcy5idWZmZXIsIDAsIG91dCwgMCk7XG4gIHJldHVybiBvdXQ7XG59O1xuXG5DaXBoZXIucHJvdG90eXBlLl91bnBhZCA9IGZ1bmN0aW9uIF91bnBhZChidWZmZXIpIHtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn07XG5cbkNpcGhlci5wcm90b3R5cGUuX2ZpbmFsRGVjcnlwdCA9IGZ1bmN0aW9uIF9maW5hbERlY3J5cHQoKSB7XG4gIGFzc2VydC5lcXVhbCh0aGlzLmJ1ZmZlck9mZiwgdGhpcy5ibG9ja1NpemUsICdOb3QgZW5vdWdoIGRhdGEgdG8gZGVjcnlwdCcpO1xuICB2YXIgb3V0ID0gbmV3IEFycmF5KHRoaXMuYmxvY2tTaXplKTtcbiAgdGhpcy5fZmx1c2hCdWZmZXIob3V0LCAwKTtcblxuICByZXR1cm4gdGhpcy5fdW5wYWQob3V0KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdtaW5pbWFsaXN0aWMtYXNzZXJ0Jyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG52YXIgZGVzID0gcmVxdWlyZSgnLi4vZGVzJyk7XG52YXIgdXRpbHMgPSBkZXMudXRpbHM7XG52YXIgQ2lwaGVyID0gZGVzLkNpcGhlcjtcblxuZnVuY3Rpb24gREVTU3RhdGUoKSB7XG4gIHRoaXMudG1wID0gbmV3IEFycmF5KDIpO1xuICB0aGlzLmtleXMgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBERVMob3B0aW9ucykge1xuICBDaXBoZXIuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICB2YXIgc3RhdGUgPSBuZXcgREVTU3RhdGUoKTtcbiAgdGhpcy5fZGVzU3RhdGUgPSBzdGF0ZTtcblxuICB0aGlzLmRlcml2ZUtleXMoc3RhdGUsIG9wdGlvbnMua2V5KTtcbn1cbmluaGVyaXRzKERFUywgQ2lwaGVyKTtcbm1vZHVsZS5leHBvcnRzID0gREVTO1xuXG5ERVMuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBERVMob3B0aW9ucyk7XG59O1xuXG52YXIgc2hpZnRUYWJsZSA9IFtcbiAgMSwgMSwgMiwgMiwgMiwgMiwgMiwgMixcbiAgMSwgMiwgMiwgMiwgMiwgMiwgMiwgMVxuXTtcblxuREVTLnByb3RvdHlwZS5kZXJpdmVLZXlzID0gZnVuY3Rpb24gZGVyaXZlS2V5cyhzdGF0ZSwga2V5KSB7XG4gIHN0YXRlLmtleXMgPSBuZXcgQXJyYXkoMTYgKiAyKTtcblxuICBhc3NlcnQuZXF1YWwoa2V5Lmxlbmd0aCwgdGhpcy5ibG9ja1NpemUsICdJbnZhbGlkIGtleSBsZW5ndGgnKTtcblxuICB2YXIga0wgPSB1dGlscy5yZWFkVUludDMyQkUoa2V5LCAwKTtcbiAgdmFyIGtSID0gdXRpbHMucmVhZFVJbnQzMkJFKGtleSwgNCk7XG5cbiAgdXRpbHMucGMxKGtMLCBrUiwgc3RhdGUudG1wLCAwKTtcbiAga0wgPSBzdGF0ZS50bXBbMF07XG4gIGtSID0gc3RhdGUudG1wWzFdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlLmtleXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2YXIgc2hpZnQgPSBzaGlmdFRhYmxlW2kgPj4+IDFdO1xuICAgIGtMID0gdXRpbHMucjI4c2hsKGtMLCBzaGlmdCk7XG4gICAga1IgPSB1dGlscy5yMjhzaGwoa1IsIHNoaWZ0KTtcbiAgICB1dGlscy5wYzIoa0wsIGtSLCBzdGF0ZS5rZXlzLCBpKTtcbiAgfVxufTtcblxuREVTLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gX3VwZGF0ZShpbnAsIGluT2ZmLCBvdXQsIG91dE9mZikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9kZXNTdGF0ZTtcblxuICB2YXIgbCA9IHV0aWxzLnJlYWRVSW50MzJCRShpbnAsIGluT2ZmKTtcbiAgdmFyIHIgPSB1dGlscy5yZWFkVUludDMyQkUoaW5wLCBpbk9mZiArIDQpO1xuXG4gIC8vIEluaXRpYWwgUGVybXV0YXRpb25cbiAgdXRpbHMuaXAobCwgciwgc3RhdGUudG1wLCAwKTtcbiAgbCA9IHN0YXRlLnRtcFswXTtcbiAgciA9IHN0YXRlLnRtcFsxXTtcblxuICBpZiAodGhpcy50eXBlID09PSAnZW5jcnlwdCcpXG4gICAgdGhpcy5fZW5jcnlwdChzdGF0ZSwgbCwgciwgc3RhdGUudG1wLCAwKTtcbiAgZWxzZVxuICAgIHRoaXMuX2RlY3J5cHQoc3RhdGUsIGwsIHIsIHN0YXRlLnRtcCwgMCk7XG5cbiAgbCA9IHN0YXRlLnRtcFswXTtcbiAgciA9IHN0YXRlLnRtcFsxXTtcblxuICB1dGlscy53cml0ZVVJbnQzMkJFKG91dCwgbCwgb3V0T2ZmKTtcbiAgdXRpbHMud3JpdGVVSW50MzJCRShvdXQsIHIsIG91dE9mZiArIDQpO1xufTtcblxuREVTLnByb3RvdHlwZS5fcGFkID0gZnVuY3Rpb24gX3BhZChidWZmZXIsIG9mZikge1xuICB2YXIgdmFsdWUgPSBidWZmZXIubGVuZ3RoIC0gb2ZmO1xuICBmb3IgKHZhciBpID0gb2ZmOyBpIDwgYnVmZmVyLmxlbmd0aDsgaSsrKVxuICAgIGJ1ZmZlcltpXSA9IHZhbHVlO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuREVTLnByb3RvdHlwZS5fdW5wYWQgPSBmdW5jdGlvbiBfdW5wYWQoYnVmZmVyKSB7XG4gIHZhciBwYWQgPSBidWZmZXJbYnVmZmVyLmxlbmd0aCAtIDFdO1xuICBmb3IgKHZhciBpID0gYnVmZmVyLmxlbmd0aCAtIHBhZDsgaSA8IGJ1ZmZlci5sZW5ndGg7IGkrKylcbiAgICBhc3NlcnQuZXF1YWwoYnVmZmVyW2ldLCBwYWQpO1xuXG4gIHJldHVybiBidWZmZXIuc2xpY2UoMCwgYnVmZmVyLmxlbmd0aCAtIHBhZCk7XG59O1xuXG5ERVMucHJvdG90eXBlLl9lbmNyeXB0ID0gZnVuY3Rpb24gX2VuY3J5cHQoc3RhdGUsIGxTdGFydCwgclN0YXJ0LCBvdXQsIG9mZikge1xuICB2YXIgbCA9IGxTdGFydDtcbiAgdmFyIHIgPSByU3RhcnQ7XG5cbiAgLy8gQXBwbHkgZigpIHgxNiB0aW1lc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlLmtleXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2YXIga2V5TCA9IHN0YXRlLmtleXNbaV07XG4gICAgdmFyIGtleVIgPSBzdGF0ZS5rZXlzW2kgKyAxXTtcblxuICAgIC8vIGYociwgaylcbiAgICB1dGlscy5leHBhbmQociwgc3RhdGUudG1wLCAwKTtcblxuICAgIGtleUwgXj0gc3RhdGUudG1wWzBdO1xuICAgIGtleVIgXj0gc3RhdGUudG1wWzFdO1xuICAgIHZhciBzID0gdXRpbHMuc3Vic3RpdHV0ZShrZXlMLCBrZXlSKTtcbiAgICB2YXIgZiA9IHV0aWxzLnBlcm11dGUocyk7XG5cbiAgICB2YXIgdCA9IHI7XG4gICAgciA9IChsIF4gZikgPj4+IDA7XG4gICAgbCA9IHQ7XG4gIH1cblxuICAvLyBSZXZlcnNlIEluaXRpYWwgUGVybXV0YXRpb25cbiAgdXRpbHMucmlwKHIsIGwsIG91dCwgb2ZmKTtcbn07XG5cbkRFUy5wcm90b3R5cGUuX2RlY3J5cHQgPSBmdW5jdGlvbiBfZGVjcnlwdChzdGF0ZSwgbFN0YXJ0LCByU3RhcnQsIG91dCwgb2ZmKSB7XG4gIHZhciBsID0gclN0YXJ0O1xuICB2YXIgciA9IGxTdGFydDtcblxuICAvLyBBcHBseSBmKCkgeDE2IHRpbWVzXG4gIGZvciAodmFyIGkgPSBzdGF0ZS5rZXlzLmxlbmd0aCAtIDI7IGkgPj0gMDsgaSAtPSAyKSB7XG4gICAgdmFyIGtleUwgPSBzdGF0ZS5rZXlzW2ldO1xuICAgIHZhciBrZXlSID0gc3RhdGUua2V5c1tpICsgMV07XG5cbiAgICAvLyBmKHIsIGspXG4gICAgdXRpbHMuZXhwYW5kKGwsIHN0YXRlLnRtcCwgMCk7XG5cbiAgICBrZXlMIF49IHN0YXRlLnRtcFswXTtcbiAgICBrZXlSIF49IHN0YXRlLnRtcFsxXTtcbiAgICB2YXIgcyA9IHV0aWxzLnN1YnN0aXR1dGUoa2V5TCwga2V5Uik7XG4gICAgdmFyIGYgPSB1dGlscy5wZXJtdXRlKHMpO1xuXG4gICAgdmFyIHQgPSBsO1xuICAgIGwgPSAociBeIGYpID4+PiAwO1xuICAgIHIgPSB0O1xuICB9XG5cbiAgLy8gUmV2ZXJzZSBJbml0aWFsIFBlcm11dGF0aW9uXG4gIHV0aWxzLnJpcChsLCByLCBvdXQsIG9mZik7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnbWluaW1hbGlzdGljLWFzc2VydCcpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxudmFyIGRlcyA9IHJlcXVpcmUoJy4uL2RlcycpO1xudmFyIENpcGhlciA9IGRlcy5DaXBoZXI7XG52YXIgREVTID0gZGVzLkRFUztcblxuZnVuY3Rpb24gRURFU3RhdGUodHlwZSwga2V5KSB7XG4gIGFzc2VydC5lcXVhbChrZXkubGVuZ3RoLCAyNCwgJ0ludmFsaWQga2V5IGxlbmd0aCcpO1xuXG4gIHZhciBrMSA9IGtleS5zbGljZSgwLCA4KTtcbiAgdmFyIGsyID0ga2V5LnNsaWNlKDgsIDE2KTtcbiAgdmFyIGszID0ga2V5LnNsaWNlKDE2LCAyNCk7XG5cbiAgaWYgKHR5cGUgPT09ICdlbmNyeXB0Jykge1xuICAgIHRoaXMuY2lwaGVycyA9IFtcbiAgICAgIERFUy5jcmVhdGUoeyB0eXBlOiAnZW5jcnlwdCcsIGtleTogazEgfSksXG4gICAgICBERVMuY3JlYXRlKHsgdHlwZTogJ2RlY3J5cHQnLCBrZXk6IGsyIH0pLFxuICAgICAgREVTLmNyZWF0ZSh7IHR5cGU6ICdlbmNyeXB0Jywga2V5OiBrMyB9KVxuICAgIF07XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5jaXBoZXJzID0gW1xuICAgICAgREVTLmNyZWF0ZSh7IHR5cGU6ICdkZWNyeXB0Jywga2V5OiBrMyB9KSxcbiAgICAgIERFUy5jcmVhdGUoeyB0eXBlOiAnZW5jcnlwdCcsIGtleTogazIgfSksXG4gICAgICBERVMuY3JlYXRlKHsgdHlwZTogJ2RlY3J5cHQnLCBrZXk6IGsxIH0pXG4gICAgXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBFREUob3B0aW9ucykge1xuICBDaXBoZXIuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICB2YXIgc3RhdGUgPSBuZXcgRURFU3RhdGUodGhpcy50eXBlLCB0aGlzLm9wdGlvbnMua2V5KTtcbiAgdGhpcy5fZWRlU3RhdGUgPSBzdGF0ZTtcbn1cbmluaGVyaXRzKEVERSwgQ2lwaGVyKTtcblxubW9kdWxlLmV4cG9ydHMgPSBFREU7XG5cbkVERS5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUob3B0aW9ucykge1xuICByZXR1cm4gbmV3IEVERShvcHRpb25zKTtcbn07XG5cbkVERS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIF91cGRhdGUoaW5wLCBpbk9mZiwgb3V0LCBvdXRPZmYpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fZWRlU3RhdGU7XG5cbiAgc3RhdGUuY2lwaGVyc1swXS5fdXBkYXRlKGlucCwgaW5PZmYsIG91dCwgb3V0T2ZmKTtcbiAgc3RhdGUuY2lwaGVyc1sxXS5fdXBkYXRlKG91dCwgb3V0T2ZmLCBvdXQsIG91dE9mZik7XG4gIHN0YXRlLmNpcGhlcnNbMl0uX3VwZGF0ZShvdXQsIG91dE9mZiwgb3V0LCBvdXRPZmYpO1xufTtcblxuRURFLnByb3RvdHlwZS5fcGFkID0gREVTLnByb3RvdHlwZS5fcGFkO1xuRURFLnByb3RvdHlwZS5fdW5wYWQgPSBERVMucHJvdG90eXBlLl91bnBhZDtcbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUoYnl0ZXMsIG9mZikge1xuICB2YXIgcmVzID0gIChieXRlc1swICsgb2ZmXSA8PCAyNCkgfFxuICAgICAgICAgICAgIChieXRlc1sxICsgb2ZmXSA8PCAxNikgfFxuICAgICAgICAgICAgIChieXRlc1syICsgb2ZmXSA8PCA4KSB8XG4gICAgICAgICAgICAgYnl0ZXNbMyArIG9mZl07XG4gIHJldHVybiByZXMgPj4+IDA7XG59O1xuXG5leHBvcnRzLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFKGJ5dGVzLCB2YWx1ZSwgb2ZmKSB7XG4gIGJ5dGVzWzAgKyBvZmZdID0gdmFsdWUgPj4+IDI0O1xuICBieXRlc1sxICsgb2ZmXSA9ICh2YWx1ZSA+Pj4gMTYpICYgMHhmZjtcbiAgYnl0ZXNbMiArIG9mZl0gPSAodmFsdWUgPj4+IDgpICYgMHhmZjtcbiAgYnl0ZXNbMyArIG9mZl0gPSB2YWx1ZSAmIDB4ZmY7XG59O1xuXG5leHBvcnRzLmlwID0gZnVuY3Rpb24gaXAoaW5MLCBpblIsIG91dCwgb2ZmKSB7XG4gIHZhciBvdXRMID0gMDtcbiAgdmFyIG91dFIgPSAwO1xuXG4gIGZvciAodmFyIGkgPSA2OyBpID49IDA7IGkgLT0gMikge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDw9IDI0OyBqICs9IDgpIHtcbiAgICAgIG91dEwgPDw9IDE7XG4gICAgICBvdXRMIHw9IChpblIgPj4+IChqICsgaSkpICYgMTtcbiAgICB9XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPD0gMjQ7IGogKz0gOCkge1xuICAgICAgb3V0TCA8PD0gMTtcbiAgICAgIG91dEwgfD0gKGluTCA+Pj4gKGogKyBpKSkgJiAxO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGkgPSA2OyBpID49IDA7IGkgLT0gMikge1xuICAgIGZvciAodmFyIGogPSAxOyBqIDw9IDI1OyBqICs9IDgpIHtcbiAgICAgIG91dFIgPDw9IDE7XG4gICAgICBvdXRSIHw9IChpblIgPj4+IChqICsgaSkpICYgMTtcbiAgICB9XG4gICAgZm9yICh2YXIgaiA9IDE7IGogPD0gMjU7IGogKz0gOCkge1xuICAgICAgb3V0UiA8PD0gMTtcbiAgICAgIG91dFIgfD0gKGluTCA+Pj4gKGogKyBpKSkgJiAxO1xuICAgIH1cbiAgfVxuXG4gIG91dFtvZmYgKyAwXSA9IG91dEwgPj4+IDA7XG4gIG91dFtvZmYgKyAxXSA9IG91dFIgPj4+IDA7XG59O1xuXG5leHBvcnRzLnJpcCA9IGZ1bmN0aW9uIHJpcChpbkwsIGluUiwgb3V0LCBvZmYpIHtcbiAgdmFyIG91dEwgPSAwO1xuICB2YXIgb3V0UiA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICBmb3IgKHZhciBqID0gMjQ7IGogPj0gMDsgaiAtPSA4KSB7XG4gICAgICBvdXRMIDw8PSAxO1xuICAgICAgb3V0TCB8PSAoaW5SID4+PiAoaiArIGkpKSAmIDE7XG4gICAgICBvdXRMIDw8PSAxO1xuICAgICAgb3V0TCB8PSAoaW5MID4+PiAoaiArIGkpKSAmIDE7XG4gICAgfVxuICB9XG4gIGZvciAodmFyIGkgPSA0OyBpIDwgODsgaSsrKSB7XG4gICAgZm9yICh2YXIgaiA9IDI0OyBqID49IDA7IGogLT0gOCkge1xuICAgICAgb3V0UiA8PD0gMTtcbiAgICAgIG91dFIgfD0gKGluUiA+Pj4gKGogKyBpKSkgJiAxO1xuICAgICAgb3V0UiA8PD0gMTtcbiAgICAgIG91dFIgfD0gKGluTCA+Pj4gKGogKyBpKSkgJiAxO1xuICAgIH1cbiAgfVxuXG4gIG91dFtvZmYgKyAwXSA9IG91dEwgPj4+IDA7XG4gIG91dFtvZmYgKyAxXSA9IG91dFIgPj4+IDA7XG59O1xuXG5leHBvcnRzLnBjMSA9IGZ1bmN0aW9uIHBjMShpbkwsIGluUiwgb3V0LCBvZmYpIHtcbiAgdmFyIG91dEwgPSAwO1xuICB2YXIgb3V0UiA9IDA7XG5cbiAgLy8gNywgMTUsIDIzLCAzMSwgMzksIDQ3LCA1NSwgNjNcbiAgLy8gNiwgMTQsIDIyLCAzMCwgMzksIDQ3LCA1NSwgNjNcbiAgLy8gNSwgMTMsIDIxLCAyOSwgMzksIDQ3LCA1NSwgNjNcbiAgLy8gNCwgMTIsIDIwLCAyOFxuICBmb3IgKHZhciBpID0gNzsgaSA+PSA1OyBpLS0pIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8PSAyNDsgaiArPSA4KSB7XG4gICAgICBvdXRMIDw8PSAxO1xuICAgICAgb3V0TCB8PSAoaW5SID4+IChqICsgaSkpICYgMTtcbiAgICB9XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPD0gMjQ7IGogKz0gOCkge1xuICAgICAgb3V0TCA8PD0gMTtcbiAgICAgIG91dEwgfD0gKGluTCA+PiAoaiArIGkpKSAmIDE7XG4gICAgfVxuICB9XG4gIGZvciAodmFyIGogPSAwOyBqIDw9IDI0OyBqICs9IDgpIHtcbiAgICBvdXRMIDw8PSAxO1xuICAgIG91dEwgfD0gKGluUiA+PiAoaiArIGkpKSAmIDE7XG4gIH1cblxuICAvLyAxLCA5LCAxNywgMjUsIDMzLCA0MSwgNDksIDU3XG4gIC8vIDIsIDEwLCAxOCwgMjYsIDM0LCA0MiwgNTAsIDU4XG4gIC8vIDMsIDExLCAxOSwgMjcsIDM1LCA0MywgNTEsIDU5XG4gIC8vIDM2LCA0NCwgNTIsIDYwXG4gIGZvciAodmFyIGkgPSAxOyBpIDw9IDM7IGkrKykge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDw9IDI0OyBqICs9IDgpIHtcbiAgICAgIG91dFIgPDw9IDE7XG4gICAgICBvdXRSIHw9IChpblIgPj4gKGogKyBpKSkgJiAxO1xuICAgIH1cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8PSAyNDsgaiArPSA4KSB7XG4gICAgICBvdXRSIDw8PSAxO1xuICAgICAgb3V0UiB8PSAoaW5MID4+IChqICsgaSkpICYgMTtcbiAgICB9XG4gIH1cbiAgZm9yICh2YXIgaiA9IDA7IGogPD0gMjQ7IGogKz0gOCkge1xuICAgIG91dFIgPDw9IDE7XG4gICAgb3V0UiB8PSAoaW5MID4+IChqICsgaSkpICYgMTtcbiAgfVxuXG4gIG91dFtvZmYgKyAwXSA9IG91dEwgPj4+IDA7XG4gIG91dFtvZmYgKyAxXSA9IG91dFIgPj4+IDA7XG59O1xuXG5leHBvcnRzLnIyOHNobCA9IGZ1bmN0aW9uIHIyOHNobChudW0sIHNoaWZ0KSB7XG4gIHJldHVybiAoKG51bSA8PCBzaGlmdCkgJiAweGZmZmZmZmYpIHwgKG51bSA+Pj4gKDI4IC0gc2hpZnQpKTtcbn07XG5cbnZhciBwYzJ0YWJsZSA9IFtcbiAgLy8gaW5MID0+IG91dExcbiAgMTQsIDExLCAxNywgNCwgMjcsIDIzLCAyNSwgMCxcbiAgMTMsIDIyLCA3LCAxOCwgNSwgOSwgMTYsIDI0LFxuICAyLCAyMCwgMTIsIDIxLCAxLCA4LCAxNSwgMjYsXG5cbiAgLy8gaW5SID0+IG91dFJcbiAgMTUsIDQsIDI1LCAxOSwgOSwgMSwgMjYsIDE2LFxuICA1LCAxMSwgMjMsIDgsIDEyLCA3LCAxNywgMCxcbiAgMjIsIDMsIDEwLCAxNCwgNiwgMjAsIDI3LCAyNFxuXTtcblxuZXhwb3J0cy5wYzIgPSBmdW5jdGlvbiBwYzIoaW5MLCBpblIsIG91dCwgb2ZmKSB7XG4gIHZhciBvdXRMID0gMDtcbiAgdmFyIG91dFIgPSAwO1xuXG4gIHZhciBsZW4gPSBwYzJ0YWJsZS5sZW5ndGggPj4+IDE7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBvdXRMIDw8PSAxO1xuICAgIG91dEwgfD0gKGluTCA+Pj4gcGMydGFibGVbaV0pICYgMHgxO1xuICB9XG4gIGZvciAodmFyIGkgPSBsZW47IGkgPCBwYzJ0YWJsZS5sZW5ndGg7IGkrKykge1xuICAgIG91dFIgPDw9IDE7XG4gICAgb3V0UiB8PSAoaW5SID4+PiBwYzJ0YWJsZVtpXSkgJiAweDE7XG4gIH1cblxuICBvdXRbb2ZmICsgMF0gPSBvdXRMID4+PiAwO1xuICBvdXRbb2ZmICsgMV0gPSBvdXRSID4+PiAwO1xufTtcblxuZXhwb3J0cy5leHBhbmQgPSBmdW5jdGlvbiBleHBhbmQociwgb3V0LCBvZmYpIHtcbiAgdmFyIG91dEwgPSAwO1xuICB2YXIgb3V0UiA9IDA7XG5cbiAgb3V0TCA9ICgociAmIDEpIDw8IDUpIHwgKHIgPj4+IDI3KTtcbiAgZm9yICh2YXIgaSA9IDIzOyBpID49IDE1OyBpIC09IDQpIHtcbiAgICBvdXRMIDw8PSA2O1xuICAgIG91dEwgfD0gKHIgPj4+IGkpICYgMHgzZjtcbiAgfVxuICBmb3IgKHZhciBpID0gMTE7IGkgPj0gMzsgaSAtPSA0KSB7XG4gICAgb3V0UiB8PSAociA+Pj4gaSkgJiAweDNmO1xuICAgIG91dFIgPDw9IDY7XG4gIH1cbiAgb3V0UiB8PSAoKHIgJiAweDFmKSA8PCAxKSB8IChyID4+PiAzMSk7XG5cbiAgb3V0W29mZiArIDBdID0gb3V0TCA+Pj4gMDtcbiAgb3V0W29mZiArIDFdID0gb3V0UiA+Pj4gMDtcbn07XG5cbnZhciBzVGFibGUgPSBbXG4gIDE0LCAwLCA0LCAxNSwgMTMsIDcsIDEsIDQsIDIsIDE0LCAxNSwgMiwgMTEsIDEzLCA4LCAxLFxuICAzLCAxMCwgMTAsIDYsIDYsIDEyLCAxMiwgMTEsIDUsIDksIDksIDUsIDAsIDMsIDcsIDgsXG4gIDQsIDE1LCAxLCAxMiwgMTQsIDgsIDgsIDIsIDEzLCA0LCA2LCA5LCAyLCAxLCAxMSwgNyxcbiAgMTUsIDUsIDEyLCAxMSwgOSwgMywgNywgMTQsIDMsIDEwLCAxMCwgMCwgNSwgNiwgMCwgMTMsXG5cbiAgMTUsIDMsIDEsIDEzLCA4LCA0LCAxNCwgNywgNiwgMTUsIDExLCAyLCAzLCA4LCA0LCAxNCxcbiAgOSwgMTIsIDcsIDAsIDIsIDEsIDEzLCAxMCwgMTIsIDYsIDAsIDksIDUsIDExLCAxMCwgNSxcbiAgMCwgMTMsIDE0LCA4LCA3LCAxMCwgMTEsIDEsIDEwLCAzLCA0LCAxNSwgMTMsIDQsIDEsIDIsXG4gIDUsIDExLCA4LCA2LCAxMiwgNywgNiwgMTIsIDksIDAsIDMsIDUsIDIsIDE0LCAxNSwgOSxcblxuICAxMCwgMTMsIDAsIDcsIDksIDAsIDE0LCA5LCA2LCAzLCAzLCA0LCAxNSwgNiwgNSwgMTAsXG4gIDEsIDIsIDEzLCA4LCAxMiwgNSwgNywgMTQsIDExLCAxMiwgNCwgMTEsIDIsIDE1LCA4LCAxLFxuICAxMywgMSwgNiwgMTAsIDQsIDEzLCA5LCAwLCA4LCA2LCAxNSwgOSwgMywgOCwgMCwgNyxcbiAgMTEsIDQsIDEsIDE1LCAyLCAxNCwgMTIsIDMsIDUsIDExLCAxMCwgNSwgMTQsIDIsIDcsIDEyLFxuXG4gIDcsIDEzLCAxMywgOCwgMTQsIDExLCAzLCA1LCAwLCA2LCA2LCAxNSwgOSwgMCwgMTAsIDMsXG4gIDEsIDQsIDIsIDcsIDgsIDIsIDUsIDEyLCAxMSwgMSwgMTIsIDEwLCA0LCAxNCwgMTUsIDksXG4gIDEwLCAzLCA2LCAxNSwgOSwgMCwgMCwgNiwgMTIsIDEwLCAxMSwgMSwgNywgMTMsIDEzLCA4LFxuICAxNSwgOSwgMSwgNCwgMywgNSwgMTQsIDExLCA1LCAxMiwgMiwgNywgOCwgMiwgNCwgMTQsXG5cbiAgMiwgMTQsIDEyLCAxMSwgNCwgMiwgMSwgMTIsIDcsIDQsIDEwLCA3LCAxMSwgMTMsIDYsIDEsXG4gIDgsIDUsIDUsIDAsIDMsIDE1LCAxNSwgMTAsIDEzLCAzLCAwLCA5LCAxNCwgOCwgOSwgNixcbiAgNCwgMTEsIDIsIDgsIDEsIDEyLCAxMSwgNywgMTAsIDEsIDEzLCAxNCwgNywgMiwgOCwgMTMsXG4gIDE1LCA2LCA5LCAxNSwgMTIsIDAsIDUsIDksIDYsIDEwLCAzLCA0LCAwLCA1LCAxNCwgMyxcblxuICAxMiwgMTAsIDEsIDE1LCAxMCwgNCwgMTUsIDIsIDksIDcsIDIsIDEyLCA2LCA5LCA4LCA1LFxuICAwLCA2LCAxMywgMSwgMywgMTMsIDQsIDE0LCAxNCwgMCwgNywgMTEsIDUsIDMsIDExLCA4LFxuICA5LCA0LCAxNCwgMywgMTUsIDIsIDUsIDEyLCAyLCA5LCA4LCA1LCAxMiwgMTUsIDMsIDEwLFxuICA3LCAxMSwgMCwgMTQsIDQsIDEsIDEwLCA3LCAxLCA2LCAxMywgMCwgMTEsIDgsIDYsIDEzLFxuXG4gIDQsIDEzLCAxMSwgMCwgMiwgMTEsIDE0LCA3LCAxNSwgNCwgMCwgOSwgOCwgMSwgMTMsIDEwLFxuICAzLCAxNCwgMTIsIDMsIDksIDUsIDcsIDEyLCA1LCAyLCAxMCwgMTUsIDYsIDgsIDEsIDYsXG4gIDEsIDYsIDQsIDExLCAxMSwgMTMsIDEzLCA4LCAxMiwgMSwgMywgNCwgNywgMTAsIDE0LCA3LFxuICAxMCwgOSwgMTUsIDUsIDYsIDAsIDgsIDE1LCAwLCAxNCwgNSwgMiwgOSwgMywgMiwgMTIsXG5cbiAgMTMsIDEsIDIsIDE1LCA4LCAxMywgNCwgOCwgNiwgMTAsIDE1LCAzLCAxMSwgNywgMSwgNCxcbiAgMTAsIDEyLCA5LCA1LCAzLCA2LCAxNCwgMTEsIDUsIDAsIDAsIDE0LCAxMiwgOSwgNywgMixcbiAgNywgMiwgMTEsIDEsIDQsIDE0LCAxLCA3LCA5LCA0LCAxMiwgMTAsIDE0LCA4LCAyLCAxMyxcbiAgMCwgMTUsIDYsIDEyLCAxMCwgOSwgMTMsIDAsIDE1LCAzLCAzLCA1LCA1LCA2LCA4LCAxMVxuXTtcblxuZXhwb3J0cy5zdWJzdGl0dXRlID0gZnVuY3Rpb24gc3Vic3RpdHV0ZShpbkwsIGluUikge1xuICB2YXIgb3V0ID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICB2YXIgYiA9IChpbkwgPj4+ICgxOCAtIGkgKiA2KSkgJiAweDNmO1xuICAgIHZhciBzYiA9IHNUYWJsZVtpICogMHg0MCArIGJdO1xuXG4gICAgb3V0IDw8PSA0O1xuICAgIG91dCB8PSBzYjtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgIHZhciBiID0gKGluUiA+Pj4gKDE4IC0gaSAqIDYpKSAmIDB4M2Y7XG4gICAgdmFyIHNiID0gc1RhYmxlWzQgKiAweDQwICsgaSAqIDB4NDAgKyBiXTtcblxuICAgIG91dCA8PD0gNDtcbiAgICBvdXQgfD0gc2I7XG4gIH1cbiAgcmV0dXJuIG91dCA+Pj4gMDtcbn07XG5cbnZhciBwZXJtdXRlVGFibGUgPSBbXG4gIDE2LCAyNSwgMTIsIDExLCAzLCAyMCwgNCwgMTUsIDMxLCAxNywgOSwgNiwgMjcsIDE0LCAxLCAyMixcbiAgMzAsIDI0LCA4LCAxOCwgMCwgNSwgMjksIDIzLCAxMywgMTksIDIsIDI2LCAxMCwgMjEsIDI4LCA3XG5dO1xuXG5leHBvcnRzLnBlcm11dGUgPSBmdW5jdGlvbiBwZXJtdXRlKG51bSkge1xuICB2YXIgb3V0ID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwZXJtdXRlVGFibGUubGVuZ3RoOyBpKyspIHtcbiAgICBvdXQgPDw9IDE7XG4gICAgb3V0IHw9IChudW0gPj4+IHBlcm11dGVUYWJsZVtpXSkgJiAweDE7XG4gIH1cbiAgcmV0dXJuIG91dCA+Pj4gMDtcbn07XG5cbmV4cG9ydHMucGFkU3BsaXQgPSBmdW5jdGlvbiBwYWRTcGxpdChudW0sIHNpemUsIGdyb3VwKSB7XG4gIHZhciBzdHIgPSBudW0udG9TdHJpbmcoMik7XG4gIHdoaWxlIChzdHIubGVuZ3RoIDwgc2l6ZSlcbiAgICBzdHIgPSAnMCcgKyBzdHI7XG5cbiAgdmFyIG91dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkgKz0gZ3JvdXApXG4gICAgb3V0LnB1c2goc3RyLnNsaWNlKGksIGkgKyBncm91cCkpO1xuICByZXR1cm4gb3V0LmpvaW4oJyAnKTtcbn07XG4iLCJ2YXIgZ2VuZXJhdGVQcmltZSA9IHJlcXVpcmUoJy4vbGliL2dlbmVyYXRlUHJpbWUnKVxudmFyIHByaW1lcyA9IHJlcXVpcmUoJy4vbGliL3ByaW1lcy5qc29uJylcblxudmFyIERIID0gcmVxdWlyZSgnLi9saWIvZGgnKVxuXG5mdW5jdGlvbiBnZXREaWZmaWVIZWxsbWFuIChtb2QpIHtcbiAgdmFyIHByaW1lID0gbmV3IEJ1ZmZlcihwcmltZXNbbW9kXS5wcmltZSwgJ2hleCcpXG4gIHZhciBnZW4gPSBuZXcgQnVmZmVyKHByaW1lc1ttb2RdLmdlbiwgJ2hleCcpXG5cbiAgcmV0dXJuIG5ldyBESChwcmltZSwgZ2VuKVxufVxuXG52YXIgRU5DT0RJTkdTID0ge1xuICAnYmluYXJ5JzogdHJ1ZSwgJ2hleCc6IHRydWUsICdiYXNlNjQnOiB0cnVlXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURpZmZpZUhlbGxtYW4gKHByaW1lLCBlbmMsIGdlbmVyYXRvciwgZ2VuYykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGVuYykgfHwgRU5DT0RJTkdTW2VuY10gPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBjcmVhdGVEaWZmaWVIZWxsbWFuKHByaW1lLCAnYmluYXJ5JywgZW5jLCBnZW5lcmF0b3IpXG4gIH1cblxuICBlbmMgPSBlbmMgfHwgJ2JpbmFyeSdcbiAgZ2VuYyA9IGdlbmMgfHwgJ2JpbmFyeSdcbiAgZ2VuZXJhdG9yID0gZ2VuZXJhdG9yIHx8IG5ldyBCdWZmZXIoWzJdKVxuXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGdlbmVyYXRvcikpIHtcbiAgICBnZW5lcmF0b3IgPSBuZXcgQnVmZmVyKGdlbmVyYXRvciwgZ2VuYylcbiAgfVxuXG4gIGlmICh0eXBlb2YgcHJpbWUgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIG5ldyBESChnZW5lcmF0ZVByaW1lKHByaW1lLCBnZW5lcmF0b3IpLCBnZW5lcmF0b3IsIHRydWUpXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihwcmltZSkpIHtcbiAgICBwcmltZSA9IG5ldyBCdWZmZXIocHJpbWUsIGVuYylcbiAgfVxuXG4gIHJldHVybiBuZXcgREgocHJpbWUsIGdlbmVyYXRvciwgdHJ1ZSlcbn1cblxuZXhwb3J0cy5EaWZmaWVIZWxsbWFuR3JvdXAgPSBleHBvcnRzLmNyZWF0ZURpZmZpZUhlbGxtYW5Hcm91cCA9IGV4cG9ydHMuZ2V0RGlmZmllSGVsbG1hbiA9IGdldERpZmZpZUhlbGxtYW5cbmV4cG9ydHMuY3JlYXRlRGlmZmllSGVsbG1hbiA9IGV4cG9ydHMuRGlmZmllSGVsbG1hbiA9IGNyZWF0ZURpZmZpZUhlbGxtYW5cbiIsInZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG52YXIgTWlsbGVyUmFiaW4gPSByZXF1aXJlKCdtaWxsZXItcmFiaW4nKTtcbnZhciBtaWxsZXJSYWJpbiA9IG5ldyBNaWxsZXJSYWJpbigpO1xudmFyIFRXRU5UWUZPVVIgPSBuZXcgQk4oMjQpO1xudmFyIEVMRVZFTiA9IG5ldyBCTigxMSk7XG52YXIgVEVOID0gbmV3IEJOKDEwKTtcbnZhciBUSFJFRSA9IG5ldyBCTigzKTtcbnZhciBTRVZFTiA9IG5ldyBCTig3KTtcbnZhciBwcmltZXMgPSByZXF1aXJlKCcuL2dlbmVyYXRlUHJpbWUnKTtcbnZhciByYW5kb21CeXRlcyA9IHJlcXVpcmUoJ3JhbmRvbWJ5dGVzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IERIO1xuXG5mdW5jdGlvbiBzZXRQdWJsaWNLZXkocHViLCBlbmMpIHtcbiAgZW5jID0gZW5jIHx8ICd1dGY4JztcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIocHViKSkge1xuICAgIHB1YiA9IG5ldyBCdWZmZXIocHViLCBlbmMpO1xuICB9XG4gIHRoaXMuX3B1YiA9IG5ldyBCTihwdWIpO1xuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gc2V0UHJpdmF0ZUtleShwcml2LCBlbmMpIHtcbiAgZW5jID0gZW5jIHx8ICd1dGY4JztcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIocHJpdikpIHtcbiAgICBwcml2ID0gbmV3IEJ1ZmZlcihwcml2LCBlbmMpO1xuICB9XG4gIHRoaXMuX3ByaXYgPSBuZXcgQk4ocHJpdik7XG4gIHJldHVybiB0aGlzO1xufVxuXG52YXIgcHJpbWVDYWNoZSA9IHt9O1xuZnVuY3Rpb24gY2hlY2tQcmltZShwcmltZSwgZ2VuZXJhdG9yKSB7XG4gIHZhciBnZW4gPSBnZW5lcmF0b3IudG9TdHJpbmcoJ2hleCcpO1xuICB2YXIgaGV4ID0gW2dlbiwgcHJpbWUudG9TdHJpbmcoMTYpXS5qb2luKCdfJyk7XG4gIGlmIChoZXggaW4gcHJpbWVDYWNoZSkge1xuICAgIHJldHVybiBwcmltZUNhY2hlW2hleF07XG4gIH1cbiAgdmFyIGVycm9yID0gMDtcblxuICBpZiAocHJpbWUuaXNFdmVuKCkgfHxcbiAgICAhcHJpbWVzLnNpbXBsZVNpZXZlIHx8XG4gICAgIXByaW1lcy5mZXJtYXRUZXN0KHByaW1lKSB8fFxuICAgICFtaWxsZXJSYWJpbi50ZXN0KHByaW1lKSkge1xuICAgIC8vbm90IGEgcHJpbWUgc28gKzFcbiAgICBlcnJvciArPSAxO1xuXG4gICAgaWYgKGdlbiA9PT0gJzAyJyB8fCBnZW4gPT09ICcwNScpIHtcbiAgICAgIC8vIHdlJ2QgYmUgYWJsZSB0byBjaGVjayB0aGUgZ2VuZXJhdG9yXG4gICAgICAvLyBpdCB3b3VsZCBmYWlsIHNvICs4XG4gICAgICBlcnJvciArPSA4O1xuICAgIH0gZWxzZSB7XG4gICAgICAvL3dlIHdvdWxkbid0IGJlIGFibGUgdG8gdGVzdCB0aGUgZ2VuZXJhdG9yXG4gICAgICAvLyBzbyArNFxuICAgICAgZXJyb3IgKz0gNDtcbiAgICB9XG4gICAgcHJpbWVDYWNoZVtoZXhdID0gZXJyb3I7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG4gIGlmICghbWlsbGVyUmFiaW4udGVzdChwcmltZS5zaHJuKDEpKSkge1xuICAgIC8vbm90IGEgc2FmZSBwcmltZVxuICAgIGVycm9yICs9IDI7XG4gIH1cbiAgdmFyIHJlbTtcbiAgc3dpdGNoIChnZW4pIHtcbiAgICBjYXNlICcwMic6XG4gICAgICBpZiAocHJpbWUubW9kKFRXRU5UWUZPVVIpLmNtcChFTEVWRU4pKSB7XG4gICAgICAgIC8vIHVuc3VpZGFibGUgZ2VuZXJhdG9yXG4gICAgICAgIGVycm9yICs9IDg7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICcwNSc6XG4gICAgICByZW0gPSBwcmltZS5tb2QoVEVOKTtcbiAgICAgIGlmIChyZW0uY21wKFRIUkVFKSAmJiByZW0uY21wKFNFVkVOKSkge1xuICAgICAgICAvLyBwcmltZSBtb2QgMTAgbmVlZHMgdG8gZXF1YWwgMyBvciA3XG4gICAgICAgIGVycm9yICs9IDg7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgZXJyb3IgKz0gNDtcbiAgfVxuICBwcmltZUNhY2hlW2hleF0gPSBlcnJvcjtcbiAgcmV0dXJuIGVycm9yO1xufVxuXG5mdW5jdGlvbiBESChwcmltZSwgZ2VuZXJhdG9yLCBtYWxsZWFibGUpIHtcbiAgdGhpcy5zZXRHZW5lcmF0b3IoZ2VuZXJhdG9yKTtcbiAgdGhpcy5fX3ByaW1lID0gbmV3IEJOKHByaW1lKTtcbiAgdGhpcy5fcHJpbWUgPSBCTi5tb250KHRoaXMuX19wcmltZSk7XG4gIHRoaXMuX3ByaW1lTGVuID0gcHJpbWUubGVuZ3RoO1xuICB0aGlzLl9wdWIgPSB1bmRlZmluZWQ7XG4gIHRoaXMuX3ByaXYgPSB1bmRlZmluZWQ7XG4gIHRoaXMuX3ByaW1lQ29kZSA9IHVuZGVmaW5lZDtcbiAgaWYgKG1hbGxlYWJsZSkge1xuICAgIHRoaXMuc2V0UHVibGljS2V5ID0gc2V0UHVibGljS2V5O1xuICAgIHRoaXMuc2V0UHJpdmF0ZUtleSA9IHNldFByaXZhdGVLZXk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fcHJpbWVDb2RlID0gODtcbiAgfVxufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KERILnByb3RvdHlwZSwgJ3ZlcmlmeUVycm9yJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuX3ByaW1lQ29kZSAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMuX3ByaW1lQ29kZSA9IGNoZWNrUHJpbWUodGhpcy5fX3ByaW1lLCB0aGlzLl9fZ2VuKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3ByaW1lQ29kZTtcbiAgfVxufSk7XG5ESC5wcm90b3R5cGUuZ2VuZXJhdGVLZXlzID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuX3ByaXYpIHtcbiAgICB0aGlzLl9wcml2ID0gbmV3IEJOKHJhbmRvbUJ5dGVzKHRoaXMuX3ByaW1lTGVuKSk7XG4gIH1cbiAgdGhpcy5fcHViID0gdGhpcy5fZ2VuLnRvUmVkKHRoaXMuX3ByaW1lKS5yZWRQb3codGhpcy5fcHJpdikuZnJvbVJlZCgpO1xuICByZXR1cm4gdGhpcy5nZXRQdWJsaWNLZXkoKTtcbn07XG5cbkRILnByb3RvdHlwZS5jb21wdXRlU2VjcmV0ID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gIG90aGVyID0gbmV3IEJOKG90aGVyKTtcbiAgb3RoZXIgPSBvdGhlci50b1JlZCh0aGlzLl9wcmltZSk7XG4gIHZhciBzZWNyZXQgPSBvdGhlci5yZWRQb3codGhpcy5fcHJpdikuZnJvbVJlZCgpO1xuICB2YXIgb3V0ID0gbmV3IEJ1ZmZlcihzZWNyZXQudG9BcnJheSgpKTtcbiAgdmFyIHByaW1lID0gdGhpcy5nZXRQcmltZSgpO1xuICBpZiAob3V0Lmxlbmd0aCA8IHByaW1lLmxlbmd0aCkge1xuICAgIHZhciBmcm9udCA9IG5ldyBCdWZmZXIocHJpbWUubGVuZ3RoIC0gb3V0Lmxlbmd0aCk7XG4gICAgZnJvbnQuZmlsbCgwKTtcbiAgICBvdXQgPSBCdWZmZXIuY29uY2F0KFtmcm9udCwgb3V0XSk7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5cbkRILnByb3RvdHlwZS5nZXRQdWJsaWNLZXkgPSBmdW5jdGlvbiBnZXRQdWJsaWNLZXkoZW5jKSB7XG4gIHJldHVybiBmb3JtYXRSZXR1cm5WYWx1ZSh0aGlzLl9wdWIsIGVuYyk7XG59O1xuXG5ESC5wcm90b3R5cGUuZ2V0UHJpdmF0ZUtleSA9IGZ1bmN0aW9uIGdldFByaXZhdGVLZXkoZW5jKSB7XG4gIHJldHVybiBmb3JtYXRSZXR1cm5WYWx1ZSh0aGlzLl9wcml2LCBlbmMpO1xufTtcblxuREgucHJvdG90eXBlLmdldFByaW1lID0gZnVuY3Rpb24gKGVuYykge1xuICByZXR1cm4gZm9ybWF0UmV0dXJuVmFsdWUodGhpcy5fX3ByaW1lLCBlbmMpO1xufTtcblxuREgucHJvdG90eXBlLmdldEdlbmVyYXRvciA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgcmV0dXJuIGZvcm1hdFJldHVyblZhbHVlKHRoaXMuX2dlbiwgZW5jKTtcbn07XG5cbkRILnByb3RvdHlwZS5zZXRHZW5lcmF0b3IgPSBmdW5jdGlvbiAoZ2VuLCBlbmMpIHtcbiAgZW5jID0gZW5jIHx8ICd1dGY4JztcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoZ2VuKSkge1xuICAgIGdlbiA9IG5ldyBCdWZmZXIoZ2VuLCBlbmMpO1xuICB9XG4gIHRoaXMuX19nZW4gPSBnZW47XG4gIHRoaXMuX2dlbiA9IG5ldyBCTihnZW4pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGZvcm1hdFJldHVyblZhbHVlKGJuLCBlbmMpIHtcbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoYm4udG9BcnJheSgpKTtcbiAgaWYgKCFlbmMpIHtcbiAgICByZXR1cm4gYnVmO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBidWYudG9TdHJpbmcoZW5jKTtcbiAgfVxufVxuIiwidmFyIHJhbmRvbUJ5dGVzID0gcmVxdWlyZSgncmFuZG9tYnl0ZXMnKTtcbm1vZHVsZS5leHBvcnRzID0gZmluZFByaW1lO1xuZmluZFByaW1lLnNpbXBsZVNpZXZlID0gc2ltcGxlU2lldmU7XG5maW5kUHJpbWUuZmVybWF0VGVzdCA9IGZlcm1hdFRlc3Q7XG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIFRXRU5UWUZPVVIgPSBuZXcgQk4oMjQpO1xudmFyIE1pbGxlclJhYmluID0gcmVxdWlyZSgnbWlsbGVyLXJhYmluJyk7XG52YXIgbWlsbGVyUmFiaW4gPSBuZXcgTWlsbGVyUmFiaW4oKTtcbnZhciBPTkUgPSBuZXcgQk4oMSk7XG52YXIgVFdPID0gbmV3IEJOKDIpO1xudmFyIEZJVkUgPSBuZXcgQk4oNSk7XG52YXIgU0lYVEVFTiA9IG5ldyBCTigxNik7XG52YXIgRUlHSFQgPSBuZXcgQk4oOCk7XG52YXIgVEVOID0gbmV3IEJOKDEwKTtcbnZhciBUSFJFRSA9IG5ldyBCTigzKTtcbnZhciBTRVZFTiA9IG5ldyBCTig3KTtcbnZhciBFTEVWRU4gPSBuZXcgQk4oMTEpO1xudmFyIEZPVVIgPSBuZXcgQk4oNCk7XG52YXIgVFdFTFZFID0gbmV3IEJOKDEyKTtcbnZhciBwcmltZXMgPSBudWxsO1xuXG5mdW5jdGlvbiBfZ2V0UHJpbWVzKCkge1xuICBpZiAocHJpbWVzICE9PSBudWxsKVxuICAgIHJldHVybiBwcmltZXM7XG5cbiAgdmFyIGxpbWl0ID0gMHgxMDAwMDA7XG4gIHZhciByZXMgPSBbXTtcbiAgcmVzWzBdID0gMjtcbiAgZm9yICh2YXIgaSA9IDEsIGsgPSAzOyBrIDwgbGltaXQ7IGsgKz0gMikge1xuICAgIHZhciBzcXJ0ID0gTWF0aC5jZWlsKE1hdGguc3FydChrKSk7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBpICYmIHJlc1tqXSA8PSBzcXJ0OyBqKyspXG4gICAgICBpZiAoayAlIHJlc1tqXSA9PT0gMClcbiAgICAgICAgYnJlYWs7XG5cbiAgICBpZiAoaSAhPT0gaiAmJiByZXNbal0gPD0gc3FydClcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgcmVzW2krK10gPSBrO1xuICB9XG4gIHByaW1lcyA9IHJlcztcbiAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gc2ltcGxlU2lldmUocCkge1xuICB2YXIgcHJpbWVzID0gX2dldFByaW1lcygpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJpbWVzLmxlbmd0aDsgaSsrKVxuICAgIGlmIChwLm1vZG4ocHJpbWVzW2ldKSA9PT0gMCkge1xuICAgICAgaWYgKHAuY21wbihwcmltZXNbaV0pID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZmVybWF0VGVzdChwKSB7XG4gIHZhciByZWQgPSBCTi5tb250KHApO1xuICByZXR1cm4gVFdPLnRvUmVkKHJlZCkucmVkUG93KHAuc3VibigxKSkuZnJvbVJlZCgpLmNtcG4oMSkgPT09IDA7XG59XG5cbmZ1bmN0aW9uIGZpbmRQcmltZShiaXRzLCBnZW4pIHtcbiAgaWYgKGJpdHMgPCAxNikge1xuICAgIC8vIHRoaXMgaXMgd2hhdCBvcGVuc3NsIGRvZXNcbiAgICBpZiAoZ2VuID09PSAyIHx8IGdlbiA9PT0gNSkge1xuICAgICAgcmV0dXJuIG5ldyBCTihbMHg4YywgMHg3Yl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IEJOKFsweDhjLCAweDI3XSk7XG4gICAgfVxuICB9XG4gIGdlbiA9IG5ldyBCTihnZW4pO1xuXG4gIHZhciBudW0sIG4yO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgbnVtID0gbmV3IEJOKHJhbmRvbUJ5dGVzKE1hdGguY2VpbChiaXRzIC8gOCkpKTtcbiAgICB3aGlsZSAobnVtLmJpdExlbmd0aCgpID4gYml0cykge1xuICAgICAgbnVtLmlzaHJuKDEpO1xuICAgIH1cbiAgICBpZiAobnVtLmlzRXZlbigpKSB7XG4gICAgICBudW0uaWFkZChPTkUpO1xuICAgIH1cbiAgICBpZiAoIW51bS50ZXN0bigxKSkge1xuICAgICAgbnVtLmlhZGQoVFdPKTtcbiAgICB9XG4gICAgaWYgKCFnZW4uY21wKFRXTykpIHtcbiAgICAgIHdoaWxlIChudW0ubW9kKFRXRU5UWUZPVVIpLmNtcChFTEVWRU4pKSB7XG4gICAgICAgIG51bS5pYWRkKEZPVVIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWdlbi5jbXAoRklWRSkpIHtcbiAgICAgIHdoaWxlIChudW0ubW9kKFRFTikuY21wKFRIUkVFKSkge1xuICAgICAgICBudW0uaWFkZChGT1VSKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbjIgPSBudW0uc2hybigxKTtcbiAgICBpZiAoc2ltcGxlU2lldmUobjIpICYmIHNpbXBsZVNpZXZlKG51bSkgJiZcbiAgICAgIGZlcm1hdFRlc3QobjIpICYmIGZlcm1hdFRlc3QobnVtKSAmJlxuICAgICAgbWlsbGVyUmFiaW4udGVzdChuMikgJiYgbWlsbGVyUmFiaW4udGVzdChudW0pKSB7XG4gICAgICByZXR1cm4gbnVtO1xuICAgIH1cbiAgfVxuXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBlbGxpcHRpYyA9IGV4cG9ydHM7XG5cbmVsbGlwdGljLnZlcnNpb24gPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uO1xuZWxsaXB0aWMudXRpbHMgPSByZXF1aXJlKCcuL2VsbGlwdGljL3V0aWxzJyk7XG5lbGxpcHRpYy5yYW5kID0gcmVxdWlyZSgnYnJvcmFuZCcpO1xuZWxsaXB0aWMuY3VydmUgPSByZXF1aXJlKCcuL2VsbGlwdGljL2N1cnZlJyk7XG5lbGxpcHRpYy5jdXJ2ZXMgPSByZXF1aXJlKCcuL2VsbGlwdGljL2N1cnZlcycpO1xuXG4vLyBQcm90b2NvbHNcbmVsbGlwdGljLmVjID0gcmVxdWlyZSgnLi9lbGxpcHRpYy9lYycpO1xuZWxsaXB0aWMuZWRkc2EgPSByZXF1aXJlKCcuL2VsbGlwdGljL2VkZHNhJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIGdldE5BRiA9IHV0aWxzLmdldE5BRjtcbnZhciBnZXRKU0YgPSB1dGlscy5nZXRKU0Y7XG52YXIgYXNzZXJ0ID0gdXRpbHMuYXNzZXJ0O1xuXG5mdW5jdGlvbiBCYXNlQ3VydmUodHlwZSwgY29uZikge1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLnAgPSBuZXcgQk4oY29uZi5wLCAxNik7XG5cbiAgLy8gVXNlIE1vbnRnb21lcnksIHdoZW4gdGhlcmUgaXMgbm8gZmFzdCByZWR1Y3Rpb24gZm9yIHRoZSBwcmltZVxuICB0aGlzLnJlZCA9IGNvbmYucHJpbWUgPyBCTi5yZWQoY29uZi5wcmltZSkgOiBCTi5tb250KHRoaXMucCk7XG5cbiAgLy8gVXNlZnVsIGZvciBtYW55IGN1cnZlc1xuICB0aGlzLnplcm8gPSBuZXcgQk4oMCkudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLm9uZSA9IG5ldyBCTigxKS50b1JlZCh0aGlzLnJlZCk7XG4gIHRoaXMudHdvID0gbmV3IEJOKDIpLnRvUmVkKHRoaXMucmVkKTtcblxuICAvLyBDdXJ2ZSBjb25maWd1cmF0aW9uLCBvcHRpb25hbFxuICB0aGlzLm4gPSBjb25mLm4gJiYgbmV3IEJOKGNvbmYubiwgMTYpO1xuICB0aGlzLmcgPSBjb25mLmcgJiYgdGhpcy5wb2ludEZyb21KU09OKGNvbmYuZywgY29uZi5nUmVkKTtcblxuICAvLyBUZW1wb3JhcnkgYXJyYXlzXG4gIHRoaXMuX3duYWZUMSA9IG5ldyBBcnJheSg0KTtcbiAgdGhpcy5fd25hZlQyID0gbmV3IEFycmF5KDQpO1xuICB0aGlzLl93bmFmVDMgPSBuZXcgQXJyYXkoNCk7XG4gIHRoaXMuX3duYWZUNCA9IG5ldyBBcnJheSg0KTtcblxuICAvLyBHZW5lcmFsaXplZCBHcmVnIE1heHdlbGwncyB0cmlja1xuICB2YXIgYWRqdXN0Q291bnQgPSB0aGlzLm4gJiYgdGhpcy5wLmRpdih0aGlzLm4pO1xuICBpZiAoIWFkanVzdENvdW50IHx8IGFkanVzdENvdW50LmNtcG4oMTAwKSA+IDApIHtcbiAgICB0aGlzLnJlZE4gPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX21heHdlbGxUcmljayA9IHRydWU7XG4gICAgdGhpcy5yZWROID0gdGhpcy5uLnRvUmVkKHRoaXMucmVkKTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBCYXNlQ3VydmU7XG5cbkJhc2VDdXJ2ZS5wcm90b3R5cGUucG9pbnQgPSBmdW5jdGlvbiBwb2ludCgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cbkJhc2VDdXJ2ZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZSgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cbkJhc2VDdXJ2ZS5wcm90b3R5cGUuX2ZpeGVkTmFmTXVsID0gZnVuY3Rpb24gX2ZpeGVkTmFmTXVsKHAsIGspIHtcbiAgYXNzZXJ0KHAucHJlY29tcHV0ZWQpO1xuICB2YXIgZG91YmxlcyA9IHAuX2dldERvdWJsZXMoKTtcblxuICB2YXIgbmFmID0gZ2V0TkFGKGssIDEpO1xuICB2YXIgSSA9ICgxIDw8IChkb3VibGVzLnN0ZXAgKyAxKSkgLSAoZG91Ymxlcy5zdGVwICUgMiA9PT0gMCA/IDIgOiAxKTtcbiAgSSAvPSAzO1xuXG4gIC8vIFRyYW5zbGF0ZSBpbnRvIG1vcmUgd2luZG93ZWQgZm9ybVxuICB2YXIgcmVwciA9IFtdO1xuICBmb3IgKHZhciBqID0gMDsgaiA8IG5hZi5sZW5ndGg7IGogKz0gZG91Ymxlcy5zdGVwKSB7XG4gICAgdmFyIG5hZlcgPSAwO1xuICAgIGZvciAodmFyIGsgPSBqICsgZG91Ymxlcy5zdGVwIC0gMTsgayA+PSBqOyBrLS0pXG4gICAgICBuYWZXID0gKG5hZlcgPDwgMSkgKyBuYWZba107XG4gICAgcmVwci5wdXNoKG5hZlcpO1xuICB9XG5cbiAgdmFyIGEgPSB0aGlzLmpwb2ludChudWxsLCBudWxsLCBudWxsKTtcbiAgdmFyIGIgPSB0aGlzLmpwb2ludChudWxsLCBudWxsLCBudWxsKTtcbiAgZm9yICh2YXIgaSA9IEk7IGkgPiAwOyBpLS0pIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlcHIubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBuYWZXID0gcmVwcltqXTtcbiAgICAgIGlmIChuYWZXID09PSBpKVxuICAgICAgICBiID0gYi5taXhlZEFkZChkb3VibGVzLnBvaW50c1tqXSk7XG4gICAgICBlbHNlIGlmIChuYWZXID09PSAtaSlcbiAgICAgICAgYiA9IGIubWl4ZWRBZGQoZG91Ymxlcy5wb2ludHNbal0ubmVnKCkpO1xuICAgIH1cbiAgICBhID0gYS5hZGQoYik7XG4gIH1cbiAgcmV0dXJuIGEudG9QKCk7XG59O1xuXG5CYXNlQ3VydmUucHJvdG90eXBlLl93bmFmTXVsID0gZnVuY3Rpb24gX3duYWZNdWwocCwgaykge1xuICB2YXIgdyA9IDQ7XG5cbiAgLy8gUHJlY29tcHV0ZSB3aW5kb3dcbiAgdmFyIG5hZlBvaW50cyA9IHAuX2dldE5BRlBvaW50cyh3KTtcbiAgdyA9IG5hZlBvaW50cy53bmQ7XG4gIHZhciB3bmQgPSBuYWZQb2ludHMucG9pbnRzO1xuXG4gIC8vIEdldCBOQUYgZm9ybVxuICB2YXIgbmFmID0gZ2V0TkFGKGssIHcpO1xuXG4gIC8vIEFkZCBgdGhpc2AqKE4rMSkgZm9yIGV2ZXJ5IHctTkFGIGluZGV4XG4gIHZhciBhY2MgPSB0aGlzLmpwb2ludChudWxsLCBudWxsLCBudWxsKTtcbiAgZm9yICh2YXIgaSA9IG5hZi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIC8vIENvdW50IHplcm9lc1xuICAgIGZvciAodmFyIGsgPSAwOyBpID49IDAgJiYgbmFmW2ldID09PSAwOyBpLS0pXG4gICAgICBrKys7XG4gICAgaWYgKGkgPj0gMClcbiAgICAgIGsrKztcbiAgICBhY2MgPSBhY2MuZGJscChrKTtcblxuICAgIGlmIChpIDwgMClcbiAgICAgIGJyZWFrO1xuICAgIHZhciB6ID0gbmFmW2ldO1xuICAgIGFzc2VydCh6ICE9PSAwKTtcbiAgICBpZiAocC50eXBlID09PSAnYWZmaW5lJykge1xuICAgICAgLy8gSiArLSBQXG4gICAgICBpZiAoeiA+IDApXG4gICAgICAgIGFjYyA9IGFjYy5taXhlZEFkZCh3bmRbKHogLSAxKSA+PiAxXSk7XG4gICAgICBlbHNlXG4gICAgICAgIGFjYyA9IGFjYy5taXhlZEFkZCh3bmRbKC16IC0gMSkgPj4gMV0ubmVnKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBKICstIEpcbiAgICAgIGlmICh6ID4gMClcbiAgICAgICAgYWNjID0gYWNjLmFkZCh3bmRbKHogLSAxKSA+PiAxXSk7XG4gICAgICBlbHNlXG4gICAgICAgIGFjYyA9IGFjYy5hZGQod25kWygteiAtIDEpID4+IDFdLm5lZygpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHAudHlwZSA9PT0gJ2FmZmluZScgPyBhY2MudG9QKCkgOiBhY2M7XG59O1xuXG5CYXNlQ3VydmUucHJvdG90eXBlLl93bmFmTXVsQWRkID0gZnVuY3Rpb24gX3duYWZNdWxBZGQoZGVmVyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29lZmZzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqYWNvYmlhblJlc3VsdCkge1xuICB2YXIgd25kV2lkdGggPSB0aGlzLl93bmFmVDE7XG4gIHZhciB3bmQgPSB0aGlzLl93bmFmVDI7XG4gIHZhciBuYWYgPSB0aGlzLl93bmFmVDM7XG5cbiAgLy8gRmlsbCBhbGwgYXJyYXlzXG4gIHZhciBtYXggPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIHAgPSBwb2ludHNbaV07XG4gICAgdmFyIG5hZlBvaW50cyA9IHAuX2dldE5BRlBvaW50cyhkZWZXKTtcbiAgICB3bmRXaWR0aFtpXSA9IG5hZlBvaW50cy53bmQ7XG4gICAgd25kW2ldID0gbmFmUG9pbnRzLnBvaW50cztcbiAgfVxuXG4gIC8vIENvbWIgc21hbGwgd2luZG93IE5BRnNcbiAgZm9yICh2YXIgaSA9IGxlbiAtIDE7IGkgPj0gMTsgaSAtPSAyKSB7XG4gICAgdmFyIGEgPSBpIC0gMTtcbiAgICB2YXIgYiA9IGk7XG4gICAgaWYgKHduZFdpZHRoW2FdICE9PSAxIHx8IHduZFdpZHRoW2JdICE9PSAxKSB7XG4gICAgICBuYWZbYV0gPSBnZXROQUYoY29lZmZzW2FdLCB3bmRXaWR0aFthXSk7XG4gICAgICBuYWZbYl0gPSBnZXROQUYoY29lZmZzW2JdLCB3bmRXaWR0aFtiXSk7XG4gICAgICBtYXggPSBNYXRoLm1heChuYWZbYV0ubGVuZ3RoLCBtYXgpO1xuICAgICAgbWF4ID0gTWF0aC5tYXgobmFmW2JdLmxlbmd0aCwgbWF4KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBjb21iID0gW1xuICAgICAgcG9pbnRzW2FdLCAvKiAxICovXG4gICAgICBudWxsLCAvKiAzICovXG4gICAgICBudWxsLCAvKiA1ICovXG4gICAgICBwb2ludHNbYl0gLyogNyAqL1xuICAgIF07XG5cbiAgICAvLyBUcnkgdG8gYXZvaWQgUHJvamVjdGl2ZSBwb2ludHMsIGlmIHBvc3NpYmxlXG4gICAgaWYgKHBvaW50c1thXS55LmNtcChwb2ludHNbYl0ueSkgPT09IDApIHtcbiAgICAgIGNvbWJbMV0gPSBwb2ludHNbYV0uYWRkKHBvaW50c1tiXSk7XG4gICAgICBjb21iWzJdID0gcG9pbnRzW2FdLnRvSigpLm1peGVkQWRkKHBvaW50c1tiXS5uZWcoKSk7XG4gICAgfSBlbHNlIGlmIChwb2ludHNbYV0ueS5jbXAocG9pbnRzW2JdLnkucmVkTmVnKCkpID09PSAwKSB7XG4gICAgICBjb21iWzFdID0gcG9pbnRzW2FdLnRvSigpLm1peGVkQWRkKHBvaW50c1tiXSk7XG4gICAgICBjb21iWzJdID0gcG9pbnRzW2FdLmFkZChwb2ludHNbYl0ubmVnKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb21iWzFdID0gcG9pbnRzW2FdLnRvSigpLm1peGVkQWRkKHBvaW50c1tiXSk7XG4gICAgICBjb21iWzJdID0gcG9pbnRzW2FdLnRvSigpLm1peGVkQWRkKHBvaW50c1tiXS5uZWcoKSk7XG4gICAgfVxuXG4gICAgdmFyIGluZGV4ID0gW1xuICAgICAgLTMsIC8qIC0xIC0xICovXG4gICAgICAtMSwgLyogLTEgMCAqL1xuICAgICAgLTUsIC8qIC0xIDEgKi9cbiAgICAgIC03LCAvKiAwIC0xICovXG4gICAgICAwLCAvKiAwIDAgKi9cbiAgICAgIDcsIC8qIDAgMSAqL1xuICAgICAgNSwgLyogMSAtMSAqL1xuICAgICAgMSwgLyogMSAwICovXG4gICAgICAzICAvKiAxIDEgKi9cbiAgICBdO1xuXG4gICAgdmFyIGpzZiA9IGdldEpTRihjb2VmZnNbYV0sIGNvZWZmc1tiXSk7XG4gICAgbWF4ID0gTWF0aC5tYXgoanNmWzBdLmxlbmd0aCwgbWF4KTtcbiAgICBuYWZbYV0gPSBuZXcgQXJyYXkobWF4KTtcbiAgICBuYWZbYl0gPSBuZXcgQXJyYXkobWF4KTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1heDsgaisrKSB7XG4gICAgICB2YXIgamEgPSBqc2ZbMF1bal0gfCAwO1xuICAgICAgdmFyIGpiID0ganNmWzFdW2pdIHwgMDtcblxuICAgICAgbmFmW2FdW2pdID0gaW5kZXhbKGphICsgMSkgKiAzICsgKGpiICsgMSldO1xuICAgICAgbmFmW2JdW2pdID0gMDtcbiAgICAgIHduZFthXSA9IGNvbWI7XG4gICAgfVxuICB9XG5cbiAgdmFyIGFjYyA9IHRoaXMuanBvaW50KG51bGwsIG51bGwsIG51bGwpO1xuICB2YXIgdG1wID0gdGhpcy5fd25hZlQ0O1xuICBmb3IgKHZhciBpID0gbWF4OyBpID49IDA7IGktLSkge1xuICAgIHZhciBrID0gMDtcblxuICAgIHdoaWxlIChpID49IDApIHtcbiAgICAgIHZhciB6ZXJvID0gdHJ1ZTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgdG1wW2pdID0gbmFmW2pdW2ldIHwgMDtcbiAgICAgICAgaWYgKHRtcFtqXSAhPT0gMClcbiAgICAgICAgICB6ZXJvID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoIXplcm8pXG4gICAgICAgIGJyZWFrO1xuICAgICAgaysrO1xuICAgICAgaS0tO1xuICAgIH1cbiAgICBpZiAoaSA+PSAwKVxuICAgICAgaysrO1xuICAgIGFjYyA9IGFjYy5kYmxwKGspO1xuICAgIGlmIChpIDwgMClcbiAgICAgIGJyZWFrO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW47IGorKykge1xuICAgICAgdmFyIHogPSB0bXBbal07XG4gICAgICB2YXIgcDtcbiAgICAgIGlmICh6ID09PSAwKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGVsc2UgaWYgKHogPiAwKVxuICAgICAgICBwID0gd25kW2pdWyh6IC0gMSkgPj4gMV07XG4gICAgICBlbHNlIGlmICh6IDwgMClcbiAgICAgICAgcCA9IHduZFtqXVsoLXogLSAxKSA+PiAxXS5uZWcoKTtcblxuICAgICAgaWYgKHAudHlwZSA9PT0gJ2FmZmluZScpXG4gICAgICAgIGFjYyA9IGFjYy5taXhlZEFkZChwKTtcbiAgICAgIGVsc2VcbiAgICAgICAgYWNjID0gYWNjLmFkZChwKTtcbiAgICB9XG4gIH1cbiAgLy8gWmVyb2lmeSByZWZlcmVuY2VzXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgd25kW2ldID0gbnVsbDtcblxuICBpZiAoamFjb2JpYW5SZXN1bHQpXG4gICAgcmV0dXJuIGFjYztcbiAgZWxzZVxuICAgIHJldHVybiBhY2MudG9QKCk7XG59O1xuXG5mdW5jdGlvbiBCYXNlUG9pbnQoY3VydmUsIHR5cGUpIHtcbiAgdGhpcy5jdXJ2ZSA9IGN1cnZlO1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLnByZWNvbXB1dGVkID0gbnVsbDtcbn1cbkJhc2VDdXJ2ZS5CYXNlUG9pbnQgPSBCYXNlUG9pbnQ7XG5cbkJhc2VQb2ludC5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiBlcSgvKm90aGVyKi8pIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZSgpIHtcbiAgcmV0dXJuIHRoaXMuY3VydmUudmFsaWRhdGUodGhpcyk7XG59O1xuXG5CYXNlQ3VydmUucHJvdG90eXBlLmRlY29kZVBvaW50ID0gZnVuY3Rpb24gZGVjb2RlUG9pbnQoYnl0ZXMsIGVuYykge1xuICBieXRlcyA9IHV0aWxzLnRvQXJyYXkoYnl0ZXMsIGVuYyk7XG5cbiAgdmFyIGxlbiA9IHRoaXMucC5ieXRlTGVuZ3RoKCk7XG5cbiAgLy8gdW5jb21wcmVzc2VkLCBoeWJyaWQtb2RkLCBoeWJyaWQtZXZlblxuICBpZiAoKGJ5dGVzWzBdID09PSAweDA0IHx8IGJ5dGVzWzBdID09PSAweDA2IHx8IGJ5dGVzWzBdID09PSAweDA3KSAmJlxuICAgICAgYnl0ZXMubGVuZ3RoIC0gMSA9PT0gMiAqIGxlbikge1xuICAgIGlmIChieXRlc1swXSA9PT0gMHgwNilcbiAgICAgIGFzc2VydChieXRlc1tieXRlcy5sZW5ndGggLSAxXSAlIDIgPT09IDApO1xuICAgIGVsc2UgaWYgKGJ5dGVzWzBdID09PSAweDA3KVxuICAgICAgYXNzZXJ0KGJ5dGVzW2J5dGVzLmxlbmd0aCAtIDFdICUgMiA9PT0gMSk7XG5cbiAgICB2YXIgcmVzID0gIHRoaXMucG9pbnQoYnl0ZXMuc2xpY2UoMSwgMSArIGxlbiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzLnNsaWNlKDEgKyBsZW4sIDEgKyAyICogbGVuKSk7XG5cbiAgICByZXR1cm4gcmVzO1xuICB9IGVsc2UgaWYgKChieXRlc1swXSA9PT0gMHgwMiB8fCBieXRlc1swXSA9PT0gMHgwMykgJiZcbiAgICAgICAgICAgICAgYnl0ZXMubGVuZ3RoIC0gMSA9PT0gbGVuKSB7XG4gICAgcmV0dXJuIHRoaXMucG9pbnRGcm9tWChieXRlcy5zbGljZSgxLCAxICsgbGVuKSwgYnl0ZXNbMF0gPT09IDB4MDMpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcignVW5rbm93biBwb2ludCBmb3JtYXQnKTtcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUuZW5jb2RlQ29tcHJlc3NlZCA9IGZ1bmN0aW9uIGVuY29kZUNvbXByZXNzZWQoZW5jKSB7XG4gIHJldHVybiB0aGlzLmVuY29kZShlbmMsIHRydWUpO1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5fZW5jb2RlID0gZnVuY3Rpb24gX2VuY29kZShjb21wYWN0KSB7XG4gIHZhciBsZW4gPSB0aGlzLmN1cnZlLnAuYnl0ZUxlbmd0aCgpO1xuICB2YXIgeCA9IHRoaXMuZ2V0WCgpLnRvQXJyYXkoJ2JlJywgbGVuKTtcblxuICBpZiAoY29tcGFjdClcbiAgICByZXR1cm4gWyB0aGlzLmdldFkoKS5pc0V2ZW4oKSA/IDB4MDIgOiAweDAzIF0uY29uY2F0KHgpO1xuXG4gIHJldHVybiBbIDB4MDQgXS5jb25jYXQoeCwgdGhpcy5nZXRZKCkudG9BcnJheSgnYmUnLCBsZW4pKSA7XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShlbmMsIGNvbXBhY3QpIHtcbiAgcmV0dXJuIHV0aWxzLmVuY29kZSh0aGlzLl9lbmNvZGUoY29tcGFjdCksIGVuYyk7XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLnByZWNvbXB1dGUgPSBmdW5jdGlvbiBwcmVjb21wdXRlKHBvd2VyKSB7XG4gIGlmICh0aGlzLnByZWNvbXB1dGVkKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIHZhciBwcmVjb21wdXRlZCA9IHtcbiAgICBkb3VibGVzOiBudWxsLFxuICAgIG5hZjogbnVsbCxcbiAgICBiZXRhOiBudWxsXG4gIH07XG4gIHByZWNvbXB1dGVkLm5hZiA9IHRoaXMuX2dldE5BRlBvaW50cyg4KTtcbiAgcHJlY29tcHV0ZWQuZG91YmxlcyA9IHRoaXMuX2dldERvdWJsZXMoNCwgcG93ZXIpO1xuICBwcmVjb21wdXRlZC5iZXRhID0gdGhpcy5fZ2V0QmV0YSgpO1xuICB0aGlzLnByZWNvbXB1dGVkID0gcHJlY29tcHV0ZWQ7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLl9oYXNEb3VibGVzID0gZnVuY3Rpb24gX2hhc0RvdWJsZXMoaykge1xuICBpZiAoIXRoaXMucHJlY29tcHV0ZWQpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBkb3VibGVzID0gdGhpcy5wcmVjb21wdXRlZC5kb3VibGVzO1xuICBpZiAoIWRvdWJsZXMpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIHJldHVybiBkb3VibGVzLnBvaW50cy5sZW5ndGggPj0gTWF0aC5jZWlsKChrLmJpdExlbmd0aCgpICsgMSkgLyBkb3VibGVzLnN0ZXApO1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5fZ2V0RG91YmxlcyA9IGZ1bmN0aW9uIF9nZXREb3VibGVzKHN0ZXAsIHBvd2VyKSB7XG4gIGlmICh0aGlzLnByZWNvbXB1dGVkICYmIHRoaXMucHJlY29tcHV0ZWQuZG91YmxlcylcbiAgICByZXR1cm4gdGhpcy5wcmVjb21wdXRlZC5kb3VibGVzO1xuXG4gIHZhciBkb3VibGVzID0gWyB0aGlzIF07XG4gIHZhciBhY2MgPSB0aGlzO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBvd2VyOyBpICs9IHN0ZXApIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN0ZXA7IGorKylcbiAgICAgIGFjYyA9IGFjYy5kYmwoKTtcbiAgICBkb3VibGVzLnB1c2goYWNjKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHN0ZXA6IHN0ZXAsXG4gICAgcG9pbnRzOiBkb3VibGVzXG4gIH07XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLl9nZXROQUZQb2ludHMgPSBmdW5jdGlvbiBfZ2V0TkFGUG9pbnRzKHduZCkge1xuICBpZiAodGhpcy5wcmVjb21wdXRlZCAmJiB0aGlzLnByZWNvbXB1dGVkLm5hZilcbiAgICByZXR1cm4gdGhpcy5wcmVjb21wdXRlZC5uYWY7XG5cbiAgdmFyIHJlcyA9IFsgdGhpcyBdO1xuICB2YXIgbWF4ID0gKDEgPDwgd25kKSAtIDE7XG4gIHZhciBkYmwgPSBtYXggPT09IDEgPyBudWxsIDogdGhpcy5kYmwoKTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBtYXg7IGkrKylcbiAgICByZXNbaV0gPSByZXNbaSAtIDFdLmFkZChkYmwpO1xuICByZXR1cm4ge1xuICAgIHduZDogd25kLFxuICAgIHBvaW50czogcmVzXG4gIH07XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLl9nZXRCZXRhID0gZnVuY3Rpb24gX2dldEJldGEoKSB7XG4gIHJldHVybiBudWxsO1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5kYmxwID0gZnVuY3Rpb24gZGJscChrKSB7XG4gIHZhciByID0gdGhpcztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrOyBpKyspXG4gICAgciA9IHIuZGJsKCk7XG4gIHJldHVybiByO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xudmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcblxudmFyIGFzc2VydCA9IHV0aWxzLmFzc2VydDtcblxuZnVuY3Rpb24gRWR3YXJkc0N1cnZlKGNvbmYpIHtcbiAgLy8gTk9URTogSW1wb3J0YW50IGFzIHdlIGFyZSBjcmVhdGluZyBwb2ludCBpbiBCYXNlLmNhbGwoKVxuICB0aGlzLnR3aXN0ZWQgPSAoY29uZi5hIHwgMCkgIT09IDE7XG4gIHRoaXMubU9uZUEgPSB0aGlzLnR3aXN0ZWQgJiYgKGNvbmYuYSB8IDApID09PSAtMTtcbiAgdGhpcy5leHRlbmRlZCA9IHRoaXMubU9uZUE7XG5cbiAgQmFzZS5jYWxsKHRoaXMsICdlZHdhcmRzJywgY29uZik7XG5cbiAgdGhpcy5hID0gbmV3IEJOKGNvbmYuYSwgMTYpLnVtb2QodGhpcy5yZWQubSk7XG4gIHRoaXMuYSA9IHRoaXMuYS50b1JlZCh0aGlzLnJlZCk7XG4gIHRoaXMuYyA9IG5ldyBCTihjb25mLmMsIDE2KS50b1JlZCh0aGlzLnJlZCk7XG4gIHRoaXMuYzIgPSB0aGlzLmMucmVkU3FyKCk7XG4gIHRoaXMuZCA9IG5ldyBCTihjb25mLmQsIDE2KS50b1JlZCh0aGlzLnJlZCk7XG4gIHRoaXMuZGQgPSB0aGlzLmQucmVkQWRkKHRoaXMuZCk7XG5cbiAgYXNzZXJ0KCF0aGlzLnR3aXN0ZWQgfHwgdGhpcy5jLmZyb21SZWQoKS5jbXBuKDEpID09PSAwKTtcbiAgdGhpcy5vbmVDID0gKGNvbmYuYyB8IDApID09PSAxO1xufVxuaW5oZXJpdHMoRWR3YXJkc0N1cnZlLCBCYXNlKTtcbm1vZHVsZS5leHBvcnRzID0gRWR3YXJkc0N1cnZlO1xuXG5FZHdhcmRzQ3VydmUucHJvdG90eXBlLl9tdWxBID0gZnVuY3Rpb24gX211bEEobnVtKSB7XG4gIGlmICh0aGlzLm1PbmVBKVxuICAgIHJldHVybiBudW0ucmVkTmVnKCk7XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5hLnJlZE11bChudW0pO1xufTtcblxuRWR3YXJkc0N1cnZlLnByb3RvdHlwZS5fbXVsQyA9IGZ1bmN0aW9uIF9tdWxDKG51bSkge1xuICBpZiAodGhpcy5vbmVDKVxuICAgIHJldHVybiBudW07XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5jLnJlZE11bChudW0pO1xufTtcblxuLy8gSnVzdCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIFNob3J0IGN1cnZlXG5FZHdhcmRzQ3VydmUucHJvdG90eXBlLmpwb2ludCA9IGZ1bmN0aW9uIGpwb2ludCh4LCB5LCB6LCB0KSB7XG4gIHJldHVybiB0aGlzLnBvaW50KHgsIHksIHosIHQpO1xufTtcblxuRWR3YXJkc0N1cnZlLnByb3RvdHlwZS5wb2ludEZyb21YID0gZnVuY3Rpb24gcG9pbnRGcm9tWCh4LCBvZGQpIHtcbiAgeCA9IG5ldyBCTih4LCAxNik7XG4gIGlmICgheC5yZWQpXG4gICAgeCA9IHgudG9SZWQodGhpcy5yZWQpO1xuXG4gIHZhciB4MiA9IHgucmVkU3FyKCk7XG4gIHZhciByaHMgPSB0aGlzLmMyLnJlZFN1Yih0aGlzLmEucmVkTXVsKHgyKSk7XG4gIHZhciBsaHMgPSB0aGlzLm9uZS5yZWRTdWIodGhpcy5jMi5yZWRNdWwodGhpcy5kKS5yZWRNdWwoeDIpKTtcblxuICB2YXIgeTIgPSByaHMucmVkTXVsKGxocy5yZWRJbnZtKCkpO1xuICB2YXIgeSA9IHkyLnJlZFNxcnQoKTtcbiAgaWYgKHkucmVkU3FyKCkucmVkU3ViKHkyKS5jbXAodGhpcy56ZXJvKSAhPT0gMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcG9pbnQnKTtcblxuICB2YXIgaXNPZGQgPSB5LmZyb21SZWQoKS5pc09kZCgpO1xuICBpZiAob2RkICYmICFpc09kZCB8fCAhb2RkICYmIGlzT2RkKVxuICAgIHkgPSB5LnJlZE5lZygpO1xuXG4gIHJldHVybiB0aGlzLnBvaW50KHgsIHkpO1xufTtcblxuRWR3YXJkc0N1cnZlLnByb3RvdHlwZS5wb2ludEZyb21ZID0gZnVuY3Rpb24gcG9pbnRGcm9tWSh5LCBvZGQpIHtcbiAgeSA9IG5ldyBCTih5LCAxNik7XG4gIGlmICgheS5yZWQpXG4gICAgeSA9IHkudG9SZWQodGhpcy5yZWQpO1xuXG4gIC8vIHheMiA9ICh5XjIgLSBjXjIpIC8gKGNeMiBkIHleMiAtIGEpXG4gIHZhciB5MiA9IHkucmVkU3FyKCk7XG4gIHZhciBsaHMgPSB5Mi5yZWRTdWIodGhpcy5jMik7XG4gIHZhciByaHMgPSB5Mi5yZWRNdWwodGhpcy5kKS5yZWRNdWwodGhpcy5jMikucmVkU3ViKHRoaXMuYSk7XG4gIHZhciB4MiA9IGxocy5yZWRNdWwocmhzLnJlZEludm0oKSk7XG5cbiAgaWYgKHgyLmNtcCh0aGlzLnplcm8pID09PSAwKSB7XG4gICAgaWYgKG9kZClcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwb2ludCcpO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiB0aGlzLnBvaW50KHRoaXMuemVybywgeSk7XG4gIH1cblxuICB2YXIgeCA9IHgyLnJlZFNxcnQoKTtcbiAgaWYgKHgucmVkU3FyKCkucmVkU3ViKHgyKS5jbXAodGhpcy56ZXJvKSAhPT0gMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcG9pbnQnKTtcblxuICBpZiAoeC5mcm9tUmVkKCkuaXNPZGQoKSAhPT0gb2RkKVxuICAgIHggPSB4LnJlZE5lZygpO1xuXG4gIHJldHVybiB0aGlzLnBvaW50KHgsIHkpO1xufTtcblxuRWR3YXJkc0N1cnZlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIHZhbGlkYXRlKHBvaW50KSB7XG4gIGlmIChwb2ludC5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgLy8gQ3VydmU6IEEgKiBYXjIgKyBZXjIgPSBDXjIgKiAoMSArIEQgKiBYXjIgKiBZXjIpXG4gIHBvaW50Lm5vcm1hbGl6ZSgpO1xuXG4gIHZhciB4MiA9IHBvaW50LngucmVkU3FyKCk7XG4gIHZhciB5MiA9IHBvaW50LnkucmVkU3FyKCk7XG4gIHZhciBsaHMgPSB4Mi5yZWRNdWwodGhpcy5hKS5yZWRBZGQoeTIpO1xuICB2YXIgcmhzID0gdGhpcy5jMi5yZWRNdWwodGhpcy5vbmUucmVkQWRkKHRoaXMuZC5yZWRNdWwoeDIpLnJlZE11bCh5MikpKTtcblxuICByZXR1cm4gbGhzLmNtcChyaHMpID09PSAwO1xufTtcblxuZnVuY3Rpb24gUG9pbnQoY3VydmUsIHgsIHksIHosIHQpIHtcbiAgQmFzZS5CYXNlUG9pbnQuY2FsbCh0aGlzLCBjdXJ2ZSwgJ3Byb2plY3RpdmUnKTtcbiAgaWYgKHggPT09IG51bGwgJiYgeSA9PT0gbnVsbCAmJiB6ID09PSBudWxsKSB7XG4gICAgdGhpcy54ID0gdGhpcy5jdXJ2ZS56ZXJvO1xuICAgIHRoaXMueSA9IHRoaXMuY3VydmUub25lO1xuICAgIHRoaXMueiA9IHRoaXMuY3VydmUub25lO1xuICAgIHRoaXMudCA9IHRoaXMuY3VydmUuemVybztcbiAgICB0aGlzLnpPbmUgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMueCA9IG5ldyBCTih4LCAxNik7XG4gICAgdGhpcy55ID0gbmV3IEJOKHksIDE2KTtcbiAgICB0aGlzLnogPSB6ID8gbmV3IEJOKHosIDE2KSA6IHRoaXMuY3VydmUub25lO1xuICAgIHRoaXMudCA9IHQgJiYgbmV3IEJOKHQsIDE2KTtcbiAgICBpZiAoIXRoaXMueC5yZWQpXG4gICAgICB0aGlzLnggPSB0aGlzLngudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICAgIGlmICghdGhpcy55LnJlZClcbiAgICAgIHRoaXMueSA9IHRoaXMueS50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG4gICAgaWYgKCF0aGlzLnoucmVkKVxuICAgICAgdGhpcy56ID0gdGhpcy56LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcbiAgICBpZiAodGhpcy50ICYmICF0aGlzLnQucmVkKVxuICAgICAgdGhpcy50ID0gdGhpcy50LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcbiAgICB0aGlzLnpPbmUgPSB0aGlzLnogPT09IHRoaXMuY3VydmUub25lO1xuXG4gICAgLy8gVXNlIGV4dGVuZGVkIGNvb3JkaW5hdGVzXG4gICAgaWYgKHRoaXMuY3VydmUuZXh0ZW5kZWQgJiYgIXRoaXMudCkge1xuICAgICAgdGhpcy50ID0gdGhpcy54LnJlZE11bCh0aGlzLnkpO1xuICAgICAgaWYgKCF0aGlzLnpPbmUpXG4gICAgICAgIHRoaXMudCA9IHRoaXMudC5yZWRNdWwodGhpcy56LnJlZEludm0oKSk7XG4gICAgfVxuICB9XG59XG5pbmhlcml0cyhQb2ludCwgQmFzZS5CYXNlUG9pbnQpO1xuXG5FZHdhcmRzQ3VydmUucHJvdG90eXBlLnBvaW50RnJvbUpTT04gPSBmdW5jdGlvbiBwb2ludEZyb21KU09OKG9iaikge1xuICByZXR1cm4gUG9pbnQuZnJvbUpTT04odGhpcywgb2JqKTtcbn07XG5cbkVkd2FyZHNDdXJ2ZS5wcm90b3R5cGUucG9pbnQgPSBmdW5jdGlvbiBwb2ludCh4LCB5LCB6LCB0KSB7XG4gIHJldHVybiBuZXcgUG9pbnQodGhpcywgeCwgeSwgeiwgdCk7XG59O1xuXG5Qb2ludC5mcm9tSlNPTiA9IGZ1bmN0aW9uIGZyb21KU09OKGN1cnZlLCBvYmopIHtcbiAgcmV0dXJuIG5ldyBQb2ludChjdXJ2ZSwgb2JqWzBdLCBvYmpbMV0sIG9ialsyXSk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QoKSB7XG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gJzxFQyBQb2ludCBJbmZpbml0eT4nO1xuICByZXR1cm4gJzxFQyBQb2ludCB4OiAnICsgdGhpcy54LmZyb21SZWQoKS50b1N0cmluZygxNiwgMikgK1xuICAgICAgJyB5OiAnICsgdGhpcy55LmZyb21SZWQoKS50b1N0cmluZygxNiwgMikgK1xuICAgICAgJyB6OiAnICsgdGhpcy56LmZyb21SZWQoKS50b1N0cmluZygxNiwgMikgKyAnPic7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuaXNJbmZpbml0eSA9IGZ1bmN0aW9uIGlzSW5maW5pdHkoKSB7XG4gIC8vIFhYWCBUaGlzIGNvZGUgYXNzdW1lcyB0aGF0IHplcm8gaXMgYWx3YXlzIHplcm8gaW4gcmVkXG4gIHJldHVybiB0aGlzLnguY21wbigwKSA9PT0gMCAmJlxuICAgICh0aGlzLnkuY21wKHRoaXMueikgPT09IDAgfHxcbiAgICAodGhpcy56T25lICYmIHRoaXMueS5jbXAodGhpcy5jdXJ2ZS5jKSA9PT0gMCkpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLl9leHREYmwgPSBmdW5jdGlvbiBfZXh0RGJsKCkge1xuICAvLyBoeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tdHdpc3RlZC1leHRlbmRlZC0xLmh0bWxcbiAgLy8gICAgICNkb3VibGluZy1kYmwtMjAwOC1od2NkXG4gIC8vIDRNICsgNFNcblxuICAvLyBBID0gWDFeMlxuICB2YXIgYSA9IHRoaXMueC5yZWRTcXIoKTtcbiAgLy8gQiA9IFkxXjJcbiAgdmFyIGIgPSB0aGlzLnkucmVkU3FyKCk7XG4gIC8vIEMgPSAyICogWjFeMlxuICB2YXIgYyA9IHRoaXMuei5yZWRTcXIoKTtcbiAgYyA9IGMucmVkSUFkZChjKTtcbiAgLy8gRCA9IGEgKiBBXG4gIHZhciBkID0gdGhpcy5jdXJ2ZS5fbXVsQShhKTtcbiAgLy8gRSA9IChYMSArIFkxKV4yIC0gQSAtIEJcbiAgdmFyIGUgPSB0aGlzLngucmVkQWRkKHRoaXMueSkucmVkU3FyKCkucmVkSVN1YihhKS5yZWRJU3ViKGIpO1xuICAvLyBHID0gRCArIEJcbiAgdmFyIGcgPSBkLnJlZEFkZChiKTtcbiAgLy8gRiA9IEcgLSBDXG4gIHZhciBmID0gZy5yZWRTdWIoYyk7XG4gIC8vIEggPSBEIC0gQlxuICB2YXIgaCA9IGQucmVkU3ViKGIpO1xuICAvLyBYMyA9IEUgKiBGXG4gIHZhciBueCA9IGUucmVkTXVsKGYpO1xuICAvLyBZMyA9IEcgKiBIXG4gIHZhciBueSA9IGcucmVkTXVsKGgpO1xuICAvLyBUMyA9IEUgKiBIXG4gIHZhciBudCA9IGUucmVkTXVsKGgpO1xuICAvLyBaMyA9IEYgKiBHXG4gIHZhciBueiA9IGYucmVkTXVsKGcpO1xuICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChueCwgbnksIG56LCBudCk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuX3Byb2pEYmwgPSBmdW5jdGlvbiBfcHJvakRibCgpIHtcbiAgLy8gaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXR3aXN0ZWQtcHJvamVjdGl2ZS5odG1sXG4gIC8vICAgICAjZG91YmxpbmctZGJsLTIwMDgtYmJqbHBcbiAgLy8gICAgICNkb3VibGluZy1kYmwtMjAwNy1ibFxuICAvLyBhbmQgb3RoZXJzXG4gIC8vIEdlbmVyYWxseSAzTSArIDRTIG9yIDJNICsgNFNcblxuICAvLyBCID0gKFgxICsgWTEpXjJcbiAgdmFyIGIgPSB0aGlzLngucmVkQWRkKHRoaXMueSkucmVkU3FyKCk7XG4gIC8vIEMgPSBYMV4yXG4gIHZhciBjID0gdGhpcy54LnJlZFNxcigpO1xuICAvLyBEID0gWTFeMlxuICB2YXIgZCA9IHRoaXMueS5yZWRTcXIoKTtcblxuICB2YXIgbng7XG4gIHZhciBueTtcbiAgdmFyIG56O1xuICBpZiAodGhpcy5jdXJ2ZS50d2lzdGVkKSB7XG4gICAgLy8gRSA9IGEgKiBDXG4gICAgdmFyIGUgPSB0aGlzLmN1cnZlLl9tdWxBKGMpO1xuICAgIC8vIEYgPSBFICsgRFxuICAgIHZhciBmID0gZS5yZWRBZGQoZCk7XG4gICAgaWYgKHRoaXMuek9uZSkge1xuICAgICAgLy8gWDMgPSAoQiAtIEMgLSBEKSAqIChGIC0gMilcbiAgICAgIG54ID0gYi5yZWRTdWIoYykucmVkU3ViKGQpLnJlZE11bChmLnJlZFN1Yih0aGlzLmN1cnZlLnR3bykpO1xuICAgICAgLy8gWTMgPSBGICogKEUgLSBEKVxuICAgICAgbnkgPSBmLnJlZE11bChlLnJlZFN1YihkKSk7XG4gICAgICAvLyBaMyA9IEZeMiAtIDIgKiBGXG4gICAgICBueiA9IGYucmVkU3FyKCkucmVkU3ViKGYpLnJlZFN1YihmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSCA9IFoxXjJcbiAgICAgIHZhciBoID0gdGhpcy56LnJlZFNxcigpO1xuICAgICAgLy8gSiA9IEYgLSAyICogSFxuICAgICAgdmFyIGogPSBmLnJlZFN1YihoKS5yZWRJU3ViKGgpO1xuICAgICAgLy8gWDMgPSAoQi1DLUQpKkpcbiAgICAgIG54ID0gYi5yZWRTdWIoYykucmVkSVN1YihkKS5yZWRNdWwoaik7XG4gICAgICAvLyBZMyA9IEYgKiAoRSAtIEQpXG4gICAgICBueSA9IGYucmVkTXVsKGUucmVkU3ViKGQpKTtcbiAgICAgIC8vIFozID0gRiAqIEpcbiAgICAgIG56ID0gZi5yZWRNdWwoaik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIEUgPSBDICsgRFxuICAgIHZhciBlID0gYy5yZWRBZGQoZCk7XG4gICAgLy8gSCA9IChjICogWjEpXjJcbiAgICB2YXIgaCA9IHRoaXMuY3VydmUuX211bEModGhpcy56KS5yZWRTcXIoKTtcbiAgICAvLyBKID0gRSAtIDIgKiBIXG4gICAgdmFyIGogPSBlLnJlZFN1YihoKS5yZWRTdWIoaCk7XG4gICAgLy8gWDMgPSBjICogKEIgLSBFKSAqIEpcbiAgICBueCA9IHRoaXMuY3VydmUuX211bEMoYi5yZWRJU3ViKGUpKS5yZWRNdWwoaik7XG4gICAgLy8gWTMgPSBjICogRSAqIChDIC0gRClcbiAgICBueSA9IHRoaXMuY3VydmUuX211bEMoZSkucmVkTXVsKGMucmVkSVN1YihkKSk7XG4gICAgLy8gWjMgPSBFICogSlxuICAgIG56ID0gZS5yZWRNdWwoaik7XG4gIH1cbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobngsIG55LCBueik7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZGJsID0gZnVuY3Rpb24gZGJsKCkge1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gRG91YmxlIGluIGV4dGVuZGVkIGNvb3JkaW5hdGVzXG4gIGlmICh0aGlzLmN1cnZlLmV4dGVuZGVkKVxuICAgIHJldHVybiB0aGlzLl9leHREYmwoKTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLl9wcm9qRGJsKCk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuX2V4dEFkZCA9IGZ1bmN0aW9uIF9leHRBZGQocCkge1xuICAvLyBoeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tdHdpc3RlZC1leHRlbmRlZC0xLmh0bWxcbiAgLy8gICAgICNhZGRpdGlvbi1hZGQtMjAwOC1od2NkLTNcbiAgLy8gOE1cblxuICAvLyBBID0gKFkxIC0gWDEpICogKFkyIC0gWDIpXG4gIHZhciBhID0gdGhpcy55LnJlZFN1Yih0aGlzLngpLnJlZE11bChwLnkucmVkU3ViKHAueCkpO1xuICAvLyBCID0gKFkxICsgWDEpICogKFkyICsgWDIpXG4gIHZhciBiID0gdGhpcy55LnJlZEFkZCh0aGlzLngpLnJlZE11bChwLnkucmVkQWRkKHAueCkpO1xuICAvLyBDID0gVDEgKiBrICogVDJcbiAgdmFyIGMgPSB0aGlzLnQucmVkTXVsKHRoaXMuY3VydmUuZGQpLnJlZE11bChwLnQpO1xuICAvLyBEID0gWjEgKiAyICogWjJcbiAgdmFyIGQgPSB0aGlzLnoucmVkTXVsKHAuei5yZWRBZGQocC56KSk7XG4gIC8vIEUgPSBCIC0gQVxuICB2YXIgZSA9IGIucmVkU3ViKGEpO1xuICAvLyBGID0gRCAtIENcbiAgdmFyIGYgPSBkLnJlZFN1YihjKTtcbiAgLy8gRyA9IEQgKyBDXG4gIHZhciBnID0gZC5yZWRBZGQoYyk7XG4gIC8vIEggPSBCICsgQVxuICB2YXIgaCA9IGIucmVkQWRkKGEpO1xuICAvLyBYMyA9IEUgKiBGXG4gIHZhciBueCA9IGUucmVkTXVsKGYpO1xuICAvLyBZMyA9IEcgKiBIXG4gIHZhciBueSA9IGcucmVkTXVsKGgpO1xuICAvLyBUMyA9IEUgKiBIXG4gIHZhciBudCA9IGUucmVkTXVsKGgpO1xuICAvLyBaMyA9IEYgKiBHXG4gIHZhciBueiA9IGYucmVkTXVsKGcpO1xuICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChueCwgbnksIG56LCBudCk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuX3Byb2pBZGQgPSBmdW5jdGlvbiBfcHJvakFkZChwKSB7XG4gIC8vIGh5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by10d2lzdGVkLXByb2plY3RpdmUuaHRtbFxuICAvLyAgICAgI2FkZGl0aW9uLWFkZC0yMDA4LWJiamxwXG4gIC8vICAgICAjYWRkaXRpb24tYWRkLTIwMDctYmxcbiAgLy8gMTBNICsgMVNcblxuICAvLyBBID0gWjEgKiBaMlxuICB2YXIgYSA9IHRoaXMuei5yZWRNdWwocC56KTtcbiAgLy8gQiA9IEFeMlxuICB2YXIgYiA9IGEucmVkU3FyKCk7XG4gIC8vIEMgPSBYMSAqIFgyXG4gIHZhciBjID0gdGhpcy54LnJlZE11bChwLngpO1xuICAvLyBEID0gWTEgKiBZMlxuICB2YXIgZCA9IHRoaXMueS5yZWRNdWwocC55KTtcbiAgLy8gRSA9IGQgKiBDICogRFxuICB2YXIgZSA9IHRoaXMuY3VydmUuZC5yZWRNdWwoYykucmVkTXVsKGQpO1xuICAvLyBGID0gQiAtIEVcbiAgdmFyIGYgPSBiLnJlZFN1YihlKTtcbiAgLy8gRyA9IEIgKyBFXG4gIHZhciBnID0gYi5yZWRBZGQoZSk7XG4gIC8vIFgzID0gQSAqIEYgKiAoKFgxICsgWTEpICogKFgyICsgWTIpIC0gQyAtIEQpXG4gIHZhciB0bXAgPSB0aGlzLngucmVkQWRkKHRoaXMueSkucmVkTXVsKHAueC5yZWRBZGQocC55KSkucmVkSVN1YihjKS5yZWRJU3ViKGQpO1xuICB2YXIgbnggPSBhLnJlZE11bChmKS5yZWRNdWwodG1wKTtcbiAgdmFyIG55O1xuICB2YXIgbno7XG4gIGlmICh0aGlzLmN1cnZlLnR3aXN0ZWQpIHtcbiAgICAvLyBZMyA9IEEgKiBHICogKEQgLSBhICogQylcbiAgICBueSA9IGEucmVkTXVsKGcpLnJlZE11bChkLnJlZFN1Yih0aGlzLmN1cnZlLl9tdWxBKGMpKSk7XG4gICAgLy8gWjMgPSBGICogR1xuICAgIG56ID0gZi5yZWRNdWwoZyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gWTMgPSBBICogRyAqIChEIC0gQylcbiAgICBueSA9IGEucmVkTXVsKGcpLnJlZE11bChkLnJlZFN1YihjKSk7XG4gICAgLy8gWjMgPSBjICogRiAqIEdcbiAgICBueiA9IHRoaXMuY3VydmUuX211bEMoZikucmVkTXVsKGcpO1xuICB9XG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG54LCBueSwgbnopO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChwKSB7XG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gcDtcbiAgaWYgKHAuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIGlmICh0aGlzLmN1cnZlLmV4dGVuZGVkKVxuICAgIHJldHVybiB0aGlzLl9leHRBZGQocCk7XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5fcHJvakFkZChwKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwoaykge1xuICBpZiAodGhpcy5faGFzRG91YmxlcyhrKSlcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fZml4ZWROYWZNdWwodGhpcywgayk7XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fd25hZk11bCh0aGlzLCBrKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5tdWxBZGQgPSBmdW5jdGlvbiBtdWxBZGQoazEsIHAsIGsyKSB7XG4gIHJldHVybiB0aGlzLmN1cnZlLl93bmFmTXVsQWRkKDEsIFsgdGhpcywgcCBdLCBbIGsxLCBrMiBdLCAyLCBmYWxzZSk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuam11bEFkZCA9IGZ1bmN0aW9uIGptdWxBZGQoazEsIHAsIGsyKSB7XG4gIHJldHVybiB0aGlzLmN1cnZlLl93bmFmTXVsQWRkKDEsIFsgdGhpcywgcCBdLCBbIGsxLCBrMiBdLCAyLCB0cnVlKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5ub3JtYWxpemUgPSBmdW5jdGlvbiBub3JtYWxpemUoKSB7XG4gIGlmICh0aGlzLnpPbmUpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gTm9ybWFsaXplIGNvb3JkaW5hdGVzXG4gIHZhciB6aSA9IHRoaXMuei5yZWRJbnZtKCk7XG4gIHRoaXMueCA9IHRoaXMueC5yZWRNdWwoemkpO1xuICB0aGlzLnkgPSB0aGlzLnkucmVkTXVsKHppKTtcbiAgaWYgKHRoaXMudClcbiAgICB0aGlzLnQgPSB0aGlzLnQucmVkTXVsKHppKTtcbiAgdGhpcy56ID0gdGhpcy5jdXJ2ZS5vbmU7XG4gIHRoaXMuek9uZSA9IHRydWU7XG4gIHJldHVybiB0aGlzO1xufTtcblxuUG9pbnQucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uIG5lZygpIHtcbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQodGhpcy54LnJlZE5lZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50ICYmIHRoaXMudC5yZWROZWcoKSk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZ2V0WCA9IGZ1bmN0aW9uIGdldFgoKSB7XG4gIHRoaXMubm9ybWFsaXplKCk7XG4gIHJldHVybiB0aGlzLnguZnJvbVJlZCgpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmdldFkgPSBmdW5jdGlvbiBnZXRZKCkge1xuICB0aGlzLm5vcm1hbGl6ZSgpO1xuICByZXR1cm4gdGhpcy55LmZyb21SZWQoKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxKG90aGVyKSB7XG4gIHJldHVybiB0aGlzID09PSBvdGhlciB8fFxuICAgICAgICAgdGhpcy5nZXRYKCkuY21wKG90aGVyLmdldFgoKSkgPT09IDAgJiZcbiAgICAgICAgIHRoaXMuZ2V0WSgpLmNtcChvdGhlci5nZXRZKCkpID09PSAwO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmVxWFRvUCA9IGZ1bmN0aW9uIGVxWFRvUCh4KSB7XG4gIHZhciByeCA9IHgudG9SZWQodGhpcy5jdXJ2ZS5yZWQpLnJlZE11bCh0aGlzLnopO1xuICBpZiAodGhpcy54LmNtcChyeCkgPT09IDApXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgdmFyIHhjID0geC5jbG9uZSgpO1xuICB2YXIgdCA9IHRoaXMuY3VydmUucmVkTi5yZWRNdWwodGhpcy56KTtcbiAgZm9yICg7Oykge1xuICAgIHhjLmlhZGQodGhpcy5jdXJ2ZS5uKTtcbiAgICBpZiAoeGMuY21wKHRoaXMuY3VydmUucCkgPj0gMClcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIHJ4LnJlZElBZGQodCk7XG4gICAgaWYgKHRoaXMueC5jbXAocngpID09PSAwKVxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbi8vIENvbXBhdGliaWxpdHkgd2l0aCBCYXNlQ3VydmVcblBvaW50LnByb3RvdHlwZS50b1AgPSBQb2ludC5wcm90b3R5cGUubm9ybWFsaXplO1xuUG9pbnQucHJvdG90eXBlLm1peGVkQWRkID0gUG9pbnQucHJvdG90eXBlLmFkZDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGN1cnZlID0gZXhwb3J0cztcblxuY3VydmUuYmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xuY3VydmUuc2hvcnQgPSByZXF1aXJlKCcuL3Nob3J0Jyk7XG5jdXJ2ZS5tb250ID0gcmVxdWlyZSgnLi9tb250Jyk7XG5jdXJ2ZS5lZHdhcmRzID0gcmVxdWlyZSgnLi9lZHdhcmRzJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xudmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gTW9udEN1cnZlKGNvbmYpIHtcbiAgQmFzZS5jYWxsKHRoaXMsICdtb250JywgY29uZik7XG5cbiAgdGhpcy5hID0gbmV3IEJOKGNvbmYuYSwgMTYpLnRvUmVkKHRoaXMucmVkKTtcbiAgdGhpcy5iID0gbmV3IEJOKGNvbmYuYiwgMTYpLnRvUmVkKHRoaXMucmVkKTtcbiAgdGhpcy5pNCA9IG5ldyBCTig0KS50b1JlZCh0aGlzLnJlZCkucmVkSW52bSgpO1xuICB0aGlzLnR3byA9IG5ldyBCTigyKS50b1JlZCh0aGlzLnJlZCk7XG4gIHRoaXMuYTI0ID0gdGhpcy5pNC5yZWRNdWwodGhpcy5hLnJlZEFkZCh0aGlzLnR3bykpO1xufVxuaW5oZXJpdHMoTW9udEN1cnZlLCBCYXNlKTtcbm1vZHVsZS5leHBvcnRzID0gTW9udEN1cnZlO1xuXG5Nb250Q3VydmUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gdmFsaWRhdGUocG9pbnQpIHtcbiAgdmFyIHggPSBwb2ludC5ub3JtYWxpemUoKS54O1xuICB2YXIgeDIgPSB4LnJlZFNxcigpO1xuICB2YXIgcmhzID0geDIucmVkTXVsKHgpLnJlZEFkZCh4Mi5yZWRNdWwodGhpcy5hKSkucmVkQWRkKHgpO1xuICB2YXIgeSA9IHJocy5yZWRTcXJ0KCk7XG5cbiAgcmV0dXJuIHkucmVkU3FyKCkuY21wKHJocykgPT09IDA7XG59O1xuXG5mdW5jdGlvbiBQb2ludChjdXJ2ZSwgeCwgeikge1xuICBCYXNlLkJhc2VQb2ludC5jYWxsKHRoaXMsIGN1cnZlLCAncHJvamVjdGl2ZScpO1xuICBpZiAoeCA9PT0gbnVsbCAmJiB6ID09PSBudWxsKSB7XG4gICAgdGhpcy54ID0gdGhpcy5jdXJ2ZS5vbmU7XG4gICAgdGhpcy56ID0gdGhpcy5jdXJ2ZS56ZXJvO1xuICB9IGVsc2Uge1xuICAgIHRoaXMueCA9IG5ldyBCTih4LCAxNik7XG4gICAgdGhpcy56ID0gbmV3IEJOKHosIDE2KTtcbiAgICBpZiAoIXRoaXMueC5yZWQpXG4gICAgICB0aGlzLnggPSB0aGlzLngudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICAgIGlmICghdGhpcy56LnJlZClcbiAgICAgIHRoaXMueiA9IHRoaXMuei50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG4gIH1cbn1cbmluaGVyaXRzKFBvaW50LCBCYXNlLkJhc2VQb2ludCk7XG5cbk1vbnRDdXJ2ZS5wcm90b3R5cGUuZGVjb2RlUG9pbnQgPSBmdW5jdGlvbiBkZWNvZGVQb2ludChieXRlcywgZW5jKSB7XG4gIHJldHVybiB0aGlzLnBvaW50KHV0aWxzLnRvQXJyYXkoYnl0ZXMsIGVuYyksIDEpO1xufTtcblxuTW9udEN1cnZlLnByb3RvdHlwZS5wb2ludCA9IGZ1bmN0aW9uIHBvaW50KHgsIHopIHtcbiAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLCB4LCB6KTtcbn07XG5cbk1vbnRDdXJ2ZS5wcm90b3R5cGUucG9pbnRGcm9tSlNPTiA9IGZ1bmN0aW9uIHBvaW50RnJvbUpTT04ob2JqKSB7XG4gIHJldHVybiBQb2ludC5mcm9tSlNPTih0aGlzLCBvYmopO1xufTtcblxuUG9pbnQucHJvdG90eXBlLnByZWNvbXB1dGUgPSBmdW5jdGlvbiBwcmVjb21wdXRlKCkge1xuICAvLyBOby1vcFxufTtcblxuUG9pbnQucHJvdG90eXBlLl9lbmNvZGUgPSBmdW5jdGlvbiBfZW5jb2RlKCkge1xuICByZXR1cm4gdGhpcy5nZXRYKCkudG9BcnJheSgnYmUnLCB0aGlzLmN1cnZlLnAuYnl0ZUxlbmd0aCgpKTtcbn07XG5cblBvaW50LmZyb21KU09OID0gZnVuY3Rpb24gZnJvbUpTT04oY3VydmUsIG9iaikge1xuICByZXR1cm4gbmV3IFBvaW50KGN1cnZlLCBvYmpbMF0sIG9ialsxXSB8fCBjdXJ2ZS5vbmUpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuICc8RUMgUG9pbnQgSW5maW5pdHk+JztcbiAgcmV0dXJuICc8RUMgUG9pbnQgeDogJyArIHRoaXMueC5mcm9tUmVkKCkudG9TdHJpbmcoMTYsIDIpICtcbiAgICAgICcgejogJyArIHRoaXMuei5mcm9tUmVkKCkudG9TdHJpbmcoMTYsIDIpICsgJz4nO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmlzSW5maW5pdHkgPSBmdW5jdGlvbiBpc0luZmluaXR5KCkge1xuICAvLyBYWFggVGhpcyBjb2RlIGFzc3VtZXMgdGhhdCB6ZXJvIGlzIGFsd2F5cyB6ZXJvIGluIHJlZFxuICByZXR1cm4gdGhpcy56LmNtcG4oMCkgPT09IDA7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZGJsID0gZnVuY3Rpb24gZGJsKCkge1xuICAvLyBodHRwOi8vaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLW1vbnRnb20teHouaHRtbCNkb3VibGluZy1kYmwtMTk4Ny1tLTNcbiAgLy8gMk0gKyAyUyArIDRBXG5cbiAgLy8gQSA9IFgxICsgWjFcbiAgdmFyIGEgPSB0aGlzLngucmVkQWRkKHRoaXMueik7XG4gIC8vIEFBID0gQV4yXG4gIHZhciBhYSA9IGEucmVkU3FyKCk7XG4gIC8vIEIgPSBYMSAtIFoxXG4gIHZhciBiID0gdGhpcy54LnJlZFN1Yih0aGlzLnopO1xuICAvLyBCQiA9IEJeMlxuICB2YXIgYmIgPSBiLnJlZFNxcigpO1xuICAvLyBDID0gQUEgLSBCQlxuICB2YXIgYyA9IGFhLnJlZFN1YihiYik7XG4gIC8vIFgzID0gQUEgKiBCQlxuICB2YXIgbnggPSBhYS5yZWRNdWwoYmIpO1xuICAvLyBaMyA9IEMgKiAoQkIgKyBBMjQgKiBDKVxuICB2YXIgbnogPSBjLnJlZE11bChiYi5yZWRBZGQodGhpcy5jdXJ2ZS5hMjQucmVkTXVsKGMpKSk7XG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG54LCBueik7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBzdXBwb3J0ZWQgb24gTW9udGdvbWVyeSBjdXJ2ZScpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmRpZmZBZGQgPSBmdW5jdGlvbiBkaWZmQWRkKHAsIGRpZmYpIHtcbiAgLy8gaHR0cDovL2h5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by1tb250Z29tLXh6Lmh0bWwjZGlmZmFkZC1kYWRkLTE5ODctbS0zXG4gIC8vIDRNICsgMlMgKyA2QVxuXG4gIC8vIEEgPSBYMiArIFoyXG4gIHZhciBhID0gdGhpcy54LnJlZEFkZCh0aGlzLnopO1xuICAvLyBCID0gWDIgLSBaMlxuICB2YXIgYiA9IHRoaXMueC5yZWRTdWIodGhpcy56KTtcbiAgLy8gQyA9IFgzICsgWjNcbiAgdmFyIGMgPSBwLngucmVkQWRkKHAueik7XG4gIC8vIEQgPSBYMyAtIFozXG4gIHZhciBkID0gcC54LnJlZFN1YihwLnopO1xuICAvLyBEQSA9IEQgKiBBXG4gIHZhciBkYSA9IGQucmVkTXVsKGEpO1xuICAvLyBDQiA9IEMgKiBCXG4gIHZhciBjYiA9IGMucmVkTXVsKGIpO1xuICAvLyBYNSA9IFoxICogKERBICsgQ0IpXjJcbiAgdmFyIG54ID0gZGlmZi56LnJlZE11bChkYS5yZWRBZGQoY2IpLnJlZFNxcigpKTtcbiAgLy8gWjUgPSBYMSAqIChEQSAtIENCKV4yXG4gIHZhciBueiA9IGRpZmYueC5yZWRNdWwoZGEucmVkSVN1YihjYikucmVkU3FyKCkpO1xuICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChueCwgbnopO1xufTtcblxuUG9pbnQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bChrKSB7XG4gIHZhciB0ID0gay5jbG9uZSgpO1xuICB2YXIgYSA9IHRoaXM7IC8vIChOIC8gMikgKiBRICsgUVxuICB2YXIgYiA9IHRoaXMuY3VydmUucG9pbnQobnVsbCwgbnVsbCk7IC8vIChOIC8gMikgKiBRXG4gIHZhciBjID0gdGhpczsgLy8gUVxuXG4gIGZvciAodmFyIGJpdHMgPSBbXTsgdC5jbXBuKDApICE9PSAwOyB0Lml1c2hybigxKSlcbiAgICBiaXRzLnB1c2godC5hbmRsbigxKSk7XG5cbiAgZm9yICh2YXIgaSA9IGJpdHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoYml0c1tpXSA9PT0gMCkge1xuICAgICAgLy8gTiAqIFEgKyBRID0gKChOIC8gMikgKiBRICsgUSkpICsgKE4gLyAyKSAqIFFcbiAgICAgIGEgPSBhLmRpZmZBZGQoYiwgYyk7XG4gICAgICAvLyBOICogUSA9IDIgKiAoKE4gLyAyKSAqIFEgKyBRKSlcbiAgICAgIGIgPSBiLmRibCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBOICogUSA9ICgoTiAvIDIpICogUSArIFEpICsgKChOIC8gMikgKiBRKVxuICAgICAgYiA9IGEuZGlmZkFkZChiLCBjKTtcbiAgICAgIC8vIE4gKiBRICsgUSA9IDIgKiAoKE4gLyAyKSAqIFEgKyBRKVxuICAgICAgYSA9IGEuZGJsKCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBiO1xufTtcblxuUG9pbnQucHJvdG90eXBlLm11bEFkZCA9IGZ1bmN0aW9uIG11bEFkZCgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdOb3Qgc3VwcG9ydGVkIG9uIE1vbnRnb21lcnkgY3VydmUnKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5qdW1sQWRkID0gZnVuY3Rpb24ganVtbEFkZCgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdOb3Qgc3VwcG9ydGVkIG9uIE1vbnRnb21lcnkgY3VydmUnKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxKG90aGVyKSB7XG4gIHJldHVybiB0aGlzLmdldFgoKS5jbXAob3RoZXIuZ2V0WCgpKSA9PT0gMDtcbn07XG5cblBvaW50LnByb3RvdHlwZS5ub3JtYWxpemUgPSBmdW5jdGlvbiBub3JtYWxpemUoKSB7XG4gIHRoaXMueCA9IHRoaXMueC5yZWRNdWwodGhpcy56LnJlZEludm0oKSk7XG4gIHRoaXMueiA9IHRoaXMuY3VydmUub25lO1xuICByZXR1cm4gdGhpcztcbn07XG5cblBvaW50LnByb3RvdHlwZS5nZXRYID0gZnVuY3Rpb24gZ2V0WCgpIHtcbiAgLy8gTm9ybWFsaXplIGNvb3JkaW5hdGVzXG4gIHRoaXMubm9ybWFsaXplKCk7XG5cbiAgcmV0dXJuIHRoaXMueC5mcm9tUmVkKCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG52YXIgQmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xuXG52YXIgYXNzZXJ0ID0gdXRpbHMuYXNzZXJ0O1xuXG5mdW5jdGlvbiBTaG9ydEN1cnZlKGNvbmYpIHtcbiAgQmFzZS5jYWxsKHRoaXMsICdzaG9ydCcsIGNvbmYpO1xuXG4gIHRoaXMuYSA9IG5ldyBCTihjb25mLmEsIDE2KS50b1JlZCh0aGlzLnJlZCk7XG4gIHRoaXMuYiA9IG5ldyBCTihjb25mLmIsIDE2KS50b1JlZCh0aGlzLnJlZCk7XG4gIHRoaXMudGludiA9IHRoaXMudHdvLnJlZEludm0oKTtcblxuICB0aGlzLnplcm9BID0gdGhpcy5hLmZyb21SZWQoKS5jbXBuKDApID09PSAwO1xuICB0aGlzLnRocmVlQSA9IHRoaXMuYS5mcm9tUmVkKCkuc3ViKHRoaXMucCkuY21wbigtMykgPT09IDA7XG5cbiAgLy8gSWYgdGhlIGN1cnZlIGlzIGVuZG9tb3JwaGljLCBwcmVjYWxjdWxhdGUgYmV0YSBhbmQgbGFtYmRhXG4gIHRoaXMuZW5kbyA9IHRoaXMuX2dldEVuZG9tb3JwaGlzbShjb25mKTtcbiAgdGhpcy5fZW5kb1duYWZUMSA9IG5ldyBBcnJheSg0KTtcbiAgdGhpcy5fZW5kb1duYWZUMiA9IG5ldyBBcnJheSg0KTtcbn1cbmluaGVyaXRzKFNob3J0Q3VydmUsIEJhc2UpO1xubW9kdWxlLmV4cG9ydHMgPSBTaG9ydEN1cnZlO1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS5fZ2V0RW5kb21vcnBoaXNtID0gZnVuY3Rpb24gX2dldEVuZG9tb3JwaGlzbShjb25mKSB7XG4gIC8vIE5vIGVmZmljaWVudCBlbmRvbW9ycGhpc21cbiAgaWYgKCF0aGlzLnplcm9BIHx8ICF0aGlzLmcgfHwgIXRoaXMubiB8fCB0aGlzLnAubW9kbigzKSAhPT0gMSlcbiAgICByZXR1cm47XG5cbiAgLy8gQ29tcHV0ZSBiZXRhIGFuZCBsYW1iZGEsIHRoYXQgbGFtYmRhICogUCA9IChiZXRhICogUHg7IFB5KVxuICB2YXIgYmV0YTtcbiAgdmFyIGxhbWJkYTtcbiAgaWYgKGNvbmYuYmV0YSkge1xuICAgIGJldGEgPSBuZXcgQk4oY29uZi5iZXRhLCAxNikudG9SZWQodGhpcy5yZWQpO1xuICB9IGVsc2Uge1xuICAgIHZhciBiZXRhcyA9IHRoaXMuX2dldEVuZG9Sb290cyh0aGlzLnApO1xuICAgIC8vIENob29zZSB0aGUgc21hbGxlc3QgYmV0YVxuICAgIGJldGEgPSBiZXRhc1swXS5jbXAoYmV0YXNbMV0pIDwgMCA/IGJldGFzWzBdIDogYmV0YXNbMV07XG4gICAgYmV0YSA9IGJldGEudG9SZWQodGhpcy5yZWQpO1xuICB9XG4gIGlmIChjb25mLmxhbWJkYSkge1xuICAgIGxhbWJkYSA9IG5ldyBCTihjb25mLmxhbWJkYSwgMTYpO1xuICB9IGVsc2Uge1xuICAgIC8vIENob29zZSB0aGUgbGFtYmRhIHRoYXQgaXMgbWF0Y2hpbmcgc2VsZWN0ZWQgYmV0YVxuICAgIHZhciBsYW1iZGFzID0gdGhpcy5fZ2V0RW5kb1Jvb3RzKHRoaXMubik7XG4gICAgaWYgKHRoaXMuZy5tdWwobGFtYmRhc1swXSkueC5jbXAodGhpcy5nLngucmVkTXVsKGJldGEpKSA9PT0gMCkge1xuICAgICAgbGFtYmRhID0gbGFtYmRhc1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGFtYmRhID0gbGFtYmRhc1sxXTtcbiAgICAgIGFzc2VydCh0aGlzLmcubXVsKGxhbWJkYSkueC5jbXAodGhpcy5nLngucmVkTXVsKGJldGEpKSA9PT0gMCk7XG4gICAgfVxuICB9XG5cbiAgLy8gR2V0IGJhc2lzIHZlY3RvcnMsIHVzZWQgZm9yIGJhbGFuY2VkIGxlbmd0aC10d28gcmVwcmVzZW50YXRpb25cbiAgdmFyIGJhc2lzO1xuICBpZiAoY29uZi5iYXNpcykge1xuICAgIGJhc2lzID0gY29uZi5iYXNpcy5tYXAoZnVuY3Rpb24odmVjKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhOiBuZXcgQk4odmVjLmEsIDE2KSxcbiAgICAgICAgYjogbmV3IEJOKHZlYy5iLCAxNilcbiAgICAgIH07XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgYmFzaXMgPSB0aGlzLl9nZXRFbmRvQmFzaXMobGFtYmRhKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYmV0YTogYmV0YSxcbiAgICBsYW1iZGE6IGxhbWJkYSxcbiAgICBiYXNpczogYmFzaXNcbiAgfTtcbn07XG5cblNob3J0Q3VydmUucHJvdG90eXBlLl9nZXRFbmRvUm9vdHMgPSBmdW5jdGlvbiBfZ2V0RW5kb1Jvb3RzKG51bSkge1xuICAvLyBGaW5kIHJvb3RzIG9mIGZvciB4XjIgKyB4ICsgMSBpbiBGXG4gIC8vIFJvb3QgPSAoLTEgKy0gU3FydCgtMykpIC8gMlxuICAvL1xuICB2YXIgcmVkID0gbnVtID09PSB0aGlzLnAgPyB0aGlzLnJlZCA6IEJOLm1vbnQobnVtKTtcbiAgdmFyIHRpbnYgPSBuZXcgQk4oMikudG9SZWQocmVkKS5yZWRJbnZtKCk7XG4gIHZhciBudGludiA9IHRpbnYucmVkTmVnKCk7XG5cbiAgdmFyIHMgPSBuZXcgQk4oMykudG9SZWQocmVkKS5yZWROZWcoKS5yZWRTcXJ0KCkucmVkTXVsKHRpbnYpO1xuXG4gIHZhciBsMSA9IG50aW52LnJlZEFkZChzKS5mcm9tUmVkKCk7XG4gIHZhciBsMiA9IG50aW52LnJlZFN1YihzKS5mcm9tUmVkKCk7XG4gIHJldHVybiBbIGwxLCBsMiBdO1xufTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUuX2dldEVuZG9CYXNpcyA9IGZ1bmN0aW9uIF9nZXRFbmRvQmFzaXMobGFtYmRhKSB7XG4gIC8vIGFwcnhTcXJ0ID49IHNxcnQodGhpcy5uKVxuICB2YXIgYXByeFNxcnQgPSB0aGlzLm4udXNocm4oTWF0aC5mbG9vcih0aGlzLm4uYml0TGVuZ3RoKCkgLyAyKSk7XG5cbiAgLy8gMy43NFxuICAvLyBSdW4gRUdDRCwgdW50aWwgcihMICsgMSkgPCBhcHJ4U3FydFxuICB2YXIgdSA9IGxhbWJkYTtcbiAgdmFyIHYgPSB0aGlzLm4uY2xvbmUoKTtcbiAgdmFyIHgxID0gbmV3IEJOKDEpO1xuICB2YXIgeTEgPSBuZXcgQk4oMCk7XG4gIHZhciB4MiA9IG5ldyBCTigwKTtcbiAgdmFyIHkyID0gbmV3IEJOKDEpO1xuXG4gIC8vIE5PVEU6IGFsbCB2ZWN0b3JzIGFyZSByb290cyBvZjogYSArIGIgKiBsYW1iZGEgPSAwIChtb2QgbilcbiAgdmFyIGEwO1xuICB2YXIgYjA7XG4gIC8vIEZpcnN0IHZlY3RvclxuICB2YXIgYTE7XG4gIHZhciBiMTtcbiAgLy8gU2Vjb25kIHZlY3RvclxuICB2YXIgYTI7XG4gIHZhciBiMjtcblxuICB2YXIgcHJldlI7XG4gIHZhciBpID0gMDtcbiAgdmFyIHI7XG4gIHZhciB4O1xuICB3aGlsZSAodS5jbXBuKDApICE9PSAwKSB7XG4gICAgdmFyIHEgPSB2LmRpdih1KTtcbiAgICByID0gdi5zdWIocS5tdWwodSkpO1xuICAgIHggPSB4Mi5zdWIocS5tdWwoeDEpKTtcbiAgICB2YXIgeSA9IHkyLnN1YihxLm11bCh5MSkpO1xuXG4gICAgaWYgKCFhMSAmJiByLmNtcChhcHJ4U3FydCkgPCAwKSB7XG4gICAgICBhMCA9IHByZXZSLm5lZygpO1xuICAgICAgYjAgPSB4MTtcbiAgICAgIGExID0gci5uZWcoKTtcbiAgICAgIGIxID0geDtcbiAgICB9IGVsc2UgaWYgKGExICYmICsraSA9PT0gMikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHByZXZSID0gcjtcblxuICAgIHYgPSB1O1xuICAgIHUgPSByO1xuICAgIHgyID0geDE7XG4gICAgeDEgPSB4O1xuICAgIHkyID0geTE7XG4gICAgeTEgPSB5O1xuICB9XG4gIGEyID0gci5uZWcoKTtcbiAgYjIgPSB4O1xuXG4gIHZhciBsZW4xID0gYTEuc3FyKCkuYWRkKGIxLnNxcigpKTtcbiAgdmFyIGxlbjIgPSBhMi5zcXIoKS5hZGQoYjIuc3FyKCkpO1xuICBpZiAobGVuMi5jbXAobGVuMSkgPj0gMCkge1xuICAgIGEyID0gYTA7XG4gICAgYjIgPSBiMDtcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBzaWduc1xuICBpZiAoYTEubmVnYXRpdmUpIHtcbiAgICBhMSA9IGExLm5lZygpO1xuICAgIGIxID0gYjEubmVnKCk7XG4gIH1cbiAgaWYgKGEyLm5lZ2F0aXZlKSB7XG4gICAgYTIgPSBhMi5uZWcoKTtcbiAgICBiMiA9IGIyLm5lZygpO1xuICB9XG5cbiAgcmV0dXJuIFtcbiAgICB7IGE6IGExLCBiOiBiMSB9LFxuICAgIHsgYTogYTIsIGI6IGIyIH1cbiAgXTtcbn07XG5cblNob3J0Q3VydmUucHJvdG90eXBlLl9lbmRvU3BsaXQgPSBmdW5jdGlvbiBfZW5kb1NwbGl0KGspIHtcbiAgdmFyIGJhc2lzID0gdGhpcy5lbmRvLmJhc2lzO1xuICB2YXIgdjEgPSBiYXNpc1swXTtcbiAgdmFyIHYyID0gYmFzaXNbMV07XG5cbiAgdmFyIGMxID0gdjIuYi5tdWwoaykuZGl2Um91bmQodGhpcy5uKTtcbiAgdmFyIGMyID0gdjEuYi5uZWcoKS5tdWwoaykuZGl2Um91bmQodGhpcy5uKTtcblxuICB2YXIgcDEgPSBjMS5tdWwodjEuYSk7XG4gIHZhciBwMiA9IGMyLm11bCh2Mi5hKTtcbiAgdmFyIHExID0gYzEubXVsKHYxLmIpO1xuICB2YXIgcTIgPSBjMi5tdWwodjIuYik7XG5cbiAgLy8gQ2FsY3VsYXRlIGFuc3dlclxuICB2YXIgazEgPSBrLnN1YihwMSkuc3ViKHAyKTtcbiAgdmFyIGsyID0gcTEuYWRkKHEyKS5uZWcoKTtcbiAgcmV0dXJuIHsgazE6IGsxLCBrMjogazIgfTtcbn07XG5cblNob3J0Q3VydmUucHJvdG90eXBlLnBvaW50RnJvbVggPSBmdW5jdGlvbiBwb2ludEZyb21YKHgsIG9kZCkge1xuICB4ID0gbmV3IEJOKHgsIDE2KTtcbiAgaWYgKCF4LnJlZClcbiAgICB4ID0geC50b1JlZCh0aGlzLnJlZCk7XG5cbiAgdmFyIHkyID0geC5yZWRTcXIoKS5yZWRNdWwoeCkucmVkSUFkZCh4LnJlZE11bCh0aGlzLmEpKS5yZWRJQWRkKHRoaXMuYik7XG4gIHZhciB5ID0geTIucmVkU3FydCgpO1xuICBpZiAoeS5yZWRTcXIoKS5yZWRTdWIoeTIpLmNtcCh0aGlzLnplcm8pICE9PSAwKVxuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwb2ludCcpO1xuXG4gIC8vIFhYWCBJcyB0aGVyZSBhbnkgd2F5IHRvIHRlbGwgaWYgdGhlIG51bWJlciBpcyBvZGQgd2l0aG91dCBjb252ZXJ0aW5nIGl0XG4gIC8vIHRvIG5vbi1yZWQgZm9ybT9cbiAgdmFyIGlzT2RkID0geS5mcm9tUmVkKCkuaXNPZGQoKTtcbiAgaWYgKG9kZCAmJiAhaXNPZGQgfHwgIW9kZCAmJiBpc09kZClcbiAgICB5ID0geS5yZWROZWcoKTtcblxuICByZXR1cm4gdGhpcy5wb2ludCh4LCB5KTtcbn07XG5cblNob3J0Q3VydmUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gdmFsaWRhdGUocG9pbnQpIHtcbiAgaWYgKHBvaW50LmluZilcbiAgICByZXR1cm4gdHJ1ZTtcblxuICB2YXIgeCA9IHBvaW50Lng7XG4gIHZhciB5ID0gcG9pbnQueTtcblxuICB2YXIgYXggPSB0aGlzLmEucmVkTXVsKHgpO1xuICB2YXIgcmhzID0geC5yZWRTcXIoKS5yZWRNdWwoeCkucmVkSUFkZChheCkucmVkSUFkZCh0aGlzLmIpO1xuICByZXR1cm4geS5yZWRTcXIoKS5yZWRJU3ViKHJocykuY21wbigwKSA9PT0gMDtcbn07XG5cblNob3J0Q3VydmUucHJvdG90eXBlLl9lbmRvV25hZk11bEFkZCA9XG4gICAgZnVuY3Rpb24gX2VuZG9XbmFmTXVsQWRkKHBvaW50cywgY29lZmZzLCBqYWNvYmlhblJlc3VsdCkge1xuICB2YXIgbnBvaW50cyA9IHRoaXMuX2VuZG9XbmFmVDE7XG4gIHZhciBuY29lZmZzID0gdGhpcy5fZW5kb1duYWZUMjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc3BsaXQgPSB0aGlzLl9lbmRvU3BsaXQoY29lZmZzW2ldKTtcbiAgICB2YXIgcCA9IHBvaW50c1tpXTtcbiAgICB2YXIgYmV0YSA9IHAuX2dldEJldGEoKTtcblxuICAgIGlmIChzcGxpdC5rMS5uZWdhdGl2ZSkge1xuICAgICAgc3BsaXQuazEuaW5lZygpO1xuICAgICAgcCA9IHAubmVnKHRydWUpO1xuICAgIH1cbiAgICBpZiAoc3BsaXQuazIubmVnYXRpdmUpIHtcbiAgICAgIHNwbGl0LmsyLmluZWcoKTtcbiAgICAgIGJldGEgPSBiZXRhLm5lZyh0cnVlKTtcbiAgICB9XG5cbiAgICBucG9pbnRzW2kgKiAyXSA9IHA7XG4gICAgbnBvaW50c1tpICogMiArIDFdID0gYmV0YTtcbiAgICBuY29lZmZzW2kgKiAyXSA9IHNwbGl0LmsxO1xuICAgIG5jb2VmZnNbaSAqIDIgKyAxXSA9IHNwbGl0LmsyO1xuICB9XG4gIHZhciByZXMgPSB0aGlzLl93bmFmTXVsQWRkKDEsIG5wb2ludHMsIG5jb2VmZnMsIGkgKiAyLCBqYWNvYmlhblJlc3VsdCk7XG5cbiAgLy8gQ2xlYW4tdXAgcmVmZXJlbmNlcyB0byBwb2ludHMgYW5kIGNvZWZmaWNpZW50c1xuICBmb3IgKHZhciBqID0gMDsgaiA8IGkgKiAyOyBqKyspIHtcbiAgICBucG9pbnRzW2pdID0gbnVsbDtcbiAgICBuY29lZmZzW2pdID0gbnVsbDtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcblxuZnVuY3Rpb24gUG9pbnQoY3VydmUsIHgsIHksIGlzUmVkKSB7XG4gIEJhc2UuQmFzZVBvaW50LmNhbGwodGhpcywgY3VydmUsICdhZmZpbmUnKTtcbiAgaWYgKHggPT09IG51bGwgJiYgeSA9PT0gbnVsbCkge1xuICAgIHRoaXMueCA9IG51bGw7XG4gICAgdGhpcy55ID0gbnVsbDtcbiAgICB0aGlzLmluZiA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy54ID0gbmV3IEJOKHgsIDE2KTtcbiAgICB0aGlzLnkgPSBuZXcgQk4oeSwgMTYpO1xuICAgIC8vIEZvcmNlIHJlZGdvbWVyeSByZXByZXNlbnRhdGlvbiB3aGVuIGxvYWRpbmcgZnJvbSBKU09OXG4gICAgaWYgKGlzUmVkKSB7XG4gICAgICB0aGlzLnguZm9yY2VSZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICAgICAgdGhpcy55LmZvcmNlUmVkKHRoaXMuY3VydmUucmVkKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLngucmVkKVxuICAgICAgdGhpcy54ID0gdGhpcy54LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcbiAgICBpZiAoIXRoaXMueS5yZWQpXG4gICAgICB0aGlzLnkgPSB0aGlzLnkudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICAgIHRoaXMuaW5mID0gZmFsc2U7XG4gIH1cbn1cbmluaGVyaXRzKFBvaW50LCBCYXNlLkJhc2VQb2ludCk7XG5cblNob3J0Q3VydmUucHJvdG90eXBlLnBvaW50ID0gZnVuY3Rpb24gcG9pbnQoeCwgeSwgaXNSZWQpIHtcbiAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLCB4LCB5LCBpc1JlZCk7XG59O1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS5wb2ludEZyb21KU09OID0gZnVuY3Rpb24gcG9pbnRGcm9tSlNPTihvYmosIHJlZCkge1xuICByZXR1cm4gUG9pbnQuZnJvbUpTT04odGhpcywgb2JqLCByZWQpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLl9nZXRCZXRhID0gZnVuY3Rpb24gX2dldEJldGEoKSB7XG4gIGlmICghdGhpcy5jdXJ2ZS5lbmRvKVxuICAgIHJldHVybjtcblxuICB2YXIgcHJlID0gdGhpcy5wcmVjb21wdXRlZDtcbiAgaWYgKHByZSAmJiBwcmUuYmV0YSlcbiAgICByZXR1cm4gcHJlLmJldGE7XG5cbiAgdmFyIGJldGEgPSB0aGlzLmN1cnZlLnBvaW50KHRoaXMueC5yZWRNdWwodGhpcy5jdXJ2ZS5lbmRvLmJldGEpLCB0aGlzLnkpO1xuICBpZiAocHJlKSB7XG4gICAgdmFyIGN1cnZlID0gdGhpcy5jdXJ2ZTtcbiAgICB2YXIgZW5kb011bCA9IGZ1bmN0aW9uKHApIHtcbiAgICAgIHJldHVybiBjdXJ2ZS5wb2ludChwLngucmVkTXVsKGN1cnZlLmVuZG8uYmV0YSksIHAueSk7XG4gICAgfTtcbiAgICBwcmUuYmV0YSA9IGJldGE7XG4gICAgYmV0YS5wcmVjb21wdXRlZCA9IHtcbiAgICAgIGJldGE6IG51bGwsXG4gICAgICBuYWY6IHByZS5uYWYgJiYge1xuICAgICAgICB3bmQ6IHByZS5uYWYud25kLFxuICAgICAgICBwb2ludHM6IHByZS5uYWYucG9pbnRzLm1hcChlbmRvTXVsKVxuICAgICAgfSxcbiAgICAgIGRvdWJsZXM6IHByZS5kb3VibGVzICYmIHtcbiAgICAgICAgc3RlcDogcHJlLmRvdWJsZXMuc3RlcCxcbiAgICAgICAgcG9pbnRzOiBwcmUuZG91Ymxlcy5wb2ludHMubWFwKGVuZG9NdWwpXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICByZXR1cm4gYmV0YTtcbn07XG5cblBvaW50LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gIGlmICghdGhpcy5wcmVjb21wdXRlZClcbiAgICByZXR1cm4gWyB0aGlzLngsIHRoaXMueSBdO1xuXG4gIHJldHVybiBbIHRoaXMueCwgdGhpcy55LCB0aGlzLnByZWNvbXB1dGVkICYmIHtcbiAgICBkb3VibGVzOiB0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXMgJiYge1xuICAgICAgc3RlcDogdGhpcy5wcmVjb21wdXRlZC5kb3VibGVzLnN0ZXAsXG4gICAgICBwb2ludHM6IHRoaXMucHJlY29tcHV0ZWQuZG91Ymxlcy5wb2ludHMuc2xpY2UoMSlcbiAgICB9LFxuICAgIG5hZjogdGhpcy5wcmVjb21wdXRlZC5uYWYgJiYge1xuICAgICAgd25kOiB0aGlzLnByZWNvbXB1dGVkLm5hZi53bmQsXG4gICAgICBwb2ludHM6IHRoaXMucHJlY29tcHV0ZWQubmFmLnBvaW50cy5zbGljZSgxKVxuICAgIH1cbiAgfSBdO1xufTtcblxuUG9pbnQuZnJvbUpTT04gPSBmdW5jdGlvbiBmcm9tSlNPTihjdXJ2ZSwgb2JqLCByZWQpIHtcbiAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKVxuICAgIG9iaiA9IEpTT04ucGFyc2Uob2JqKTtcbiAgdmFyIHJlcyA9IGN1cnZlLnBvaW50KG9ialswXSwgb2JqWzFdLCByZWQpO1xuICBpZiAoIW9ialsyXSlcbiAgICByZXR1cm4gcmVzO1xuXG4gIGZ1bmN0aW9uIG9iajJwb2ludChvYmopIHtcbiAgICByZXR1cm4gY3VydmUucG9pbnQob2JqWzBdLCBvYmpbMV0sIHJlZCk7XG4gIH1cblxuICB2YXIgcHJlID0gb2JqWzJdO1xuICByZXMucHJlY29tcHV0ZWQgPSB7XG4gICAgYmV0YTogbnVsbCxcbiAgICBkb3VibGVzOiBwcmUuZG91YmxlcyAmJiB7XG4gICAgICBzdGVwOiBwcmUuZG91Ymxlcy5zdGVwLFxuICAgICAgcG9pbnRzOiBbIHJlcyBdLmNvbmNhdChwcmUuZG91Ymxlcy5wb2ludHMubWFwKG9iajJwb2ludCkpXG4gICAgfSxcbiAgICBuYWY6IHByZS5uYWYgJiYge1xuICAgICAgd25kOiBwcmUubmFmLnduZCxcbiAgICAgIHBvaW50czogWyByZXMgXS5jb25jYXQocHJlLm5hZi5wb2ludHMubWFwKG9iajJwb2ludCkpXG4gICAgfVxuICB9O1xuICByZXR1cm4gcmVzO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuICc8RUMgUG9pbnQgSW5maW5pdHk+JztcbiAgcmV0dXJuICc8RUMgUG9pbnQgeDogJyArIHRoaXMueC5mcm9tUmVkKCkudG9TdHJpbmcoMTYsIDIpICtcbiAgICAgICcgeTogJyArIHRoaXMueS5mcm9tUmVkKCkudG9TdHJpbmcoMTYsIDIpICsgJz4nO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmlzSW5maW5pdHkgPSBmdW5jdGlvbiBpc0luZmluaXR5KCkge1xuICByZXR1cm4gdGhpcy5pbmY7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKHApIHtcbiAgLy8gTyArIFAgPSBQXG4gIGlmICh0aGlzLmluZilcbiAgICByZXR1cm4gcDtcblxuICAvLyBQICsgTyA9IFBcbiAgaWYgKHAuaW5mKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIFAgKyBQID0gMlBcbiAgaWYgKHRoaXMuZXEocCkpXG4gICAgcmV0dXJuIHRoaXMuZGJsKCk7XG5cbiAgLy8gUCArICgtUCkgPSBPXG4gIGlmICh0aGlzLm5lZygpLmVxKHApKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG51bGwsIG51bGwpO1xuXG4gIC8vIFAgKyBRID0gT1xuICBpZiAodGhpcy54LmNtcChwLngpID09PSAwKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG51bGwsIG51bGwpO1xuXG4gIHZhciBjID0gdGhpcy55LnJlZFN1YihwLnkpO1xuICBpZiAoYy5jbXBuKDApICE9PSAwKVxuICAgIGMgPSBjLnJlZE11bCh0aGlzLngucmVkU3ViKHAueCkucmVkSW52bSgpKTtcbiAgdmFyIG54ID0gYy5yZWRTcXIoKS5yZWRJU3ViKHRoaXMueCkucmVkSVN1YihwLngpO1xuICB2YXIgbnkgPSBjLnJlZE11bCh0aGlzLngucmVkU3ViKG54KSkucmVkSVN1Yih0aGlzLnkpO1xuICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChueCwgbnkpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmRibCA9IGZ1bmN0aW9uIGRibCgpIHtcbiAgaWYgKHRoaXMuaW5mKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIDJQID0gT1xuICB2YXIgeXMxID0gdGhpcy55LnJlZEFkZCh0aGlzLnkpO1xuICBpZiAoeXMxLmNtcG4oMCkgPT09IDApXG4gICAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobnVsbCwgbnVsbCk7XG5cbiAgdmFyIGEgPSB0aGlzLmN1cnZlLmE7XG5cbiAgdmFyIHgyID0gdGhpcy54LnJlZFNxcigpO1xuICB2YXIgZHlpbnYgPSB5czEucmVkSW52bSgpO1xuICB2YXIgYyA9IHgyLnJlZEFkZCh4MikucmVkSUFkZCh4MikucmVkSUFkZChhKS5yZWRNdWwoZHlpbnYpO1xuXG4gIHZhciBueCA9IGMucmVkU3FyKCkucmVkSVN1Yih0aGlzLngucmVkQWRkKHRoaXMueCkpO1xuICB2YXIgbnkgPSBjLnJlZE11bCh0aGlzLngucmVkU3ViKG54KSkucmVkSVN1Yih0aGlzLnkpO1xuICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChueCwgbnkpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmdldFggPSBmdW5jdGlvbiBnZXRYKCkge1xuICByZXR1cm4gdGhpcy54LmZyb21SZWQoKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5nZXRZID0gZnVuY3Rpb24gZ2V0WSgpIHtcbiAgcmV0dXJuIHRoaXMueS5mcm9tUmVkKCk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsKGspIHtcbiAgayA9IG5ldyBCTihrLCAxNik7XG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gdGhpcztcbiAgZWxzZSBpZiAodGhpcy5faGFzRG91YmxlcyhrKSlcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fZml4ZWROYWZNdWwodGhpcywgayk7XG4gIGVsc2UgaWYgKHRoaXMuY3VydmUuZW5kbylcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fZW5kb1duYWZNdWxBZGQoWyB0aGlzIF0sIFsgayBdKTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLmN1cnZlLl93bmFmTXVsKHRoaXMsIGspO1xufTtcblxuUG9pbnQucHJvdG90eXBlLm11bEFkZCA9IGZ1bmN0aW9uIG11bEFkZChrMSwgcDIsIGsyKSB7XG4gIHZhciBwb2ludHMgPSBbIHRoaXMsIHAyIF07XG4gIHZhciBjb2VmZnMgPSBbIGsxLCBrMiBdO1xuICBpZiAodGhpcy5jdXJ2ZS5lbmRvKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLl9lbmRvV25hZk11bEFkZChwb2ludHMsIGNvZWZmcyk7XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fd25hZk11bEFkZCgxLCBwb2ludHMsIGNvZWZmcywgMik7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuam11bEFkZCA9IGZ1bmN0aW9uIGptdWxBZGQoazEsIHAyLCBrMikge1xuICB2YXIgcG9pbnRzID0gWyB0aGlzLCBwMiBdO1xuICB2YXIgY29lZmZzID0gWyBrMSwgazIgXTtcbiAgaWYgKHRoaXMuY3VydmUuZW5kbylcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fZW5kb1duYWZNdWxBZGQocG9pbnRzLCBjb2VmZnMsIHRydWUpO1xuICBlbHNlXG4gICAgcmV0dXJuIHRoaXMuY3VydmUuX3duYWZNdWxBZGQoMSwgcG9pbnRzLCBjb2VmZnMsIDIsIHRydWUpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gZXEocCkge1xuICByZXR1cm4gdGhpcyA9PT0gcCB8fFxuICAgICAgICAgdGhpcy5pbmYgPT09IHAuaW5mICYmXG4gICAgICAgICAgICAgKHRoaXMuaW5mIHx8IHRoaXMueC5jbXAocC54KSA9PT0gMCAmJiB0aGlzLnkuY21wKHAueSkgPT09IDApO1xufTtcblxuUG9pbnQucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uIG5lZyhfcHJlY29tcHV0ZSkge1xuICBpZiAodGhpcy5pbmYpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgdmFyIHJlcyA9IHRoaXMuY3VydmUucG9pbnQodGhpcy54LCB0aGlzLnkucmVkTmVnKCkpO1xuICBpZiAoX3ByZWNvbXB1dGUgJiYgdGhpcy5wcmVjb21wdXRlZCkge1xuICAgIHZhciBwcmUgPSB0aGlzLnByZWNvbXB1dGVkO1xuICAgIHZhciBuZWdhdGUgPSBmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4gcC5uZWcoKTtcbiAgICB9O1xuICAgIHJlcy5wcmVjb21wdXRlZCA9IHtcbiAgICAgIG5hZjogcHJlLm5hZiAmJiB7XG4gICAgICAgIHduZDogcHJlLm5hZi53bmQsXG4gICAgICAgIHBvaW50czogcHJlLm5hZi5wb2ludHMubWFwKG5lZ2F0ZSlcbiAgICAgIH0sXG4gICAgICBkb3VibGVzOiBwcmUuZG91YmxlcyAmJiB7XG4gICAgICAgIHN0ZXA6IHByZS5kb3VibGVzLnN0ZXAsXG4gICAgICAgIHBvaW50czogcHJlLmRvdWJsZXMucG9pbnRzLm1hcChuZWdhdGUpXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcblxuUG9pbnQucHJvdG90eXBlLnRvSiA9IGZ1bmN0aW9uIHRvSigpIHtcbiAgaWYgKHRoaXMuaW5mKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChudWxsLCBudWxsLCBudWxsKTtcblxuICB2YXIgcmVzID0gdGhpcy5jdXJ2ZS5qcG9pbnQodGhpcy54LCB0aGlzLnksIHRoaXMuY3VydmUub25lKTtcbiAgcmV0dXJuIHJlcztcbn07XG5cbmZ1bmN0aW9uIEpQb2ludChjdXJ2ZSwgeCwgeSwgeikge1xuICBCYXNlLkJhc2VQb2ludC5jYWxsKHRoaXMsIGN1cnZlLCAnamFjb2JpYW4nKTtcbiAgaWYgKHggPT09IG51bGwgJiYgeSA9PT0gbnVsbCAmJiB6ID09PSBudWxsKSB7XG4gICAgdGhpcy54ID0gdGhpcy5jdXJ2ZS5vbmU7XG4gICAgdGhpcy55ID0gdGhpcy5jdXJ2ZS5vbmU7XG4gICAgdGhpcy56ID0gbmV3IEJOKDApO1xuICB9IGVsc2Uge1xuICAgIHRoaXMueCA9IG5ldyBCTih4LCAxNik7XG4gICAgdGhpcy55ID0gbmV3IEJOKHksIDE2KTtcbiAgICB0aGlzLnogPSBuZXcgQk4oeiwgMTYpO1xuICB9XG4gIGlmICghdGhpcy54LnJlZClcbiAgICB0aGlzLnggPSB0aGlzLngudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICBpZiAoIXRoaXMueS5yZWQpXG4gICAgdGhpcy55ID0gdGhpcy55LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcbiAgaWYgKCF0aGlzLnoucmVkKVxuICAgIHRoaXMueiA9IHRoaXMuei50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG5cbiAgdGhpcy56T25lID0gdGhpcy56ID09PSB0aGlzLmN1cnZlLm9uZTtcbn1cbmluaGVyaXRzKEpQb2ludCwgQmFzZS5CYXNlUG9pbnQpO1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS5qcG9pbnQgPSBmdW5jdGlvbiBqcG9pbnQoeCwgeSwgeikge1xuICByZXR1cm4gbmV3IEpQb2ludCh0aGlzLCB4LCB5LCB6KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUudG9QID0gZnVuY3Rpb24gdG9QKCkge1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobnVsbCwgbnVsbCk7XG5cbiAgdmFyIHppbnYgPSB0aGlzLnoucmVkSW52bSgpO1xuICB2YXIgemludjIgPSB6aW52LnJlZFNxcigpO1xuICB2YXIgYXggPSB0aGlzLngucmVkTXVsKHppbnYyKTtcbiAgdmFyIGF5ID0gdGhpcy55LnJlZE11bCh6aW52MikucmVkTXVsKHppbnYpO1xuXG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KGF4LCBheSk7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uIG5lZygpIHtcbiAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KHRoaXMueCwgdGhpcy55LnJlZE5lZygpLCB0aGlzLnopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQocCkge1xuICAvLyBPICsgUCA9IFBcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiBwO1xuXG4gIC8vIFAgKyBPID0gUFxuICBpZiAocC5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gMTJNICsgNFMgKyA3QVxuICB2YXIgcHoyID0gcC56LnJlZFNxcigpO1xuICB2YXIgejIgPSB0aGlzLnoucmVkU3FyKCk7XG4gIHZhciB1MSA9IHRoaXMueC5yZWRNdWwocHoyKTtcbiAgdmFyIHUyID0gcC54LnJlZE11bCh6Mik7XG4gIHZhciBzMSA9IHRoaXMueS5yZWRNdWwocHoyLnJlZE11bChwLnopKTtcbiAgdmFyIHMyID0gcC55LnJlZE11bCh6Mi5yZWRNdWwodGhpcy56KSk7XG5cbiAgdmFyIGggPSB1MS5yZWRTdWIodTIpO1xuICB2YXIgciA9IHMxLnJlZFN1YihzMik7XG4gIGlmIChoLmNtcG4oMCkgPT09IDApIHtcbiAgICBpZiAoci5jbXBuKDApICE9PSAwKVxuICAgICAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG51bGwsIG51bGwsIG51bGwpO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiB0aGlzLmRibCgpO1xuICB9XG5cbiAgdmFyIGgyID0gaC5yZWRTcXIoKTtcbiAgdmFyIGgzID0gaDIucmVkTXVsKGgpO1xuICB2YXIgdiA9IHUxLnJlZE11bChoMik7XG5cbiAgdmFyIG54ID0gci5yZWRTcXIoKS5yZWRJQWRkKGgzKS5yZWRJU3ViKHYpLnJlZElTdWIodik7XG4gIHZhciBueSA9IHIucmVkTXVsKHYucmVkSVN1YihueCkpLnJlZElTdWIoczEucmVkTXVsKGgzKSk7XG4gIHZhciBueiA9IHRoaXMuei5yZWRNdWwocC56KS5yZWRNdWwoaCk7XG5cbiAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG54LCBueSwgbnopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5taXhlZEFkZCA9IGZ1bmN0aW9uIG1peGVkQWRkKHApIHtcbiAgLy8gTyArIFAgPSBQXG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gcC50b0ooKTtcblxuICAvLyBQICsgTyA9IFBcbiAgaWYgKHAuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIDhNICsgM1MgKyA3QVxuICB2YXIgejIgPSB0aGlzLnoucmVkU3FyKCk7XG4gIHZhciB1MSA9IHRoaXMueDtcbiAgdmFyIHUyID0gcC54LnJlZE11bCh6Mik7XG4gIHZhciBzMSA9IHRoaXMueTtcbiAgdmFyIHMyID0gcC55LnJlZE11bCh6MikucmVkTXVsKHRoaXMueik7XG5cbiAgdmFyIGggPSB1MS5yZWRTdWIodTIpO1xuICB2YXIgciA9IHMxLnJlZFN1YihzMik7XG4gIGlmIChoLmNtcG4oMCkgPT09IDApIHtcbiAgICBpZiAoci5jbXBuKDApICE9PSAwKVxuICAgICAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG51bGwsIG51bGwsIG51bGwpO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiB0aGlzLmRibCgpO1xuICB9XG5cbiAgdmFyIGgyID0gaC5yZWRTcXIoKTtcbiAgdmFyIGgzID0gaDIucmVkTXVsKGgpO1xuICB2YXIgdiA9IHUxLnJlZE11bChoMik7XG5cbiAgdmFyIG54ID0gci5yZWRTcXIoKS5yZWRJQWRkKGgzKS5yZWRJU3ViKHYpLnJlZElTdWIodik7XG4gIHZhciBueSA9IHIucmVkTXVsKHYucmVkSVN1YihueCkpLnJlZElTdWIoczEucmVkTXVsKGgzKSk7XG4gIHZhciBueiA9IHRoaXMuei5yZWRNdWwoaCk7XG5cbiAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG54LCBueSwgbnopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5kYmxwID0gZnVuY3Rpb24gZGJscChwb3cpIHtcbiAgaWYgKHBvdyA9PT0gMClcbiAgICByZXR1cm4gdGhpcztcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiB0aGlzO1xuICBpZiAoIXBvdylcbiAgICByZXR1cm4gdGhpcy5kYmwoKTtcblxuICBpZiAodGhpcy5jdXJ2ZS56ZXJvQSB8fCB0aGlzLmN1cnZlLnRocmVlQSkge1xuICAgIHZhciByID0gdGhpcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvdzsgaSsrKVxuICAgICAgciA9IHIuZGJsKCk7XG4gICAgcmV0dXJuIHI7XG4gIH1cblxuICAvLyAxTSArIDJTICsgMUEgKyBOICogKDRTICsgNU0gKyA4QSlcbiAgLy8gTiA9IDEgPT4gNk0gKyA2UyArIDlBXG4gIHZhciBhID0gdGhpcy5jdXJ2ZS5hO1xuICB2YXIgdGludiA9IHRoaXMuY3VydmUudGludjtcblxuICB2YXIganggPSB0aGlzLng7XG4gIHZhciBqeSA9IHRoaXMueTtcbiAgdmFyIGp6ID0gdGhpcy56O1xuICB2YXIgano0ID0ganoucmVkU3FyKCkucmVkU3FyKCk7XG5cbiAgLy8gUmV1c2UgcmVzdWx0c1xuICB2YXIganlkID0gankucmVkQWRkKGp5KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb3c7IGkrKykge1xuICAgIHZhciBqeDIgPSBqeC5yZWRTcXIoKTtcbiAgICB2YXIganlkMiA9IGp5ZC5yZWRTcXIoKTtcbiAgICB2YXIganlkNCA9IGp5ZDIucmVkU3FyKCk7XG4gICAgdmFyIGMgPSBqeDIucmVkQWRkKGp4MikucmVkSUFkZChqeDIpLnJlZElBZGQoYS5yZWRNdWwoano0KSk7XG5cbiAgICB2YXIgdDEgPSBqeC5yZWRNdWwoanlkMik7XG4gICAgdmFyIG54ID0gYy5yZWRTcXIoKS5yZWRJU3ViKHQxLnJlZEFkZCh0MSkpO1xuICAgIHZhciB0MiA9IHQxLnJlZElTdWIobngpO1xuICAgIHZhciBkbnkgPSBjLnJlZE11bCh0Mik7XG4gICAgZG55ID0gZG55LnJlZElBZGQoZG55KS5yZWRJU3ViKGp5ZDQpO1xuICAgIHZhciBueiA9IGp5ZC5yZWRNdWwoanopO1xuICAgIGlmIChpICsgMSA8IHBvdylcbiAgICAgIGp6NCA9IGp6NC5yZWRNdWwoanlkNCk7XG5cbiAgICBqeCA9IG54O1xuICAgIGp6ID0gbno7XG4gICAganlkID0gZG55O1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KGp4LCBqeWQucmVkTXVsKHRpbnYpLCBqeik7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLmRibCA9IGZ1bmN0aW9uIGRibCgpIHtcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIGlmICh0aGlzLmN1cnZlLnplcm9BKVxuICAgIHJldHVybiB0aGlzLl96ZXJvRGJsKCk7XG4gIGVsc2UgaWYgKHRoaXMuY3VydmUudGhyZWVBKVxuICAgIHJldHVybiB0aGlzLl90aHJlZURibCgpO1xuICBlbHNlXG4gICAgcmV0dXJuIHRoaXMuX2RibCgpO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5femVyb0RibCA9IGZ1bmN0aW9uIF96ZXJvRGJsKCkge1xuICB2YXIgbng7XG4gIHZhciBueTtcbiAgdmFyIG56O1xuICAvLyBaID0gMVxuICBpZiAodGhpcy56T25lKSB7XG4gICAgLy8gaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXNob3J0dy1qYWNvYmlhbi0wLmh0bWxcbiAgICAvLyAgICAgI2RvdWJsaW5nLW1kYmwtMjAwNy1ibFxuICAgIC8vIDFNICsgNVMgKyAxNEFcblxuICAgIC8vIFhYID0gWDFeMlxuICAgIHZhciB4eCA9IHRoaXMueC5yZWRTcXIoKTtcbiAgICAvLyBZWSA9IFkxXjJcbiAgICB2YXIgeXkgPSB0aGlzLnkucmVkU3FyKCk7XG4gICAgLy8gWVlZWSA9IFlZXjJcbiAgICB2YXIgeXl5eSA9IHl5LnJlZFNxcigpO1xuICAgIC8vIFMgPSAyICogKChYMSArIFlZKV4yIC0gWFggLSBZWVlZKVxuICAgIHZhciBzID0gdGhpcy54LnJlZEFkZCh5eSkucmVkU3FyKCkucmVkSVN1Yih4eCkucmVkSVN1Yih5eXl5KTtcbiAgICBzID0gcy5yZWRJQWRkKHMpO1xuICAgIC8vIE0gPSAzICogWFggKyBhOyBhID0gMFxuICAgIHZhciBtID0geHgucmVkQWRkKHh4KS5yZWRJQWRkKHh4KTtcbiAgICAvLyBUID0gTSBeIDIgLSAyKlNcbiAgICB2YXIgdCA9IG0ucmVkU3FyKCkucmVkSVN1YihzKS5yZWRJU3ViKHMpO1xuXG4gICAgLy8gOCAqIFlZWVlcbiAgICB2YXIgeXl5eTggPSB5eXl5LnJlZElBZGQoeXl5eSk7XG4gICAgeXl5eTggPSB5eXl5OC5yZWRJQWRkKHl5eXk4KTtcbiAgICB5eXl5OCA9IHl5eXk4LnJlZElBZGQoeXl5eTgpO1xuXG4gICAgLy8gWDMgPSBUXG4gICAgbnggPSB0O1xuICAgIC8vIFkzID0gTSAqIChTIC0gVCkgLSA4ICogWVlZWVxuICAgIG55ID0gbS5yZWRNdWwocy5yZWRJU3ViKHQpKS5yZWRJU3ViKHl5eXk4KTtcbiAgICAvLyBaMyA9IDIqWTFcbiAgICBueiA9IHRoaXMueS5yZWRBZGQodGhpcy55KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBoeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tc2hvcnR3LWphY29iaWFuLTAuaHRtbFxuICAgIC8vICAgICAjZG91YmxpbmctZGJsLTIwMDktbFxuICAgIC8vIDJNICsgNVMgKyAxM0FcblxuICAgIC8vIEEgPSBYMV4yXG4gICAgdmFyIGEgPSB0aGlzLngucmVkU3FyKCk7XG4gICAgLy8gQiA9IFkxXjJcbiAgICB2YXIgYiA9IHRoaXMueS5yZWRTcXIoKTtcbiAgICAvLyBDID0gQl4yXG4gICAgdmFyIGMgPSBiLnJlZFNxcigpO1xuICAgIC8vIEQgPSAyICogKChYMSArIEIpXjIgLSBBIC0gQylcbiAgICB2YXIgZCA9IHRoaXMueC5yZWRBZGQoYikucmVkU3FyKCkucmVkSVN1YihhKS5yZWRJU3ViKGMpO1xuICAgIGQgPSBkLnJlZElBZGQoZCk7XG4gICAgLy8gRSA9IDMgKiBBXG4gICAgdmFyIGUgPSBhLnJlZEFkZChhKS5yZWRJQWRkKGEpO1xuICAgIC8vIEYgPSBFXjJcbiAgICB2YXIgZiA9IGUucmVkU3FyKCk7XG5cbiAgICAvLyA4ICogQ1xuICAgIHZhciBjOCA9IGMucmVkSUFkZChjKTtcbiAgICBjOCA9IGM4LnJlZElBZGQoYzgpO1xuICAgIGM4ID0gYzgucmVkSUFkZChjOCk7XG5cbiAgICAvLyBYMyA9IEYgLSAyICogRFxuICAgIG54ID0gZi5yZWRJU3ViKGQpLnJlZElTdWIoZCk7XG4gICAgLy8gWTMgPSBFICogKEQgLSBYMykgLSA4ICogQ1xuICAgIG55ID0gZS5yZWRNdWwoZC5yZWRJU3ViKG54KSkucmVkSVN1YihjOCk7XG4gICAgLy8gWjMgPSAyICogWTEgKiBaMVxuICAgIG56ID0gdGhpcy55LnJlZE11bCh0aGlzLnopO1xuICAgIG56ID0gbnoucmVkSUFkZChueik7XG4gIH1cblxuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobngsIG55LCBueik7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLl90aHJlZURibCA9IGZ1bmN0aW9uIF90aHJlZURibCgpIHtcbiAgdmFyIG54O1xuICB2YXIgbnk7XG4gIHZhciBuejtcbiAgLy8gWiA9IDFcbiAgaWYgKHRoaXMuek9uZSkge1xuICAgIC8vIGh5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by1zaG9ydHctamFjb2JpYW4tMy5odG1sXG4gICAgLy8gICAgICNkb3VibGluZy1tZGJsLTIwMDctYmxcbiAgICAvLyAxTSArIDVTICsgMTVBXG5cbiAgICAvLyBYWCA9IFgxXjJcbiAgICB2YXIgeHggPSB0aGlzLngucmVkU3FyKCk7XG4gICAgLy8gWVkgPSBZMV4yXG4gICAgdmFyIHl5ID0gdGhpcy55LnJlZFNxcigpO1xuICAgIC8vIFlZWVkgPSBZWV4yXG4gICAgdmFyIHl5eXkgPSB5eS5yZWRTcXIoKTtcbiAgICAvLyBTID0gMiAqICgoWDEgKyBZWSleMiAtIFhYIC0gWVlZWSlcbiAgICB2YXIgcyA9IHRoaXMueC5yZWRBZGQoeXkpLnJlZFNxcigpLnJlZElTdWIoeHgpLnJlZElTdWIoeXl5eSk7XG4gICAgcyA9IHMucmVkSUFkZChzKTtcbiAgICAvLyBNID0gMyAqIFhYICsgYVxuICAgIHZhciBtID0geHgucmVkQWRkKHh4KS5yZWRJQWRkKHh4KS5yZWRJQWRkKHRoaXMuY3VydmUuYSk7XG4gICAgLy8gVCA9IE1eMiAtIDIgKiBTXG4gICAgdmFyIHQgPSBtLnJlZFNxcigpLnJlZElTdWIocykucmVkSVN1YihzKTtcbiAgICAvLyBYMyA9IFRcbiAgICBueCA9IHQ7XG4gICAgLy8gWTMgPSBNICogKFMgLSBUKSAtIDggKiBZWVlZXG4gICAgdmFyIHl5eXk4ID0geXl5eS5yZWRJQWRkKHl5eXkpO1xuICAgIHl5eXk4ID0geXl5eTgucmVkSUFkZCh5eXl5OCk7XG4gICAgeXl5eTggPSB5eXl5OC5yZWRJQWRkKHl5eXk4KTtcbiAgICBueSA9IG0ucmVkTXVsKHMucmVkSVN1Yih0KSkucmVkSVN1Yih5eXl5OCk7XG4gICAgLy8gWjMgPSAyICogWTFcbiAgICBueiA9IHRoaXMueS5yZWRBZGQodGhpcy55KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBoeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tc2hvcnR3LWphY29iaWFuLTMuaHRtbCNkb3VibGluZy1kYmwtMjAwMS1iXG4gICAgLy8gM00gKyA1U1xuXG4gICAgLy8gZGVsdGEgPSBaMV4yXG4gICAgdmFyIGRlbHRhID0gdGhpcy56LnJlZFNxcigpO1xuICAgIC8vIGdhbW1hID0gWTFeMlxuICAgIHZhciBnYW1tYSA9IHRoaXMueS5yZWRTcXIoKTtcbiAgICAvLyBiZXRhID0gWDEgKiBnYW1tYVxuICAgIHZhciBiZXRhID0gdGhpcy54LnJlZE11bChnYW1tYSk7XG4gICAgLy8gYWxwaGEgPSAzICogKFgxIC0gZGVsdGEpICogKFgxICsgZGVsdGEpXG4gICAgdmFyIGFscGhhID0gdGhpcy54LnJlZFN1YihkZWx0YSkucmVkTXVsKHRoaXMueC5yZWRBZGQoZGVsdGEpKTtcbiAgICBhbHBoYSA9IGFscGhhLnJlZEFkZChhbHBoYSkucmVkSUFkZChhbHBoYSk7XG4gICAgLy8gWDMgPSBhbHBoYV4yIC0gOCAqIGJldGFcbiAgICB2YXIgYmV0YTQgPSBiZXRhLnJlZElBZGQoYmV0YSk7XG4gICAgYmV0YTQgPSBiZXRhNC5yZWRJQWRkKGJldGE0KTtcbiAgICB2YXIgYmV0YTggPSBiZXRhNC5yZWRBZGQoYmV0YTQpO1xuICAgIG54ID0gYWxwaGEucmVkU3FyKCkucmVkSVN1YihiZXRhOCk7XG4gICAgLy8gWjMgPSAoWTEgKyBaMSleMiAtIGdhbW1hIC0gZGVsdGFcbiAgICBueiA9IHRoaXMueS5yZWRBZGQodGhpcy56KS5yZWRTcXIoKS5yZWRJU3ViKGdhbW1hKS5yZWRJU3ViKGRlbHRhKTtcbiAgICAvLyBZMyA9IGFscGhhICogKDQgKiBiZXRhIC0gWDMpIC0gOCAqIGdhbW1hXjJcbiAgICB2YXIgZ2dhbW1hOCA9IGdhbW1hLnJlZFNxcigpO1xuICAgIGdnYW1tYTggPSBnZ2FtbWE4LnJlZElBZGQoZ2dhbW1hOCk7XG4gICAgZ2dhbW1hOCA9IGdnYW1tYTgucmVkSUFkZChnZ2FtbWE4KTtcbiAgICBnZ2FtbWE4ID0gZ2dhbW1hOC5yZWRJQWRkKGdnYW1tYTgpO1xuICAgIG55ID0gYWxwaGEucmVkTXVsKGJldGE0LnJlZElTdWIobngpKS5yZWRJU3ViKGdnYW1tYTgpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG54LCBueSwgbnopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5fZGJsID0gZnVuY3Rpb24gX2RibCgpIHtcbiAgdmFyIGEgPSB0aGlzLmN1cnZlLmE7XG5cbiAgLy8gNE0gKyA2UyArIDEwQVxuICB2YXIganggPSB0aGlzLng7XG4gIHZhciBqeSA9IHRoaXMueTtcbiAgdmFyIGp6ID0gdGhpcy56O1xuICB2YXIgano0ID0ganoucmVkU3FyKCkucmVkU3FyKCk7XG5cbiAgdmFyIGp4MiA9IGp4LnJlZFNxcigpO1xuICB2YXIgankyID0gankucmVkU3FyKCk7XG5cbiAgdmFyIGMgPSBqeDIucmVkQWRkKGp4MikucmVkSUFkZChqeDIpLnJlZElBZGQoYS5yZWRNdWwoano0KSk7XG5cbiAgdmFyIGp4ZDQgPSBqeC5yZWRBZGQoangpO1xuICBqeGQ0ID0ganhkNC5yZWRJQWRkKGp4ZDQpO1xuICB2YXIgdDEgPSBqeGQ0LnJlZE11bChqeTIpO1xuICB2YXIgbnggPSBjLnJlZFNxcigpLnJlZElTdWIodDEucmVkQWRkKHQxKSk7XG4gIHZhciB0MiA9IHQxLnJlZElTdWIobngpO1xuXG4gIHZhciBqeWQ4ID0gankyLnJlZFNxcigpO1xuICBqeWQ4ID0ganlkOC5yZWRJQWRkKGp5ZDgpO1xuICBqeWQ4ID0ganlkOC5yZWRJQWRkKGp5ZDgpO1xuICBqeWQ4ID0ganlkOC5yZWRJQWRkKGp5ZDgpO1xuICB2YXIgbnkgPSBjLnJlZE11bCh0MikucmVkSVN1YihqeWQ4KTtcbiAgdmFyIG56ID0gankucmVkQWRkKGp5KS5yZWRNdWwoanopO1xuXG4gIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChueCwgbnksIG56KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUudHJwbCA9IGZ1bmN0aW9uIHRycGwoKSB7XG4gIGlmICghdGhpcy5jdXJ2ZS56ZXJvQSlcbiAgICByZXR1cm4gdGhpcy5kYmwoKS5hZGQodGhpcyk7XG5cbiAgLy8gaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXNob3J0dy1qYWNvYmlhbi0wLmh0bWwjdHJpcGxpbmctdHBsLTIwMDctYmxcbiAgLy8gNU0gKyAxMFMgKyAuLi5cblxuICAvLyBYWCA9IFgxXjJcbiAgdmFyIHh4ID0gdGhpcy54LnJlZFNxcigpO1xuICAvLyBZWSA9IFkxXjJcbiAgdmFyIHl5ID0gdGhpcy55LnJlZFNxcigpO1xuICAvLyBaWiA9IFoxXjJcbiAgdmFyIHp6ID0gdGhpcy56LnJlZFNxcigpO1xuICAvLyBZWVlZID0gWVleMlxuICB2YXIgeXl5eSA9IHl5LnJlZFNxcigpO1xuICAvLyBNID0gMyAqIFhYICsgYSAqIFpaMjsgYSA9IDBcbiAgdmFyIG0gPSB4eC5yZWRBZGQoeHgpLnJlZElBZGQoeHgpO1xuICAvLyBNTSA9IE1eMlxuICB2YXIgbW0gPSBtLnJlZFNxcigpO1xuICAvLyBFID0gNiAqICgoWDEgKyBZWSleMiAtIFhYIC0gWVlZWSkgLSBNTVxuICB2YXIgZSA9IHRoaXMueC5yZWRBZGQoeXkpLnJlZFNxcigpLnJlZElTdWIoeHgpLnJlZElTdWIoeXl5eSk7XG4gIGUgPSBlLnJlZElBZGQoZSk7XG4gIGUgPSBlLnJlZEFkZChlKS5yZWRJQWRkKGUpO1xuICBlID0gZS5yZWRJU3ViKG1tKTtcbiAgLy8gRUUgPSBFXjJcbiAgdmFyIGVlID0gZS5yZWRTcXIoKTtcbiAgLy8gVCA9IDE2KllZWVlcbiAgdmFyIHQgPSB5eXl5LnJlZElBZGQoeXl5eSk7XG4gIHQgPSB0LnJlZElBZGQodCk7XG4gIHQgPSB0LnJlZElBZGQodCk7XG4gIHQgPSB0LnJlZElBZGQodCk7XG4gIC8vIFUgPSAoTSArIEUpXjIgLSBNTSAtIEVFIC0gVFxuICB2YXIgdSA9IG0ucmVkSUFkZChlKS5yZWRTcXIoKS5yZWRJU3ViKG1tKS5yZWRJU3ViKGVlKS5yZWRJU3ViKHQpO1xuICAvLyBYMyA9IDQgKiAoWDEgKiBFRSAtIDQgKiBZWSAqIFUpXG4gIHZhciB5eXU0ID0geXkucmVkTXVsKHUpO1xuICB5eXU0ID0geXl1NC5yZWRJQWRkKHl5dTQpO1xuICB5eXU0ID0geXl1NC5yZWRJQWRkKHl5dTQpO1xuICB2YXIgbnggPSB0aGlzLngucmVkTXVsKGVlKS5yZWRJU3ViKHl5dTQpO1xuICBueCA9IG54LnJlZElBZGQobngpO1xuICBueCA9IG54LnJlZElBZGQobngpO1xuICAvLyBZMyA9IDggKiBZMSAqIChVICogKFQgLSBVKSAtIEUgKiBFRSlcbiAgdmFyIG55ID0gdGhpcy55LnJlZE11bCh1LnJlZE11bCh0LnJlZElTdWIodSkpLnJlZElTdWIoZS5yZWRNdWwoZWUpKSk7XG4gIG55ID0gbnkucmVkSUFkZChueSk7XG4gIG55ID0gbnkucmVkSUFkZChueSk7XG4gIG55ID0gbnkucmVkSUFkZChueSk7XG4gIC8vIFozID0gKFoxICsgRSleMiAtIFpaIC0gRUVcbiAgdmFyIG56ID0gdGhpcy56LnJlZEFkZChlKS5yZWRTcXIoKS5yZWRJU3ViKHp6KS5yZWRJU3ViKGVlKTtcblxuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobngsIG55LCBueik7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bChrLCBrYmFzZSkge1xuICBrID0gbmV3IEJOKGssIGtiYXNlKTtcblxuICByZXR1cm4gdGhpcy5jdXJ2ZS5fd25hZk11bCh0aGlzLCBrKTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiBlcShwKSB7XG4gIGlmIChwLnR5cGUgPT09ICdhZmZpbmUnKVxuICAgIHJldHVybiB0aGlzLmVxKHAudG9KKCkpO1xuXG4gIGlmICh0aGlzID09PSBwKVxuICAgIHJldHVybiB0cnVlO1xuXG4gIC8vIHgxICogejJeMiA9PSB4MiAqIHoxXjJcbiAgdmFyIHoyID0gdGhpcy56LnJlZFNxcigpO1xuICB2YXIgcHoyID0gcC56LnJlZFNxcigpO1xuICBpZiAodGhpcy54LnJlZE11bChwejIpLnJlZElTdWIocC54LnJlZE11bCh6MikpLmNtcG4oMCkgIT09IDApXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIHkxICogejJeMyA9PSB5MiAqIHoxXjNcbiAgdmFyIHozID0gejIucmVkTXVsKHRoaXMueik7XG4gIHZhciBwejMgPSBwejIucmVkTXVsKHAueik7XG4gIHJldHVybiB0aGlzLnkucmVkTXVsKHB6MykucmVkSVN1YihwLnkucmVkTXVsKHozKSkuY21wbigwKSA9PT0gMDtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUuZXFYVG9QID0gZnVuY3Rpb24gZXFYVG9QKHgpIHtcbiAgdmFyIHpzID0gdGhpcy56LnJlZFNxcigpO1xuICB2YXIgcnggPSB4LnRvUmVkKHRoaXMuY3VydmUucmVkKS5yZWRNdWwoenMpO1xuICBpZiAodGhpcy54LmNtcChyeCkgPT09IDApXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgdmFyIHhjID0geC5jbG9uZSgpO1xuICB2YXIgdCA9IHRoaXMuY3VydmUucmVkTi5yZWRNdWwoenMpO1xuICBmb3IgKDs7KSB7XG4gICAgeGMuaWFkZCh0aGlzLmN1cnZlLm4pO1xuICAgIGlmICh4Yy5jbXAodGhpcy5jdXJ2ZS5wKSA+PSAwKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgcngucmVkSUFkZCh0KTtcbiAgICBpZiAodGhpcy54LmNtcChyeCkgPT09IDApXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuSlBvaW50LnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiAnPEVDIEpQb2ludCBJbmZpbml0eT4nO1xuICByZXR1cm4gJzxFQyBKUG9pbnQgeDogJyArIHRoaXMueC50b1N0cmluZygxNiwgMikgK1xuICAgICAgJyB5OiAnICsgdGhpcy55LnRvU3RyaW5nKDE2LCAyKSArXG4gICAgICAnIHo6ICcgKyB0aGlzLnoudG9TdHJpbmcoMTYsIDIpICsgJz4nO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5pc0luZmluaXR5ID0gZnVuY3Rpb24gaXNJbmZpbml0eSgpIHtcbiAgLy8gWFhYIFRoaXMgY29kZSBhc3N1bWVzIHRoYXQgemVybyBpcyBhbHdheXMgemVybyBpbiByZWRcbiAgcmV0dXJuIHRoaXMuei5jbXBuKDApID09PSAwO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGN1cnZlcyA9IGV4cG9ydHM7XG5cbnZhciBoYXNoID0gcmVxdWlyZSgnaGFzaC5qcycpO1xudmFyIGN1cnZlID0gcmVxdWlyZSgnLi9jdXJ2ZScpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG52YXIgYXNzZXJ0ID0gdXRpbHMuYXNzZXJ0O1xuXG5mdW5jdGlvbiBQcmVzZXRDdXJ2ZShvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLnR5cGUgPT09ICdzaG9ydCcpXG4gICAgdGhpcy5jdXJ2ZSA9IG5ldyBjdXJ2ZS5zaG9ydChvcHRpb25zKTtcbiAgZWxzZSBpZiAob3B0aW9ucy50eXBlID09PSAnZWR3YXJkcycpXG4gICAgdGhpcy5jdXJ2ZSA9IG5ldyBjdXJ2ZS5lZHdhcmRzKG9wdGlvbnMpO1xuICBlbHNlXG4gICAgdGhpcy5jdXJ2ZSA9IG5ldyBjdXJ2ZS5tb250KG9wdGlvbnMpO1xuICB0aGlzLmcgPSB0aGlzLmN1cnZlLmc7XG4gIHRoaXMubiA9IHRoaXMuY3VydmUubjtcbiAgdGhpcy5oYXNoID0gb3B0aW9ucy5oYXNoO1xuXG4gIGFzc2VydCh0aGlzLmcudmFsaWRhdGUoKSwgJ0ludmFsaWQgY3VydmUnKTtcbiAgYXNzZXJ0KHRoaXMuZy5tdWwodGhpcy5uKS5pc0luZmluaXR5KCksICdJbnZhbGlkIGN1cnZlLCBHKk4gIT0gTycpO1xufVxuY3VydmVzLlByZXNldEN1cnZlID0gUHJlc2V0Q3VydmU7XG5cbmZ1bmN0aW9uIGRlZmluZUN1cnZlKG5hbWUsIG9wdGlvbnMpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1cnZlcywgbmFtZSwge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY3VydmUgPSBuZXcgUHJlc2V0Q3VydmUob3B0aW9ucyk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VydmVzLCBuYW1lLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGN1cnZlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjdXJ2ZTtcbiAgICB9XG4gIH0pO1xufVxuXG5kZWZpbmVDdXJ2ZSgncDE5MicsIHtcbiAgdHlwZTogJ3Nob3J0JyxcbiAgcHJpbWU6ICdwMTkyJyxcbiAgcDogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmZmZmIGZmZmZmZmZmJyxcbiAgYTogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmZmZmIGZmZmZmZmZjJyxcbiAgYjogJzY0MjEwNTE5IGU1OWM4MGU3IDBmYTdlOWFiIDcyMjQzMDQ5IGZlYjhkZWVjIGMxNDZiOWIxJyxcbiAgbjogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIDk5ZGVmODM2IDE0NmJjOWIxIGI0ZDIyODMxJyxcbiAgaGFzaDogaGFzaC5zaGEyNTYsXG4gIGdSZWQ6IGZhbHNlLFxuICBnOiBbXG4gICAgJzE4OGRhODBlIGIwMzA5MGY2IDdjYmYyMGViIDQzYTE4ODAwIGY0ZmYwYWZkIDgyZmYxMDEyJyxcbiAgICAnMDcxOTJiOTUgZmZjOGRhNzggNjMxMDExZWQgNmIyNGNkZDUgNzNmOTc3YTEgMWU3OTQ4MTEnXG4gIF1cbn0pO1xuXG5kZWZpbmVDdXJ2ZSgncDIyNCcsIHtcbiAgdHlwZTogJ3Nob3J0JyxcbiAgcHJpbWU6ICdwMjI0JyxcbiAgcDogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAxJyxcbiAgYTogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlJyxcbiAgYjogJ2I0MDUwYTg1IDBjMDRiM2FiIGY1NDEzMjU2IDUwNDRiMGI3IGQ3YmZkOGJhIDI3MGIzOTQzIDIzNTVmZmI0JyxcbiAgbjogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmYxNmEyIGUwYjhmMDNlIDEzZGQyOTQ1IDVjNWMyYTNkJyxcbiAgaGFzaDogaGFzaC5zaGEyNTYsXG4gIGdSZWQ6IGZhbHNlLFxuICBnOiBbXG4gICAgJ2I3MGUwY2JkIDZiYjRiZjdmIDMyMTM5MGI5IDRhMDNjMWQzIDU2YzIxMTIyIDM0MzI4MGQ2IDExNWMxZDIxJyxcbiAgICAnYmQzNzYzODggYjVmNzIzZmIgNGMyMmRmZTYgY2Q0Mzc1YTAgNWEwNzQ3NjQgNDRkNTgxOTkgODUwMDdlMzQnXG4gIF1cbn0pO1xuXG5kZWZpbmVDdXJ2ZSgncDI1NicsIHtcbiAgdHlwZTogJ3Nob3J0JyxcbiAgcHJpbWU6IG51bGwsXG4gIHA6ICdmZmZmZmZmZiAwMDAwMDAwMSAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMCBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZicsXG4gIGE6ICdmZmZmZmZmZiAwMDAwMDAwMSAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMCBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmYycsXG4gIGI6ICc1YWM2MzVkOCBhYTNhOTNlNyBiM2ViYmQ1NSA3Njk4ODZiYyA2NTFkMDZiMCBjYzUzYjBmNiAzYmNlM2MzZSAyN2QyNjA0YicsXG4gIG46ICdmZmZmZmZmZiAwMDAwMDAwMCBmZmZmZmZmZiBmZmZmZmZmZiBiY2U2ZmFhZCBhNzE3OWU4NCBmM2I5Y2FjMiBmYzYzMjU1MScsXG4gIGhhc2g6IGhhc2guc2hhMjU2LFxuICBnUmVkOiBmYWxzZSxcbiAgZzogW1xuICAgICc2YjE3ZDFmMiBlMTJjNDI0NyBmOGJjZTZlNSA2M2E0NDBmMiA3NzAzN2Q4MSAyZGViMzNhMCBmNGExMzk0NSBkODk4YzI5NicsXG4gICAgJzRmZTM0MmUyIGZlMWE3ZjliIDhlZTdlYjRhIDdjMGY5ZTE2IDJiY2UzMzU3IDZiMzE1ZWNlIGNiYjY0MDY4IDM3YmY1MWY1J1xuICBdXG59KTtcblxuZGVmaW5lQ3VydmUoJ3AzODQnLCB7XG4gIHR5cGU6ICdzaG9ydCcsXG4gIHByaW1lOiBudWxsLFxuICBwOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgJyArXG4gICAgICdmZmZmZmZmZSBmZmZmZmZmZiAwMDAwMDAwMCAwMDAwMDAwMCBmZmZmZmZmZicsXG4gIGE6ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAnICtcbiAgICAgJ2ZmZmZmZmZlIGZmZmZmZmZmIDAwMDAwMDAwIDAwMDAwMDAwIGZmZmZmZmZjJyxcbiAgYjogJ2IzMzEyZmE3IGUyM2VlN2U0IDk4OGUwNTZiIGUzZjgyZDE5IDE4MWQ5YzZlIGZlODE0MTEyIDAzMTQwODhmICcgK1xuICAgICAnNTAxMzg3NWEgYzY1NjM5OGQgOGEyZWQxOWQgMmE4NWM4ZWQgZDNlYzJhZWYnLFxuICBuOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgYzc2MzRkODEgJyArXG4gICAgICdmNDM3MmRkZiA1ODFhMGRiMiA0OGIwYTc3YSBlY2VjMTk2YSBjY2M1Mjk3MycsXG4gIGhhc2g6IGhhc2guc2hhMzg0LFxuICBnUmVkOiBmYWxzZSxcbiAgZzogW1xuICAgICdhYTg3Y2EyMiBiZThiMDUzNyA4ZWIxYzcxZSBmMzIwYWQ3NCA2ZTFkM2I2MiA4YmE3OWI5OCA1OWY3NDFlMCA4MjU0MmEzOCAnICtcbiAgICAnNTUwMmYyNWQgYmY1NTI5NmMgM2E1NDVlMzggNzI3NjBhYjcnLFxuICAgICczNjE3ZGU0YSA5NjI2MmM2ZiA1ZDllOThiZiA5MjkyZGMyOSBmOGY0MWRiZCAyODlhMTQ3YyBlOWRhMzExMyBiNWYwYjhjMCAnICtcbiAgICAnMGE2MGIxY2UgMWQ3ZTgxOWQgN2E0MzFkN2MgOTBlYTBlNWYnXG4gIF1cbn0pO1xuXG5kZWZpbmVDdXJ2ZSgncDUyMScsIHtcbiAgdHlwZTogJ3Nob3J0JyxcbiAgcHJpbWU6IG51bGwsXG4gIHA6ICcwMDAwMDFmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAnICtcbiAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmICcgK1xuICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYnLFxuICBhOiAnMDAwMDAxZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgJyArXG4gICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAnICtcbiAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZjJyxcbiAgYjogJzAwMDAwMDUxIDk1M2ViOTYxIDhlMWM5YTFmIDkyOWEyMWEwIGI2ODU0MGVlIGEyZGE3MjViICcgK1xuICAgICAnOTliMzE1ZjMgYjhiNDg5OTEgOGVmMTA5ZTEgNTYxOTM5NTEgZWM3ZTkzN2IgMTY1MmMwYmQgJyArXG4gICAgICczYmIxYmYwNyAzNTczZGY4OCAzZDJjMzRmMSBlZjQ1MWZkNCA2YjUwM2YwMCcsXG4gIG46ICcwMDAwMDFmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAnICtcbiAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZhIDUxODY4NzgzIGJmMmY5NjZiIDdmY2MwMTQ4ICcgK1xuICAgICAnZjcwOWE1ZDAgM2JiNWM5YjggODk5YzQ3YWUgYmI2ZmI3MWUgOTEzODY0MDknLFxuICBoYXNoOiBoYXNoLnNoYTUxMixcbiAgZ1JlZDogZmFsc2UsXG4gIGc6IFtcbiAgICAnMDAwMDAwYzYgODU4ZTA2YjcgMDQwNGU5Y2QgOWUzZWNiNjYgMjM5NWI0NDIgOWM2NDgxMzkgJyArXG4gICAgJzA1M2ZiNTIxIGY4MjhhZjYwIDZiNGQzZGJhIGExNGI1ZTc3IGVmZTc1OTI4IGZlMWRjMTI3ICcgK1xuICAgICdhMmZmYThkZSAzMzQ4YjNjMSA4NTZhNDI5YiBmOTdlN2UzMSBjMmU1YmQ2NicsXG4gICAgJzAwMDAwMTE4IDM5Mjk2YTc4IDlhM2JjMDA0IDVjOGE1ZmI0IDJjN2QxYmQ5IDk4ZjU0NDQ5ICcgK1xuICAgICc1NzliNDQ2OCAxN2FmYmQxNyAyNzNlNjYyYyA5N2VlNzI5OSA1ZWY0MjY0MCBjNTUwYjkwMSAnICtcbiAgICAnM2ZhZDA3NjEgMzUzYzcwODYgYTI3MmMyNDAgODhiZTk0NzYgOWZkMTY2NTAnXG4gIF1cbn0pO1xuXG5kZWZpbmVDdXJ2ZSgnY3VydmUyNTUxOScsIHtcbiAgdHlwZTogJ21vbnQnLFxuICBwcmltZTogJ3AyNTUxOScsXG4gIHA6ICc3ZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmVkJyxcbiAgYTogJzc2ZDA2JyxcbiAgYjogJzEnLFxuICBuOiAnMTAwMDAwMDAwMDAwMDAwMCAwMDAwMDAwMDAwMDAwMDAwIDE0ZGVmOWRlYTJmNzljZDYgNTgxMjYzMWE1Y2Y1ZDNlZCcsXG4gIGhhc2g6IGhhc2guc2hhMjU2LFxuICBnUmVkOiBmYWxzZSxcbiAgZzogW1xuICAgICc5J1xuICBdXG59KTtcblxuZGVmaW5lQ3VydmUoJ2VkMjU1MTknLCB7XG4gIHR5cGU6ICdlZHdhcmRzJyxcbiAgcHJpbWU6ICdwMjU1MTknLFxuICBwOiAnN2ZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZlZCcsXG4gIGE6ICctMScsXG4gIGM6ICcxJyxcbiAgLy8gLTEyMTY2NSAqICgxMjE2NjZeKC0xKSkgKG1vZCBQKVxuICBkOiAnNTIwMzZjZWUyYjZmZmU3MyA4Y2M3NDA3OTc3NzllODk4IDAwNzAwYTRkNDE0MWQ4YWIgNzVlYjRkY2ExMzU5NzhhMycsXG4gIG46ICcxMDAwMDAwMDAwMDAwMDAwIDAwMDAwMDAwMDAwMDAwMDAgMTRkZWY5ZGVhMmY3OWNkNiA1ODEyNjMxYTVjZjVkM2VkJyxcbiAgaGFzaDogaGFzaC5zaGEyNTYsXG4gIGdSZWQ6IGZhbHNlLFxuICBnOiBbXG4gICAgJzIxNjkzNmQzY2Q2ZTUzZmVjMGE0ZTIzMWZkZDZkYzVjNjkyY2M3NjA5NTI1YTdiMmM5NTYyZDYwOGYyNWQ1MWEnLFxuXG4gICAgLy8gNC81XG4gICAgJzY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NTgnXG4gIF1cbn0pO1xuXG52YXIgcHJlO1xudHJ5IHtcbiAgcHJlID0gcmVxdWlyZSgnLi9wcmVjb21wdXRlZC9zZWNwMjU2azEnKTtcbn0gY2F0Y2ggKGUpIHtcbiAgcHJlID0gdW5kZWZpbmVkO1xufVxuXG5kZWZpbmVDdXJ2ZSgnc2VjcDI1NmsxJywge1xuICB0eXBlOiAnc2hvcnQnLFxuICBwcmltZTogJ2syNTYnLFxuICBwOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZjMmYnLFxuICBhOiAnMCcsXG4gIGI6ICc3JyxcbiAgbjogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGJhYWVkY2U2IGFmNDhhMDNiIGJmZDI1ZThjIGQwMzY0MTQxJyxcbiAgaDogJzEnLFxuICBoYXNoOiBoYXNoLnNoYTI1NixcblxuICAvLyBQcmVjb21wdXRlZCBlbmRvbW9ycGhpc21cbiAgYmV0YTogJzdhZTk2YTJiNjU3YzA3MTA2ZTY0NDc5ZWFjMzQzNGU5OWNmMDQ5NzUxMmY1ODk5NWMxMzk2YzI4NzE5NTAxZWUnLFxuICBsYW1iZGE6ICc1MzYzYWQ0Y2MwNWMzMGUwYTUyNjFjMDI4ODEyNjQ1YTEyMmUyMmVhMjA4MTY2NzhkZjAyOTY3YzFiMjNiZDcyJyxcbiAgYmFzaXM6IFtcbiAgICB7XG4gICAgICBhOiAnMzA4NmQyMjFhN2Q0NmJjZGU4NmM5MGU0OTI4NGViMTUnLFxuICAgICAgYjogJy1lNDQzN2VkNjAxMGU4ODI4NmY1NDdmYTkwYWJmZTRjMydcbiAgICB9LFxuICAgIHtcbiAgICAgIGE6ICcxMTRjYTUwZjdhOGUyZjNmNjU3YzExMDhkOWQ0NGNmZDgnLFxuICAgICAgYjogJzMwODZkMjIxYTdkNDZiY2RlODZjOTBlNDkyODRlYjE1J1xuICAgIH1cbiAgXSxcblxuICBnUmVkOiBmYWxzZSxcbiAgZzogW1xuICAgICc3OWJlNjY3ZWY5ZGNiYmFjNTVhMDYyOTVjZTg3MGIwNzAyOWJmY2RiMmRjZTI4ZDk1OWYyODE1YjE2ZjgxNzk4JyxcbiAgICAnNDgzYWRhNzcyNmEzYzQ2NTVkYTRmYmZjMGUxMTA4YThmZDE3YjQ0OGE2ODU1NDE5OWM0N2QwOGZmYjEwZDRiOCcsXG4gICAgcHJlXG4gIF1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIEhtYWNEUkJHID0gcmVxdWlyZSgnaG1hYy1kcmJnJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIGN1cnZlcyA9IHJlcXVpcmUoJy4uL2N1cnZlcycpO1xudmFyIHJhbmQgPSByZXF1aXJlKCdicm9yYW5kJyk7XG52YXIgYXNzZXJ0ID0gdXRpbHMuYXNzZXJ0O1xuXG52YXIgS2V5UGFpciA9IHJlcXVpcmUoJy4va2V5Jyk7XG52YXIgU2lnbmF0dXJlID0gcmVxdWlyZSgnLi9zaWduYXR1cmUnKTtcblxuZnVuY3Rpb24gRUMob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRUMpKVxuICAgIHJldHVybiBuZXcgRUMob3B0aW9ucyk7XG5cbiAgLy8gU2hvcnRjdXQgYGVsbGlwdGljLmVjKGN1cnZlLW5hbWUpYFxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgYXNzZXJ0KGN1cnZlcy5oYXNPd25Qcm9wZXJ0eShvcHRpb25zKSwgJ1Vua25vd24gY3VydmUgJyArIG9wdGlvbnMpO1xuXG4gICAgb3B0aW9ucyA9IGN1cnZlc1tvcHRpb25zXTtcbiAgfVxuXG4gIC8vIFNob3J0Y3V0IGZvciBgZWxsaXB0aWMuZWMoZWxsaXB0aWMuY3VydmVzLmN1cnZlTmFtZSlgXG4gIGlmIChvcHRpb25zIGluc3RhbmNlb2YgY3VydmVzLlByZXNldEN1cnZlKVxuICAgIG9wdGlvbnMgPSB7IGN1cnZlOiBvcHRpb25zIH07XG5cbiAgdGhpcy5jdXJ2ZSA9IG9wdGlvbnMuY3VydmUuY3VydmU7XG4gIHRoaXMubiA9IHRoaXMuY3VydmUubjtcbiAgdGhpcy5uaCA9IHRoaXMubi51c2hybigxKTtcbiAgdGhpcy5nID0gdGhpcy5jdXJ2ZS5nO1xuXG4gIC8vIFBvaW50IG9uIGN1cnZlXG4gIHRoaXMuZyA9IG9wdGlvbnMuY3VydmUuZztcbiAgdGhpcy5nLnByZWNvbXB1dGUob3B0aW9ucy5jdXJ2ZS5uLmJpdExlbmd0aCgpICsgMSk7XG5cbiAgLy8gSGFzaCBmb3IgZnVuY3Rpb24gZm9yIERSQkdcbiAgdGhpcy5oYXNoID0gb3B0aW9ucy5oYXNoIHx8IG9wdGlvbnMuY3VydmUuaGFzaDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRUM7XG5cbkVDLnByb3RvdHlwZS5rZXlQYWlyID0gZnVuY3Rpb24ga2V5UGFpcihvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgS2V5UGFpcih0aGlzLCBvcHRpb25zKTtcbn07XG5cbkVDLnByb3RvdHlwZS5rZXlGcm9tUHJpdmF0ZSA9IGZ1bmN0aW9uIGtleUZyb21Qcml2YXRlKHByaXYsIGVuYykge1xuICByZXR1cm4gS2V5UGFpci5mcm9tUHJpdmF0ZSh0aGlzLCBwcml2LCBlbmMpO1xufTtcblxuRUMucHJvdG90eXBlLmtleUZyb21QdWJsaWMgPSBmdW5jdGlvbiBrZXlGcm9tUHVibGljKHB1YiwgZW5jKSB7XG4gIHJldHVybiBLZXlQYWlyLmZyb21QdWJsaWModGhpcywgcHViLCBlbmMpO1xufTtcblxuRUMucHJvdG90eXBlLmdlbktleVBhaXIgPSBmdW5jdGlvbiBnZW5LZXlQYWlyKG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zKVxuICAgIG9wdGlvbnMgPSB7fTtcblxuICAvLyBJbnN0YW50aWF0ZSBIbWFjX0RSQkdcbiAgdmFyIGRyYmcgPSBuZXcgSG1hY0RSQkcoe1xuICAgIGhhc2g6IHRoaXMuaGFzaCxcbiAgICBwZXJzOiBvcHRpb25zLnBlcnMsXG4gICAgcGVyc0VuYzogb3B0aW9ucy5wZXJzRW5jIHx8ICd1dGY4JyxcbiAgICBlbnRyb3B5OiBvcHRpb25zLmVudHJvcHkgfHwgcmFuZCh0aGlzLmhhc2guaG1hY1N0cmVuZ3RoKSxcbiAgICBlbnRyb3B5RW5jOiBvcHRpb25zLmVudHJvcHkgJiYgb3B0aW9ucy5lbnRyb3B5RW5jIHx8ICd1dGY4JyxcbiAgICBub25jZTogdGhpcy5uLnRvQXJyYXkoKVxuICB9KTtcblxuICB2YXIgYnl0ZXMgPSB0aGlzLm4uYnl0ZUxlbmd0aCgpO1xuICB2YXIgbnMyID0gdGhpcy5uLnN1YihuZXcgQk4oMikpO1xuICBkbyB7XG4gICAgdmFyIHByaXYgPSBuZXcgQk4oZHJiZy5nZW5lcmF0ZShieXRlcykpO1xuICAgIGlmIChwcml2LmNtcChuczIpID4gMClcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgcHJpdi5pYWRkbigxKTtcbiAgICByZXR1cm4gdGhpcy5rZXlGcm9tUHJpdmF0ZShwcml2KTtcbiAgfSB3aGlsZSAodHJ1ZSk7XG59O1xuXG5FQy5wcm90b3R5cGUuX3RydW5jYXRlVG9OID0gZnVuY3Rpb24gdHJ1bmNhdGVUb04obXNnLCB0cnVuY09ubHkpIHtcbiAgdmFyIGRlbHRhID0gbXNnLmJ5dGVMZW5ndGgoKSAqIDggLSB0aGlzLm4uYml0TGVuZ3RoKCk7XG4gIGlmIChkZWx0YSA+IDApXG4gICAgbXNnID0gbXNnLnVzaHJuKGRlbHRhKTtcbiAgaWYgKCF0cnVuY09ubHkgJiYgbXNnLmNtcCh0aGlzLm4pID49IDApXG4gICAgcmV0dXJuIG1zZy5zdWIodGhpcy5uKTtcbiAgZWxzZVxuICAgIHJldHVybiBtc2c7XG59O1xuXG5FQy5wcm90b3R5cGUuc2lnbiA9IGZ1bmN0aW9uIHNpZ24obXNnLCBrZXksIGVuYywgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIGVuYyA9PT0gJ29iamVjdCcpIHtcbiAgICBvcHRpb25zID0gZW5jO1xuICAgIGVuYyA9IG51bGw7XG4gIH1cbiAgaWYgKCFvcHRpb25zKVxuICAgIG9wdGlvbnMgPSB7fTtcblxuICBrZXkgPSB0aGlzLmtleUZyb21Qcml2YXRlKGtleSwgZW5jKTtcbiAgbXNnID0gdGhpcy5fdHJ1bmNhdGVUb04obmV3IEJOKG1zZywgMTYpKTtcblxuICAvLyBaZXJvLWV4dGVuZCBrZXkgdG8gcHJvdmlkZSBlbm91Z2ggZW50cm9weVxuICB2YXIgYnl0ZXMgPSB0aGlzLm4uYnl0ZUxlbmd0aCgpO1xuICB2YXIgYmtleSA9IGtleS5nZXRQcml2YXRlKCkudG9BcnJheSgnYmUnLCBieXRlcyk7XG5cbiAgLy8gWmVyby1leHRlbmQgbm9uY2UgdG8gaGF2ZSB0aGUgc2FtZSBieXRlIHNpemUgYXMgTlxuICB2YXIgbm9uY2UgPSBtc2cudG9BcnJheSgnYmUnLCBieXRlcyk7XG5cbiAgLy8gSW5zdGFudGlhdGUgSG1hY19EUkJHXG4gIHZhciBkcmJnID0gbmV3IEhtYWNEUkJHKHtcbiAgICBoYXNoOiB0aGlzLmhhc2gsXG4gICAgZW50cm9weTogYmtleSxcbiAgICBub25jZTogbm9uY2UsXG4gICAgcGVyczogb3B0aW9ucy5wZXJzLFxuICAgIHBlcnNFbmM6IG9wdGlvbnMucGVyc0VuYyB8fCAndXRmOCdcbiAgfSk7XG5cbiAgLy8gTnVtYmVyIG9mIGJ5dGVzIHRvIGdlbmVyYXRlXG4gIHZhciBuczEgPSB0aGlzLm4uc3ViKG5ldyBCTigxKSk7XG5cbiAgZm9yICh2YXIgaXRlciA9IDA7IHRydWU7IGl0ZXIrKykge1xuICAgIHZhciBrID0gb3B0aW9ucy5rID9cbiAgICAgICAgb3B0aW9ucy5rKGl0ZXIpIDpcbiAgICAgICAgbmV3IEJOKGRyYmcuZ2VuZXJhdGUodGhpcy5uLmJ5dGVMZW5ndGgoKSkpO1xuICAgIGsgPSB0aGlzLl90cnVuY2F0ZVRvTihrLCB0cnVlKTtcbiAgICBpZiAoay5jbXBuKDEpIDw9IDAgfHwgay5jbXAobnMxKSA+PSAwKVxuICAgICAgY29udGludWU7XG5cbiAgICB2YXIga3AgPSB0aGlzLmcubXVsKGspO1xuICAgIGlmIChrcC5pc0luZmluaXR5KCkpXG4gICAgICBjb250aW51ZTtcblxuICAgIHZhciBrcFggPSBrcC5nZXRYKCk7XG4gICAgdmFyIHIgPSBrcFgudW1vZCh0aGlzLm4pO1xuICAgIGlmIChyLmNtcG4oMCkgPT09IDApXG4gICAgICBjb250aW51ZTtcblxuICAgIHZhciBzID0gay5pbnZtKHRoaXMubikubXVsKHIubXVsKGtleS5nZXRQcml2YXRlKCkpLmlhZGQobXNnKSk7XG4gICAgcyA9IHMudW1vZCh0aGlzLm4pO1xuICAgIGlmIChzLmNtcG4oMCkgPT09IDApXG4gICAgICBjb250aW51ZTtcblxuICAgIHZhciByZWNvdmVyeVBhcmFtID0gKGtwLmdldFkoKS5pc09kZCgpID8gMSA6IDApIHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChrcFguY21wKHIpICE9PSAwID8gMiA6IDApO1xuXG4gICAgLy8gVXNlIGNvbXBsZW1lbnQgb2YgYHNgLCBpZiBpdCBpcyA+IGBuIC8gMmBcbiAgICBpZiAob3B0aW9ucy5jYW5vbmljYWwgJiYgcy5jbXAodGhpcy5uaCkgPiAwKSB7XG4gICAgICBzID0gdGhpcy5uLnN1YihzKTtcbiAgICAgIHJlY292ZXJ5UGFyYW0gXj0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFNpZ25hdHVyZSh7IHI6IHIsIHM6IHMsIHJlY292ZXJ5UGFyYW06IHJlY292ZXJ5UGFyYW0gfSk7XG4gIH1cbn07XG5cbkVDLnByb3RvdHlwZS52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobXNnLCBzaWduYXR1cmUsIGtleSwgZW5jKSB7XG4gIG1zZyA9IHRoaXMuX3RydW5jYXRlVG9OKG5ldyBCTihtc2csIDE2KSk7XG4gIGtleSA9IHRoaXMua2V5RnJvbVB1YmxpYyhrZXksIGVuYyk7XG4gIHNpZ25hdHVyZSA9IG5ldyBTaWduYXR1cmUoc2lnbmF0dXJlLCAnaGV4Jyk7XG5cbiAgLy8gUGVyZm9ybSBwcmltaXRpdmUgdmFsdWVzIHZhbGlkYXRpb25cbiAgdmFyIHIgPSBzaWduYXR1cmUucjtcbiAgdmFyIHMgPSBzaWduYXR1cmUucztcbiAgaWYgKHIuY21wbigxKSA8IDAgfHwgci5jbXAodGhpcy5uKSA+PSAwKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKHMuY21wbigxKSA8IDAgfHwgcy5jbXAodGhpcy5uKSA+PSAwKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBWYWxpZGF0ZSBzaWduYXR1cmVcbiAgdmFyIHNpbnYgPSBzLmludm0odGhpcy5uKTtcbiAgdmFyIHUxID0gc2ludi5tdWwobXNnKS51bW9kKHRoaXMubik7XG4gIHZhciB1MiA9IHNpbnYubXVsKHIpLnVtb2QodGhpcy5uKTtcblxuICBpZiAoIXRoaXMuY3VydmUuX21heHdlbGxUcmljaykge1xuICAgIHZhciBwID0gdGhpcy5nLm11bEFkZCh1MSwga2V5LmdldFB1YmxpYygpLCB1Mik7XG4gICAgaWYgKHAuaXNJbmZpbml0eSgpKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgcmV0dXJuIHAuZ2V0WCgpLnVtb2QodGhpcy5uKS5jbXAocikgPT09IDA7XG4gIH1cblxuICAvLyBOT1RFOiBHcmVnIE1heHdlbGwncyB0cmljaywgaW5zcGlyZWQgYnk6XG4gIC8vIGh0dHBzOi8vZ2l0LmlvL3ZhZDNLXG5cbiAgdmFyIHAgPSB0aGlzLmcuam11bEFkZCh1MSwga2V5LmdldFB1YmxpYygpLCB1Mik7XG4gIGlmIChwLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8gQ29tcGFyZSBgcC54YCBvZiBKYWNvYmlhbiBwb2ludCB3aXRoIGByYCxcbiAgLy8gdGhpcyB3aWxsIGRvIGBwLnggPT0gciAqIHAuel4yYCBpbnN0ZWFkIG9mIG11bHRpcGx5aW5nIGBwLnhgIGJ5IHRoZVxuICAvLyBpbnZlcnNlIG9mIGBwLnpeMmBcbiAgcmV0dXJuIHAuZXFYVG9QKHIpO1xufTtcblxuRUMucHJvdG90eXBlLnJlY292ZXJQdWJLZXkgPSBmdW5jdGlvbihtc2csIHNpZ25hdHVyZSwgaiwgZW5jKSB7XG4gIGFzc2VydCgoMyAmIGopID09PSBqLCAnVGhlIHJlY292ZXJ5IHBhcmFtIGlzIG1vcmUgdGhhbiB0d28gYml0cycpO1xuICBzaWduYXR1cmUgPSBuZXcgU2lnbmF0dXJlKHNpZ25hdHVyZSwgZW5jKTtcblxuICB2YXIgbiA9IHRoaXMubjtcbiAgdmFyIGUgPSBuZXcgQk4obXNnKTtcbiAgdmFyIHIgPSBzaWduYXR1cmUucjtcbiAgdmFyIHMgPSBzaWduYXR1cmUucztcblxuICAvLyBBIHNldCBMU0Igc2lnbmlmaWVzIHRoYXQgdGhlIHktY29vcmRpbmF0ZSBpcyBvZGRcbiAgdmFyIGlzWU9kZCA9IGogJiAxO1xuICB2YXIgaXNTZWNvbmRLZXkgPSBqID4+IDE7XG4gIGlmIChyLmNtcCh0aGlzLmN1cnZlLnAudW1vZCh0aGlzLmN1cnZlLm4pKSA+PSAwICYmIGlzU2Vjb25kS2V5KVxuICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgc2VuY29uZCBrZXkgY2FuZGluYXRlJyk7XG5cbiAgLy8gMS4xLiBMZXQgeCA9IHIgKyBqbi5cbiAgaWYgKGlzU2Vjb25kS2V5KVxuICAgIHIgPSB0aGlzLmN1cnZlLnBvaW50RnJvbVgoci5hZGQodGhpcy5jdXJ2ZS5uKSwgaXNZT2RkKTtcbiAgZWxzZVxuICAgIHIgPSB0aGlzLmN1cnZlLnBvaW50RnJvbVgociwgaXNZT2RkKTtcblxuICB2YXIgckludiA9IHNpZ25hdHVyZS5yLmludm0obik7XG4gIHZhciBzMSA9IG4uc3ViKGUpLm11bChySW52KS51bW9kKG4pO1xuICB2YXIgczIgPSBzLm11bChySW52KS51bW9kKG4pO1xuXG4gIC8vIDEuNi4xIENvbXB1dGUgUSA9IHJeLTEgKHNSIC0gIGVHKVxuICAvLyAgICAgICAgICAgICAgIFEgPSByXi0xIChzUiArIC1lRylcbiAgcmV0dXJuIHRoaXMuZy5tdWxBZGQoczEsIHIsIHMyKTtcbn07XG5cbkVDLnByb3RvdHlwZS5nZXRLZXlSZWNvdmVyeVBhcmFtID0gZnVuY3Rpb24oZSwgc2lnbmF0dXJlLCBRLCBlbmMpIHtcbiAgc2lnbmF0dXJlID0gbmV3IFNpZ25hdHVyZShzaWduYXR1cmUsIGVuYyk7XG4gIGlmIChzaWduYXR1cmUucmVjb3ZlcnlQYXJhbSAhPT0gbnVsbClcbiAgICByZXR1cm4gc2lnbmF0dXJlLnJlY292ZXJ5UGFyYW07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICB2YXIgUXByaW1lO1xuICAgIHRyeSB7XG4gICAgICBRcHJpbWUgPSB0aGlzLnJlY292ZXJQdWJLZXkoZSwgc2lnbmF0dXJlLCBpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoUXByaW1lLmVxKFEpKVxuICAgICAgcmV0dXJuIGk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCB2YWxpZCByZWNvdmVyeSBmYWN0b3InKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIGFzc2VydCA9IHV0aWxzLmFzc2VydDtcblxuZnVuY3Rpb24gS2V5UGFpcihlYywgb3B0aW9ucykge1xuICB0aGlzLmVjID0gZWM7XG4gIHRoaXMucHJpdiA9IG51bGw7XG4gIHRoaXMucHViID0gbnVsbDtcblxuICAvLyBLZXlQYWlyKGVjLCB7IHByaXY6IC4uLiwgcHViOiAuLi4gfSlcbiAgaWYgKG9wdGlvbnMucHJpdilcbiAgICB0aGlzLl9pbXBvcnRQcml2YXRlKG9wdGlvbnMucHJpdiwgb3B0aW9ucy5wcml2RW5jKTtcbiAgaWYgKG9wdGlvbnMucHViKVxuICAgIHRoaXMuX2ltcG9ydFB1YmxpYyhvcHRpb25zLnB1Yiwgb3B0aW9ucy5wdWJFbmMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBLZXlQYWlyO1xuXG5LZXlQYWlyLmZyb21QdWJsaWMgPSBmdW5jdGlvbiBmcm9tUHVibGljKGVjLCBwdWIsIGVuYykge1xuICBpZiAocHViIGluc3RhbmNlb2YgS2V5UGFpcilcbiAgICByZXR1cm4gcHViO1xuXG4gIHJldHVybiBuZXcgS2V5UGFpcihlYywge1xuICAgIHB1YjogcHViLFxuICAgIHB1YkVuYzogZW5jXG4gIH0pO1xufTtcblxuS2V5UGFpci5mcm9tUHJpdmF0ZSA9IGZ1bmN0aW9uIGZyb21Qcml2YXRlKGVjLCBwcml2LCBlbmMpIHtcbiAgaWYgKHByaXYgaW5zdGFuY2VvZiBLZXlQYWlyKVxuICAgIHJldHVybiBwcml2O1xuXG4gIHJldHVybiBuZXcgS2V5UGFpcihlYywge1xuICAgIHByaXY6IHByaXYsXG4gICAgcHJpdkVuYzogZW5jXG4gIH0pO1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZSgpIHtcbiAgdmFyIHB1YiA9IHRoaXMuZ2V0UHVibGljKCk7XG5cbiAgaWYgKHB1Yi5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHsgcmVzdWx0OiBmYWxzZSwgcmVhc29uOiAnSW52YWxpZCBwdWJsaWMga2V5JyB9O1xuICBpZiAoIXB1Yi52YWxpZGF0ZSgpKVxuICAgIHJldHVybiB7IHJlc3VsdDogZmFsc2UsIHJlYXNvbjogJ1B1YmxpYyBrZXkgaXMgbm90IGEgcG9pbnQnIH07XG4gIGlmICghcHViLm11bCh0aGlzLmVjLmN1cnZlLm4pLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4geyByZXN1bHQ6IGZhbHNlLCByZWFzb246ICdQdWJsaWMga2V5ICogTiAhPSBPJyB9O1xuXG4gIHJldHVybiB7IHJlc3VsdDogdHJ1ZSwgcmVhc29uOiBudWxsIH07XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS5nZXRQdWJsaWMgPSBmdW5jdGlvbiBnZXRQdWJsaWMoY29tcGFjdCwgZW5jKSB7XG4gIC8vIGNvbXBhY3QgaXMgb3B0aW9uYWwgYXJndW1lbnRcbiAgaWYgKHR5cGVvZiBjb21wYWN0ID09PSAnc3RyaW5nJykge1xuICAgIGVuYyA9IGNvbXBhY3Q7XG4gICAgY29tcGFjdCA9IG51bGw7XG4gIH1cblxuICBpZiAoIXRoaXMucHViKVxuICAgIHRoaXMucHViID0gdGhpcy5lYy5nLm11bCh0aGlzLnByaXYpO1xuXG4gIGlmICghZW5jKVxuICAgIHJldHVybiB0aGlzLnB1YjtcblxuICByZXR1cm4gdGhpcy5wdWIuZW5jb2RlKGVuYywgY29tcGFjdCk7XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS5nZXRQcml2YXRlID0gZnVuY3Rpb24gZ2V0UHJpdmF0ZShlbmMpIHtcbiAgaWYgKGVuYyA9PT0gJ2hleCcpXG4gICAgcmV0dXJuIHRoaXMucHJpdi50b1N0cmluZygxNiwgMik7XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5wcml2O1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUuX2ltcG9ydFByaXZhdGUgPSBmdW5jdGlvbiBfaW1wb3J0UHJpdmF0ZShrZXksIGVuYykge1xuICB0aGlzLnByaXYgPSBuZXcgQk4oa2V5LCBlbmMgfHwgMTYpO1xuXG4gIC8vIEVuc3VyZSB0aGF0IHRoZSBwcml2IHdvbid0IGJlIGJpZ2dlciB0aGFuIG4sIG90aGVyd2lzZSB3ZSBtYXkgZmFpbFxuICAvLyBpbiBmaXhlZCBtdWx0aXBsaWNhdGlvbiBtZXRob2RcbiAgdGhpcy5wcml2ID0gdGhpcy5wcml2LnVtb2QodGhpcy5lYy5jdXJ2ZS5uKTtcbn07XG5cbktleVBhaXIucHJvdG90eXBlLl9pbXBvcnRQdWJsaWMgPSBmdW5jdGlvbiBfaW1wb3J0UHVibGljKGtleSwgZW5jKSB7XG4gIGlmIChrZXkueCB8fCBrZXkueSkge1xuICAgIC8vIE1vbnRnb21lcnkgcG9pbnRzIG9ubHkgaGF2ZSBhbiBgeGAgY29vcmRpbmF0ZS5cbiAgICAvLyBXZWllcnN0cmFzcy9FZHdhcmRzIHBvaW50cyBvbiB0aGUgb3RoZXIgaGFuZCBoYXZlIGJvdGggYHhgIGFuZFxuICAgIC8vIGB5YCBjb29yZGluYXRlcy5cbiAgICBpZiAodGhpcy5lYy5jdXJ2ZS50eXBlID09PSAnbW9udCcpIHtcbiAgICAgIGFzc2VydChrZXkueCwgJ05lZWQgeCBjb29yZGluYXRlJyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmVjLmN1cnZlLnR5cGUgPT09ICdzaG9ydCcgfHxcbiAgICAgICAgICAgICAgIHRoaXMuZWMuY3VydmUudHlwZSA9PT0gJ2Vkd2FyZHMnKSB7XG4gICAgICBhc3NlcnQoa2V5LnggJiYga2V5LnksICdOZWVkIGJvdGggeCBhbmQgeSBjb29yZGluYXRlJyk7XG4gICAgfVxuICAgIHRoaXMucHViID0gdGhpcy5lYy5jdXJ2ZS5wb2ludChrZXkueCwga2V5LnkpO1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLnB1YiA9IHRoaXMuZWMuY3VydmUuZGVjb2RlUG9pbnQoa2V5LCBlbmMpO1xufTtcblxuLy8gRUNESFxuS2V5UGFpci5wcm90b3R5cGUuZGVyaXZlID0gZnVuY3Rpb24gZGVyaXZlKHB1Yikge1xuICByZXR1cm4gcHViLm11bCh0aGlzLnByaXYpLmdldFgoKTtcbn07XG5cbi8vIEVDRFNBXG5LZXlQYWlyLnByb3RvdHlwZS5zaWduID0gZnVuY3Rpb24gc2lnbihtc2csIGVuYywgb3B0aW9ucykge1xuICByZXR1cm4gdGhpcy5lYy5zaWduKG1zZywgdGhpcywgZW5jLCBvcHRpb25zKTtcbn07XG5cbktleVBhaXIucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtc2csIHNpZ25hdHVyZSkge1xuICByZXR1cm4gdGhpcy5lYy52ZXJpZnkobXNnLCBzaWduYXR1cmUsIHRoaXMpO1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QoKSB7XG4gIHJldHVybiAnPEtleSBwcml2OiAnICsgKHRoaXMucHJpdiAmJiB0aGlzLnByaXYudG9TdHJpbmcoMTYsIDIpKSArXG4gICAgICAgICAnIHB1YjogJyArICh0aGlzLnB1YiAmJiB0aGlzLnB1Yi5pbnNwZWN0KCkpICsgJyA+Jztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgYXNzZXJ0ID0gdXRpbHMuYXNzZXJ0O1xuXG5mdW5jdGlvbiBTaWduYXR1cmUob3B0aW9ucywgZW5jKSB7XG4gIGlmIChvcHRpb25zIGluc3RhbmNlb2YgU2lnbmF0dXJlKVxuICAgIHJldHVybiBvcHRpb25zO1xuXG4gIGlmICh0aGlzLl9pbXBvcnRERVIob3B0aW9ucywgZW5jKSlcbiAgICByZXR1cm47XG5cbiAgYXNzZXJ0KG9wdGlvbnMuciAmJiBvcHRpb25zLnMsICdTaWduYXR1cmUgd2l0aG91dCByIG9yIHMnKTtcbiAgdGhpcy5yID0gbmV3IEJOKG9wdGlvbnMuciwgMTYpO1xuICB0aGlzLnMgPSBuZXcgQk4ob3B0aW9ucy5zLCAxNik7XG4gIGlmIChvcHRpb25zLnJlY292ZXJ5UGFyYW0gPT09IHVuZGVmaW5lZClcbiAgICB0aGlzLnJlY292ZXJ5UGFyYW0gPSBudWxsO1xuICBlbHNlXG4gICAgdGhpcy5yZWNvdmVyeVBhcmFtID0gb3B0aW9ucy5yZWNvdmVyeVBhcmFtO1xufVxubW9kdWxlLmV4cG9ydHMgPSBTaWduYXR1cmU7XG5cbmZ1bmN0aW9uIFBvc2l0aW9uKCkge1xuICB0aGlzLnBsYWNlID0gMDtcbn1cblxuZnVuY3Rpb24gZ2V0TGVuZ3RoKGJ1ZiwgcCkge1xuICB2YXIgaW5pdGlhbCA9IGJ1ZltwLnBsYWNlKytdO1xuICBpZiAoIShpbml0aWFsICYgMHg4MCkpIHtcbiAgICByZXR1cm4gaW5pdGlhbDtcbiAgfVxuICB2YXIgb2N0ZXRMZW4gPSBpbml0aWFsICYgMHhmO1xuICB2YXIgdmFsID0gMDtcbiAgZm9yICh2YXIgaSA9IDAsIG9mZiA9IHAucGxhY2U7IGkgPCBvY3RldExlbjsgaSsrLCBvZmYrKykge1xuICAgIHZhbCA8PD0gODtcbiAgICB2YWwgfD0gYnVmW29mZl07XG4gIH1cbiAgcC5wbGFjZSA9IG9mZjtcbiAgcmV0dXJuIHZhbDtcbn1cblxuZnVuY3Rpb24gcm1QYWRkaW5nKGJ1Zikge1xuICB2YXIgaSA9IDA7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoIC0gMTtcbiAgd2hpbGUgKCFidWZbaV0gJiYgIShidWZbaSArIDFdICYgMHg4MCkgJiYgaSA8IGxlbikge1xuICAgIGkrKztcbiAgfVxuICBpZiAoaSA9PT0gMCkge1xuICAgIHJldHVybiBidWY7XG4gIH1cbiAgcmV0dXJuIGJ1Zi5zbGljZShpKTtcbn1cblxuU2lnbmF0dXJlLnByb3RvdHlwZS5faW1wb3J0REVSID0gZnVuY3Rpb24gX2ltcG9ydERFUihkYXRhLCBlbmMpIHtcbiAgZGF0YSA9IHV0aWxzLnRvQXJyYXkoZGF0YSwgZW5jKTtcbiAgdmFyIHAgPSBuZXcgUG9zaXRpb24oKTtcbiAgaWYgKGRhdGFbcC5wbGFjZSsrXSAhPT0gMHgzMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGVuID0gZ2V0TGVuZ3RoKGRhdGEsIHApO1xuICBpZiAoKGxlbiArIHAucGxhY2UpICE9PSBkYXRhLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZGF0YVtwLnBsYWNlKytdICE9PSAweDAyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBybGVuID0gZ2V0TGVuZ3RoKGRhdGEsIHApO1xuICB2YXIgciA9IGRhdGEuc2xpY2UocC5wbGFjZSwgcmxlbiArIHAucGxhY2UpO1xuICBwLnBsYWNlICs9IHJsZW47XG4gIGlmIChkYXRhW3AucGxhY2UrK10gIT09IDB4MDIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHNsZW4gPSBnZXRMZW5ndGgoZGF0YSwgcCk7XG4gIGlmIChkYXRhLmxlbmd0aCAhPT0gc2xlbiArIHAucGxhY2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHMgPSBkYXRhLnNsaWNlKHAucGxhY2UsIHNsZW4gKyBwLnBsYWNlKTtcbiAgaWYgKHJbMF0gPT09IDAgJiYgKHJbMV0gJiAweDgwKSkge1xuICAgIHIgPSByLnNsaWNlKDEpO1xuICB9XG4gIGlmIChzWzBdID09PSAwICYmIChzWzFdICYgMHg4MCkpIHtcbiAgICBzID0gcy5zbGljZSgxKTtcbiAgfVxuXG4gIHRoaXMuciA9IG5ldyBCTihyKTtcbiAgdGhpcy5zID0gbmV3IEJOKHMpO1xuICB0aGlzLnJlY292ZXJ5UGFyYW0gPSBudWxsO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gY29uc3RydWN0TGVuZ3RoKGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPCAweDgwKSB7XG4gICAgYXJyLnB1c2gobGVuKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG9jdGV0cyA9IDEgKyAoTWF0aC5sb2cobGVuKSAvIE1hdGguTE4yID4+PiAzKTtcbiAgYXJyLnB1c2gob2N0ZXRzIHwgMHg4MCk7XG4gIHdoaWxlICgtLW9jdGV0cykge1xuICAgIGFyci5wdXNoKChsZW4gPj4+IChvY3RldHMgPDwgMykpICYgMHhmZik7XG4gIH1cbiAgYXJyLnB1c2gobGVuKTtcbn1cblxuU2lnbmF0dXJlLnByb3RvdHlwZS50b0RFUiA9IGZ1bmN0aW9uIHRvREVSKGVuYykge1xuICB2YXIgciA9IHRoaXMuci50b0FycmF5KCk7XG4gIHZhciBzID0gdGhpcy5zLnRvQXJyYXkoKTtcblxuICAvLyBQYWQgdmFsdWVzXG4gIGlmIChyWzBdICYgMHg4MClcbiAgICByID0gWyAwIF0uY29uY2F0KHIpO1xuICAvLyBQYWQgdmFsdWVzXG4gIGlmIChzWzBdICYgMHg4MClcbiAgICBzID0gWyAwIF0uY29uY2F0KHMpO1xuXG4gIHIgPSBybVBhZGRpbmcocik7XG4gIHMgPSBybVBhZGRpbmcocyk7XG5cbiAgd2hpbGUgKCFzWzBdICYmICEoc1sxXSAmIDB4ODApKSB7XG4gICAgcyA9IHMuc2xpY2UoMSk7XG4gIH1cbiAgdmFyIGFyciA9IFsgMHgwMiBdO1xuICBjb25zdHJ1Y3RMZW5ndGgoYXJyLCByLmxlbmd0aCk7XG4gIGFyciA9IGFyci5jb25jYXQocik7XG4gIGFyci5wdXNoKDB4MDIpO1xuICBjb25zdHJ1Y3RMZW5ndGgoYXJyLCBzLmxlbmd0aCk7XG4gIHZhciBiYWNrSGFsZiA9IGFyci5jb25jYXQocyk7XG4gIHZhciByZXMgPSBbIDB4MzAgXTtcbiAgY29uc3RydWN0TGVuZ3RoKHJlcywgYmFja0hhbGYubGVuZ3RoKTtcbiAgcmVzID0gcmVzLmNvbmNhdChiYWNrSGFsZik7XG4gIHJldHVybiB1dGlscy5lbmNvZGUocmVzLCBlbmMpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhc2ggPSByZXF1aXJlKCdoYXNoLmpzJyk7XG52YXIgY3VydmVzID0gcmVxdWlyZSgnLi4vY3VydmVzJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIGFzc2VydCA9IHV0aWxzLmFzc2VydDtcbnZhciBwYXJzZUJ5dGVzID0gdXRpbHMucGFyc2VCeXRlcztcbnZhciBLZXlQYWlyID0gcmVxdWlyZSgnLi9rZXknKTtcbnZhciBTaWduYXR1cmUgPSByZXF1aXJlKCcuL3NpZ25hdHVyZScpO1xuXG5mdW5jdGlvbiBFRERTQShjdXJ2ZSkge1xuICBhc3NlcnQoY3VydmUgPT09ICdlZDI1NTE5JywgJ29ubHkgdGVzdGVkIHdpdGggZWQyNTUxOSBzbyBmYXInKTtcblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRUREU0EpKVxuICAgIHJldHVybiBuZXcgRUREU0EoY3VydmUpO1xuXG4gIHZhciBjdXJ2ZSA9IGN1cnZlc1tjdXJ2ZV0uY3VydmU7XG4gIHRoaXMuY3VydmUgPSBjdXJ2ZTtcbiAgdGhpcy5nID0gY3VydmUuZztcbiAgdGhpcy5nLnByZWNvbXB1dGUoY3VydmUubi5iaXRMZW5ndGgoKSArIDEpO1xuXG4gIHRoaXMucG9pbnRDbGFzcyA9IGN1cnZlLnBvaW50KCkuY29uc3RydWN0b3I7XG4gIHRoaXMuZW5jb2RpbmdMZW5ndGggPSBNYXRoLmNlaWwoY3VydmUubi5iaXRMZW5ndGgoKSAvIDgpO1xuICB0aGlzLmhhc2ggPSBoYXNoLnNoYTUxMjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBFRERTQTtcblxuLyoqXG4qIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBtZXNzYWdlIC0gbWVzc2FnZSBieXRlc1xuKiBAcGFyYW0ge0FycmF5fFN0cmluZ3xLZXlQYWlyfSBzZWNyZXQgLSBzZWNyZXQgYnl0ZXMgb3IgYSBrZXlwYWlyXG4qIEByZXR1cm5zIHtTaWduYXR1cmV9IC0gc2lnbmF0dXJlXG4qL1xuRUREU0EucHJvdG90eXBlLnNpZ24gPSBmdW5jdGlvbiBzaWduKG1lc3NhZ2UsIHNlY3JldCkge1xuICBtZXNzYWdlID0gcGFyc2VCeXRlcyhtZXNzYWdlKTtcbiAgdmFyIGtleSA9IHRoaXMua2V5RnJvbVNlY3JldChzZWNyZXQpO1xuICB2YXIgciA9IHRoaXMuaGFzaEludChrZXkubWVzc2FnZVByZWZpeCgpLCBtZXNzYWdlKTtcbiAgdmFyIFIgPSB0aGlzLmcubXVsKHIpO1xuICB2YXIgUmVuY29kZWQgPSB0aGlzLmVuY29kZVBvaW50KFIpO1xuICB2YXIgc18gPSB0aGlzLmhhc2hJbnQoUmVuY29kZWQsIGtleS5wdWJCeXRlcygpLCBtZXNzYWdlKVxuICAgICAgICAgICAgICAgLm11bChrZXkucHJpdigpKTtcbiAgdmFyIFMgPSByLmFkZChzXykudW1vZCh0aGlzLmN1cnZlLm4pO1xuICByZXR1cm4gdGhpcy5tYWtlU2lnbmF0dXJlKHsgUjogUiwgUzogUywgUmVuY29kZWQ6IFJlbmNvZGVkIH0pO1xufTtcblxuLyoqXG4qIEBwYXJhbSB7QXJyYXl9IG1lc3NhZ2UgLSBtZXNzYWdlIGJ5dGVzXG4qIEBwYXJhbSB7QXJyYXl8U3RyaW5nfFNpZ25hdHVyZX0gc2lnIC0gc2lnIGJ5dGVzXG4qIEBwYXJhbSB7QXJyYXl8U3RyaW5nfFBvaW50fEtleVBhaXJ9IHB1YiAtIHB1YmxpYyBrZXlcbiogQHJldHVybnMge0Jvb2xlYW59IC0gdHJ1ZSBpZiBwdWJsaWMga2V5IG1hdGNoZXMgc2lnIG9mIG1lc3NhZ2VcbiovXG5FRERTQS5wcm90b3R5cGUudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UsIHNpZywgcHViKSB7XG4gIG1lc3NhZ2UgPSBwYXJzZUJ5dGVzKG1lc3NhZ2UpO1xuICBzaWcgPSB0aGlzLm1ha2VTaWduYXR1cmUoc2lnKTtcbiAgdmFyIGtleSA9IHRoaXMua2V5RnJvbVB1YmxpYyhwdWIpO1xuICB2YXIgaCA9IHRoaXMuaGFzaEludChzaWcuUmVuY29kZWQoKSwga2V5LnB1YkJ5dGVzKCksIG1lc3NhZ2UpO1xuICB2YXIgU0cgPSB0aGlzLmcubXVsKHNpZy5TKCkpO1xuICB2YXIgUnBsdXNBaCA9IHNpZy5SKCkuYWRkKGtleS5wdWIoKS5tdWwoaCkpO1xuICByZXR1cm4gUnBsdXNBaC5lcShTRyk7XG59O1xuXG5FRERTQS5wcm90b3R5cGUuaGFzaEludCA9IGZ1bmN0aW9uIGhhc2hJbnQoKSB7XG4gIHZhciBoYXNoID0gdGhpcy5oYXNoKCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxuICAgIGhhc2gudXBkYXRlKGFyZ3VtZW50c1tpXSk7XG4gIHJldHVybiB1dGlscy5pbnRGcm9tTEUoaGFzaC5kaWdlc3QoKSkudW1vZCh0aGlzLmN1cnZlLm4pO1xufTtcblxuRUREU0EucHJvdG90eXBlLmtleUZyb21QdWJsaWMgPSBmdW5jdGlvbiBrZXlGcm9tUHVibGljKHB1Yikge1xuICByZXR1cm4gS2V5UGFpci5mcm9tUHVibGljKHRoaXMsIHB1Yik7XG59O1xuXG5FRERTQS5wcm90b3R5cGUua2V5RnJvbVNlY3JldCA9IGZ1bmN0aW9uIGtleUZyb21TZWNyZXQoc2VjcmV0KSB7XG4gIHJldHVybiBLZXlQYWlyLmZyb21TZWNyZXQodGhpcywgc2VjcmV0KTtcbn07XG5cbkVERFNBLnByb3RvdHlwZS5tYWtlU2lnbmF0dXJlID0gZnVuY3Rpb24gbWFrZVNpZ25hdHVyZShzaWcpIHtcbiAgaWYgKHNpZyBpbnN0YW5jZW9mIFNpZ25hdHVyZSlcbiAgICByZXR1cm4gc2lnO1xuICByZXR1cm4gbmV3IFNpZ25hdHVyZSh0aGlzLCBzaWcpO1xufTtcblxuLyoqXG4qICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LWpvc2Vmc3Nvbi1lZGRzYS1lZDI1NTE5LTAzI3NlY3Rpb24tNS4yXG4qXG4qIEVERFNBIGRlZmluZXMgbWV0aG9kcyBmb3IgZW5jb2RpbmcgYW5kIGRlY29kaW5nIHBvaW50cyBhbmQgaW50ZWdlcnMuIFRoZXNlIGFyZVxuKiBoZWxwZXIgY29udmVuaWVuY2UgbWV0aG9kcywgdGhhdCBwYXNzIGFsb25nIHRvIHV0aWxpdHkgZnVuY3Rpb25zIGltcGxpZWRcbiogcGFyYW1ldGVycy5cbipcbiovXG5FRERTQS5wcm90b3R5cGUuZW5jb2RlUG9pbnQgPSBmdW5jdGlvbiBlbmNvZGVQb2ludChwb2ludCkge1xuICB2YXIgZW5jID0gcG9pbnQuZ2V0WSgpLnRvQXJyYXkoJ2xlJywgdGhpcy5lbmNvZGluZ0xlbmd0aCk7XG4gIGVuY1t0aGlzLmVuY29kaW5nTGVuZ3RoIC0gMV0gfD0gcG9pbnQuZ2V0WCgpLmlzT2RkKCkgPyAweDgwIDogMDtcbiAgcmV0dXJuIGVuYztcbn07XG5cbkVERFNBLnByb3RvdHlwZS5kZWNvZGVQb2ludCA9IGZ1bmN0aW9uIGRlY29kZVBvaW50KGJ5dGVzKSB7XG4gIGJ5dGVzID0gdXRpbHMucGFyc2VCeXRlcyhieXRlcyk7XG5cbiAgdmFyIGxhc3RJeCA9IGJ5dGVzLmxlbmd0aCAtIDE7XG4gIHZhciBub3JtZWQgPSBieXRlcy5zbGljZSgwLCBsYXN0SXgpLmNvbmNhdChieXRlc1tsYXN0SXhdICYgfjB4ODApO1xuICB2YXIgeElzT2RkID0gKGJ5dGVzW2xhc3RJeF0gJiAweDgwKSAhPT0gMDtcblxuICB2YXIgeSA9IHV0aWxzLmludEZyb21MRShub3JtZWQpO1xuICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludEZyb21ZKHksIHhJc09kZCk7XG59O1xuXG5FRERTQS5wcm90b3R5cGUuZW5jb2RlSW50ID0gZnVuY3Rpb24gZW5jb2RlSW50KG51bSkge1xuICByZXR1cm4gbnVtLnRvQXJyYXkoJ2xlJywgdGhpcy5lbmNvZGluZ0xlbmd0aCk7XG59O1xuXG5FRERTQS5wcm90b3R5cGUuZGVjb2RlSW50ID0gZnVuY3Rpb24gZGVjb2RlSW50KGJ5dGVzKSB7XG4gIHJldHVybiB1dGlscy5pbnRGcm9tTEUoYnl0ZXMpO1xufTtcblxuRUREU0EucHJvdG90eXBlLmlzUG9pbnQgPSBmdW5jdGlvbiBpc1BvaW50KHZhbCkge1xuICByZXR1cm4gdmFsIGluc3RhbmNlb2YgdGhpcy5wb2ludENsYXNzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBhc3NlcnQgPSB1dGlscy5hc3NlcnQ7XG52YXIgcGFyc2VCeXRlcyA9IHV0aWxzLnBhcnNlQnl0ZXM7XG52YXIgY2FjaGVkUHJvcGVydHkgPSB1dGlscy5jYWNoZWRQcm9wZXJ0eTtcblxuLyoqXG4qIEBwYXJhbSB7RUREU0F9IGVkZHNhIC0gaW5zdGFuY2VcbiogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIHB1YmxpYy9wcml2YXRlIGtleSBwYXJhbWV0ZXJzXG4qXG4qIEBwYXJhbSB7QXJyYXk8Qnl0ZT59IFtwYXJhbXMuc2VjcmV0XSAtIHNlY3JldCBzZWVkIGJ5dGVzXG4qIEBwYXJhbSB7UG9pbnR9IFtwYXJhbXMucHViXSAtIHB1YmxpYyBrZXkgcG9pbnQgKGFrYSBgQWAgaW4gZWRkc2EgdGVybXMpXG4qIEBwYXJhbSB7QXJyYXk8Qnl0ZT59IFtwYXJhbXMucHViXSAtIHB1YmxpYyBrZXkgcG9pbnQgZW5jb2RlZCBhcyBieXRlc1xuKlxuKi9cbmZ1bmN0aW9uIEtleVBhaXIoZWRkc2EsIHBhcmFtcykge1xuICB0aGlzLmVkZHNhID0gZWRkc2E7XG4gIHRoaXMuX3NlY3JldCA9IHBhcnNlQnl0ZXMocGFyYW1zLnNlY3JldCk7XG4gIGlmIChlZGRzYS5pc1BvaW50KHBhcmFtcy5wdWIpKVxuICAgIHRoaXMuX3B1YiA9IHBhcmFtcy5wdWI7XG4gIGVsc2VcbiAgICB0aGlzLl9wdWJCeXRlcyA9IHBhcnNlQnl0ZXMocGFyYW1zLnB1Yik7XG59XG5cbktleVBhaXIuZnJvbVB1YmxpYyA9IGZ1bmN0aW9uIGZyb21QdWJsaWMoZWRkc2EsIHB1Yikge1xuICBpZiAocHViIGluc3RhbmNlb2YgS2V5UGFpcilcbiAgICByZXR1cm4gcHViO1xuICByZXR1cm4gbmV3IEtleVBhaXIoZWRkc2EsIHsgcHViOiBwdWIgfSk7XG59O1xuXG5LZXlQYWlyLmZyb21TZWNyZXQgPSBmdW5jdGlvbiBmcm9tU2VjcmV0KGVkZHNhLCBzZWNyZXQpIHtcbiAgaWYgKHNlY3JldCBpbnN0YW5jZW9mIEtleVBhaXIpXG4gICAgcmV0dXJuIHNlY3JldDtcbiAgcmV0dXJuIG5ldyBLZXlQYWlyKGVkZHNhLCB7IHNlY3JldDogc2VjcmV0IH0pO1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUuc2VjcmV0ID0gZnVuY3Rpb24gc2VjcmV0KCkge1xuICByZXR1cm4gdGhpcy5fc2VjcmV0O1xufTtcblxuY2FjaGVkUHJvcGVydHkoS2V5UGFpciwgJ3B1YkJ5dGVzJywgZnVuY3Rpb24gcHViQnl0ZXMoKSB7XG4gIHJldHVybiB0aGlzLmVkZHNhLmVuY29kZVBvaW50KHRoaXMucHViKCkpO1xufSk7XG5cbmNhY2hlZFByb3BlcnR5KEtleVBhaXIsICdwdWInLCBmdW5jdGlvbiBwdWIoKSB7XG4gIGlmICh0aGlzLl9wdWJCeXRlcylcbiAgICByZXR1cm4gdGhpcy5lZGRzYS5kZWNvZGVQb2ludCh0aGlzLl9wdWJCeXRlcyk7XG4gIHJldHVybiB0aGlzLmVkZHNhLmcubXVsKHRoaXMucHJpdigpKTtcbn0pO1xuXG5jYWNoZWRQcm9wZXJ0eShLZXlQYWlyLCAncHJpdkJ5dGVzJywgZnVuY3Rpb24gcHJpdkJ5dGVzKCkge1xuICB2YXIgZWRkc2EgPSB0aGlzLmVkZHNhO1xuICB2YXIgaGFzaCA9IHRoaXMuaGFzaCgpO1xuICB2YXIgbGFzdEl4ID0gZWRkc2EuZW5jb2RpbmdMZW5ndGggLSAxO1xuXG4gIHZhciBhID0gaGFzaC5zbGljZSgwLCBlZGRzYS5lbmNvZGluZ0xlbmd0aCk7XG4gIGFbMF0gJj0gMjQ4O1xuICBhW2xhc3RJeF0gJj0gMTI3O1xuICBhW2xhc3RJeF0gfD0gNjQ7XG5cbiAgcmV0dXJuIGE7XG59KTtcblxuY2FjaGVkUHJvcGVydHkoS2V5UGFpciwgJ3ByaXYnLCBmdW5jdGlvbiBwcml2KCkge1xuICByZXR1cm4gdGhpcy5lZGRzYS5kZWNvZGVJbnQodGhpcy5wcml2Qnl0ZXMoKSk7XG59KTtcblxuY2FjaGVkUHJvcGVydHkoS2V5UGFpciwgJ2hhc2gnLCBmdW5jdGlvbiBoYXNoKCkge1xuICByZXR1cm4gdGhpcy5lZGRzYS5oYXNoKCkudXBkYXRlKHRoaXMuc2VjcmV0KCkpLmRpZ2VzdCgpO1xufSk7XG5cbmNhY2hlZFByb3BlcnR5KEtleVBhaXIsICdtZXNzYWdlUHJlZml4JywgZnVuY3Rpb24gbWVzc2FnZVByZWZpeCgpIHtcbiAgcmV0dXJuIHRoaXMuaGFzaCgpLnNsaWNlKHRoaXMuZWRkc2EuZW5jb2RpbmdMZW5ndGgpO1xufSk7XG5cbktleVBhaXIucHJvdG90eXBlLnNpZ24gPSBmdW5jdGlvbiBzaWduKG1lc3NhZ2UpIHtcbiAgYXNzZXJ0KHRoaXMuX3NlY3JldCwgJ0tleVBhaXIgY2FuIG9ubHkgdmVyaWZ5Jyk7XG4gIHJldHVybiB0aGlzLmVkZHNhLnNpZ24obWVzc2FnZSwgdGhpcyk7XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSwgc2lnKSB7XG4gIHJldHVybiB0aGlzLmVkZHNhLnZlcmlmeShtZXNzYWdlLCBzaWcsIHRoaXMpO1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUuZ2V0U2VjcmV0ID0gZnVuY3Rpb24gZ2V0U2VjcmV0KGVuYykge1xuICBhc3NlcnQodGhpcy5fc2VjcmV0LCAnS2V5UGFpciBpcyBwdWJsaWMgb25seScpO1xuICByZXR1cm4gdXRpbHMuZW5jb2RlKHRoaXMuc2VjcmV0KCksIGVuYyk7XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS5nZXRQdWJsaWMgPSBmdW5jdGlvbiBnZXRQdWJsaWMoZW5jKSB7XG4gIHJldHVybiB1dGlscy5lbmNvZGUodGhpcy5wdWJCeXRlcygpLCBlbmMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBLZXlQYWlyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBhc3NlcnQgPSB1dGlscy5hc3NlcnQ7XG52YXIgY2FjaGVkUHJvcGVydHkgPSB1dGlscy5jYWNoZWRQcm9wZXJ0eTtcbnZhciBwYXJzZUJ5dGVzID0gdXRpbHMucGFyc2VCeXRlcztcblxuLyoqXG4qIEBwYXJhbSB7RUREU0F9IGVkZHNhIC0gZWRkc2EgaW5zdGFuY2VcbiogQHBhcmFtIHtBcnJheTxCeXRlcz58T2JqZWN0fSBzaWcgLVxuKiBAcGFyYW0ge0FycmF5PEJ5dGVzPnxQb2ludH0gW3NpZy5SXSAtIFIgcG9pbnQgYXMgUG9pbnQgb3IgYnl0ZXNcbiogQHBhcmFtIHtBcnJheTxCeXRlcz58Ym59IFtzaWcuU10gLSBTIHNjYWxhciBhcyBibiBvciBieXRlc1xuKiBAcGFyYW0ge0FycmF5PEJ5dGVzPn0gW3NpZy5SZW5jb2RlZF0gLSBSIHBvaW50IGVuY29kZWRcbiogQHBhcmFtIHtBcnJheTxCeXRlcz59IFtzaWcuU2VuY29kZWRdIC0gUyBzY2FsYXIgZW5jb2RlZFxuKi9cbmZ1bmN0aW9uIFNpZ25hdHVyZShlZGRzYSwgc2lnKSB7XG4gIHRoaXMuZWRkc2EgPSBlZGRzYTtcblxuICBpZiAodHlwZW9mIHNpZyAhPT0gJ29iamVjdCcpXG4gICAgc2lnID0gcGFyc2VCeXRlcyhzaWcpO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KHNpZykpIHtcbiAgICBzaWcgPSB7XG4gICAgICBSOiBzaWcuc2xpY2UoMCwgZWRkc2EuZW5jb2RpbmdMZW5ndGgpLFxuICAgICAgUzogc2lnLnNsaWNlKGVkZHNhLmVuY29kaW5nTGVuZ3RoKVxuICAgIH07XG4gIH1cblxuICBhc3NlcnQoc2lnLlIgJiYgc2lnLlMsICdTaWduYXR1cmUgd2l0aG91dCBSIG9yIFMnKTtcblxuICBpZiAoZWRkc2EuaXNQb2ludChzaWcuUikpXG4gICAgdGhpcy5fUiA9IHNpZy5SO1xuICBpZiAoc2lnLlMgaW5zdGFuY2VvZiBCTilcbiAgICB0aGlzLl9TID0gc2lnLlM7XG5cbiAgdGhpcy5fUmVuY29kZWQgPSBBcnJheS5pc0FycmF5KHNpZy5SKSA/IHNpZy5SIDogc2lnLlJlbmNvZGVkO1xuICB0aGlzLl9TZW5jb2RlZCA9IEFycmF5LmlzQXJyYXkoc2lnLlMpID8gc2lnLlMgOiBzaWcuU2VuY29kZWQ7XG59XG5cbmNhY2hlZFByb3BlcnR5KFNpZ25hdHVyZSwgJ1MnLCBmdW5jdGlvbiBTKCkge1xuICByZXR1cm4gdGhpcy5lZGRzYS5kZWNvZGVJbnQodGhpcy5TZW5jb2RlZCgpKTtcbn0pO1xuXG5jYWNoZWRQcm9wZXJ0eShTaWduYXR1cmUsICdSJywgZnVuY3Rpb24gUigpIHtcbiAgcmV0dXJuIHRoaXMuZWRkc2EuZGVjb2RlUG9pbnQodGhpcy5SZW5jb2RlZCgpKTtcbn0pO1xuXG5jYWNoZWRQcm9wZXJ0eShTaWduYXR1cmUsICdSZW5jb2RlZCcsIGZ1bmN0aW9uIFJlbmNvZGVkKCkge1xuICByZXR1cm4gdGhpcy5lZGRzYS5lbmNvZGVQb2ludCh0aGlzLlIoKSk7XG59KTtcblxuY2FjaGVkUHJvcGVydHkoU2lnbmF0dXJlLCAnU2VuY29kZWQnLCBmdW5jdGlvbiBTZW5jb2RlZCgpIHtcbiAgcmV0dXJuIHRoaXMuZWRkc2EuZW5jb2RlSW50KHRoaXMuUygpKTtcbn0pO1xuXG5TaWduYXR1cmUucHJvdG90eXBlLnRvQnl0ZXMgPSBmdW5jdGlvbiB0b0J5dGVzKCkge1xuICByZXR1cm4gdGhpcy5SZW5jb2RlZCgpLmNvbmNhdCh0aGlzLlNlbmNvZGVkKCkpO1xufTtcblxuU2lnbmF0dXJlLnByb3RvdHlwZS50b0hleCA9IGZ1bmN0aW9uIHRvSGV4KCkge1xuICByZXR1cm4gdXRpbHMuZW5jb2RlKHRoaXMudG9CeXRlcygpLCAnaGV4JykudG9VcHBlckNhc2UoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2lnbmF0dXJlO1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRvdWJsZXM6IHtcbiAgICBzdGVwOiA0LFxuICAgIHBvaW50czogW1xuICAgICAgW1xuICAgICAgICAnZTYwZmNlOTNiNTllOWVjNTMwMTFhYWJjMjFjMjNlOTdiMmEzMTM2OWI4N2E1YWU5YzQ0ZWU4OWUyYTZkZWMwYScsXG4gICAgICAgICdmN2UzNTA3Mzk5ZTU5NTkyOWRiOTlmMzRmNTc5MzcxMDEyOTY4OTFlNDRkMjNmMGJlMWYzMmNjZTY5NjE2ODIxJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzgyODIyNjMyMTJjNjA5ZDllYTJhNmUzZTE3MmRlMjM4ZDhjMzljYWJkNWFjMWNhMTA2NDZlMjNmZDVmNTE1MDgnLFxuICAgICAgICAnMTFmOGE4MDk4NTU3ZGZlNDVlODI1NmU4MzBiNjBhY2U2MmQ2MTNhYzJmN2IxN2JlZDMxYjZlYWZmNmUyNmNhZidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxNzVlMTU5ZjcyOGI4NjVhNzJmOTljYzZjNmZjODQ2ZGUwYjkzODMzZmQyMjIyZWQ3M2ZjZTViNTUxZTViNzM5JyxcbiAgICAgICAgJ2QzNTA2ZTBkOWUzYzc5ZWJhNGVmOTdhNTFmZjcxZjVlYWNiNTk1NWFkZDI0MzQ1YzZlZmE2ZmZlZTlmZWQ2OTUnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzYzZDkwZDQ0N2IwMGM5Yzk5Y2VhYzA1YjYyNjJlZTA1MzQ0MWM3ZTU1NTUyZmZlNTI2YmFkOGY4M2ZmNDY0MCcsXG4gICAgICAgICc0ZTI3M2FkZmM3MzIyMjE5NTNiNDQ1Mzk3ZjMzNjMxNDViOWE4OTAwODE5OWVjYjYyMDAzYzdmM2JlZTlkZTknXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOGI0YjVmMTY1ZGYzYzJiZThjNjI0NGI1Yjc0NTYzODg0M2U0YTc4MWExNWJjZDFiNjlmNzlhNTVkZmZkZjgwYycsXG4gICAgICAgICc0YWFkMGE2ZjY4ZDMwOGI0YjNmYmQ3ODEzYWIwZGEwNGY5ZTMzNjU0NjE2MmVlNTZiM2VmZjBjNjVmZDRmZDM2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzcyM2NiYWE2ZTVkYjk5NmQ2YmY3NzFjMDBiZDU0OGM3YjcwMGRiZmZhNmMwZTc3YmNiNjExNTkyNTIzMmZjZGEnLFxuICAgICAgICAnOTZlODY3YjU1OTVjYzQ5OGE5MjExMzc0ODg4MjRkNmUyNjYwYTA2NTM3Nzk0OTQ4MDFkYzA2OWQ5ZWIzOWY1ZidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlZWJmYTRkNDkzYmViZjk4YmE1ZmVlYzgxMmMyZDNiNTA5NDc5NjEyMzdhOTE5ODM5YTUzM2VjYTBlN2RkN2ZhJyxcbiAgICAgICAgJzVkOWE4Y2EzOTcwZWYwZjI2OWVlN2VkYWYxNzgwODlkOWFlNGNkYzNhNzExZjcxMmRkZmQ0ZmRhZTFkZTg5OTknXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMTAwZjQ0ZGE2OTZlNzE2NzI3OTFkMGEwOWI3YmRlNDU5ZjEyMTVhMjliM2MwM2JmZWZkNzgzNWIzOWE0OGRiMCcsXG4gICAgICAgICdjZGQ5ZTEzMTkyYTAwYjc3MmVjOGYzMzAwYzA5MDY2NmI3ZmY0YTE4ZmY1MTk1YWMwZmJkNWNkNjJiYzY1YTA5J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2UxMDMxYmUyNjJjN2VkMWIxZGM5MjI3YTRhMDRjMDE3YTc3ZjhkNDQ2NGYzYjM4NTJjOGFjZGU2ZTUzNGZkMmQnLFxuICAgICAgICAnOWQ3MDYxOTI4OTQwNDA1ZTZiYjZhNDE3NjU5NzUzNWFmMjkyZGQ0MTllMWNlZDc5YTQ0ZjE4ZjI5NDU2YTAwZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdmZWVhNmNhZTQ2ZDU1YjUzMGFjMjgzOWYxNDNiZDdlYzVjZjhiMjY2YTQxZDZhZjUyZDVlNjg4ZDkwOTQ2OTZkJyxcbiAgICAgICAgJ2U1N2M2YjZjOTdkY2UxYmFiMDZlNGUxMmJmM2VjZDVjOTgxYzg5NTdjYzQxNDQyZDMxNTVkZWJmMTgwOTAwODgnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZGE2N2E5MWQ5MTA0OWNkY2IzNjdiZTRiZTZmZmNhM2NmZWVkNjU3ZDgwODU4M2RlMzNmYTk3OGJjMWVjNmNiMScsXG4gICAgICAgICc5YmFjYWEzNTQ4MTY0MmJjNDFmNDYzZjdlYzk3ODBlNWRlYzdhZGM1MDhmNzQwYTE3ZTllYThlMjdhNjhiZTFkJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzUzOTA0ZmFhMGIzMzRjZGRhNmUwMDA5MzVlZjIyMTUxZWMwOGQwZjdiYjExMDY5ZjU3NTQ1Y2NjMWEzN2I3YzAnLFxuICAgICAgICAnNWJjMDg3ZDBiYzgwMTA2ZDg4YzllY2NhYzIwZDNjMWMxMzk5OTk4MWUxNDQzNDY5OWRjYjA5NmIwMjI3NzFjOCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4ZTdiY2QwYmQzNTk4M2E3NzE5Y2NhNzc2NGNhOTA2Nzc5YjUzYTA0M2E5YjhiY2FlZmY5NTlmNDNhZDg2MDQ3JyxcbiAgICAgICAgJzEwYjc3NzBiMmEzZGE0YjM5NDAzMTA0MjBjYTk1MTQ1NzllODhlMmU0N2ZkNjhiM2VhMTAwNDdlODQ2MDM3MmEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzg1ZWVkMzRjMWNkZmYyMWU2ZDA4MTg2ODliODFiZGU3MWE3ZjRmMTgzOTdlNjY5MGE4NDFlMTU5OWM0Mzg2MicsXG4gICAgICAgICcyODNiZWJjM2U4ZWEyM2Y1NjcwMWRlMTllOWViZjQ1NzZiMzA0ZWVjMjA4NmRjOGNjMDQ1OGZlNTU0MmU1NDUzJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzZmOWQ5YjgwM2VjZjE5MTYzN2M3M2E0NDEzZGZhMTgwZmRkZjg0YTU5NDdmYmM5YzYwNmVkODZjM2ZhYzNhNycsXG4gICAgICAgICc3YzgwYzY4ZTYwMzA1OWJhNjliOGUyYTMwZTQ1YzRkNDdlYTRkZDJmNWMyODEwMDJkODY4OTA2MDNhODQyMTYwJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzMzMjJkNDAxMjQzYzRlMjU4MmEyMTQ3YzEwNGQ2ZWNiZjc3NGQxNjNkYjBmNWU1MzEzYjdlMGU3NDJkMGU2YmQnLFxuICAgICAgICAnNTZlNzA3OTdlOTY2NGVmNWJmYjAxOWJjNGRkYWY5YjcyODA1ZjYzZWEyODczYWY2MjRmM2EyZTk2YzI4YjJhMCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4NTY3MmM3ZDJkZTBiN2RhMmJkMTc3MGQ4OTY2NTg2ODc0MWIzZjlhZjc2NDMzOTc3MjFkNzRkMjgxMzRhYjgzJyxcbiAgICAgICAgJzdjNDgxYjliNWI0M2IyZWI2Mzc0MDQ5YmZhNjJjMmU1ZTc3ZjE3ZmNjNTI5OGY0NGM4ZTMwOTRmNzkwMzEzYTYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOTQ4YmY4MDliMTk4OGE0NmIwNmM5ZjE5MTk0MTNiMTBmOTIyNmM2MGY2Njg4MzJmZmQ5NTlhZjYwYzgyYTBhJyxcbiAgICAgICAgJzUzYTU2Mjg1NmRjYjY2NDZkYzZiNzRjNWQxYzM0MThjNmQ0ZGZmMDhjOTdjZDJiZWQ0Y2I3Zjg4ZDhjOGU1ODknXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNjI2MGNlN2Y0NjE4MDFjMzRmMDY3Y2UwZjAyODczYThmMWIwZTQ0ZGZjNjk3NTJhY2NlY2Q4MTlmMzhmZDhlOCcsXG4gICAgICAgICdiYzJkYTgyYjZmYTViNTcxYTdmMDkwNDk3NzZhMWVmN2VjZDI5MjIzODA1MWMxOThjMWE4NGU5NWIyYjRhZTE3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2U1MDM3ZGUwYWZjMWQ4ZDQzZDgzNDg0MTRiYmY0MTAzMDQzZWM4ZjU3NWJmZGM0MzI5NTNjYzhkMjAzN2ZhMmQnLFxuICAgICAgICAnNDU3MTUzNGJhYTk0ZDNiNWY5Zjk4ZDA5ZmI5OTBiZGRiZDVmNWIwM2VjNDgxZjEwZTBlNWRjODQxZDc1NWJkYSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlMDYzNzJiMGY0YTIwN2FkZjVlYTkwNWU4ZjE3NzFiNGU3ZThkYmQxYzZhNmM1YjcyNTg2NmEwYWU0ZmNlNzI1JyxcbiAgICAgICAgJzdhOTA4OTc0YmNlMThjZmUxMmEyN2JiMmFkNWE0ODhjZDc0ODRhNzc4NzEwNDg3MGIyNzAzNGY5NGVlZTMxZGQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMjEzYzdhNzE1Y2Q1ZDQ1MzU4ZDBiYmY5ZGMwY2UwMjIwNGIxMGJkZGUyYTNmNTg1NDBhZDY5MDhkMDU1OTc1NCcsXG4gICAgICAgICc0YjZkYWQwYjVhZTQ2MjUwNzAxM2FkMDYyNDViYTE5MGJiNDg1MGY1ZjM2YTdlZWRkZmYyYzI3NTM0YjQ1OGYyJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzRlN2MyNzJhN2FmNGIzNGU4ZGJiOTM1MmE1NDE5YTg3ZTI4MzhjNzBhZGM2MmNkZGYwY2MzYTNiMDhmYmQ1M2MnLFxuICAgICAgICAnMTc3NDljNzY2YzlkMGIxOGUxNmZkMDlmNmRlZjY4MWI1MzBiOTYxNGJmZjdkZDMzZTBiMzk0MTgxN2RjYWFlNidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdmZWE3NGUzZGJlNzc4YjFiMTBmMjM4YWQ2MTY4NmFhNWM3NmUzZGIyYmU0MzA1NzYzMjQyN2UyODQwZmIyN2I2JyxcbiAgICAgICAgJzZlMDU2OGRiOWIwYjEzMjk3Y2Y2NzRkZWNjYjZhZjkzMTI2YjU5NmI5NzNmN2I3NzcwMWQzZGI3ZjIzY2I5NmYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzZlNjQxMTNmNjc3Y2YwZTEwYTI1NzBkNTk5OTY4ZDMxNTQ0ZTE3OWI3NjA0MzI5NTJjMDJhNDQxN2JkZGUzOScsXG4gICAgICAgICdjOTBkZGY4ZGVlNGU5NWNmNTc3MDY2ZDcwNjgxZjBkMzVlMmEzM2QyYjU2ZDIwMzJiNGIxNzUyZDE5MDFhYzAxJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2M3MzhjNTZiMDNiMmFiZTFlODI4MWJhYTc0M2Y4ZjlhOGY3Y2M2NDNkZjI2Y2JlZTNhYjE1MDI0MmJjYmI4OTEnLFxuICAgICAgICAnODkzZmI1Nzg5NTFhZDI1MzdmNzE4ZjJlYWNiZmJiYmI4MjMxNGVlZjc4ODBjZmU5MTdlNzM1ZDk2OTlhODRjMydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkODk1NjI2NTQ4YjY1YjgxZTI2NGM3NjM3Yzk3Mjg3N2QxZDcyZTVmM2E5MjUwMTQzNzJlOWY2NTg4ZjZjMTRiJyxcbiAgICAgICAgJ2ZlYmZhYTM4ZjJiYzdlYWU3MjhlYzYwODE4YzM0MGViMDM0MjhkNjMyYmIwNjdlMTc5MzYzZWQ3NWQ3ZDk5MWYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYjhkYTk0MDMyYTk1NzUxOGViMGY2NDMzNTcxZTg3NjFjZWZmYzczNjkzZTg0ZWRkNDkxNTBhNTY0ZjY3NmUwMycsXG4gICAgICAgICcyODA0ZGZhNDQ4MDVhMWU0ZDdjOTljYzk3NjI4MDhiMDkyY2M1ODRkOTVmZjNiNTExNDg4ZTRlNzRlZmRmNmU3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2U4MGZlYTE0NDQxZmIzM2E3ZDhhZGFiOTQ3NWQ3ZmFiMjAxOWVmZmI1MTU2YTc5MmYxYTExNzc4ZTNjMGRmNWQnLFxuICAgICAgICAnZWVkMWRlN2Y2MzhlMDA3NzFlODk3NjhjYTNjYTk0NDcyZDE1NWU4MGFmMzIyZWE5ZmNiNDI5MWI2YWM5ZWM3OCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdhMzAxNjk3YmRmY2Q3MDQzMTNiYTQ4ZTUxZDU2NzU0M2YyYTE4MjAzMWVmZDY5MTVkZGMwN2JiY2M0ZTE2MDcwJyxcbiAgICAgICAgJzczNzBmOTFjZmI2N2U0ZjUwODE4MDlmYTI1ZDQwZjliMTczNWRiZjdjMGExMWExMzBjMGQxYTA0MWUxNzdlYTEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOTBhZDg1YjM4OWQ2YjkzNjQ2M2Y5ZDA1MTI2NzhkZTIwOGNjMzMwYjExMzA3ZmZmYWI3YWM2M2UzZmIwNGVkNCcsXG4gICAgICAgICdlNTA3YTM2MjBhMzgyNjFhZmZkY2JkOTQyNzIyMmI4MzlhZWZhYmUxNTgyODk0ZDk5MWQ0ZDQ4Y2I2ZWYxNTAnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOGY2OGI5ZDJmNjNiNWYzMzkyMzljMWFkOTgxZjE2MmVlODhjNTY3ODcyM2VhMzM1MWI3YjQ0NGM5ZWM0YzBkYScsXG4gICAgICAgICc2NjJhOWYyZGJhMDYzOTg2ZGUxZDkwYzJiNmJlMjE1ZGJiZWEyY2ZlOTU1MTBiZmRmMjNjYmY3OTUwMWZmZjgyJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2U0ZjNmYjAxNzZhZjg1ZDY1ZmY5OWZmOTE5OGMzNjA5MWY0OGU4NjUwMzY4MWUzZTY2ODZmZDUwNTMyMzFlMTEnLFxuICAgICAgICAnMWU2MzYzM2FkMGVmNGYxYzE2NjFhNmQwZWEwMmI3Mjg2Y2M3ZTc0ZWM5NTFkMWM5ODIyYzM4NTc2ZmViNzNiYydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4YzAwZmE5YjE4ZWJmMzMxZWI5NjE1MzdhNDVhNDI2NmM3MDM0ZjJmMGQ0ZTFkMDcxNmZiNmVhZTIwZWFlMjllJyxcbiAgICAgICAgJ2VmYTQ3MjY3ZmVhNTIxYTFhOWRjMzQzYTM3MzZjOTc0YzJmYWRhZmE4MWUzNmM1NGU3ZDJhNGM2NjcwMjQxNGInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZTdhMjZjZTY5ZGQ0ODI5ZjNlMTBjZWMwYTllOThlZDMxNDNkMDg0ZjMwOGI5MmMwOTk3ZmRkZmM2MGNiM2U0MScsXG4gICAgICAgICcyYTc1OGUzMDBmYTc5ODRiNDcxYjAwNmExYWFmYmIxOGQwYTZiMmMwNDIwZTgzZTIwZThhOTQyMWNmMmNmZDUxJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2I2NDU5ZTBlZTM2NjJlYzhkMjM1NDBjMjIzYmNiZGM1NzFjYmNiOTY3ZDc5NDI0ZjNjZjI5ZWIzZGU2YjgwZWYnLFxuICAgICAgICAnNjdjODc2ZDA2ZjNlMDZkZTFkYWRmMTZlNTY2MWRiM2M0YjNhZTZkNDhlMzViMmZmMzBiZjBiNjFhNzFiYTQ1J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2Q2OGE4MGM4MjgwYmI4NDA3OTMyMzRhYTExOGYwNjIzMWQ2ZjFmYzY3ZTczYzVhNWRlZGEwZjViNDk2OTQzZTgnLFxuICAgICAgICAnZGI4YmE5ZmZmNGI1ODZkMDBjNGIxZjkxNzdiMGUyOGI1YjBlN2I4Zjc4NDUyOTVhMjk0Yzg0MjY2YjEzMzEyMCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczMjRhZWQ3ZGY2NWM4MDQyNTJkYzAyNzA5MDdhMzBiMDk2MTJhZWI5NzM0NDljZWE0MDk1OTgwZmMyOGQzZDVkJyxcbiAgICAgICAgJzY0OGEzNjU3NzRiNjFmMmZmMTMwYzBjMzVhZWMxZjRmMTkyMTNiMGM3ZTMzMjg0Mzk2NzIyNGFmOTZhYjdjODQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNGRmOWMxNDkxOWNkZTYxZjZkNTFkZmRiZTVmZWU1ZGNlZWM0MTQzYmE4ZDFjYTg4OGU4YmQzNzNmZDA1NGM5NicsXG4gICAgICAgICczNWVjNTEwOTJkODcyODA1MDk3NGMyM2ExZDg1ZDRiNWQ1MDZjZGMyODg0OTAxOTJlYmFjMDZjYWQxMGQ1ZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc5YzM5MTlhODRhNDc0ODcwZmFlZDhhOWMxY2M2NjAyMTUyMzQ4OTA1NGQ3ZjAzMDhjYmZjOTljOGFjMWY5OGNkJyxcbiAgICAgICAgJ2RkYjg0ZjBmNGE0ZGRkNTc1ODRmMDQ0YmYyNjBlNjQxOTA1MzI2Zjc2YzY0YzhlNmJlN2U1ZTAzZDRmYzU5OWQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNjA1NzE3MGIxZGQxMmZkZjhkZTA1ZjI4MWQ4ZTA2YmI5MWUxNDkzYThiOTFkNGNjNWEyMTM4MjEyMGE5NTllNScsXG4gICAgICAgICc5YTFhZjBiMjZhNmE0ODA3YWRkOWEyZGFmNzFkZjI2MjQ2NTE1MmJjM2VlMjRjNjVlODk5YmU5MzIzODVhMmE4J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2E1NzZkZjhlMjNhMDg0MTE0MjE0MzlhNDUxOGRhMzE4ODBjZWYwZmJhN2Q0ZGYxMmIxYTY5NzNlZWNiOTQyNjYnLFxuICAgICAgICAnNDBhNmJmMjBlNzY2NDBiMmM5MmI5N2FmZTU4Y2Q4MmM0MzJlMTBhN2Y1MTRkOWYzZWU4YmUxMWFlMWIyOGVjOCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3Nzc4YTc4YzI4ZGVjM2UzMGEwNWZlOTYyOWRlOGMzOGJiMzBkMWY1Y2Y5YTNhMjA4Zjc2Mzg4OWJlNThhZDcxJyxcbiAgICAgICAgJzM0NjI2ZDlhYjVhNWIyMmZmNzA5OGUxMmYyZmY1ODAwODdiMzg0MTFmZjI0YWM1NjNiNTEzZmMxZmQ5ZjQzYWMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOTI4OTU1ZWU2MzdhODQ0NjM3MjlmZDMwZTdhZmQyZWQ1Zjk2Mjc0ZTVhZDdlNWNiMDllZGE5YzA2ZDkwM2FjJyxcbiAgICAgICAgJ2MyNTYyMTAwM2QzZjQyYTgyN2I3OGExMzA5M2E5NWVlYWMzZDI2ZWZhOGE4ZDgzZmM1MTgwZTkzNWJjZDA5MWYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnODVkMGZlZjNlYzZkYjEwOTM5OTA2NGYzYTBlM2IyODU1NjQ1YjRhOTA3YWQzNTQ1MjdhYWU3NTE2M2Q4Mjc1MScsXG4gICAgICAgICcxZjAzNjQ4NDEzYTM4YzBiZTI5ZDQ5NmU1ODJjZjU2NjNlODc1MWU5Njg3NzMzMTU4MmMyMzdhMjRlYjFmOTYyJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2ZmMmIwZGNlOTdlZWNlOTdjMWM5YjYwNDE3OThiODVkZmRmYjZkODg4MmRhMjAzMDhmNTQwNDgyNDUyNjA4N2UnLFxuICAgICAgICAnNDkzZDEzZmVmNTI0YmExODhhZjRjNGRjNTRkMDc5MzZjN2I3ZWQ2ZmI5MGUyY2ViMmM5NTFlMDFmMGMyOTkwNydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4MjdmYmJlNGIxZTg4MGVhOWVkMmIyZTYzMDFiMjEyYjU3ZjFlZTE0OGNkNmRkMjg3ODBlNWUyY2Y4NTZlMjQxJyxcbiAgICAgICAgJ2M2MGY5YzkyM2M3MjdiMGI3MWJlZjJjNjdkMWQxMjY4N2ZmN2E2MzE4NjkwMzE2NmQ2MDViNjhiYWVjMjkzZWMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZWFhNjQ5ZjIxZjUxYmRiYWU3YmU0YWUzNGNlNmU1MjE3YTU4ZmRjZTdmNDdmOWFhN2YzYjU4ZmEyMTIwZTJiMycsXG4gICAgICAgICdiZTMyNzllZDViYmJiMDNhYzY5YTgwZjg5ODc5YWE1YTAxYTZiOTY1ZjEzZjdlNTlkNDdhNTMwNWJhNWFkOTNkJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2U0YTQyZDQzYzVjZjE2OWQ5MzkxZGY2ZGVjZjQyZWU1NDFiNmQ4ZjBjOWExMzc0MDFlMjM2MzJkZGEzNGQyNGYnLFxuICAgICAgICAnNGQ5ZjkyZTcxNmQxYzczNTI2ZmM5OWNjZmI4YWQzNGNlODg2ZWVkZmE4ZDhlNGYxM2E3ZjcxMzFkZWJhOTQxNCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxZWM4MGZlZjM2MGNiZGQ5NTQxNjBmYWRhYjM1MmI2YjkyYjUzNTc2YTg4ZmVhNDk0NzE3M2I5ZDQzMDBiZjE5JyxcbiAgICAgICAgJ2FlZWZlOTM3NTZiNTM0MGQyZjNhNDk1OGE3YWJiZjVlMDE0NmU3N2Y2Mjk1YTA3YjY3MWNkYzFjYzEwN2NlZmQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMTQ2YTc3OGMwNDY3MGMyZjkxYjAwYWY0NjgwZGZhOGJjZTM0OTA3MTdkNThiYTg4OWRkYjU5MjgzNjY2NDJiZScsXG4gICAgICAgICdiMzE4ZTBlYzMzNTQwMjhhZGQ2Njk4MjdmOWQ0YjI4NzBhYWE5NzFkMmY3ZTVlZDFkMGIyOTc0ODNkODNlZmQwJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2ZhNTBjMGY2MWQyMmU1ZjA3ZTNhY2ViYjFhYTA3YjEyOGQwMDEyMjA5YTI4Yjk3NzZkNzZhODc5MzE4MGVlZjknLFxuICAgICAgICAnNmI4NGM2OTIyMzk3ZWJhOWI3MmNkMjg3MjI4MWE2OGE1ZTY4MzI5M2E1N2EyMTNiMzhjZDhkN2QzZjRmMjgxMSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkYTFkNjFkMGNhNzIxYTExYjFhNWJmNmI3ZDg4ZTg0MjFhMjg4YWI1ZDViYmE1MjIwZTUzZDMyYjVmMDY3ZWMyJyxcbiAgICAgICAgJzgxNTdmNTVhN2M5OTMwNmM3OWMwNzY2MTYxYzkxZTI5NjZhNzM4OTlkMjc5YjQ4YTY1NWZiYTBmMWFkODM2ZjEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYThlMjgyZmYwYzk3MDY5MDcyMTVmZjk4ZThmZDQxNjYxNTMxMWRlMDQ0NmYxZTA2MmE3M2IwNjEwZDA2NGUxMycsXG4gICAgICAgICc3Zjk3MzU1YjhkYjgxYzA5YWJmYjdmM2M1YjI1MTU4ODhiNjc5YTNlNTBkZDZiZDZjZWY3YzczMTExZjRjYzBjJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzE3NGE1M2I5YzlhMjg1ODcyZDM5ZTU2ZTY5MTNjYWIxNWQ1OWIxZmE1MTI1MDhjMDIyZjM4MmRlODMxOTQ5N2MnLFxuICAgICAgICAnY2NjOWRjMzdhYmZjOWMxNjU3YjQxNTVmMmM0N2Y5ZTY2NDZiM2ExZDhjYjk4NTQzODNkYTEzYWMwNzlhZmE3MydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc5NTkzOTY5ODE5NDM3ODVjM2QzZTU3ZWRmNTAxOGNkYmUwMzllNzMwZTQ5MThiM2Q4ODRmZGZmMDk0NzViN2JhJyxcbiAgICAgICAgJzJlN2U1NTI4ODhjMzMxZGQ4YmEwMzg2YTRiOWNkNjg0OWM2NTNmNjRjODcwOTM4NWU5YjhhYmY4NzUyNGYyZmQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZDJhNjNhNTBhZTQwMWU1NmQ2NDVhMTE1M2IxMDlhOGZjY2EwYTQzZDU2MWZiYTJkYmI1MTM0MGM5ZDgyYjE1MScsXG4gICAgICAgICdlODJkODZmYjY0NDNmY2I3NTY1YWVlNThiMjk0ODIyMGE3MGY3NTBhZjQ4NGNhNTJkNDE0MjE3NGRjZjg5NDA1J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzY0NTg3ZTIzMzU0NzFlYjg5MGVlNzg5NmQ3Y2ZkYzg2NmJhY2JkYmQzODM5MzE3YjM0MzZmOWI0NTYxN2UwNzMnLFxuICAgICAgICAnZDk5ZmNkZDViZjY5MDJlMmFlOTZkZDY0NDdjMjk5YTE4NWI5MGEzOTEzM2FlYWIzNTgyOTllNWU5ZmFmNjU4OSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4NDgxYmRlMGU0ZTRkODg1YjNhNTQ2ZDNlNTQ5ZGUwNDJmMGFhNmNlYTI1MGU3ZmQzNThkNmM4NmRkNDVlNDU4JyxcbiAgICAgICAgJzM4ZWU3YjhjYmE1NDA0ZGQ4NGEyNWJmMzljZWNiMmNhOTAwYTc5YzQyYjI2MmU1NTZkNjRiMWI1OTc3OTA1N2UnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMTM0NjRhNTdhNzgxMDJhYTYyYjY5NzlhZTgxN2Y0NjM3ZmZjZmVkM2M0YjFjZTMwYmNkNjMwM2Y2Y2FmNjY2YicsXG4gICAgICAgICc2OWJlMTU5MDA0NjE0NTgwZWY3ZTQzMzQ1M2NjYjBjYTQ4ZjMwMGE4MWQwOTQyZTEzZjQ5NWE5MDdmNmVjYzI3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2JjNGE5ZGY1YjcxM2ZlMmU5YWVmNDMwYmNjMWRjOTdhMGNkOWNjZWRlMmYyODU4OGNhZGEzYTBkMmQ4M2YzNjYnLFxuICAgICAgICAnZDNhODFjYTZlNzg1YzA2MzgzOTM3YWRmNGI3OThjYWE2ZThhOWZiZmE1NDdiMTZkNzU4ZDY2NjU4MWYzM2MxJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzhjMjhhOTdiZjgyOThiYzBkMjNkOGM3NDk0NTJhMzJlNjk0YjY1ZTMwYTk0NzJhMzk1NGFiMzBmZTUzMjRjYWEnLFxuICAgICAgICAnNDBhMzA0NjNhMzMwNTE5MzM3OGZlZGYzMWY3Y2MwZWI3YWU3ODRmMDQ1MWNiOTQ1OWU3MWRjNzNjYmVmOTQ4MidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4ZWE5NjY2MTM5NTI3YThjMWRkOTRjZTRmMDcxZmQyM2M4YjM1MGM1YTRiYjMzNzQ4YzRiYTExMWZhY2NhZTAnLFxuICAgICAgICAnNjIwZWZhYmJjOGVlMjc4MmUyNGU3YzBjZmI5NWM1ZDczNWI3ODNiZTljZjBmOGU5NTVhZjM0YTMwZTYyYjk0NSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkZDM2MjVmYWVmNWJhMDYwNzQ2Njk3MTZiYmQzNzg4ZDg5YmRkZTgxNTk1OTk2ODA5MmY3NmNjNGViOWE5Nzg3JyxcbiAgICAgICAgJzdhMTg4ZmEzNTIwZTMwZDQ2MWRhMjUwMTA0NTczMWNhOTQxNDYxOTgyODgzMzk1OTM3ZjY4ZDAwYzY0NGE1NzMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZjcxMGQ3OWQ5ZWI5NjIyOTdlNGY2MjMyYjQwZThmN2ZlYjJiYzYzODE0NjE0ZDY5MmMxMmRlNzUyNDA4MjIxZScsXG4gICAgICAgICdlYTk4ZTY3MjMyZDNiMzI5NWQzYjUzNTUzMjExNWNjYWM4NjEyYzcyMTg1MTYxNzUyNmFlNDdhOWM3N2JmYzgyJ1xuICAgICAgXVxuICAgIF1cbiAgfSxcbiAgbmFmOiB7XG4gICAgd25kOiA3LFxuICAgIHBvaW50czogW1xuICAgICAgW1xuICAgICAgICAnZjkzMDhhMDE5MjU4YzMxMDQ5MzQ0Zjg1Zjg5ZDUyMjliNTMxYzg0NTgzNmY5OWIwODYwMWYxMTNiY2UwMzZmOScsXG4gICAgICAgICczODhmN2IwZjYzMmRlODE0MGZlMzM3ZTYyYTM3ZjM1NjY1MDBhOTk5MzRjMjIzMWI2Y2I5ZmQ3NTg0YjhlNjcyJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzJmOGJkZTRkMWEwNzIwOTM1NWI0YTcyNTBhNWM1MTI4ZTg4Yjg0YmRkYzYxOWFiN2NiYThkNTY5YjI0MGVmZTQnLFxuICAgICAgICAnZDhhYzIyMjYzNmU1ZTNkNmQ0ZGJhOWRkYTZjOWM0MjZmNzg4MjcxYmFiMGQ2ODQwZGNhODdkM2FhNmFjNjJkNidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc1Y2JkZjA2NDZlNWRiNGVhYTM5OGYzNjVmMmVhN2EwZTNkNDE5YjdlMDMzMGUzOWNlOTJiZGRlZGNhYzRmOWJjJyxcbiAgICAgICAgJzZhZWJjYTQwYmEyNTU5NjBhMzE3OGQ2ZDg2MWE1NGRiYTgxM2QwYjgxM2ZkZTdiNWE1MDgyNjI4MDg3MjY0ZGEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYWNkNDg0ZTJmMGM3ZjY1MzA5YWQxNzhhOWY1NTlhYmRlMDk3OTY5NzRjNTdlNzE0YzM1ZjExMGRmYzI3Y2NiZScsXG4gICAgICAgICdjYzMzODkyMWIwYTdkOWZkNjQzODA5NzE3NjNiNjFlOWFkZDg4OGE0Mzc1ZjhlMGYwNWNjMjYyYWM2NGY5YzM3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzc3NGFlN2Y4NThhOTQxMWU1ZWY0MjQ2YjcwYzY1YWFjNTY0OTk4MGJlNWMxNzg5MWJiZWMxNzg5NWRhMDA4Y2InLFxuICAgICAgICAnZDk4NGEwMzJlYjZiNWUxOTAyNDNkZDU2ZDdiN2IzNjUzNzJkYjFlMmRmZjlkNmE4MzAxZDc0YzljOTUzYzYxYidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdmMjg3NzNjMmQ5NzUyODhiYzdkMWQyMDVjMzc0ODY1MWIwNzVmYmM2NjEwZTU4Y2RkZWVkZGY4ZjE5NDA1YWE4JyxcbiAgICAgICAgJ2FiMDkwMmU4ZDg4MGE4OTc1ODIxMmViNjVjZGFmNDczYTFhMDZkYTUyMWZhOTFmMjliNWNiNTJkYjAzZWQ4MSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkNzkyNGQ0ZjdkNDNlYTk2NWE0NjVhZTMwOTVmZjQxMTMxZTU5NDZmM2M4NWY3OWU0NGFkYmNmOGUyN2UwODBlJyxcbiAgICAgICAgJzU4MWUyODcyYTg2YzcyYTY4Mzg0MmVjMjI4Y2M2ZGVmZWE0MGFmMmJkODk2ZDNhNWM1MDRkYzlmZjZhMjZiNTgnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZGVmZGVhNGNkYjY3Nzc1MGE0MjBmZWU4MDdlYWNmMjFlYjk4OThhZTc5Yjk3Njg3NjZlNGZhYTA0YTJkNGEzNCcsXG4gICAgICAgICc0MjExYWIwNjk0NjM1MTY4ZTk5N2IwZWFkMmE5M2RhZWNlZDFmNGEwNGE5NWMwZjZjZmIxOTlmNjllNTZlYjc3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzJiNGVhMGE3OTdhNDQzZDI5M2VmNWNmZjQ0NGY0OTc5ZjA2YWNmZWJkN2U4NmQyNzc0NzU2NTYxMzgzODViNmMnLFxuICAgICAgICAnODVlODliYzAzNzk0NWQ5M2IzNDMwODNiNWExYzg2MTMxYTAxZjYwYzUwMjY5NzYzYjU3MGM4NTRlNWMwOWI3YSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczNTJiYmY0YTRjZGQxMjU2NGY5M2ZhMzMyY2UzMzMzMDFkOWFkNDAyNzFmODEwNzE4MTM0MGFlZjI1YmU1OWQ1JyxcbiAgICAgICAgJzMyMWViNDA3NTM0OGY1MzRkNTljMTgyNTlkZGEzZTFmNGExYjNiMmU3MWIxMDM5YzY3YmQzZDhiY2Y4MTk5OGMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMmZhMjEwNGQ2YjM4ZDExYjAyMzAwMTA1NTk4NzkxMjRlNDJhYjhkZmVmZjVmZjI5ZGM5Y2RhZGQ0ZWNhY2MzZicsXG4gICAgICAgICcyZGUxMDY4Mjk1ZGQ4NjViNjQ1NjkzMzViZDVkZDgwMTgxZDcwZWNmYzg4MjY0ODQyM2JhNzZiNTMyYjdkNjcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOTI0ODI3OWIwOWI0ZDY4ZGFiMjFhOWIwNjZlZGRhODMyNjNjM2Q4NGUwOTU3MmUyNjljYTBjZDdmNTQ1MzcxNCcsXG4gICAgICAgICc3MzAxNmY3YmYyMzRhYWRlNWQxYWE3MWJkZWEyYjFmZjNmYzBkZTJhODg3OTEyZmZlNTRhMzJjZTk3Y2IzNDAyJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2RhZWQ0ZjJiZTNhOGJmMjc4ZTcwMTMyZmIwYmViNzUyMmY1NzBlMTQ0YmY2MTVjMDdlOTk2ZDQ0M2RlZTg3MjknLFxuICAgICAgICAnYTY5ZGNlNGE3ZDZjOThlOGQ0YTFhY2E4N2VmOGQ3MDAzZjgzYzIzMGYzYWZhNzI2YWI0MGU1MjI5MGJlMWM1NSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdjNDRkMTJjNzA2NWQ4MTJlOGFjZjI4ZDdjYmIxOWY5MDExZWNkOWU5ZmRmMjgxYjBlNmEzYjVlODdkMjJlN2RiJyxcbiAgICAgICAgJzIxMTlhNDYwY2UzMjZjZGM3NmM0NTkyNmM5ODJmZGFjMGUxMDZlODYxZWRmNjFjNWEwMzkwNjNmMGUwZTY0ODInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNmEyNDViZjZkYzY5ODUwNGM4OWEyMGNmZGVkNjA4NTMxNTJiNjk1MzM2YzI4MDYzYjYxYzY1Y2JkMjY5ZTZiNCcsXG4gICAgICAgICdlMDIyY2Y0MmMyYmQ0YTcwOGIzZjUxMjZmMTZhMjRhZDhiMzNiYTQ4ZDA0MjNiNmVmZDVlNjM0ODEwMGQ4YTgyJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzE2OTdmZmE2ZmQ5ZGU2MjdjMDc3ZTNkMmZlNTQxMDg0Y2UxMzMwMGIwYmVjMTE0NmY5NWFlNTdmMGQwYmQ2YTUnLFxuICAgICAgICAnYjljMzk4ZjE4NjgwNmY1ZDI3NTYxNTA2ZTQ1NTc0MzNhMmNmMTUwMDllNDk4YWU3YWRlZTlkNjNkMDFiMjM5NidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc2MDViZGIwMTk5ODE3MThiOTg2ZDBmMDdlODM0Y2IwZDlkZWI4MzYwZmZiN2Y2MWRmOTgyMzQ1ZWYyN2E3NDc5JyxcbiAgICAgICAgJzI5NzJkMmRlNGY4ZDIwNjgxYTc4ZDkzZWM5NmZlMjNjMjZiZmFlODRmYjE0ZGI0M2IwMWUxZTkwNTZiOGM0OSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc2MmQxNGRhYjQxNTBiZjQ5NzQwMmZkYzQ1YTIxNWUxMGRjYjAxYzM1NDk1OWIxMGNmZTMxYzdlOWQ4N2ZmMzNkJyxcbiAgICAgICAgJzgwZmMwNmJkOGNjNWIwMTA5ODA4OGExOTUwZWVkMGRiMDFhYTEzMjk2N2FiNDcyMjM1ZjU2NDI0ODNiMjVlYWYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnODBjNjBhZDAwNDBmMjdkYWRlNWI0YjA2YzQwOGU1NmIyYzUwZTlmNTZiOWI4YjQyNWU1NTVjMmY4NjMwOGI2ZicsXG4gICAgICAgICcxYzM4MzAzZjFjYzVjMzBmMjZlNjZiYWQ3ZmU3MmY3MGE2NWVlZDRjYmU3MDI0ZWIxYWEwMWY1NjQzMGJkNTdhJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzdhOTM3NWFkNjE2N2FkNTRhYTc0YzYzNDhjYzU0ZDM0NGNjNWRjOTQ4N2Q4NDcwNDlkNWVhYmIwZmEwM2M4ZmInLFxuICAgICAgICAnZDBlM2ZhOWVjYTg3MjY5MDk1NTllMGQ3OTI2OTA0NmJkYzU5ZWExMGM3MGNlMmIwMmQ0OTllYzIyNGRjN2Y3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2Q1MjhlY2Q5YjY5NmI1NGM5MDdhOWVkMDQ1NDQ3YTc5YmI0MDhlYzM5YjY4ZGY1MDRiYjUxZjQ1OWJjM2ZmYzknLFxuICAgICAgICAnZWVjZjQxMjUzMTM2ZTVmOTk5NjZmMjE4ODFmZDY1NmViYzQzNDU0MDVjNTIwZGJjMDYzNDY1YjUyMTQwOTkzMydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc0OTM3MGE0YjVmNDM0MTJlYTI1ZjUxNGU4ZWNkYWQwNTI2NjExNWU0YTdlY2IxMzg3MjMxODA4ZjhiNDU5NjMnLFxuICAgICAgICAnNzU4ZjNmNDFhZmQ2ZWQ0MjhiMzA4MWIwNTEyZmQ2MmE1NGMzZjNhZmJiNWI2NzY0YjY1MzA1MmExMjk0OWM5YSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3N2YyMzA5MzZlZTg4Y2JiZDczZGY5MzBkNjQ3MDJlZjg4MWQ4MTFlMGUxNDk4ZTJmMWMxM2ViMWZjMzQ1ZDc0JyxcbiAgICAgICAgJzk1OGVmNDJhNzg4NmI2NDAwYTA4MjY2ZTliYTFiMzc4OTZjOTUzMzBkOTcwNzdjYmJlOGViM2M3NjcxYzYwZDYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZjJkYWM5OTFjYzRjZTRiOWVhNDQ4ODdlNWM3YzBiY2U1OGM4MDA3NGFiOWQ0ZGJhZWIyODUzMWI3NzM5ZjUzMCcsXG4gICAgICAgICdlMGRlZGM5YjNiMmY4ZGFkNGRhMWYzMmRlYzI1MzFkZjllYjVmYmViMDU5OGU0ZmQxYTExN2RiYTcwM2EzYzM3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzQ2M2IzZDlmNjYyNjIxZmIxYjRiZThmYmJlMjUyMDEyNWEyMTZjZGZjOWRhZTNkZWJjYmE0ODUwYzY5MGQ0NWInLFxuICAgICAgICAnNWVkNDMwZDc4YzI5NmMzNTQzMTE0MzA2ZGQ4NjIyZDdjNjIyZTI3Yzk3MGExZGUzMWNiMzc3YjAxYWY3MzA3ZSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdmMTZmODA0MjQ0ZTQ2ZTJhMDkyMzJkNGFmZjNiNTk5NzZiOThmYWMxNDMyOGEyZDFhMzI0OTZiNDk5OThmMjQ3JyxcbiAgICAgICAgJ2NlZGFiZDliODIyMDNmN2UxM2QyMDZmY2RmNGUzM2Q5MmE2YzUzYzI2ZTVjY2UyNmQ2NTc5OTYyYzRlMzFkZjYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnY2FmNzU0MjcyZGM4NDU2M2IwMzUyYjdhMTQzMTFhZjU1ZDI0NTMxNWFjZTI3YzY1MzY5ZTE1ZjcxNTFkNDFkMScsXG4gICAgICAgICdjYjQ3NDY2MGVmMzVmNWYyYTQxYjY0M2ZhNWU0NjA1NzVmNGZhOWI3OTYyMjMyYTVjMzJmOTA4MzE4YTA0NDc2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzI2MDBjYTRiMjgyY2I5ODZmODVkMGYxNzA5OTc5ZDhiNDRhMDljMDdjYjg2ZDdjMTI0NDk3YmM4NmYwODIxMjAnLFxuICAgICAgICAnNDExOWI4ODc1M2MxNWJkNmE2OTNiMDNmY2RkYmI0NWQ1YWM2YmU3NGFiNWYwZWY0NGIwYmU5NDc1YTdlNGI0MCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3NjM1Y2E3MmQ3ZTg0MzJjMzM4ZWM1M2NkMTIyMjBiYzAxYzQ4Njg1ZTI0ZjdkYzhjNjAyYTc3NDY5OThlNDM1JyxcbiAgICAgICAgJzkxYjY0OTYwOTQ4OWQ2MTNkMWQ1ZTU5MGY3OGU2ZDc0ZWNmYzA2MWQ1NzA0OGJhZDllNzZmMzAyYzViOWM2MSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3NTRlMzIzOWYzMjU1NzBjZGJiZjRhODdkZWVlOGE2NmI3ZjJiMzM0NzlkNDY4ZmJjMWE1MDc0M2JmNTZjYzE4JyxcbiAgICAgICAgJzY3M2ZiODZlNWJkYTMwZmIzY2QwZWQzMDRlYTQ5YTAyM2VlMzNkMDE5N2E2OTVkMGM1ZDk4MDkzYzUzNjY4MydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlM2U2YmQxMDcxYTFlOTZhZmY1Nzg1OWM4MmQ1NzBmMDMzMDgwMDY2MWQxYzk1MmY5ZmUyNjk0NjkxZDliOWU4JyxcbiAgICAgICAgJzU5YzllMGJiYTM5NGU3NmY0MGMwYWE1ODM3OWEzY2I2YTVhMjI4Mzk5M2U5MGM0MTY3MDAyYWY0OTIwZTM3ZjUnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMTg2YjQ4M2QwNTZhMDMzODI2YWU3M2Q4OGY3MzI5ODVjNGNjYjFmMzJiYTM1ZjRiNGNjNDdmZGNmMDRhYTZlYicsXG4gICAgICAgICczYjk1MmQzMmM2N2NmNzdlMmUxNzQ0NmUyMDQxODBhYjIxZmI4MDkwODk1MTM4YjRhNGE3OTdmODZlODA4ODhiJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2RmOWQ3MGE2Yjk4NzZjZTU0NGM5ODU2MWY0YmU0ZjcyNTQ0MmU2ZDJiNzM3ZDljOTFhODMyMTcyNGNlMDk2M2YnLFxuICAgICAgICAnNTVlYjJkYWZkODRkNmNjZDVmODYyYjc4NWRjMzlkNGFiMTU3MjIyNzIwZWY5ZGEyMTdiOGM0NWNmMmJhMjQxNydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc1ZWRkNWNjMjNjNTFlODdhNDk3Y2E4MTVkNWRjZTBmOGFiNTI1NTRmODQ5ZWQ4OTk1ZGU2NGM1ZjM0Y2U3MTQzJyxcbiAgICAgICAgJ2VmYWU5YzhkYmMxNDEzMDY2MWU4Y2VjMDMwYzg5YWQwYzEzYzY2YzBkMTdhMjkwNWNkYzcwNmFiNzM5OWE4NjgnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMjkwNzk4YzJiNjQ3NjgzMGRhMTJmZTAyMjg3ZTllNzc3YWEzZmJhMWMzNTViMTdhNzIyZDM2MmY4NDYxNGZiYScsXG4gICAgICAgICdlMzhkYTc2ZGNkNDQwNjIxOTg4ZDAwYmNmNzlhZjI1ZDViMjljMDk0ZGIyYTIzMTQ2ZDAwM2FmZDQxOTQzZTdhJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2FmM2M0MjNhOTVkOWY1YjMwNTQ3NTRlZmExNTBhYzM5Y2QyOTU1MmZlMzYwMjU3MzYyZGZkZWNlZjQwNTNiNDUnLFxuICAgICAgICAnZjk4YTNmZDgzMWViMmI3NDlhOTNiMGU2ZjM1Y2ZiNDBjOGNkNWFhNjY3YTE1NTgxYmMyZmVkZWQ0OThmZDljNidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3NjZkYmIyNGQxMzRlNzQ1Y2NjYWEyOGM5OWJmMjc0OTA2YmI2NmIyNmRjZjk4ZGY4ZDJmZWQ1MGQ4ODQyNDlhJyxcbiAgICAgICAgJzc0NGIxMTUyZWFjYmU1ZTM4ZGNjODg3OTgwZGEzOGI4OTc1ODRhNjVmYTA2Y2VkZDJjOTI0Zjk3Y2JhYzU5OTYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNTlkYmY0NmY4Yzk0NzU5YmEyMTI3N2MzMzc4NGY0MTY0NWY3YjQ0ZjZjNTk2YTU4Y2U5MmU2NjYxOTFhYmUzZScsXG4gICAgICAgICdjNTM0YWQ0NDE3NWZiYzMwMGY0ZWE2Y2U2NDgzMDlhMDQyY2U3MzlhNzkxOTc5OGNkODVlMjE2YzRhMzA3ZjZlJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2YxM2FkYTk1MTAzYzQ1MzczMDVlNjkxZTc0ZTlhNGE4ZGQ2NDdlNzExYTk1ZTczY2I2MmRjNjAxOGNmZDg3YjgnLFxuICAgICAgICAnZTEzODE3YjQ0ZWUxNGRlNjYzYmY0YmM4MDgzNDFmMzI2OTQ5ZTIxYTZhNzVjMjU3MDc3ODQxOWJkYWY1NzMzZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3NzU0YjRmYTBlOGFjZWQwNmQ0MTY3YTJjNTljY2E0Y2RhMTg2OWMwNmViYWRmYjY0ODg1NTAwMTVhODg1MjJjJyxcbiAgICAgICAgJzMwZTkzZTg2NGU2NjlkODIyMjRiOTY3YzMwMjBiOGZhOGQxZTRlMzUwYjZjYmNjNTM3YTQ4YjU3ODQxMTYzYTInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOTQ4ZGNhZGY1OTkwZTA0OGFhMzg3NGQ0NmFiZWY5ZDcwMTg1OGY5NWRlODA0MWQyYTY4MjhjOTllMjI2MjUxOScsXG4gICAgICAgICdlNDkxYTQyNTM3ZjZlNTk3ZDVkMjhhMzIyNGIxYmMyNWRmOTE1NGVmYmQyZWYxZDJjYmJhMmNhZTUzNDdkNTdlJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzc5NjI0MTQ0NTBjNzZjMTY4OWM3YjQ4ZjgyMDJlYzM3ZmIyMjRjZjVhYzBiZmExNTcwMzI4YThhM2Q3Yzc3YWInLFxuICAgICAgICAnMTAwYjYxMGVjNGZmYjQ3NjBkNWMxZmMxMzNlZjZmNmIxMjUwN2EwNTFmMDRhYzU3NjBhZmE1YjI5ZGI4MzQzNydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczNTE0MDg3ODM0OTY0YjU0YjE1YjE2MDY0NGQ5MTU0ODVhMTY5NzcyMjViODg0N2JiMGRkMDg1MTM3ZWM0N2NhJyxcbiAgICAgICAgJ2VmMGFmYmIyMDU2MjA1NDQ4ZTE2NTJjNDhlODEyN2ZjNjAzOWU3N2MxNWMyMzc4YjdlN2QxNWEwZGUyOTMzMTEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZDNjYzMwYWQ2YjQ4M2U0YmM3OWNlMmM5ZGQ4YmM1NDk5M2U5NDdlYjhkZjc4N2I0NDI5NDNkM2Y3YjUyN2VhZicsXG4gICAgICAgICc4YjM3OGEyMmQ4MjcyNzhkODljNWU5YmU4Zjk1MDhhZTNjMmFkNDYyOTAzNTg2MzBhZmIzNGRiMDRlZWRlMGE0J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzE2MjRkODQ3ODA3MzI4NjBjZTFjNzhmY2JmZWZlMDhiMmIyOTgyM2RiOTEzZjY0OTM5NzViYTBmZjQ4NDc2MTAnLFxuICAgICAgICAnNjg2NTFjZjliNmRhOTAzZTA5MTQ0NDhjNmNkOWQ0Y2E4OTY4NzhmNTI4MmJlNGM4Y2MwNmUyYTQwNDA3ODU3NSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3MzNjZTgwZGE5NTVhOGEyNjkwMmM5NTYzM2U2MmE5ODUxOTI0NzRiNWFmMjA3ZGE2ZGY3YjRmZDVmYzYxY2Q0JyxcbiAgICAgICAgJ2Y1NDM1YTJiZDJiYWRmN2Q0ODVhNGQ4YjhkYjlmY2NlM2UxZWY4ZTAyMDFlNDU3OGM1NDY3M2JjMWRjNWVhMWQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMTVkOTQ0MTI1NDk0NTA2NGNmMWExYzMzYmJkM2I0OWY4OTY2YzUwOTIxNzFlNjk5ZWYyNThkZmFiODFjMDQ1YycsXG4gICAgICAgICdkNTZlYjMwYjY5NDYzZTcyMzRmNTEzN2I3M2I4NDE3NzQzNDgwMGJhY2ViZmM2ODVmYzM3YmJlOWVmZTQwNzBkJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2ExZDBmY2YyZWM5ZGU2NzViNjEyMTM2ZTVjZTcwZDI3MWMyMTQxN2M5ZDJiOGFhYWFjMTM4NTk5ZDA3MTc5NDAnLFxuICAgICAgICAnZWRkNzdmNTBiY2I1YTNjYWIyZTkwNzM3MzA5NjY3ZjI2NDE0NjJhNTQwNzBmM2Q1MTkyMTJkMzljMTk3YTYyOSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlMjJmYmUxNWMwYWY4Y2NjNTc4MGMwNzM1Zjg0ZGJlOWE3OTBiYWRlZTgyNDVjMDZjN2NhMzczMzFjYjM2OTgwJyxcbiAgICAgICAgJ2E4NTViYWJhZDVjZDYwYzg4YjQzMGE2OWY1M2ExYTdhMzgyODkxNTQ5NjQ3OTliZTQzZDA2ZDc3ZDMxZGEwNidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczMTEwOTFkZDk4NjBlOGUyMGVlMTM0NzNjMTE1NWY1ZjY5NjM1ZTM5NDcwNGVhYTc0MDA5NDUyMjQ2Y2ZhOWIzJyxcbiAgICAgICAgJzY2ZGI2NTZmODdkMWYwNGZmZmQxZjA0Nzg4YzA2ODMwODcxZWM1YTY0ZmVlZTY4NWJkODBmMGIxMjg2ZDgzNzQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzRjMWZkMDRkMzAxYmU4OWIzMWMwNDQyZDNlNmFjMjQ4ODM5MjhiNDVhOTM0MDc4MTg2N2Q0MjMyZWMyZGJkZicsXG4gICAgICAgICc5NDE0Njg1ZTk3YjFiNTk1NGJkNDZmNzMwMTc0MTM2ZDU3ZjFjZWViNDg3NDQzZGM1MzIxODU3YmE3M2FiZWUnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZjIxOWVhNWQ2YjU0NzAxYzFjMTRkZTViNTU3ZWI0MmE4ZDEzZjNhYmJjZDA4YWZmY2MyYTVlNmIwNDliOGQ2MycsXG4gICAgICAgICc0Y2I5NTk1N2U4M2Q0MGIwZjczYWY0NTQ0Y2NjZjZiMWY0YjA4ZDNjMDdiMjdmYjhkOGMyOTYyYTQwMDc2NmQxJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2Q3Yjg3NDBmNzRhOGZiYWFiMWY2ODNkYjhmNDVkZTI2NTQzYTU0OTBiY2E2MjcwODcyMzY5MTI0NjlhMGI0NDgnLFxuICAgICAgICAnZmE3Nzk2ODEyOGQ5YzkyZWUxMDEwZjMzN2FkNDcxN2VmZjE1ZGI1ZWQzYzA0OWIzNDExZTAzMTVlYWE0NTkzYidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczMmQzMWMyMjJmOGY2ZjBlZjg2ZjdjOThkM2EzMzM1ZWFkNWJjZDMyYWJkZDk0Mjg5ZmU0ZDMwOTFhYTgyNGJmJyxcbiAgICAgICAgJzVmMzAzMmY1ODkyMTU2ZTM5Y2NkM2Q3OTE1YjllMWRhMmU2ZGFjOWU2ZjI2ZTk2MTExOGQxNGI4NDYyZTE2NjEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzQ2MWYzNzE5MTRhYjMyNjcxMDQ1YTE1NWQ5ODMxZWE4NzkzZDc3Y2Q1OTU5MmM0MzQwZjg2Y2JjMTgzNDdiNScsXG4gICAgICAgICc4ZWMwYmEyMzhiOTZiZWMwY2JkZGRjYWUwYWE0NDI1NDJlZWUxZmY1MGM5ODZlYTZiMzk4NDdiM2NjMDkyZmY2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2VlMDc5YWRiMWRmMTg2MDA3NDM1NmEyNWFhMzgyMDZhNmQ3MTZiMmMzZTY3NDUzZDI4NzY5OGJhZDdiMmIyZDYnLFxuICAgICAgICAnOGRjMjQxMmFhZmUzYmU1YzRjNWYzN2UwZWNjNWY5ZjZhNDQ2OTg5YWYwNGM0ZTI1ZWJhYWM0NzllYzFjOGMxZSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxNmVjOTNlNDQ3ZWM4M2YwNDY3YjE4MzAyZWU2MjBmN2U2NWRlMzMxODc0YzlkYzcyYmZkODYxNmJhOWRhNmI1JyxcbiAgICAgICAgJzVlNDYzMTE1MGU2MmZiNDBkMGU4YzJhN2NhNTgwNGEzOWQ1ODE4NmE1MGU0OTcxMzk2MjY3NzhlMjViMDY3NGQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZWFhNWY5ODBjMjQ1ZjZmMDM4OTc4MjkwYWZhNzBiNmJkODg1NTg5N2Y5OGI2YWE0ODViOTYwNjVkNTM3YmQ5OScsXG4gICAgICAgICdmNjVmNWQzZTI5MmMyZTA4MTlhNTI4MzkxYzk5NDYyNGQ3ODQ4NjlkN2U2ZWE2N2ZiMTgwNDEwMjRlZGMwN2RjJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzc4Yzk0MDc1NDRhYzEzMjY5MmVlMTkxMGEwMjQzOTk1OGFlMDQ4NzcxNTEzNDJlYTk2YzRiNmIzNWE0OWY1MScsXG4gICAgICAgICdmM2UwMzE5MTY5ZWI5Yjg1ZDU0MDQ3OTU1MzlhNWU2OGZhMWZiZDU4M2MwNjRkMjQ2MmI2NzVmMTk0YTNkZGI0J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzQ5NGY0YmUyMTlhMWE3NzAxNmRjZDgzODQzMWFlYTAwMDFjZGM4YWU3YTZmYzY4ODcyNjU3OGQ5NzAyODU3YTUnLFxuICAgICAgICAnNDIyNDJhOTY5MjgzYTVmMzM5YmE3ZjA3NWUzNmJhMmFmOTI1Y2UzMGQ3NjdlZDZlNTVmNGIwMzE4ODBkNTYyYydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdhNTk4YTgwMzBkYTZkODZjNmJjN2YyZjUxNDRlYTU0OWQyODIxMWVhNThmYWE3MGViZjRjMWU2NjVjMWZlOWI1JyxcbiAgICAgICAgJzIwNGI1ZDZmODQ4MjJjMzA3ZTRiNGE3MTQwNzM3YWVjMjNmYzYzYjY1YjM1Zjg2YTEwMDI2ZGJkMmQ4NjRlNmInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYzQxOTE2MzY1YWJiMmI1ZDA5MTkyZjVmMmRiZWFmZWMyMDhmMDIwZjEyNTcwYTE4NGRiYWRjM2U1ODU5NTk5NycsXG4gICAgICAgICc0ZjE0MzUxZDAwODdlZmE0OWQyNDViMzI4OTg0OTg5ZDVjYWY5NDUwZjM0YmZjMGVkMTZlOTZiNThmYTk5MTMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnODQxZDYwNjNhNTg2ZmE0NzVhNzI0NjA0ZGEwM2JjNWI5MmEyZTBkMmUwYTM2YWNmZTRjNzNhNTUxNDc0Mjg4MScsXG4gICAgICAgICc3Mzg2N2Y1OWMwNjU5ZTgxOTA0ZjlhMWM3NTQzNjk4ZTYyNTYyZDY3NDRjMTY5Y2U3YTM2ZGUwMWE4ZDYxNTQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNWU5NWJiMzk5YTY5NzFkMzc2MDI2OTQ3Zjg5YmRlMmYyODJiMzM4MTA5MjhiZTRkZWQxMTJhYzRkNzBlMjBkNScsXG4gICAgICAgICczOWYyM2YzNjY4MDkwODViZWViZmM3MTE4MTMxMzc3NWE5OWM5YWVkN2Q4YmEzOGIxNjEzODRjNzQ2MDEyODY1J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzM2ZTQ2NDFhNTM5NDhmZDQ3NmMzOWY4YTk5ZmQ5NzRlNWVjMDc1NjRiNTMxNWQ4YmY5OTQ3MWJjYTBlZjJmNjYnLFxuICAgICAgICAnZDI0MjRiMWIxYWJlNGViODE2NDIyN2IwODVjOWFhOTQ1NmVhMTM0OTNmZDU2M2UwNmZkNTFjZjU2OTRjNzhmYydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczMzY1ODFlYTdiZmJiYjI5MGMxOTFhMmY1MDdhNDFjZjU2NDM4NDIxNzBlOTE0ZmFlYWIyN2MyYzU3OWY3MjYnLFxuICAgICAgICAnZWFkMTIxNjg1OTVmZTFiZTk5MjUyMTI5YjZlNTZiMzM5MWY3YWIxNDEwY2QxZTBlZjNkY2RjYWJkMmZkYTIyNCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4YWI4OTgxNmRhZGZkNmI2YTFmMjYzNGZjZjAwZWM4NDAzNzgxMDI1ZWQ2ODkwYzQ4NDk3NDI3MDZiZDQzZWRlJyxcbiAgICAgICAgJzZmZGNlZjA5ZjJmNmQwYTA0NGU2NTRhZWY2MjQxMzZmNTAzZDQ1OWMzZTg5ODQ1ODU4YTQ3YTkxMjljZGQyNGUnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMWUzM2YxYTc0NmM5YzU3NzgxMzMzNDRkOTI5OWZjYWEyMGIwOTM4ZThhY2ZmMjU0NGJiNDAyODRiOGM1ZmI5NCcsXG4gICAgICAgICc2MDY2MDI1N2RkMTFiM2FhOWM4ZWQ2MThkMjRlZGZmMjMwNmQzMjBmMWQwMzAxMGUzM2E3ZDIwNTdmM2IzYjYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnODViN2MxZGNiM2NlYzFiN2VlN2YzMGRlZDc5ZGQyMGEwZWQxZjRjYzE4Y2JjZmNmYTQxMDM2MWZkOGYwOGYzMScsXG4gICAgICAgICczZDk4YTljZGQwMjZkZDQzZjM5MDQ4ZjI1YTg4NDdmNGZjYWZhZDE4OTVkN2E2MzNjNmZlZDNjMzVlOTk5NTExJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzI5ZGY5ZmJkOGQ5ZTQ2NTA5Mjc1ZjRiMTI1ZDZkNDVkN2ZiZTlhM2I4NzhhN2FmODcyYTI4MDA2NjFhYzVmNTEnLFxuICAgICAgICAnYjRjNGZlOTljNzc1YTYwNmUyZDg4NjIxNzkxMzlmZmRhNjFkYzg2MWMwMTllNTVjZDI4NzZlYjJhMjdkODRiJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2EwYjFjYWUwNmIwYTg0N2EzZmVhNmU2NzFhYWY4YWRmZGZlNThjYTJmNzY4MTA1YzgwODJiMmU0NDlmY2UyNTInLFxuICAgICAgICAnYWU0MzQxMDJlZGRlMDk1OGVjNGIxOWQ5MTdhNmEyOGU2YjcyZGExODM0YWZmMGU2NTBmMDQ5NTAzYTI5NmNmMidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc0ZThjZWFmYjliM2U5YTEzNmRjN2ZmNjdlODQwMjk1YjQ5OWRmYjNiMjEzM2U0YmExMTNmMmU0YzBlMTIxZTUnLFxuICAgICAgICAnY2YyMTc0MTE4YzhiNmQ3YTRiNDhmNmQ1MzRjZTVjNzk0MjJjMDg2YTYzNDYwNTAyYjgyN2NlNjJhMzI2NjgzYydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkMjRhNDRlMDQ3ZTE5YjZmNWFmYjgxYzdjYTJmNjkwODBhNTA3NjY4OWEwMTA5MTlmNDI3MjVjMmI3ODlhMzNiJyxcbiAgICAgICAgJzZmYjhkNTU5MWI0NjZmOGZjNjNkYjUwZjFjMGYxYzY5MDEzZjk5Njg4N2I4MjQ0ZDJjZGVjNDE3YWZlYThmYTMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZWEwMTYwNmE3YTZjOWNkZDI0OWZkZmNmYWNiOTk1ODQwMDFlZGQyOGFiYmFiNzdiNTEwNGU5OGU4ZTNiMzVkNCcsXG4gICAgICAgICczMjJhZjQ5MDhjNzMxMmIwY2ZiZmUzNjlmN2E3YjNjZGI3ZDQ0OTRiYzI4MjM3MDBjZmQ2NTIxODhhM2VhOThkJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2FmOGFkZGJmMmI2NjFjOGE2YzYzMjg2NTVlYjk2NjUxMjUyMDA3ZDhjNWVhMzFiZTRhZDE5NmRlOGNlMjEzMWYnLFxuICAgICAgICAnNjc0OWU2N2MwMjliODVmNTJhMDM0ZWFmZDA5NjgzNmIyNTIwODE4NjgwZTI2YWM4ZjNkZmJjZGI3MTc0OTcwMCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlM2FlMTk3NDU2NmNhMDZjYzUxNmQ0N2UwZmIxNjVhNjc0YTNkYWJjZmNhMTVlNzIyZjBlMzQ1MGY0NTg4OScsXG4gICAgICAgICcyYWVhYmU3ZTQ1MzE1MTAxMTYyMTdmMDdiZjRkMDczMDBkZTk3ZTQ4NzRmODFmNTMzNDIwYTcyZWViMGJkNmE0J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzU5MWVlMzU1MzEzZDk5NzIxY2Y2OTkzZmZlZDFlM2UzMDE5OTNmZjNlZDI1ODgwMjA3NWVhOGNlZDM5N2UyNDYnLFxuICAgICAgICAnYjBlYTU1OGExMTNjMzBiZWE2MGZjNDc3NTQ2MGM3OTAxZmYwYjA1M2QyNWNhMmJkZWVlOThmMWE0YmU1ZDE5NidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxMTM5NmQ1NWZkYTU0YzQ5ZjE5YWE5NzMxOGQ4ZGE2MWZhODU4NGU0N2IwODQ5NDUwNzdjZjAzMjU1YjUyOTg0JyxcbiAgICAgICAgJzk5OGM3NGE4Y2Q0NWFjMDEyODlkNTgzM2E3YmViNDc0NGZmNTM2YjAxYjI1N2JlNGM1NzY3YmVhOTNlYTU3YTQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnM2M1ZDJhMWJhMzljNWExNzkwMDAwNzM4YzllMGM0MGI4ZGNkZmQ1NDY4NzU0YjY0MDU1NDAxNTdlMDE3YWE3YScsXG4gICAgICAgICdiMjI4NDI3OTk5NWEzNGUyZjlkNGRlNzM5NmZjMThiODBmOWI4YjlmZGQyNzBmNjY2MWY3OWNhNGM4MWJkMjU3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2NjODcwNGI4YTYwYTBkZWZhM2E5OWE3Mjk5ZjJlOWMzZmJjMzk1YWZiMDRhYzA3ODQyNWVmOGExNzkzY2MwMzAnLFxuICAgICAgICAnYmRkNDYwMzlmZWVkMTc4ODFkMWUwODYyZGIzNDdmOGNmMzk1Yjc0ZmM0YmNkYzRlOTQwYjc0ZTNhYzFmMWIxMydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdjNTMzZTRmN2VhODU1NWFhY2Q5Nzc3YWM1Y2FkMjliOTdkZDRkZWZjY2M1M2VlN2VhMjA0MTE5YjI4ODliMTk3JyxcbiAgICAgICAgJzZmMGEyNTZiYzVlZmRmNDI5YTJmYjYyNDJmMWE0M2EyZDliOTI1YmI0YTRiM2EyNmJiOGUwZjQ1ZWI1OTYwOTYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYzE0ZjhmMmNjYjI3ZDZmMTA5ZjZkMDhkMDNjYzk2YTY5YmE4YzM0ZWVjMDdiYmNmNTY2ZDQ4ZTMzZGE2NTkzJyxcbiAgICAgICAgJ2MzNTlkNjkyM2JiMzk4ZjdmZDQ0NzNlMTZmZTFjMjg0NzViNzQwZGQwOTgwNzVlNmMwZTg2NDkxMTNkYzNhMzgnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYTZjYmMzMDQ2YmM2YTQ1MGJhYzI0Nzg5ZmExNzExNWE0Yzk3MzllZDc1ZjhmMjFjZTQ0MWY3MmUwYjkwZTZlZicsXG4gICAgICAgICcyMWFlN2Y0NjgwZTg4OWJiMTMwNjE5ZTJjMGY5NWEzNjBjZWI1NzNjNzA2MDMxMzk4NjJhZmQ2MTdmYTliOWYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzQ3ZDZkOWEwMmM0ODkyN2ViZmI4NmMxMzU5YjFjYWYxMzBhM2MwMjY3ZDExY2U2MzQ0YjM5Zjk5ZDQzY2MzOCcsXG4gICAgICAgICc2MGVhN2Y2MWEzNTM1MjRkMWM5ODdmNmVjZWM5MmYwODZkNTY1YWI2ODc4NzBjYjEyNjg5ZmYxZTMxYzc0NDQ4J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2RhNjU0NWQyMTgxZGI4ZDk4M2Y3ZGNiMzc1ZWY1ODY2ZDQ3YzY3YjFiZjMxYzhjZjg1NWVmNzQzN2I3MjY1NmEnLFxuICAgICAgICAnNDliOTY3MTVhYjY4NzhhNzllNzhmMDdjZTU2ODBjNWQ2NjczMDUxYjQ5MzViZDg5N2ZlYTgyNGI3N2RjMjA4YSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdjNDA3NDdjYzlkMDEyY2IxYTEzYjgxNDgzMDljNmRlN2VjMjVkNjk0NWQ2NTcxNDZiOWQ1OTk0YjhmZWIxMTExJyxcbiAgICAgICAgJzVjYTU2MDc1M2JlMmExMmZjNmRlNmNhZjJjYjQ4OTU2NWRiOTM2MTU2Yjk1MTRlMWJiNWU4MzAzN2UwZmEyZDQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNGU0MmM4ZWM4MmM5OTc5OGNjZjNhNjEwYmU4NzBlNzgzMzhjN2Y3MTMzNDhiZDM0YzgyMDNlZjQwMzdmMzUwMicsXG4gICAgICAgICc3NTcxZDc0ZWU1ZTBmYjkyYTdhOGIzM2EwNzc4MzM0MWE1NDkyMTQ0Y2M1NGJjYzQwYTk0NDczNjkzNjA2NDM3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzM3NzVhYjcwODliYzZhZjgyM2FiYTJlMWFmNzBiMjM2ZDI1MWNhZGIwYzg2NzQzMjg3NTIyYTFiM2IwZGVkZWEnLFxuICAgICAgICAnYmU1MmQxMDdiY2ZhMDlkOGJjYjk3MzZhODI4Y2ZhN2ZhYzhkYjE3YmY3YTc2YTJjNDJhZDk2MTQwOTAxOGNmNydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdjZWUzMWNiZjdlMzRlYzM3OWQ5NGZiODE0ZDNkNzc1YWQ5NTQ1OTVkMTMxNGJhODg0Njk1OWUzZTgyZjc0ZTI2JyxcbiAgICAgICAgJzhmZDY0YTE0YzA2YjU4OWMyNmI5NDdhZTJiY2Y2YmZhMDE0OWVmMGJlMTRlZDRkODBmNDQ4YTAxYzQzYjFjNmQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYjRmOWVhZWEwOWI2OTE3NjE5ZjZlYTZhNGViNTQ2NGVmZGRiNThmZDQ1YjFlYmVmY2RjMWEwMWQwOGI0Nzk4NicsXG4gICAgICAgICczOWU1Yzk5MjViNWE1NGIwNzQzM2E0ZjE4YzYxNzI2ZjhiYjEzMWMwMTJjYTU0MmViMjRhOGFjMDcyMDA2ODJhJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2Q0MjYzZGZjM2QyZGY5MjNhMDE3OWE0ODk2NmQzMGNlODRlMjUxNWFmYzNkY2NjMWI3NzkwNzc5MmViY2M2MGUnLFxuICAgICAgICAnNjJkZmFmMDdhMGY3OGZlYjMwZTMwZDYyOTU4NTNjZTE4OWUxMjc3NjBhZDZjZjdmYWUxNjRlMTIyYTIwOGQ1NCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc0ODQ1NzUyNDgyMGZhNjVhNGY4ZDM1ZWI2OTMwODU3YzAwMzJhY2MwYTRhMmRlNDIyMjMzZWVkYTg5NzYxMmM0JyxcbiAgICAgICAgJzI1YTc0OGFiMzY3OTc5ZDk4NzMzYzM4YTFmYTFjMmU3ZGM2Y2MwN2RiMmQ2MGE5YWU3YTc2YWFhNDliZDBmNzcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZGZlZWVmMTg4MTEwMWYyY2IxMTY0NGYzYTJhZmRmYzIwNDVlMTk5MTkxNTI5MjNmMzY3YTE3NjdjMTFjY2VkYScsXG4gICAgICAgICdlY2ZiNzA1NmNmMWRlMDQyZjk0MjBiYWIzOTY3OTNjMGMzOTBiZGU3NGI0YmJkZmYxNmE4M2FlMDlhOWE3NTE3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzZkN2VmNmIxNzU0M2Y4MzczYzU3M2Y0NGUxZjM4OTgzNWQ4OWJjYmM2MDYyY2VkMzZjODJkZjgzYjhmYWU4NTknLFxuICAgICAgICAnY2Q0NTBlYzMzNTQzODk4NmRmZWZhMTBjNTdmZWE5YmNjNTIxYTA5NTliMmQ4MGJiZjc0YjE5MGRjYTcxMmQxMCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlNzU2MDVkNTkxMDJhNWEyNjg0NTAwZDNiOTkxZjJlM2YzYzg4YjkzMjI1NTQ3MDM1YWYyNWFmNjZlMDQ1NDFmJyxcbiAgICAgICAgJ2Y1YzU0NzU0YThmNzFlZTU0MGI5YjQ4NzI4NDczZTMxNGY3MjlhYzUzMDhiMDY5MzgzNjA5OTBlMmJmYWQxMjUnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZWI5ODY2MGY0YzRkZmFhMDZhMmJlNDUzZDUwMjBiYzk5YTBjMmU2MGFiZTM4ODQ1N2RkNDNmZWZiMWVkNjIwYycsXG4gICAgICAgICc2Y2I5YTg4NzZkOWNiODUyMDYwOWFmM2FkZDI2Y2QyMGEwYTdjZDhhOTQxMTEzMWNlODVmNDQxMDAwOTkyMjNlJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzEzZTg3YjAyN2Q4NTE0ZDM1OTM5ZjJlNjg5MmIxOTkyMjE1NDU5Njk0MTg4ODMzNmRjMzU2M2UzYjhkYmE5NDInLFxuICAgICAgICAnZmVmNWEzYzY4MDU5YTZkZWM1ZDYyNDExNGJmMWU5MWFhYzJiOWRhNTY4ZDZhYmViMjU3MGQ1NTY0NmI4YWRmMSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlZTE2MzAyNmU5ZmQ2ZmUwMTdjMzhmMDZhNWJlNmZjMTI1NDI0YjM3MWNlMjcwOGU3YmY0NDkxNjkxZTU3NjRhJyxcbiAgICAgICAgJzFhY2IyNTBmMjU1ZGQ2MWM0M2Q5NGNjYzY3MGQwZjU4ZjQ5YWUzZmExNWI5NjYyM2U1NDMwZGEwYWQ2YzYyYjInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYjI2OGY1ZWY5YWQ1MWU0ZDc4ZGUzYTc1MGMyZGM4OWIxZTYyNmQ0MzUwNTg2Nzk5OTkzMmU1ZGIzM2FmM2Q4MCcsXG4gICAgICAgICc1ZjMxMGQ0YjNjOTliOWViYjE5Zjc3ZDQxYzFkZWUwMThjZjBkMzRmZDQxOTE2MTQwMDNlOTQ1YTEyMTZlNDIzJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2ZmMDdmMzExOGE5ZGYwMzVlOWZhZDg1ZWI2YzdiZmU0MmIwMmYwMWNhOTljZWVhM2JmN2ZmZGJhOTNjNDc1MGQnLFxuICAgICAgICAnNDM4MTM2ZDYwM2U4NThhM2E1YzQ0MGMzOGVjY2JhZGRjMWQyOTQyMTE0ZTJlZGRkNDc0MGQwOThjZWQxZjBkOCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4ZDhiOTg1NWM3YzA1MmEzNDE0NmZkMjBmZmI2NThiZWE0YjlmNjllMGQ4MjVlYmVjMTZlOGMzY2UyYjUyNmExJyxcbiAgICAgICAgJ2NkYjU1OWVlZGMyZDc5ZjkyNmJhZjQ0ZmI4NGVhNGQ0NGJjZjUwZmVlNTFkN2NlYjMwZTJlN2Y0NjMwMzY3NTgnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNTJkYjBiNTM4NGRmYmYwNWJmYTlkNDcyZDdhZTI2ZGZlNGI4NTFjZWNhOTFiMWViYTU0MjYzMTgwZGEzMmI2MycsXG4gICAgICAgICdjM2I5OTdkMDUwZWU1ZDQyM2ViYWY2NmE2ZGI5ZjU3YjMxODBjOTAyODc1Njc5ZGU5MjRiNjlkODRhN2IzNzUnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZTYyZjk0OTBkM2Q1MWRhNjM5NWVmZDI0ZTgwOTE5Y2M3ZDBmMjljM2YzZmE0OGM2ZmZmNTQzYmVjYmQ0MzM1MicsXG4gICAgICAgICc2ZDg5YWQ3YmE0ODc2YjBiMjJjMmNhMjgwYzY4Mjg2MmYzNDJjODU5MWYxZGFmNTE3MGUwN2JmZDljY2FmYTdkJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzdmMzBlYTI0NzZiMzk5YjQ5NTc1MDljODhmNzdkMDE5MWFmYTJmZjVjYjdiMTRmZDZkOGU3ZDY1YWFhYjExOTMnLFxuICAgICAgICAnY2E1ZWY3ZDRiMjMxYzk0YzNiMTUzODlhNWY2MzExZTlkYWZmN2JiNjdiMTAzZTk4ODBlZjRiZmY2MzdhY2FlYydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc1MDk4ZmYxZTFkOWYxNGZiNDZhMjEwZmFkYTZjOTAzZmVmMGZiN2I0YTFkZDFkOWFjNjBhMDM2MTgwMGI3YTAwJyxcbiAgICAgICAgJzk3MzExNDFkODFmYzhmODA4NGQzN2M2ZTc1NDIwMDZiM2VlMWI0MGQ2MGRmZTUzNjJhNWIxMzJmZDE3ZGRjMCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczMmI3OGM3ZGU5ZWU1MTJhNzI4OTViZTZiOWNiZWZhNmUyZjNjNGNjY2U0NDVjOTZiOWYyYzgxZTI3NzhhZDU4JyxcbiAgICAgICAgJ2VlMTg0OWY1MTNkZjcxZTMyZWZjMzg5NmVlMjgyNjBjNzNiYjgwNTQ3YWUyMjc1YmE0OTcyMzc3OTRjODc1M2MnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZTJjYjc0ZmRkYzhlOWZiY2QwNzZlZWYyYTdjNzJiMGNlMzdkNTBmMDgyNjlkZmMwNzRiNTgxNTUwNTQ3YTRmNycsXG4gICAgICAgICdkM2FhMmVkNzFjOWRkMjI0N2E2MmRmMDYyNzM2ZWIwYmFkZGVhOWUzNjEyMmQyYmU4NjQxYWJjYjAwNWNjNGE0J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzg0Mzg0NDc1NjZkNGQ3YmVkYWRjMjk5NDk2YWIzNTc0MjYwMDlhMzVmMjM1Y2IxNDFiZTBkOTljZDEwYWUzYTgnLFxuICAgICAgICAnYzRlMTAyMDkxNjk4MGE0ZGE1ZDAxYWM1ZTZhZDMzMDczNGVmMGQ3OTA2NjMxYzRmMjM5MDQyNmIyZWRkNzkxZidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc0MTYyZDQ4OGI4OTQwMjAzOWI1ODRjNmZjNmMzMDg4NzA1ODdkOWM0NmY2NjBiODc4YWI2NWM4MmM3MTFkNjdlJyxcbiAgICAgICAgJzY3MTYzZTkwMzIzNjI4OWY3NzZmMjJjMjVmYjhhM2FmYzE3MzJmMmI4NGI0ZTk1ZGJkYTQ3YWU1YTA4NTI2NDknXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnM2ZhZDNmYTg0Y2FmMGYzNGYwZjg5YmZkMmRjZjU0ZmMxNzVkNzY3YWVjM2U1MDY4NGYzYmE0YTRiZjVmNjgzZCcsXG4gICAgICAgICdjZDFiYzdjYjZjYzQwN2JiMmYwY2E2NDdjNzE4YTczMGNmNzE4NzJlN2QwZDJhNTNmYTIwZWZjZGZlNjE4MjYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNjc0ZjI2MDBhMzAwN2EwMDU2OGMxYTdjZTA1ZDA4MTZjMWZiODRiZjEzNzA3OThmMWM2OTUzMmZhZWIxYTg2YicsXG4gICAgICAgICcyOTlkMjFmOTQxM2YzM2IzZWRmNDNiMjU3MDA0NTgwYjcwZGI1N2RhMGIxODIyNTllMDllZWNjNjllMGQzOGE1J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2QzMmY0ZGE1NGFkZTc0YWJiODFiODE1YWQxZmIzYjI2M2Q4MmQ2YzY5MjcxNGJjZmY4N2QyOWJkNWVlOWYwOGYnLFxuICAgICAgICAnZjk0MjllNzM4YjhlNTNiOTY4ZTk5MDE2YzA1OTcwNzc4MmUxNGY0NTM1MzU5ZDU4MmZjNDE2OTEwYjNlZWE4NydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczMGU0ZTY3MDQzNTM4NTU1NmU1OTM2NTcxMzU4NDVkMzZmYmI2OTMxZjcyYjA4Y2IxZWQ5NTRmMWUzY2UzZmY2JyxcbiAgICAgICAgJzQ2MmY5YmNlNjE5ODk4NjM4NDk5MzUwMTEzYmJjOWIxMGE4NzhkMzVkYTcwNzQwZGM2OTVhNTU5ZWI4OGRiN2InXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYmUyMDYyMDAzYzUxY2MzMDA0NjgyOTA0MzMwZTRkZWU3ZjNkY2QxMGIwMWU1ODBiZjE5NzFiMDRkNGNhZDI5NycsXG4gICAgICAgICc2MjE4OGJjNDlkNjFlNTQyODU3M2Q0OGE3NGUxYzY1NWIxYzYxMDkwOTA1NjgyYTBkNTU1OGVkNzJkY2NiOWJjJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzkzMTQ0NDIzYWNlMzQ1MWVkMjllMGZiOWFjMmFmMjExY2I2ZTg0YTYwMWRmNTk5M2M0MTk4NTlmZmY1ZGYwNGEnLFxuICAgICAgICAnN2MxMGRmYjE2NGMzNDI1ZjVjNzFhM2Y5ZDc5OTIwMzhmMTA2NTIyNGY3MmJiOWQxZDkwMmE2ZDEzMDM3YjQ3YydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdiMDE1ZjgwNDRmNWZjYmRjZjIxY2EyNmQ2YzM0ZmI4MTk3ODI5MjA1YzdiN2QyYTdjYjY2NDE4YzE1N2IxMTJjJyxcbiAgICAgICAgJ2FiOGMxZTA4NmQwNGU4MTM3NDRhNjU1YjJkZjhkNWY4M2IzY2RjNmZhYTMwODhjMWQzYWVhMTQ1NGUzYTFkNWYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZDVlOWUxZGE2NDlkOTdkODllNDg2ODExN2E0NjVhM2E0ZjhhMThkZTU3YTE0MGQzNmIzZjJhZjM0MWEyMWI1MicsXG4gICAgICAgICc0Y2IwNDQzN2YzOTFlZDczMTExYTEzY2MxZDRkZDBkYjE2OTM0NjVjMjI0MDQ4MGQ4OTU1ZTg1OTJmMjc0NDdhJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2QzYWU0MTA0N2RkN2NhMDY1ZGJmOGVkNzdiOTkyNDM5OTgzMDA1Y2Q3MmUxNmQ2Zjk5NmE1MzE2ZDM2OTY2YmInLFxuICAgICAgICAnYmQxYWViMjFhZDIyZWJiMjJhMTBmMDMwMzQxN2M2ZDk2NGY4Y2RkN2RmMGFjYTYxNGIxMGRjMTRkMTI1YWM0NidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc0NjNlMjc2M2Q4ODVmOTU4ZmM2NmNkZDIyODAwZjBhNDg3MTk3ZDBhODJlMzc3YjQ5ZjgwYWY4N2M4OTdiMDY1JyxcbiAgICAgICAgJ2JmZWZhY2RiMGU1ZDBmZDdkZjNhMzExYTk0ZGUwNjJiMjZiODBjNjFmYmM5NzUwOGI3OTk5MjY3MWVmN2NhN2YnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzk4NWZkZmQxMjdjMDU2N2M2ZjUzZWMxYmI2M2VjMzE1OGU1OTdjNDBiZmU3NDdjODNjZGRmYzkxMDY0MTkxNycsXG4gICAgICAgICc2MDNjMTJkYWYzZDk4NjJlZjJiMjVmZTFkZTI4OWFlZDI0ZWQyOTFlMGVjNjcwODcwM2E1YmQ1NjdmMzJlZDAzJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzc0YTFhZDZiNWY3NmUzOWRiMmRkMjQ5NDEwZWFjN2Y5OWU3NGM1OWNiODNkMmQwZWQ1ZmYxNTQzZGE3NzAzZTknLFxuICAgICAgICAnY2M2MTU3ZWYxOGM5YzYzY2Q2MTkzZDgzNjMxYmJlYTAwOTNlMDk2ODk0MmU4YzMzZDU3MzdmZDc5MGUwZGIwOCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczMDY4MmE1MDcwMzM3NWY2MDJkNDE2NjY0YmExOWI3ZmM5YmFiNDJjNzI3NDc0NjNhNzFkMDg5NmIyMmY2ZGEzJyxcbiAgICAgICAgJzU1M2UwNGY2YjAxOGI0ZmE2YzhmMzllN2YzMTFkMzE3NjI5MGQwZTBmMTljYTczZjE3NzE0ZDk5NzdhMjJmZjgnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOWUyMTU4ZjBkN2MwZDVmMjZjMzc5MWVmZWZhNzk1OTc2NTRlN2EyYjI0NjRmNTJiMWVlNmMxMzQ3NzY5ZWY1NycsXG4gICAgICAgICc3MTJmY2RkMWI5MDUzZjA5MDAzYTM0ODFmYTc3NjJlOWZmZDdjOGVmMzVhMzg1MDllMmZiZjI2MjkwMDgzNzMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMTc2ZTI2OTg5YTQzYzljZmViYTQwMjljMjAyNTM4YzI4MTcyZTU2NmUzYzRmY2U3MzIyODU3ZjNiZTMyN2Q2NicsXG4gICAgICAgICdlZDhjYzlkMDRiMjllYjg3N2QyNzBiNDg3OGRjNDNjMTlhZWZkMzFmNGVlZTA5ZWU3YjQ3ODM0YzFmYTRiMWMzJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzc1ZDQ2ZWZlYTM3NzFlNmU2OGFiYjg5YTEzYWQ3NDdlY2YxODkyMzkzZGZjNGYxYjcwMDQ3ODhjNTAzNzRkYTgnLFxuICAgICAgICAnOTg1MjM5MGE5OTUwNzY3OWZkMGI4NmZkMmIzOWE4NjhkN2VmYzIyMTUxMzQ2ZTFhM2NhNDcyNjU4NmE2YmVkOCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4MDlhMjBjNjdkNjQ5MDBmZmI2OThjNGM4MjVmNmQ1ZjIzMTBmYjA0NTFjODY5MzQ1YjczMTlmNjQ1NjA1NzIxJyxcbiAgICAgICAgJzllOTk0OTgwZDk5MTdlMjJiNzZiMDYxOTI3ZmEwNDE0M2QwOTZjY2M1NDk2M2U2YTVlYmZhNWYzZjhlMjg2YzEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMWIzODkwM2E0M2Y3ZjExNGVkNDUwMGI0ZWFjNzA4M2ZkZWZlY2UxY2YyOWM2MzUyOGQ1NjM0NDZmOTcyYzE4MCcsXG4gICAgICAgICc0MDM2ZWRjOTMxYTYwYWU4ODkzNTNmNzdmZDUzZGU0YTI3MDhiMjZiNmY1ZGE3MmFkMzM5NDExOWRhZjQwOGY5J1xuICAgICAgXVxuICAgIF1cbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gZXhwb3J0cztcbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG52YXIgbWluQXNzZXJ0ID0gcmVxdWlyZSgnbWluaW1hbGlzdGljLWFzc2VydCcpO1xudmFyIG1pblV0aWxzID0gcmVxdWlyZSgnbWluaW1hbGlzdGljLWNyeXB0by11dGlscycpO1xuXG51dGlscy5hc3NlcnQgPSBtaW5Bc3NlcnQ7XG51dGlscy50b0FycmF5ID0gbWluVXRpbHMudG9BcnJheTtcbnV0aWxzLnplcm8yID0gbWluVXRpbHMuemVybzI7XG51dGlscy50b0hleCA9IG1pblV0aWxzLnRvSGV4O1xudXRpbHMuZW5jb2RlID0gbWluVXRpbHMuZW5jb2RlO1xuXG4vLyBSZXByZXNlbnQgbnVtIGluIGEgdy1OQUYgZm9ybVxuZnVuY3Rpb24gZ2V0TkFGKG51bSwgdykge1xuICB2YXIgbmFmID0gW107XG4gIHZhciB3cyA9IDEgPDwgKHcgKyAxKTtcbiAgdmFyIGsgPSBudW0uY2xvbmUoKTtcbiAgd2hpbGUgKGsuY21wbigxKSA+PSAwKSB7XG4gICAgdmFyIHo7XG4gICAgaWYgKGsuaXNPZGQoKSkge1xuICAgICAgdmFyIG1vZCA9IGsuYW5kbG4od3MgLSAxKTtcbiAgICAgIGlmIChtb2QgPiAod3MgPj4gMSkgLSAxKVxuICAgICAgICB6ID0gKHdzID4+IDEpIC0gbW9kO1xuICAgICAgZWxzZVxuICAgICAgICB6ID0gbW9kO1xuICAgICAgay5pc3Vibih6KTtcbiAgICB9IGVsc2Uge1xuICAgICAgeiA9IDA7XG4gICAgfVxuICAgIG5hZi5wdXNoKHopO1xuXG4gICAgLy8gT3B0aW1pemF0aW9uLCBzaGlmdCBieSB3b3JkIGlmIHBvc3NpYmxlXG4gICAgdmFyIHNoaWZ0ID0gKGsuY21wbigwKSAhPT0gMCAmJiBrLmFuZGxuKHdzIC0gMSkgPT09IDApID8gKHcgKyAxKSA6IDE7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBzaGlmdDsgaSsrKVxuICAgICAgbmFmLnB1c2goMCk7XG4gICAgay5pdXNocm4oc2hpZnQpO1xuICB9XG5cbiAgcmV0dXJuIG5hZjtcbn1cbnV0aWxzLmdldE5BRiA9IGdldE5BRjtcblxuLy8gUmVwcmVzZW50IGsxLCBrMiBpbiBhIEpvaW50IFNwYXJzZSBGb3JtXG5mdW5jdGlvbiBnZXRKU0YoazEsIGsyKSB7XG4gIHZhciBqc2YgPSBbXG4gICAgW10sXG4gICAgW11cbiAgXTtcblxuICBrMSA9IGsxLmNsb25lKCk7XG4gIGsyID0gazIuY2xvbmUoKTtcbiAgdmFyIGQxID0gMDtcbiAgdmFyIGQyID0gMDtcbiAgd2hpbGUgKGsxLmNtcG4oLWQxKSA+IDAgfHwgazIuY21wbigtZDIpID4gMCkge1xuXG4gICAgLy8gRmlyc3QgcGhhc2VcbiAgICB2YXIgbTE0ID0gKGsxLmFuZGxuKDMpICsgZDEpICYgMztcbiAgICB2YXIgbTI0ID0gKGsyLmFuZGxuKDMpICsgZDIpICYgMztcbiAgICBpZiAobTE0ID09PSAzKVxuICAgICAgbTE0ID0gLTE7XG4gICAgaWYgKG0yNCA9PT0gMylcbiAgICAgIG0yNCA9IC0xO1xuICAgIHZhciB1MTtcbiAgICBpZiAoKG0xNCAmIDEpID09PSAwKSB7XG4gICAgICB1MSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBtOCA9IChrMS5hbmRsbig3KSArIGQxKSAmIDc7XG4gICAgICBpZiAoKG04ID09PSAzIHx8IG04ID09PSA1KSAmJiBtMjQgPT09IDIpXG4gICAgICAgIHUxID0gLW0xNDtcbiAgICAgIGVsc2VcbiAgICAgICAgdTEgPSBtMTQ7XG4gICAgfVxuICAgIGpzZlswXS5wdXNoKHUxKTtcblxuICAgIHZhciB1MjtcbiAgICBpZiAoKG0yNCAmIDEpID09PSAwKSB7XG4gICAgICB1MiA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBtOCA9IChrMi5hbmRsbig3KSArIGQyKSAmIDc7XG4gICAgICBpZiAoKG04ID09PSAzIHx8IG04ID09PSA1KSAmJiBtMTQgPT09IDIpXG4gICAgICAgIHUyID0gLW0yNDtcbiAgICAgIGVsc2VcbiAgICAgICAgdTIgPSBtMjQ7XG4gICAgfVxuICAgIGpzZlsxXS5wdXNoKHUyKTtcblxuICAgIC8vIFNlY29uZCBwaGFzZVxuICAgIGlmICgyICogZDEgPT09IHUxICsgMSlcbiAgICAgIGQxID0gMSAtIGQxO1xuICAgIGlmICgyICogZDIgPT09IHUyICsgMSlcbiAgICAgIGQyID0gMSAtIGQyO1xuICAgIGsxLml1c2hybigxKTtcbiAgICBrMi5pdXNocm4oMSk7XG4gIH1cblxuICByZXR1cm4ganNmO1xufVxudXRpbHMuZ2V0SlNGID0gZ2V0SlNGO1xuXG5mdW5jdGlvbiBjYWNoZWRQcm9wZXJ0eShvYmosIG5hbWUsIGNvbXB1dGVyKSB7XG4gIHZhciBrZXkgPSAnXycgKyBuYW1lO1xuICBvYmoucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24gY2FjaGVkUHJvcGVydHkoKSB7XG4gICAgcmV0dXJuIHRoaXNba2V5XSAhPT0gdW5kZWZpbmVkID8gdGhpc1trZXldIDpcbiAgICAgICAgICAgdGhpc1trZXldID0gY29tcHV0ZXIuY2FsbCh0aGlzKTtcbiAgfTtcbn1cbnV0aWxzLmNhY2hlZFByb3BlcnR5ID0gY2FjaGVkUHJvcGVydHk7XG5cbmZ1bmN0aW9uIHBhcnNlQnl0ZXMoYnl0ZXMpIHtcbiAgcmV0dXJuIHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycgPyB1dGlscy50b0FycmF5KGJ5dGVzLCAnaGV4JykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzO1xufVxudXRpbHMucGFyc2VCeXRlcyA9IHBhcnNlQnl0ZXM7XG5cbmZ1bmN0aW9uIGludEZyb21MRShieXRlcykge1xuICByZXR1cm4gbmV3IEJOKGJ5dGVzLCAnaGV4JywgJ2xlJyk7XG59XG51dGlscy5pbnRGcm9tTEUgPSBpbnRGcm9tTEU7XG5cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSID0gdHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnID8gUmVmbGVjdCA6IG51bGxcbnZhciBSZWZsZWN0QXBwbHkgPSBSICYmIHR5cGVvZiBSLmFwcGx5ID09PSAnZnVuY3Rpb24nXG4gID8gUi5hcHBseVxuICA6IGZ1bmN0aW9uIFJlZmxlY3RBcHBseSh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpO1xuICB9XG5cbnZhciBSZWZsZWN0T3duS2V5c1xuaWYgKFIgJiYgdHlwZW9mIFIub3duS2V5cyA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWZsZWN0T3duS2V5cyA9IFIub3duS2V5c1xufSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldClcbiAgICAgIC5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpKTtcbiAgfTtcbn0gZWxzZSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFByb2Nlc3NFbWl0V2FybmluZyh3YXJuaW5nKSB7XG4gIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2FybikgY29uc29sZS53YXJuKHdhcm5pbmcpO1xufVxuXG52YXIgTnVtYmVySXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gTnVtYmVySXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBFdmVudEVtaXR0ZXIuaW5pdC5jYWxsKHRoaXMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzQ291bnQgPSAwO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG52YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRFbWl0dGVyLCAnZGVmYXVsdE1heExpc3RlbmVycycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZGVmYXVsdE1heExpc3RlbmVycztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbihhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ251bWJlcicgfHwgYXJnIDwgMCB8fCBOdW1iZXJJc05hTihhcmcpKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiZGVmYXVsdE1heExpc3RlbmVyc1wiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBhcmcgKyAnLicpO1xuICAgIH1cbiAgICBkZWZhdWx0TWF4TGlzdGVuZXJzID0gYXJnO1xuICB9XG59KTtcblxuRXZlbnRFbWl0dGVyLmluaXQgPSBmdW5jdGlvbigpIHtcblxuICBpZiAodGhpcy5fZXZlbnRzID09PSB1bmRlZmluZWQgfHxcbiAgICAgIHRoaXMuX2V2ZW50cyA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLl9ldmVudHMpIHtcbiAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59O1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikge1xuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPCAwIHx8IE51bWJlcklzTmFOKG4pKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcIm5cIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgbiArICcuJyk7XG4gIH1cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiAkZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHtcbiAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVycztcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiAkZ2V0TWF4TGlzdGVuZXJzKHRoaXMpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCh0eXBlKSB7XG4gIHZhciBhcmdzID0gW107XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgdmFyIGRvRXJyb3IgPSAodHlwZSA9PT0gJ2Vycm9yJyk7XG5cbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKVxuICAgIGRvRXJyb3IgPSAoZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT09IHVuZGVmaW5lZCk7XG4gIGVsc2UgaWYgKCFkb0Vycm9yKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmIChkb0Vycm9yKSB7XG4gICAgdmFyIGVyO1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDApXG4gICAgICBlciA9IGFyZ3NbMF07XG4gICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIC8vIE5vdGU6IFRoZSBjb21tZW50cyBvbiB0aGUgYHRocm93YCBsaW5lcyBhcmUgaW50ZW50aW9uYWwsIHRoZXkgc2hvd1xuICAgICAgLy8gdXAgaW4gTm9kZSdzIG91dHB1dCBpZiB0aGlzIHJlc3VsdHMgaW4gYW4gdW5oYW5kbGVkIGV4Y2VwdGlvbi5cbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgIH1cbiAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5oYW5kbGVkIGVycm9yLicgKyAoZXIgPyAnICgnICsgZXIubWVzc2FnZSArICcpJyA6ICcnKSk7XG4gICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICB0aHJvdyBlcnI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gIH1cblxuICB2YXIgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTtcblxuICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBSZWZsZWN0QXBwbHkoaGFuZGxlciwgdGhpcywgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIFJlZmxlY3RBcHBseShsaXN0ZW5lcnNbaV0sIHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBfYWRkTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xuICB2YXIgbTtcbiAgdmFyIGV2ZW50cztcbiAgdmFyIGV4aXN0aW5nO1xuXG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgfVxuXG4gIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGFyZ2V0Ll9ldmVudHNDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gICAgaWYgKGV2ZW50cy5uZXdMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0YXJnZXQuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgPyBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICAgICAgLy8gUmUtYXNzaWduIGBldmVudHNgIGJlY2F1c2UgYSBuZXdMaXN0ZW5lciBoYW5kbGVyIGNvdWxkIGhhdmUgY2F1c2VkIHRoZVxuICAgICAgLy8gdGhpcy5fZXZlbnRzIHRvIGJlIGFzc2lnbmVkIHRvIGEgbmV3IG9iamVjdFxuICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gICAgfVxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdO1xuICB9XG5cbiAgaWYgKGV4aXN0aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID1cbiAgICAgICAgcHJlcGVuZCA/IFtsaXN0ZW5lciwgZXhpc3RpbmddIDogW2V4aXN0aW5nLCBsaXN0ZW5lcl07XG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgfSBlbHNlIGlmIChwcmVwZW5kKSB7XG4gICAgICBleGlzdGluZy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhpc3RpbmcucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgICBtID0gJGdldE1heExpc3RlbmVycyh0YXJnZXQpO1xuICAgIGlmIChtID4gMCAmJiBleGlzdGluZy5sZW5ndGggPiBtICYmICFleGlzdGluZy53YXJuZWQpIHtcbiAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7XG4gICAgICAvLyBObyBlcnJvciBjb2RlIGZvciB0aGlzIHNpbmNlIGl0IGlzIGEgV2FybmluZ1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICB2YXIgdyA9IG5ldyBFcnJvcignUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcubGVuZ3RoICsgJyAnICsgU3RyaW5nKHR5cGUpICsgJyBsaXN0ZW5lcnMgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdpbmNyZWFzZSBsaW1pdCcpO1xuICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgICB3LmVtaXR0ZXIgPSB0YXJnZXQ7XG4gICAgICB3LnR5cGUgPSB0eXBlO1xuICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDtcbiAgICAgIFByb2Nlc3NFbWl0V2FybmluZyh3KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG5cbmZ1bmN0aW9uIG9uY2VXcmFwcGVyKCkge1xuICB2YXIgYXJncyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gIGlmICghdGhpcy5maXJlZCkge1xuICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pO1xuICAgIHRoaXMuZmlyZWQgPSB0cnVlO1xuICAgIFJlZmxlY3RBcHBseSh0aGlzLmxpc3RlbmVyLCB0aGlzLnRhcmdldCwgYXJncyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHN0YXRlID0geyBmaXJlZDogZmFsc2UsIHdyYXBGbjogdW5kZWZpbmVkLCB0YXJnZXQ6IHRhcmdldCwgdHlwZTogdHlwZSwgbGlzdGVuZXI6IGxpc3RlbmVyIH07XG4gIHZhciB3cmFwcGVkID0gb25jZVdyYXBwZXIuYmluZChzdGF0ZSk7XG4gIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgc3RhdGUud3JhcEZuID0gd3JhcHBlZDtcbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICB9XG4gIHRoaXMub24odHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgdGhpcy5wcmVwZW5kTGlzdGVuZXIodHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4vLyBFbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWYgYW5kIG9ubHkgaWYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBsaXN0LCBldmVudHMsIHBvc2l0aW9uLCBpLCBvcmlnaW5hbExpc3RlbmVyO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBsaXN0ID0gZXZlbnRzW3R5cGVdO1xuICAgICAgaWYgKGxpc3QgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fCBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcG9zaXRpb24gPSAtMTtcblxuICAgICAgICBmb3IgKGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBvcmlnaW5hbExpc3RlbmVyID0gbGlzdFtpXS5saXN0ZW5lcjtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAwKVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc3BsaWNlT25lKGxpc3QsIHBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICBldmVudHNbdHlwZV0gPSBsaXN0WzBdO1xuXG4gICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgb3JpZ2luYWxMaXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyh0eXBlKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzLCBldmVudHMsIGk7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50c1t0eXBlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhldmVudHMpO1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gICAgICB9IGVsc2UgaWYgKGxpc3RlbmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIExJRk8gb3JkZXJcbiAgICAgICAgZm9yIChpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbmZ1bmN0aW9uIF9saXN0ZW5lcnModGFyZ2V0LCB0eXBlLCB1bndyYXApIHtcbiAgdmFyIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG4gIGlmIChldmxpc3RlbmVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJylcbiAgICByZXR1cm4gdW53cmFwID8gW2V2bGlzdGVuZXIubGlzdGVuZXIgfHwgZXZsaXN0ZW5lcl0gOiBbZXZsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIHVud3JhcCA/XG4gICAgdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpIDogYXJyYXlDbG9uZShldmxpc3RlbmVyLCBldmxpc3RlbmVyLmxlbmd0aCk7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgdHJ1ZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJhd0xpc3RlbmVycyA9IGZ1bmN0aW9uIHJhd0xpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlKTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudDtcbmZ1bmN0aW9uIGxpc3RlbmVyQ291bnQodHlwZSkge1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGV2bGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICByZXR1cm4gdGhpcy5fZXZlbnRzQ291bnQgPiAwID8gUmVmbGVjdE93bktleXModGhpcy5fZXZlbnRzKSA6IFtdO1xufTtcblxuZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIsIG4pIHtcbiAgdmFyIGNvcHkgPSBuZXcgQXJyYXkobik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKVxuICAgIGNvcHlbaV0gPSBhcnJbaV07XG4gIHJldHVybiBjb3B5O1xufVxuXG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgZm9yICg7IGluZGV4ICsgMSA8IGxpc3QubGVuZ3RoOyBpbmRleCsrKVxuICAgIGxpc3RbaW5kZXhdID0gbGlzdFtpbmRleCArIDFdO1xuICBsaXN0LnBvcCgpO1xufVxuXG5mdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuIiwidmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG52YXIgTUQ1ID0gcmVxdWlyZSgnbWQ1LmpzJylcblxuLyogZXNsaW50LWRpc2FibGUgY2FtZWxjYXNlICovXG5mdW5jdGlvbiBFVlBfQnl0ZXNUb0tleSAocGFzc3dvcmQsIHNhbHQsIGtleUJpdHMsIGl2TGVuKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHBhc3N3b3JkKSkgcGFzc3dvcmQgPSBCdWZmZXIuZnJvbShwYXNzd29yZCwgJ2JpbmFyeScpXG4gIGlmIChzYWx0KSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoc2FsdCkpIHNhbHQgPSBCdWZmZXIuZnJvbShzYWx0LCAnYmluYXJ5JylcbiAgICBpZiAoc2FsdC5sZW5ndGggIT09IDgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzYWx0IHNob3VsZCBiZSBCdWZmZXIgd2l0aCA4IGJ5dGUgbGVuZ3RoJylcbiAgfVxuXG4gIHZhciBrZXlMZW4gPSBrZXlCaXRzIC8gOFxuICB2YXIga2V5ID0gQnVmZmVyLmFsbG9jKGtleUxlbilcbiAgdmFyIGl2ID0gQnVmZmVyLmFsbG9jKGl2TGVuIHx8IDApXG4gIHZhciB0bXAgPSBCdWZmZXIuYWxsb2MoMClcblxuICB3aGlsZSAoa2V5TGVuID4gMCB8fCBpdkxlbiA+IDApIHtcbiAgICB2YXIgaGFzaCA9IG5ldyBNRDUoKVxuICAgIGhhc2gudXBkYXRlKHRtcClcbiAgICBoYXNoLnVwZGF0ZShwYXNzd29yZClcbiAgICBpZiAoc2FsdCkgaGFzaC51cGRhdGUoc2FsdClcbiAgICB0bXAgPSBoYXNoLmRpZ2VzdCgpXG5cbiAgICB2YXIgdXNlZCA9IDBcblxuICAgIGlmIChrZXlMZW4gPiAwKSB7XG4gICAgICB2YXIga2V5U3RhcnQgPSBrZXkubGVuZ3RoIC0ga2V5TGVuXG4gICAgICB1c2VkID0gTWF0aC5taW4oa2V5TGVuLCB0bXAubGVuZ3RoKVxuICAgICAgdG1wLmNvcHkoa2V5LCBrZXlTdGFydCwgMCwgdXNlZClcbiAgICAgIGtleUxlbiAtPSB1c2VkXG4gICAgfVxuXG4gICAgaWYgKHVzZWQgPCB0bXAubGVuZ3RoICYmIGl2TGVuID4gMCkge1xuICAgICAgdmFyIGl2U3RhcnQgPSBpdi5sZW5ndGggLSBpdkxlblxuICAgICAgdmFyIGxlbmd0aCA9IE1hdGgubWluKGl2TGVuLCB0bXAubGVuZ3RoIC0gdXNlZClcbiAgICAgIHRtcC5jb3B5KGl2LCBpdlN0YXJ0LCB1c2VkLCB1c2VkICsgbGVuZ3RoKVxuICAgICAgaXZMZW4gLT0gbGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdG1wLmZpbGwoMClcbiAgcmV0dXJuIHsga2V5OiBrZXksIGl2OiBpdiB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRVZQX0J5dGVzVG9LZXlcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IFZpY3RvciBEaWJpYS5cbiAqIEhhbmR0cmFjay5qcyAtIEEgbGlicmFyeSBmb3IgcHJvdG90eXBpbmcgcmVhbHRpbWUgaGFuZCB0cmFja2luZyB1c2luZyBuZXVyYWwgbmV0d29ya3MuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKHRoZSBcIkxpY2Vuc2VcIik7IFxuICogQ29kZSBzbmlwcGV0cyBmcm9tIHRoZSB0ZW5zb3JmbG93IGNvY28tc3NkIGV4YW1wbGUgYXJlIHJldXNlZCBoZXJlIC0gaHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvdGZqcy1tb2RlbHMvdHJlZS9tYXN0ZXIvY29jby1zc2RcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuXG5pbXBvcnQgKiBhcyB0ZiBmcm9tICdAdGVuc29yZmxvdy90ZmpzJztcblxuLy8gY29uc3QgYmFzZVBhdGggPSBcImh0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vaGFuZHRyYWNranMvbW9kZWxzL3dlYi9cIlxuY29uc3QgYmFzZVBhdGggPSBcImh0dHA6Ly9sb2NhbGhvc3Q6ODA4MC9cIlxuXG5jb25zdCBkZWZhdWx0UGFyYW1zID0ge1xuICBmbGlwSG9yaXpvbnRhbDogdHJ1ZSxcbiAgb3V0cHV0U3RyaWRlOiAxNixcbiAgaW1hZ2VTY2FsZUZhY3RvcjogMC43LFxuICBtYXhOdW1Cb3hlczogMjAsXG4gIGlvdVRocmVzaG9sZDogMC41LFxuICBzY29yZVRocmVzaG9sZDogMC45OSxcbiAgbW9kZWxUeXBlOiBcInNzZGxpdGVtb2JpbGVuZXR2MlwiXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsb2FkKHBhcmFtcykge1xuICBsZXQgbW9kZWxQYXJhbXMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0UGFyYW1zLCBwYXJhbXMpO1xuICAvLyBjb25zb2xlLmxvZyhtb2RlbFBhcmFtcykgXG4gIGNvbnN0IG9iamVjdERldGVjdGlvbiA9IG5ldyBPYmplY3REZXRlY3Rpb24obW9kZWxQYXJhbXMpO1xuICBhd2FpdCBvYmplY3REZXRlY3Rpb24ubG9hZCgpO1xuICByZXR1cm4gKG9iamVjdERldGVjdGlvbik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdGFydFZpZGVvKHZpZGVvKSB7XG4gIC8vIFZpZGVvIG11c3QgaGF2ZSBoZWlnaHQgYW5kIHdpZHRoIGluIG9yZGVyIHRvIGJlIHVzZWQgYXMgaW5wdXQgZm9yIE5OXG4gIC8vIEFzcGVjdCByYXRpbyBvZiAzLzQgaXMgdXNlZCB0byBzdXBwb3J0IHNhZmFyaSBicm93c2VyLlxuICB2aWRlby53aWR0aCA9IHZpZGVvLndpZHRoIHx8IDY0MDtcbiAgdmlkZW8uaGVpZ2h0ID0gdmlkZW8uaGVpZ2h0IHx8IHZpZGVvLndpZHRoICogKDMgLyA0KVxuXG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlc1xuICAgICAgLmdldFVzZXJNZWRpYSh7XG4gICAgICAgIGF1ZGlvOiBmYWxzZSxcbiAgICAgICAgdmlkZW86IHtcbiAgICAgICAgICBmYWNpbmdNb2RlOiBcInVzZXJcIlxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLnRoZW4oc3RyZWFtID0+IHtcbiAgICAgICAgd2luZG93LmxvY2FsU3RyZWFtID0gc3RyZWFtO1xuICAgICAgICB2aWRlby5zcmNPYmplY3QgPSBzdHJlYW1cbiAgICAgICAgdmlkZW8ub25sb2FkZWRtZXRhZGF0YSA9ICgpID0+IHtcbiAgICAgICAgICB2aWRlby5wbGF5KClcbiAgICAgICAgICByZXNvbHZlKHRydWUpXG4gICAgICAgIH1cbiAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgcmVzb2x2ZShmYWxzZSlcbiAgICAgIH0pO1xuICB9KTtcblxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc3RvcFZpZGVvKCkge1xuICBpZiAod2luZG93LmxvY2FsU3RyZWFtKSB7XG4gICAgd2luZG93LmxvY2FsU3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2goKHRyYWNrKSA9PiB7XG4gICAgICB0cmFjay5zdG9wKCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIE9iamVjdERldGVjdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG1vZGVsUGFyYW1zKSB7XG4gICAgdGhpcy5tb2RlbFBhdGggPSBiYXNlUGF0aCArIG1vZGVsUGFyYW1zLm1vZGVsVHlwZSArIFwiL3RlbnNvcmZsb3dqc19tb2RlbC5wYlwiO1xuICAgIHRoaXMud2VpZ2h0UGF0aCA9IGJhc2VQYXRoICsgbW9kZWxQYXJhbXMubW9kZWxUeXBlICsgXCIvd2VpZ2h0c19tYW5pZmVzdC5qc29uXCI7XG4gICAgdGhpcy5tb2RlbFBhcmFtcyA9IG1vZGVsUGFyYW1zXG4gIH1cblxuICBhc3luYyBsb2FkKCkge1xuICAgIHRoaXMuZnBzID0gMFxuICAgIHRoaXMubW9kZWwgPSBhd2FpdCB0Zi5sb2FkRnJvemVuTW9kZWwodGhpcy5tb2RlbFBhdGgsIHRoaXMud2VpZ2h0UGF0aCk7XG5cbiAgICAvLyBXYXJtdXAgdGhlIG1vZGVsLlxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMubW9kZWwuZXhlY3V0ZUFzeW5jKHRmLnplcm9zKFsxLCAzMDAsIDMwMCwgM10pKTtcbiAgICByZXN1bHQubWFwKGFzeW5jICh0KSA9PiBhd2FpdCB0LmRhdGEoKSk7XG4gICAgcmVzdWx0Lm1hcChhc3luYyAodCkgPT4gdC5kaXNwb3NlKCkpO1xuICAgIC8vIGNvbnNvbGUubG9nKFwibW9kZWwgbG9hZGVkIGFuZCB3YXJtZWQgdXBcIilcbiAgfVxuXG4gIGFzeW5jIGRldGVjdChpbnB1dCkge1xuXG4gICAgbGV0IHRpbWVCZWdpbiA9IERhdGUubm93KClcbiAgICBjb25zdCBbaGVpZ2h0LCB3aWR0aF0gPSBnZXRJbnB1dFRlbnNvckRpbWVuc2lvbnMoaW5wdXQpO1xuICAgIGNvbnN0IHJlc2l6ZWRIZWlnaHQgPSBnZXRWYWxpZFJlc29sdXRpb24odGhpcy5tb2RlbFBhcmFtcy5pbWFnZVNjYWxlRmFjdG9yLCBoZWlnaHQsIHRoaXMubW9kZWxQYXJhbXMub3V0cHV0U3RyaWRlKTtcbiAgICBjb25zdCByZXNpemVkV2lkdGggPSBnZXRWYWxpZFJlc29sdXRpb24odGhpcy5tb2RlbFBhcmFtcy5pbWFnZVNjYWxlRmFjdG9yLCB3aWR0aCwgdGhpcy5tb2RlbFBhcmFtcy5vdXRwdXRTdHJpZGUpO1xuXG4gICAgY29uc3QgYmF0Y2hlZCA9IHRmLnRpZHkoKCkgPT4ge1xuICAgICAgY29uc3QgaW1hZ2VUZW5zb3IgPSB0Zi5mcm9tUGl4ZWxzKGlucHV0KVxuICAgICAgaWYgKHRoaXMubW9kZWxQYXJhbXMuZmxpcEhvcml6b250YWwpIHtcbiAgICAgICAgcmV0dXJuIGltYWdlVGVuc29yLnJldmVyc2UoMSkucmVzaXplQmlsaW5lYXIoW3Jlc2l6ZWRIZWlnaHQsIHJlc2l6ZWRXaWR0aF0pLmV4cGFuZERpbXMoMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaW1hZ2VUZW5zb3IucmVzaXplQmlsaW5lYXIoW3Jlc2l6ZWRIZWlnaHQsIHJlc2l6ZWRXaWR0aF0pLmV4cGFuZERpbXMoMCk7XG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMubW9kZWwuZXhlY3V0ZUFzeW5jKGJhdGNoZWQpO1xuICAgIHNlbGYgPSB0aGlzXG4gICAgcmV0dXJuIHRoaXMubW9kZWwuZXhlY3V0ZUFzeW5jKGJhdGNoZWQpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuXG5cbiAgICAgIGNvbnN0IHNjb3JlcyA9IHJlc3VsdFswXS5kYXRhU3luYygpXG4gICAgICBjb25zdCBib3hlcyA9IHJlc3VsdFsxXS5kYXRhU3luYygpXG5cbiAgICAgIC8vIGNsZWFuIHRoZSB3ZWJnbCB0ZW5zb3JzXG4gICAgICBiYXRjaGVkLmRpc3Bvc2UoKVxuICAgICAgdGYuZGlzcG9zZShyZXN1bHQpXG5cbiAgICAgIC8vIGNvbnNvbGUubG9nKFwic2NvcmVzIHJlc3VsdFwiLHNjb3JlcywgYm94ZXMpXG5cbiAgICAgIGNvbnN0IFttYXhTY29yZXMsIGNsYXNzZXNdID0gY2FsY3VsYXRlTWF4U2NvcmVzKHNjb3JlcywgcmVzdWx0WzBdLnNoYXBlWzFdLCByZXN1bHRbMF0uc2hhcGVbMl0pO1xuICAgICAgY29uc3QgcHJldkJhY2tlbmQgPSB0Zi5nZXRCYWNrZW5kKClcbiAgICAgIC8vIHJ1biBwb3N0IHByb2Nlc3MgaW4gY3B1XG4gICAgICB0Zi5zZXRCYWNrZW5kKCdjcHUnKVxuICAgICAgY29uc3QgaW5kZXhUZW5zb3IgPSB0Zi50aWR5KCgpID0+IHtcbiAgICAgICAgY29uc3QgYm94ZXMyID0gdGYudGVuc29yMmQoYm94ZXMsIFtcbiAgICAgICAgICByZXN1bHRbMV0uc2hhcGVbMV0sXG4gICAgICAgICAgcmVzdWx0WzFdLnNoYXBlWzNdXG4gICAgICAgIF0pXG4gICAgICAgIHJldHVybiB0Zi5pbWFnZS5ub25NYXhTdXBwcmVzc2lvbihcbiAgICAgICAgICBib3hlczIsXG4gICAgICAgICAgc2NvcmVzLFxuICAgICAgICAgIHNlbGYubW9kZWxQYXJhbXMubWF4TnVtQm94ZXMsIC8vIG1heE51bUJveGVzXG4gICAgICAgICAgc2VsZi5tb2RlbFBhcmFtcy5pb3VUaHJlc2hvbGQsIC8vIGlvdV90aHJlc2hvbGRcbiAgICAgICAgICBzZWxmLm1vZGVsUGFyYW1zLnNjb3JlVGhyZXNob2xkIC8vIHNjb3JlX3RocmVzaG9sZFxuICAgICAgICApXG4gICAgICB9KVxuICAgICAgY29uc3QgaW5kZXhlcyA9IGluZGV4VGVuc29yLmRhdGFTeW5jKClcbiAgICAgIGluZGV4VGVuc29yLmRpc3Bvc2UoKVxuICAgICAgLy8gcmVzdG9yZSBwcmV2aW91cyBiYWNrZW5kXG4gICAgICB0Zi5zZXRCYWNrZW5kKHByZXZCYWNrZW5kKVxuXG4gICAgICBjb25zdCBwcmVkaWN0aW9ucyA9IHNlbGYuYnVpbGREZXRlY3RlZE9iamVjdHMoXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIGJveGVzLFxuICAgICAgICBzY29yZXMsXG4gICAgICAgIGluZGV4ZXMsXG4gICAgICAgIGNsYXNzZXNcbiAgICAgIClcbiAgICAgIGxldCB0aW1lRW5kID0gRGF0ZS5ub3coKVxuICAgICAgc2VsZi5mcHMgPSBNYXRoLnJvdW5kKDEwMDAgLyAodGltZUVuZCAtIHRpbWVCZWdpbikpXG5cbiAgICAgIHJldHVybiBwcmVkaWN0aW9uc1xuXG4gICAgfSlcblxuICB9XG5cbiAgYnVpbGREZXRlY3RlZE9iamVjdHMod2lkdGgsIGhlaWdodCwgYm94ZXMsIHNjb3JlcywgaW5kZXhlcywgY2xhc3Nlcykge1xuICAgIGNvbnN0IGNvdW50ID0gaW5kZXhlcy5sZW5ndGhcbiAgICBjb25zdCBvYmplY3RzID0gW11cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IGJib3ggPSBbXVxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCA0OyBqKyspIHtcbiAgICAgICAgYmJveFtqXSA9IGJveGVzW2luZGV4ZXNbaV0gKiA0ICsgal1cbiAgICAgIH1cbiAgICAgIGNvbnN0IG1pblkgPSBiYm94WzBdICogaGVpZ2h0XG4gICAgICBjb25zdCBtaW5YID0gYmJveFsxXSAqIHdpZHRoXG4gICAgICBjb25zdCBtYXhZID0gYmJveFsyXSAqIGhlaWdodFxuICAgICAgY29uc3QgbWF4WCA9IGJib3hbM10gKiB3aWR0aFxuICAgICAgYmJveFswXSA9IG1pblhcbiAgICAgIGJib3hbMV0gPSBtaW5ZXG4gICAgICBiYm94WzJdID0gbWF4WCAtIG1pblhcbiAgICAgIGJib3hbM10gPSBtYXhZIC0gbWluWVxuICAgICAgb2JqZWN0cy5wdXNoKHtcbiAgICAgICAgYmJveDogYmJveCxcbiAgICAgICAgY2xhc3M6IGNsYXNzZXNbaW5kZXhlc1tpXV0sXG4gICAgICAgIHNjb3JlOiBzY29yZXNbaW5kZXhlc1tpXV1cbiAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiBvYmplY3RzXG4gIH1cblxuICBnZXRGUFMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZnBzO1xuICB9XG5cbiAgc2V0TW9kZWxQYXJhbWV0ZXJzKHBhcmFtcykge1xuICAgIHRoaXMubW9kZWxQYXJhbXMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm1vZGVsUGFyYW1zLCBwYXJhbXMpO1xuICB9XG5cbiAgZ2V0TW9kZWxQYXJhbWV0ZXJzKCkge1xuICAgIHJldHVybiB0aGlzLm1vZGVsUGFyYW1zO1xuICB9XG5cbiAgcmVuZGVyUHJlZGljdGlvbnMocHJlZGljdGlvbnMsIGNhbnZhcywgY29udGV4dCwgbWVkaWFzb3VyY2UpIHtcblxuICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgY2FudmFzLndpZHRoID0gbWVkaWFzb3VyY2Uud2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IG1lZGlhc291cmNlLmhlaWdodDtcbiAgICAvLyBjb25zb2xlLmxvZyhcInJlbmRlclwiLCBtZWRpYXNvdXJjZS53aWR0aCwgbWVkaWFzb3VyY2UuaGVpZ2h0KVxuXG4gICAgY29udGV4dC5zYXZlKCk7XG4gICAgaWYgKHRoaXMubW9kZWxQYXJhbXMuZmxpcEhvcml6b250YWwpIHtcbiAgICAgIGNvbnRleHQuc2NhbGUoLTEsIDEpO1xuICAgICAgY29udGV4dC50cmFuc2xhdGUoLW1lZGlhc291cmNlLndpZHRoLCAwKTtcbiAgICB9XG4gICAgY29udGV4dC5kcmF3SW1hZ2UobWVkaWFzb3VyY2UsIDAsIDAsIG1lZGlhc291cmNlLndpZHRoLCBtZWRpYXNvdXJjZS5oZWlnaHQpO1xuICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgIGNvbnRleHQuZm9udCA9ICcxMHB4IEFyaWFsJztcblxuICAgIC8vIGNvbnNvbGUubG9nKCdudW1iZXIgb2YgZGV0ZWN0aW9uczogJywgcHJlZGljdGlvbnMubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZWRpY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBcInJnYmEoMjU1LCAyNTUsIDI1NSwgMC42KVwiO1xuICAgICAgY29udGV4dC5maWxsUmVjdChwcmVkaWN0aW9uc1tpXS5iYm94WzBdLCBwcmVkaWN0aW9uc1tpXS5iYm94WzFdIC0gMTcsIHByZWRpY3Rpb25zW2ldLmJib3hbMl0sIDE3KVxuICAgICAgY29udGV4dC5yZWN0KC4uLnByZWRpY3Rpb25zW2ldLmJib3gpO1xuXG4gICAgICAvLyBkcmF3IGEgZG90IGF0IHRoZSBjZW50ZXIgb2YgYm91bmRpbmcgYm94XG5cblxuICAgICAgY29udGV4dC5saW5lV2lkdGggPSAxO1xuICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9ICcjMDA2M0ZGJztcbiAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gXCIjMDA2M0ZGXCIgLy8gXCJyZ2JhKDI0NCwyNDcsMjUxLDEpXCI7XG4gICAgICBjb250ZXh0LmZpbGxSZWN0KHByZWRpY3Rpb25zW2ldLmJib3hbMF0gKyAocHJlZGljdGlvbnNbaV0uYmJveFsyXSAvIDIpLCBwcmVkaWN0aW9uc1tpXS5iYm94WzFdICsgKHByZWRpY3Rpb25zW2ldLmJib3hbM10gLyAyKSwgNSwgNSlcblxuICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgIGNvbnRleHQuZmlsbFRleHQoXG4gICAgICAgIHByZWRpY3Rpb25zW2ldLnNjb3JlLnRvRml4ZWQoMykgKyAnICcgKyBcIiB8IGhhbmRcIixcbiAgICAgICAgcHJlZGljdGlvbnNbaV0uYmJveFswXSArIDUsXG4gICAgICAgIHByZWRpY3Rpb25zW2ldLmJib3hbMV0gPiAxMCA/IHByZWRpY3Rpb25zW2ldLmJib3hbMV0gLSA1IDogMTApO1xuICAgIH1cblxuICAgIC8vIFdyaXRlIEZQUyB0byB0b3AgbGVmdFxuICAgIGNvbnRleHQuZm9udCA9IFwiYm9sZCAxMnB4IEFyaWFsXCJcbiAgICBjb250ZXh0LmZpbGxUZXh0KFwiW0ZQU106IFwiICsgdGhpcy5mcHMsIDEwLCAyMClcbiAgfVxuXG4gIGRpc3Bvc2UoKSB7XG4gICAgaWYgKHRoaXMubW9kZWwpIHtcbiAgICAgIHRoaXMubW9kZWwuZGlzcG9zZSgpO1xuICAgIH1cbiAgfVxuXG59XG5cblxuXG5mdW5jdGlvbiBnZXRWYWxpZFJlc29sdXRpb24oaW1hZ2VTY2FsZUZhY3RvciwgaW5wdXREaW1lbnNpb24sIG91dHB1dFN0cmlkZSkge1xuICBjb25zdCBldmVuUmVzb2x1dGlvbiA9IGlucHV0RGltZW5zaW9uICogaW1hZ2VTY2FsZUZhY3RvciAtIDE7XG4gIHJldHVybiBldmVuUmVzb2x1dGlvbiAtIChldmVuUmVzb2x1dGlvbiAlIG91dHB1dFN0cmlkZSkgKyAxO1xufVxuXG5mdW5jdGlvbiBnZXRJbnB1dFRlbnNvckRpbWVuc2lvbnMoaW5wdXQpIHtcbiAgcmV0dXJuIGlucHV0IGluc3RhbmNlb2YgdGYuVGVuc29yID8gW2lucHV0LnNoYXBlWzBdLCBpbnB1dC5zaGFwZVsxXV0gOiBbaW5wdXQuaGVpZ2h0LCBpbnB1dC53aWR0aF07XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZU1heFNjb3JlcyhzY29yZXMsIG51bUJveGVzLCBudW1DbGFzc2VzKSB7XG4gIGNvbnN0IG1heGVzID0gW107XG4gIGNvbnN0IGNsYXNzZXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Cb3hlczsgaSsrKSB7XG4gICAgbGV0IG1heCA9IE51bWJlci5NSU5fVkFMVUU7XG4gICAgbGV0IGluZGV4ID0gLTE7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBudW1DbGFzc2VzOyBqKyspIHtcbiAgICAgIGlmIChzY29yZXNbaSAqIG51bUNsYXNzZXMgKyBqXSA+IG1heCkge1xuICAgICAgICBtYXggPSBzY29yZXNbaSAqIG51bUNsYXNzZXMgKyBqXTtcbiAgICAgICAgaW5kZXggPSBqO1xuICAgICAgfVxuICAgIH1cbiAgICBtYXhlc1tpXSA9IG1heDtcbiAgICBjbGFzc2VzW2ldID0gaW5kZXg7XG4gIH1cbiAgLy8gY29uc29sZS5sb2coW21heGVzLCBjbGFzc2VzXSlcbiAgcmV0dXJuIFttYXhlcywgY2xhc3Nlc107XG59IiwiJ3VzZSBzdHJpY3QnXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCdzdHJlYW0nKS5UcmFuc2Zvcm1cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcblxuZnVuY3Rpb24gdGhyb3dJZk5vdFN0cmluZ09yQnVmZmVyICh2YWwsIHByZWZpeCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih2YWwpICYmIHR5cGVvZiB2YWwgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihwcmVmaXggKyAnIG11c3QgYmUgYSBzdHJpbmcgb3IgYSBidWZmZXInKVxuICB9XG59XG5cbmZ1bmN0aW9uIEhhc2hCYXNlIChibG9ja1NpemUpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcylcblxuICB0aGlzLl9ibG9jayA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShibG9ja1NpemUpXG4gIHRoaXMuX2Jsb2NrU2l6ZSA9IGJsb2NrU2l6ZVxuICB0aGlzLl9ibG9ja09mZnNldCA9IDBcbiAgdGhpcy5fbGVuZ3RoID0gWzAsIDAsIDAsIDBdXG5cbiAgdGhpcy5fZmluYWxpemVkID0gZmFsc2Vcbn1cblxuaW5oZXJpdHMoSGFzaEJhc2UsIFRyYW5zZm9ybSlcblxuSGFzaEJhc2UucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICB2YXIgZXJyb3IgPSBudWxsXG4gIHRyeSB7XG4gICAgdGhpcy51cGRhdGUoY2h1bmssIGVuY29kaW5nKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnJvciA9IGVyclxuICB9XG5cbiAgY2FsbGJhY2soZXJyb3IpXG59XG5cbkhhc2hCYXNlLnByb3RvdHlwZS5fZmx1c2ggPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgdmFyIGVycm9yID0gbnVsbFxuICB0cnkge1xuICAgIHRoaXMucHVzaCh0aGlzLmRpZ2VzdCgpKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnJvciA9IGVyclxuICB9XG5cbiAgY2FsbGJhY2soZXJyb3IpXG59XG5cbkhhc2hCYXNlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSwgZW5jb2RpbmcpIHtcbiAgdGhyb3dJZk5vdFN0cmluZ09yQnVmZmVyKGRhdGEsICdEYXRhJylcbiAgaWYgKHRoaXMuX2ZpbmFsaXplZCkgdGhyb3cgbmV3IEVycm9yKCdEaWdlc3QgYWxyZWFkeSBjYWxsZWQnKVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEsIGVuY29kaW5nKVxuXG4gIC8vIGNvbnN1bWUgZGF0YVxuICB2YXIgYmxvY2sgPSB0aGlzLl9ibG9ja1xuICB2YXIgb2Zmc2V0ID0gMFxuICB3aGlsZSAodGhpcy5fYmxvY2tPZmZzZXQgKyBkYXRhLmxlbmd0aCAtIG9mZnNldCA+PSB0aGlzLl9ibG9ja1NpemUpIHtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5fYmxvY2tPZmZzZXQ7IGkgPCB0aGlzLl9ibG9ja1NpemU7KSBibG9ja1tpKytdID0gZGF0YVtvZmZzZXQrK11cbiAgICB0aGlzLl91cGRhdGUoKVxuICAgIHRoaXMuX2Jsb2NrT2Zmc2V0ID0gMFxuICB9XG4gIHdoaWxlIChvZmZzZXQgPCBkYXRhLmxlbmd0aCkgYmxvY2tbdGhpcy5fYmxvY2tPZmZzZXQrK10gPSBkYXRhW29mZnNldCsrXVxuXG4gIC8vIHVwZGF0ZSBsZW5ndGhcbiAgZm9yICh2YXIgaiA9IDAsIGNhcnJ5ID0gZGF0YS5sZW5ndGggKiA4OyBjYXJyeSA+IDA7ICsraikge1xuICAgIHRoaXMuX2xlbmd0aFtqXSArPSBjYXJyeVxuICAgIGNhcnJ5ID0gKHRoaXMuX2xlbmd0aFtqXSAvIDB4MDEwMDAwMDAwMCkgfCAwXG4gICAgaWYgKGNhcnJ5ID4gMCkgdGhpcy5fbGVuZ3RoW2pdIC09IDB4MDEwMDAwMDAwMCAqIGNhcnJ5XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG5IYXNoQmFzZS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdfdXBkYXRlIGlzIG5vdCBpbXBsZW1lbnRlZCcpXG59XG5cbkhhc2hCYXNlLnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcbiAgaWYgKHRoaXMuX2ZpbmFsaXplZCkgdGhyb3cgbmV3IEVycm9yKCdEaWdlc3QgYWxyZWFkeSBjYWxsZWQnKVxuICB0aGlzLl9maW5hbGl6ZWQgPSB0cnVlXG5cbiAgdmFyIGRpZ2VzdCA9IHRoaXMuX2RpZ2VzdCgpXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSBkaWdlc3QgPSBkaWdlc3QudG9TdHJpbmcoZW5jb2RpbmcpXG5cbiAgLy8gcmVzZXQgc3RhdGVcbiAgdGhpcy5fYmxvY2suZmlsbCgwKVxuICB0aGlzLl9ibG9ja09mZnNldCA9IDBcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyArK2kpIHRoaXMuX2xlbmd0aFtpXSA9IDBcblxuICByZXR1cm4gZGlnZXN0XG59XG5cbkhhc2hCYXNlLnByb3RvdHlwZS5fZGlnZXN0ID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ19kaWdlc3QgaXMgbm90IGltcGxlbWVudGVkJylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBIYXNoQmFzZVxuIiwidmFyIGhhc2ggPSBleHBvcnRzO1xuXG5oYXNoLnV0aWxzID0gcmVxdWlyZSgnLi9oYXNoL3V0aWxzJyk7XG5oYXNoLmNvbW1vbiA9IHJlcXVpcmUoJy4vaGFzaC9jb21tb24nKTtcbmhhc2guc2hhID0gcmVxdWlyZSgnLi9oYXNoL3NoYScpO1xuaGFzaC5yaXBlbWQgPSByZXF1aXJlKCcuL2hhc2gvcmlwZW1kJyk7XG5oYXNoLmhtYWMgPSByZXF1aXJlKCcuL2hhc2gvaG1hYycpO1xuXG4vLyBQcm94eSBoYXNoIGZ1bmN0aW9ucyB0byB0aGUgbWFpbiBvYmplY3Rcbmhhc2guc2hhMSA9IGhhc2guc2hhLnNoYTE7XG5oYXNoLnNoYTI1NiA9IGhhc2guc2hhLnNoYTI1Njtcbmhhc2guc2hhMjI0ID0gaGFzaC5zaGEuc2hhMjI0O1xuaGFzaC5zaGEzODQgPSBoYXNoLnNoYS5zaGEzODQ7XG5oYXNoLnNoYTUxMiA9IGhhc2guc2hhLnNoYTUxMjtcbmhhc2gucmlwZW1kMTYwID0gaGFzaC5yaXBlbWQucmlwZW1kMTYwO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnbWluaW1hbGlzdGljLWFzc2VydCcpO1xuXG5mdW5jdGlvbiBCbG9ja0hhc2goKSB7XG4gIHRoaXMucGVuZGluZyA9IG51bGw7XG4gIHRoaXMucGVuZGluZ1RvdGFsID0gMDtcbiAgdGhpcy5ibG9ja1NpemUgPSB0aGlzLmNvbnN0cnVjdG9yLmJsb2NrU2l6ZTtcbiAgdGhpcy5vdXRTaXplID0gdGhpcy5jb25zdHJ1Y3Rvci5vdXRTaXplO1xuICB0aGlzLmhtYWNTdHJlbmd0aCA9IHRoaXMuY29uc3RydWN0b3IuaG1hY1N0cmVuZ3RoO1xuICB0aGlzLnBhZExlbmd0aCA9IHRoaXMuY29uc3RydWN0b3IucGFkTGVuZ3RoIC8gODtcbiAgdGhpcy5lbmRpYW4gPSAnYmlnJztcblxuICB0aGlzLl9kZWx0YTggPSB0aGlzLmJsb2NrU2l6ZSAvIDg7XG4gIHRoaXMuX2RlbHRhMzIgPSB0aGlzLmJsb2NrU2l6ZSAvIDMyO1xufVxuZXhwb3J0cy5CbG9ja0hhc2ggPSBCbG9ja0hhc2g7XG5cbkJsb2NrSGFzaC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKG1zZywgZW5jKSB7XG4gIC8vIENvbnZlcnQgbWVzc2FnZSB0byBhcnJheSwgcGFkIGl0LCBhbmQgam9pbiBpbnRvIDMyYml0IGJsb2Nrc1xuICBtc2cgPSB1dGlscy50b0FycmF5KG1zZywgZW5jKTtcbiAgaWYgKCF0aGlzLnBlbmRpbmcpXG4gICAgdGhpcy5wZW5kaW5nID0gbXNnO1xuICBlbHNlXG4gICAgdGhpcy5wZW5kaW5nID0gdGhpcy5wZW5kaW5nLmNvbmNhdChtc2cpO1xuICB0aGlzLnBlbmRpbmdUb3RhbCArPSBtc2cubGVuZ3RoO1xuXG4gIC8vIEVub3VnaCBkYXRhLCB0cnkgdXBkYXRpbmdcbiAgaWYgKHRoaXMucGVuZGluZy5sZW5ndGggPj0gdGhpcy5fZGVsdGE4KSB7XG4gICAgbXNnID0gdGhpcy5wZW5kaW5nO1xuXG4gICAgLy8gUHJvY2VzcyBwZW5kaW5nIGRhdGEgaW4gYmxvY2tzXG4gICAgdmFyIHIgPSBtc2cubGVuZ3RoICUgdGhpcy5fZGVsdGE4O1xuICAgIHRoaXMucGVuZGluZyA9IG1zZy5zbGljZShtc2cubGVuZ3RoIC0gciwgbXNnLmxlbmd0aCk7XG4gICAgaWYgKHRoaXMucGVuZGluZy5sZW5ndGggPT09IDApXG4gICAgICB0aGlzLnBlbmRpbmcgPSBudWxsO1xuXG4gICAgbXNnID0gdXRpbHMuam9pbjMyKG1zZywgMCwgbXNnLmxlbmd0aCAtIHIsIHRoaXMuZW5kaWFuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkgKz0gdGhpcy5fZGVsdGEzMilcbiAgICAgIHRoaXMuX3VwZGF0ZShtc2csIGksIGkgKyB0aGlzLl9kZWx0YTMyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuQmxvY2tIYXNoLnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiBkaWdlc3QoZW5jKSB7XG4gIHRoaXMudXBkYXRlKHRoaXMuX3BhZCgpKTtcbiAgYXNzZXJ0KHRoaXMucGVuZGluZyA9PT0gbnVsbCk7XG5cbiAgcmV0dXJuIHRoaXMuX2RpZ2VzdChlbmMpO1xufTtcblxuQmxvY2tIYXNoLnByb3RvdHlwZS5fcGFkID0gZnVuY3Rpb24gcGFkKCkge1xuICB2YXIgbGVuID0gdGhpcy5wZW5kaW5nVG90YWw7XG4gIHZhciBieXRlcyA9IHRoaXMuX2RlbHRhODtcbiAgdmFyIGsgPSBieXRlcyAtICgobGVuICsgdGhpcy5wYWRMZW5ndGgpICUgYnl0ZXMpO1xuICB2YXIgcmVzID0gbmV3IEFycmF5KGsgKyB0aGlzLnBhZExlbmd0aCk7XG4gIHJlc1swXSA9IDB4ODA7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgazsgaSsrKVxuICAgIHJlc1tpXSA9IDA7XG5cbiAgLy8gQXBwZW5kIGxlbmd0aFxuICBsZW4gPDw9IDM7XG4gIGlmICh0aGlzLmVuZGlhbiA9PT0gJ2JpZycpIHtcbiAgICBmb3IgKHZhciB0ID0gODsgdCA8IHRoaXMucGFkTGVuZ3RoOyB0KyspXG4gICAgICByZXNbaSsrXSA9IDA7XG5cbiAgICByZXNbaSsrXSA9IDA7XG4gICAgcmVzW2krK10gPSAwO1xuICAgIHJlc1tpKytdID0gMDtcbiAgICByZXNbaSsrXSA9IDA7XG4gICAgcmVzW2krK10gPSAobGVuID4+PiAyNCkgJiAweGZmO1xuICAgIHJlc1tpKytdID0gKGxlbiA+Pj4gMTYpICYgMHhmZjtcbiAgICByZXNbaSsrXSA9IChsZW4gPj4+IDgpICYgMHhmZjtcbiAgICByZXNbaSsrXSA9IGxlbiAmIDB4ZmY7XG4gIH0gZWxzZSB7XG4gICAgcmVzW2krK10gPSBsZW4gJiAweGZmO1xuICAgIHJlc1tpKytdID0gKGxlbiA+Pj4gOCkgJiAweGZmO1xuICAgIHJlc1tpKytdID0gKGxlbiA+Pj4gMTYpICYgMHhmZjtcbiAgICByZXNbaSsrXSA9IChsZW4gPj4+IDI0KSAmIDB4ZmY7XG4gICAgcmVzW2krK10gPSAwO1xuICAgIHJlc1tpKytdID0gMDtcbiAgICByZXNbaSsrXSA9IDA7XG4gICAgcmVzW2krK10gPSAwO1xuXG4gICAgZm9yICh0ID0gODsgdCA8IHRoaXMucGFkTGVuZ3RoOyB0KyspXG4gICAgICByZXNbaSsrXSA9IDA7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIGFzc2VydCA9IHJlcXVpcmUoJ21pbmltYWxpc3RpYy1hc3NlcnQnKTtcblxuZnVuY3Rpb24gSG1hYyhoYXNoLCBrZXksIGVuYykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSG1hYykpXG4gICAgcmV0dXJuIG5ldyBIbWFjKGhhc2gsIGtleSwgZW5jKTtcbiAgdGhpcy5IYXNoID0gaGFzaDtcbiAgdGhpcy5ibG9ja1NpemUgPSBoYXNoLmJsb2NrU2l6ZSAvIDg7XG4gIHRoaXMub3V0U2l6ZSA9IGhhc2gub3V0U2l6ZSAvIDg7XG4gIHRoaXMuaW5uZXIgPSBudWxsO1xuICB0aGlzLm91dGVyID0gbnVsbDtcblxuICB0aGlzLl9pbml0KHV0aWxzLnRvQXJyYXkoa2V5LCBlbmMpKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gSG1hYztcblxuSG1hYy5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiBpbml0KGtleSkge1xuICAvLyBTaG9ydGVuIGtleSwgaWYgbmVlZGVkXG4gIGlmIChrZXkubGVuZ3RoID4gdGhpcy5ibG9ja1NpemUpXG4gICAga2V5ID0gbmV3IHRoaXMuSGFzaCgpLnVwZGF0ZShrZXkpLmRpZ2VzdCgpO1xuICBhc3NlcnQoa2V5Lmxlbmd0aCA8PSB0aGlzLmJsb2NrU2l6ZSk7XG5cbiAgLy8gQWRkIHBhZGRpbmcgdG8ga2V5XG4gIGZvciAodmFyIGkgPSBrZXkubGVuZ3RoOyBpIDwgdGhpcy5ibG9ja1NpemU7IGkrKylcbiAgICBrZXkucHVzaCgwKTtcblxuICBmb3IgKGkgPSAwOyBpIDwga2V5Lmxlbmd0aDsgaSsrKVxuICAgIGtleVtpXSBePSAweDM2O1xuICB0aGlzLmlubmVyID0gbmV3IHRoaXMuSGFzaCgpLnVwZGF0ZShrZXkpO1xuXG4gIC8vIDB4MzYgXiAweDVjID0gMHg2YVxuICBmb3IgKGkgPSAwOyBpIDwga2V5Lmxlbmd0aDsgaSsrKVxuICAgIGtleVtpXSBePSAweDZhO1xuICB0aGlzLm91dGVyID0gbmV3IHRoaXMuSGFzaCgpLnVwZGF0ZShrZXkpO1xufTtcblxuSG1hYy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKG1zZywgZW5jKSB7XG4gIHRoaXMuaW5uZXIudXBkYXRlKG1zZywgZW5jKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5IbWFjLnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiBkaWdlc3QoZW5jKSB7XG4gIHRoaXMub3V0ZXIudXBkYXRlKHRoaXMuaW5uZXIuZGlnZXN0KCkpO1xuICByZXR1cm4gdGhpcy5vdXRlci5kaWdlc3QoZW5jKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuXG52YXIgcm90bDMyID0gdXRpbHMucm90bDMyO1xudmFyIHN1bTMyID0gdXRpbHMuc3VtMzI7XG52YXIgc3VtMzJfMyA9IHV0aWxzLnN1bTMyXzM7XG52YXIgc3VtMzJfNCA9IHV0aWxzLnN1bTMyXzQ7XG52YXIgQmxvY2tIYXNoID0gY29tbW9uLkJsb2NrSGFzaDtcblxuZnVuY3Rpb24gUklQRU1EMTYwKCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUklQRU1EMTYwKSlcbiAgICByZXR1cm4gbmV3IFJJUEVNRDE2MCgpO1xuXG4gIEJsb2NrSGFzaC5jYWxsKHRoaXMpO1xuXG4gIHRoaXMuaCA9IFsgMHg2NzQ1MjMwMSwgMHhlZmNkYWI4OSwgMHg5OGJhZGNmZSwgMHgxMDMyNTQ3NiwgMHhjM2QyZTFmMCBdO1xuICB0aGlzLmVuZGlhbiA9ICdsaXR0bGUnO1xufVxudXRpbHMuaW5oZXJpdHMoUklQRU1EMTYwLCBCbG9ja0hhc2gpO1xuZXhwb3J0cy5yaXBlbWQxNjAgPSBSSVBFTUQxNjA7XG5cblJJUEVNRDE2MC5ibG9ja1NpemUgPSA1MTI7XG5SSVBFTUQxNjAub3V0U2l6ZSA9IDE2MDtcblJJUEVNRDE2MC5obWFjU3RyZW5ndGggPSAxOTI7XG5SSVBFTUQxNjAucGFkTGVuZ3RoID0gNjQ7XG5cblJJUEVNRDE2MC5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShtc2csIHN0YXJ0KSB7XG4gIHZhciBBID0gdGhpcy5oWzBdO1xuICB2YXIgQiA9IHRoaXMuaFsxXTtcbiAgdmFyIEMgPSB0aGlzLmhbMl07XG4gIHZhciBEID0gdGhpcy5oWzNdO1xuICB2YXIgRSA9IHRoaXMuaFs0XTtcbiAgdmFyIEFoID0gQTtcbiAgdmFyIEJoID0gQjtcbiAgdmFyIENoID0gQztcbiAgdmFyIERoID0gRDtcbiAgdmFyIEVoID0gRTtcbiAgZm9yICh2YXIgaiA9IDA7IGogPCA4MDsgaisrKSB7XG4gICAgdmFyIFQgPSBzdW0zMihcbiAgICAgIHJvdGwzMihcbiAgICAgICAgc3VtMzJfNChBLCBmKGosIEIsIEMsIEQpLCBtc2dbcltqXSArIHN0YXJ0XSwgSyhqKSksXG4gICAgICAgIHNbal0pLFxuICAgICAgRSk7XG4gICAgQSA9IEU7XG4gICAgRSA9IEQ7XG4gICAgRCA9IHJvdGwzMihDLCAxMCk7XG4gICAgQyA9IEI7XG4gICAgQiA9IFQ7XG4gICAgVCA9IHN1bTMyKFxuICAgICAgcm90bDMyKFxuICAgICAgICBzdW0zMl80KEFoLCBmKDc5IC0gaiwgQmgsIENoLCBEaCksIG1zZ1tyaFtqXSArIHN0YXJ0XSwgS2goaikpLFxuICAgICAgICBzaFtqXSksXG4gICAgICBFaCk7XG4gICAgQWggPSBFaDtcbiAgICBFaCA9IERoO1xuICAgIERoID0gcm90bDMyKENoLCAxMCk7XG4gICAgQ2ggPSBCaDtcbiAgICBCaCA9IFQ7XG4gIH1cbiAgVCA9IHN1bTMyXzModGhpcy5oWzFdLCBDLCBEaCk7XG4gIHRoaXMuaFsxXSA9IHN1bTMyXzModGhpcy5oWzJdLCBELCBFaCk7XG4gIHRoaXMuaFsyXSA9IHN1bTMyXzModGhpcy5oWzNdLCBFLCBBaCk7XG4gIHRoaXMuaFszXSA9IHN1bTMyXzModGhpcy5oWzRdLCBBLCBCaCk7XG4gIHRoaXMuaFs0XSA9IHN1bTMyXzModGhpcy5oWzBdLCBCLCBDaCk7XG4gIHRoaXMuaFswXSA9IFQ7XG59O1xuXG5SSVBFTUQxNjAucHJvdG90eXBlLl9kaWdlc3QgPSBmdW5jdGlvbiBkaWdlc3QoZW5jKSB7XG4gIGlmIChlbmMgPT09ICdoZXgnKVxuICAgIHJldHVybiB1dGlscy50b0hleDMyKHRoaXMuaCwgJ2xpdHRsZScpO1xuICBlbHNlXG4gICAgcmV0dXJuIHV0aWxzLnNwbGl0MzIodGhpcy5oLCAnbGl0dGxlJyk7XG59O1xuXG5mdW5jdGlvbiBmKGosIHgsIHksIHopIHtcbiAgaWYgKGogPD0gMTUpXG4gICAgcmV0dXJuIHggXiB5IF4gejtcbiAgZWxzZSBpZiAoaiA8PSAzMSlcbiAgICByZXR1cm4gKHggJiB5KSB8ICgofngpICYgeik7XG4gIGVsc2UgaWYgKGogPD0gNDcpXG4gICAgcmV0dXJuICh4IHwgKH55KSkgXiB6O1xuICBlbHNlIGlmIChqIDw9IDYzKVxuICAgIHJldHVybiAoeCAmIHopIHwgKHkgJiAofnopKTtcbiAgZWxzZVxuICAgIHJldHVybiB4IF4gKHkgfCAofnopKTtcbn1cblxuZnVuY3Rpb24gSyhqKSB7XG4gIGlmIChqIDw9IDE1KVxuICAgIHJldHVybiAweDAwMDAwMDAwO1xuICBlbHNlIGlmIChqIDw9IDMxKVxuICAgIHJldHVybiAweDVhODI3OTk5O1xuICBlbHNlIGlmIChqIDw9IDQ3KVxuICAgIHJldHVybiAweDZlZDllYmExO1xuICBlbHNlIGlmIChqIDw9IDYzKVxuICAgIHJldHVybiAweDhmMWJiY2RjO1xuICBlbHNlXG4gICAgcmV0dXJuIDB4YTk1M2ZkNGU7XG59XG5cbmZ1bmN0aW9uIEtoKGopIHtcbiAgaWYgKGogPD0gMTUpXG4gICAgcmV0dXJuIDB4NTBhMjhiZTY7XG4gIGVsc2UgaWYgKGogPD0gMzEpXG4gICAgcmV0dXJuIDB4NWM0ZGQxMjQ7XG4gIGVsc2UgaWYgKGogPD0gNDcpXG4gICAgcmV0dXJuIDB4NmQ3MDNlZjM7XG4gIGVsc2UgaWYgKGogPD0gNjMpXG4gICAgcmV0dXJuIDB4N2E2ZDc2ZTk7XG4gIGVsc2VcbiAgICByZXR1cm4gMHgwMDAwMDAwMDtcbn1cblxudmFyIHIgPSBbXG4gIDAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTIsIDEzLCAxNCwgMTUsXG4gIDcsIDQsIDEzLCAxLCAxMCwgNiwgMTUsIDMsIDEyLCAwLCA5LCA1LCAyLCAxNCwgMTEsIDgsXG4gIDMsIDEwLCAxNCwgNCwgOSwgMTUsIDgsIDEsIDIsIDcsIDAsIDYsIDEzLCAxMSwgNSwgMTIsXG4gIDEsIDksIDExLCAxMCwgMCwgOCwgMTIsIDQsIDEzLCAzLCA3LCAxNSwgMTQsIDUsIDYsIDIsXG4gIDQsIDAsIDUsIDksIDcsIDEyLCAyLCAxMCwgMTQsIDEsIDMsIDgsIDExLCA2LCAxNSwgMTNcbl07XG5cbnZhciByaCA9IFtcbiAgNSwgMTQsIDcsIDAsIDksIDIsIDExLCA0LCAxMywgNiwgMTUsIDgsIDEsIDEwLCAzLCAxMixcbiAgNiwgMTEsIDMsIDcsIDAsIDEzLCA1LCAxMCwgMTQsIDE1LCA4LCAxMiwgNCwgOSwgMSwgMixcbiAgMTUsIDUsIDEsIDMsIDcsIDE0LCA2LCA5LCAxMSwgOCwgMTIsIDIsIDEwLCAwLCA0LCAxMyxcbiAgOCwgNiwgNCwgMSwgMywgMTEsIDE1LCAwLCA1LCAxMiwgMiwgMTMsIDksIDcsIDEwLCAxNCxcbiAgMTIsIDE1LCAxMCwgNCwgMSwgNSwgOCwgNywgNiwgMiwgMTMsIDE0LCAwLCAzLCA5LCAxMVxuXTtcblxudmFyIHMgPSBbXG4gIDExLCAxNCwgMTUsIDEyLCA1LCA4LCA3LCA5LCAxMSwgMTMsIDE0LCAxNSwgNiwgNywgOSwgOCxcbiAgNywgNiwgOCwgMTMsIDExLCA5LCA3LCAxNSwgNywgMTIsIDE1LCA5LCAxMSwgNywgMTMsIDEyLFxuICAxMSwgMTMsIDYsIDcsIDE0LCA5LCAxMywgMTUsIDE0LCA4LCAxMywgNiwgNSwgMTIsIDcsIDUsXG4gIDExLCAxMiwgMTQsIDE1LCAxNCwgMTUsIDksIDgsIDksIDE0LCA1LCA2LCA4LCA2LCA1LCAxMixcbiAgOSwgMTUsIDUsIDExLCA2LCA4LCAxMywgMTIsIDUsIDEyLCAxMywgMTQsIDExLCA4LCA1LCA2XG5dO1xuXG52YXIgc2ggPSBbXG4gIDgsIDksIDksIDExLCAxMywgMTUsIDE1LCA1LCA3LCA3LCA4LCAxMSwgMTQsIDE0LCAxMiwgNixcbiAgOSwgMTMsIDE1LCA3LCAxMiwgOCwgOSwgMTEsIDcsIDcsIDEyLCA3LCA2LCAxNSwgMTMsIDExLFxuICA5LCA3LCAxNSwgMTEsIDgsIDYsIDYsIDE0LCAxMiwgMTMsIDUsIDE0LCAxMywgMTMsIDcsIDUsXG4gIDE1LCA1LCA4LCAxMSwgMTQsIDE0LCA2LCAxNCwgNiwgOSwgMTIsIDksIDEyLCA1LCAxNSwgOCxcbiAgOCwgNSwgMTIsIDksIDEyLCA1LCAxNCwgNiwgOCwgMTMsIDYsIDUsIDE1LCAxMywgMTEsIDExXG5dO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLnNoYTEgPSByZXF1aXJlKCcuL3NoYS8xJyk7XG5leHBvcnRzLnNoYTIyNCA9IHJlcXVpcmUoJy4vc2hhLzIyNCcpO1xuZXhwb3J0cy5zaGEyNTYgPSByZXF1aXJlKCcuL3NoYS8yNTYnKTtcbmV4cG9ydHMuc2hhMzg0ID0gcmVxdWlyZSgnLi9zaGEvMzg0Jyk7XG5leHBvcnRzLnNoYTUxMiA9IHJlcXVpcmUoJy4vc2hhLzUxMicpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xudmFyIHNoYUNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5cbnZhciByb3RsMzIgPSB1dGlscy5yb3RsMzI7XG52YXIgc3VtMzIgPSB1dGlscy5zdW0zMjtcbnZhciBzdW0zMl81ID0gdXRpbHMuc3VtMzJfNTtcbnZhciBmdF8xID0gc2hhQ29tbW9uLmZ0XzE7XG52YXIgQmxvY2tIYXNoID0gY29tbW9uLkJsb2NrSGFzaDtcblxudmFyIHNoYTFfSyA9IFtcbiAgMHg1QTgyNzk5OSwgMHg2RUQ5RUJBMSxcbiAgMHg4RjFCQkNEQywgMHhDQTYyQzFENlxuXTtcblxuZnVuY3Rpb24gU0hBMSgpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNIQTEpKVxuICAgIHJldHVybiBuZXcgU0hBMSgpO1xuXG4gIEJsb2NrSGFzaC5jYWxsKHRoaXMpO1xuICB0aGlzLmggPSBbXG4gICAgMHg2NzQ1MjMwMSwgMHhlZmNkYWI4OSwgMHg5OGJhZGNmZSxcbiAgICAweDEwMzI1NDc2LCAweGMzZDJlMWYwIF07XG4gIHRoaXMuVyA9IG5ldyBBcnJheSg4MCk7XG59XG5cbnV0aWxzLmluaGVyaXRzKFNIQTEsIEJsb2NrSGFzaCk7XG5tb2R1bGUuZXhwb3J0cyA9IFNIQTE7XG5cblNIQTEuYmxvY2tTaXplID0gNTEyO1xuU0hBMS5vdXRTaXplID0gMTYwO1xuU0hBMS5obWFjU3RyZW5ndGggPSA4MDtcblNIQTEucGFkTGVuZ3RoID0gNjQ7XG5cblNIQTEucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiBfdXBkYXRlKG1zZywgc3RhcnQpIHtcbiAgdmFyIFcgPSB0aGlzLlc7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKVxuICAgIFdbaV0gPSBtc2dbc3RhcnQgKyBpXTtcblxuICBmb3IoOyBpIDwgVy5sZW5ndGg7IGkrKylcbiAgICBXW2ldID0gcm90bDMyKFdbaSAtIDNdIF4gV1tpIC0gOF0gXiBXW2kgLSAxNF0gXiBXW2kgLSAxNl0sIDEpO1xuXG4gIHZhciBhID0gdGhpcy5oWzBdO1xuICB2YXIgYiA9IHRoaXMuaFsxXTtcbiAgdmFyIGMgPSB0aGlzLmhbMl07XG4gIHZhciBkID0gdGhpcy5oWzNdO1xuICB2YXIgZSA9IHRoaXMuaFs0XTtcblxuICBmb3IgKGkgPSAwOyBpIDwgVy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzID0gfn4oaSAvIDIwKTtcbiAgICB2YXIgdCA9IHN1bTMyXzUocm90bDMyKGEsIDUpLCBmdF8xKHMsIGIsIGMsIGQpLCBlLCBXW2ldLCBzaGExX0tbc10pO1xuICAgIGUgPSBkO1xuICAgIGQgPSBjO1xuICAgIGMgPSByb3RsMzIoYiwgMzApO1xuICAgIGIgPSBhO1xuICAgIGEgPSB0O1xuICB9XG5cbiAgdGhpcy5oWzBdID0gc3VtMzIodGhpcy5oWzBdLCBhKTtcbiAgdGhpcy5oWzFdID0gc3VtMzIodGhpcy5oWzFdLCBiKTtcbiAgdGhpcy5oWzJdID0gc3VtMzIodGhpcy5oWzJdLCBjKTtcbiAgdGhpcy5oWzNdID0gc3VtMzIodGhpcy5oWzNdLCBkKTtcbiAgdGhpcy5oWzRdID0gc3VtMzIodGhpcy5oWzRdLCBlKTtcbn07XG5cblNIQTEucHJvdG90eXBlLl9kaWdlc3QgPSBmdW5jdGlvbiBkaWdlc3QoZW5jKSB7XG4gIGlmIChlbmMgPT09ICdoZXgnKVxuICAgIHJldHVybiB1dGlscy50b0hleDMyKHRoaXMuaCwgJ2JpZycpO1xuICBlbHNlXG4gICAgcmV0dXJuIHV0aWxzLnNwbGl0MzIodGhpcy5oLCAnYmlnJyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIFNIQTI1NiA9IHJlcXVpcmUoJy4vMjU2Jyk7XG5cbmZ1bmN0aW9uIFNIQTIyNCgpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNIQTIyNCkpXG4gICAgcmV0dXJuIG5ldyBTSEEyMjQoKTtcblxuICBTSEEyNTYuY2FsbCh0aGlzKTtcbiAgdGhpcy5oID0gW1xuICAgIDB4YzEwNTllZDgsIDB4MzY3Y2Q1MDcsIDB4MzA3MGRkMTcsIDB4ZjcwZTU5MzksXG4gICAgMHhmZmMwMGIzMSwgMHg2ODU4MTUxMSwgMHg2NGY5OGZhNywgMHhiZWZhNGZhNCBdO1xufVxudXRpbHMuaW5oZXJpdHMoU0hBMjI0LCBTSEEyNTYpO1xubW9kdWxlLmV4cG9ydHMgPSBTSEEyMjQ7XG5cblNIQTIyNC5ibG9ja1NpemUgPSA1MTI7XG5TSEEyMjQub3V0U2l6ZSA9IDIyNDtcblNIQTIyNC5obWFjU3RyZW5ndGggPSAxOTI7XG5TSEEyMjQucGFkTGVuZ3RoID0gNjQ7XG5cblNIQTIyNC5wcm90b3R5cGUuX2RpZ2VzdCA9IGZ1bmN0aW9uIGRpZ2VzdChlbmMpIHtcbiAgLy8gSnVzdCB0cnVuY2F0ZSBvdXRwdXRcbiAgaWYgKGVuYyA9PT0gJ2hleCcpXG4gICAgcmV0dXJuIHV0aWxzLnRvSGV4MzIodGhpcy5oLnNsaWNlKDAsIDcpLCAnYmlnJyk7XG4gIGVsc2VcbiAgICByZXR1cm4gdXRpbHMuc3BsaXQzMih0aGlzLmguc2xpY2UoMCwgNyksICdiaWcnKTtcbn07XG5cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBjb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcbnZhciBzaGFDb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xudmFyIGFzc2VydCA9IHJlcXVpcmUoJ21pbmltYWxpc3RpYy1hc3NlcnQnKTtcblxudmFyIHN1bTMyID0gdXRpbHMuc3VtMzI7XG52YXIgc3VtMzJfNCA9IHV0aWxzLnN1bTMyXzQ7XG52YXIgc3VtMzJfNSA9IHV0aWxzLnN1bTMyXzU7XG52YXIgY2gzMiA9IHNoYUNvbW1vbi5jaDMyO1xudmFyIG1hajMyID0gc2hhQ29tbW9uLm1hajMyO1xudmFyIHMwXzI1NiA9IHNoYUNvbW1vbi5zMF8yNTY7XG52YXIgczFfMjU2ID0gc2hhQ29tbW9uLnMxXzI1NjtcbnZhciBnMF8yNTYgPSBzaGFDb21tb24uZzBfMjU2O1xudmFyIGcxXzI1NiA9IHNoYUNvbW1vbi5nMV8yNTY7XG5cbnZhciBCbG9ja0hhc2ggPSBjb21tb24uQmxvY2tIYXNoO1xuXG52YXIgc2hhMjU2X0sgPSBbXG4gIDB4NDI4YTJmOTgsIDB4NzEzNzQ0OTEsIDB4YjVjMGZiY2YsIDB4ZTliNWRiYTUsXG4gIDB4Mzk1NmMyNWIsIDB4NTlmMTExZjEsIDB4OTIzZjgyYTQsIDB4YWIxYzVlZDUsXG4gIDB4ZDgwN2FhOTgsIDB4MTI4MzViMDEsIDB4MjQzMTg1YmUsIDB4NTUwYzdkYzMsXG4gIDB4NzJiZTVkNzQsIDB4ODBkZWIxZmUsIDB4OWJkYzA2YTcsIDB4YzE5YmYxNzQsXG4gIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsIDB4MGZjMTlkYzYsIDB4MjQwY2ExY2MsXG4gIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsXG4gIDB4OTgzZTUxNTIsIDB4YTgzMWM2NmQsIDB4YjAwMzI3YzgsIDB4YmY1OTdmYzcsXG4gIDB4YzZlMDBiZjMsIDB4ZDVhNzkxNDcsIDB4MDZjYTYzNTEsIDB4MTQyOTI5NjcsXG4gIDB4MjdiNzBhODUsIDB4MmUxYjIxMzgsIDB4NGQyYzZkZmMsIDB4NTMzODBkMTMsXG4gIDB4NjUwYTczNTQsIDB4NzY2YTBhYmIsIDB4ODFjMmM5MmUsIDB4OTI3MjJjODUsXG4gIDB4YTJiZmU4YTEsIDB4YTgxYTY2NGIsIDB4YzI0YjhiNzAsIDB4Yzc2YzUxYTMsXG4gIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXG4gIDB4MTlhNGMxMTYsIDB4MWUzNzZjMDgsIDB4Mjc0ODc3NGMsIDB4MzRiMGJjYjUsXG4gIDB4MzkxYzBjYjMsIDB4NGVkOGFhNGEsIDB4NWI5Y2NhNGYsIDB4NjgyZTZmZjMsXG4gIDB4NzQ4ZjgyZWUsIDB4NzhhNTYzNmYsIDB4ODRjODc4MTQsIDB4OGNjNzAyMDgsXG4gIDB4OTBiZWZmZmEsIDB4YTQ1MDZjZWIsIDB4YmVmOWEzZjcsIDB4YzY3MTc4ZjJcbl07XG5cbmZ1bmN0aW9uIFNIQTI1NigpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNIQTI1NikpXG4gICAgcmV0dXJuIG5ldyBTSEEyNTYoKTtcblxuICBCbG9ja0hhc2guY2FsbCh0aGlzKTtcbiAgdGhpcy5oID0gW1xuICAgIDB4NmEwOWU2NjcsIDB4YmI2N2FlODUsIDB4M2M2ZWYzNzIsIDB4YTU0ZmY1M2EsXG4gICAgMHg1MTBlNTI3ZiwgMHg5YjA1Njg4YywgMHgxZjgzZDlhYiwgMHg1YmUwY2QxOVxuICBdO1xuICB0aGlzLmsgPSBzaGEyNTZfSztcbiAgdGhpcy5XID0gbmV3IEFycmF5KDY0KTtcbn1cbnV0aWxzLmluaGVyaXRzKFNIQTI1NiwgQmxvY2tIYXNoKTtcbm1vZHVsZS5leHBvcnRzID0gU0hBMjU2O1xuXG5TSEEyNTYuYmxvY2tTaXplID0gNTEyO1xuU0hBMjU2Lm91dFNpemUgPSAyNTY7XG5TSEEyNTYuaG1hY1N0cmVuZ3RoID0gMTkyO1xuU0hBMjU2LnBhZExlbmd0aCA9IDY0O1xuXG5TSEEyNTYucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiBfdXBkYXRlKG1zZywgc3RhcnQpIHtcbiAgdmFyIFcgPSB0aGlzLlc7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKVxuICAgIFdbaV0gPSBtc2dbc3RhcnQgKyBpXTtcbiAgZm9yICg7IGkgPCBXLmxlbmd0aDsgaSsrKVxuICAgIFdbaV0gPSBzdW0zMl80KGcxXzI1NihXW2kgLSAyXSksIFdbaSAtIDddLCBnMF8yNTYoV1tpIC0gMTVdKSwgV1tpIC0gMTZdKTtcblxuICB2YXIgYSA9IHRoaXMuaFswXTtcbiAgdmFyIGIgPSB0aGlzLmhbMV07XG4gIHZhciBjID0gdGhpcy5oWzJdO1xuICB2YXIgZCA9IHRoaXMuaFszXTtcbiAgdmFyIGUgPSB0aGlzLmhbNF07XG4gIHZhciBmID0gdGhpcy5oWzVdO1xuICB2YXIgZyA9IHRoaXMuaFs2XTtcbiAgdmFyIGggPSB0aGlzLmhbN107XG5cbiAgYXNzZXJ0KHRoaXMuay5sZW5ndGggPT09IFcubGVuZ3RoKTtcbiAgZm9yIChpID0gMDsgaSA8IFcubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgVDEgPSBzdW0zMl81KGgsIHMxXzI1NihlKSwgY2gzMihlLCBmLCBnKSwgdGhpcy5rW2ldLCBXW2ldKTtcbiAgICB2YXIgVDIgPSBzdW0zMihzMF8yNTYoYSksIG1hajMyKGEsIGIsIGMpKTtcbiAgICBoID0gZztcbiAgICBnID0gZjtcbiAgICBmID0gZTtcbiAgICBlID0gc3VtMzIoZCwgVDEpO1xuICAgIGQgPSBjO1xuICAgIGMgPSBiO1xuICAgIGIgPSBhO1xuICAgIGEgPSBzdW0zMihUMSwgVDIpO1xuICB9XG5cbiAgdGhpcy5oWzBdID0gc3VtMzIodGhpcy5oWzBdLCBhKTtcbiAgdGhpcy5oWzFdID0gc3VtMzIodGhpcy5oWzFdLCBiKTtcbiAgdGhpcy5oWzJdID0gc3VtMzIodGhpcy5oWzJdLCBjKTtcbiAgdGhpcy5oWzNdID0gc3VtMzIodGhpcy5oWzNdLCBkKTtcbiAgdGhpcy5oWzRdID0gc3VtMzIodGhpcy5oWzRdLCBlKTtcbiAgdGhpcy5oWzVdID0gc3VtMzIodGhpcy5oWzVdLCBmKTtcbiAgdGhpcy5oWzZdID0gc3VtMzIodGhpcy5oWzZdLCBnKTtcbiAgdGhpcy5oWzddID0gc3VtMzIodGhpcy5oWzddLCBoKTtcbn07XG5cblNIQTI1Ni5wcm90b3R5cGUuX2RpZ2VzdCA9IGZ1bmN0aW9uIGRpZ2VzdChlbmMpIHtcbiAgaWYgKGVuYyA9PT0gJ2hleCcpXG4gICAgcmV0dXJuIHV0aWxzLnRvSGV4MzIodGhpcy5oLCAnYmlnJyk7XG4gIGVsc2VcbiAgICByZXR1cm4gdXRpbHMuc3BsaXQzMih0aGlzLmgsICdiaWcnKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbnZhciBTSEE1MTIgPSByZXF1aXJlKCcuLzUxMicpO1xuXG5mdW5jdGlvbiBTSEEzODQoKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTSEEzODQpKVxuICAgIHJldHVybiBuZXcgU0hBMzg0KCk7XG5cbiAgU0hBNTEyLmNhbGwodGhpcyk7XG4gIHRoaXMuaCA9IFtcbiAgICAweGNiYmI5ZDVkLCAweGMxMDU5ZWQ4LFxuICAgIDB4NjI5YTI5MmEsIDB4MzY3Y2Q1MDcsXG4gICAgMHg5MTU5MDE1YSwgMHgzMDcwZGQxNyxcbiAgICAweDE1MmZlY2Q4LCAweGY3MGU1OTM5LFxuICAgIDB4NjczMzI2NjcsIDB4ZmZjMDBiMzEsXG4gICAgMHg4ZWI0NGE4NywgMHg2ODU4MTUxMSxcbiAgICAweGRiMGMyZTBkLCAweDY0Zjk4ZmE3LFxuICAgIDB4NDdiNTQ4MWQsIDB4YmVmYTRmYTQgXTtcbn1cbnV0aWxzLmluaGVyaXRzKFNIQTM4NCwgU0hBNTEyKTtcbm1vZHVsZS5leHBvcnRzID0gU0hBMzg0O1xuXG5TSEEzODQuYmxvY2tTaXplID0gMTAyNDtcblNIQTM4NC5vdXRTaXplID0gMzg0O1xuU0hBMzg0LmhtYWNTdHJlbmd0aCA9IDE5MjtcblNIQTM4NC5wYWRMZW5ndGggPSAxMjg7XG5cblNIQTM4NC5wcm90b3R5cGUuX2RpZ2VzdCA9IGZ1bmN0aW9uIGRpZ2VzdChlbmMpIHtcbiAgaWYgKGVuYyA9PT0gJ2hleCcpXG4gICAgcmV0dXJuIHV0aWxzLnRvSGV4MzIodGhpcy5oLnNsaWNlKDAsIDEyKSwgJ2JpZycpO1xuICBlbHNlXG4gICAgcmV0dXJuIHV0aWxzLnNwbGl0MzIodGhpcy5oLnNsaWNlKDAsIDEyKSwgJ2JpZycpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBjb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdtaW5pbWFsaXN0aWMtYXNzZXJ0Jyk7XG5cbnZhciByb3RyNjRfaGkgPSB1dGlscy5yb3RyNjRfaGk7XG52YXIgcm90cjY0X2xvID0gdXRpbHMucm90cjY0X2xvO1xudmFyIHNocjY0X2hpID0gdXRpbHMuc2hyNjRfaGk7XG52YXIgc2hyNjRfbG8gPSB1dGlscy5zaHI2NF9sbztcbnZhciBzdW02NCA9IHV0aWxzLnN1bTY0O1xudmFyIHN1bTY0X2hpID0gdXRpbHMuc3VtNjRfaGk7XG52YXIgc3VtNjRfbG8gPSB1dGlscy5zdW02NF9sbztcbnZhciBzdW02NF80X2hpID0gdXRpbHMuc3VtNjRfNF9oaTtcbnZhciBzdW02NF80X2xvID0gdXRpbHMuc3VtNjRfNF9sbztcbnZhciBzdW02NF81X2hpID0gdXRpbHMuc3VtNjRfNV9oaTtcbnZhciBzdW02NF81X2xvID0gdXRpbHMuc3VtNjRfNV9sbztcblxudmFyIEJsb2NrSGFzaCA9IGNvbW1vbi5CbG9ja0hhc2g7XG5cbnZhciBzaGE1MTJfSyA9IFtcbiAgMHg0MjhhMmY5OCwgMHhkNzI4YWUyMiwgMHg3MTM3NDQ5MSwgMHgyM2VmNjVjZCxcbiAgMHhiNWMwZmJjZiwgMHhlYzRkM2IyZiwgMHhlOWI1ZGJhNSwgMHg4MTg5ZGJiYyxcbiAgMHgzOTU2YzI1YiwgMHhmMzQ4YjUzOCwgMHg1OWYxMTFmMSwgMHhiNjA1ZDAxOSxcbiAgMHg5MjNmODJhNCwgMHhhZjE5NGY5YiwgMHhhYjFjNWVkNSwgMHhkYTZkODExOCxcbiAgMHhkODA3YWE5OCwgMHhhMzAzMDI0MiwgMHgxMjgzNWIwMSwgMHg0NTcwNmZiZSxcbiAgMHgyNDMxODViZSwgMHg0ZWU0YjI4YywgMHg1NTBjN2RjMywgMHhkNWZmYjRlMixcbiAgMHg3MmJlNWQ3NCwgMHhmMjdiODk2ZiwgMHg4MGRlYjFmZSwgMHgzYjE2OTZiMSxcbiAgMHg5YmRjMDZhNywgMHgyNWM3MTIzNSwgMHhjMTliZjE3NCwgMHhjZjY5MjY5NCxcbiAgMHhlNDliNjljMSwgMHg5ZWYxNGFkMiwgMHhlZmJlNDc4NiwgMHgzODRmMjVlMyxcbiAgMHgwZmMxOWRjNiwgMHg4YjhjZDViNSwgMHgyNDBjYTFjYywgMHg3N2FjOWM2NSxcbiAgMHgyZGU5MmM2ZiwgMHg1OTJiMDI3NSwgMHg0YTc0ODRhYSwgMHg2ZWE2ZTQ4MyxcbiAgMHg1Y2IwYTlkYywgMHhiZDQxZmJkNCwgMHg3NmY5ODhkYSwgMHg4MzExNTNiNSxcbiAgMHg5ODNlNTE1MiwgMHhlZTY2ZGZhYiwgMHhhODMxYzY2ZCwgMHgyZGI0MzIxMCxcbiAgMHhiMDAzMjdjOCwgMHg5OGZiMjEzZiwgMHhiZjU5N2ZjNywgMHhiZWVmMGVlNCxcbiAgMHhjNmUwMGJmMywgMHgzZGE4OGZjMiwgMHhkNWE3OTE0NywgMHg5MzBhYTcyNSxcbiAgMHgwNmNhNjM1MSwgMHhlMDAzODI2ZiwgMHgxNDI5Mjk2NywgMHgwYTBlNmU3MCxcbiAgMHgyN2I3MGE4NSwgMHg0NmQyMmZmYywgMHgyZTFiMjEzOCwgMHg1YzI2YzkyNixcbiAgMHg0ZDJjNmRmYywgMHg1YWM0MmFlZCwgMHg1MzM4MGQxMywgMHg5ZDk1YjNkZixcbiAgMHg2NTBhNzM1NCwgMHg4YmFmNjNkZSwgMHg3NjZhMGFiYiwgMHgzYzc3YjJhOCxcbiAgMHg4MWMyYzkyZSwgMHg0N2VkYWVlNiwgMHg5MjcyMmM4NSwgMHgxNDgyMzUzYixcbiAgMHhhMmJmZThhMSwgMHg0Y2YxMDM2NCwgMHhhODFhNjY0YiwgMHhiYzQyMzAwMSxcbiAgMHhjMjRiOGI3MCwgMHhkMGY4OTc5MSwgMHhjNzZjNTFhMywgMHgwNjU0YmUzMCxcbiAgMHhkMTkyZTgxOSwgMHhkNmVmNTIxOCwgMHhkNjk5MDYyNCwgMHg1NTY1YTkxMCxcbiAgMHhmNDBlMzU4NSwgMHg1NzcxMjAyYSwgMHgxMDZhYTA3MCwgMHgzMmJiZDFiOCxcbiAgMHgxOWE0YzExNiwgMHhiOGQyZDBjOCwgMHgxZTM3NmMwOCwgMHg1MTQxYWI1MyxcbiAgMHgyNzQ4Nzc0YywgMHhkZjhlZWI5OSwgMHgzNGIwYmNiNSwgMHhlMTliNDhhOCxcbiAgMHgzOTFjMGNiMywgMHhjNWM5NWE2MywgMHg0ZWQ4YWE0YSwgMHhlMzQxOGFjYixcbiAgMHg1YjljY2E0ZiwgMHg3NzYzZTM3MywgMHg2ODJlNmZmMywgMHhkNmIyYjhhMyxcbiAgMHg3NDhmODJlZSwgMHg1ZGVmYjJmYywgMHg3OGE1NjM2ZiwgMHg0MzE3MmY2MCxcbiAgMHg4NGM4NzgxNCwgMHhhMWYwYWI3MiwgMHg4Y2M3MDIwOCwgMHgxYTY0MzllYyxcbiAgMHg5MGJlZmZmYSwgMHgyMzYzMWUyOCwgMHhhNDUwNmNlYiwgMHhkZTgyYmRlOSxcbiAgMHhiZWY5YTNmNywgMHhiMmM2NzkxNSwgMHhjNjcxNzhmMiwgMHhlMzcyNTMyYixcbiAgMHhjYTI3M2VjZSwgMHhlYTI2NjE5YywgMHhkMTg2YjhjNywgMHgyMWMwYzIwNyxcbiAgMHhlYWRhN2RkNiwgMHhjZGUwZWIxZSwgMHhmNTdkNGY3ZiwgMHhlZTZlZDE3OCxcbiAgMHgwNmYwNjdhYSwgMHg3MjE3NmZiYSwgMHgwYTYzN2RjNSwgMHhhMmM4OThhNixcbiAgMHgxMTNmOTgwNCwgMHhiZWY5MGRhZSwgMHgxYjcxMGIzNSwgMHgxMzFjNDcxYixcbiAgMHgyOGRiNzdmNSwgMHgyMzA0N2Q4NCwgMHgzMmNhYWI3YiwgMHg0MGM3MjQ5MyxcbiAgMHgzYzllYmUwYSwgMHgxNWM5YmViYywgMHg0MzFkNjdjNCwgMHg5YzEwMGQ0YyxcbiAgMHg0Y2M1ZDRiZSwgMHhjYjNlNDJiNiwgMHg1OTdmMjk5YywgMHhmYzY1N2UyYSxcbiAgMHg1ZmNiNmZhYiwgMHgzYWQ2ZmFlYywgMHg2YzQ0MTk4YywgMHg0YTQ3NTgxN1xuXTtcblxuZnVuY3Rpb24gU0hBNTEyKCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU0hBNTEyKSlcbiAgICByZXR1cm4gbmV3IFNIQTUxMigpO1xuXG4gIEJsb2NrSGFzaC5jYWxsKHRoaXMpO1xuICB0aGlzLmggPSBbXG4gICAgMHg2YTA5ZTY2NywgMHhmM2JjYzkwOCxcbiAgICAweGJiNjdhZTg1LCAweDg0Y2FhNzNiLFxuICAgIDB4M2M2ZWYzNzIsIDB4ZmU5NGY4MmIsXG4gICAgMHhhNTRmZjUzYSwgMHg1ZjFkMzZmMSxcbiAgICAweDUxMGU1MjdmLCAweGFkZTY4MmQxLFxuICAgIDB4OWIwNTY4OGMsIDB4MmIzZTZjMWYsXG4gICAgMHgxZjgzZDlhYiwgMHhmYjQxYmQ2YixcbiAgICAweDViZTBjZDE5LCAweDEzN2UyMTc5IF07XG4gIHRoaXMuayA9IHNoYTUxMl9LO1xuICB0aGlzLlcgPSBuZXcgQXJyYXkoMTYwKTtcbn1cbnV0aWxzLmluaGVyaXRzKFNIQTUxMiwgQmxvY2tIYXNoKTtcbm1vZHVsZS5leHBvcnRzID0gU0hBNTEyO1xuXG5TSEE1MTIuYmxvY2tTaXplID0gMTAyNDtcblNIQTUxMi5vdXRTaXplID0gNTEyO1xuU0hBNTEyLmhtYWNTdHJlbmd0aCA9IDE5MjtcblNIQTUxMi5wYWRMZW5ndGggPSAxMjg7XG5cblNIQTUxMi5wcm90b3R5cGUuX3ByZXBhcmVCbG9jayA9IGZ1bmN0aW9uIF9wcmVwYXJlQmxvY2sobXNnLCBzdGFydCkge1xuICB2YXIgVyA9IHRoaXMuVztcblxuICAvLyAzMiB4IDMyYml0IHdvcmRzXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMzI7IGkrKylcbiAgICBXW2ldID0gbXNnW3N0YXJ0ICsgaV07XG4gIGZvciAoOyBpIDwgVy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciBjMF9oaSA9IGcxXzUxMl9oaShXW2kgLSA0XSwgV1tpIC0gM10pOyAgLy8gaSAtIDJcbiAgICB2YXIgYzBfbG8gPSBnMV81MTJfbG8oV1tpIC0gNF0sIFdbaSAtIDNdKTtcbiAgICB2YXIgYzFfaGkgPSBXW2kgLSAxNF07ICAvLyBpIC0gN1xuICAgIHZhciBjMV9sbyA9IFdbaSAtIDEzXTtcbiAgICB2YXIgYzJfaGkgPSBnMF81MTJfaGkoV1tpIC0gMzBdLCBXW2kgLSAyOV0pOyAgLy8gaSAtIDE1XG4gICAgdmFyIGMyX2xvID0gZzBfNTEyX2xvKFdbaSAtIDMwXSwgV1tpIC0gMjldKTtcbiAgICB2YXIgYzNfaGkgPSBXW2kgLSAzMl07ICAvLyBpIC0gMTZcbiAgICB2YXIgYzNfbG8gPSBXW2kgLSAzMV07XG5cbiAgICBXW2ldID0gc3VtNjRfNF9oaShcbiAgICAgIGMwX2hpLCBjMF9sbyxcbiAgICAgIGMxX2hpLCBjMV9sbyxcbiAgICAgIGMyX2hpLCBjMl9sbyxcbiAgICAgIGMzX2hpLCBjM19sbyk7XG4gICAgV1tpICsgMV0gPSBzdW02NF80X2xvKFxuICAgICAgYzBfaGksIGMwX2xvLFxuICAgICAgYzFfaGksIGMxX2xvLFxuICAgICAgYzJfaGksIGMyX2xvLFxuICAgICAgYzNfaGksIGMzX2xvKTtcbiAgfVxufTtcblxuU0hBNTEyLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gX3VwZGF0ZShtc2csIHN0YXJ0KSB7XG4gIHRoaXMuX3ByZXBhcmVCbG9jayhtc2csIHN0YXJ0KTtcblxuICB2YXIgVyA9IHRoaXMuVztcblxuICB2YXIgYWggPSB0aGlzLmhbMF07XG4gIHZhciBhbCA9IHRoaXMuaFsxXTtcbiAgdmFyIGJoID0gdGhpcy5oWzJdO1xuICB2YXIgYmwgPSB0aGlzLmhbM107XG4gIHZhciBjaCA9IHRoaXMuaFs0XTtcbiAgdmFyIGNsID0gdGhpcy5oWzVdO1xuICB2YXIgZGggPSB0aGlzLmhbNl07XG4gIHZhciBkbCA9IHRoaXMuaFs3XTtcbiAgdmFyIGVoID0gdGhpcy5oWzhdO1xuICB2YXIgZWwgPSB0aGlzLmhbOV07XG4gIHZhciBmaCA9IHRoaXMuaFsxMF07XG4gIHZhciBmbCA9IHRoaXMuaFsxMV07XG4gIHZhciBnaCA9IHRoaXMuaFsxMl07XG4gIHZhciBnbCA9IHRoaXMuaFsxM107XG4gIHZhciBoaCA9IHRoaXMuaFsxNF07XG4gIHZhciBobCA9IHRoaXMuaFsxNV07XG5cbiAgYXNzZXJ0KHRoaXMuay5sZW5ndGggPT09IFcubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBXLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgdmFyIGMwX2hpID0gaGg7XG4gICAgdmFyIGMwX2xvID0gaGw7XG4gICAgdmFyIGMxX2hpID0gczFfNTEyX2hpKGVoLCBlbCk7XG4gICAgdmFyIGMxX2xvID0gczFfNTEyX2xvKGVoLCBlbCk7XG4gICAgdmFyIGMyX2hpID0gY2g2NF9oaShlaCwgZWwsIGZoLCBmbCwgZ2gsIGdsKTtcbiAgICB2YXIgYzJfbG8gPSBjaDY0X2xvKGVoLCBlbCwgZmgsIGZsLCBnaCwgZ2wpO1xuICAgIHZhciBjM19oaSA9IHRoaXMua1tpXTtcbiAgICB2YXIgYzNfbG8gPSB0aGlzLmtbaSArIDFdO1xuICAgIHZhciBjNF9oaSA9IFdbaV07XG4gICAgdmFyIGM0X2xvID0gV1tpICsgMV07XG5cbiAgICB2YXIgVDFfaGkgPSBzdW02NF81X2hpKFxuICAgICAgYzBfaGksIGMwX2xvLFxuICAgICAgYzFfaGksIGMxX2xvLFxuICAgICAgYzJfaGksIGMyX2xvLFxuICAgICAgYzNfaGksIGMzX2xvLFxuICAgICAgYzRfaGksIGM0X2xvKTtcbiAgICB2YXIgVDFfbG8gPSBzdW02NF81X2xvKFxuICAgICAgYzBfaGksIGMwX2xvLFxuICAgICAgYzFfaGksIGMxX2xvLFxuICAgICAgYzJfaGksIGMyX2xvLFxuICAgICAgYzNfaGksIGMzX2xvLFxuICAgICAgYzRfaGksIGM0X2xvKTtcblxuICAgIGMwX2hpID0gczBfNTEyX2hpKGFoLCBhbCk7XG4gICAgYzBfbG8gPSBzMF81MTJfbG8oYWgsIGFsKTtcbiAgICBjMV9oaSA9IG1hajY0X2hpKGFoLCBhbCwgYmgsIGJsLCBjaCwgY2wpO1xuICAgIGMxX2xvID0gbWFqNjRfbG8oYWgsIGFsLCBiaCwgYmwsIGNoLCBjbCk7XG5cbiAgICB2YXIgVDJfaGkgPSBzdW02NF9oaShjMF9oaSwgYzBfbG8sIGMxX2hpLCBjMV9sbyk7XG4gICAgdmFyIFQyX2xvID0gc3VtNjRfbG8oYzBfaGksIGMwX2xvLCBjMV9oaSwgYzFfbG8pO1xuXG4gICAgaGggPSBnaDtcbiAgICBobCA9IGdsO1xuXG4gICAgZ2ggPSBmaDtcbiAgICBnbCA9IGZsO1xuXG4gICAgZmggPSBlaDtcbiAgICBmbCA9IGVsO1xuXG4gICAgZWggPSBzdW02NF9oaShkaCwgZGwsIFQxX2hpLCBUMV9sbyk7XG4gICAgZWwgPSBzdW02NF9sbyhkbCwgZGwsIFQxX2hpLCBUMV9sbyk7XG5cbiAgICBkaCA9IGNoO1xuICAgIGRsID0gY2w7XG5cbiAgICBjaCA9IGJoO1xuICAgIGNsID0gYmw7XG5cbiAgICBiaCA9IGFoO1xuICAgIGJsID0gYWw7XG5cbiAgICBhaCA9IHN1bTY0X2hpKFQxX2hpLCBUMV9sbywgVDJfaGksIFQyX2xvKTtcbiAgICBhbCA9IHN1bTY0X2xvKFQxX2hpLCBUMV9sbywgVDJfaGksIFQyX2xvKTtcbiAgfVxuXG4gIHN1bTY0KHRoaXMuaCwgMCwgYWgsIGFsKTtcbiAgc3VtNjQodGhpcy5oLCAyLCBiaCwgYmwpO1xuICBzdW02NCh0aGlzLmgsIDQsIGNoLCBjbCk7XG4gIHN1bTY0KHRoaXMuaCwgNiwgZGgsIGRsKTtcbiAgc3VtNjQodGhpcy5oLCA4LCBlaCwgZWwpO1xuICBzdW02NCh0aGlzLmgsIDEwLCBmaCwgZmwpO1xuICBzdW02NCh0aGlzLmgsIDEyLCBnaCwgZ2wpO1xuICBzdW02NCh0aGlzLmgsIDE0LCBoaCwgaGwpO1xufTtcblxuU0hBNTEyLnByb3RvdHlwZS5fZGlnZXN0ID0gZnVuY3Rpb24gZGlnZXN0KGVuYykge1xuICBpZiAoZW5jID09PSAnaGV4JylcbiAgICByZXR1cm4gdXRpbHMudG9IZXgzMih0aGlzLmgsICdiaWcnKTtcbiAgZWxzZVxuICAgIHJldHVybiB1dGlscy5zcGxpdDMyKHRoaXMuaCwgJ2JpZycpO1xufTtcblxuZnVuY3Rpb24gY2g2NF9oaSh4aCwgeGwsIHloLCB5bCwgemgpIHtcbiAgdmFyIHIgPSAoeGggJiB5aCkgXiAoKH54aCkgJiB6aCk7XG4gIGlmIChyIDwgMClcbiAgICByICs9IDB4MTAwMDAwMDAwO1xuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gY2g2NF9sbyh4aCwgeGwsIHloLCB5bCwgemgsIHpsKSB7XG4gIHZhciByID0gKHhsICYgeWwpIF4gKCh+eGwpICYgemwpO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIG1hajY0X2hpKHhoLCB4bCwgeWgsIHlsLCB6aCkge1xuICB2YXIgciA9ICh4aCAmIHloKSBeICh4aCAmIHpoKSBeICh5aCAmIHpoKTtcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBtYWo2NF9sbyh4aCwgeGwsIHloLCB5bCwgemgsIHpsKSB7XG4gIHZhciByID0gKHhsICYgeWwpIF4gKHhsICYgemwpIF4gKHlsICYgemwpO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIHMwXzUxMl9oaSh4aCwgeGwpIHtcbiAgdmFyIGMwX2hpID0gcm90cjY0X2hpKHhoLCB4bCwgMjgpO1xuICB2YXIgYzFfaGkgPSByb3RyNjRfaGkoeGwsIHhoLCAyKTsgIC8vIDM0XG4gIHZhciBjMl9oaSA9IHJvdHI2NF9oaSh4bCwgeGgsIDcpOyAgLy8gMzlcblxuICB2YXIgciA9IGMwX2hpIF4gYzFfaGkgXiBjMl9oaTtcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBzMF81MTJfbG8oeGgsIHhsKSB7XG4gIHZhciBjMF9sbyA9IHJvdHI2NF9sbyh4aCwgeGwsIDI4KTtcbiAgdmFyIGMxX2xvID0gcm90cjY0X2xvKHhsLCB4aCwgMik7ICAvLyAzNFxuICB2YXIgYzJfbG8gPSByb3RyNjRfbG8oeGwsIHhoLCA3KTsgIC8vIDM5XG5cbiAgdmFyIHIgPSBjMF9sbyBeIGMxX2xvIF4gYzJfbG87XG4gIGlmIChyIDwgMClcbiAgICByICs9IDB4MTAwMDAwMDAwO1xuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gczFfNTEyX2hpKHhoLCB4bCkge1xuICB2YXIgYzBfaGkgPSByb3RyNjRfaGkoeGgsIHhsLCAxNCk7XG4gIHZhciBjMV9oaSA9IHJvdHI2NF9oaSh4aCwgeGwsIDE4KTtcbiAgdmFyIGMyX2hpID0gcm90cjY0X2hpKHhsLCB4aCwgOSk7ICAvLyA0MVxuXG4gIHZhciByID0gYzBfaGkgXiBjMV9oaSBeIGMyX2hpO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIHMxXzUxMl9sbyh4aCwgeGwpIHtcbiAgdmFyIGMwX2xvID0gcm90cjY0X2xvKHhoLCB4bCwgMTQpO1xuICB2YXIgYzFfbG8gPSByb3RyNjRfbG8oeGgsIHhsLCAxOCk7XG4gIHZhciBjMl9sbyA9IHJvdHI2NF9sbyh4bCwgeGgsIDkpOyAgLy8gNDFcblxuICB2YXIgciA9IGMwX2xvIF4gYzFfbG8gXiBjMl9sbztcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBnMF81MTJfaGkoeGgsIHhsKSB7XG4gIHZhciBjMF9oaSA9IHJvdHI2NF9oaSh4aCwgeGwsIDEpO1xuICB2YXIgYzFfaGkgPSByb3RyNjRfaGkoeGgsIHhsLCA4KTtcbiAgdmFyIGMyX2hpID0gc2hyNjRfaGkoeGgsIHhsLCA3KTtcblxuICB2YXIgciA9IGMwX2hpIF4gYzFfaGkgXiBjMl9oaTtcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBnMF81MTJfbG8oeGgsIHhsKSB7XG4gIHZhciBjMF9sbyA9IHJvdHI2NF9sbyh4aCwgeGwsIDEpO1xuICB2YXIgYzFfbG8gPSByb3RyNjRfbG8oeGgsIHhsLCA4KTtcbiAgdmFyIGMyX2xvID0gc2hyNjRfbG8oeGgsIHhsLCA3KTtcblxuICB2YXIgciA9IGMwX2xvIF4gYzFfbG8gXiBjMl9sbztcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBnMV81MTJfaGkoeGgsIHhsKSB7XG4gIHZhciBjMF9oaSA9IHJvdHI2NF9oaSh4aCwgeGwsIDE5KTtcbiAgdmFyIGMxX2hpID0gcm90cjY0X2hpKHhsLCB4aCwgMjkpOyAgLy8gNjFcbiAgdmFyIGMyX2hpID0gc2hyNjRfaGkoeGgsIHhsLCA2KTtcblxuICB2YXIgciA9IGMwX2hpIF4gYzFfaGkgXiBjMl9oaTtcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBnMV81MTJfbG8oeGgsIHhsKSB7XG4gIHZhciBjMF9sbyA9IHJvdHI2NF9sbyh4aCwgeGwsIDE5KTtcbiAgdmFyIGMxX2xvID0gcm90cjY0X2xvKHhsLCB4aCwgMjkpOyAgLy8gNjFcbiAgdmFyIGMyX2xvID0gc2hyNjRfbG8oeGgsIHhsLCA2KTtcblxuICB2YXIgciA9IGMwX2xvIF4gYzFfbG8gXiBjMl9sbztcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIHJvdHIzMiA9IHV0aWxzLnJvdHIzMjtcblxuZnVuY3Rpb24gZnRfMShzLCB4LCB5LCB6KSB7XG4gIGlmIChzID09PSAwKVxuICAgIHJldHVybiBjaDMyKHgsIHksIHopO1xuICBpZiAocyA9PT0gMSB8fCBzID09PSAzKVxuICAgIHJldHVybiBwMzIoeCwgeSwgeik7XG4gIGlmIChzID09PSAyKVxuICAgIHJldHVybiBtYWozMih4LCB5LCB6KTtcbn1cbmV4cG9ydHMuZnRfMSA9IGZ0XzE7XG5cbmZ1bmN0aW9uIGNoMzIoeCwgeSwgeikge1xuICByZXR1cm4gKHggJiB5KSBeICgofngpICYgeik7XG59XG5leHBvcnRzLmNoMzIgPSBjaDMyO1xuXG5mdW5jdGlvbiBtYWozMih4LCB5LCB6KSB7XG4gIHJldHVybiAoeCAmIHkpIF4gKHggJiB6KSBeICh5ICYgeik7XG59XG5leHBvcnRzLm1hajMyID0gbWFqMzI7XG5cbmZ1bmN0aW9uIHAzMih4LCB5LCB6KSB7XG4gIHJldHVybiB4IF4geSBeIHo7XG59XG5leHBvcnRzLnAzMiA9IHAzMjtcblxuZnVuY3Rpb24gczBfMjU2KHgpIHtcbiAgcmV0dXJuIHJvdHIzMih4LCAyKSBeIHJvdHIzMih4LCAxMykgXiByb3RyMzIoeCwgMjIpO1xufVxuZXhwb3J0cy5zMF8yNTYgPSBzMF8yNTY7XG5cbmZ1bmN0aW9uIHMxXzI1Nih4KSB7XG4gIHJldHVybiByb3RyMzIoeCwgNikgXiByb3RyMzIoeCwgMTEpIF4gcm90cjMyKHgsIDI1KTtcbn1cbmV4cG9ydHMuczFfMjU2ID0gczFfMjU2O1xuXG5mdW5jdGlvbiBnMF8yNTYoeCkge1xuICByZXR1cm4gcm90cjMyKHgsIDcpIF4gcm90cjMyKHgsIDE4KSBeICh4ID4+PiAzKTtcbn1cbmV4cG9ydHMuZzBfMjU2ID0gZzBfMjU2O1xuXG5mdW5jdGlvbiBnMV8yNTYoeCkge1xuICByZXR1cm4gcm90cjMyKHgsIDE3KSBeIHJvdHIzMih4LCAxOSkgXiAoeCA+Pj4gMTApO1xufVxuZXhwb3J0cy5nMV8yNTYgPSBnMV8yNTY7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdtaW5pbWFsaXN0aWMtYXNzZXJ0Jyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5leHBvcnRzLmluaGVyaXRzID0gaW5oZXJpdHM7XG5cbmZ1bmN0aW9uIGlzU3Vycm9nYXRlUGFpcihtc2csIGkpIHtcbiAgaWYgKChtc2cuY2hhckNvZGVBdChpKSAmIDB4RkMwMCkgIT09IDB4RDgwMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoaSA8IDAgfHwgaSArIDEgPj0gbXNnLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gKG1zZy5jaGFyQ29kZUF0KGkgKyAxKSAmIDB4RkMwMCkgPT09IDB4REMwMDtcbn1cblxuZnVuY3Rpb24gdG9BcnJheShtc2csIGVuYykge1xuICBpZiAoQXJyYXkuaXNBcnJheShtc2cpKVxuICAgIHJldHVybiBtc2cuc2xpY2UoKTtcbiAgaWYgKCFtc2cpXG4gICAgcmV0dXJuIFtdO1xuICB2YXIgcmVzID0gW107XG4gIGlmICh0eXBlb2YgbXNnID09PSAnc3RyaW5nJykge1xuICAgIGlmICghZW5jKSB7XG4gICAgICAvLyBJbnNwaXJlZCBieSBzdHJpbmdUb1V0ZjhCeXRlQXJyYXkoKSBpbiBjbG9zdXJlLWxpYnJhcnkgYnkgR29vZ2xlXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL2Nsb3N1cmUtbGlicmFyeS9ibG9iLzg1OThkODcyNDJhZjU5YWFjMjMzMjcwNzQyYzg5ODRlMmIyYmRiZTAvY2xvc3VyZS9nb29nL2NyeXB0L2NyeXB0LmpzI0wxMTctTDE0M1xuICAgICAgLy8gQXBhY2hlIExpY2Vuc2UgMi4wXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL2Nsb3N1cmUtbGlicmFyeS9ibG9iL21hc3Rlci9MSUNFTlNFXG4gICAgICB2YXIgcCA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYyA9IG1zZy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8IDEyOCkge1xuICAgICAgICAgIHJlc1twKytdID0gYztcbiAgICAgICAgfSBlbHNlIGlmIChjIDwgMjA0OCkge1xuICAgICAgICAgIHJlc1twKytdID0gKGMgPj4gNikgfCAxOTI7XG4gICAgICAgICAgcmVzW3ArK10gPSAoYyAmIDYzKSB8IDEyODtcbiAgICAgICAgfSBlbHNlIGlmIChpc1N1cnJvZ2F0ZVBhaXIobXNnLCBpKSkge1xuICAgICAgICAgIGMgPSAweDEwMDAwICsgKChjICYgMHgwM0ZGKSA8PCAxMCkgKyAobXNnLmNoYXJDb2RlQXQoKytpKSAmIDB4MDNGRik7XG4gICAgICAgICAgcmVzW3ArK10gPSAoYyA+PiAxOCkgfCAyNDA7XG4gICAgICAgICAgcmVzW3ArK10gPSAoKGMgPj4gMTIpICYgNjMpIHwgMTI4O1xuICAgICAgICAgIHJlc1twKytdID0gKChjID4+IDYpICYgNjMpIHwgMTI4O1xuICAgICAgICAgIHJlc1twKytdID0gKGMgJiA2MykgfCAxMjg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzW3ArK10gPSAoYyA+PiAxMikgfCAyMjQ7XG4gICAgICAgICAgcmVzW3ArK10gPSAoKGMgPj4gNikgJiA2MykgfCAxMjg7XG4gICAgICAgICAgcmVzW3ArK10gPSAoYyAmIDYzKSB8IDEyODtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZW5jID09PSAnaGV4Jykge1xuICAgICAgbXNnID0gbXNnLnJlcGxhY2UoL1teYS16MC05XSsvaWcsICcnKTtcbiAgICAgIGlmIChtc2cubGVuZ3RoICUgMiAhPT0gMClcbiAgICAgICAgbXNnID0gJzAnICsgbXNnO1xuICAgICAgZm9yIChpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkgKz0gMilcbiAgICAgICAgcmVzLnB1c2gocGFyc2VJbnQobXNnW2ldICsgbXNnW2kgKyAxXSwgMTYpKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yIChpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKylcbiAgICAgIHJlc1tpXSA9IG1zZ1tpXSB8IDA7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbmV4cG9ydHMudG9BcnJheSA9IHRvQXJyYXk7XG5cbmZ1bmN0aW9uIHRvSGV4KG1zZykge1xuICB2YXIgcmVzID0gJyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKVxuICAgIHJlcyArPSB6ZXJvMihtc2dbaV0udG9TdHJpbmcoMTYpKTtcbiAgcmV0dXJuIHJlcztcbn1cbmV4cG9ydHMudG9IZXggPSB0b0hleDtcblxuZnVuY3Rpb24gaHRvbmwodykge1xuICB2YXIgcmVzID0gKHcgPj4+IDI0KSB8XG4gICAgICAgICAgICAoKHcgPj4+IDgpICYgMHhmZjAwKSB8XG4gICAgICAgICAgICAoKHcgPDwgOCkgJiAweGZmMDAwMCkgfFxuICAgICAgICAgICAgKCh3ICYgMHhmZikgPDwgMjQpO1xuICByZXR1cm4gcmVzID4+PiAwO1xufVxuZXhwb3J0cy5odG9ubCA9IGh0b25sO1xuXG5mdW5jdGlvbiB0b0hleDMyKG1zZywgZW5kaWFuKSB7XG4gIHZhciByZXMgPSAnJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdyA9IG1zZ1tpXTtcbiAgICBpZiAoZW5kaWFuID09PSAnbGl0dGxlJylcbiAgICAgIHcgPSBodG9ubCh3KTtcbiAgICByZXMgKz0gemVybzgody50b1N0cmluZygxNikpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5leHBvcnRzLnRvSGV4MzIgPSB0b0hleDMyO1xuXG5mdW5jdGlvbiB6ZXJvMih3b3JkKSB7XG4gIGlmICh3b3JkLmxlbmd0aCA9PT0gMSlcbiAgICByZXR1cm4gJzAnICsgd29yZDtcbiAgZWxzZVxuICAgIHJldHVybiB3b3JkO1xufVxuZXhwb3J0cy56ZXJvMiA9IHplcm8yO1xuXG5mdW5jdGlvbiB6ZXJvOCh3b3JkKSB7XG4gIGlmICh3b3JkLmxlbmd0aCA9PT0gNylcbiAgICByZXR1cm4gJzAnICsgd29yZDtcbiAgZWxzZSBpZiAod29yZC5sZW5ndGggPT09IDYpXG4gICAgcmV0dXJuICcwMCcgKyB3b3JkO1xuICBlbHNlIGlmICh3b3JkLmxlbmd0aCA9PT0gNSlcbiAgICByZXR1cm4gJzAwMCcgKyB3b3JkO1xuICBlbHNlIGlmICh3b3JkLmxlbmd0aCA9PT0gNClcbiAgICByZXR1cm4gJzAwMDAnICsgd29yZDtcbiAgZWxzZSBpZiAod29yZC5sZW5ndGggPT09IDMpXG4gICAgcmV0dXJuICcwMDAwMCcgKyB3b3JkO1xuICBlbHNlIGlmICh3b3JkLmxlbmd0aCA9PT0gMilcbiAgICByZXR1cm4gJzAwMDAwMCcgKyB3b3JkO1xuICBlbHNlIGlmICh3b3JkLmxlbmd0aCA9PT0gMSlcbiAgICByZXR1cm4gJzAwMDAwMDAnICsgd29yZDtcbiAgZWxzZVxuICAgIHJldHVybiB3b3JkO1xufVxuZXhwb3J0cy56ZXJvOCA9IHplcm84O1xuXG5mdW5jdGlvbiBqb2luMzIobXNnLCBzdGFydCwgZW5kLCBlbmRpYW4pIHtcbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0O1xuICBhc3NlcnQobGVuICUgNCA9PT0gMCk7XG4gIHZhciByZXMgPSBuZXcgQXJyYXkobGVuIC8gNCk7XG4gIGZvciAodmFyIGkgPSAwLCBrID0gc3RhcnQ7IGkgPCByZXMubGVuZ3RoOyBpKyssIGsgKz0gNCkge1xuICAgIHZhciB3O1xuICAgIGlmIChlbmRpYW4gPT09ICdiaWcnKVxuICAgICAgdyA9IChtc2dba10gPDwgMjQpIHwgKG1zZ1trICsgMV0gPDwgMTYpIHwgKG1zZ1trICsgMl0gPDwgOCkgfCBtc2dbayArIDNdO1xuICAgIGVsc2VcbiAgICAgIHcgPSAobXNnW2sgKyAzXSA8PCAyNCkgfCAobXNnW2sgKyAyXSA8PCAxNikgfCAobXNnW2sgKyAxXSA8PCA4KSB8IG1zZ1trXTtcbiAgICByZXNbaV0gPSB3ID4+PiAwO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5leHBvcnRzLmpvaW4zMiA9IGpvaW4zMjtcblxuZnVuY3Rpb24gc3BsaXQzMihtc2csIGVuZGlhbikge1xuICB2YXIgcmVzID0gbmV3IEFycmF5KG1zZy5sZW5ndGggKiA0KTtcbiAgZm9yICh2YXIgaSA9IDAsIGsgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrLCBrICs9IDQpIHtcbiAgICB2YXIgbSA9IG1zZ1tpXTtcbiAgICBpZiAoZW5kaWFuID09PSAnYmlnJykge1xuICAgICAgcmVzW2tdID0gbSA+Pj4gMjQ7XG4gICAgICByZXNbayArIDFdID0gKG0gPj4+IDE2KSAmIDB4ZmY7XG4gICAgICByZXNbayArIDJdID0gKG0gPj4+IDgpICYgMHhmZjtcbiAgICAgIHJlc1trICsgM10gPSBtICYgMHhmZjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzW2sgKyAzXSA9IG0gPj4+IDI0O1xuICAgICAgcmVzW2sgKyAyXSA9IChtID4+PiAxNikgJiAweGZmO1xuICAgICAgcmVzW2sgKyAxXSA9IChtID4+PiA4KSAmIDB4ZmY7XG4gICAgICByZXNba10gPSBtICYgMHhmZjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbmV4cG9ydHMuc3BsaXQzMiA9IHNwbGl0MzI7XG5cbmZ1bmN0aW9uIHJvdHIzMih3LCBiKSB7XG4gIHJldHVybiAodyA+Pj4gYikgfCAodyA8PCAoMzIgLSBiKSk7XG59XG5leHBvcnRzLnJvdHIzMiA9IHJvdHIzMjtcblxuZnVuY3Rpb24gcm90bDMyKHcsIGIpIHtcbiAgcmV0dXJuICh3IDw8IGIpIHwgKHcgPj4+ICgzMiAtIGIpKTtcbn1cbmV4cG9ydHMucm90bDMyID0gcm90bDMyO1xuXG5mdW5jdGlvbiBzdW0zMihhLCBiKSB7XG4gIHJldHVybiAoYSArIGIpID4+PiAwO1xufVxuZXhwb3J0cy5zdW0zMiA9IHN1bTMyO1xuXG5mdW5jdGlvbiBzdW0zMl8zKGEsIGIsIGMpIHtcbiAgcmV0dXJuIChhICsgYiArIGMpID4+PiAwO1xufVxuZXhwb3J0cy5zdW0zMl8zID0gc3VtMzJfMztcblxuZnVuY3Rpb24gc3VtMzJfNChhLCBiLCBjLCBkKSB7XG4gIHJldHVybiAoYSArIGIgKyBjICsgZCkgPj4+IDA7XG59XG5leHBvcnRzLnN1bTMyXzQgPSBzdW0zMl80O1xuXG5mdW5jdGlvbiBzdW0zMl81KGEsIGIsIGMsIGQsIGUpIHtcbiAgcmV0dXJuIChhICsgYiArIGMgKyBkICsgZSkgPj4+IDA7XG59XG5leHBvcnRzLnN1bTMyXzUgPSBzdW0zMl81O1xuXG5mdW5jdGlvbiBzdW02NChidWYsIHBvcywgYWgsIGFsKSB7XG4gIHZhciBiaCA9IGJ1Zltwb3NdO1xuICB2YXIgYmwgPSBidWZbcG9zICsgMV07XG5cbiAgdmFyIGxvID0gKGFsICsgYmwpID4+PiAwO1xuICB2YXIgaGkgPSAobG8gPCBhbCA/IDEgOiAwKSArIGFoICsgYmg7XG4gIGJ1Zltwb3NdID0gaGkgPj4+IDA7XG4gIGJ1Zltwb3MgKyAxXSA9IGxvO1xufVxuZXhwb3J0cy5zdW02NCA9IHN1bTY0O1xuXG5mdW5jdGlvbiBzdW02NF9oaShhaCwgYWwsIGJoLCBibCkge1xuICB2YXIgbG8gPSAoYWwgKyBibCkgPj4+IDA7XG4gIHZhciBoaSA9IChsbyA8IGFsID8gMSA6IDApICsgYWggKyBiaDtcbiAgcmV0dXJuIGhpID4+PiAwO1xufVxuZXhwb3J0cy5zdW02NF9oaSA9IHN1bTY0X2hpO1xuXG5mdW5jdGlvbiBzdW02NF9sbyhhaCwgYWwsIGJoLCBibCkge1xuICB2YXIgbG8gPSBhbCArIGJsO1xuICByZXR1cm4gbG8gPj4+IDA7XG59XG5leHBvcnRzLnN1bTY0X2xvID0gc3VtNjRfbG87XG5cbmZ1bmN0aW9uIHN1bTY0XzRfaGkoYWgsIGFsLCBiaCwgYmwsIGNoLCBjbCwgZGgsIGRsKSB7XG4gIHZhciBjYXJyeSA9IDA7XG4gIHZhciBsbyA9IGFsO1xuICBsbyA9IChsbyArIGJsKSA+Pj4gMDtcbiAgY2FycnkgKz0gbG8gPCBhbCA/IDEgOiAwO1xuICBsbyA9IChsbyArIGNsKSA+Pj4gMDtcbiAgY2FycnkgKz0gbG8gPCBjbCA/IDEgOiAwO1xuICBsbyA9IChsbyArIGRsKSA+Pj4gMDtcbiAgY2FycnkgKz0gbG8gPCBkbCA/IDEgOiAwO1xuXG4gIHZhciBoaSA9IGFoICsgYmggKyBjaCArIGRoICsgY2Fycnk7XG4gIHJldHVybiBoaSA+Pj4gMDtcbn1cbmV4cG9ydHMuc3VtNjRfNF9oaSA9IHN1bTY0XzRfaGk7XG5cbmZ1bmN0aW9uIHN1bTY0XzRfbG8oYWgsIGFsLCBiaCwgYmwsIGNoLCBjbCwgZGgsIGRsKSB7XG4gIHZhciBsbyA9IGFsICsgYmwgKyBjbCArIGRsO1xuICByZXR1cm4gbG8gPj4+IDA7XG59XG5leHBvcnRzLnN1bTY0XzRfbG8gPSBzdW02NF80X2xvO1xuXG5mdW5jdGlvbiBzdW02NF81X2hpKGFoLCBhbCwgYmgsIGJsLCBjaCwgY2wsIGRoLCBkbCwgZWgsIGVsKSB7XG4gIHZhciBjYXJyeSA9IDA7XG4gIHZhciBsbyA9IGFsO1xuICBsbyA9IChsbyArIGJsKSA+Pj4gMDtcbiAgY2FycnkgKz0gbG8gPCBhbCA/IDEgOiAwO1xuICBsbyA9IChsbyArIGNsKSA+Pj4gMDtcbiAgY2FycnkgKz0gbG8gPCBjbCA/IDEgOiAwO1xuICBsbyA9IChsbyArIGRsKSA+Pj4gMDtcbiAgY2FycnkgKz0gbG8gPCBkbCA/IDEgOiAwO1xuICBsbyA9IChsbyArIGVsKSA+Pj4gMDtcbiAgY2FycnkgKz0gbG8gPCBlbCA/IDEgOiAwO1xuXG4gIHZhciBoaSA9IGFoICsgYmggKyBjaCArIGRoICsgZWggKyBjYXJyeTtcbiAgcmV0dXJuIGhpID4+PiAwO1xufVxuZXhwb3J0cy5zdW02NF81X2hpID0gc3VtNjRfNV9oaTtcblxuZnVuY3Rpb24gc3VtNjRfNV9sbyhhaCwgYWwsIGJoLCBibCwgY2gsIGNsLCBkaCwgZGwsIGVoLCBlbCkge1xuICB2YXIgbG8gPSBhbCArIGJsICsgY2wgKyBkbCArIGVsO1xuXG4gIHJldHVybiBsbyA+Pj4gMDtcbn1cbmV4cG9ydHMuc3VtNjRfNV9sbyA9IHN1bTY0XzVfbG87XG5cbmZ1bmN0aW9uIHJvdHI2NF9oaShhaCwgYWwsIG51bSkge1xuICB2YXIgciA9IChhbCA8PCAoMzIgLSBudW0pKSB8IChhaCA+Pj4gbnVtKTtcbiAgcmV0dXJuIHIgPj4+IDA7XG59XG5leHBvcnRzLnJvdHI2NF9oaSA9IHJvdHI2NF9oaTtcblxuZnVuY3Rpb24gcm90cjY0X2xvKGFoLCBhbCwgbnVtKSB7XG4gIHZhciByID0gKGFoIDw8ICgzMiAtIG51bSkpIHwgKGFsID4+PiBudW0pO1xuICByZXR1cm4gciA+Pj4gMDtcbn1cbmV4cG9ydHMucm90cjY0X2xvID0gcm90cjY0X2xvO1xuXG5mdW5jdGlvbiBzaHI2NF9oaShhaCwgYWwsIG51bSkge1xuICByZXR1cm4gYWggPj4+IG51bTtcbn1cbmV4cG9ydHMuc2hyNjRfaGkgPSBzaHI2NF9oaTtcblxuZnVuY3Rpb24gc2hyNjRfbG8oYWgsIGFsLCBudW0pIHtcbiAgdmFyIHIgPSAoYWggPDwgKDMyIC0gbnVtKSkgfCAoYWwgPj4+IG51bSk7XG4gIHJldHVybiByID4+PiAwO1xufVxuZXhwb3J0cy5zaHI2NF9sbyA9IHNocjY0X2xvO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzaCA9IHJlcXVpcmUoJ2hhc2guanMnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJ21pbmltYWxpc3RpYy1jcnlwdG8tdXRpbHMnKTtcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdtaW5pbWFsaXN0aWMtYXNzZXJ0Jyk7XG5cbmZ1bmN0aW9uIEhtYWNEUkJHKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEhtYWNEUkJHKSlcbiAgICByZXR1cm4gbmV3IEhtYWNEUkJHKG9wdGlvbnMpO1xuICB0aGlzLmhhc2ggPSBvcHRpb25zLmhhc2g7XG4gIHRoaXMucHJlZFJlc2lzdCA9ICEhb3B0aW9ucy5wcmVkUmVzaXN0O1xuXG4gIHRoaXMub3V0TGVuID0gdGhpcy5oYXNoLm91dFNpemU7XG4gIHRoaXMubWluRW50cm9weSA9IG9wdGlvbnMubWluRW50cm9weSB8fCB0aGlzLmhhc2guaG1hY1N0cmVuZ3RoO1xuXG4gIHRoaXMuX3Jlc2VlZCA9IG51bGw7XG4gIHRoaXMucmVzZWVkSW50ZXJ2YWwgPSBudWxsO1xuICB0aGlzLksgPSBudWxsO1xuICB0aGlzLlYgPSBudWxsO1xuXG4gIHZhciBlbnRyb3B5ID0gdXRpbHMudG9BcnJheShvcHRpb25zLmVudHJvcHksIG9wdGlvbnMuZW50cm9weUVuYyB8fCAnaGV4Jyk7XG4gIHZhciBub25jZSA9IHV0aWxzLnRvQXJyYXkob3B0aW9ucy5ub25jZSwgb3B0aW9ucy5ub25jZUVuYyB8fCAnaGV4Jyk7XG4gIHZhciBwZXJzID0gdXRpbHMudG9BcnJheShvcHRpb25zLnBlcnMsIG9wdGlvbnMucGVyc0VuYyB8fCAnaGV4Jyk7XG4gIGFzc2VydChlbnRyb3B5Lmxlbmd0aCA+PSAodGhpcy5taW5FbnRyb3B5IC8gOCksXG4gICAgICAgICAnTm90IGVub3VnaCBlbnRyb3B5LiBNaW5pbXVtIGlzOiAnICsgdGhpcy5taW5FbnRyb3B5ICsgJyBiaXRzJyk7XG4gIHRoaXMuX2luaXQoZW50cm9weSwgbm9uY2UsIHBlcnMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBIbWFjRFJCRztcblxuSG1hY0RSQkcucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gaW5pdChlbnRyb3B5LCBub25jZSwgcGVycykge1xuICB2YXIgc2VlZCA9IGVudHJvcHkuY29uY2F0KG5vbmNlKS5jb25jYXQocGVycyk7XG5cbiAgdGhpcy5LID0gbmV3IEFycmF5KHRoaXMub3V0TGVuIC8gOCk7XG4gIHRoaXMuViA9IG5ldyBBcnJheSh0aGlzLm91dExlbiAvIDgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuVi5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMuS1tpXSA9IDB4MDA7XG4gICAgdGhpcy5WW2ldID0gMHgwMTtcbiAgfVxuXG4gIHRoaXMuX3VwZGF0ZShzZWVkKTtcbiAgdGhpcy5fcmVzZWVkID0gMTtcbiAgdGhpcy5yZXNlZWRJbnRlcnZhbCA9IDB4MTAwMDAwMDAwMDAwMDsgIC8vIDJeNDhcbn07XG5cbkhtYWNEUkJHLnByb3RvdHlwZS5faG1hYyA9IGZ1bmN0aW9uIGhtYWMoKSB7XG4gIHJldHVybiBuZXcgaGFzaC5obWFjKHRoaXMuaGFzaCwgdGhpcy5LKTtcbn07XG5cbkhtYWNEUkJHLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKHNlZWQpIHtcbiAgdmFyIGttYWMgPSB0aGlzLl9obWFjKClcbiAgICAgICAgICAgICAgICAgLnVwZGF0ZSh0aGlzLlYpXG4gICAgICAgICAgICAgICAgIC51cGRhdGUoWyAweDAwIF0pO1xuICBpZiAoc2VlZClcbiAgICBrbWFjID0ga21hYy51cGRhdGUoc2VlZCk7XG4gIHRoaXMuSyA9IGttYWMuZGlnZXN0KCk7XG4gIHRoaXMuViA9IHRoaXMuX2htYWMoKS51cGRhdGUodGhpcy5WKS5kaWdlc3QoKTtcbiAgaWYgKCFzZWVkKVxuICAgIHJldHVybjtcblxuICB0aGlzLksgPSB0aGlzLl9obWFjKClcbiAgICAgICAgICAgICAgIC51cGRhdGUodGhpcy5WKVxuICAgICAgICAgICAgICAgLnVwZGF0ZShbIDB4MDEgXSlcbiAgICAgICAgICAgICAgIC51cGRhdGUoc2VlZClcbiAgICAgICAgICAgICAgIC5kaWdlc3QoKTtcbiAgdGhpcy5WID0gdGhpcy5faG1hYygpLnVwZGF0ZSh0aGlzLlYpLmRpZ2VzdCgpO1xufTtcblxuSG1hY0RSQkcucHJvdG90eXBlLnJlc2VlZCA9IGZ1bmN0aW9uIHJlc2VlZChlbnRyb3B5LCBlbnRyb3B5RW5jLCBhZGQsIGFkZEVuYykge1xuICAvLyBPcHRpb25hbCBlbnRyb3B5IGVuY1xuICBpZiAodHlwZW9mIGVudHJvcHlFbmMgIT09ICdzdHJpbmcnKSB7XG4gICAgYWRkRW5jID0gYWRkO1xuICAgIGFkZCA9IGVudHJvcHlFbmM7XG4gICAgZW50cm9weUVuYyA9IG51bGw7XG4gIH1cblxuICBlbnRyb3B5ID0gdXRpbHMudG9BcnJheShlbnRyb3B5LCBlbnRyb3B5RW5jKTtcbiAgYWRkID0gdXRpbHMudG9BcnJheShhZGQsIGFkZEVuYyk7XG5cbiAgYXNzZXJ0KGVudHJvcHkubGVuZ3RoID49ICh0aGlzLm1pbkVudHJvcHkgLyA4KSxcbiAgICAgICAgICdOb3QgZW5vdWdoIGVudHJvcHkuIE1pbmltdW0gaXM6ICcgKyB0aGlzLm1pbkVudHJvcHkgKyAnIGJpdHMnKTtcblxuICB0aGlzLl91cGRhdGUoZW50cm9weS5jb25jYXQoYWRkIHx8IFtdKSk7XG4gIHRoaXMuX3Jlc2VlZCA9IDE7XG59O1xuXG5IbWFjRFJCRy5wcm90b3R5cGUuZ2VuZXJhdGUgPSBmdW5jdGlvbiBnZW5lcmF0ZShsZW4sIGVuYywgYWRkLCBhZGRFbmMpIHtcbiAgaWYgKHRoaXMuX3Jlc2VlZCA+IHRoaXMucmVzZWVkSW50ZXJ2YWwpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZXNlZWQgaXMgcmVxdWlyZWQnKTtcblxuICAvLyBPcHRpb25hbCBlbmNvZGluZ1xuICBpZiAodHlwZW9mIGVuYyAhPT0gJ3N0cmluZycpIHtcbiAgICBhZGRFbmMgPSBhZGQ7XG4gICAgYWRkID0gZW5jO1xuICAgIGVuYyA9IG51bGw7XG4gIH1cblxuICAvLyBPcHRpb25hbCBhZGRpdGlvbmFsIGRhdGFcbiAgaWYgKGFkZCkge1xuICAgIGFkZCA9IHV0aWxzLnRvQXJyYXkoYWRkLCBhZGRFbmMgfHwgJ2hleCcpO1xuICAgIHRoaXMuX3VwZGF0ZShhZGQpO1xuICB9XG5cbiAgdmFyIHRlbXAgPSBbXTtcbiAgd2hpbGUgKHRlbXAubGVuZ3RoIDwgbGVuKSB7XG4gICAgdGhpcy5WID0gdGhpcy5faG1hYygpLnVwZGF0ZSh0aGlzLlYpLmRpZ2VzdCgpO1xuICAgIHRlbXAgPSB0ZW1wLmNvbmNhdCh0aGlzLlYpO1xuICB9XG5cbiAgdmFyIHJlcyA9IHRlbXAuc2xpY2UoMCwgbGVuKTtcbiAgdGhpcy5fdXBkYXRlKGFkZCk7XG4gIHRoaXMuX3Jlc2VlZCsrO1xuICByZXR1cm4gdXRpbHMuZW5jb2RlKHJlcywgZW5jKTtcbn07XG4iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBpZiAoc3VwZXJDdG9yKSB7XG4gICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gICAgfVxuICB9XG59XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIid1c2Ugc3RyaWN0J1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIEhhc2hCYXNlID0gcmVxdWlyZSgnaGFzaC1iYXNlJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG52YXIgQVJSQVkxNiA9IG5ldyBBcnJheSgxNilcblxuZnVuY3Rpb24gTUQ1ICgpIHtcbiAgSGFzaEJhc2UuY2FsbCh0aGlzLCA2NClcblxuICAvLyBzdGF0ZVxuICB0aGlzLl9hID0gMHg2NzQ1MjMwMVxuICB0aGlzLl9iID0gMHhlZmNkYWI4OVxuICB0aGlzLl9jID0gMHg5OGJhZGNmZVxuICB0aGlzLl9kID0gMHgxMDMyNTQ3NlxufVxuXG5pbmhlcml0cyhNRDUsIEhhc2hCYXNlKVxuXG5NRDUucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBNID0gQVJSQVkxNlxuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIE1baV0gPSB0aGlzLl9ibG9jay5yZWFkSW50MzJMRShpICogNClcblxuICB2YXIgYSA9IHRoaXMuX2FcbiAgdmFyIGIgPSB0aGlzLl9iXG4gIHZhciBjID0gdGhpcy5fY1xuICB2YXIgZCA9IHRoaXMuX2RcblxuICBhID0gZm5GKGEsIGIsIGMsIGQsIE1bMF0sIDB4ZDc2YWE0NzgsIDcpXG4gIGQgPSBmbkYoZCwgYSwgYiwgYywgTVsxXSwgMHhlOGM3Yjc1NiwgMTIpXG4gIGMgPSBmbkYoYywgZCwgYSwgYiwgTVsyXSwgMHgyNDIwNzBkYiwgMTcpXG4gIGIgPSBmbkYoYiwgYywgZCwgYSwgTVszXSwgMHhjMWJkY2VlZSwgMjIpXG4gIGEgPSBmbkYoYSwgYiwgYywgZCwgTVs0XSwgMHhmNTdjMGZhZiwgNylcbiAgZCA9IGZuRihkLCBhLCBiLCBjLCBNWzVdLCAweDQ3ODdjNjJhLCAxMilcbiAgYyA9IGZuRihjLCBkLCBhLCBiLCBNWzZdLCAweGE4MzA0NjEzLCAxNylcbiAgYiA9IGZuRihiLCBjLCBkLCBhLCBNWzddLCAweGZkNDY5NTAxLCAyMilcbiAgYSA9IGZuRihhLCBiLCBjLCBkLCBNWzhdLCAweDY5ODA5OGQ4LCA3KVxuICBkID0gZm5GKGQsIGEsIGIsIGMsIE1bOV0sIDB4OGI0NGY3YWYsIDEyKVxuICBjID0gZm5GKGMsIGQsIGEsIGIsIE1bMTBdLCAweGZmZmY1YmIxLCAxNylcbiAgYiA9IGZuRihiLCBjLCBkLCBhLCBNWzExXSwgMHg4OTVjZDdiZSwgMjIpXG4gIGEgPSBmbkYoYSwgYiwgYywgZCwgTVsxMl0sIDB4NmI5MDExMjIsIDcpXG4gIGQgPSBmbkYoZCwgYSwgYiwgYywgTVsxM10sIDB4ZmQ5ODcxOTMsIDEyKVxuICBjID0gZm5GKGMsIGQsIGEsIGIsIE1bMTRdLCAweGE2Nzk0MzhlLCAxNylcbiAgYiA9IGZuRihiLCBjLCBkLCBhLCBNWzE1XSwgMHg0OWI0MDgyMSwgMjIpXG5cbiAgYSA9IGZuRyhhLCBiLCBjLCBkLCBNWzFdLCAweGY2MWUyNTYyLCA1KVxuICBkID0gZm5HKGQsIGEsIGIsIGMsIE1bNl0sIDB4YzA0MGIzNDAsIDkpXG4gIGMgPSBmbkcoYywgZCwgYSwgYiwgTVsxMV0sIDB4MjY1ZTVhNTEsIDE0KVxuICBiID0gZm5HKGIsIGMsIGQsIGEsIE1bMF0sIDB4ZTliNmM3YWEsIDIwKVxuICBhID0gZm5HKGEsIGIsIGMsIGQsIE1bNV0sIDB4ZDYyZjEwNWQsIDUpXG4gIGQgPSBmbkcoZCwgYSwgYiwgYywgTVsxMF0sIDB4MDI0NDE0NTMsIDkpXG4gIGMgPSBmbkcoYywgZCwgYSwgYiwgTVsxNV0sIDB4ZDhhMWU2ODEsIDE0KVxuICBiID0gZm5HKGIsIGMsIGQsIGEsIE1bNF0sIDB4ZTdkM2ZiYzgsIDIwKVxuICBhID0gZm5HKGEsIGIsIGMsIGQsIE1bOV0sIDB4MjFlMWNkZTYsIDUpXG4gIGQgPSBmbkcoZCwgYSwgYiwgYywgTVsxNF0sIDB4YzMzNzA3ZDYsIDkpXG4gIGMgPSBmbkcoYywgZCwgYSwgYiwgTVszXSwgMHhmNGQ1MGQ4NywgMTQpXG4gIGIgPSBmbkcoYiwgYywgZCwgYSwgTVs4XSwgMHg0NTVhMTRlZCwgMjApXG4gIGEgPSBmbkcoYSwgYiwgYywgZCwgTVsxM10sIDB4YTllM2U5MDUsIDUpXG4gIGQgPSBmbkcoZCwgYSwgYiwgYywgTVsyXSwgMHhmY2VmYTNmOCwgOSlcbiAgYyA9IGZuRyhjLCBkLCBhLCBiLCBNWzddLCAweDY3NmYwMmQ5LCAxNClcbiAgYiA9IGZuRyhiLCBjLCBkLCBhLCBNWzEyXSwgMHg4ZDJhNGM4YSwgMjApXG5cbiAgYSA9IGZuSChhLCBiLCBjLCBkLCBNWzVdLCAweGZmZmEzOTQyLCA0KVxuICBkID0gZm5IKGQsIGEsIGIsIGMsIE1bOF0sIDB4ODc3MWY2ODEsIDExKVxuICBjID0gZm5IKGMsIGQsIGEsIGIsIE1bMTFdLCAweDZkOWQ2MTIyLCAxNilcbiAgYiA9IGZuSChiLCBjLCBkLCBhLCBNWzE0XSwgMHhmZGU1MzgwYywgMjMpXG4gIGEgPSBmbkgoYSwgYiwgYywgZCwgTVsxXSwgMHhhNGJlZWE0NCwgNClcbiAgZCA9IGZuSChkLCBhLCBiLCBjLCBNWzRdLCAweDRiZGVjZmE5LCAxMSlcbiAgYyA9IGZuSChjLCBkLCBhLCBiLCBNWzddLCAweGY2YmI0YjYwLCAxNilcbiAgYiA9IGZuSChiLCBjLCBkLCBhLCBNWzEwXSwgMHhiZWJmYmM3MCwgMjMpXG4gIGEgPSBmbkgoYSwgYiwgYywgZCwgTVsxM10sIDB4Mjg5YjdlYzYsIDQpXG4gIGQgPSBmbkgoZCwgYSwgYiwgYywgTVswXSwgMHhlYWExMjdmYSwgMTEpXG4gIGMgPSBmbkgoYywgZCwgYSwgYiwgTVszXSwgMHhkNGVmMzA4NSwgMTYpXG4gIGIgPSBmbkgoYiwgYywgZCwgYSwgTVs2XSwgMHgwNDg4MWQwNSwgMjMpXG4gIGEgPSBmbkgoYSwgYiwgYywgZCwgTVs5XSwgMHhkOWQ0ZDAzOSwgNClcbiAgZCA9IGZuSChkLCBhLCBiLCBjLCBNWzEyXSwgMHhlNmRiOTllNSwgMTEpXG4gIGMgPSBmbkgoYywgZCwgYSwgYiwgTVsxNV0sIDB4MWZhMjdjZjgsIDE2KVxuICBiID0gZm5IKGIsIGMsIGQsIGEsIE1bMl0sIDB4YzRhYzU2NjUsIDIzKVxuXG4gIGEgPSBmbkkoYSwgYiwgYywgZCwgTVswXSwgMHhmNDI5MjI0NCwgNilcbiAgZCA9IGZuSShkLCBhLCBiLCBjLCBNWzddLCAweDQzMmFmZjk3LCAxMClcbiAgYyA9IGZuSShjLCBkLCBhLCBiLCBNWzE0XSwgMHhhYjk0MjNhNywgMTUpXG4gIGIgPSBmbkkoYiwgYywgZCwgYSwgTVs1XSwgMHhmYzkzYTAzOSwgMjEpXG4gIGEgPSBmbkkoYSwgYiwgYywgZCwgTVsxMl0sIDB4NjU1YjU5YzMsIDYpXG4gIGQgPSBmbkkoZCwgYSwgYiwgYywgTVszXSwgMHg4ZjBjY2M5MiwgMTApXG4gIGMgPSBmbkkoYywgZCwgYSwgYiwgTVsxMF0sIDB4ZmZlZmY0N2QsIDE1KVxuICBiID0gZm5JKGIsIGMsIGQsIGEsIE1bMV0sIDB4ODU4NDVkZDEsIDIxKVxuICBhID0gZm5JKGEsIGIsIGMsIGQsIE1bOF0sIDB4NmZhODdlNGYsIDYpXG4gIGQgPSBmbkkoZCwgYSwgYiwgYywgTVsxNV0sIDB4ZmUyY2U2ZTAsIDEwKVxuICBjID0gZm5JKGMsIGQsIGEsIGIsIE1bNl0sIDB4YTMwMTQzMTQsIDE1KVxuICBiID0gZm5JKGIsIGMsIGQsIGEsIE1bMTNdLCAweDRlMDgxMWExLCAyMSlcbiAgYSA9IGZuSShhLCBiLCBjLCBkLCBNWzRdLCAweGY3NTM3ZTgyLCA2KVxuICBkID0gZm5JKGQsIGEsIGIsIGMsIE1bMTFdLCAweGJkM2FmMjM1LCAxMClcbiAgYyA9IGZuSShjLCBkLCBhLCBiLCBNWzJdLCAweDJhZDdkMmJiLCAxNSlcbiAgYiA9IGZuSShiLCBjLCBkLCBhLCBNWzldLCAweGViODZkMzkxLCAyMSlcblxuICB0aGlzLl9hID0gKHRoaXMuX2EgKyBhKSB8IDBcbiAgdGhpcy5fYiA9ICh0aGlzLl9iICsgYikgfCAwXG4gIHRoaXMuX2MgPSAodGhpcy5fYyArIGMpIHwgMFxuICB0aGlzLl9kID0gKHRoaXMuX2QgKyBkKSB8IDBcbn1cblxuTUQ1LnByb3RvdHlwZS5fZGlnZXN0ID0gZnVuY3Rpb24gKCkge1xuICAvLyBjcmVhdGUgcGFkZGluZyBhbmQgaGFuZGxlIGJsb2Nrc1xuICB0aGlzLl9ibG9ja1t0aGlzLl9ibG9ja09mZnNldCsrXSA9IDB4ODBcbiAgaWYgKHRoaXMuX2Jsb2NrT2Zmc2V0ID4gNTYpIHtcbiAgICB0aGlzLl9ibG9jay5maWxsKDAsIHRoaXMuX2Jsb2NrT2Zmc2V0LCA2NClcbiAgICB0aGlzLl91cGRhdGUoKVxuICAgIHRoaXMuX2Jsb2NrT2Zmc2V0ID0gMFxuICB9XG5cbiAgdGhpcy5fYmxvY2suZmlsbCgwLCB0aGlzLl9ibG9ja09mZnNldCwgNTYpXG4gIHRoaXMuX2Jsb2NrLndyaXRlVUludDMyTEUodGhpcy5fbGVuZ3RoWzBdLCA1NilcbiAgdGhpcy5fYmxvY2sud3JpdGVVSW50MzJMRSh0aGlzLl9sZW5ndGhbMV0sIDYwKVxuICB0aGlzLl91cGRhdGUoKVxuXG4gIC8vIHByb2R1Y2UgcmVzdWx0XG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMTYpXG4gIGJ1ZmZlci53cml0ZUludDMyTEUodGhpcy5fYSwgMClcbiAgYnVmZmVyLndyaXRlSW50MzJMRSh0aGlzLl9iLCA0KVxuICBidWZmZXIud3JpdGVJbnQzMkxFKHRoaXMuX2MsIDgpXG4gIGJ1ZmZlci53cml0ZUludDMyTEUodGhpcy5fZCwgMTIpXG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gcm90bCAoeCwgbikge1xuICByZXR1cm4gKHggPDwgbikgfCAoeCA+Pj4gKDMyIC0gbikpXG59XG5cbmZ1bmN0aW9uIGZuRiAoYSwgYiwgYywgZCwgbSwgaywgcykge1xuICByZXR1cm4gKHJvdGwoKGEgKyAoKGIgJiBjKSB8ICgofmIpICYgZCkpICsgbSArIGspIHwgMCwgcykgKyBiKSB8IDBcbn1cblxuZnVuY3Rpb24gZm5HIChhLCBiLCBjLCBkLCBtLCBrLCBzKSB7XG4gIHJldHVybiAocm90bCgoYSArICgoYiAmIGQpIHwgKGMgJiAofmQpKSkgKyBtICsgaykgfCAwLCBzKSArIGIpIHwgMFxufVxuXG5mdW5jdGlvbiBmbkggKGEsIGIsIGMsIGQsIG0sIGssIHMpIHtcbiAgcmV0dXJuIChyb3RsKChhICsgKGIgXiBjIF4gZCkgKyBtICsgaykgfCAwLCBzKSArIGIpIHwgMFxufVxuXG5mdW5jdGlvbiBmbkkgKGEsIGIsIGMsIGQsIG0sIGssIHMpIHtcbiAgcmV0dXJuIChyb3RsKChhICsgKChjIF4gKGIgfCAofmQpKSkpICsgbSArIGspIHwgMCwgcykgKyBiKSB8IDBcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBNRDVcbiIsInZhciBibiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG52YXIgYnJvcmFuZCA9IHJlcXVpcmUoJ2Jyb3JhbmQnKTtcblxuZnVuY3Rpb24gTWlsbGVyUmFiaW4ocmFuZCkge1xuICB0aGlzLnJhbmQgPSByYW5kIHx8IG5ldyBicm9yYW5kLlJhbmQoKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gTWlsbGVyUmFiaW47XG5cbk1pbGxlclJhYmluLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShyYW5kKSB7XG4gIHJldHVybiBuZXcgTWlsbGVyUmFiaW4ocmFuZCk7XG59O1xuXG5NaWxsZXJSYWJpbi5wcm90b3R5cGUuX3JhbmRiZWxvdyA9IGZ1bmN0aW9uIF9yYW5kYmVsb3cobikge1xuICB2YXIgbGVuID0gbi5iaXRMZW5ndGgoKTtcbiAgdmFyIG1pbl9ieXRlcyA9IE1hdGguY2VpbChsZW4gLyA4KTtcblxuICAvLyBHZW5lcmFnZSByYW5kb20gYnl0ZXMgdW50aWwgYSBudW1iZXIgbGVzcyB0aGFuIG4gaXMgZm91bmQuXG4gIC8vIFRoaXMgZW5zdXJlcyB0aGF0IDAuLm4tMSBoYXZlIGFuIGVxdWFsIHByb2JhYmlsaXR5IG9mIGJlaW5nIHNlbGVjdGVkLlxuICBkb1xuICAgIHZhciBhID0gbmV3IGJuKHRoaXMucmFuZC5nZW5lcmF0ZShtaW5fYnl0ZXMpKTtcbiAgd2hpbGUgKGEuY21wKG4pID49IDApO1xuXG4gIHJldHVybiBhO1xufTtcblxuTWlsbGVyUmFiaW4ucHJvdG90eXBlLl9yYW5kcmFuZ2UgPSBmdW5jdGlvbiBfcmFuZHJhbmdlKHN0YXJ0LCBzdG9wKSB7XG4gIC8vIEdlbmVyYXRlIGEgcmFuZG9tIG51bWJlciBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gc3RhcnQgYW5kIGxlc3MgdGhhbiBzdG9wLlxuICB2YXIgc2l6ZSA9IHN0b3Auc3ViKHN0YXJ0KTtcbiAgcmV0dXJuIHN0YXJ0LmFkZCh0aGlzLl9yYW5kYmVsb3coc2l6ZSkpO1xufTtcblxuTWlsbGVyUmFiaW4ucHJvdG90eXBlLnRlc3QgPSBmdW5jdGlvbiB0ZXN0KG4sIGssIGNiKSB7XG4gIHZhciBsZW4gPSBuLmJpdExlbmd0aCgpO1xuICB2YXIgcmVkID0gYm4ubW9udChuKTtcbiAgdmFyIHJvbmUgPSBuZXcgYm4oMSkudG9SZWQocmVkKTtcblxuICBpZiAoIWspXG4gICAgayA9IE1hdGgubWF4KDEsIChsZW4gLyA0OCkgfCAwKTtcblxuICAvLyBGaW5kIGQgYW5kIHMsIChuIC0gMSkgPSAoMiBeIHMpICogZDtcbiAgdmFyIG4xID0gbi5zdWJuKDEpO1xuICBmb3IgKHZhciBzID0gMDsgIW4xLnRlc3RuKHMpOyBzKyspIHt9XG4gIHZhciBkID0gbi5zaHJuKHMpO1xuXG4gIHZhciBybjEgPSBuMS50b1JlZChyZWQpO1xuXG4gIHZhciBwcmltZSA9IHRydWU7XG4gIGZvciAoOyBrID4gMDsgay0tKSB7XG4gICAgdmFyIGEgPSB0aGlzLl9yYW5kcmFuZ2UobmV3IGJuKDIpLCBuMSk7XG4gICAgaWYgKGNiKVxuICAgICAgY2IoYSk7XG5cbiAgICB2YXIgeCA9IGEudG9SZWQocmVkKS5yZWRQb3coZCk7XG4gICAgaWYgKHguY21wKHJvbmUpID09PSAwIHx8IHguY21wKHJuMSkgPT09IDApXG4gICAgICBjb250aW51ZTtcblxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgczsgaSsrKSB7XG4gICAgICB4ID0geC5yZWRTcXIoKTtcblxuICAgICAgaWYgKHguY21wKHJvbmUpID09PSAwKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAoeC5jbXAocm4xKSA9PT0gMClcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKGkgPT09IHMpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gcHJpbWU7XG59O1xuXG5NaWxsZXJSYWJpbi5wcm90b3R5cGUuZ2V0RGl2aXNvciA9IGZ1bmN0aW9uIGdldERpdmlzb3Iobiwgaykge1xuICB2YXIgbGVuID0gbi5iaXRMZW5ndGgoKTtcbiAgdmFyIHJlZCA9IGJuLm1vbnQobik7XG4gIHZhciByb25lID0gbmV3IGJuKDEpLnRvUmVkKHJlZCk7XG5cbiAgaWYgKCFrKVxuICAgIGsgPSBNYXRoLm1heCgxLCAobGVuIC8gNDgpIHwgMCk7XG5cbiAgLy8gRmluZCBkIGFuZCBzLCAobiAtIDEpID0gKDIgXiBzKSAqIGQ7XG4gIHZhciBuMSA9IG4uc3VibigxKTtcbiAgZm9yICh2YXIgcyA9IDA7ICFuMS50ZXN0bihzKTsgcysrKSB7fVxuICB2YXIgZCA9IG4uc2hybihzKTtcblxuICB2YXIgcm4xID0gbjEudG9SZWQocmVkKTtcblxuICBmb3IgKDsgayA+IDA7IGstLSkge1xuICAgIHZhciBhID0gdGhpcy5fcmFuZHJhbmdlKG5ldyBibigyKSwgbjEpO1xuXG4gICAgdmFyIGcgPSBuLmdjZChhKTtcbiAgICBpZiAoZy5jbXBuKDEpICE9PSAwKVxuICAgICAgcmV0dXJuIGc7XG5cbiAgICB2YXIgeCA9IGEudG9SZWQocmVkKS5yZWRQb3coZCk7XG4gICAgaWYgKHguY21wKHJvbmUpID09PSAwIHx8IHguY21wKHJuMSkgPT09IDApXG4gICAgICBjb250aW51ZTtcblxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgczsgaSsrKSB7XG4gICAgICB4ID0geC5yZWRTcXIoKTtcblxuICAgICAgaWYgKHguY21wKHJvbmUpID09PSAwKVxuICAgICAgICByZXR1cm4geC5mcm9tUmVkKCkuc3VibigxKS5nY2Qobik7XG4gICAgICBpZiAoeC5jbXAocm4xKSA9PT0gMClcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKGkgPT09IHMpIHtcbiAgICAgIHggPSB4LnJlZFNxcigpO1xuICAgICAgcmV0dXJuIHguZnJvbVJlZCgpLnN1Ym4oMSkuZ2NkKG4pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGFzc2VydDtcblxuZnVuY3Rpb24gYXNzZXJ0KHZhbCwgbXNnKSB7XG4gIGlmICghdmFsKVxuICAgIHRocm93IG5ldyBFcnJvcihtc2cgfHwgJ0Fzc2VydGlvbiBmYWlsZWQnKTtcbn1cblxuYXNzZXJ0LmVxdWFsID0gZnVuY3Rpb24gYXNzZXJ0RXF1YWwobCwgciwgbXNnKSB7XG4gIGlmIChsICE9IHIpXG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZyB8fCAoJ0Fzc2VydGlvbiBmYWlsZWQ6ICcgKyBsICsgJyAhPSAnICsgcikpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gZXhwb3J0cztcblxuZnVuY3Rpb24gdG9BcnJheShtc2csIGVuYykge1xuICBpZiAoQXJyYXkuaXNBcnJheShtc2cpKVxuICAgIHJldHVybiBtc2cuc2xpY2UoKTtcbiAgaWYgKCFtc2cpXG4gICAgcmV0dXJuIFtdO1xuICB2YXIgcmVzID0gW107XG4gIGlmICh0eXBlb2YgbXNnICE9PSAnc3RyaW5nJykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKVxuICAgICAgcmVzW2ldID0gbXNnW2ldIHwgMDtcbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIGlmIChlbmMgPT09ICdoZXgnKSB7XG4gICAgbXNnID0gbXNnLnJlcGxhY2UoL1teYS16MC05XSsvaWcsICcnKTtcbiAgICBpZiAobXNnLmxlbmd0aCAlIDIgIT09IDApXG4gICAgICBtc2cgPSAnMCcgKyBtc2c7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpICs9IDIpXG4gICAgICByZXMucHVzaChwYXJzZUludChtc2dbaV0gKyBtc2dbaSArIDFdLCAxNikpO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IG1zZy5jaGFyQ29kZUF0KGkpO1xuICAgICAgdmFyIGhpID0gYyA+PiA4O1xuICAgICAgdmFyIGxvID0gYyAmIDB4ZmY7XG4gICAgICBpZiAoaGkpXG4gICAgICAgIHJlcy5wdXNoKGhpLCBsbyk7XG4gICAgICBlbHNlXG4gICAgICAgIHJlcy5wdXNoKGxvKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbnV0aWxzLnRvQXJyYXkgPSB0b0FycmF5O1xuXG5mdW5jdGlvbiB6ZXJvMih3b3JkKSB7XG4gIGlmICh3b3JkLmxlbmd0aCA9PT0gMSlcbiAgICByZXR1cm4gJzAnICsgd29yZDtcbiAgZWxzZVxuICAgIHJldHVybiB3b3JkO1xufVxudXRpbHMuemVybzIgPSB6ZXJvMjtcblxuZnVuY3Rpb24gdG9IZXgobXNnKSB7XG4gIHZhciByZXMgPSAnJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspXG4gICAgcmVzICs9IHplcm8yKG1zZ1tpXS50b1N0cmluZygxNikpO1xuICByZXR1cm4gcmVzO1xufVxudXRpbHMudG9IZXggPSB0b0hleDtcblxudXRpbHMuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKGFyciwgZW5jKSB7XG4gIGlmIChlbmMgPT09ICdoZXgnKVxuICAgIHJldHVybiB0b0hleChhcnIpO1xuICBlbHNlXG4gICAgcmV0dXJuIGFycjtcbn07XG4iLCIvLyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L3NlbGYtc2lnbmVkL2Jsb2IvZ2gtcGFnZXMvbGliL2FzbjEuanNcbi8vIEZlZG9yLCB5b3UgYXJlIGFtYXppbmcuXG4ndXNlIHN0cmljdCdcblxudmFyIGFzbjEgPSByZXF1aXJlKCdhc24xLmpzJylcblxuZXhwb3J0cy5jZXJ0aWZpY2F0ZSA9IHJlcXVpcmUoJy4vY2VydGlmaWNhdGUnKVxuXG52YXIgUlNBUHJpdmF0ZUtleSA9IGFzbjEuZGVmaW5lKCdSU0FQcml2YXRlS2V5JywgZnVuY3Rpb24gKCkge1xuICB0aGlzLnNlcSgpLm9iaihcbiAgICB0aGlzLmtleSgndmVyc2lvbicpLmludCgpLFxuICAgIHRoaXMua2V5KCdtb2R1bHVzJykuaW50KCksXG4gICAgdGhpcy5rZXkoJ3B1YmxpY0V4cG9uZW50JykuaW50KCksXG4gICAgdGhpcy5rZXkoJ3ByaXZhdGVFeHBvbmVudCcpLmludCgpLFxuICAgIHRoaXMua2V5KCdwcmltZTEnKS5pbnQoKSxcbiAgICB0aGlzLmtleSgncHJpbWUyJykuaW50KCksXG4gICAgdGhpcy5rZXkoJ2V4cG9uZW50MScpLmludCgpLFxuICAgIHRoaXMua2V5KCdleHBvbmVudDInKS5pbnQoKSxcbiAgICB0aGlzLmtleSgnY29lZmZpY2llbnQnKS5pbnQoKVxuICApXG59KVxuZXhwb3J0cy5SU0FQcml2YXRlS2V5ID0gUlNBUHJpdmF0ZUtleVxuXG52YXIgUlNBUHVibGljS2V5ID0gYXNuMS5kZWZpbmUoJ1JTQVB1YmxpY0tleScsIGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZXEoKS5vYmooXG4gICAgdGhpcy5rZXkoJ21vZHVsdXMnKS5pbnQoKSxcbiAgICB0aGlzLmtleSgncHVibGljRXhwb25lbnQnKS5pbnQoKVxuICApXG59KVxuZXhwb3J0cy5SU0FQdWJsaWNLZXkgPSBSU0FQdWJsaWNLZXlcblxudmFyIFB1YmxpY0tleSA9IGFzbjEuZGVmaW5lKCdTdWJqZWN0UHVibGljS2V5SW5mbycsIGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZXEoKS5vYmooXG4gICAgdGhpcy5rZXkoJ2FsZ29yaXRobScpLnVzZShBbGdvcml0aG1JZGVudGlmaWVyKSxcbiAgICB0aGlzLmtleSgnc3ViamVjdFB1YmxpY0tleScpLmJpdHN0cigpXG4gIClcbn0pXG5leHBvcnRzLlB1YmxpY0tleSA9IFB1YmxpY0tleVxuXG52YXIgQWxnb3JpdGhtSWRlbnRpZmllciA9IGFzbjEuZGVmaW5lKCdBbGdvcml0aG1JZGVudGlmaWVyJywgZnVuY3Rpb24gKCkge1xuICB0aGlzLnNlcSgpLm9iaihcbiAgICB0aGlzLmtleSgnYWxnb3JpdGhtJykub2JqaWQoKSxcbiAgICB0aGlzLmtleSgnbm9uZScpLm51bGxfKCkub3B0aW9uYWwoKSxcbiAgICB0aGlzLmtleSgnY3VydmUnKS5vYmppZCgpLm9wdGlvbmFsKCksXG4gICAgdGhpcy5rZXkoJ3BhcmFtcycpLnNlcSgpLm9iaihcbiAgICAgIHRoaXMua2V5KCdwJykuaW50KCksXG4gICAgICB0aGlzLmtleSgncScpLmludCgpLFxuICAgICAgdGhpcy5rZXkoJ2cnKS5pbnQoKVxuICAgICkub3B0aW9uYWwoKVxuICApXG59KVxuXG52YXIgUHJpdmF0ZUtleUluZm8gPSBhc24xLmRlZmluZSgnUHJpdmF0ZUtleUluZm8nLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VxKCkub2JqKFxuICAgIHRoaXMua2V5KCd2ZXJzaW9uJykuaW50KCksXG4gICAgdGhpcy5rZXkoJ2FsZ29yaXRobScpLnVzZShBbGdvcml0aG1JZGVudGlmaWVyKSxcbiAgICB0aGlzLmtleSgnc3ViamVjdFByaXZhdGVLZXknKS5vY3RzdHIoKVxuICApXG59KVxuZXhwb3J0cy5Qcml2YXRlS2V5ID0gUHJpdmF0ZUtleUluZm9cbnZhciBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mbyA9IGFzbjEuZGVmaW5lKCdFbmNyeXB0ZWRQcml2YXRlS2V5SW5mbycsIGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZXEoKS5vYmooXG4gICAgdGhpcy5rZXkoJ2FsZ29yaXRobScpLnNlcSgpLm9iaihcbiAgICAgIHRoaXMua2V5KCdpZCcpLm9iamlkKCksXG4gICAgICB0aGlzLmtleSgnZGVjcnlwdCcpLnNlcSgpLm9iaihcbiAgICAgICAgdGhpcy5rZXkoJ2tkZScpLnNlcSgpLm9iaihcbiAgICAgICAgICB0aGlzLmtleSgnaWQnKS5vYmppZCgpLFxuICAgICAgICAgIHRoaXMua2V5KCdrZGVwYXJhbXMnKS5zZXEoKS5vYmooXG4gICAgICAgICAgICB0aGlzLmtleSgnc2FsdCcpLm9jdHN0cigpLFxuICAgICAgICAgICAgdGhpcy5rZXkoJ2l0ZXJzJykuaW50KClcbiAgICAgICAgICApXG4gICAgICAgICksXG4gICAgICAgIHRoaXMua2V5KCdjaXBoZXInKS5zZXEoKS5vYmooXG4gICAgICAgICAgdGhpcy5rZXkoJ2FsZ28nKS5vYmppZCgpLFxuICAgICAgICAgIHRoaXMua2V5KCdpdicpLm9jdHN0cigpXG4gICAgICAgIClcbiAgICAgIClcbiAgICApLFxuICAgIHRoaXMua2V5KCdzdWJqZWN0UHJpdmF0ZUtleScpLm9jdHN0cigpXG4gIClcbn0pXG5cbmV4cG9ydHMuRW5jcnlwdGVkUHJpdmF0ZUtleSA9IEVuY3J5cHRlZFByaXZhdGVLZXlJbmZvXG5cbnZhciBEU0FQcml2YXRlS2V5ID0gYXNuMS5kZWZpbmUoJ0RTQVByaXZhdGVLZXknLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VxKCkub2JqKFxuICAgIHRoaXMua2V5KCd2ZXJzaW9uJykuaW50KCksXG4gICAgdGhpcy5rZXkoJ3AnKS5pbnQoKSxcbiAgICB0aGlzLmtleSgncScpLmludCgpLFxuICAgIHRoaXMua2V5KCdnJykuaW50KCksXG4gICAgdGhpcy5rZXkoJ3B1Yl9rZXknKS5pbnQoKSxcbiAgICB0aGlzLmtleSgncHJpdl9rZXknKS5pbnQoKVxuICApXG59KVxuZXhwb3J0cy5EU0FQcml2YXRlS2V5ID0gRFNBUHJpdmF0ZUtleVxuXG5leHBvcnRzLkRTQXBhcmFtID0gYXNuMS5kZWZpbmUoJ0RTQXBhcmFtJywgZnVuY3Rpb24gKCkge1xuICB0aGlzLmludCgpXG59KVxuXG52YXIgRUNQcml2YXRlS2V5ID0gYXNuMS5kZWZpbmUoJ0VDUHJpdmF0ZUtleScsIGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZXEoKS5vYmooXG4gICAgdGhpcy5rZXkoJ3ZlcnNpb24nKS5pbnQoKSxcbiAgICB0aGlzLmtleSgncHJpdmF0ZUtleScpLm9jdHN0cigpLFxuICAgIHRoaXMua2V5KCdwYXJhbWV0ZXJzJykub3B0aW9uYWwoKS5leHBsaWNpdCgwKS51c2UoRUNQYXJhbWV0ZXJzKSxcbiAgICB0aGlzLmtleSgncHVibGljS2V5Jykub3B0aW9uYWwoKS5leHBsaWNpdCgxKS5iaXRzdHIoKVxuICApXG59KVxuZXhwb3J0cy5FQ1ByaXZhdGVLZXkgPSBFQ1ByaXZhdGVLZXlcblxudmFyIEVDUGFyYW1ldGVycyA9IGFzbjEuZGVmaW5lKCdFQ1BhcmFtZXRlcnMnLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuY2hvaWNlKHtcbiAgICBuYW1lZEN1cnZlOiB0aGlzLm9iamlkKClcbiAgfSlcbn0pXG5cbmV4cG9ydHMuc2lnbmF0dXJlID0gYXNuMS5kZWZpbmUoJ3NpZ25hdHVyZScsIGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZXEoKS5vYmooXG4gICAgdGhpcy5rZXkoJ3InKS5pbnQoKSxcbiAgICB0aGlzLmtleSgncycpLmludCgpXG4gIClcbn0pXG4iLCIvLyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9SYW50YW5lbi9ub2RlLWR0bHMvYmxvYi8yNWE3ZGM4NjFiZGEzOGNmZWFjOTNhNzIzNTAwZWVhNGYwYWMyZTg2L0NlcnRpZmljYXRlLmpzXG4vLyB0aGFua3MgdG8gQFJhbnRhbmVuXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYXNuID0gcmVxdWlyZSgnYXNuMS5qcycpXG5cbnZhciBUaW1lID0gYXNuLmRlZmluZSgnVGltZScsIGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5jaG9pY2Uoe1xuICAgIHV0Y1RpbWU6IHRoaXMudXRjdGltZSgpLFxuICAgIGdlbmVyYWxUaW1lOiB0aGlzLmdlbnRpbWUoKVxuICB9KVxufSlcblxudmFyIEF0dHJpYnV0ZVR5cGVWYWx1ZSA9IGFzbi5kZWZpbmUoJ0F0dHJpYnV0ZVR5cGVWYWx1ZScsIGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZXEoKS5vYmooXG4gICAgdGhpcy5rZXkoJ3R5cGUnKS5vYmppZCgpLFxuICAgIHRoaXMua2V5KCd2YWx1ZScpLmFueSgpXG4gIClcbn0pXG5cbnZhciBBbGdvcml0aG1JZGVudGlmaWVyID0gYXNuLmRlZmluZSgnQWxnb3JpdGhtSWRlbnRpZmllcicsIGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZXEoKS5vYmooXG4gICAgdGhpcy5rZXkoJ2FsZ29yaXRobScpLm9iamlkKCksXG4gICAgdGhpcy5rZXkoJ3BhcmFtZXRlcnMnKS5vcHRpb25hbCgpLFxuICAgIHRoaXMua2V5KCdjdXJ2ZScpLm9iamlkKCkub3B0aW9uYWwoKVxuICApXG59KVxuXG52YXIgU3ViamVjdFB1YmxpY0tleUluZm8gPSBhc24uZGVmaW5lKCdTdWJqZWN0UHVibGljS2V5SW5mbycsIGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZXEoKS5vYmooXG4gICAgdGhpcy5rZXkoJ2FsZ29yaXRobScpLnVzZShBbGdvcml0aG1JZGVudGlmaWVyKSxcbiAgICB0aGlzLmtleSgnc3ViamVjdFB1YmxpY0tleScpLmJpdHN0cigpXG4gIClcbn0pXG5cbnZhciBSZWxhdGl2ZURpc3Rpbmd1aXNoZWROYW1lID0gYXNuLmRlZmluZSgnUmVsYXRpdmVEaXN0aW5ndWlzaGVkTmFtZScsIGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZXRvZihBdHRyaWJ1dGVUeXBlVmFsdWUpXG59KVxuXG52YXIgUkROU2VxdWVuY2UgPSBhc24uZGVmaW5lKCdSRE5TZXF1ZW5jZScsIGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZXFvZihSZWxhdGl2ZURpc3Rpbmd1aXNoZWROYW1lKVxufSlcblxudmFyIE5hbWUgPSBhc24uZGVmaW5lKCdOYW1lJywgZnVuY3Rpb24gKCkge1xuICB0aGlzLmNob2ljZSh7XG4gICAgcmRuU2VxdWVuY2U6IHRoaXMudXNlKFJETlNlcXVlbmNlKVxuICB9KVxufSlcblxudmFyIFZhbGlkaXR5ID0gYXNuLmRlZmluZSgnVmFsaWRpdHknLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VxKCkub2JqKFxuICAgIHRoaXMua2V5KCdub3RCZWZvcmUnKS51c2UoVGltZSksXG4gICAgdGhpcy5rZXkoJ25vdEFmdGVyJykudXNlKFRpbWUpXG4gIClcbn0pXG5cbnZhciBFeHRlbnNpb24gPSBhc24uZGVmaW5lKCdFeHRlbnNpb24nLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VxKCkub2JqKFxuICAgIHRoaXMua2V5KCdleHRuSUQnKS5vYmppZCgpLFxuICAgIHRoaXMua2V5KCdjcml0aWNhbCcpLmJvb2woKS5kZWYoZmFsc2UpLFxuICAgIHRoaXMua2V5KCdleHRuVmFsdWUnKS5vY3RzdHIoKVxuICApXG59KVxuXG52YXIgVEJTQ2VydGlmaWNhdGUgPSBhc24uZGVmaW5lKCdUQlNDZXJ0aWZpY2F0ZScsIGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZXEoKS5vYmooXG4gICAgdGhpcy5rZXkoJ3ZlcnNpb24nKS5leHBsaWNpdCgwKS5pbnQoKS5vcHRpb25hbCgpLFxuICAgIHRoaXMua2V5KCdzZXJpYWxOdW1iZXInKS5pbnQoKSxcbiAgICB0aGlzLmtleSgnc2lnbmF0dXJlJykudXNlKEFsZ29yaXRobUlkZW50aWZpZXIpLFxuICAgIHRoaXMua2V5KCdpc3N1ZXInKS51c2UoTmFtZSksXG4gICAgdGhpcy5rZXkoJ3ZhbGlkaXR5JykudXNlKFZhbGlkaXR5KSxcbiAgICB0aGlzLmtleSgnc3ViamVjdCcpLnVzZShOYW1lKSxcbiAgICB0aGlzLmtleSgnc3ViamVjdFB1YmxpY0tleUluZm8nKS51c2UoU3ViamVjdFB1YmxpY0tleUluZm8pLFxuICAgIHRoaXMua2V5KCdpc3N1ZXJVbmlxdWVJRCcpLmltcGxpY2l0KDEpLmJpdHN0cigpLm9wdGlvbmFsKCksXG4gICAgdGhpcy5rZXkoJ3N1YmplY3RVbmlxdWVJRCcpLmltcGxpY2l0KDIpLmJpdHN0cigpLm9wdGlvbmFsKCksXG4gICAgdGhpcy5rZXkoJ2V4dGVuc2lvbnMnKS5leHBsaWNpdCgzKS5zZXFvZihFeHRlbnNpb24pLm9wdGlvbmFsKClcbiAgKVxufSlcblxudmFyIFg1MDlDZXJ0aWZpY2F0ZSA9IGFzbi5kZWZpbmUoJ1g1MDlDZXJ0aWZpY2F0ZScsIGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZXEoKS5vYmooXG4gICAgdGhpcy5rZXkoJ3Ric0NlcnRpZmljYXRlJykudXNlKFRCU0NlcnRpZmljYXRlKSxcbiAgICB0aGlzLmtleSgnc2lnbmF0dXJlQWxnb3JpdGhtJykudXNlKEFsZ29yaXRobUlkZW50aWZpZXIpLFxuICAgIHRoaXMua2V5KCdzaWduYXR1cmVWYWx1ZScpLmJpdHN0cigpXG4gIClcbn0pXG5cbm1vZHVsZS5leHBvcnRzID0gWDUwOUNlcnRpZmljYXRlXG4iLCIvLyBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2FwYXRpbC9wZW1zdHJpcFxudmFyIGZpbmRQcm9jID0gL1Byb2MtVHlwZTogNCxFTkNSWVBURURbXFxuXFxyXStERUstSW5mbzogQUVTLSgoPzoxMjgpfCg/OjE5Mil8KD86MjU2KSktQ0JDLChbMC05QS1IXSspW1xcblxccl0rKFswLTlBLXpcXG5cXHJcXCtcXC9cXD1dKylbXFxuXFxyXSsvbVxudmFyIHN0YXJ0UmVnZXggPSAvXi0tLS0tQkVHSU4gKCg/Oi4qPyBLRVkpfENFUlRJRklDQVRFKS0tLS0tL21cbnZhciBmdWxsUmVnZXggPSAvXi0tLS0tQkVHSU4gKCg/Oi4qPyBLRVkpfENFUlRJRklDQVRFKS0tLS0tKFswLTlBLXpcXG5cXHJcXCtcXC9cXD1dKyktLS0tLUVORCBcXDEtLS0tLSQvbVxudmFyIGV2cCA9IHJlcXVpcmUoJ2V2cF9ieXRlc3Rva2V5JylcbnZhciBjaXBoZXJzID0gcmVxdWlyZSgnYnJvd3NlcmlmeS1hZXMnKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChva2V5LCBwYXNzd29yZCkge1xuICB2YXIga2V5ID0gb2tleS50b1N0cmluZygpXG4gIHZhciBtYXRjaCA9IGtleS5tYXRjaChmaW5kUHJvYylcbiAgdmFyIGRlY3J5cHRlZFxuICBpZiAoIW1hdGNoKSB7XG4gICAgdmFyIG1hdGNoMiA9IGtleS5tYXRjaChmdWxsUmVnZXgpXG4gICAgZGVjcnlwdGVkID0gbmV3IEJ1ZmZlcihtYXRjaDJbMl0ucmVwbGFjZSgvW1xcclxcbl0vZywgJycpLCAnYmFzZTY0JylcbiAgfSBlbHNlIHtcbiAgICB2YXIgc3VpdGUgPSAnYWVzJyArIG1hdGNoWzFdXG4gICAgdmFyIGl2ID0gQnVmZmVyLmZyb20obWF0Y2hbMl0sICdoZXgnKVxuICAgIHZhciBjaXBoZXJUZXh0ID0gQnVmZmVyLmZyb20obWF0Y2hbM10ucmVwbGFjZSgvW1xcclxcbl0vZywgJycpLCAnYmFzZTY0JylcbiAgICB2YXIgY2lwaGVyS2V5ID0gZXZwKHBhc3N3b3JkLCBpdi5zbGljZSgwLCA4KSwgcGFyc2VJbnQobWF0Y2hbMV0sIDEwKSkua2V5XG4gICAgdmFyIG91dCA9IFtdXG4gICAgdmFyIGNpcGhlciA9IGNpcGhlcnMuY3JlYXRlRGVjaXBoZXJpdihzdWl0ZSwgY2lwaGVyS2V5LCBpdilcbiAgICBvdXQucHVzaChjaXBoZXIudXBkYXRlKGNpcGhlclRleHQpKVxuICAgIG91dC5wdXNoKGNpcGhlci5maW5hbCgpKVxuICAgIGRlY3J5cHRlZCA9IEJ1ZmZlci5jb25jYXQob3V0KVxuICB9XG4gIHZhciB0YWcgPSBrZXkubWF0Y2goc3RhcnRSZWdleClbMV1cbiAgcmV0dXJuIHtcbiAgICB0YWc6IHRhZyxcbiAgICBkYXRhOiBkZWNyeXB0ZWRcbiAgfVxufVxuIiwidmFyIGFzbjEgPSByZXF1aXJlKCcuL2FzbjEnKVxudmFyIGFlc2lkID0gcmVxdWlyZSgnLi9hZXNpZC5qc29uJylcbnZhciBmaXhQcm9jID0gcmVxdWlyZSgnLi9maXhQcm9jJylcbnZhciBjaXBoZXJzID0gcmVxdWlyZSgnYnJvd3NlcmlmeS1hZXMnKVxudmFyIGNvbXBhdCA9IHJlcXVpcmUoJ3Bia2RmMicpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbm1vZHVsZS5leHBvcnRzID0gcGFyc2VLZXlzXG5cbmZ1bmN0aW9uIHBhcnNlS2V5cyAoYnVmZmVyKSB7XG4gIHZhciBwYXNzd29yZFxuICBpZiAodHlwZW9mIGJ1ZmZlciA9PT0gJ29iamVjdCcgJiYgIUJ1ZmZlci5pc0J1ZmZlcihidWZmZXIpKSB7XG4gICAgcGFzc3dvcmQgPSBidWZmZXIucGFzc3BocmFzZVxuICAgIGJ1ZmZlciA9IGJ1ZmZlci5rZXlcbiAgfVxuICBpZiAodHlwZW9mIGJ1ZmZlciA9PT0gJ3N0cmluZycpIHtcbiAgICBidWZmZXIgPSBCdWZmZXIuZnJvbShidWZmZXIpXG4gIH1cblxuICB2YXIgc3RyaXBwZWQgPSBmaXhQcm9jKGJ1ZmZlciwgcGFzc3dvcmQpXG5cbiAgdmFyIHR5cGUgPSBzdHJpcHBlZC50YWdcbiAgdmFyIGRhdGEgPSBzdHJpcHBlZC5kYXRhXG4gIHZhciBzdWJ0eXBlLCBuZGF0YVxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdDRVJUSUZJQ0FURSc6XG4gICAgICBuZGF0YSA9IGFzbjEuY2VydGlmaWNhdGUuZGVjb2RlKGRhdGEsICdkZXInKS50YnNDZXJ0aWZpY2F0ZS5zdWJqZWN0UHVibGljS2V5SW5mb1xuICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgIGNhc2UgJ1BVQkxJQyBLRVknOlxuICAgICAgaWYgKCFuZGF0YSkge1xuICAgICAgICBuZGF0YSA9IGFzbjEuUHVibGljS2V5LmRlY29kZShkYXRhLCAnZGVyJylcbiAgICAgIH1cbiAgICAgIHN1YnR5cGUgPSBuZGF0YS5hbGdvcml0aG0uYWxnb3JpdGhtLmpvaW4oJy4nKVxuICAgICAgc3dpdGNoIChzdWJ0eXBlKSB7XG4gICAgICAgIGNhc2UgJzEuMi44NDAuMTEzNTQ5LjEuMS4xJzpcbiAgICAgICAgICByZXR1cm4gYXNuMS5SU0FQdWJsaWNLZXkuZGVjb2RlKG5kYXRhLnN1YmplY3RQdWJsaWNLZXkuZGF0YSwgJ2RlcicpXG4gICAgICAgIGNhc2UgJzEuMi44NDAuMTAwNDUuMi4xJzpcbiAgICAgICAgICBuZGF0YS5zdWJqZWN0UHJpdmF0ZUtleSA9IG5kYXRhLnN1YmplY3RQdWJsaWNLZXlcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ2VjJyxcbiAgICAgICAgICAgIGRhdGE6IG5kYXRhXG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICcxLjIuODQwLjEwMDQwLjQuMSc6XG4gICAgICAgICAgbmRhdGEuYWxnb3JpdGhtLnBhcmFtcy5wdWJfa2V5ID0gYXNuMS5EU0FwYXJhbS5kZWNvZGUobmRhdGEuc3ViamVjdFB1YmxpY0tleS5kYXRhLCAnZGVyJylcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ2RzYScsXG4gICAgICAgICAgICBkYXRhOiBuZGF0YS5hbGdvcml0aG0ucGFyYW1zXG4gICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24ga2V5IGlkICcgKyBzdWJ0eXBlKVxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGtleSB0eXBlICcgKyB0eXBlKVxuICAgIGNhc2UgJ0VOQ1JZUFRFRCBQUklWQVRFIEtFWSc6XG4gICAgICBkYXRhID0gYXNuMS5FbmNyeXB0ZWRQcml2YXRlS2V5LmRlY29kZShkYXRhLCAnZGVyJylcbiAgICAgIGRhdGEgPSBkZWNyeXB0KGRhdGEsIHBhc3N3b3JkKVxuICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgIGNhc2UgJ1BSSVZBVEUgS0VZJzpcbiAgICAgIG5kYXRhID0gYXNuMS5Qcml2YXRlS2V5LmRlY29kZShkYXRhLCAnZGVyJylcbiAgICAgIHN1YnR5cGUgPSBuZGF0YS5hbGdvcml0aG0uYWxnb3JpdGhtLmpvaW4oJy4nKVxuICAgICAgc3dpdGNoIChzdWJ0eXBlKSB7XG4gICAgICAgIGNhc2UgJzEuMi44NDAuMTEzNTQ5LjEuMS4xJzpcbiAgICAgICAgICByZXR1cm4gYXNuMS5SU0FQcml2YXRlS2V5LmRlY29kZShuZGF0YS5zdWJqZWN0UHJpdmF0ZUtleSwgJ2RlcicpXG4gICAgICAgIGNhc2UgJzEuMi44NDAuMTAwNDUuMi4xJzpcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3VydmU6IG5kYXRhLmFsZ29yaXRobS5jdXJ2ZSxcbiAgICAgICAgICAgIHByaXZhdGVLZXk6IGFzbjEuRUNQcml2YXRlS2V5LmRlY29kZShuZGF0YS5zdWJqZWN0UHJpdmF0ZUtleSwgJ2RlcicpLnByaXZhdGVLZXlcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJzEuMi44NDAuMTAwNDAuNC4xJzpcbiAgICAgICAgICBuZGF0YS5hbGdvcml0aG0ucGFyYW1zLnByaXZfa2V5ID0gYXNuMS5EU0FwYXJhbS5kZWNvZGUobmRhdGEuc3ViamVjdFByaXZhdGVLZXksICdkZXInKVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnZHNhJyxcbiAgICAgICAgICAgIHBhcmFtczogbmRhdGEuYWxnb3JpdGhtLnBhcmFtc1xuICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGtleSBpZCAnICsgc3VidHlwZSlcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBrZXkgdHlwZSAnICsgdHlwZSlcbiAgICBjYXNlICdSU0EgUFVCTElDIEtFWSc6XG4gICAgICByZXR1cm4gYXNuMS5SU0FQdWJsaWNLZXkuZGVjb2RlKGRhdGEsICdkZXInKVxuICAgIGNhc2UgJ1JTQSBQUklWQVRFIEtFWSc6XG4gICAgICByZXR1cm4gYXNuMS5SU0FQcml2YXRlS2V5LmRlY29kZShkYXRhLCAnZGVyJylcbiAgICBjYXNlICdEU0EgUFJJVkFURSBLRVknOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2RzYScsXG4gICAgICAgIHBhcmFtczogYXNuMS5EU0FQcml2YXRlS2V5LmRlY29kZShkYXRhLCAnZGVyJylcbiAgICAgIH1cbiAgICBjYXNlICdFQyBQUklWQVRFIEtFWSc6XG4gICAgICBkYXRhID0gYXNuMS5FQ1ByaXZhdGVLZXkuZGVjb2RlKGRhdGEsICdkZXInKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY3VydmU6IGRhdGEucGFyYW1ldGVycy52YWx1ZSxcbiAgICAgICAgcHJpdmF0ZUtleTogZGF0YS5wcml2YXRlS2V5XG4gICAgICB9XG4gICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGtleSB0eXBlICcgKyB0eXBlKVxuICB9XG59XG5wYXJzZUtleXMuc2lnbmF0dXJlID0gYXNuMS5zaWduYXR1cmVcbmZ1bmN0aW9uIGRlY3J5cHQgKGRhdGEsIHBhc3N3b3JkKSB7XG4gIHZhciBzYWx0ID0gZGF0YS5hbGdvcml0aG0uZGVjcnlwdC5rZGUua2RlcGFyYW1zLnNhbHRcbiAgdmFyIGl0ZXJzID0gcGFyc2VJbnQoZGF0YS5hbGdvcml0aG0uZGVjcnlwdC5rZGUua2RlcGFyYW1zLml0ZXJzLnRvU3RyaW5nKCksIDEwKVxuICB2YXIgYWxnbyA9IGFlc2lkW2RhdGEuYWxnb3JpdGhtLmRlY3J5cHQuY2lwaGVyLmFsZ28uam9pbignLicpXVxuICB2YXIgaXYgPSBkYXRhLmFsZ29yaXRobS5kZWNyeXB0LmNpcGhlci5pdlxuICB2YXIgY2lwaGVyVGV4dCA9IGRhdGEuc3ViamVjdFByaXZhdGVLZXlcbiAgdmFyIGtleWxlbiA9IHBhcnNlSW50KGFsZ28uc3BsaXQoJy0nKVsxXSwgMTApIC8gOFxuICB2YXIga2V5ID0gY29tcGF0LnBia2RmMlN5bmMocGFzc3dvcmQsIHNhbHQsIGl0ZXJzLCBrZXlsZW4sICdzaGExJylcbiAgdmFyIGNpcGhlciA9IGNpcGhlcnMuY3JlYXRlRGVjaXBoZXJpdihhbGdvLCBrZXksIGl2KVxuICB2YXIgb3V0ID0gW11cbiAgb3V0LnB1c2goY2lwaGVyLnVwZGF0ZShjaXBoZXJUZXh0KSlcbiAgb3V0LnB1c2goY2lwaGVyLmZpbmFsKCkpXG4gIHJldHVybiBCdWZmZXIuY29uY2F0KG91dClcbn1cbiIsImV4cG9ydHMucGJrZGYyID0gcmVxdWlyZSgnLi9saWIvYXN5bmMnKVxuZXhwb3J0cy5wYmtkZjJTeW5jID0gcmVxdWlyZSgnLi9saWIvc3luYycpXG4iLCJ2YXIgY2hlY2tQYXJhbWV0ZXJzID0gcmVxdWlyZSgnLi9wcmVjb25kaXRpb24nKVxudmFyIGRlZmF1bHRFbmNvZGluZyA9IHJlcXVpcmUoJy4vZGVmYXVsdC1lbmNvZGluZycpXG52YXIgc3luYyA9IHJlcXVpcmUoJy4vc3luYycpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxudmFyIFpFUk9fQlVGXG52YXIgc3VidGxlID0gZ2xvYmFsLmNyeXB0byAmJiBnbG9iYWwuY3J5cHRvLnN1YnRsZVxudmFyIHRvQnJvd3NlciA9IHtcbiAgJ3NoYSc6ICdTSEEtMScsXG4gICdzaGEtMSc6ICdTSEEtMScsXG4gICdzaGExJzogJ1NIQS0xJyxcbiAgJ3NoYTI1Nic6ICdTSEEtMjU2JyxcbiAgJ3NoYS0yNTYnOiAnU0hBLTI1NicsXG4gICdzaGEzODQnOiAnU0hBLTM4NCcsXG4gICdzaGEtMzg0JzogJ1NIQS0zODQnLFxuICAnc2hhLTUxMic6ICdTSEEtNTEyJyxcbiAgJ3NoYTUxMic6ICdTSEEtNTEyJ1xufVxudmFyIGNoZWNrcyA9IFtdXG5mdW5jdGlvbiBjaGVja05hdGl2ZSAoYWxnbykge1xuICBpZiAoZ2xvYmFsLnByb2Nlc3MgJiYgIWdsb2JhbC5wcm9jZXNzLmJyb3dzZXIpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKVxuICB9XG4gIGlmICghc3VidGxlIHx8ICFzdWJ0bGUuaW1wb3J0S2V5IHx8ICFzdWJ0bGUuZGVyaXZlQml0cykge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpXG4gIH1cbiAgaWYgKGNoZWNrc1thbGdvXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGNoZWNrc1thbGdvXVxuICB9XG4gIFpFUk9fQlVGID0gWkVST19CVUYgfHwgQnVmZmVyLmFsbG9jKDgpXG4gIHZhciBwcm9tID0gYnJvd3NlclBia2RmMihaRVJPX0JVRiwgWkVST19CVUYsIDEwLCAxMjgsIGFsZ28pXG4gICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9KS5jYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9KVxuICBjaGVja3NbYWxnb10gPSBwcm9tXG4gIHJldHVybiBwcm9tXG59XG5cbmZ1bmN0aW9uIGJyb3dzZXJQYmtkZjIgKHBhc3N3b3JkLCBzYWx0LCBpdGVyYXRpb25zLCBsZW5ndGgsIGFsZ28pIHtcbiAgcmV0dXJuIHN1YnRsZS5pbXBvcnRLZXkoXG4gICAgJ3JhdycsIHBhc3N3b3JkLCB7bmFtZTogJ1BCS0RGMid9LCBmYWxzZSwgWydkZXJpdmVCaXRzJ11cbiAgKS50aGVuKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gc3VidGxlLmRlcml2ZUJpdHMoe1xuICAgICAgbmFtZTogJ1BCS0RGMicsXG4gICAgICBzYWx0OiBzYWx0LFxuICAgICAgaXRlcmF0aW9uczogaXRlcmF0aW9ucyxcbiAgICAgIGhhc2g6IHtcbiAgICAgICAgbmFtZTogYWxnb1xuICAgICAgfVxuICAgIH0sIGtleSwgbGVuZ3RoIDw8IDMpXG4gIH0pLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShyZXMpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVQcm9taXNlIChwcm9taXNlLCBjYWxsYmFjaykge1xuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKG91dCkge1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgY2FsbGJhY2sobnVsbCwgb3V0KVxuICAgIH0pXG4gIH0sIGZ1bmN0aW9uIChlKSB7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICBjYWxsYmFjayhlKVxuICAgIH0pXG4gIH0pXG59XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChwYXNzd29yZCwgc2FsdCwgaXRlcmF0aW9ucywga2V5bGVuLCBkaWdlc3QsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgZGlnZXN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBkaWdlc3RcbiAgICBkaWdlc3QgPSB1bmRlZmluZWRcbiAgfVxuXG4gIGRpZ2VzdCA9IGRpZ2VzdCB8fCAnc2hhMSdcbiAgdmFyIGFsZ28gPSB0b0Jyb3dzZXJbZGlnZXN0LnRvTG93ZXJDYXNlKCldXG5cbiAgaWYgKCFhbGdvIHx8IHR5cGVvZiBnbG9iYWwuUHJvbWlzZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBvdXRcbiAgICAgIHRyeSB7XG4gICAgICAgIG91dCA9IHN5bmMocGFzc3dvcmQsIHNhbHQsIGl0ZXJhdGlvbnMsIGtleWxlbiwgZGlnZXN0KVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZSlcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKG51bGwsIG91dClcbiAgICB9KVxuICB9XG5cbiAgY2hlY2tQYXJhbWV0ZXJzKHBhc3N3b3JkLCBzYWx0LCBpdGVyYXRpb25zLCBrZXlsZW4pXG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcignTm8gY2FsbGJhY2sgcHJvdmlkZWQgdG8gcGJrZGYyJylcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIocGFzc3dvcmQpKSBwYXNzd29yZCA9IEJ1ZmZlci5mcm9tKHBhc3N3b3JkLCBkZWZhdWx0RW5jb2RpbmcpXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHNhbHQpKSBzYWx0ID0gQnVmZmVyLmZyb20oc2FsdCwgZGVmYXVsdEVuY29kaW5nKVxuXG4gIHJlc29sdmVQcm9taXNlKGNoZWNrTmF0aXZlKGFsZ28pLnRoZW4oZnVuY3Rpb24gKHJlc3ApIHtcbiAgICBpZiAocmVzcCkgcmV0dXJuIGJyb3dzZXJQYmtkZjIocGFzc3dvcmQsIHNhbHQsIGl0ZXJhdGlvbnMsIGtleWxlbiwgYWxnbylcblxuICAgIHJldHVybiBzeW5jKHBhc3N3b3JkLCBzYWx0LCBpdGVyYXRpb25zLCBrZXlsZW4sIGRpZ2VzdClcbiAgfSksIGNhbGxiYWNrKVxufVxuIiwidmFyIGRlZmF1bHRFbmNvZGluZ1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmlmIChwcm9jZXNzLmJyb3dzZXIpIHtcbiAgZGVmYXVsdEVuY29kaW5nID0gJ3V0Zi04J1xufSBlbHNlIHtcbiAgdmFyIHBWZXJzaW9uTWFqb3IgPSBwYXJzZUludChwcm9jZXNzLnZlcnNpb24uc3BsaXQoJy4nKVswXS5zbGljZSgxKSwgMTApXG5cbiAgZGVmYXVsdEVuY29kaW5nID0gcFZlcnNpb25NYWpvciA+PSA2ID8gJ3V0Zi04JyA6ICdiaW5hcnknXG59XG5tb2R1bGUuZXhwb3J0cyA9IGRlZmF1bHRFbmNvZGluZ1xuIiwidmFyIE1BWF9BTExPQyA9IE1hdGgucG93KDIsIDMwKSAtIDEgLy8gZGVmYXVsdCBpbiBpb2pzXG5cbmZ1bmN0aW9uIGNoZWNrQnVmZmVyIChidWYsIG5hbWUpIHtcbiAgaWYgKHR5cGVvZiBidWYgIT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IobmFtZSArICcgbXVzdCBiZSBhIGJ1ZmZlciBvciBzdHJpbmcnKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHBhc3N3b3JkLCBzYWx0LCBpdGVyYXRpb25zLCBrZXlsZW4pIHtcbiAgY2hlY2tCdWZmZXIocGFzc3dvcmQsICdQYXNzd29yZCcpXG4gIGNoZWNrQnVmZmVyKHNhbHQsICdTYWx0JylcblxuICBpZiAodHlwZW9mIGl0ZXJhdGlvbnMgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSXRlcmF0aW9ucyBub3QgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKGl0ZXJhdGlvbnMgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQmFkIGl0ZXJhdGlvbnMnKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBrZXlsZW4gIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignS2V5IGxlbmd0aCBub3QgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKGtleWxlbiA8IDAgfHwga2V5bGVuID4gTUFYX0FMTE9DIHx8IGtleWxlbiAhPT0ga2V5bGVuKSB7IC8qIGVzbGludCBuby1zZWxmLWNvbXBhcmU6IDAgKi9cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCYWQga2V5IGxlbmd0aCcpXG4gIH1cbn1cbiIsInZhciBtZDUgPSByZXF1aXJlKCdjcmVhdGUtaGFzaC9tZDUnKVxudmFyIFJJUEVNRDE2MCA9IHJlcXVpcmUoJ3JpcGVtZDE2MCcpXG52YXIgc2hhID0gcmVxdWlyZSgnc2hhLmpzJylcblxudmFyIGNoZWNrUGFyYW1ldGVycyA9IHJlcXVpcmUoJy4vcHJlY29uZGl0aW9uJylcbnZhciBkZWZhdWx0RW5jb2RpbmcgPSByZXF1aXJlKCcuL2RlZmF1bHQtZW5jb2RpbmcnKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG52YXIgWkVST1MgPSBCdWZmZXIuYWxsb2MoMTI4KVxudmFyIHNpemVzID0ge1xuICBtZDU6IDE2LFxuICBzaGExOiAyMCxcbiAgc2hhMjI0OiAyOCxcbiAgc2hhMjU2OiAzMixcbiAgc2hhMzg0OiA0OCxcbiAgc2hhNTEyOiA2NCxcbiAgcm1kMTYwOiAyMCxcbiAgcmlwZW1kMTYwOiAyMFxufVxuXG5mdW5jdGlvbiBIbWFjIChhbGcsIGtleSwgc2FsdExlbikge1xuICB2YXIgaGFzaCA9IGdldERpZ2VzdChhbGcpXG4gIHZhciBibG9ja3NpemUgPSAoYWxnID09PSAnc2hhNTEyJyB8fCBhbGcgPT09ICdzaGEzODQnKSA/IDEyOCA6IDY0XG5cbiAgaWYgKGtleS5sZW5ndGggPiBibG9ja3NpemUpIHtcbiAgICBrZXkgPSBoYXNoKGtleSlcbiAgfSBlbHNlIGlmIChrZXkubGVuZ3RoIDwgYmxvY2tzaXplKSB7XG4gICAga2V5ID0gQnVmZmVyLmNvbmNhdChba2V5LCBaRVJPU10sIGJsb2Nrc2l6ZSlcbiAgfVxuXG4gIHZhciBpcGFkID0gQnVmZmVyLmFsbG9jVW5zYWZlKGJsb2Nrc2l6ZSArIHNpemVzW2FsZ10pXG4gIHZhciBvcGFkID0gQnVmZmVyLmFsbG9jVW5zYWZlKGJsb2Nrc2l6ZSArIHNpemVzW2FsZ10pXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYmxvY2tzaXplOyBpKyspIHtcbiAgICBpcGFkW2ldID0ga2V5W2ldIF4gMHgzNlxuICAgIG9wYWRbaV0gPSBrZXlbaV0gXiAweDVDXG4gIH1cblxuICB2YXIgaXBhZDEgPSBCdWZmZXIuYWxsb2NVbnNhZmUoYmxvY2tzaXplICsgc2FsdExlbiArIDQpXG4gIGlwYWQuY29weShpcGFkMSwgMCwgMCwgYmxvY2tzaXplKVxuICB0aGlzLmlwYWQxID0gaXBhZDFcbiAgdGhpcy5pcGFkMiA9IGlwYWRcbiAgdGhpcy5vcGFkID0gb3BhZFxuICB0aGlzLmFsZyA9IGFsZ1xuICB0aGlzLmJsb2Nrc2l6ZSA9IGJsb2Nrc2l6ZVxuICB0aGlzLmhhc2ggPSBoYXNoXG4gIHRoaXMuc2l6ZSA9IHNpemVzW2FsZ11cbn1cblxuSG1hYy5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKGRhdGEsIGlwYWQpIHtcbiAgZGF0YS5jb3B5KGlwYWQsIHRoaXMuYmxvY2tzaXplKVxuICB2YXIgaCA9IHRoaXMuaGFzaChpcGFkKVxuICBoLmNvcHkodGhpcy5vcGFkLCB0aGlzLmJsb2Nrc2l6ZSlcbiAgcmV0dXJuIHRoaXMuaGFzaCh0aGlzLm9wYWQpXG59XG5cbmZ1bmN0aW9uIGdldERpZ2VzdCAoYWxnKSB7XG4gIGZ1bmN0aW9uIHNoYUZ1bmMgKGRhdGEpIHtcbiAgICByZXR1cm4gc2hhKGFsZykudXBkYXRlKGRhdGEpLmRpZ2VzdCgpXG4gIH1cbiAgZnVuY3Rpb24gcm1kMTYwRnVuYyAoZGF0YSkge1xuICAgIHJldHVybiBuZXcgUklQRU1EMTYwKCkudXBkYXRlKGRhdGEpLmRpZ2VzdCgpXG4gIH1cblxuICBpZiAoYWxnID09PSAncm1kMTYwJyB8fCBhbGcgPT09ICdyaXBlbWQxNjAnKSByZXR1cm4gcm1kMTYwRnVuY1xuICBpZiAoYWxnID09PSAnbWQ1JykgcmV0dXJuIG1kNVxuICByZXR1cm4gc2hhRnVuY1xufVxuXG5mdW5jdGlvbiBwYmtkZjIgKHBhc3N3b3JkLCBzYWx0LCBpdGVyYXRpb25zLCBrZXlsZW4sIGRpZ2VzdCkge1xuICBjaGVja1BhcmFtZXRlcnMocGFzc3dvcmQsIHNhbHQsIGl0ZXJhdGlvbnMsIGtleWxlbilcblxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihwYXNzd29yZCkpIHBhc3N3b3JkID0gQnVmZmVyLmZyb20ocGFzc3dvcmQsIGRlZmF1bHRFbmNvZGluZylcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoc2FsdCkpIHNhbHQgPSBCdWZmZXIuZnJvbShzYWx0LCBkZWZhdWx0RW5jb2RpbmcpXG5cbiAgZGlnZXN0ID0gZGlnZXN0IHx8ICdzaGExJ1xuXG4gIHZhciBobWFjID0gbmV3IEhtYWMoZGlnZXN0LCBwYXNzd29yZCwgc2FsdC5sZW5ndGgpXG5cbiAgdmFyIERLID0gQnVmZmVyLmFsbG9jVW5zYWZlKGtleWxlbilcbiAgdmFyIGJsb2NrMSA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShzYWx0Lmxlbmd0aCArIDQpXG4gIHNhbHQuY29weShibG9jazEsIDAsIDAsIHNhbHQubGVuZ3RoKVxuXG4gIHZhciBkZXN0UG9zID0gMFxuICB2YXIgaExlbiA9IHNpemVzW2RpZ2VzdF1cbiAgdmFyIGwgPSBNYXRoLmNlaWwoa2V5bGVuIC8gaExlbilcblxuICBmb3IgKHZhciBpID0gMTsgaSA8PSBsOyBpKyspIHtcbiAgICBibG9jazEud3JpdGVVSW50MzJCRShpLCBzYWx0Lmxlbmd0aClcblxuICAgIHZhciBUID0gaG1hYy5ydW4oYmxvY2sxLCBobWFjLmlwYWQxKVxuICAgIHZhciBVID0gVFxuXG4gICAgZm9yICh2YXIgaiA9IDE7IGogPCBpdGVyYXRpb25zOyBqKyspIHtcbiAgICAgIFUgPSBobWFjLnJ1bihVLCBobWFjLmlwYWQyKVxuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBoTGVuOyBrKyspIFRba10gXj0gVVtrXVxuICAgIH1cblxuICAgIFQuY29weShESywgZGVzdFBvcylcbiAgICBkZXN0UG9zICs9IGhMZW5cbiAgfVxuXG4gIHJldHVybiBES1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBia2RmMlxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnIHx8XG4gICAgIXByb2Nlc3MudmVyc2lvbiB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MC4nKSA9PT0gMCB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS4nKSA9PT0gMCAmJiBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuOC4nKSAhPT0gMCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IHsgbmV4dFRpY2s6IG5leHRUaWNrIH07XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHByb2Nlc3Ncbn1cblxuZnVuY3Rpb24gbmV4dFRpY2soZm4sIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiY2FsbGJhY2tcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGFyZ3MsIGk7XG4gIHN3aXRjaCAobGVuKSB7XG4gIGNhc2UgMDpcbiAgY2FzZSAxOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZuKTtcbiAgY2FzZSAyOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja09uZSgpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSk7XG4gICAgfSk7XG4gIGNhc2UgMzpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tUd28oKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEsIGFyZzIpO1xuICAgIH0pO1xuICBjYXNlIDQ6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVGhyZWUoKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgIH0pO1xuICBkZWZhdWx0OlxuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBhcmdzLmxlbmd0aCkge1xuICAgICAgYXJnc1tpKytdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2soKSB7XG4gICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9KTtcbiAgfVxufVxuXG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiZXhwb3J0cy5wdWJsaWNFbmNyeXB0ID0gcmVxdWlyZSgnLi9wdWJsaWNFbmNyeXB0JylcbmV4cG9ydHMucHJpdmF0ZURlY3J5cHQgPSByZXF1aXJlKCcuL3ByaXZhdGVEZWNyeXB0JylcblxuZXhwb3J0cy5wcml2YXRlRW5jcnlwdCA9IGZ1bmN0aW9uIHByaXZhdGVFbmNyeXB0IChrZXksIGJ1Zikge1xuICByZXR1cm4gZXhwb3J0cy5wdWJsaWNFbmNyeXB0KGtleSwgYnVmLCB0cnVlKVxufVxuXG5leHBvcnRzLnB1YmxpY0RlY3J5cHQgPSBmdW5jdGlvbiBwdWJsaWNEZWNyeXB0IChrZXksIGJ1Zikge1xuICByZXR1cm4gZXhwb3J0cy5wcml2YXRlRGVjcnlwdChrZXksIGJ1ZiwgdHJ1ZSlcbn1cbiIsInZhciBjcmVhdGVIYXNoID0gcmVxdWlyZSgnY3JlYXRlLWhhc2gnKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNlZWQsIGxlbikge1xuICB2YXIgdCA9IEJ1ZmZlci5hbGxvYygwKVxuICB2YXIgaSA9IDBcbiAgdmFyIGNcbiAgd2hpbGUgKHQubGVuZ3RoIDwgbGVuKSB7XG4gICAgYyA9IGkyb3BzKGkrKylcbiAgICB0ID0gQnVmZmVyLmNvbmNhdChbdCwgY3JlYXRlSGFzaCgnc2hhMScpLnVwZGF0ZShzZWVkKS51cGRhdGUoYykuZGlnZXN0KCldKVxuICB9XG4gIHJldHVybiB0LnNsaWNlKDAsIGxlbilcbn1cblxuZnVuY3Rpb24gaTJvcHMgKGMpIHtcbiAgdmFyIG91dCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSg0KVxuICBvdXQud3JpdGVVSW50MzJCRShjLCAwKVxuICByZXR1cm4gb3V0XG59XG4iLCJ2YXIgcGFyc2VLZXlzID0gcmVxdWlyZSgncGFyc2UtYXNuMScpXG52YXIgbWdmID0gcmVxdWlyZSgnLi9tZ2YnKVxudmFyIHhvciA9IHJlcXVpcmUoJy4veG9yJylcbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJylcbnZhciBjcnQgPSByZXF1aXJlKCdicm93c2VyaWZ5LXJzYScpXG52YXIgY3JlYXRlSGFzaCA9IHJlcXVpcmUoJ2NyZWF0ZS1oYXNoJylcbnZhciB3aXRoUHVibGljID0gcmVxdWlyZSgnLi93aXRoUHVibGljJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHByaXZhdGVEZWNyeXB0IChwcml2YXRlS2V5LCBlbmMsIHJldmVyc2UpIHtcbiAgdmFyIHBhZGRpbmdcbiAgaWYgKHByaXZhdGVLZXkucGFkZGluZykge1xuICAgIHBhZGRpbmcgPSBwcml2YXRlS2V5LnBhZGRpbmdcbiAgfSBlbHNlIGlmIChyZXZlcnNlKSB7XG4gICAgcGFkZGluZyA9IDFcbiAgfSBlbHNlIHtcbiAgICBwYWRkaW5nID0gNFxuICB9XG5cbiAgdmFyIGtleSA9IHBhcnNlS2V5cyhwcml2YXRlS2V5KVxuICB2YXIgayA9IGtleS5tb2R1bHVzLmJ5dGVMZW5ndGgoKVxuICBpZiAoZW5jLmxlbmd0aCA+IGsgfHwgbmV3IEJOKGVuYykuY21wKGtleS5tb2R1bHVzKSA+PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdkZWNyeXB0aW9uIGVycm9yJylcbiAgfVxuICB2YXIgbXNnXG4gIGlmIChyZXZlcnNlKSB7XG4gICAgbXNnID0gd2l0aFB1YmxpYyhuZXcgQk4oZW5jKSwga2V5KVxuICB9IGVsc2Uge1xuICAgIG1zZyA9IGNydChlbmMsIGtleSlcbiAgfVxuICB2YXIgekJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyhrIC0gbXNnLmxlbmd0aClcbiAgbXNnID0gQnVmZmVyLmNvbmNhdChbekJ1ZmZlciwgbXNnXSwgaylcbiAgaWYgKHBhZGRpbmcgPT09IDQpIHtcbiAgICByZXR1cm4gb2FlcChrZXksIG1zZylcbiAgfSBlbHNlIGlmIChwYWRkaW5nID09PSAxKSB7XG4gICAgcmV0dXJuIHBrY3MxKGtleSwgbXNnLCByZXZlcnNlKVxuICB9IGVsc2UgaWYgKHBhZGRpbmcgPT09IDMpIHtcbiAgICByZXR1cm4gbXNnXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIHBhZGRpbmcnKVxuICB9XG59XG5cbmZ1bmN0aW9uIG9hZXAgKGtleSwgbXNnKSB7XG4gIHZhciBrID0ga2V5Lm1vZHVsdXMuYnl0ZUxlbmd0aCgpXG4gIHZhciBpSGFzaCA9IGNyZWF0ZUhhc2goJ3NoYTEnKS51cGRhdGUoQnVmZmVyLmFsbG9jKDApKS5kaWdlc3QoKVxuICB2YXIgaExlbiA9IGlIYXNoLmxlbmd0aFxuICBpZiAobXNnWzBdICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdkZWNyeXB0aW9uIGVycm9yJylcbiAgfVxuICB2YXIgbWFza2VkU2VlZCA9IG1zZy5zbGljZSgxLCBoTGVuICsgMSlcbiAgdmFyIG1hc2tlZERiID0gbXNnLnNsaWNlKGhMZW4gKyAxKVxuICB2YXIgc2VlZCA9IHhvcihtYXNrZWRTZWVkLCBtZ2YobWFza2VkRGIsIGhMZW4pKVxuICB2YXIgZGIgPSB4b3IobWFza2VkRGIsIG1nZihzZWVkLCBrIC0gaExlbiAtIDEpKVxuICBpZiAoY29tcGFyZShpSGFzaCwgZGIuc2xpY2UoMCwgaExlbikpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdkZWNyeXB0aW9uIGVycm9yJylcbiAgfVxuICB2YXIgaSA9IGhMZW5cbiAgd2hpbGUgKGRiW2ldID09PSAwKSB7XG4gICAgaSsrXG4gIH1cbiAgaWYgKGRiW2krK10gIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2RlY3J5cHRpb24gZXJyb3InKVxuICB9XG4gIHJldHVybiBkYi5zbGljZShpKVxufVxuXG5mdW5jdGlvbiBwa2NzMSAoa2V5LCBtc2csIHJldmVyc2UpIHtcbiAgdmFyIHAxID0gbXNnLnNsaWNlKDAsIDIpXG4gIHZhciBpID0gMlxuICB2YXIgc3RhdHVzID0gMFxuICB3aGlsZSAobXNnW2krK10gIT09IDApIHtcbiAgICBpZiAoaSA+PSBtc2cubGVuZ3RoKSB7XG4gICAgICBzdGF0dXMrK1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgdmFyIHBzID0gbXNnLnNsaWNlKDIsIGkgLSAxKVxuXG4gIGlmICgocDEudG9TdHJpbmcoJ2hleCcpICE9PSAnMDAwMicgJiYgIXJldmVyc2UpIHx8IChwMS50b1N0cmluZygnaGV4JykgIT09ICcwMDAxJyAmJiByZXZlcnNlKSkge1xuICAgIHN0YXR1cysrXG4gIH1cbiAgaWYgKHBzLmxlbmd0aCA8IDgpIHtcbiAgICBzdGF0dXMrK1xuICB9XG4gIGlmIChzdGF0dXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2RlY3J5cHRpb24gZXJyb3InKVxuICB9XG4gIHJldHVybiBtc2cuc2xpY2UoaSlcbn1cbmZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgYSA9IEJ1ZmZlci5mcm9tKGEpXG4gIGIgPSBCdWZmZXIuZnJvbShiKVxuICB2YXIgZGlmID0gMFxuICB2YXIgbGVuID0gYS5sZW5ndGhcbiAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgIGRpZisrXG4gICAgbGVuID0gTWF0aC5taW4oYS5sZW5ndGgsIGIubGVuZ3RoKVxuICB9XG4gIHZhciBpID0gLTFcbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIGRpZiArPSAoYVtpXSBeIGJbaV0pXG4gIH1cbiAgcmV0dXJuIGRpZlxufVxuIiwidmFyIHBhcnNlS2V5cyA9IHJlcXVpcmUoJ3BhcnNlLWFzbjEnKVxudmFyIHJhbmRvbUJ5dGVzID0gcmVxdWlyZSgncmFuZG9tYnl0ZXMnKVxudmFyIGNyZWF0ZUhhc2ggPSByZXF1aXJlKCdjcmVhdGUtaGFzaCcpXG52YXIgbWdmID0gcmVxdWlyZSgnLi9tZ2YnKVxudmFyIHhvciA9IHJlcXVpcmUoJy4veG9yJylcbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJylcbnZhciB3aXRoUHVibGljID0gcmVxdWlyZSgnLi93aXRoUHVibGljJylcbnZhciBjcnQgPSByZXF1aXJlKCdicm93c2VyaWZ5LXJzYScpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwdWJsaWNFbmNyeXB0IChwdWJsaWNLZXksIG1zZywgcmV2ZXJzZSkge1xuICB2YXIgcGFkZGluZ1xuICBpZiAocHVibGljS2V5LnBhZGRpbmcpIHtcbiAgICBwYWRkaW5nID0gcHVibGljS2V5LnBhZGRpbmdcbiAgfSBlbHNlIGlmIChyZXZlcnNlKSB7XG4gICAgcGFkZGluZyA9IDFcbiAgfSBlbHNlIHtcbiAgICBwYWRkaW5nID0gNFxuICB9XG4gIHZhciBrZXkgPSBwYXJzZUtleXMocHVibGljS2V5KVxuICB2YXIgcGFkZGVkTXNnXG4gIGlmIChwYWRkaW5nID09PSA0KSB7XG4gICAgcGFkZGVkTXNnID0gb2FlcChrZXksIG1zZylcbiAgfSBlbHNlIGlmIChwYWRkaW5nID09PSAxKSB7XG4gICAgcGFkZGVkTXNnID0gcGtjczEoa2V5LCBtc2csIHJldmVyc2UpXG4gIH0gZWxzZSBpZiAocGFkZGluZyA9PT0gMykge1xuICAgIHBhZGRlZE1zZyA9IG5ldyBCTihtc2cpXG4gICAgaWYgKHBhZGRlZE1zZy5jbXAoa2V5Lm1vZHVsdXMpID49IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZGF0YSB0b28gbG9uZyBmb3IgbW9kdWx1cycpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBwYWRkaW5nJylcbiAgfVxuICBpZiAocmV2ZXJzZSkge1xuICAgIHJldHVybiBjcnQocGFkZGVkTXNnLCBrZXkpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHdpdGhQdWJsaWMocGFkZGVkTXNnLCBrZXkpXG4gIH1cbn1cblxuZnVuY3Rpb24gb2FlcCAoa2V5LCBtc2cpIHtcbiAgdmFyIGsgPSBrZXkubW9kdWx1cy5ieXRlTGVuZ3RoKClcbiAgdmFyIG1MZW4gPSBtc2cubGVuZ3RoXG4gIHZhciBpSGFzaCA9IGNyZWF0ZUhhc2goJ3NoYTEnKS51cGRhdGUoQnVmZmVyLmFsbG9jKDApKS5kaWdlc3QoKVxuICB2YXIgaExlbiA9IGlIYXNoLmxlbmd0aFxuICB2YXIgaExlbjIgPSAyICogaExlblxuICBpZiAobUxlbiA+IGsgLSBoTGVuMiAtIDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ21lc3NhZ2UgdG9vIGxvbmcnKVxuICB9XG4gIHZhciBwcyA9IEJ1ZmZlci5hbGxvYyhrIC0gbUxlbiAtIGhMZW4yIC0gMilcbiAgdmFyIGRibGVuID0gayAtIGhMZW4gLSAxXG4gIHZhciBzZWVkID0gcmFuZG9tQnl0ZXMoaExlbilcbiAgdmFyIG1hc2tlZERiID0geG9yKEJ1ZmZlci5jb25jYXQoW2lIYXNoLCBwcywgQnVmZmVyLmFsbG9jKDEsIDEpLCBtc2ddLCBkYmxlbiksIG1nZihzZWVkLCBkYmxlbikpXG4gIHZhciBtYXNrZWRTZWVkID0geG9yKHNlZWQsIG1nZihtYXNrZWREYiwgaExlbikpXG4gIHJldHVybiBuZXcgQk4oQnVmZmVyLmNvbmNhdChbQnVmZmVyLmFsbG9jKDEpLCBtYXNrZWRTZWVkLCBtYXNrZWREYl0sIGspKVxufVxuZnVuY3Rpb24gcGtjczEgKGtleSwgbXNnLCByZXZlcnNlKSB7XG4gIHZhciBtTGVuID0gbXNnLmxlbmd0aFxuICB2YXIgayA9IGtleS5tb2R1bHVzLmJ5dGVMZW5ndGgoKVxuICBpZiAobUxlbiA+IGsgLSAxMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignbWVzc2FnZSB0b28gbG9uZycpXG4gIH1cbiAgdmFyIHBzXG4gIGlmIChyZXZlcnNlKSB7XG4gICAgcHMgPSBCdWZmZXIuYWxsb2MoayAtIG1MZW4gLSAzLCAweGZmKVxuICB9IGVsc2Uge1xuICAgIHBzID0gbm9uWmVybyhrIC0gbUxlbiAtIDMpXG4gIH1cbiAgcmV0dXJuIG5ldyBCTihCdWZmZXIuY29uY2F0KFtCdWZmZXIuZnJvbShbMCwgcmV2ZXJzZSA/IDEgOiAyXSksIHBzLCBCdWZmZXIuYWxsb2MoMSksIG1zZ10sIGspKVxufVxuZnVuY3Rpb24gbm9uWmVybyAobGVuKSB7XG4gIHZhciBvdXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuKVxuICB2YXIgaSA9IDBcbiAgdmFyIGNhY2hlID0gcmFuZG9tQnl0ZXMobGVuICogMilcbiAgdmFyIGN1ciA9IDBcbiAgdmFyIG51bVxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIGlmIChjdXIgPT09IGNhY2hlLmxlbmd0aCkge1xuICAgICAgY2FjaGUgPSByYW5kb21CeXRlcyhsZW4gKiAyKVxuICAgICAgY3VyID0gMFxuICAgIH1cbiAgICBudW0gPSBjYWNoZVtjdXIrK11cbiAgICBpZiAobnVtKSB7XG4gICAgICBvdXRbaSsrXSA9IG51bVxuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0XG59XG4iLCJ2YXIgQk4gPSByZXF1aXJlKCdibi5qcycpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxuZnVuY3Rpb24gd2l0aFB1YmxpYyAocGFkZGVkTXNnLCBrZXkpIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHBhZGRlZE1zZ1xuICAgIC50b1JlZChCTi5tb250KGtleS5tb2R1bHVzKSlcbiAgICAucmVkUG93KG5ldyBCTihrZXkucHVibGljRXhwb25lbnQpKVxuICAgIC5mcm9tUmVkKClcbiAgICAudG9BcnJheSgpKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdpdGhQdWJsaWNcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24geG9yIChhLCBiKSB7XG4gIHZhciBsZW4gPSBhLmxlbmd0aFxuICB2YXIgaSA9IC0xXG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICBhW2ldIF49IGJbaV1cbiAgfVxuICByZXR1cm4gYVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbi8vIGxpbWl0IG9mIENyeXB0by5nZXRSYW5kb21WYWx1ZXMoKVxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NyeXB0by9nZXRSYW5kb21WYWx1ZXNcbnZhciBNQVhfQllURVMgPSA2NTUzNlxuXG4vLyBOb2RlIHN1cHBvcnRzIHJlcXVlc3RpbmcgdXAgdG8gdGhpcyBudW1iZXIgb2YgYnl0ZXNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL21hc3Rlci9saWIvaW50ZXJuYWwvY3J5cHRvL3JhbmRvbS5qcyNMNDhcbnZhciBNQVhfVUlOVDMyID0gNDI5NDk2NzI5NVxuXG5mdW5jdGlvbiBvbGRCcm93c2VyICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdTZWN1cmUgcmFuZG9tIG51bWJlciBnZW5lcmF0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBicm93c2VyLlxcblVzZSBDaHJvbWUsIEZpcmVmb3ggb3IgSW50ZXJuZXQgRXhwbG9yZXIgMTEnKVxufVxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbnZhciBjcnlwdG8gPSBnbG9iYWwuY3J5cHRvIHx8IGdsb2JhbC5tc0NyeXB0b1xuXG5pZiAoY3J5cHRvICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByYW5kb21CeXRlc1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBvbGRCcm93c2VyXG59XG5cbmZ1bmN0aW9uIHJhbmRvbUJ5dGVzIChzaXplLCBjYikge1xuICAvLyBwaGFudG9tanMgbmVlZHMgdG8gdGhyb3dcbiAgaWYgKHNpemUgPiBNQVhfVUlOVDMyKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcigncmVxdWVzdGVkIHRvbyBtYW55IHJhbmRvbSBieXRlcycpXG5cbiAgdmFyIGJ5dGVzID0gQnVmZmVyLmFsbG9jVW5zYWZlKHNpemUpXG5cbiAgaWYgKHNpemUgPiAwKSB7ICAvLyBnZXRSYW5kb21WYWx1ZXMgZmFpbHMgb24gSUUgaWYgc2l6ZSA9PSAwXG4gICAgaWYgKHNpemUgPiBNQVhfQllURVMpIHsgLy8gdGhpcyBpcyB0aGUgbWF4IGJ5dGVzIGNyeXB0by5nZXRSYW5kb21WYWx1ZXNcbiAgICAgIC8vIGNhbiBkbyBhdCBvbmNlIHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXNcbiAgICAgIGZvciAodmFyIGdlbmVyYXRlZCA9IDA7IGdlbmVyYXRlZCA8IHNpemU7IGdlbmVyYXRlZCArPSBNQVhfQllURVMpIHtcbiAgICAgICAgLy8gYnVmZmVyLnNsaWNlIGF1dG9tYXRpY2FsbHkgY2hlY2tzIGlmIHRoZSBlbmQgaXMgcGFzdCB0aGUgZW5kIG9mXG4gICAgICAgIC8vIHRoZSBidWZmZXIgc28gd2UgZG9uJ3QgaGF2ZSB0byBoZXJlXG4gICAgICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYnl0ZXMuc2xpY2UoZ2VuZXJhdGVkLCBnZW5lcmF0ZWQgKyBNQVhfQllURVMpKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGJ5dGVzKVxuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICBjYihudWxsLCBieXRlcylcbiAgICB9KVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG4iLCIndXNlIHN0cmljdCdcblxuZnVuY3Rpb24gb2xkQnJvd3NlciAoKSB7XG4gIHRocm93IG5ldyBFcnJvcignc2VjdXJlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdGlvbiBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgYnJvd3NlclxcbnVzZSBjaHJvbWUsIEZpcmVGb3ggb3IgSW50ZXJuZXQgRXhwbG9yZXIgMTEnKVxufVxudmFyIHNhZmVCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpXG52YXIgcmFuZG9tYnl0ZXMgPSByZXF1aXJlKCdyYW5kb21ieXRlcycpXG52YXIgQnVmZmVyID0gc2FmZUJ1ZmZlci5CdWZmZXJcbnZhciBrQnVmZmVyTWF4TGVuZ3RoID0gc2FmZUJ1ZmZlci5rTWF4TGVuZ3RoXG52YXIgY3J5cHRvID0gZ2xvYmFsLmNyeXB0byB8fCBnbG9iYWwubXNDcnlwdG9cbnZhciBrTWF4VWludDMyID0gTWF0aC5wb3coMiwgMzIpIC0gMVxuZnVuY3Rpb24gYXNzZXJ0T2Zmc2V0IChvZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICE9PSBvZmZzZXQpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvZmZzZXQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAob2Zmc2V0ID4ga01heFVpbnQzMiB8fCBvZmZzZXQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb2Zmc2V0IG11c3QgYmUgYSB1aW50MzInKVxuICB9XG5cbiAgaWYgKG9mZnNldCA+IGtCdWZmZXJNYXhMZW5ndGggfHwgb2Zmc2V0ID4gbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBvdXQgb2YgcmFuZ2UnKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicgfHwgc2l6ZSAhPT0gc2l6ZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NpemUgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAoc2l6ZSA+IGtNYXhVaW50MzIgfHwgc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzaXplIG11c3QgYmUgYSB1aW50MzInKVxuICB9XG5cbiAgaWYgKHNpemUgKyBvZmZzZXQgPiBsZW5ndGggfHwgc2l6ZSA+IGtCdWZmZXJNYXhMZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignYnVmZmVyIHRvbyBzbWFsbCcpXG4gIH1cbn1cbmlmICgoY3J5cHRvICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHx8ICFwcm9jZXNzLmJyb3dzZXIpIHtcbiAgZXhwb3J0cy5yYW5kb21GaWxsID0gcmFuZG9tRmlsbFxuICBleHBvcnRzLnJhbmRvbUZpbGxTeW5jID0gcmFuZG9tRmlsbFN5bmNcbn0gZWxzZSB7XG4gIGV4cG9ydHMucmFuZG9tRmlsbCA9IG9sZEJyb3dzZXJcbiAgZXhwb3J0cy5yYW5kb21GaWxsU3luYyA9IG9sZEJyb3dzZXJcbn1cbmZ1bmN0aW9uIHJhbmRvbUZpbGwgKGJ1Ziwgb2Zmc2V0LCBzaXplLCBjYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpICYmICEoYnVmIGluc3RhbmNlb2YgZ2xvYmFsLlVpbnQ4QXJyYXkpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIG9yIFVpbnQ4QXJyYXknKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IG9mZnNldFxuICAgIG9mZnNldCA9IDBcbiAgICBzaXplID0gYnVmLmxlbmd0aFxuICB9IGVsc2UgaWYgKHR5cGVvZiBzaXplID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBzaXplXG4gICAgc2l6ZSA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgfSBlbHNlIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImNiXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJylcbiAgfVxuICBhc3NlcnRPZmZzZXQob2Zmc2V0LCBidWYubGVuZ3RoKVxuICBhc3NlcnRTaXplKHNpemUsIG9mZnNldCwgYnVmLmxlbmd0aClcbiAgcmV0dXJuIGFjdHVhbEZpbGwoYnVmLCBvZmZzZXQsIHNpemUsIGNiKVxufVxuXG5mdW5jdGlvbiBhY3R1YWxGaWxsIChidWYsIG9mZnNldCwgc2l6ZSwgY2IpIHtcbiAgaWYgKHByb2Nlc3MuYnJvd3Nlcikge1xuICAgIHZhciBvdXJCdWYgPSBidWYuYnVmZmVyXG4gICAgdmFyIHVpbnQgPSBuZXcgVWludDhBcnJheShvdXJCdWYsIG9mZnNldCwgc2l6ZSlcbiAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKHVpbnQpXG4gICAgaWYgKGNiKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2IobnVsbCwgYnVmKVxuICAgICAgfSlcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICByZXR1cm4gYnVmXG4gIH1cbiAgaWYgKGNiKSB7XG4gICAgcmFuZG9tYnl0ZXMoc2l6ZSwgZnVuY3Rpb24gKGVyciwgYnl0ZXMpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNiKGVycilcbiAgICAgIH1cbiAgICAgIGJ5dGVzLmNvcHkoYnVmLCBvZmZzZXQpXG4gICAgICBjYihudWxsLCBidWYpXG4gICAgfSlcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgYnl0ZXMgPSByYW5kb21ieXRlcyhzaXplKVxuICBieXRlcy5jb3B5KGJ1Ziwgb2Zmc2V0KVxuICByZXR1cm4gYnVmXG59XG5mdW5jdGlvbiByYW5kb21GaWxsU3luYyAoYnVmLCBvZmZzZXQsIHNpemUpIHtcbiAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgb2Zmc2V0ID0gMFxuICB9XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikgJiYgIShidWYgaW5zdGFuY2VvZiBnbG9iYWwuVWludDhBcnJheSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZlwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgb3IgVWludDhBcnJheScpXG4gIH1cblxuICBhc3NlcnRPZmZzZXQob2Zmc2V0LCBidWYubGVuZ3RoKVxuXG4gIGlmIChzaXplID09PSB1bmRlZmluZWQpIHNpemUgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG5cbiAgYXNzZXJ0U2l6ZShzaXplLCBvZmZzZXQsIGJ1Zi5sZW5ndGgpXG5cbiAgcmV0dXJuIGFjdHVhbEZpbGwoYnVmLCBvZmZzZXQsIHNpemUpXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBkdXBsZXggc3RyZWFtIGlzIGp1c3QgYSBzdHJlYW0gdGhhdCBpcyBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZS5cbi8vIFNpbmNlIEpTIGRvZXNuJ3QgaGF2ZSBtdWx0aXBsZSBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCB0aGlzIGNsYXNzXG4vLyBwcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBSZWFkYWJsZSwgYW5kIHRoZW4gcGFyYXNpdGljYWxseSBmcm9tXG4vLyBXcml0YWJsZS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgfXJldHVybiBrZXlzO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IER1cGxleDtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgUmVhZGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fcmVhZGFibGUnKTtcbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV93cml0YWJsZScpO1xuXG51dGlsLmluaGVyaXRzKER1cGxleCwgUmVhZGFibGUpO1xuXG57XG4gIC8vIGF2b2lkIHNjb3BlIGNyZWVwLCB0aGUga2V5cyBhcnJheSBjYW4gdGhlbiBiZSBjb2xsZWN0ZWRcbiAgdmFyIGtleXMgPSBvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSk7XG4gIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgIHZhciBtZXRob2QgPSBrZXlzW3ZdO1xuICAgIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKSBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucyk7XG5cbiAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgV3JpdGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSkgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKSB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSkgdGhpcy5hbGxvd0hhbGZPcGVuID0gZmFsc2U7XG5cbiAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZCk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcblxuLy8gdGhlIG5vLWhhbGYtb3BlbiBlbmZvcmNlclxuZnVuY3Rpb24gb25lbmQoKSB7XG4gIC8vIGlmIHdlIGFsbG93IGhhbGYtb3BlbiBzdGF0ZSwgb3IgaWYgdGhlIHdyaXRhYmxlIHNpZGUgZW5kZWQsXG4gIC8vIHRoZW4gd2UncmUgb2suXG4gIGlmICh0aGlzLmFsbG93SGFsZk9wZW4gfHwgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCkgcmV0dXJuO1xuXG4gIC8vIG5vIG1vcmUgZGF0YSBjYW4gYmUgd3JpdHRlbi5cbiAgLy8gQnV0IGFsbG93IG1vcmUgd3JpdGVzIHRvIGhhcHBlbiBpbiB0aGlzIHRpY2suXG4gIHBuYS5uZXh0VGljayhvbkVuZE5ULCB0aGlzKTtcbn1cblxuZnVuY3Rpb24gb25FbmROVChzZWxmKSB7XG4gIHNlbGYuZW5kKCk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5cbkR1cGxleC5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB0aGlzLnB1c2gobnVsbCk7XG4gIHRoaXMuZW5kKCk7XG5cbiAgcG5hLm5leHRUaWNrKGNiLCBlcnIpO1xufTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBwYXNzdGhyb3VnaCBzdHJlYW0uXG4vLyBiYXNpY2FsbHkganVzdCB0aGUgbW9zdCBtaW5pbWFsIHNvcnQgb2YgVHJhbnNmb3JtIHN0cmVhbS5cbi8vIEV2ZXJ5IHdyaXR0ZW4gY2h1bmsgZ2V0cyBvdXRwdXQgYXMtaXMuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBQYXNzVGhyb3VnaDtcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vX3N0cmVhbV90cmFuc2Zvcm0nKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFBhc3NUaHJvdWdoLCBUcmFuc2Zvcm0pO1xuXG5mdW5jdGlvbiBQYXNzVGhyb3VnaChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaCkpIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG5cbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobnVsbCwgY2h1bmspO1xufTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbnZhciBFRWxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiAoZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG5cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgZGVidWdVdGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIGRlYnVnID0gdm9pZCAwO1xuaWYgKGRlYnVnVXRpbCAmJiBkZWJ1Z1V0aWwuZGVidWdsb2cpIHtcbiAgZGVidWcgPSBkZWJ1Z1V0aWwuZGVidWdsb2coJ3N0cmVhbScpO1xufSBlbHNlIHtcbiAgZGVidWcgPSBmdW5jdGlvbiAoKSB7fTtcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyTGlzdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9CdWZmZXJMaXN0Jyk7XG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xudmFyIFN0cmluZ0RlY29kZXI7XG5cbnV0aWwuaW5oZXJpdHMoUmVhZGFibGUsIFN0cmVhbSk7XG5cbnZhciBrUHJveHlFdmVudHMgPSBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knLCAncGF1c2UnLCAncmVzdW1lJ107XG5cbmZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4pIHtcbiAgLy8gU2FkbHkgdGhpcyBpcyBub3QgY2FjaGVhYmxlIGFzIHNvbWUgbGlicmFyaWVzIGJ1bmRsZSB0aGVpciBvd25cbiAgLy8gZXZlbnQgZW1pdHRlciBpbXBsZW1lbnRhdGlvbiB3aXRoIHRoZW0uXG4gIGlmICh0eXBlb2YgZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHJldHVybiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lcihldmVudCwgZm4pO1xuXG4gIC8vIFRoaXMgaXMgYSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnlcbiAgLy8gdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuIFRoaXMgaXMgaGVyZSBvbmx5IGJlY2F1c2UgdGhpcyBjb2RlIG5lZWRzXG4gIC8vIHRvIGNvbnRpbnVlIHRvIHdvcmsgd2l0aCBvbGRlciB2ZXJzaW9ucyBvZiBOb2RlLmpzIHRoYXQgZG8gbm90IGluY2x1ZGVcbiAgLy8gdGhlIHByZXBlbmRMaXN0ZW5lcigpIG1ldGhvZC4gVGhlIGdvYWwgaXMgdG8gZXZlbnR1YWxseSByZW1vdmUgdGhpcyBoYWNrLlxuICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkgZW1pdHRlci5vbihldmVudCwgZm4pO2Vsc2UgaWYgKGlzQXJyYXkoZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkpIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0udW5zaGlmdChmbik7ZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdID0gW2ZuLCBlbWl0dGVyLl9ldmVudHNbZXZlbnRdXTtcbn1cblxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbS5cbiAgLy8gVGhlc2Ugb3B0aW9ucyBjYW4gYmUgcHJvdmlkZWQgc2VwYXJhdGVseSBhcyByZWFkYWJsZVhYWCBhbmQgd3JpdGFibGVYWFguXG4gIHZhciBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCBpdCBzdG9wcyBjYWxsaW5nIF9yZWFkKCkgdG8gZmlsbCB0aGUgYnVmZmVyXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgXCJkb24ndCBjYWxsIF9yZWFkIHByZWVtcHRpdmVseSBldmVyXCJcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIHJlYWRhYmxlSHdtID0gb3B0aW9ucy5yZWFkYWJsZUhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG5cbiAgaWYgKGh3bSB8fCBod20gPT09IDApIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bTtlbHNlIGlmIChpc0R1cGxleCAmJiAocmVhZGFibGVId20gfHwgcmVhZGFibGVId20gPT09IDApKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSByZWFkYWJsZUh3bTtlbHNlIHRoaXMuaGlnaFdhdGVyTWFyayA9IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBNYXRoLmZsb29yKHRoaXMuaGlnaFdhdGVyTWFyayk7XG5cbiAgLy8gQSBsaW5rZWQgbGlzdCBpcyB1c2VkIHRvIHN0b3JlIGRhdGEgY2h1bmtzIGluc3RlYWQgb2YgYW4gYXJyYXkgYmVjYXVzZSB0aGVcbiAgLy8gbGlua2VkIGxpc3QgY2FuIHJlbW92ZSBlbGVtZW50cyBmcm9tIHRoZSBiZWdpbm5pbmcgZmFzdGVyIHRoYW5cbiAgLy8gYXJyYXkuc2hpZnQoKVxuICB0aGlzLmJ1ZmZlciA9IG5ldyBCdWZmZXJMaXN0KCk7XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdGhpcy5waXBlcyA9IG51bGw7XG4gIHRoaXMucGlwZXNDb3VudCA9IDA7XG4gIHRoaXMuZmxvd2luZyA9IG51bGw7XG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgdGhpcy5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIHRoaXMucmVhZGluZyA9IGZhbHNlO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIGV2ZW50ICdyZWFkYWJsZScvJ2RhdGEnIGlzIGVtaXR0ZWRcbiAgLy8gaW1tZWRpYXRlbHksIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2VcbiAgLy8gYW55IGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHJlYWQgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxuICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi5cbiAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlO1xuICB0aGlzLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuXG4gIC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7XG5cbiAgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XG5cbiAgdGhpcy5kZWNvZGVyID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IG51bGw7XG4gIGlmIChvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTtcbiAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSkgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTtcblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5XG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnJlYWQgPT09ICdmdW5jdGlvbicpIHRoaXMuX3JlYWQgPSBvcHRpb25zLnJlYWQ7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuXG5SZWFkYWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG5SZWFkYWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcblJlYWRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHRoaXMucHVzaChudWxsKTtcbiAgY2IoZXJyKTtcbn07XG5cbi8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgc2tpcENodW5rQ2hlY2s7XG5cbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuICAgICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xuICAgICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICAgIGVuY29kaW5nID0gJyc7XG4gICAgICB9XG4gICAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBlbmNvZGluZywgZmFsc2UsIHNraXBDaHVua0NoZWNrKTtcbn07XG5cbi8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIChjaHVuaykge1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgbnVsbCwgdHJ1ZSwgZmFsc2UpO1xufTtcblxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCwgc2tpcENodW5rQ2hlY2spIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKCFza2lwQ2h1bmtDaGVjaykgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcbiAgICBpZiAoZXIpIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgIXN0YXRlLm9iamVjdE1vZGUgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGNodW5rKSAhPT0gQnVmZmVyLnByb3RvdHlwZSkge1xuICAgICAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWRkVG9Gcm9udCkge1xuICAgICAgICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcpKTtlbHNlIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kZWQpIHtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIWVuY29kaW5nKSB7XG4gICAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcbiAgICAgICAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuay5sZW5ndGggIT09IDApIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7ZWxzZSBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5lZWRNb3JlRGF0YShzdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBhZGRUb0Zyb250KSB7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuc3luYykge1xuICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgY2h1bmspO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9IGVsc2Uge1xuICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXG4gICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIGlmIChhZGRUb0Zyb250KSBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7ZWxzZSBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG5cbiAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKSBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgfVxuICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG5mdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XG4gIHZhciBlcjtcbiAgaWYgKCFfaXNVaW50OEFycmF5KGNodW5rKSAmJiB0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICByZXR1cm4gZXI7XG59XG5cbi8vIGlmIGl0J3MgcGFzdCB0aGUgaGlnaCB3YXRlciBtYXJrLCB3ZSBjYW4gcHVzaCBpbiBzb21lIG1vcmUuXG4vLyBBbHNvLCBpZiB3ZSBoYXZlIG5vIGRhdGEgeWV0LCB3ZSBjYW4gc3RhbmQgc29tZVxuLy8gbW9yZSBieXRlcy4gIFRoaXMgaXMgdG8gd29yayBhcm91bmQgY2FzZXMgd2hlcmUgaHdtPTAsXG4vLyBzdWNoIGFzIHRoZSByZXBsLiAgQWxzbywgaWYgdGhlIHB1c2goKSB0cmlnZ2VyZWQgYVxuLy8gcmVhZGFibGUgZXZlbnQsIGFuZCB0aGUgdXNlciBjYWxsZWQgcmVhZChsYXJnZU51bWJlcikgc3VjaCB0aGF0XG4vLyBuZWVkUmVhZGFibGUgd2FzIHNldCwgdGhlbiB3ZSBvdWdodCB0byBwdXNoIG1vcmUsIHNvIHRoYXQgYW5vdGhlclxuLy8gJ3JlYWRhYmxlJyBldmVudCB3aWxsIGJlIHRyaWdnZXJlZC5cbmZ1bmN0aW9uIG5lZWRNb3JlRGF0YShzdGF0ZSkge1xuICByZXR1cm4gIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5uZWVkUmVhZGFibGUgfHwgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPT09IGZhbHNlO1xufTtcblxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5SZWFkYWJsZS5wcm90b3R5cGUuc2V0RW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcgPSBlbmM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDhNQlxudmFyIE1BWF9IV00gPSAweDgwMDAwMDtcbmZ1bmN0aW9uIGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pIHtcbiAgaWYgKG4gPj0gTUFYX0hXTSkge1xuICAgIG4gPSBNQVhfSFdNO1xuICB9IGVsc2Uge1xuICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDIgdG8gcHJldmVudCBpbmNyZWFzaW5nIGh3bSBleGNlc3NpdmVseSBpblxuICAgIC8vIHRpbnkgYW1vdW50c1xuICAgIG4tLTtcbiAgICBuIHw9IG4gPj4+IDE7XG4gICAgbiB8PSBuID4+PiAyO1xuICAgIG4gfD0gbiA+Pj4gNDtcbiAgICBuIHw9IG4gPj4+IDg7XG4gICAgbiB8PSBuID4+PiAxNjtcbiAgICBuKys7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xuICBpZiAobiA8PSAwIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgcmV0dXJuIDA7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXR1cm4gMTtcbiAgaWYgKG4gIT09IG4pIHtcbiAgICAvLyBPbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWVcbiAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGgpIHJldHVybiBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhLmxlbmd0aDtlbHNlIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIGN1cnJlbnQgaHdtLCB0aGVuIHJhaXNlIHRoZSBod20uXG4gIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaykgc3RhdGUuaGlnaFdhdGVyTWFyayA9IGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pO1xuICBpZiAobiA8PSBzdGF0ZS5sZW5ndGgpIHJldHVybiBuO1xuICAvLyBEb24ndCBoYXZlIGVub3VnaFxuICBpZiAoIXN0YXRlLmVuZGVkKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gc3RhdGUubGVuZ3RoO1xufVxuXG4vLyB5b3UgY2FuIG92ZXJyaWRlIGVpdGhlciB0aGlzIG1ldGhvZCwgb3IgdGhlIGFzeW5jIF9yZWFkKG4pIGJlbG93LlxuUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAobikge1xuICBkZWJ1ZygncmVhZCcsIG4pO1xuICBuID0gcGFyc2VJbnQobiwgMTApO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgbk9yaWcgPSBuO1xuXG4gIGlmIChuICE9PSAwKSBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcblxuICAvLyBpZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcbiAgLy8gdGhlICdyZWFkYWJsZScgZXZlbnQgYW5kIG1vdmUgb24uXG4gIGlmIChuID09PSAwICYmIHN0YXRlLm5lZWRSZWFkYWJsZSAmJiAoc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO2Vsc2UgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpO1xuXG4gIC8vIGlmIHdlJ3ZlIGVuZGVkLCBhbmQgd2UncmUgbm93IGNsZWFyLCB0aGVuIGZpbmlzaCBpdCB1cC5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIEFsbCB0aGUgYWN0dWFsIGNodW5rIGdlbmVyYXRpb24gbG9naWMgbmVlZHMgdG8gYmVcbiAgLy8gKmJlbG93KiB0aGUgY2FsbCB0byBfcmVhZC4gIFRoZSByZWFzb24gaXMgdGhhdCBpbiBjZXJ0YWluXG4gIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWRcbiAgLy8gbWF5IGJlIGEgY29tcGxldGVseSBzeW5jaHJvbm91cyBvcGVyYXRpb24gd2hpY2ggbWF5IGNoYW5nZVxuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHJlYWQgYnVmZmVyLCBwcm92aWRpbmcgZW5vdWdoIGRhdGEgd2hlblxuICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC5cbiAgLy9cbiAgLy8gU28sIHRoZSBzdGVwcyBhcmU6XG4gIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG9cbiAgLy8gYSByZWFkIGZyb20gdGhlIGJ1ZmZlci5cbiAgLy9cbiAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC5cbiAgLy8gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGFzeW5jaHJvbm91cywgb3Igc3luY2hyb25vdXMuICBZZXMsIGl0IGlzXG4gIC8vIGRlZXBseSB1Z2x5IHRvIHdyaXRlIEFQSXMgdGhpcyB3YXksIGJ1dCB0aGF0IHN0aWxsIGRvZXNuJ3QgbWVhblxuICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlXG4gIC8vIGRlc2lnbmVkIHRvIGJlIHN5bmMvYXN5bmMgYWdub3N0aWMuXG4gIC8vIFRha2Ugbm90ZSBpZiB0aGUgX3JlYWQgY2FsbCBpcyBzeW5jIG9yIGFzeW5jIChpZSwgaWYgdGhlIHJlYWQgY2FsbFxuICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0XG4gIC8vICdyZWFkYWJsZScgZXRjLlxuICAvL1xuICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uXG5cbiAgLy8gaWYgd2UgbmVlZCBhIHJlYWRhYmxlIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gZG8gc29tZSByZWFkaW5nLlxuICB2YXIgZG9SZWFkID0gc3RhdGUubmVlZFJlYWRhYmxlO1xuICBkZWJ1ZygnbmVlZCByZWFkYWJsZScsIGRvUmVhZCk7XG5cbiAgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgfHwgc3RhdGUubGVuZ3RoIC0gbiA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkb1JlYWQgPSB0cnVlO1xuICAgIGRlYnVnKCdsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFyaycsIGRvUmVhZCk7XG4gIH1cblxuICAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXG4gIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZG9SZWFkID0gZmFsc2U7XG4gICAgZGVidWcoJ3JlYWRpbmcgb3IgZW5kZWQnLCBkb1JlYWQpO1xuICB9IGVsc2UgaWYgKGRvUmVhZCkge1xuICAgIGRlYnVnKCdkbyByZWFkJyk7XG4gICAgc3RhdGUucmVhZGluZyA9IHRydWU7XG4gICAgc3RhdGUuc3luYyA9IHRydWU7XG4gICAgLy8gaWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTtcbiAgICAvLyBJZiBfcmVhZCBwdXNoZWQgZGF0YSBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYCB3aWxsIGJlIGZhbHNlLFxuICAgIC8vIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2UgY2FuIHJldHVybiB0byB0aGUgdXNlci5cbiAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG4gIH1cblxuICB2YXIgcmV0O1xuICBpZiAobiA+IDApIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtlbHNlIHJldCA9IG51bGw7XG5cbiAgaWYgKHJldCA9PT0gbnVsbCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgbiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUubGVuZ3RoIC09IG47XG4gIH1cblxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93XG4gICAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICAgIGlmICghc3RhdGUuZW5kZWQpIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgICAvLyBJZiB3ZSB0cmllZCB0byByZWFkKCkgcGFzdCB0aGUgRU9GLCB0aGVuIGVtaXQgZW5kIG9uIHRoZSBuZXh0IHRpY2suXG4gICAgaWYgKG5PcmlnICE9PSBuICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgfVxuXG4gIGlmIChyZXQgIT09IG51bGwpIHRoaXMuZW1pdCgnZGF0YScsIHJldCk7XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUuZW5kZWQpIHJldHVybjtcbiAgaWYgKHN0YXRlLmRlY29kZXIpIHtcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuXG4gIC8vIGVtaXQgJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbn1cblxuLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBpZiAoc3RhdGUuc3luYykgcG5hLm5leHRUaWNrKGVtaXRSZWFkYWJsZV8sIHN0cmVhbSk7ZWxzZSBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcbiAgZGVidWcoJ2VtaXQgcmVhZGFibGUnKTtcbiAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gIGZsb3coc3RyZWFtKTtcbn1cblxuLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICBwbmEubmV4dFRpY2sobWF5YmVSZWFkTW9yZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJiBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZGVidWcoJ21heWJlUmVhZE1vcmUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKVxuICAgICAgLy8gZGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy5cbiAgICAgIGJyZWFrO2Vsc2UgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB9XG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59XG5cbi8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignX3JlYWQoKSBpcyBub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uIChkZXN0LCBwaXBlT3B0cykge1xuICB2YXIgc3JjID0gdGhpcztcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHtcbiAgICBjYXNlIDA6XG4gICAgICBzdGF0ZS5waXBlcyA9IGRlc3Q7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICBzdGF0ZS5waXBlcyA9IFtzdGF0ZS5waXBlcywgZGVzdF07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgc3RhdGUucGlwZXMucHVzaChkZXN0KTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHN0YXRlLnBpcGVzQ291bnQgKz0gMTtcbiAgZGVidWcoJ3BpcGUgY291bnQ9JWQgb3B0cz0laicsIHN0YXRlLnBpcGVzQ291bnQsIHBpcGVPcHRzKTtcblxuICB2YXIgZG9FbmQgPSAoIXBpcGVPcHRzIHx8IHBpcGVPcHRzLmVuZCAhPT0gZmFsc2UpICYmIGRlc3QgIT09IHByb2Nlc3Muc3Rkb3V0ICYmIGRlc3QgIT09IHByb2Nlc3Muc3RkZXJyO1xuXG4gIHZhciBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiB1bnBpcGU7XG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBwbmEubmV4dFRpY2soZW5kRm4pO2Vsc2Ugc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcblxuICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gIGZ1bmN0aW9uIG9udW5waXBlKHJlYWRhYmxlLCB1bnBpcGVJbmZvKSB7XG4gICAgZGVidWcoJ29udW5waXBlJyk7XG4gICAgaWYgKHJlYWRhYmxlID09PSBzcmMpIHtcbiAgICAgIGlmICh1bnBpcGVJbmZvICYmIHVucGlwZUluZm8uaGFzVW5waXBlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdW5waXBlSW5mby5oYXNVbnBpcGVkID0gdHJ1ZTtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlYnVnKCdvbmVuZCcpO1xuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuICAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIHZhciBjbGVhbmVkVXAgPSBmYWxzZTtcbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBkZWJ1ZygnY2xlYW51cCcpO1xuICAgIC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgdW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuXG4gICAgY2xlYW5lZFVwID0gdHJ1ZTtcblxuICAgIC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXNcbiAgICAvLyBzcGVjaWZpYyB3cml0ZXIsIHRoZW4gaXQgd291bGQgY2F1c2UgaXQgdG8gbmV2ZXIgc3RhcnRcbiAgICAvLyBmbG93aW5nIGFnYWluLlxuICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy5cbiAgICAvLyBJZiB3ZSBkb24ndCBrbm93LCB0aGVuIGFzc3VtZSB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBvbmUuXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gJiYgKCFkZXN0Ll93cml0YWJsZVN0YXRlIHx8IGRlc3QuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSkgb25kcmFpbigpO1xuICB9XG5cbiAgLy8gSWYgdGhlIHVzZXIgcHVzaGVzIG1vcmUgZGF0YSB3aGlsZSB3ZSdyZSB3cml0aW5nIHRvIGRlc3QgdGhlbiB3ZSdsbCBlbmQgdXBcbiAgLy8gaW4gb25kYXRhIGFnYWluLiBIb3dldmVyLCB3ZSBvbmx5IHdhbnQgdG8gaW5jcmVhc2UgYXdhaXREcmFpbiBvbmNlIGJlY2F1c2VcbiAgLy8gZGVzdCB3aWxsIG9ubHkgZW1pdCBvbmUgJ2RyYWluJyBldmVudCBmb3IgdGhlIG11bHRpcGxlIHdyaXRlcy5cbiAgLy8gPT4gSW50cm9kdWNlIGEgZ3VhcmQgb24gaW5jcmVhc2luZyBhd2FpdERyYWluLlxuICB2YXIgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlO1xuICBzcmMub24oJ2RhdGEnLCBvbmRhdGEpO1xuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBkZWJ1Zygnb25kYXRhJyk7XG4gICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlO1xuICAgIHZhciByZXQgPSBkZXN0LndyaXRlKGNodW5rKTtcbiAgICBpZiAoZmFsc2UgPT09IHJldCAmJiAhaW5jcmVhc2VkQXdhaXREcmFpbikge1xuICAgICAgLy8gSWYgdGhlIHVzZXIgdW5waXBlZCBkdXJpbmcgYGRlc3Qud3JpdGUoKWAsIGl0IGlzIHBvc3NpYmxlXG4gICAgICAvLyB0byBnZXQgc3R1Y2sgaW4gYSBwZXJtYW5lbnRseSBwYXVzZWQgc3RhdGUgaWYgdGhhdCB3cml0ZVxuICAgICAgLy8gYWxzbyByZXR1cm5lZCBmYWxzZS5cbiAgICAgIC8vID0+IENoZWNrIHdoZXRoZXIgYGRlc3RgIGlzIHN0aWxsIGEgcGlwaW5nIGRlc3RpbmF0aW9uLlxuICAgICAgaWYgKChzdGF0ZS5waXBlc0NvdW50ID09PSAxICYmIHN0YXRlLnBpcGVzID09PSBkZXN0IHx8IHN0YXRlLnBpcGVzQ291bnQgPiAxICYmIGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpICE9PSAtMSkgJiYgIWNsZWFuZWRVcCkge1xuICAgICAgICBkZWJ1ZygnZmFsc2Ugd3JpdGUgcmVzcG9uc2UsIHBhdXNlJywgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4pO1xuICAgICAgICBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbisrO1xuICAgICAgICBpbmNyZWFzZWRBd2FpdERyYWluID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHNyYy5wYXVzZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxuICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicsIGVyKTtcbiAgICB1bnBpcGUoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGlmIChFRWxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApIGRlc3QuZW1pdCgnZXJyb3InLCBlcik7XG4gIH1cblxuICAvLyBNYWtlIHN1cmUgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIHVzZXJsYW5kIG9uZXMuXG4gIHByZXBlbmRMaXN0ZW5lcihkZXN0LCAnZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlYnVnKCdvbmZpbmlzaCcpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIGRlYnVnKCd1bnBpcGUnKTtcbiAgICBzcmMudW5waXBlKGRlc3QpO1xuICB9XG5cbiAgLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTtcblxuICAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpO1xuICAgIHNyYy5yZXN1bWUoKTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIGRlYnVnKCdwaXBlT25EcmFpbicsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKSBzdGF0ZS5hd2FpdERyYWluLS07XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgRUVsaXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSkge1xuICAgICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgICBmbG93KHNyYyk7XG4gICAgfVxuICB9O1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24gKGRlc3QpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHVucGlwZUluZm8gPSB7IGhhc1VucGlwZWQ6IGZhbHNlIH07XG5cbiAgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkgcmV0dXJuIHRoaXM7XG5cbiAgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKSByZXR1cm4gdGhpcztcblxuICAgIGlmICghZGVzdCkgZGVzdCA9IHN0YXRlLnBpcGVzO1xuXG4gICAgLy8gZ290IGEgbWF0Y2guXG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICBpZiAoZGVzdCkgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXG5cbiAgaWYgKCFkZXN0KSB7XG4gICAgLy8gcmVtb3ZlIGFsbC5cbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdHNbaV0uZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gICAgfXJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgdmFyIGluZGV4ID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7XG4gIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiB0aGlzO1xuXG4gIHN0YXRlLnBpcGVzLnNwbGljZShpbmRleCwgMSk7XG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XG5cbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICBpZiAoZXYgPT09ICdkYXRhJykge1xuICAgIC8vIFN0YXJ0IGZsb3dpbmcgb24gbmV4dCB0aWNrIGlmIHN0cmVhbSBpc24ndCBleHBsaWNpdGx5IHBhdXNlZFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB0aGlzLnJlc3VtZSgpO1xuICB9IGVsc2UgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICBwbmEubmV4dFRpY2soblJlYWRpbmdOZXh0VGljaywgdGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5SZWFkYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBSZWFkYWJsZS5wcm90b3R5cGUub247XG5cbmZ1bmN0aW9uIG5SZWFkaW5nTmV4dFRpY2soc2VsZikge1xuICBkZWJ1ZygncmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwJyk7XG4gIHNlbGYucmVhZCgwKTtcbn1cblxuLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZScpO1xuICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgIHJlc3VtZSh0aGlzLCBzdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiByZXN1bWUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlc3VtZVNjaGVkdWxlZCkge1xuICAgIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgcG5hLm5leHRUaWNrKHJlc3VtZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZV8oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9XG5cbiAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuICBzdHJlYW0uZW1pdCgncmVzdW1lJyk7XG4gIGZsb3coc3RyZWFtKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLnJlYWRpbmcpIHN0cmVhbS5yZWFkKDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdjYWxsIHBhdXNlIGZsb3dpbmc9JWonLCB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpO1xuICBpZiAoZmFsc2UgIT09IHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwYXVzZScpO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2Zsb3cnLCBzdGF0ZS5mbG93aW5nKTtcbiAgd2hpbGUgKHN0YXRlLmZsb3dpbmcgJiYgc3RyZWFtLnJlYWQoKSAhPT0gbnVsbCkge31cbn1cblxuLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuXG4gIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKCd3cmFwcGVkIGVuZCcpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIF90aGlzLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIF90aGlzLnB1c2gobnVsbCk7XG4gIH0pO1xuXG4gIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGRlYnVnKCd3cmFwcGVkIGRhdGEnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcblxuICAgIC8vIGRvbid0IHNraXAgb3ZlciBmYWxzeSB2YWx1ZXMgaW4gb2JqZWN0TW9kZVxuICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlICYmIChjaHVuayA9PT0gbnVsbCB8fCBjaHVuayA9PT0gdW5kZWZpbmVkKSkgcmV0dXJuO2Vsc2UgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmICghY2h1bmsgfHwgIWNodW5rLmxlbmd0aCkpIHJldHVybjtcblxuICAgIHZhciByZXQgPSBfdGhpcy5wdXNoKGNodW5rKTtcbiAgICBpZiAoIXJldCkge1xuICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gcHJveHkgYWxsIHRoZSBvdGhlciBtZXRob2RzLlxuICAvLyBpbXBvcnRhbnQgd2hlbiB3cmFwcGluZyBmaWx0ZXJzIGFuZCBkdXBsZXhlcy5cbiAgZm9yICh2YXIgaSBpbiBzdHJlYW0pIHtcbiAgICBpZiAodGhpc1tpXSA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBzdHJlYW1baV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbaV0gPSBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH0oaSk7XG4gICAgfVxuICB9XG5cbiAgLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxuICBmb3IgKHZhciBuID0gMDsgbiA8IGtQcm94eUV2ZW50cy5sZW5ndGg7IG4rKykge1xuICAgIHN0cmVhbS5vbihrUHJveHlFdmVudHNbbl0sIHRoaXMuZW1pdC5iaW5kKHRoaXMsIGtQcm94eUV2ZW50c1tuXSkpO1xuICB9XG5cbiAgLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cbiAgdGhpcy5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgX3JlYWQnLCBuKTtcbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcblxuLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XG5cbi8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIC8vIG5vdGhpbmcgYnVmZmVyZWRcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgdmFyIHJldDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldCA9IHN0YXRlLmJ1ZmZlci5zaGlmdCgpO2Vsc2UgaWYgKCFuIHx8IG4gPj0gc3RhdGUubGVuZ3RoKSB7XG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBsaXN0XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIHJldCA9IHN0YXRlLmJ1ZmZlci5qb2luKCcnKTtlbHNlIGlmIChzdGF0ZS5idWZmZXIubGVuZ3RoID09PSAxKSByZXQgPSBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhO2Vsc2UgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbmNhdChzdGF0ZS5sZW5ndGgpO1xuICAgIHN0YXRlLmJ1ZmZlci5jbGVhcigpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQgcGFydCBvZiBsaXN0XG4gICAgcmV0ID0gZnJvbUxpc3RQYXJ0aWFsKG4sIHN0YXRlLmJ1ZmZlciwgc3RhdGUuZGVjb2Rlcik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBFeHRyYWN0cyBvbmx5IGVub3VnaCBidWZmZXJlZCBkYXRhIHRvIHNhdGlzZnkgdGhlIGFtb3VudCByZXF1ZXN0ZWQuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0UGFydGlhbChuLCBsaXN0LCBoYXNTdHJpbmdzKSB7XG4gIHZhciByZXQ7XG4gIGlmIChuIDwgbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gc2xpY2UgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3NcbiAgICByZXQgPSBsaXN0LmhlYWQuZGF0YS5zbGljZSgwLCBuKTtcbiAgICBsaXN0LmhlYWQuZGF0YSA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKG4pO1xuICB9IGVsc2UgaWYgKG4gPT09IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgIC8vIGZpcnN0IGNodW5rIGlzIGEgcGVyZmVjdCBtYXRjaFxuICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZXN1bHQgc3BhbnMgbW9yZSB0aGFuIG9uZSBidWZmZXJcbiAgICByZXQgPSBoYXNTdHJpbmdzID8gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkgOiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGNoYXJhY3RlcnMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhXG4vLyBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIHtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgdmFyIHJldCA9IHAuZGF0YTtcbiAgbiAtPSByZXQubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBzdHIgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IHN0ci5sZW5ndGggPyBzdHIubGVuZ3RoIDogbjtcbiAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHJldCArPSBzdHI7ZWxzZSByZXQgKz0gc3RyLnNsaWNlKDAsIG4pO1xuICAgIG4gLT0gbmI7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgICArK2M7XG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0LmhlYWQgPSBwO1xuICAgICAgICBwLmRhdGEgPSBzdHIuc2xpY2UobmIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICsrYztcbiAgfVxuICBsaXN0Lmxlbmd0aCAtPSBjO1xuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGJ5dGVzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YSBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpIHtcbiAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuKTtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgcC5kYXRhLmNvcHkocmV0KTtcbiAgbiAtPSBwLmRhdGEubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBidWYgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IGJ1Zi5sZW5ndGggPyBidWYubGVuZ3RoIDogbjtcbiAgICBidWYuY29weShyZXQsIHJldC5sZW5ndGggLSBuLCAwLCBuYik7XG4gICAgbiAtPSBuYjtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgaWYgKG5iID09PSBidWYubGVuZ3RoKSB7XG4gICAgICAgICsrYztcbiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3QuaGVhZCA9IHA7XG4gICAgICAgIHAuZGF0YSA9IGJ1Zi5zbGljZShuYik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgKytjO1xuICB9XG4gIGxpc3QubGVuZ3RoIC09IGM7XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gSWYgd2UgZ2V0IGhlcmUgYmVmb3JlIGNvbnN1bWluZyBhbGwgdGhlIGJ5dGVzLCB0aGVuIHRoYXQgaXMgYVxuICAvLyBidWcgaW4gbm9kZS4gIFNob3VsZCBuZXZlciBoYXBwZW4uXG4gIGlmIChzdGF0ZS5sZW5ndGggPiAwKSB0aHJvdyBuZXcgRXJyb3IoJ1wiZW5kUmVhZGFibGUoKVwiIGNhbGxlZCBvbiBub24tZW1wdHkgc3RyZWFtJyk7XG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIHBuYS5uZXh0VGljayhlbmRSZWFkYWJsZU5ULCBzdGF0ZSwgc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZU5UKHN0YXRlLCBzdHJlYW0pIHtcbiAgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kZXhPZih4cywgeCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmICh4c1tpXSA9PT0geCkgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIHRyYW5zZm9ybSBzdHJlYW0gaXMgYSByZWFkYWJsZS93cml0YWJsZSBzdHJlYW0gd2hlcmUgeW91IGRvXG4vLyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS4gIFNvbWV0aW1lcyBpdCdzIGNhbGxlZCBhIFwiZmlsdGVyXCIsXG4vLyBidXQgdGhhdCdzIG5vdCBhIGdyZWF0IG5hbWUgZm9yIGl0LCBzaW5jZSB0aGF0IGltcGxpZXMgYSB0aGluZyB3aGVyZVxuLy8gc29tZSBiaXRzIHBhc3MgdGhyb3VnaCwgYW5kIG90aGVycyBhcmUgc2ltcGx5IGlnbm9yZWQuICAoVGhhdCB3b3VsZFxuLy8gYmUgYSB2YWxpZCBleGFtcGxlIG9mIGEgdHJhbnNmb3JtLCBvZiBjb3Vyc2UuKVxuLy9cbi8vIFdoaWxlIHRoZSBvdXRwdXQgaXMgY2F1c2FsbHkgcmVsYXRlZCB0byB0aGUgaW5wdXQsIGl0J3Mgbm90IGFcbi8vIG5lY2Vzc2FyaWx5IHN5bW1ldHJpYyBvciBzeW5jaHJvbm91cyB0cmFuc2Zvcm1hdGlvbi4gIEZvciBleGFtcGxlLFxuLy8gYSB6bGliIHN0cmVhbSBtaWdodCB0YWtlIG11bHRpcGxlIHBsYWluLXRleHQgd3JpdGVzKCksIGFuZCB0aGVuXG4vLyBlbWl0IGEgc2luZ2xlIGNvbXByZXNzZWQgY2h1bmsgc29tZSB0aW1lIGluIHRoZSBmdXR1cmUuXG4vL1xuLy8gSGVyZSdzIGhvdyB0aGlzIHdvcmtzOlxuLy9cbi8vIFRoZSBUcmFuc2Zvcm0gc3RyZWFtIGhhcyBhbGwgdGhlIGFzcGVjdHMgb2YgdGhlIHJlYWRhYmxlIGFuZCB3cml0YWJsZVxuLy8gc3RyZWFtIGNsYXNzZXMuICBXaGVuIHlvdSB3cml0ZShjaHVuayksIHRoYXQgY2FsbHMgX3dyaXRlKGNodW5rLGNiKVxuLy8gaW50ZXJuYWxseSwgYW5kIHJldHVybnMgZmFsc2UgaWYgdGhlcmUncyBhIGxvdCBvZiBwZW5kaW5nIHdyaXRlc1xuLy8gYnVmZmVyZWQgdXAuICBXaGVuIHlvdSBjYWxsIHJlYWQoKSwgdGhhdCBjYWxscyBfcmVhZChuKSB1bnRpbFxuLy8gdGhlcmUncyBlbm91Z2ggcGVuZGluZyByZWFkYWJsZSBkYXRhIGJ1ZmZlcmVkIHVwLlxuLy9cbi8vIEluIGEgdHJhbnNmb3JtIHN0cmVhbSwgdGhlIHdyaXR0ZW4gZGF0YSBpcyBwbGFjZWQgaW4gYSBidWZmZXIuICBXaGVuXG4vLyBfcmVhZChuKSBpcyBjYWxsZWQsIGl0IHRyYW5zZm9ybXMgdGhlIHF1ZXVlZCB1cCBkYXRhLCBjYWxsaW5nIHRoZVxuLy8gYnVmZmVyZWQgX3dyaXRlIGNiJ3MgYXMgaXQgY29uc3VtZXMgY2h1bmtzLiAgSWYgY29uc3VtaW5nIGEgc2luZ2xlXG4vLyB3cml0dGVuIGNodW5rIHdvdWxkIHJlc3VsdCBpbiBtdWx0aXBsZSBvdXRwdXQgY2h1bmtzLCB0aGVuIHRoZSBmaXJzdFxuLy8gb3V0cHV0dGVkIGJpdCBjYWxscyB0aGUgcmVhZGNiLCBhbmQgc3Vic2VxdWVudCBjaHVua3MganVzdCBnbyBpbnRvXG4vLyB0aGUgcmVhZCBidWZmZXIsIGFuZCB3aWxsIGNhdXNlIGl0IHRvIGVtaXQgJ3JlYWRhYmxlJyBpZiBuZWNlc3NhcnkuXG4vL1xuLy8gVGhpcyB3YXksIGJhY2stcHJlc3N1cmUgaXMgYWN0dWFsbHkgZGV0ZXJtaW5lZCBieSB0aGUgcmVhZGluZyBzaWRlLFxuLy8gc2luY2UgX3JlYWQgaGFzIHRvIGJlIGNhbGxlZCB0byBzdGFydCBwcm9jZXNzaW5nIGEgbmV3IGNodW5rLiAgSG93ZXZlcixcbi8vIGEgcGF0aG9sb2dpY2FsIGluZmxhdGUgdHlwZSBvZiB0cmFuc2Zvcm0gY2FuIGNhdXNlIGV4Y2Vzc2l2ZSBidWZmZXJpbmdcbi8vIGhlcmUuICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBhIHN0cmVhbSB3aGVyZSBldmVyeSBieXRlIG9mIGlucHV0IGlzXG4vLyBpbnRlcnByZXRlZCBhcyBhbiBpbnRlZ2VyIGZyb20gMC0yNTUsIGFuZCB0aGVuIHJlc3VsdHMgaW4gdGhhdCBtYW55XG4vLyBieXRlcyBvZiBvdXRwdXQuICBXcml0aW5nIHRoZSA0IGJ5dGVzIHtmZixmZixmZixmZn0gd291bGQgcmVzdWx0IGluXG4vLyAxa2Igb2YgZGF0YSBiZWluZyBvdXRwdXQuICBJbiB0aGlzIGNhc2UsIHlvdSBjb3VsZCB3cml0ZSBhIHZlcnkgc21hbGxcbi8vIGFtb3VudCBvZiBpbnB1dCwgYW5kIGVuZCB1cCB3aXRoIGEgdmVyeSBsYXJnZSBhbW91bnQgb2Ygb3V0cHV0LiAgSW5cbi8vIHN1Y2ggYSBwYXRob2xvZ2ljYWwgaW5mbGF0aW5nIG1lY2hhbmlzbSwgdGhlcmUnZCBiZSBubyB3YXkgdG8gdGVsbFxuLy8gdGhlIHN5c3RlbSB0byBzdG9wIGRvaW5nIHRoZSB0cmFuc2Zvcm0uICBBIHNpbmdsZSA0TUIgd3JpdGUgY291bGRcbi8vIGNhdXNlIHRoZSBzeXN0ZW0gdG8gcnVuIG91dCBvZiBtZW1vcnkuXG4vL1xuLy8gSG93ZXZlciwgZXZlbiBpbiBzdWNoIGEgcGF0aG9sb2dpY2FsIGNhc2UsIG9ubHkgYSBzaW5nbGUgd3JpdHRlbiBjaHVua1xuLy8gd291bGQgYmUgY29uc3VtZWQsIGFuZCB0aGVuIHRoZSByZXN0IHdvdWxkIHdhaXQgKHVuLXRyYW5zZm9ybWVkKSB1bnRpbFxuLy8gdGhlIHJlc3VsdHMgb2YgdGhlIHByZXZpb3VzIHRyYW5zZm9ybWVkIGNodW5rIHdlcmUgY29uc3VtZWQuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07XG5cbnZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhUcmFuc2Zvcm0sIER1cGxleCk7XG5cbmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKGVyLCBkYXRhKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcblxuICB2YXIgY2IgPSB0cy53cml0ZWNiO1xuXG4gIGlmICghY2IpIHtcbiAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignd3JpdGUgY2FsbGJhY2sgY2FsbGVkIG11bHRpcGxlIHRpbWVzJykpO1xuICB9XG5cbiAgdHMud3JpdGVjaHVuayA9IG51bGw7XG4gIHRzLndyaXRlY2IgPSBudWxsO1xuXG4gIGlmIChkYXRhICE9IG51bGwpIC8vIHNpbmdsZSBlcXVhbHMgY2hlY2sgZm9yIGJvdGggYG51bGxgIGFuZCBgdW5kZWZpbmVkYFxuICAgIHRoaXMucHVzaChkYXRhKTtcblxuICBjYihlcik7XG5cbiAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgcnMucmVhZGluZyA9IGZhbHNlO1xuICBpZiAocnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHtcbiAgICB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKSByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKTtcblxuICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZSA9IHtcbiAgICBhZnRlclRyYW5zZm9ybTogYWZ0ZXJUcmFuc2Zvcm0uYmluZCh0aGlzKSxcbiAgICBuZWVkVHJhbnNmb3JtOiBmYWxzZSxcbiAgICB0cmFuc2Zvcm1pbmc6IGZhbHNlLFxuICAgIHdyaXRlY2I6IG51bGwsXG4gICAgd3JpdGVjaHVuazogbnVsbCxcbiAgICB3cml0ZWVuY29kaW5nOiBudWxsXG4gIH07XG5cbiAgLy8gc3RhcnQgb3V0IGFza2luZyBmb3IgYSByZWFkYWJsZSBldmVudCBvbmNlIGRhdGEgaXMgdHJhbnNmb3JtZWQuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAvLyB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSBfcmVhZCBtZXRob2QsIGFuZCBkb25lIHRoZSBvdGhlciB0aGluZ3NcbiAgLy8gdGhhdCBSZWFkYWJsZSB3YW50cyBiZWZvcmUgdGhlIGZpcnN0IF9yZWFkIGNhbGwsIHNvIHVuc2V0IHRoZVxuICAvLyBzeW5jIGd1YXJkIGZsYWcuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuc3luYyA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fdHJhbnNmb3JtID0gb3B0aW9ucy50cmFuc2Zvcm07XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmx1c2ggPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZsdXNoID0gb3B0aW9ucy5mbHVzaDtcbiAgfVxuXG4gIC8vIFdoZW4gdGhlIHdyaXRhYmxlIHNpZGUgZmluaXNoZXMsIHRoZW4gZmx1c2ggb3V0IGFueXRoaW5nIHJlbWFpbmluZy5cbiAgdGhpcy5vbigncHJlZmluaXNoJywgcHJlZmluaXNoKTtcbn1cblxuZnVuY3Rpb24gcHJlZmluaXNoKCkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIGlmICh0eXBlb2YgdGhpcy5fZmx1c2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLl9mbHVzaChmdW5jdGlvbiAoZXIsIGRhdGEpIHtcbiAgICAgIGRvbmUoX3RoaXMsIGVyLCBkYXRhKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBkb25lKHRoaXMsIG51bGwsIG51bGwpO1xuICB9XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICByZXR1cm4gRHVwbGV4LnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGVuY29kaW5nKTtcbn07XG5cbi8vIFRoaXMgaXMgdGhlIHBhcnQgd2hlcmUgeW91IGRvIHN0dWZmIVxuLy8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBpbiBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gJ2NodW5rJyBpcyBhbiBpbnB1dCBjaHVuay5cbi8vXG4vLyBDYWxsIGBwdXNoKG5ld0NodW5rKWAgdG8gcGFzcyBhbG9uZyB0cmFuc2Zvcm1lZCBvdXRwdXRcbi8vIHRvIHRoZSByZWFkYWJsZSBzaWRlLiAgWW91IG1heSBjYWxsICdwdXNoJyB6ZXJvIG9yIG1vcmUgdGltZXMuXG4vL1xuLy8gQ2FsbCBgY2IoZXJyKWAgd2hlbiB5b3UgYXJlIGRvbmUgd2l0aCB0aGlzIGNodW5rLiAgSWYgeW91IHBhc3Ncbi8vIGFuIGVycm9yLCB0aGVuIHRoYXQnbGwgcHV0IHRoZSBodXJ0IG9uIHRoZSB3aG9sZSBvcGVyYXRpb24uICBJZiB5b3Vcbi8vIG5ldmVyIGNhbGwgY2IoKSwgdGhlbiB5b3UnbGwgbmV2ZXIgZ2V0IGFub3RoZXIgY2h1bmsuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aHJvdyBuZXcgRXJyb3IoJ190cmFuc2Zvcm0oKSBpcyBub3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLndyaXRlY2IgPSBjYjtcbiAgdHMud3JpdGVjaHVuayA9IGNodW5rO1xuICB0cy53cml0ZWVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIGlmICghdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fCBycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufTtcblxuLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgYXJncyBhcmUgaGVyZS5cbi8vIF90cmFuc2Zvcm0gZG9lcyBhbGwgdGhlIHdvcmsuXG4vLyBUaGF0IHdlIGdvdCBoZXJlIG1lYW5zIHRoYXQgdGhlIHJlYWRhYmxlIHNpZGUgd2FudHMgbW9yZSBkYXRhLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh0cy53cml0ZWNodW5rICE9PSBudWxsICYmIHRzLndyaXRlY2IgJiYgIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHRzLnRyYW5zZm9ybWluZyA9IHRydWU7XG4gICAgdGhpcy5fdHJhbnNmb3JtKHRzLndyaXRlY2h1bmssIHRzLndyaXRlZW5jb2RpbmcsIHRzLmFmdGVyVHJhbnNmb3JtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBtYXJrIHRoYXQgd2UgbmVlZCBhIHRyYW5zZm9ybSwgc28gdGhhdCBhbnkgZGF0YSB0aGF0IGNvbWVzIGluXG4gICAgLy8gd2lsbCBnZXQgcHJvY2Vzc2VkLCBub3cgdGhhdCB3ZSd2ZSBhc2tlZCBmb3IgaXQuXG4gICAgdHMubmVlZFRyYW5zZm9ybSA9IHRydWU7XG4gIH1cbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB2YXIgX3RoaXMyID0gdGhpcztcblxuICBEdXBsZXgucHJvdG90eXBlLl9kZXN0cm95LmNhbGwodGhpcywgZXJyLCBmdW5jdGlvbiAoZXJyMikge1xuICAgIGNiKGVycjIpO1xuICAgIF90aGlzMi5lbWl0KCdjbG9zZScpO1xuICB9KTtcbn07XG5cbmZ1bmN0aW9uIGRvbmUoc3RyZWFtLCBlciwgZGF0YSkge1xuICBpZiAoZXIpIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG5cbiAgaWYgKGRhdGEgIT0gbnVsbCkgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICAgc3RyZWFtLnB1c2goZGF0YSk7XG5cbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcbiAgaWYgKHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHdzLmxlbmd0aCAhPSAwJyk7XG5cbiAgaWYgKHN0cmVhbS5fdHJhbnNmb3JtU3RhdGUudHJhbnNmb3JtaW5nKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiBzdGlsbCB0cmFuc2Zvcm1pbmcnKTtcblxuICByZXR1cm4gc3RyZWFtLnB1c2gobnVsbCk7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsXG4vLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuXG4vKiA8cmVwbGFjZW1lbnQ+ICovXG5mdW5jdGlvbiBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRoaXMuY2h1bmsgPSBjaHVuaztcbiAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICB0aGlzLmNhbGxiYWNrID0gY2I7XG4gIHRoaXMubmV4dCA9IG51bGw7XG59XG5cbi8vIEl0IHNlZW1zIGEgbGlua2VkIGxpc3QgYnV0IGl0IGlzIG5vdFxuLy8gdGhlcmUgd2lsbCBiZSBvbmx5IDIgb2YgdGhlc2UgZm9yIGVhY2ggc3RyZWFtXG5mdW5jdGlvbiBDb3JrZWRSZXF1ZXN0KHN0YXRlKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgdGhpcy5lbnRyeSA9IG51bGw7XG4gIHRoaXMuZmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgIG9uQ29ya2VkRmluaXNoKF90aGlzLCBzdGF0ZSk7XG4gIH07XG59XG4vKiA8L3JlcGxhY2VtZW50PiAqL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGFzeW5jV3JpdGUgPSAhcHJvY2Vzcy5icm93c2VyICYmIFsndjAuMTAnLCAndjAuOS4nXS5pbmRleE9mKHByb2Nlc3MudmVyc2lvbi5zbGljZSgwLCA1KSkgPiAtMSA/IHNldEltbWVkaWF0ZSA6IHBuYS5uZXh0VGljaztcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGludGVybmFsVXRpbCA9IHtcbiAgZGVwcmVjYXRlOiByZXF1aXJlKCd1dGlsLWRlcHJlY2F0ZScpXG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciBPdXJVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XG59XG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cblxuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XG5cbnV0aWwuaW5oZXJpdHMoV3JpdGFibGUsIFN0cmVhbSk7XG5cbmZ1bmN0aW9uIG5vcCgpIHt9XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0uXG4gIC8vIFRoZXNlIG9wdGlvbnMgY2FuIGJlIHByb3ZpZGVkIHNlcGFyYXRlbHkgYXMgcmVhZGFibGVYWFggYW5kIHdyaXRhYmxlWFhYLlxuICB2YXIgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoaXMgc3RyZWFtXG4gIC8vIGNvbnRhaW5zIGJ1ZmZlcnMgb3Igb2JqZWN0cy5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIHdyaXRhYmxlSHdtID0gb3B0aW9ucy53cml0YWJsZUhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG5cbiAgaWYgKGh3bSB8fCBod20gPT09IDApIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bTtlbHNlIGlmIChpc0R1cGxleCAmJiAod3JpdGFibGVId20gfHwgd3JpdGFibGVId20gPT09IDApKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSB3cml0YWJsZUh3bTtlbHNlIHRoaXMuaGlnaFdhdGVyTWFyayA9IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBNYXRoLmZsb29yKHRoaXMuaGlnaFdhdGVyTWFyayk7XG5cbiAgLy8gaWYgX2ZpbmFsIGhhcyBiZWVuIGNhbGxlZFxuICB0aGlzLmZpbmFsQ2FsbGVkID0gZmFsc2U7XG5cbiAgLy8gZHJhaW4gZXZlbnQgZmxhZy5cbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcbiAgdGhpcy5lbmRpbmcgPSBmYWxzZTtcbiAgLy8gd2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZFxuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xuICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cbiAgdGhpcy5sZW5ndGggPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG4gIHRoaXMud3JpdGluZyA9IGZhbHNlO1xuXG4gIC8vIHdoZW4gdHJ1ZSBhbGwgd3JpdGVzIHdpbGwgYmUgYnVmZmVyZWQgdW50aWwgLnVuY29yaygpIGNhbGxcbiAgdGhpcy5jb3JrZWQgPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG4gIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcbiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24gKGVyKSB7XG4gICAgb253cml0ZShzdHJlYW0sIGVyKTtcbiAgfTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCB0aGUgdXNlciBzdXBwbGllcyB0byB3cml0ZShjaHVuayxlbmNvZGluZyxjYilcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcblxuICAvLyB0aGUgYW1vdW50IHRoYXQgaXMgYmVpbmcgd3JpdHRlbiB3aGVuIF93cml0ZSBpcyBjYWxsZWQuXG4gIHRoaXMud3JpdGVsZW4gPSAwO1xuXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgdGhpcy5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcblxuICAvLyBudW1iZXIgb2YgcGVuZGluZyB1c2VyLXN1cHBsaWVkIHdyaXRlIGNhbGxiYWNrc1xuICAvLyB0aGlzIG11c3QgYmUgMCBiZWZvcmUgJ2ZpbmlzaCcgY2FuIGJlIGVtaXR0ZWRcbiAgdGhpcy5wZW5kaW5nY2IgPSAwO1xuXG4gIC8vIGVtaXQgcHJlZmluaXNoIGlmIHRoZSBvbmx5IHRoaW5nIHdlJ3JlIHdhaXRpbmcgZm9yIGlzIF93cml0ZSBjYnNcbiAgLy8gVGhpcyBpcyByZWxldmFudCBmb3Igc3luY2hyb25vdXMgVHJhbnNmb3JtIHN0cmVhbXNcbiAgdGhpcy5wcmVmaW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluXG4gIHRoaXMuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG5cbiAgLy8gY291bnQgYnVmZmVyZWQgcmVxdWVzdHNcbiAgdGhpcy5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG5cbiAgLy8gYWxsb2NhdGUgdGhlIGZpcnN0IENvcmtlZFJlcXVlc3QsIHRoZXJlIGlzIGFsd2F5c1xuICAvLyBvbmUgYWxsb2NhdGVkIGFuZCBmcmVlIHRvIHVzZSwgYW5kIHdlIG1haW50YWluIGF0IG1vc3QgdHdvXG4gIHRoaXMuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3QodGhpcyk7XG59XG5cbldyaXRhYmxlU3RhdGUucHJvdG90eXBlLmdldEJ1ZmZlciA9IGZ1bmN0aW9uIGdldEJ1ZmZlcigpIHtcbiAgdmFyIGN1cnJlbnQgPSB0aGlzLmJ1ZmZlcmVkUmVxdWVzdDtcbiAgdmFyIG91dCA9IFtdO1xuICB3aGlsZSAoY3VycmVudCkge1xuICAgIG91dC5wdXNoKGN1cnJlbnQpO1xuICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5cbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlU3RhdGUucHJvdG90eXBlLCAnYnVmZmVyJywge1xuICAgICAgZ2V0OiBpbnRlcm5hbFV0aWwuZGVwcmVjYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyKCk7XG4gICAgICB9LCAnX3dyaXRhYmxlU3RhdGUuYnVmZmVyIGlzIGRlcHJlY2F0ZWQuIFVzZSBfd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIgJyArICdpbnN0ZWFkLicsICdERVAwMDAzJylcbiAgICB9KTtcbiAgfSBjYXRjaCAoXykge31cbn0pKCk7XG5cbi8vIFRlc3QgX3dyaXRhYmxlU3RhdGUgZm9yIGluaGVyaXRhbmNlIHRvIGFjY291bnQgZm9yIER1cGxleCBzdHJlYW1zLFxuLy8gd2hvc2UgcHJvdG90eXBlIGNoYWluIG9ubHkgcG9pbnRzIHRvIFJlYWRhYmxlLlxudmFyIHJlYWxIYXNJbnN0YW5jZTtcbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5oYXNJbnN0YW5jZSAmJiB0eXBlb2YgRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZSwgU3ltYm9sLmhhc0luc3RhbmNlLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIGlmIChyZWFsSGFzSW5zdGFuY2UuY2FsbCh0aGlzLCBvYmplY3QpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmICh0aGlzICE9PSBXcml0YWJsZSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICByZXR1cm4gb2JqZWN0ICYmIG9iamVjdC5fd3JpdGFibGVTdGF0ZSBpbnN0YW5jZW9mIFdyaXRhYmxlU3RhdGU7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgdGhpcztcbiAgfTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIC8vIFdyaXRhYmxlIGN0b3IgaXMgYXBwbGllZCB0byBEdXBsZXhlcywgdG9vLlxuICAvLyBgcmVhbEhhc0luc3RhbmNlYCBpcyBuZWNlc3NhcnkgYmVjYXVzZSB1c2luZyBwbGFpbiBgaW5zdGFuY2VvZmBcbiAgLy8gd291bGQgcmV0dXJuIGZhbHNlLCBhcyBubyBgX3dyaXRhYmxlU3RhdGVgIHByb3BlcnR5IGlzIGF0dGFjaGVkLlxuXG4gIC8vIFRyeWluZyB0byB1c2UgdGhlIGN1c3RvbSBgaW5zdGFuY2VvZmAgZm9yIFdyaXRhYmxlIGhlcmUgd2lsbCBhbHNvIGJyZWFrIHRoZVxuICAvLyBOb2RlLmpzIExhenlUcmFuc2Zvcm0gaW1wbGVtZW50YXRpb24sIHdoaWNoIGhhcyBhIG5vbi10cml2aWFsIGdldHRlciBmb3JcbiAgLy8gYF93cml0YWJsZVN0YXRlYCB0aGF0IHdvdWxkIGxlYWQgdG8gaW5maW5pdGUgcmVjdXJzaW9uLlxuICBpZiAoIXJlYWxIYXNJbnN0YW5jZS5jYWxsKFdyaXRhYmxlLCB0aGlzKSAmJiAhKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSB7XG4gICAgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcbiAgfVxuXG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUgPSBuZXcgV3JpdGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3kuXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRlID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZSA9IG9wdGlvbnMud3JpdGU7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGV2ID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZXYgPSBvcHRpb25zLndyaXRldjtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZpbmFsID09PSAnZnVuY3Rpb24nKSB0aGlzLl9maW5hbCA9IG9wdGlvbnMuZmluYWw7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0Nhbm5vdCBwaXBlLCBub3QgcmVhZGFibGUnKSk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgY2IpIHtcbiAgdmFyIGVyID0gbmV3IEVycm9yKCd3cml0ZSBhZnRlciBlbmQnKTtcbiAgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICBwbmEubmV4dFRpY2soY2IsIGVyKTtcbn1cblxuLy8gQ2hlY2tzIHRoYXQgYSB1c2VyLXN1cHBsaWVkIGNodW5rIGlzIHZhbGlkLCBlc3BlY2lhbGx5IGZvciB0aGUgcGFydGljdWxhclxuLy8gbW9kZSB0aGUgc3RyZWFtIGlzIGluLiBDdXJyZW50bHkgdGhpcyBtZWFucyB0aGF0IGBudWxsYCBpcyBuZXZlciBhY2NlcHRlZFxuLy8gYW5kIHVuZGVmaW5lZC9ub24tc3RyaW5nIHZhbHVlcyBhcmUgb25seSBhbGxvd2VkIGluIG9iamVjdCBtb2RlLlxuZnVuY3Rpb24gdmFsaWRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgY2IpIHtcbiAgdmFyIHZhbGlkID0gdHJ1ZTtcbiAgdmFyIGVyID0gZmFsc2U7XG5cbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdNYXkgbm90IHdyaXRlIG51bGwgdmFsdWVzIHRvIHN0cmVhbScpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIGlmIChlcikge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICBwbmEubmV4dFRpY2soY2IsIGVyKTtcbiAgICB2YWxpZCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWxpZDtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJldCA9IGZhbHNlO1xuICB2YXIgaXNCdWYgPSAhc3RhdGUub2JqZWN0TW9kZSAmJiBfaXNVaW50OEFycmF5KGNodW5rKTtcblxuICBpZiAoaXNCdWYgJiYgIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpIHtcbiAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGlzQnVmKSBlbmNvZGluZyA9ICdidWZmZXInO2Vsc2UgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG5cbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgY2IgPSBub3A7XG5cbiAgaWYgKHN0YXRlLmVuZGVkKSB3cml0ZUFmdGVyRW5kKHRoaXMsIGNiKTtlbHNlIGlmIChpc0J1ZiB8fCB2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIHN0YXRlLmNvcmtlZCsrO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkLS07XG5cbiAgICBpZiAoIXN0YXRlLndyaXRpbmcgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSBjbGVhckJ1ZmZlcih0aGlzLCBzdGF0ZSk7XG4gIH1cbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5zZXREZWZhdWx0RW5jb2RpbmcgPSBmdW5jdGlvbiBzZXREZWZhdWx0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgLy8gbm9kZTo6UGFyc2VFbmNvZGluZygpIHJlcXVpcmVzIGxvd2VyIGNhc2UuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSBlbmNvZGluZyA9IGVuY29kaW5nLnRvTG93ZXJDYXNlKCk7XG4gIGlmICghKFsnaGV4JywgJ3V0ZjgnLCAndXRmLTgnLCAnYXNjaWknLCAnYmluYXJ5JywgJ2Jhc2U2NCcsICd1Y3MyJywgJ3Vjcy0yJywgJ3V0ZjE2bGUnLCAndXRmLTE2bGUnLCAncmF3J10uaW5kZXhPZigoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKSkgPiAtMSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVmYXVsdEVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgfVxuICByZXR1cm4gY2h1bms7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuXG4vLyBpZiB3ZSdyZSBhbHJlYWR5IHdyaXRpbmcgc29tZXRoaW5nLCB0aGVuIGp1c3QgcHV0IHRoaXNcbi8vIGluIHRoZSBxdWV1ZSwgYW5kIHdhaXQgb3VyIHR1cm4uICBPdGhlcndpc2UsIGNhbGwgX3dyaXRlXG4vLyBJZiB3ZSByZXR1cm4gZmFsc2UsIHRoZW4gd2UgbmVlZCBhIGRyYWluIGV2ZW50LCBzbyBzZXQgdGhhdCBmbGFnLlxuZnVuY3Rpb24gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBpZiAoIWlzQnVmKSB7XG4gICAgdmFyIG5ld0NodW5rID0gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZyk7XG4gICAgaWYgKGNodW5rICE9PSBuZXdDaHVuaykge1xuICAgICAgaXNCdWYgPSB0cnVlO1xuICAgICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgICAgIGNodW5rID0gbmV3Q2h1bms7XG4gICAgfVxuICB9XG4gIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICBzdGF0ZS5sZW5ndGggKz0gbGVuO1xuXG4gIHZhciByZXQgPSBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICAvLyB3ZSBtdXN0IGVuc3VyZSB0aGF0IHByZXZpb3VzIG5lZWREcmFpbiB3aWxsIG5vdCBiZSByZXNldCB0byBmYWxzZS5cbiAgaWYgKCFyZXQpIHN0YXRlLm5lZWREcmFpbiA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLndyaXRpbmcgfHwgc3RhdGUuY29ya2VkKSB7XG4gICAgdmFyIGxhc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSB7XG4gICAgICBjaHVuazogY2h1bmssXG4gICAgICBlbmNvZGluZzogZW5jb2RpbmcsXG4gICAgICBpc0J1ZjogaXNCdWYsXG4gICAgICBjYWxsYmFjazogY2IsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcbiAgICBpZiAobGFzdCkge1xuICAgICAgbGFzdC5uZXh0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9XG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgKz0gMTtcbiAgfSBlbHNlIHtcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBzdGF0ZS53cml0ZWxlbiA9IGxlbjtcbiAgc3RhdGUud3JpdGVjYiA9IGNiO1xuICBzdGF0ZS53cml0aW5nID0gdHJ1ZTtcbiAgc3RhdGUuc3luYyA9IHRydWU7XG4gIGlmICh3cml0ZXYpIHN0cmVhbS5fd3JpdGV2KGNodW5rLCBzdGF0ZS5vbndyaXRlKTtlbHNlIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKTtcbiAgc3RhdGUuc3luYyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKSB7XG4gIC0tc3RhdGUucGVuZGluZ2NiO1xuXG4gIGlmIChzeW5jKSB7XG4gICAgLy8gZGVmZXIgdGhlIGNhbGxiYWNrIGlmIHdlIGFyZSBiZWluZyBjYWxsZWQgc3luY2hyb25vdXNseVxuICAgIC8vIHRvIGF2b2lkIHBpbGluZyB1cCB0aGluZ3Mgb24gdGhlIHN0YWNrXG4gICAgcG5hLm5leHRUaWNrKGNiLCBlcik7XG4gICAgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGFuZCBpdCB3aWxsIGFsd2F5cyBoYXBwZW5cbiAgICAvLyBhZnRlciBlcnJvclxuICAgIHBuYS5uZXh0VGljayhmaW5pc2hNYXliZSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9IGVsc2Uge1xuICAgIC8vIHRoZSBjYWxsZXIgZXhwZWN0IHRoaXMgdG8gaGFwcGVuIGJlZm9yZSBpZlxuICAgIC8vIGl0IGlzIGFzeW5jXG4gICAgY2IoZXIpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYnV0IGZpbmlzaCBtdXN0XG4gICAgLy8gYWx3YXlzIGZvbGxvdyBlcnJvclxuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkge1xuICBzdGF0ZS53cml0aW5nID0gZmFsc2U7XG4gIHN0YXRlLndyaXRlY2IgPSBudWxsO1xuICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47XG4gIHN0YXRlLndyaXRlbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gb253cml0ZShzdHJlYW0sIGVyKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jO1xuICB2YXIgY2IgPSBzdGF0ZS53cml0ZWNiO1xuXG4gIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSk7XG5cbiAgaWYgKGVyKSBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKTtlbHNlIHtcbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBhY3R1YWxseSByZWFkeSB0byBmaW5pc2gsIGJ1dCBkb24ndCBlbWl0IHlldFxuICAgIHZhciBmaW5pc2hlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuXG4gICAgaWYgKCFmaW5pc2hlZCAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkge1xuICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIC8qPHJlcGxhY2VtZW50PiovXG4gICAgICBhc3luY1dyaXRlKGFmdGVyV3JpdGUsIHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgICAvKjwvcmVwbGFjZW1lbnQ+Ki9cbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYikge1xuICBpZiAoIWZpbmlzaGVkKSBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSk7XG4gIHN0YXRlLnBlbmRpbmdjYi0tO1xuICBjYigpO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuLy8gTXVzdCBmb3JjZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gbmV4dFRpY2ssIHNvIHRoYXQgd2UgZG9uJ3Rcbi8vIGVtaXQgJ2RyYWluJyBiZWZvcmUgdGhlIHdyaXRlKCkgY29uc3VtZXIgZ2V0cyB0aGUgJ2ZhbHNlJyByZXR1cm5cbi8vIHZhbHVlLCBhbmQgaGFzIGEgY2hhbmNlIHRvIGF0dGFjaCBhICdkcmFpbicgbGlzdGVuZXIuXG5mdW5jdGlvbiBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpbikge1xuICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpO1xuICB9XG59XG5cbi8vIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBwcm9jZXNzIGl0XG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlO1xuICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3Q7XG5cbiAgaWYgKHN0cmVhbS5fd3JpdGV2ICYmIGVudHJ5ICYmIGVudHJ5Lm5leHQpIHtcbiAgICAvLyBGYXN0IGNhc2UsIHdyaXRlIGV2ZXJ5dGhpbmcgdXNpbmcgX3dyaXRldigpXG4gICAgdmFyIGwgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudDtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KGwpO1xuICAgIHZhciBob2xkZXIgPSBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWU7XG4gICAgaG9sZGVyLmVudHJ5ID0gZW50cnk7XG5cbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHZhciBhbGxCdWZmZXJzID0gdHJ1ZTtcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIGJ1ZmZlcltjb3VudF0gPSBlbnRyeTtcbiAgICAgIGlmICghZW50cnkuaXNCdWYpIGFsbEJ1ZmZlcnMgPSBmYWxzZTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgfVxuICAgIGJ1ZmZlci5hbGxCdWZmZXJzID0gYWxsQnVmZmVycztcblxuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgdHJ1ZSwgc3RhdGUubGVuZ3RoLCBidWZmZXIsICcnLCBob2xkZXIuZmluaXNoKTtcblxuICAgIC8vIGRvV3JpdGUgaXMgYWxtb3N0IGFsd2F5cyBhc3luYywgZGVmZXIgdGhlc2UgdG8gc2F2ZSBhIGJpdCBvZiB0aW1lXG4gICAgLy8gYXMgdGhlIGhvdCBwYXRoIGVuZHMgd2l0aCBkb1dyaXRlXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gICAgaWYgKGhvbGRlci5uZXh0KSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBob2xkZXIubmV4dDtcbiAgICAgIGhvbGRlci5uZXh0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3Qoc3RhdGUpO1xuICAgIH1cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gU2xvdyBjYXNlLCB3cml0ZSBjaHVua3Mgb25lLWJ5LW9uZVxuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgdmFyIGNodW5rID0gZW50cnkuY2h1bms7XG4gICAgICB2YXIgZW5jb2RpbmcgPSBlbnRyeS5lbmNvZGluZztcbiAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgICAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQtLTtcbiAgICAgIC8vIGlmIHdlIGRpZG4ndCBjYWxsIHRoZSBvbndyaXRlIGltbWVkaWF0ZWx5LCB0aGVuXG4gICAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxuICAgICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxuICAgICAgLy8gYmVpbmcgcHJvY2Vzc2VkLCBzbyBtb3ZlIHRoZSBidWZmZXIgY291bnRlciBwYXN0IHRoZW0uXG4gICAgICBpZiAoc3RhdGUud3JpdGluZykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZW50cnkgPT09IG51bGwpIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB9XG5cbiAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gZW50cnk7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFcnJvcignX3dyaXRlKCkgaXMgbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBjaHVuaztcbiAgICBjaHVuayA9IG51bGw7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQpIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTtcblxuICAvLyAuZW5kKCkgZnVsbHkgdW5jb3Jrc1xuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkID0gMTtcbiAgICB0aGlzLnVuY29yaygpO1xuICB9XG5cbiAgLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuICBpZiAoIXN0YXRlLmVuZGluZyAmJiAhc3RhdGUuZmluaXNoZWQpIGVuZFdyaXRhYmxlKHRoaXMsIHN0YXRlLCBjYik7XG59O1xuXG5mdW5jdGlvbiBuZWVkRmluaXNoKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5lbmRpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9PT0gbnVsbCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLndyaXRpbmc7XG59XG5mdW5jdGlvbiBjYWxsRmluYWwoc3RyZWFtLCBzdGF0ZSkge1xuICBzdHJlYW0uX2ZpbmFsKGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgIH1cbiAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucHJlZmluaXNoZWQgJiYgIXN0YXRlLmZpbmFsQ2FsbGVkKSB7XG4gICAgaWYgKHR5cGVvZiBzdHJlYW0uX2ZpbmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICAgIHN0YXRlLmZpbmFsQ2FsbGVkID0gdHJ1ZTtcbiAgICAgIHBuYS5uZXh0VGljayhjYWxsRmluYWwsIHN0cmVhbSwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG5lZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcbiAgaWYgKG5lZWQpIHtcbiAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkge1xuICAgICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmVlZDtcbn1cblxuZnVuY3Rpb24gZW5kV3JpdGFibGUoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgc3RhdGUuZW5kaW5nID0gdHJ1ZTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIGlmIChjYikge1xuICAgIGlmIChzdGF0ZS5maW5pc2hlZCkgcG5hLm5leHRUaWNrKGNiKTtlbHNlIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICBzdHJlYW0ud3JpdGFibGUgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb25Db3JrZWRGaW5pc2goY29ya1JlcSwgc3RhdGUsIGVycikge1xuICB2YXIgZW50cnkgPSBjb3JrUmVxLmVudHJ5O1xuICBjb3JrUmVxLmVudHJ5ID0gbnVsbDtcbiAgd2hpbGUgKGVudHJ5KSB7XG4gICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgY2IoZXJyKTtcbiAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gIH1cbiAgaWYgKHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSkge1xuICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZS5uZXh0ID0gY29ya1JlcTtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBjb3JrUmVxO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcbldyaXRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuV3JpdGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdGhpcy5lbmQoKTtcbiAgY2IoZXJyKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuZnVuY3Rpb24gY29weUJ1ZmZlcihzcmMsIHRhcmdldCwgb2Zmc2V0KSB7XG4gIHNyYy5jb3B5KHRhcmdldCwgb2Zmc2V0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJ1ZmZlckxpc3QoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJ1ZmZlckxpc3QpO1xuXG4gICAgdGhpcy5oZWFkID0gbnVsbDtcbiAgICB0aGlzLnRhaWwgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgfVxuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoKHYpIHtcbiAgICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IG51bGwgfTtcbiAgICBpZiAodGhpcy5sZW5ndGggPiAwKSB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O2Vsc2UgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgdGhpcy50YWlsID0gZW50cnk7XG4gICAgKyt0aGlzLmxlbmd0aDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gdW5zaGlmdCh2KSB7XG4gICAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiB0aGlzLmhlYWQgfTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgICsrdGhpcy5sZW5ndGg7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiBzaGlmdCgpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICB2YXIgcmV0ID0gdGhpcy5oZWFkLmRhdGE7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO2Vsc2UgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQ7XG4gICAgLS10aGlzLmxlbmd0aDtcbiAgICByZXR1cm4gcmV0O1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uIGpvaW4ocykge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgIHZhciByZXQgPSAnJyArIHAuZGF0YTtcbiAgICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgICAgcmV0ICs9IHMgKyBwLmRhdGE7XG4gICAgfXJldHVybiByZXQ7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0KG4pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSByZXR1cm4gdGhpcy5oZWFkLmRhdGE7XG4gICAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuID4+PiAwKTtcbiAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKHApIHtcbiAgICAgIGNvcHlCdWZmZXIocC5kYXRhLCByZXQsIGkpO1xuICAgICAgaSArPSBwLmRhdGEubGVuZ3RoO1xuICAgICAgcCA9IHAubmV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICByZXR1cm4gQnVmZmVyTGlzdDtcbn0oKTtcblxuaWYgKHV0aWwgJiYgdXRpbC5pbnNwZWN0ICYmIHV0aWwuaW5zcGVjdC5jdXN0b20pIHtcbiAgbW9kdWxlLmV4cG9ydHMucHJvdG90eXBlW3V0aWwuaW5zcGVjdC5jdXN0b21dID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYmogPSB1dGlsLmluc3BlY3QoeyBsZW5ndGg6IHRoaXMubGVuZ3RoIH0pO1xuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgKyAnICcgKyBvYmo7XG4gIH07XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vLyB1bmRvY3VtZW50ZWQgY2IoKSBBUEksIG5lZWRlZCBmb3IgY29yZSwgbm90IGZvciBwdWJsaWMgQVBJXG5mdW5jdGlvbiBkZXN0cm95KGVyciwgY2IpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgcmVhZGFibGVEZXN0cm95ZWQgPSB0aGlzLl9yZWFkYWJsZVN0YXRlICYmIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB2YXIgd3JpdGFibGVEZXN0cm95ZWQgPSB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuXG4gIGlmIChyZWFkYWJsZURlc3Ryb3llZCB8fCB3cml0YWJsZURlc3Ryb3llZCkge1xuICAgIGlmIChjYikge1xuICAgICAgY2IoZXJyKTtcbiAgICB9IGVsc2UgaWYgKGVyciAmJiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUgfHwgIXRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKSkge1xuICAgICAgcG5hLm5leHRUaWNrKGVtaXRFcnJvck5ULCB0aGlzLCBlcnIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHdlIHNldCBkZXN0cm95ZWQgdG8gdHJ1ZSBiZWZvcmUgZmlyaW5nIGVycm9yIGNhbGxiYWNrcyBpbiBvcmRlclxuICAvLyB0byBtYWtlIGl0IHJlLWVudHJhbmNlIHNhZmUgaW4gY2FzZSBkZXN0cm95KCkgaXMgY2FsbGVkIHdpdGhpbiBjYWxsYmFja3NcblxuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIGlmIHRoaXMgaXMgYSBkdXBsZXggc3RyZWFtIG1hcmsgdGhlIHdyaXRhYmxlIHBhcnQgYXMgZGVzdHJveWVkIGFzIHdlbGxcbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gIH1cblxuICB0aGlzLl9kZXN0cm95KGVyciB8fCBudWxsLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKCFjYiAmJiBlcnIpIHtcbiAgICAgIHBuYS5uZXh0VGljayhlbWl0RXJyb3JOVCwgX3RoaXMsIGVycik7XG4gICAgICBpZiAoX3RoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgICAgX3RoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNiKSB7XG4gICAgICBjYihlcnIpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIHVuZGVzdHJveSgpIHtcbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0RXJyb3JOVChzZWxmLCBlcnIpIHtcbiAgc2VsZi5lbWl0KCdlcnJvcicsIGVycik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkZXN0cm95OiBkZXN0cm95LFxuICB1bmRlc3Ryb3k6IHVuZGVzdHJveVxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9yZWFkYWJsZScpLlBhc3NUaHJvdWdoXG4iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzJyk7XG5leHBvcnRzLlN0cmVhbSA9IGV4cG9ydHM7XG5leHBvcnRzLlJlYWRhYmxlID0gZXhwb3J0cztcbmV4cG9ydHMuV3JpdGFibGUgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XG5leHBvcnRzLkR1cGxleCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG5leHBvcnRzLlRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzJyk7XG5leHBvcnRzLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcycpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3JlYWRhYmxlJykuVHJhbnNmb3JtXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcbiIsIid1c2Ugc3RyaWN0J1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlclxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIEhhc2hCYXNlID0gcmVxdWlyZSgnaGFzaC1iYXNlJylcblxudmFyIEFSUkFZMTYgPSBuZXcgQXJyYXkoMTYpXG5cbnZhciB6bCA9IFtcbiAgMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMiwgMTMsIDE0LCAxNSxcbiAgNywgNCwgMTMsIDEsIDEwLCA2LCAxNSwgMywgMTIsIDAsIDksIDUsIDIsIDE0LCAxMSwgOCxcbiAgMywgMTAsIDE0LCA0LCA5LCAxNSwgOCwgMSwgMiwgNywgMCwgNiwgMTMsIDExLCA1LCAxMixcbiAgMSwgOSwgMTEsIDEwLCAwLCA4LCAxMiwgNCwgMTMsIDMsIDcsIDE1LCAxNCwgNSwgNiwgMixcbiAgNCwgMCwgNSwgOSwgNywgMTIsIDIsIDEwLCAxNCwgMSwgMywgOCwgMTEsIDYsIDE1LCAxM1xuXVxuXG52YXIgenIgPSBbXG4gIDUsIDE0LCA3LCAwLCA5LCAyLCAxMSwgNCwgMTMsIDYsIDE1LCA4LCAxLCAxMCwgMywgMTIsXG4gIDYsIDExLCAzLCA3LCAwLCAxMywgNSwgMTAsIDE0LCAxNSwgOCwgMTIsIDQsIDksIDEsIDIsXG4gIDE1LCA1LCAxLCAzLCA3LCAxNCwgNiwgOSwgMTEsIDgsIDEyLCAyLCAxMCwgMCwgNCwgMTMsXG4gIDgsIDYsIDQsIDEsIDMsIDExLCAxNSwgMCwgNSwgMTIsIDIsIDEzLCA5LCA3LCAxMCwgMTQsXG4gIDEyLCAxNSwgMTAsIDQsIDEsIDUsIDgsIDcsIDYsIDIsIDEzLCAxNCwgMCwgMywgOSwgMTFcbl1cblxudmFyIHNsID0gW1xuICAxMSwgMTQsIDE1LCAxMiwgNSwgOCwgNywgOSwgMTEsIDEzLCAxNCwgMTUsIDYsIDcsIDksIDgsXG4gIDcsIDYsIDgsIDEzLCAxMSwgOSwgNywgMTUsIDcsIDEyLCAxNSwgOSwgMTEsIDcsIDEzLCAxMixcbiAgMTEsIDEzLCA2LCA3LCAxNCwgOSwgMTMsIDE1LCAxNCwgOCwgMTMsIDYsIDUsIDEyLCA3LCA1LFxuICAxMSwgMTIsIDE0LCAxNSwgMTQsIDE1LCA5LCA4LCA5LCAxNCwgNSwgNiwgOCwgNiwgNSwgMTIsXG4gIDksIDE1LCA1LCAxMSwgNiwgOCwgMTMsIDEyLCA1LCAxMiwgMTMsIDE0LCAxMSwgOCwgNSwgNlxuXVxuXG52YXIgc3IgPSBbXG4gIDgsIDksIDksIDExLCAxMywgMTUsIDE1LCA1LCA3LCA3LCA4LCAxMSwgMTQsIDE0LCAxMiwgNixcbiAgOSwgMTMsIDE1LCA3LCAxMiwgOCwgOSwgMTEsIDcsIDcsIDEyLCA3LCA2LCAxNSwgMTMsIDExLFxuICA5LCA3LCAxNSwgMTEsIDgsIDYsIDYsIDE0LCAxMiwgMTMsIDUsIDE0LCAxMywgMTMsIDcsIDUsXG4gIDE1LCA1LCA4LCAxMSwgMTQsIDE0LCA2LCAxNCwgNiwgOSwgMTIsIDksIDEyLCA1LCAxNSwgOCxcbiAgOCwgNSwgMTIsIDksIDEyLCA1LCAxNCwgNiwgOCwgMTMsIDYsIDUsIDE1LCAxMywgMTEsIDExXG5dXG5cbnZhciBobCA9IFsweDAwMDAwMDAwLCAweDVhODI3OTk5LCAweDZlZDllYmExLCAweDhmMWJiY2RjLCAweGE5NTNmZDRlXVxudmFyIGhyID0gWzB4NTBhMjhiZTYsIDB4NWM0ZGQxMjQsIDB4NmQ3MDNlZjMsIDB4N2E2ZDc2ZTksIDB4MDAwMDAwMDBdXG5cbmZ1bmN0aW9uIFJJUEVNRDE2MCAoKSB7XG4gIEhhc2hCYXNlLmNhbGwodGhpcywgNjQpXG5cbiAgLy8gc3RhdGVcbiAgdGhpcy5fYSA9IDB4Njc0NTIzMDFcbiAgdGhpcy5fYiA9IDB4ZWZjZGFiODlcbiAgdGhpcy5fYyA9IDB4OThiYWRjZmVcbiAgdGhpcy5fZCA9IDB4MTAzMjU0NzZcbiAgdGhpcy5fZSA9IDB4YzNkMmUxZjBcbn1cblxuaW5oZXJpdHMoUklQRU1EMTYwLCBIYXNoQmFzZSlcblxuUklQRU1EMTYwLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgd29yZHMgPSBBUlJBWTE2XG4gIGZvciAodmFyIGogPSAwOyBqIDwgMTY7ICsraikgd29yZHNbal0gPSB0aGlzLl9ibG9jay5yZWFkSW50MzJMRShqICogNClcblxuICB2YXIgYWwgPSB0aGlzLl9hIHwgMFxuICB2YXIgYmwgPSB0aGlzLl9iIHwgMFxuICB2YXIgY2wgPSB0aGlzLl9jIHwgMFxuICB2YXIgZGwgPSB0aGlzLl9kIHwgMFxuICB2YXIgZWwgPSB0aGlzLl9lIHwgMFxuXG4gIHZhciBhciA9IHRoaXMuX2EgfCAwXG4gIHZhciBiciA9IHRoaXMuX2IgfCAwXG4gIHZhciBjciA9IHRoaXMuX2MgfCAwXG4gIHZhciBkciA9IHRoaXMuX2QgfCAwXG4gIHZhciBlciA9IHRoaXMuX2UgfCAwXG5cbiAgLy8gY29tcHV0YXRpb25cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA4MDsgaSArPSAxKSB7XG4gICAgdmFyIHRsXG4gICAgdmFyIHRyXG4gICAgaWYgKGkgPCAxNikge1xuICAgICAgdGwgPSBmbjEoYWwsIGJsLCBjbCwgZGwsIGVsLCB3b3Jkc1t6bFtpXV0sIGhsWzBdLCBzbFtpXSlcbiAgICAgIHRyID0gZm41KGFyLCBiciwgY3IsIGRyLCBlciwgd29yZHNbenJbaV1dLCBoclswXSwgc3JbaV0pXG4gICAgfSBlbHNlIGlmIChpIDwgMzIpIHtcbiAgICAgIHRsID0gZm4yKGFsLCBibCwgY2wsIGRsLCBlbCwgd29yZHNbemxbaV1dLCBobFsxXSwgc2xbaV0pXG4gICAgICB0ciA9IGZuNChhciwgYnIsIGNyLCBkciwgZXIsIHdvcmRzW3pyW2ldXSwgaHJbMV0sIHNyW2ldKVxuICAgIH0gZWxzZSBpZiAoaSA8IDQ4KSB7XG4gICAgICB0bCA9IGZuMyhhbCwgYmwsIGNsLCBkbCwgZWwsIHdvcmRzW3psW2ldXSwgaGxbMl0sIHNsW2ldKVxuICAgICAgdHIgPSBmbjMoYXIsIGJyLCBjciwgZHIsIGVyLCB3b3Jkc1t6cltpXV0sIGhyWzJdLCBzcltpXSlcbiAgICB9IGVsc2UgaWYgKGkgPCA2NCkge1xuICAgICAgdGwgPSBmbjQoYWwsIGJsLCBjbCwgZGwsIGVsLCB3b3Jkc1t6bFtpXV0sIGhsWzNdLCBzbFtpXSlcbiAgICAgIHRyID0gZm4yKGFyLCBiciwgY3IsIGRyLCBlciwgd29yZHNbenJbaV1dLCBoclszXSwgc3JbaV0pXG4gICAgfSBlbHNlIHsgLy8gaWYgKGk8ODApIHtcbiAgICAgIHRsID0gZm41KGFsLCBibCwgY2wsIGRsLCBlbCwgd29yZHNbemxbaV1dLCBobFs0XSwgc2xbaV0pXG4gICAgICB0ciA9IGZuMShhciwgYnIsIGNyLCBkciwgZXIsIHdvcmRzW3pyW2ldXSwgaHJbNF0sIHNyW2ldKVxuICAgIH1cblxuICAgIGFsID0gZWxcbiAgICBlbCA9IGRsXG4gICAgZGwgPSByb3RsKGNsLCAxMClcbiAgICBjbCA9IGJsXG4gICAgYmwgPSB0bFxuXG4gICAgYXIgPSBlclxuICAgIGVyID0gZHJcbiAgICBkciA9IHJvdGwoY3IsIDEwKVxuICAgIGNyID0gYnJcbiAgICBiciA9IHRyXG4gIH1cblxuICAvLyB1cGRhdGUgc3RhdGVcbiAgdmFyIHQgPSAodGhpcy5fYiArIGNsICsgZHIpIHwgMFxuICB0aGlzLl9iID0gKHRoaXMuX2MgKyBkbCArIGVyKSB8IDBcbiAgdGhpcy5fYyA9ICh0aGlzLl9kICsgZWwgKyBhcikgfCAwXG4gIHRoaXMuX2QgPSAodGhpcy5fZSArIGFsICsgYnIpIHwgMFxuICB0aGlzLl9lID0gKHRoaXMuX2EgKyBibCArIGNyKSB8IDBcbiAgdGhpcy5fYSA9IHRcbn1cblxuUklQRU1EMTYwLnByb3RvdHlwZS5fZGlnZXN0ID0gZnVuY3Rpb24gKCkge1xuICAvLyBjcmVhdGUgcGFkZGluZyBhbmQgaGFuZGxlIGJsb2Nrc1xuICB0aGlzLl9ibG9ja1t0aGlzLl9ibG9ja09mZnNldCsrXSA9IDB4ODBcbiAgaWYgKHRoaXMuX2Jsb2NrT2Zmc2V0ID4gNTYpIHtcbiAgICB0aGlzLl9ibG9jay5maWxsKDAsIHRoaXMuX2Jsb2NrT2Zmc2V0LCA2NClcbiAgICB0aGlzLl91cGRhdGUoKVxuICAgIHRoaXMuX2Jsb2NrT2Zmc2V0ID0gMFxuICB9XG5cbiAgdGhpcy5fYmxvY2suZmlsbCgwLCB0aGlzLl9ibG9ja09mZnNldCwgNTYpXG4gIHRoaXMuX2Jsb2NrLndyaXRlVUludDMyTEUodGhpcy5fbGVuZ3RoWzBdLCA1NilcbiAgdGhpcy5fYmxvY2sud3JpdGVVSW50MzJMRSh0aGlzLl9sZW5ndGhbMV0sIDYwKVxuICB0aGlzLl91cGRhdGUoKVxuXG4gIC8vIHByb2R1Y2UgcmVzdWx0XG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2MgPyBCdWZmZXIuYWxsb2MoMjApIDogbmV3IEJ1ZmZlcigyMClcbiAgYnVmZmVyLndyaXRlSW50MzJMRSh0aGlzLl9hLCAwKVxuICBidWZmZXIud3JpdGVJbnQzMkxFKHRoaXMuX2IsIDQpXG4gIGJ1ZmZlci53cml0ZUludDMyTEUodGhpcy5fYywgOClcbiAgYnVmZmVyLndyaXRlSW50MzJMRSh0aGlzLl9kLCAxMilcbiAgYnVmZmVyLndyaXRlSW50MzJMRSh0aGlzLl9lLCAxNilcbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiByb3RsICh4LCBuKSB7XG4gIHJldHVybiAoeCA8PCBuKSB8ICh4ID4+PiAoMzIgLSBuKSlcbn1cblxuZnVuY3Rpb24gZm4xIChhLCBiLCBjLCBkLCBlLCBtLCBrLCBzKSB7XG4gIHJldHVybiAocm90bCgoYSArIChiIF4gYyBeIGQpICsgbSArIGspIHwgMCwgcykgKyBlKSB8IDBcbn1cblxuZnVuY3Rpb24gZm4yIChhLCBiLCBjLCBkLCBlLCBtLCBrLCBzKSB7XG4gIHJldHVybiAocm90bCgoYSArICgoYiAmIGMpIHwgKCh+YikgJiBkKSkgKyBtICsgaykgfCAwLCBzKSArIGUpIHwgMFxufVxuXG5mdW5jdGlvbiBmbjMgKGEsIGIsIGMsIGQsIGUsIG0sIGssIHMpIHtcbiAgcmV0dXJuIChyb3RsKChhICsgKChiIHwgKH5jKSkgXiBkKSArIG0gKyBrKSB8IDAsIHMpICsgZSkgfCAwXG59XG5cbmZ1bmN0aW9uIGZuNCAoYSwgYiwgYywgZCwgZSwgbSwgaywgcykge1xuICByZXR1cm4gKHJvdGwoKGEgKyAoKGIgJiBkKSB8IChjICYgKH5kKSkpICsgbSArIGspIHwgMCwgcykgKyBlKSB8IDBcbn1cblxuZnVuY3Rpb24gZm41IChhLCBiLCBjLCBkLCBlLCBtLCBrLCBzKSB7XG4gIHJldHVybiAocm90bCgoYSArIChiIF4gKGMgfCAofmQpKSkgKyBtICsgaykgfCAwLCBzKSArIGUpIHwgMFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJJUEVNRDE2MFxuIiwiLyogZXNsaW50LWRpc2FibGUgbm9kZS9uby1kZXByZWNhdGVkLWFwaSAqL1xudmFyIGJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpXG52YXIgQnVmZmVyID0gYnVmZmVyLkJ1ZmZlclxuXG4vLyBhbHRlcm5hdGl2ZSB0byB1c2luZyBPYmplY3Qua2V5cyBmb3Igb2xkIGJyb3dzZXJzXG5mdW5jdGlvbiBjb3B5UHJvcHMgKHNyYywgZHN0KSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICBkc3Rba2V5XSA9IHNyY1trZXldXG4gIH1cbn1cbmlmIChCdWZmZXIuZnJvbSAmJiBCdWZmZXIuYWxsb2MgJiYgQnVmZmVyLmFsbG9jVW5zYWZlICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBidWZmZXJcbn0gZWxzZSB7XG4gIC8vIENvcHkgcHJvcGVydGllcyBmcm9tIHJlcXVpcmUoJ2J1ZmZlcicpXG4gIGNvcHlQcm9wcyhidWZmZXIsIGV4cG9ydHMpXG4gIGV4cG9ydHMuQnVmZmVyID0gU2FmZUJ1ZmZlclxufVxuXG5mdW5jdGlvbiBTYWZlQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBDb3B5IHN0YXRpYyBtZXRob2RzIGZyb20gQnVmZmVyXG5jb3B5UHJvcHMoQnVmZmVyLCBTYWZlQnVmZmVyKVxuXG5TYWZlQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cblNhZmVCdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHZhciBidWYgPSBCdWZmZXIoc2l6ZSlcbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICBidWYuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmLmZpbGwoZmlsbClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYnVmLmZpbGwoMClcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihzaXplKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gYnVmZmVyLlNsb3dCdWZmZXIoc2l6ZSlcbn1cbiIsIihmdW5jdGlvbiAoZ2xvYmFsLCB1bmRlZmluZWQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmIChnbG9iYWwuc2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmV4dEhhbmRsZSA9IDE7IC8vIFNwZWMgc2F5cyBncmVhdGVyIHRoYW4gemVyb1xuICAgIHZhciB0YXNrc0J5SGFuZGxlID0ge307XG4gICAgdmFyIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgIHZhciBkb2MgPSBnbG9iYWwuZG9jdW1lbnQ7XG4gICAgdmFyIHJlZ2lzdGVySW1tZWRpYXRlO1xuXG4gICAgZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGNhbGxiYWNrKSB7XG4gICAgICAvLyBDYWxsYmFjayBjYW4gZWl0aGVyIGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmdcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYWxsYmFjayA9IG5ldyBGdW5jdGlvbihcIlwiICsgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgLy8gQ29weSBmdW5jdGlvbiBhcmd1bWVudHNcbiAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDFdO1xuICAgICAgfVxuICAgICAgLy8gU3RvcmUgYW5kIHJlZ2lzdGVyIHRoZSB0YXNrXG4gICAgICB2YXIgdGFzayA9IHsgY2FsbGJhY2s6IGNhbGxiYWNrLCBhcmdzOiBhcmdzIH07XG4gICAgICB0YXNrc0J5SGFuZGxlW25leHRIYW5kbGVdID0gdGFzaztcbiAgICAgIHJlZ2lzdGVySW1tZWRpYXRlKG5leHRIYW5kbGUpO1xuICAgICAgcmV0dXJuIG5leHRIYW5kbGUrKztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShoYW5kbGUpIHtcbiAgICAgICAgZGVsZXRlIHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW4odGFzaykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0YXNrLmNhbGxiYWNrO1xuICAgICAgICB2YXIgYXJncyA9IHRhc2suYXJncztcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW5JZlByZXNlbnQoaGFuZGxlKSB7XG4gICAgICAgIC8vIEZyb20gdGhlIHNwZWM6IFwiV2FpdCB1bnRpbCBhbnkgaW52b2NhdGlvbnMgb2YgdGhpcyBhbGdvcml0aG0gc3RhcnRlZCBiZWZvcmUgdGhpcyBvbmUgaGF2ZSBjb21wbGV0ZWQuXCJcbiAgICAgICAgLy8gU28gaWYgd2UncmUgY3VycmVudGx5IHJ1bm5pbmcgYSB0YXNrLCB3ZSdsbCBuZWVkIHRvIGRlbGF5IHRoaXMgaW52b2NhdGlvbi5cbiAgICAgICAgaWYgKGN1cnJlbnRseVJ1bm5pbmdBVGFzaykge1xuICAgICAgICAgICAgLy8gRGVsYXkgYnkgZG9pbmcgYSBzZXRUaW1lb3V0LiBzZXRJbW1lZGlhdGUgd2FzIHRyaWVkIGluc3RlYWQsIGJ1dCBpbiBGaXJlZm94IDcgaXQgZ2VuZXJhdGVkIGFcbiAgICAgICAgICAgIC8vIFwidG9vIG11Y2ggcmVjdXJzaW9uXCIgZXJyb3IuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0YXNrID0gdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgICAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bih0YXNrKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckltbWVkaWF0ZShoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkgeyBydW5JZlByZXNlbnQoaGFuZGxlKTsgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FuVXNlUG9zdE1lc3NhZ2UoKSB7XG4gICAgICAgIC8vIFRoZSB0ZXN0IGFnYWluc3QgYGltcG9ydFNjcmlwdHNgIHByZXZlbnRzIHRoaXMgaW1wbGVtZW50YXRpb24gZnJvbSBiZWluZyBpbnN0YWxsZWQgaW5zaWRlIGEgd2ViIHdvcmtlcixcbiAgICAgICAgLy8gd2hlcmUgYGdsb2JhbC5wb3N0TWVzc2FnZWAgbWVhbnMgc29tZXRoaW5nIGNvbXBsZXRlbHkgZGlmZmVyZW50IGFuZCBjYW4ndCBiZSB1c2VkIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAgIGlmIChnbG9iYWwucG9zdE1lc3NhZ2UgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgICAgICAgICB2YXIgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgb2xkT25NZXNzYWdlID0gZ2xvYmFsLm9ubWVzc2FnZTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKFwiXCIsIFwiKlwiKTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBvbGRPbk1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICAvLyBJbnN0YWxscyBhbiBldmVudCBoYW5kbGVyIG9uIGBnbG9iYWxgIGZvciB0aGUgYG1lc3NhZ2VgIGV2ZW50OiBzZWVcbiAgICAgICAgLy8gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vd2luZG93LnBvc3RNZXNzYWdlXG4gICAgICAgIC8vICogaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvY29tbXMuaHRtbCNjcm9zc0RvY3VtZW50TWVzc2FnZXNcblxuICAgICAgICB2YXIgbWVzc2FnZVByZWZpeCA9IFwic2V0SW1tZWRpYXRlJFwiICsgTWF0aC5yYW5kb20oKSArIFwiJFwiO1xuICAgICAgICB2YXIgb25HbG9iYWxNZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IGdsb2JhbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBldmVudC5kYXRhID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5pbmRleE9mKG1lc3NhZ2VQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KCtldmVudC5kYXRhLnNsaWNlKG1lc3NhZ2VQcmVmaXgubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoXCJvbm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UobWVzc2FnZVByZWZpeCArIGhhbmRsZSwgXCIqXCIpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXG4gICAgICAgICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudC4gRG8gc28sIHRodXMgcXVldWluZyB1cCB0aGUgdGFzay4gUmVtZW1iZXIgdG8gY2xlYW4gdXAgb25jZSBpdCdzIGJlZW4gY2FsbGVkLlxuICAgICAgICAgICAgdmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBodG1sLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIElmIHN1cHBvcnRlZCwgd2Ugc2hvdWxkIGF0dGFjaCB0byB0aGUgcHJvdG90eXBlIG9mIGdsb2JhbCwgc2luY2UgdGhhdCBpcyB3aGVyZSBzZXRUaW1lb3V0IGV0IGFsLiBsaXZlLlxuICAgIHZhciBhdHRhY2hUbyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZ2xvYmFsKTtcbiAgICBhdHRhY2hUbyA9IGF0dGFjaFRvICYmIGF0dGFjaFRvLnNldFRpbWVvdXQgPyBhdHRhY2hUbyA6IGdsb2JhbDtcblxuICAgIC8vIERvbid0IGdldCBmb29sZWQgYnkgZS5nLiBicm93c2VyaWZ5IGVudmlyb25tZW50cy5cbiAgICBpZiAoe30udG9TdHJpbmcuY2FsbChnbG9iYWwucHJvY2VzcykgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiKSB7XG4gICAgICAgIC8vIEZvciBOb2RlLmpzIGJlZm9yZSAwLjlcbiAgICAgICAgaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoY2FuVXNlUG9zdE1lc3NhZ2UoKSkge1xuICAgICAgICAvLyBGb3Igbm9uLUlFMTAgbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCkge1xuICAgICAgICAvLyBGb3Igd2ViIHdvcmtlcnMsIHdoZXJlIHN1cHBvcnRlZFxuICAgICAgICBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChkb2MgJiYgXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiBpbiBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSkge1xuICAgICAgICAvLyBGb3IgSUUgNuKAkzhcbiAgICAgICAgaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIG9sZGVyIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKTtcbiAgICB9XG5cbiAgICBhdHRhY2hUby5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG4gICAgYXR0YWNoVG8uY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcbn0odHlwZW9mIHNlbGYgPT09IFwidW5kZWZpbmVkXCIgPyB0eXBlb2YgZ2xvYmFsID09PSBcInVuZGVmaW5lZFwiID8gdGhpcyA6IGdsb2JhbCA6IHNlbGYpKTtcbiIsInZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG4vLyBwcm90b3R5cGUgY2xhc3MgZm9yIGhhc2ggZnVuY3Rpb25zXG5mdW5jdGlvbiBIYXNoIChibG9ja1NpemUsIGZpbmFsU2l6ZSkge1xuICB0aGlzLl9ibG9jayA9IEJ1ZmZlci5hbGxvYyhibG9ja1NpemUpXG4gIHRoaXMuX2ZpbmFsU2l6ZSA9IGZpbmFsU2l6ZVxuICB0aGlzLl9ibG9ja1NpemUgPSBibG9ja1NpemVcbiAgdGhpcy5fbGVuID0gMFxufVxuXG5IYXNoLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSwgZW5jKSB7XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmMgPSBlbmMgfHwgJ3V0ZjgnXG4gICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEsIGVuYylcbiAgfVxuXG4gIHZhciBibG9jayA9IHRoaXMuX2Jsb2NrXG4gIHZhciBibG9ja1NpemUgPSB0aGlzLl9ibG9ja1NpemVcbiAgdmFyIGxlbmd0aCA9IGRhdGEubGVuZ3RoXG4gIHZhciBhY2N1bSA9IHRoaXMuX2xlblxuXG4gIGZvciAodmFyIG9mZnNldCA9IDA7IG9mZnNldCA8IGxlbmd0aDspIHtcbiAgICB2YXIgYXNzaWduZWQgPSBhY2N1bSAlIGJsb2NrU2l6ZVxuICAgIHZhciByZW1haW5kZXIgPSBNYXRoLm1pbihsZW5ndGggLSBvZmZzZXQsIGJsb2NrU2l6ZSAtIGFzc2lnbmVkKVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZW1haW5kZXI7IGkrKykge1xuICAgICAgYmxvY2tbYXNzaWduZWQgKyBpXSA9IGRhdGFbb2Zmc2V0ICsgaV1cbiAgICB9XG5cbiAgICBhY2N1bSArPSByZW1haW5kZXJcbiAgICBvZmZzZXQgKz0gcmVtYWluZGVyXG5cbiAgICBpZiAoKGFjY3VtICUgYmxvY2tTaXplKSA9PT0gMCkge1xuICAgICAgdGhpcy5fdXBkYXRlKGJsb2NrKVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuX2xlbiArPSBsZW5ndGhcbiAgcmV0dXJuIHRoaXNcbn1cblxuSGFzaC5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gKGVuYykge1xuICB2YXIgcmVtID0gdGhpcy5fbGVuICUgdGhpcy5fYmxvY2tTaXplXG5cbiAgdGhpcy5fYmxvY2tbcmVtXSA9IDB4ODBcblxuICAvLyB6ZXJvIChyZW0gKyAxKSB0cmFpbGluZyBiaXRzLCB3aGVyZSAocmVtICsgMSkgaXMgdGhlIHNtYWxsZXN0XG4gIC8vIG5vbi1uZWdhdGl2ZSBzb2x1dGlvbiB0byB0aGUgZXF1YXRpb24gKGxlbmd0aCArIDEgKyAocmVtICsgMSkpID09PSBmaW5hbFNpemUgbW9kIGJsb2NrU2l6ZVxuICB0aGlzLl9ibG9jay5maWxsKDAsIHJlbSArIDEpXG5cbiAgaWYgKHJlbSA+PSB0aGlzLl9maW5hbFNpemUpIHtcbiAgICB0aGlzLl91cGRhdGUodGhpcy5fYmxvY2spXG4gICAgdGhpcy5fYmxvY2suZmlsbCgwKVxuICB9XG5cbiAgdmFyIGJpdHMgPSB0aGlzLl9sZW4gKiA4XG5cbiAgLy8gdWludDMyXG4gIGlmIChiaXRzIDw9IDB4ZmZmZmZmZmYpIHtcbiAgICB0aGlzLl9ibG9jay53cml0ZVVJbnQzMkJFKGJpdHMsIHRoaXMuX2Jsb2NrU2l6ZSAtIDQpXG5cbiAgLy8gdWludDY0XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxvd0JpdHMgPSAoYml0cyAmIDB4ZmZmZmZmZmYpID4+PiAwXG4gICAgdmFyIGhpZ2hCaXRzID0gKGJpdHMgLSBsb3dCaXRzKSAvIDB4MTAwMDAwMDAwXG5cbiAgICB0aGlzLl9ibG9jay53cml0ZVVJbnQzMkJFKGhpZ2hCaXRzLCB0aGlzLl9ibG9ja1NpemUgLSA4KVxuICAgIHRoaXMuX2Jsb2NrLndyaXRlVUludDMyQkUobG93Qml0cywgdGhpcy5fYmxvY2tTaXplIC0gNClcbiAgfVxuXG4gIHRoaXMuX3VwZGF0ZSh0aGlzLl9ibG9jaylcbiAgdmFyIGhhc2ggPSB0aGlzLl9oYXNoKClcblxuICByZXR1cm4gZW5jID8gaGFzaC50b1N0cmluZyhlbmMpIDogaGFzaFxufVxuXG5IYXNoLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ191cGRhdGUgbXVzdCBiZSBpbXBsZW1lbnRlZCBieSBzdWJjbGFzcycpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gSGFzaFxuIiwidmFyIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIFNIQSAoYWxnb3JpdGhtKSB7XG4gIGFsZ29yaXRobSA9IGFsZ29yaXRobS50b0xvd2VyQ2FzZSgpXG5cbiAgdmFyIEFsZ29yaXRobSA9IGV4cG9ydHNbYWxnb3JpdGhtXVxuICBpZiAoIUFsZ29yaXRobSkgdGhyb3cgbmV3IEVycm9yKGFsZ29yaXRobSArICcgaXMgbm90IHN1cHBvcnRlZCAod2UgYWNjZXB0IHB1bGwgcmVxdWVzdHMpJylcblxuICByZXR1cm4gbmV3IEFsZ29yaXRobSgpXG59XG5cbmV4cG9ydHMuc2hhID0gcmVxdWlyZSgnLi9zaGEnKVxuZXhwb3J0cy5zaGExID0gcmVxdWlyZSgnLi9zaGExJylcbmV4cG9ydHMuc2hhMjI0ID0gcmVxdWlyZSgnLi9zaGEyMjQnKVxuZXhwb3J0cy5zaGEyNTYgPSByZXF1aXJlKCcuL3NoYTI1NicpXG5leHBvcnRzLnNoYTM4NCA9IHJlcXVpcmUoJy4vc2hhMzg0JylcbmV4cG9ydHMuc2hhNTEyID0gcmVxdWlyZSgnLi9zaGE1MTInKVxuIiwiLypcbiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2VjdXJlIEhhc2ggQWxnb3JpdGhtLCBTSEEtMCwgYXMgZGVmaW5lZFxuICogaW4gRklQUyBQVUIgMTgwLTFcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgZGVyaXZlZCBmcm9tIHNoYTEuanMgb2YgdGhlIHNhbWUgcmVwb3NpdG9yeS5cbiAqIFRoZSBkaWZmZXJlbmNlIGJldHdlZW4gU0hBLTAgYW5kIFNIQS0xIGlzIGp1c3QgYSBiaXR3aXNlIHJvdGF0ZSBsZWZ0XG4gKiBvcGVyYXRpb24gd2FzIGFkZGVkLlxuICovXG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBIYXNoID0gcmVxdWlyZSgnLi9oYXNoJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG52YXIgSyA9IFtcbiAgMHg1YTgyNzk5OSwgMHg2ZWQ5ZWJhMSwgMHg4ZjFiYmNkYyB8IDAsIDB4Y2E2MmMxZDYgfCAwXG5dXG5cbnZhciBXID0gbmV3IEFycmF5KDgwKVxuXG5mdW5jdGlvbiBTaGEgKCkge1xuICB0aGlzLmluaXQoKVxuICB0aGlzLl93ID0gV1xuXG4gIEhhc2guY2FsbCh0aGlzLCA2NCwgNTYpXG59XG5cbmluaGVyaXRzKFNoYSwgSGFzaClcblxuU2hhLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9hID0gMHg2NzQ1MjMwMVxuICB0aGlzLl9iID0gMHhlZmNkYWI4OVxuICB0aGlzLl9jID0gMHg5OGJhZGNmZVxuICB0aGlzLl9kID0gMHgxMDMyNTQ3NlxuICB0aGlzLl9lID0gMHhjM2QyZTFmMFxuXG4gIHJldHVybiB0aGlzXG59XG5cbmZ1bmN0aW9uIHJvdGw1IChudW0pIHtcbiAgcmV0dXJuIChudW0gPDwgNSkgfCAobnVtID4+PiAyNylcbn1cblxuZnVuY3Rpb24gcm90bDMwIChudW0pIHtcbiAgcmV0dXJuIChudW0gPDwgMzApIHwgKG51bSA+Pj4gMilcbn1cblxuZnVuY3Rpb24gZnQgKHMsIGIsIGMsIGQpIHtcbiAgaWYgKHMgPT09IDApIHJldHVybiAoYiAmIGMpIHwgKCh+YikgJiBkKVxuICBpZiAocyA9PT0gMikgcmV0dXJuIChiICYgYykgfCAoYiAmIGQpIHwgKGMgJiBkKVxuICByZXR1cm4gYiBeIGMgXiBkXG59XG5cblNoYS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChNKSB7XG4gIHZhciBXID0gdGhpcy5fd1xuXG4gIHZhciBhID0gdGhpcy5fYSB8IDBcbiAgdmFyIGIgPSB0aGlzLl9iIHwgMFxuICB2YXIgYyA9IHRoaXMuX2MgfCAwXG4gIHZhciBkID0gdGhpcy5fZCB8IDBcbiAgdmFyIGUgPSB0aGlzLl9lIHwgMFxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7ICsraSkgV1tpXSA9IE0ucmVhZEludDMyQkUoaSAqIDQpXG4gIGZvciAoOyBpIDwgODA7ICsraSkgV1tpXSA9IFdbaSAtIDNdIF4gV1tpIC0gOF0gXiBXW2kgLSAxNF0gXiBXW2kgLSAxNl1cblxuICBmb3IgKHZhciBqID0gMDsgaiA8IDgwOyArK2opIHtcbiAgICB2YXIgcyA9IH5+KGogLyAyMClcbiAgICB2YXIgdCA9IChyb3RsNShhKSArIGZ0KHMsIGIsIGMsIGQpICsgZSArIFdbal0gKyBLW3NdKSB8IDBcblxuICAgIGUgPSBkXG4gICAgZCA9IGNcbiAgICBjID0gcm90bDMwKGIpXG4gICAgYiA9IGFcbiAgICBhID0gdFxuICB9XG5cbiAgdGhpcy5fYSA9IChhICsgdGhpcy5fYSkgfCAwXG4gIHRoaXMuX2IgPSAoYiArIHRoaXMuX2IpIHwgMFxuICB0aGlzLl9jID0gKGMgKyB0aGlzLl9jKSB8IDBcbiAgdGhpcy5fZCA9IChkICsgdGhpcy5fZCkgfCAwXG4gIHRoaXMuX2UgPSAoZSArIHRoaXMuX2UpIHwgMFxufVxuXG5TaGEucHJvdG90eXBlLl9oYXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgSCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgyMClcblxuICBILndyaXRlSW50MzJCRSh0aGlzLl9hIHwgMCwgMClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYiB8IDAsIDQpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2MgfCAwLCA4KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9kIHwgMCwgMTIpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2UgfCAwLCAxNilcblxuICByZXR1cm4gSFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNoYVxuIiwiLypcbiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2VjdXJlIEhhc2ggQWxnb3JpdGhtLCBTSEEtMSwgYXMgZGVmaW5lZFxuICogaW4gRklQUyBQVUIgMTgwLTFcbiAqIFZlcnNpb24gMi4xYSBDb3B5cmlnaHQgUGF1bCBKb2huc3RvbiAyMDAwIC0gMjAwMi5cbiAqIE90aGVyIGNvbnRyaWJ1dG9yczogR3JlZyBIb2x0LCBBbmRyZXcgS2VwZXJ0LCBZZG5hciwgTG9zdGluZXRcbiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgTGljZW5zZVxuICogU2VlIGh0dHA6Ly9wYWpob21lLm9yZy51ay9jcnlwdC9tZDUgZm9yIGRldGFpbHMuXG4gKi9cblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIEhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbnZhciBLID0gW1xuICAweDVhODI3OTk5LCAweDZlZDllYmExLCAweDhmMWJiY2RjIHwgMCwgMHhjYTYyYzFkNiB8IDBcbl1cblxudmFyIFcgPSBuZXcgQXJyYXkoODApXG5cbmZ1bmN0aW9uIFNoYTEgKCkge1xuICB0aGlzLmluaXQoKVxuICB0aGlzLl93ID0gV1xuXG4gIEhhc2guY2FsbCh0aGlzLCA2NCwgNTYpXG59XG5cbmluaGVyaXRzKFNoYTEsIEhhc2gpXG5cblNoYTEucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2EgPSAweDY3NDUyMzAxXG4gIHRoaXMuX2IgPSAweGVmY2RhYjg5XG4gIHRoaXMuX2MgPSAweDk4YmFkY2ZlXG4gIHRoaXMuX2QgPSAweDEwMzI1NDc2XG4gIHRoaXMuX2UgPSAweGMzZDJlMWYwXG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuZnVuY3Rpb24gcm90bDEgKG51bSkge1xuICByZXR1cm4gKG51bSA8PCAxKSB8IChudW0gPj4+IDMxKVxufVxuXG5mdW5jdGlvbiByb3RsNSAobnVtKSB7XG4gIHJldHVybiAobnVtIDw8IDUpIHwgKG51bSA+Pj4gMjcpXG59XG5cbmZ1bmN0aW9uIHJvdGwzMCAobnVtKSB7XG4gIHJldHVybiAobnVtIDw8IDMwKSB8IChudW0gPj4+IDIpXG59XG5cbmZ1bmN0aW9uIGZ0IChzLCBiLCBjLCBkKSB7XG4gIGlmIChzID09PSAwKSByZXR1cm4gKGIgJiBjKSB8ICgofmIpICYgZClcbiAgaWYgKHMgPT09IDIpIHJldHVybiAoYiAmIGMpIHwgKGIgJiBkKSB8IChjICYgZClcbiAgcmV0dXJuIGIgXiBjIF4gZFxufVxuXG5TaGExLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKE0pIHtcbiAgdmFyIFcgPSB0aGlzLl93XG5cbiAgdmFyIGEgPSB0aGlzLl9hIHwgMFxuICB2YXIgYiA9IHRoaXMuX2IgfCAwXG4gIHZhciBjID0gdGhpcy5fYyB8IDBcbiAgdmFyIGQgPSB0aGlzLl9kIHwgMFxuICB2YXIgZSA9IHRoaXMuX2UgfCAwXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgKytpKSBXW2ldID0gTS5yZWFkSW50MzJCRShpICogNClcbiAgZm9yICg7IGkgPCA4MDsgKytpKSBXW2ldID0gcm90bDEoV1tpIC0gM10gXiBXW2kgLSA4XSBeIFdbaSAtIDE0XSBeIFdbaSAtIDE2XSlcblxuICBmb3IgKHZhciBqID0gMDsgaiA8IDgwOyArK2opIHtcbiAgICB2YXIgcyA9IH5+KGogLyAyMClcbiAgICB2YXIgdCA9IChyb3RsNShhKSArIGZ0KHMsIGIsIGMsIGQpICsgZSArIFdbal0gKyBLW3NdKSB8IDBcblxuICAgIGUgPSBkXG4gICAgZCA9IGNcbiAgICBjID0gcm90bDMwKGIpXG4gICAgYiA9IGFcbiAgICBhID0gdFxuICB9XG5cbiAgdGhpcy5fYSA9IChhICsgdGhpcy5fYSkgfCAwXG4gIHRoaXMuX2IgPSAoYiArIHRoaXMuX2IpIHwgMFxuICB0aGlzLl9jID0gKGMgKyB0aGlzLl9jKSB8IDBcbiAgdGhpcy5fZCA9IChkICsgdGhpcy5fZCkgfCAwXG4gIHRoaXMuX2UgPSAoZSArIHRoaXMuX2UpIHwgMFxufVxuXG5TaGExLnByb3RvdHlwZS5faGFzaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIEggPSBCdWZmZXIuYWxsb2NVbnNhZmUoMjApXG5cbiAgSC53cml0ZUludDMyQkUodGhpcy5fYSB8IDAsIDApXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2IgfCAwLCA0KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9jIHwgMCwgOClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZCB8IDAsIDEyKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9lIHwgMCwgMTYpXG5cbiAgcmV0dXJuIEhcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaGExXG4iLCIvKipcbiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2VjdXJlIEhhc2ggQWxnb3JpdGhtLCBTSEEtMjU2LCBhcyBkZWZpbmVkXG4gKiBpbiBGSVBTIDE4MC0yXG4gKiBWZXJzaW9uIDIuMi1iZXRhIENvcHlyaWdodCBBbmdlbCBNYXJpbiwgUGF1bCBKb2huc3RvbiAyMDAwIC0gMjAwOS5cbiAqIE90aGVyIGNvbnRyaWJ1dG9yczogR3JlZyBIb2x0LCBBbmRyZXcgS2VwZXJ0LCBZZG5hciwgTG9zdGluZXRcbiAqXG4gKi9cblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIFNoYTI1NiA9IHJlcXVpcmUoJy4vc2hhMjU2JylcbnZhciBIYXNoID0gcmVxdWlyZSgnLi9oYXNoJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG52YXIgVyA9IG5ldyBBcnJheSg2NClcblxuZnVuY3Rpb24gU2hhMjI0ICgpIHtcbiAgdGhpcy5pbml0KClcblxuICB0aGlzLl93ID0gVyAvLyBuZXcgQXJyYXkoNjQpXG5cbiAgSGFzaC5jYWxsKHRoaXMsIDY0LCA1Nilcbn1cblxuaW5oZXJpdHMoU2hhMjI0LCBTaGEyNTYpXG5cblNoYTIyNC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fYSA9IDB4YzEwNTllZDhcbiAgdGhpcy5fYiA9IDB4MzY3Y2Q1MDdcbiAgdGhpcy5fYyA9IDB4MzA3MGRkMTdcbiAgdGhpcy5fZCA9IDB4ZjcwZTU5MzlcbiAgdGhpcy5fZSA9IDB4ZmZjMDBiMzFcbiAgdGhpcy5fZiA9IDB4Njg1ODE1MTFcbiAgdGhpcy5fZyA9IDB4NjRmOThmYTdcbiAgdGhpcy5faCA9IDB4YmVmYTRmYTRcblxuICByZXR1cm4gdGhpc1xufVxuXG5TaGEyMjQucHJvdG90eXBlLl9oYXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgSCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgyOClcblxuICBILndyaXRlSW50MzJCRSh0aGlzLl9hLCAwKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9iLCA0KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9jLCA4KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9kLCAxMilcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZSwgMTYpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2YsIDIwKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9nLCAyNClcblxuICByZXR1cm4gSFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNoYTIyNFxuIiwiLyoqXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFNlY3VyZSBIYXNoIEFsZ29yaXRobSwgU0hBLTI1NiwgYXMgZGVmaW5lZFxuICogaW4gRklQUyAxODAtMlxuICogVmVyc2lvbiAyLjItYmV0YSBDb3B5cmlnaHQgQW5nZWwgTWFyaW4sIFBhdWwgSm9obnN0b24gMjAwMCAtIDIwMDkuXG4gKiBPdGhlciBjb250cmlidXRvcnM6IEdyZWcgSG9sdCwgQW5kcmV3IEtlcGVydCwgWWRuYXIsIExvc3RpbmV0XG4gKlxuICovXG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBIYXNoID0gcmVxdWlyZSgnLi9oYXNoJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG52YXIgSyA9IFtcbiAgMHg0MjhBMkY5OCwgMHg3MTM3NDQ5MSwgMHhCNUMwRkJDRiwgMHhFOUI1REJBNSxcbiAgMHgzOTU2QzI1QiwgMHg1OUYxMTFGMSwgMHg5MjNGODJBNCwgMHhBQjFDNUVENSxcbiAgMHhEODA3QUE5OCwgMHgxMjgzNUIwMSwgMHgyNDMxODVCRSwgMHg1NTBDN0RDMyxcbiAgMHg3MkJFNUQ3NCwgMHg4MERFQjFGRSwgMHg5QkRDMDZBNywgMHhDMTlCRjE3NCxcbiAgMHhFNDlCNjlDMSwgMHhFRkJFNDc4NiwgMHgwRkMxOURDNiwgMHgyNDBDQTFDQyxcbiAgMHgyREU5MkM2RiwgMHg0QTc0ODRBQSwgMHg1Q0IwQTlEQywgMHg3NkY5ODhEQSxcbiAgMHg5ODNFNTE1MiwgMHhBODMxQzY2RCwgMHhCMDAzMjdDOCwgMHhCRjU5N0ZDNyxcbiAgMHhDNkUwMEJGMywgMHhENUE3OTE0NywgMHgwNkNBNjM1MSwgMHgxNDI5Mjk2NyxcbiAgMHgyN0I3MEE4NSwgMHgyRTFCMjEzOCwgMHg0RDJDNkRGQywgMHg1MzM4MEQxMyxcbiAgMHg2NTBBNzM1NCwgMHg3NjZBMEFCQiwgMHg4MUMyQzkyRSwgMHg5MjcyMkM4NSxcbiAgMHhBMkJGRThBMSwgMHhBODFBNjY0QiwgMHhDMjRCOEI3MCwgMHhDNzZDNTFBMyxcbiAgMHhEMTkyRTgxOSwgMHhENjk5MDYyNCwgMHhGNDBFMzU4NSwgMHgxMDZBQTA3MCxcbiAgMHgxOUE0QzExNiwgMHgxRTM3NkMwOCwgMHgyNzQ4Nzc0QywgMHgzNEIwQkNCNSxcbiAgMHgzOTFDMENCMywgMHg0RUQ4QUE0QSwgMHg1QjlDQ0E0RiwgMHg2ODJFNkZGMyxcbiAgMHg3NDhGODJFRSwgMHg3OEE1NjM2RiwgMHg4NEM4NzgxNCwgMHg4Q0M3MDIwOCxcbiAgMHg5MEJFRkZGQSwgMHhBNDUwNkNFQiwgMHhCRUY5QTNGNywgMHhDNjcxNzhGMlxuXVxuXG52YXIgVyA9IG5ldyBBcnJheSg2NClcblxuZnVuY3Rpb24gU2hhMjU2ICgpIHtcbiAgdGhpcy5pbml0KClcblxuICB0aGlzLl93ID0gVyAvLyBuZXcgQXJyYXkoNjQpXG5cbiAgSGFzaC5jYWxsKHRoaXMsIDY0LCA1Nilcbn1cblxuaW5oZXJpdHMoU2hhMjU2LCBIYXNoKVxuXG5TaGEyNTYucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2EgPSAweDZhMDllNjY3XG4gIHRoaXMuX2IgPSAweGJiNjdhZTg1XG4gIHRoaXMuX2MgPSAweDNjNmVmMzcyXG4gIHRoaXMuX2QgPSAweGE1NGZmNTNhXG4gIHRoaXMuX2UgPSAweDUxMGU1MjdmXG4gIHRoaXMuX2YgPSAweDliMDU2ODhjXG4gIHRoaXMuX2cgPSAweDFmODNkOWFiXG4gIHRoaXMuX2ggPSAweDViZTBjZDE5XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuZnVuY3Rpb24gY2ggKHgsIHksIHopIHtcbiAgcmV0dXJuIHogXiAoeCAmICh5IF4geikpXG59XG5cbmZ1bmN0aW9uIG1haiAoeCwgeSwgeikge1xuICByZXR1cm4gKHggJiB5KSB8ICh6ICYgKHggfCB5KSlcbn1cblxuZnVuY3Rpb24gc2lnbWEwICh4KSB7XG4gIHJldHVybiAoeCA+Pj4gMiB8IHggPDwgMzApIF4gKHggPj4+IDEzIHwgeCA8PCAxOSkgXiAoeCA+Pj4gMjIgfCB4IDw8IDEwKVxufVxuXG5mdW5jdGlvbiBzaWdtYTEgKHgpIHtcbiAgcmV0dXJuICh4ID4+PiA2IHwgeCA8PCAyNikgXiAoeCA+Pj4gMTEgfCB4IDw8IDIxKSBeICh4ID4+PiAyNSB8IHggPDwgNylcbn1cblxuZnVuY3Rpb24gZ2FtbWEwICh4KSB7XG4gIHJldHVybiAoeCA+Pj4gNyB8IHggPDwgMjUpIF4gKHggPj4+IDE4IHwgeCA8PCAxNCkgXiAoeCA+Pj4gMylcbn1cblxuZnVuY3Rpb24gZ2FtbWExICh4KSB7XG4gIHJldHVybiAoeCA+Pj4gMTcgfCB4IDw8IDE1KSBeICh4ID4+PiAxOSB8IHggPDwgMTMpIF4gKHggPj4+IDEwKVxufVxuXG5TaGEyNTYucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoTSkge1xuICB2YXIgVyA9IHRoaXMuX3dcblxuICB2YXIgYSA9IHRoaXMuX2EgfCAwXG4gIHZhciBiID0gdGhpcy5fYiB8IDBcbiAgdmFyIGMgPSB0aGlzLl9jIHwgMFxuICB2YXIgZCA9IHRoaXMuX2QgfCAwXG4gIHZhciBlID0gdGhpcy5fZSB8IDBcbiAgdmFyIGYgPSB0aGlzLl9mIHwgMFxuICB2YXIgZyA9IHRoaXMuX2cgfCAwXG4gIHZhciBoID0gdGhpcy5faCB8IDBcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIFdbaV0gPSBNLnJlYWRJbnQzMkJFKGkgKiA0KVxuICBmb3IgKDsgaSA8IDY0OyArK2kpIFdbaV0gPSAoZ2FtbWExKFdbaSAtIDJdKSArIFdbaSAtIDddICsgZ2FtbWEwKFdbaSAtIDE1XSkgKyBXW2kgLSAxNl0pIHwgMFxuXG4gIGZvciAodmFyIGogPSAwOyBqIDwgNjQ7ICsraikge1xuICAgIHZhciBUMSA9IChoICsgc2lnbWExKGUpICsgY2goZSwgZiwgZykgKyBLW2pdICsgV1tqXSkgfCAwXG4gICAgdmFyIFQyID0gKHNpZ21hMChhKSArIG1haihhLCBiLCBjKSkgfCAwXG5cbiAgICBoID0gZ1xuICAgIGcgPSBmXG4gICAgZiA9IGVcbiAgICBlID0gKGQgKyBUMSkgfCAwXG4gICAgZCA9IGNcbiAgICBjID0gYlxuICAgIGIgPSBhXG4gICAgYSA9IChUMSArIFQyKSB8IDBcbiAgfVxuXG4gIHRoaXMuX2EgPSAoYSArIHRoaXMuX2EpIHwgMFxuICB0aGlzLl9iID0gKGIgKyB0aGlzLl9iKSB8IDBcbiAgdGhpcy5fYyA9IChjICsgdGhpcy5fYykgfCAwXG4gIHRoaXMuX2QgPSAoZCArIHRoaXMuX2QpIHwgMFxuICB0aGlzLl9lID0gKGUgKyB0aGlzLl9lKSB8IDBcbiAgdGhpcy5fZiA9IChmICsgdGhpcy5fZikgfCAwXG4gIHRoaXMuX2cgPSAoZyArIHRoaXMuX2cpIHwgMFxuICB0aGlzLl9oID0gKGggKyB0aGlzLl9oKSB8IDBcbn1cblxuU2hhMjU2LnByb3RvdHlwZS5faGFzaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIEggPSBCdWZmZXIuYWxsb2NVbnNhZmUoMzIpXG5cbiAgSC53cml0ZUludDMyQkUodGhpcy5fYSwgMClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYiwgNClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYywgOClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZCwgMTIpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2UsIDE2KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9mLCAyMClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZywgMjQpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2gsIDI4KVxuXG4gIHJldHVybiBIXG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2hhMjU2XG4iLCJ2YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgU0hBNTEyID0gcmVxdWlyZSgnLi9zaGE1MTInKVxudmFyIEhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbnZhciBXID0gbmV3IEFycmF5KDE2MClcblxuZnVuY3Rpb24gU2hhMzg0ICgpIHtcbiAgdGhpcy5pbml0KClcbiAgdGhpcy5fdyA9IFdcblxuICBIYXNoLmNhbGwodGhpcywgMTI4LCAxMTIpXG59XG5cbmluaGVyaXRzKFNoYTM4NCwgU0hBNTEyKVxuXG5TaGEzODQucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2FoID0gMHhjYmJiOWQ1ZFxuICB0aGlzLl9iaCA9IDB4NjI5YTI5MmFcbiAgdGhpcy5fY2ggPSAweDkxNTkwMTVhXG4gIHRoaXMuX2RoID0gMHgxNTJmZWNkOFxuICB0aGlzLl9laCA9IDB4NjczMzI2NjdcbiAgdGhpcy5fZmggPSAweDhlYjQ0YTg3XG4gIHRoaXMuX2doID0gMHhkYjBjMmUwZFxuICB0aGlzLl9oaCA9IDB4NDdiNTQ4MWRcblxuICB0aGlzLl9hbCA9IDB4YzEwNTllZDhcbiAgdGhpcy5fYmwgPSAweDM2N2NkNTA3XG4gIHRoaXMuX2NsID0gMHgzMDcwZGQxN1xuICB0aGlzLl9kbCA9IDB4ZjcwZTU5MzlcbiAgdGhpcy5fZWwgPSAweGZmYzAwYjMxXG4gIHRoaXMuX2ZsID0gMHg2ODU4MTUxMVxuICB0aGlzLl9nbCA9IDB4NjRmOThmYTdcbiAgdGhpcy5faGwgPSAweGJlZmE0ZmE0XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuU2hhMzg0LnByb3RvdHlwZS5faGFzaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIEggPSBCdWZmZXIuYWxsb2NVbnNhZmUoNDgpXG5cbiAgZnVuY3Rpb24gd3JpdGVJbnQ2NEJFIChoLCBsLCBvZmZzZXQpIHtcbiAgICBILndyaXRlSW50MzJCRShoLCBvZmZzZXQpXG4gICAgSC53cml0ZUludDMyQkUobCwgb2Zmc2V0ICsgNClcbiAgfVxuXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9haCwgdGhpcy5fYWwsIDApXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9iaCwgdGhpcy5fYmwsIDgpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9jaCwgdGhpcy5fY2wsIDE2KVxuICB3cml0ZUludDY0QkUodGhpcy5fZGgsIHRoaXMuX2RsLCAyNClcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2VoLCB0aGlzLl9lbCwgMzIpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9maCwgdGhpcy5fZmwsIDQwKVxuXG4gIHJldHVybiBIXG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2hhMzg0XG4iLCJ2YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgSGFzaCA9IHJlcXVpcmUoJy4vaGFzaCcpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxudmFyIEsgPSBbXG4gIDB4NDI4YTJmOTgsIDB4ZDcyOGFlMjIsIDB4NzEzNzQ0OTEsIDB4MjNlZjY1Y2QsXG4gIDB4YjVjMGZiY2YsIDB4ZWM0ZDNiMmYsIDB4ZTliNWRiYTUsIDB4ODE4OWRiYmMsXG4gIDB4Mzk1NmMyNWIsIDB4ZjM0OGI1MzgsIDB4NTlmMTExZjEsIDB4YjYwNWQwMTksXG4gIDB4OTIzZjgyYTQsIDB4YWYxOTRmOWIsIDB4YWIxYzVlZDUsIDB4ZGE2ZDgxMTgsXG4gIDB4ZDgwN2FhOTgsIDB4YTMwMzAyNDIsIDB4MTI4MzViMDEsIDB4NDU3MDZmYmUsXG4gIDB4MjQzMTg1YmUsIDB4NGVlNGIyOGMsIDB4NTUwYzdkYzMsIDB4ZDVmZmI0ZTIsXG4gIDB4NzJiZTVkNzQsIDB4ZjI3Yjg5NmYsIDB4ODBkZWIxZmUsIDB4M2IxNjk2YjEsXG4gIDB4OWJkYzA2YTcsIDB4MjVjNzEyMzUsIDB4YzE5YmYxNzQsIDB4Y2Y2OTI2OTQsXG4gIDB4ZTQ5YjY5YzEsIDB4OWVmMTRhZDIsIDB4ZWZiZTQ3ODYsIDB4Mzg0ZjI1ZTMsXG4gIDB4MGZjMTlkYzYsIDB4OGI4Y2Q1YjUsIDB4MjQwY2ExY2MsIDB4NzdhYzljNjUsXG4gIDB4MmRlOTJjNmYsIDB4NTkyYjAyNzUsIDB4NGE3NDg0YWEsIDB4NmVhNmU0ODMsXG4gIDB4NWNiMGE5ZGMsIDB4YmQ0MWZiZDQsIDB4NzZmOTg4ZGEsIDB4ODMxMTUzYjUsXG4gIDB4OTgzZTUxNTIsIDB4ZWU2NmRmYWIsIDB4YTgzMWM2NmQsIDB4MmRiNDMyMTAsXG4gIDB4YjAwMzI3YzgsIDB4OThmYjIxM2YsIDB4YmY1OTdmYzcsIDB4YmVlZjBlZTQsXG4gIDB4YzZlMDBiZjMsIDB4M2RhODhmYzIsIDB4ZDVhNzkxNDcsIDB4OTMwYWE3MjUsXG4gIDB4MDZjYTYzNTEsIDB4ZTAwMzgyNmYsIDB4MTQyOTI5NjcsIDB4MGEwZTZlNzAsXG4gIDB4MjdiNzBhODUsIDB4NDZkMjJmZmMsIDB4MmUxYjIxMzgsIDB4NWMyNmM5MjYsXG4gIDB4NGQyYzZkZmMsIDB4NWFjNDJhZWQsIDB4NTMzODBkMTMsIDB4OWQ5NWIzZGYsXG4gIDB4NjUwYTczNTQsIDB4OGJhZjYzZGUsIDB4NzY2YTBhYmIsIDB4M2M3N2IyYTgsXG4gIDB4ODFjMmM5MmUsIDB4NDdlZGFlZTYsIDB4OTI3MjJjODUsIDB4MTQ4MjM1M2IsXG4gIDB4YTJiZmU4YTEsIDB4NGNmMTAzNjQsIDB4YTgxYTY2NGIsIDB4YmM0MjMwMDEsXG4gIDB4YzI0YjhiNzAsIDB4ZDBmODk3OTEsIDB4Yzc2YzUxYTMsIDB4MDY1NGJlMzAsXG4gIDB4ZDE5MmU4MTksIDB4ZDZlZjUyMTgsIDB4ZDY5OTA2MjQsIDB4NTU2NWE5MTAsXG4gIDB4ZjQwZTM1ODUsIDB4NTc3MTIwMmEsIDB4MTA2YWEwNzAsIDB4MzJiYmQxYjgsXG4gIDB4MTlhNGMxMTYsIDB4YjhkMmQwYzgsIDB4MWUzNzZjMDgsIDB4NTE0MWFiNTMsXG4gIDB4Mjc0ODc3NGMsIDB4ZGY4ZWViOTksIDB4MzRiMGJjYjUsIDB4ZTE5YjQ4YTgsXG4gIDB4MzkxYzBjYjMsIDB4YzVjOTVhNjMsIDB4NGVkOGFhNGEsIDB4ZTM0MThhY2IsXG4gIDB4NWI5Y2NhNGYsIDB4Nzc2M2UzNzMsIDB4NjgyZTZmZjMsIDB4ZDZiMmI4YTMsXG4gIDB4NzQ4ZjgyZWUsIDB4NWRlZmIyZmMsIDB4NzhhNTYzNmYsIDB4NDMxNzJmNjAsXG4gIDB4ODRjODc4MTQsIDB4YTFmMGFiNzIsIDB4OGNjNzAyMDgsIDB4MWE2NDM5ZWMsXG4gIDB4OTBiZWZmZmEsIDB4MjM2MzFlMjgsIDB4YTQ1MDZjZWIsIDB4ZGU4MmJkZTksXG4gIDB4YmVmOWEzZjcsIDB4YjJjNjc5MTUsIDB4YzY3MTc4ZjIsIDB4ZTM3MjUzMmIsXG4gIDB4Y2EyNzNlY2UsIDB4ZWEyNjYxOWMsIDB4ZDE4NmI4YzcsIDB4MjFjMGMyMDcsXG4gIDB4ZWFkYTdkZDYsIDB4Y2RlMGViMWUsIDB4ZjU3ZDRmN2YsIDB4ZWU2ZWQxNzgsXG4gIDB4MDZmMDY3YWEsIDB4NzIxNzZmYmEsIDB4MGE2MzdkYzUsIDB4YTJjODk4YTYsXG4gIDB4MTEzZjk4MDQsIDB4YmVmOTBkYWUsIDB4MWI3MTBiMzUsIDB4MTMxYzQ3MWIsXG4gIDB4MjhkYjc3ZjUsIDB4MjMwNDdkODQsIDB4MzJjYWFiN2IsIDB4NDBjNzI0OTMsXG4gIDB4M2M5ZWJlMGEsIDB4MTVjOWJlYmMsIDB4NDMxZDY3YzQsIDB4OWMxMDBkNGMsXG4gIDB4NGNjNWQ0YmUsIDB4Y2IzZTQyYjYsIDB4NTk3ZjI5OWMsIDB4ZmM2NTdlMmEsXG4gIDB4NWZjYjZmYWIsIDB4M2FkNmZhZWMsIDB4NmM0NDE5OGMsIDB4NGE0NzU4MTdcbl1cblxudmFyIFcgPSBuZXcgQXJyYXkoMTYwKVxuXG5mdW5jdGlvbiBTaGE1MTIgKCkge1xuICB0aGlzLmluaXQoKVxuICB0aGlzLl93ID0gV1xuXG4gIEhhc2guY2FsbCh0aGlzLCAxMjgsIDExMilcbn1cblxuaW5oZXJpdHMoU2hhNTEyLCBIYXNoKVxuXG5TaGE1MTIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2FoID0gMHg2YTA5ZTY2N1xuICB0aGlzLl9iaCA9IDB4YmI2N2FlODVcbiAgdGhpcy5fY2ggPSAweDNjNmVmMzcyXG4gIHRoaXMuX2RoID0gMHhhNTRmZjUzYVxuICB0aGlzLl9laCA9IDB4NTEwZTUyN2ZcbiAgdGhpcy5fZmggPSAweDliMDU2ODhjXG4gIHRoaXMuX2doID0gMHgxZjgzZDlhYlxuICB0aGlzLl9oaCA9IDB4NWJlMGNkMTlcblxuICB0aGlzLl9hbCA9IDB4ZjNiY2M5MDhcbiAgdGhpcy5fYmwgPSAweDg0Y2FhNzNiXG4gIHRoaXMuX2NsID0gMHhmZTk0ZjgyYlxuICB0aGlzLl9kbCA9IDB4NWYxZDM2ZjFcbiAgdGhpcy5fZWwgPSAweGFkZTY4MmQxXG4gIHRoaXMuX2ZsID0gMHgyYjNlNmMxZlxuICB0aGlzLl9nbCA9IDB4ZmI0MWJkNmJcbiAgdGhpcy5faGwgPSAweDEzN2UyMTc5XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuZnVuY3Rpb24gQ2ggKHgsIHksIHopIHtcbiAgcmV0dXJuIHogXiAoeCAmICh5IF4geikpXG59XG5cbmZ1bmN0aW9uIG1haiAoeCwgeSwgeikge1xuICByZXR1cm4gKHggJiB5KSB8ICh6ICYgKHggfCB5KSlcbn1cblxuZnVuY3Rpb24gc2lnbWEwICh4LCB4bCkge1xuICByZXR1cm4gKHggPj4+IDI4IHwgeGwgPDwgNCkgXiAoeGwgPj4+IDIgfCB4IDw8IDMwKSBeICh4bCA+Pj4gNyB8IHggPDwgMjUpXG59XG5cbmZ1bmN0aW9uIHNpZ21hMSAoeCwgeGwpIHtcbiAgcmV0dXJuICh4ID4+PiAxNCB8IHhsIDw8IDE4KSBeICh4ID4+PiAxOCB8IHhsIDw8IDE0KSBeICh4bCA+Pj4gOSB8IHggPDwgMjMpXG59XG5cbmZ1bmN0aW9uIEdhbW1hMCAoeCwgeGwpIHtcbiAgcmV0dXJuICh4ID4+PiAxIHwgeGwgPDwgMzEpIF4gKHggPj4+IDggfCB4bCA8PCAyNCkgXiAoeCA+Pj4gNylcbn1cblxuZnVuY3Rpb24gR2FtbWEwbCAoeCwgeGwpIHtcbiAgcmV0dXJuICh4ID4+PiAxIHwgeGwgPDwgMzEpIF4gKHggPj4+IDggfCB4bCA8PCAyNCkgXiAoeCA+Pj4gNyB8IHhsIDw8IDI1KVxufVxuXG5mdW5jdGlvbiBHYW1tYTEgKHgsIHhsKSB7XG4gIHJldHVybiAoeCA+Pj4gMTkgfCB4bCA8PCAxMykgXiAoeGwgPj4+IDI5IHwgeCA8PCAzKSBeICh4ID4+PiA2KVxufVxuXG5mdW5jdGlvbiBHYW1tYTFsICh4LCB4bCkge1xuICByZXR1cm4gKHggPj4+IDE5IHwgeGwgPDwgMTMpIF4gKHhsID4+PiAyOSB8IHggPDwgMykgXiAoeCA+Pj4gNiB8IHhsIDw8IDI2KVxufVxuXG5mdW5jdGlvbiBnZXRDYXJyeSAoYSwgYikge1xuICByZXR1cm4gKGEgPj4+IDApIDwgKGIgPj4+IDApID8gMSA6IDBcbn1cblxuU2hhNTEyLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKE0pIHtcbiAgdmFyIFcgPSB0aGlzLl93XG5cbiAgdmFyIGFoID0gdGhpcy5fYWggfCAwXG4gIHZhciBiaCA9IHRoaXMuX2JoIHwgMFxuICB2YXIgY2ggPSB0aGlzLl9jaCB8IDBcbiAgdmFyIGRoID0gdGhpcy5fZGggfCAwXG4gIHZhciBlaCA9IHRoaXMuX2VoIHwgMFxuICB2YXIgZmggPSB0aGlzLl9maCB8IDBcbiAgdmFyIGdoID0gdGhpcy5fZ2ggfCAwXG4gIHZhciBoaCA9IHRoaXMuX2hoIHwgMFxuXG4gIHZhciBhbCA9IHRoaXMuX2FsIHwgMFxuICB2YXIgYmwgPSB0aGlzLl9ibCB8IDBcbiAgdmFyIGNsID0gdGhpcy5fY2wgfCAwXG4gIHZhciBkbCA9IHRoaXMuX2RsIHwgMFxuICB2YXIgZWwgPSB0aGlzLl9lbCB8IDBcbiAgdmFyIGZsID0gdGhpcy5fZmwgfCAwXG4gIHZhciBnbCA9IHRoaXMuX2dsIHwgMFxuICB2YXIgaGwgPSB0aGlzLl9obCB8IDBcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDMyOyBpICs9IDIpIHtcbiAgICBXW2ldID0gTS5yZWFkSW50MzJCRShpICogNClcbiAgICBXW2kgKyAxXSA9IE0ucmVhZEludDMyQkUoaSAqIDQgKyA0KVxuICB9XG4gIGZvciAoOyBpIDwgMTYwOyBpICs9IDIpIHtcbiAgICB2YXIgeGggPSBXW2kgLSAxNSAqIDJdXG4gICAgdmFyIHhsID0gV1tpIC0gMTUgKiAyICsgMV1cbiAgICB2YXIgZ2FtbWEwID0gR2FtbWEwKHhoLCB4bClcbiAgICB2YXIgZ2FtbWEwbCA9IEdhbW1hMGwoeGwsIHhoKVxuXG4gICAgeGggPSBXW2kgLSAyICogMl1cbiAgICB4bCA9IFdbaSAtIDIgKiAyICsgMV1cbiAgICB2YXIgZ2FtbWExID0gR2FtbWExKHhoLCB4bClcbiAgICB2YXIgZ2FtbWExbCA9IEdhbW1hMWwoeGwsIHhoKVxuXG4gICAgLy8gV1tpXSA9IGdhbW1hMCArIFdbaSAtIDddICsgZ2FtbWExICsgV1tpIC0gMTZdXG4gICAgdmFyIFdpN2ggPSBXW2kgLSA3ICogMl1cbiAgICB2YXIgV2k3bCA9IFdbaSAtIDcgKiAyICsgMV1cblxuICAgIHZhciBXaTE2aCA9IFdbaSAtIDE2ICogMl1cbiAgICB2YXIgV2kxNmwgPSBXW2kgLSAxNiAqIDIgKyAxXVxuXG4gICAgdmFyIFdpbCA9IChnYW1tYTBsICsgV2k3bCkgfCAwXG4gICAgdmFyIFdpaCA9IChnYW1tYTAgKyBXaTdoICsgZ2V0Q2FycnkoV2lsLCBnYW1tYTBsKSkgfCAwXG4gICAgV2lsID0gKFdpbCArIGdhbW1hMWwpIHwgMFxuICAgIFdpaCA9IChXaWggKyBnYW1tYTEgKyBnZXRDYXJyeShXaWwsIGdhbW1hMWwpKSB8IDBcbiAgICBXaWwgPSAoV2lsICsgV2kxNmwpIHwgMFxuICAgIFdpaCA9IChXaWggKyBXaTE2aCArIGdldENhcnJ5KFdpbCwgV2kxNmwpKSB8IDBcblxuICAgIFdbaV0gPSBXaWhcbiAgICBXW2kgKyAxXSA9IFdpbFxuICB9XG5cbiAgZm9yICh2YXIgaiA9IDA7IGogPCAxNjA7IGogKz0gMikge1xuICAgIFdpaCA9IFdbal1cbiAgICBXaWwgPSBXW2ogKyAxXVxuXG4gICAgdmFyIG1hamggPSBtYWooYWgsIGJoLCBjaClcbiAgICB2YXIgbWFqbCA9IG1haihhbCwgYmwsIGNsKVxuXG4gICAgdmFyIHNpZ21hMGggPSBzaWdtYTAoYWgsIGFsKVxuICAgIHZhciBzaWdtYTBsID0gc2lnbWEwKGFsLCBhaClcbiAgICB2YXIgc2lnbWExaCA9IHNpZ21hMShlaCwgZWwpXG4gICAgdmFyIHNpZ21hMWwgPSBzaWdtYTEoZWwsIGVoKVxuXG4gICAgLy8gdDEgPSBoICsgc2lnbWExICsgY2ggKyBLW2pdICsgV1tqXVxuICAgIHZhciBLaWggPSBLW2pdXG4gICAgdmFyIEtpbCA9IEtbaiArIDFdXG5cbiAgICB2YXIgY2hoID0gQ2goZWgsIGZoLCBnaClcbiAgICB2YXIgY2hsID0gQ2goZWwsIGZsLCBnbClcblxuICAgIHZhciB0MWwgPSAoaGwgKyBzaWdtYTFsKSB8IDBcbiAgICB2YXIgdDFoID0gKGhoICsgc2lnbWExaCArIGdldENhcnJ5KHQxbCwgaGwpKSB8IDBcbiAgICB0MWwgPSAodDFsICsgY2hsKSB8IDBcbiAgICB0MWggPSAodDFoICsgY2hoICsgZ2V0Q2FycnkodDFsLCBjaGwpKSB8IDBcbiAgICB0MWwgPSAodDFsICsgS2lsKSB8IDBcbiAgICB0MWggPSAodDFoICsgS2loICsgZ2V0Q2FycnkodDFsLCBLaWwpKSB8IDBcbiAgICB0MWwgPSAodDFsICsgV2lsKSB8IDBcbiAgICB0MWggPSAodDFoICsgV2loICsgZ2V0Q2FycnkodDFsLCBXaWwpKSB8IDBcblxuICAgIC8vIHQyID0gc2lnbWEwICsgbWFqXG4gICAgdmFyIHQybCA9IChzaWdtYTBsICsgbWFqbCkgfCAwXG4gICAgdmFyIHQyaCA9IChzaWdtYTBoICsgbWFqaCArIGdldENhcnJ5KHQybCwgc2lnbWEwbCkpIHwgMFxuXG4gICAgaGggPSBnaFxuICAgIGhsID0gZ2xcbiAgICBnaCA9IGZoXG4gICAgZ2wgPSBmbFxuICAgIGZoID0gZWhcbiAgICBmbCA9IGVsXG4gICAgZWwgPSAoZGwgKyB0MWwpIHwgMFxuICAgIGVoID0gKGRoICsgdDFoICsgZ2V0Q2FycnkoZWwsIGRsKSkgfCAwXG4gICAgZGggPSBjaFxuICAgIGRsID0gY2xcbiAgICBjaCA9IGJoXG4gICAgY2wgPSBibFxuICAgIGJoID0gYWhcbiAgICBibCA9IGFsXG4gICAgYWwgPSAodDFsICsgdDJsKSB8IDBcbiAgICBhaCA9ICh0MWggKyB0MmggKyBnZXRDYXJyeShhbCwgdDFsKSkgfCAwXG4gIH1cblxuICB0aGlzLl9hbCA9ICh0aGlzLl9hbCArIGFsKSB8IDBcbiAgdGhpcy5fYmwgPSAodGhpcy5fYmwgKyBibCkgfCAwXG4gIHRoaXMuX2NsID0gKHRoaXMuX2NsICsgY2wpIHwgMFxuICB0aGlzLl9kbCA9ICh0aGlzLl9kbCArIGRsKSB8IDBcbiAgdGhpcy5fZWwgPSAodGhpcy5fZWwgKyBlbCkgfCAwXG4gIHRoaXMuX2ZsID0gKHRoaXMuX2ZsICsgZmwpIHwgMFxuICB0aGlzLl9nbCA9ICh0aGlzLl9nbCArIGdsKSB8IDBcbiAgdGhpcy5faGwgPSAodGhpcy5faGwgKyBobCkgfCAwXG5cbiAgdGhpcy5fYWggPSAodGhpcy5fYWggKyBhaCArIGdldENhcnJ5KHRoaXMuX2FsLCBhbCkpIHwgMFxuICB0aGlzLl9iaCA9ICh0aGlzLl9iaCArIGJoICsgZ2V0Q2FycnkodGhpcy5fYmwsIGJsKSkgfCAwXG4gIHRoaXMuX2NoID0gKHRoaXMuX2NoICsgY2ggKyBnZXRDYXJyeSh0aGlzLl9jbCwgY2wpKSB8IDBcbiAgdGhpcy5fZGggPSAodGhpcy5fZGggKyBkaCArIGdldENhcnJ5KHRoaXMuX2RsLCBkbCkpIHwgMFxuICB0aGlzLl9laCA9ICh0aGlzLl9laCArIGVoICsgZ2V0Q2FycnkodGhpcy5fZWwsIGVsKSkgfCAwXG4gIHRoaXMuX2ZoID0gKHRoaXMuX2ZoICsgZmggKyBnZXRDYXJyeSh0aGlzLl9mbCwgZmwpKSB8IDBcbiAgdGhpcy5fZ2ggPSAodGhpcy5fZ2ggKyBnaCArIGdldENhcnJ5KHRoaXMuX2dsLCBnbCkpIHwgMFxuICB0aGlzLl9oaCA9ICh0aGlzLl9oaCArIGhoICsgZ2V0Q2FycnkodGhpcy5faGwsIGhsKSkgfCAwXG59XG5cblNoYTUxMi5wcm90b3R5cGUuX2hhc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBIID0gQnVmZmVyLmFsbG9jVW5zYWZlKDY0KVxuXG4gIGZ1bmN0aW9uIHdyaXRlSW50NjRCRSAoaCwgbCwgb2Zmc2V0KSB7XG4gICAgSC53cml0ZUludDMyQkUoaCwgb2Zmc2V0KVxuICAgIEgud3JpdGVJbnQzMkJFKGwsIG9mZnNldCArIDQpXG4gIH1cblxuICB3cml0ZUludDY0QkUodGhpcy5fYWgsIHRoaXMuX2FsLCAwKVxuICB3cml0ZUludDY0QkUodGhpcy5fYmgsIHRoaXMuX2JsLCA4KVxuICB3cml0ZUludDY0QkUodGhpcy5fY2gsIHRoaXMuX2NsLCAxNilcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2RoLCB0aGlzLl9kbCwgMjQpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9laCwgdGhpcy5fZWwsIDMyKVxuICB3cml0ZUludDY0QkUodGhpcy5fZmgsIHRoaXMuX2ZsLCA0MClcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2doLCB0aGlzLl9nbCwgNDgpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9oaCwgdGhpcy5faGwsIDU2KVxuXG4gIHJldHVybiBIXG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2hhNTEyXG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW07XG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmluaGVyaXRzKFN0cmVhbSwgRUUpO1xuU3RyZWFtLlJlYWRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzJyk7XG5TdHJlYW0uV3JpdGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUuanMnKTtcblN0cmVhbS5EdXBsZXggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzJyk7XG5TdHJlYW0uVHJhbnNmb3JtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcycpO1xuU3RyZWFtLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzJyk7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuNC54XG5TdHJlYW0uU3RyZWFtID0gU3RyZWFtO1xuXG5cblxuLy8gb2xkLXN0eWxlIHN0cmVhbXMuICBOb3RlIHRoYXQgdGhlIHBpcGUgbWV0aG9kICh0aGUgb25seSByZWxldmFudFxuLy8gcGFydCBvZiB0aGlzIGNsYXNzKSBpcyBvdmVycmlkZGVuIGluIHRoZSBSZWFkYWJsZSBjbGFzcy5cblxuZnVuY3Rpb24gU3RyZWFtKCkge1xuICBFRS5jYWxsKHRoaXMpO1xufVxuXG5TdHJlYW0ucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbihkZXN0LCBvcHRpb25zKSB7XG4gIHZhciBzb3VyY2UgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGlmIChkZXN0LndyaXRhYmxlKSB7XG4gICAgICBpZiAoZmFsc2UgPT09IGRlc3Qud3JpdGUoY2h1bmspICYmIHNvdXJjZS5wYXVzZSkge1xuICAgICAgICBzb3VyY2UucGF1c2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2RhdGEnLCBvbmRhdGEpO1xuXG4gIGZ1bmN0aW9uIG9uZHJhaW4oKSB7XG4gICAgaWYgKHNvdXJjZS5yZWFkYWJsZSAmJiBzb3VyY2UucmVzdW1lKSB7XG4gICAgICBzb3VyY2UucmVzdW1lKCk7XG4gICAgfVxuICB9XG5cbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICAvLyBJZiB0aGUgJ2VuZCcgb3B0aW9uIGlzIG5vdCBzdXBwbGllZCwgZGVzdC5lbmQoKSB3aWxsIGJlIGNhbGxlZCB3aGVuXG4gIC8vIHNvdXJjZSBnZXRzIHRoZSAnZW5kJyBvciAnY2xvc2UnIGV2ZW50cy4gIE9ubHkgZGVzdC5lbmQoKSBvbmNlLlxuICBpZiAoIWRlc3QuX2lzU3RkaW8gJiYgKCFvcHRpb25zIHx8IG9wdGlvbnMuZW5kICE9PSBmYWxzZSkpIHtcbiAgICBzb3VyY2Uub24oJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2Uub24oJ2Nsb3NlJywgb25jbG9zZSk7XG4gIH1cblxuICB2YXIgZGlkT25FbmQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBpZiAodHlwZW9mIGRlc3QuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgZGVzdC5kZXN0cm95KCk7XG4gIH1cblxuICAvLyBkb24ndCBsZWF2ZSBkYW5nbGluZyBwaXBlcyB3aGVuIHRoZXJlIGFyZSBlcnJvcnMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBjbGVhbnVwKCk7XG4gICAgaWYgKEVFLmxpc3RlbmVyQ291bnQodGhpcywgJ2Vycm9yJykgPT09IDApIHtcbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgc3RyZWFtIGVycm9yIGluIHBpcGUuXG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICBkZXN0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIHJlbW92ZSBhbGwgdGhlIGV2ZW50IGxpc3RlbmVycyB0aGF0IHdlcmUgYWRkZWQuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG4gIH1cblxuICBzb3VyY2Uub24oJ2VuZCcsIGNsZWFudXApO1xuICBzb3VyY2Uub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0LmVtaXQoJ3BpcGUnLCBzb3VyY2UpO1xuXG4gIC8vIEFsbG93IGZvciB1bml4LWxpa2UgdXNhZ2U6IEEucGlwZShCKS5waXBlKEMpXG4gIHJldHVybiBkZXN0O1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgaXNFbmNvZGluZyA9IEJ1ZmZlci5pc0VuY29kaW5nIHx8IGZ1bmN0aW9uIChlbmNvZGluZykge1xuICBlbmNvZGluZyA9ICcnICsgZW5jb2Rpbmc7XG4gIHN3aXRjaCAoZW5jb2RpbmcgJiYgZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6Y2FzZSAndXRmOCc6Y2FzZSAndXRmLTgnOmNhc2UgJ2FzY2lpJzpjYXNlICdiaW5hcnknOmNhc2UgJ2Jhc2U2NCc6Y2FzZSAndWNzMic6Y2FzZSAndWNzLTInOmNhc2UgJ3V0ZjE2bGUnOmNhc2UgJ3V0Zi0xNmxlJzpjYXNlICdyYXcnOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuZnVuY3Rpb24gX25vcm1hbGl6ZUVuY29kaW5nKGVuYykge1xuICBpZiAoIWVuYykgcmV0dXJuICd1dGY4JztcbiAgdmFyIHJldHJpZWQ7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmMpIHtcbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gJ3V0ZjgnO1xuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuICd1dGYxNmxlJztcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gJ2xhdGluMSc7XG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGVuYztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChyZXRyaWVkKSByZXR1cm47IC8vIHVuZGVmaW5lZFxuICAgICAgICBlbmMgPSAoJycgKyBlbmMpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHJpZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxuLy8gRG8gbm90IGNhY2hlIGBCdWZmZXIuaXNFbmNvZGluZ2Agd2hlbiBjaGVja2luZyBlbmNvZGluZyBuYW1lcyBhcyBzb21lXG4vLyBtb2R1bGVzIG1vbmtleS1wYXRjaCBpdCB0byBzdXBwb3J0IGFkZGl0aW9uYWwgZW5jb2RpbmdzXG5mdW5jdGlvbiBub3JtYWxpemVFbmNvZGluZyhlbmMpIHtcbiAgdmFyIG5lbmMgPSBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKTtcbiAgaWYgKHR5cGVvZiBuZW5jICE9PSAnc3RyaW5nJyAmJiAoQnVmZmVyLmlzRW5jb2RpbmcgPT09IGlzRW5jb2RpbmcgfHwgIWlzRW5jb2RpbmcoZW5jKSkpIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuYyk7XG4gIHJldHVybiBuZW5jIHx8IGVuYztcbn1cblxuLy8gU3RyaW5nRGVjb2RlciBwcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIGVmZmljaWVudGx5IHNwbGl0dGluZyBhIHNlcmllcyBvZlxuLy8gYnVmZmVycyBpbnRvIGEgc2VyaWVzIG9mIEpTIHN0cmluZ3Mgd2l0aG91dCBicmVha2luZyBhcGFydCBtdWx0aS1ieXRlXG4vLyBjaGFyYWN0ZXJzLlxuZXhwb3J0cy5TdHJpbmdEZWNvZGVyID0gU3RyaW5nRGVjb2RlcjtcbmZ1bmN0aW9uIFN0cmluZ0RlY29kZXIoZW5jb2RpbmcpIHtcbiAgdGhpcy5lbmNvZGluZyA9IG5vcm1hbGl6ZUVuY29kaW5nKGVuY29kaW5nKTtcbiAgdmFyIG5iO1xuICBzd2l0Y2ggKHRoaXMuZW5jb2RpbmcpIHtcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIHRoaXMudGV4dCA9IHV0ZjE2VGV4dDtcbiAgICAgIHRoaXMuZW5kID0gdXRmMTZFbmQ7XG4gICAgICBuYiA9IDQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd1dGY4JzpcbiAgICAgIHRoaXMuZmlsbExhc3QgPSB1dGY4RmlsbExhc3Q7XG4gICAgICBuYiA9IDQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgdGhpcy50ZXh0ID0gYmFzZTY0VGV4dDtcbiAgICAgIHRoaXMuZW5kID0gYmFzZTY0RW5kO1xuICAgICAgbmIgPSAzO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMud3JpdGUgPSBzaW1wbGVXcml0ZTtcbiAgICAgIHRoaXMuZW5kID0gc2ltcGxlRW5kO1xuICAgICAgcmV0dXJuO1xuICB9XG4gIHRoaXMubGFzdE5lZWQgPSAwO1xuICB0aGlzLmxhc3RUb3RhbCA9IDA7XG4gIHRoaXMubGFzdENoYXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobmIpO1xufVxuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChidWYpIHtcbiAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgdmFyIHI7XG4gIHZhciBpO1xuICBpZiAodGhpcy5sYXN0TmVlZCkge1xuICAgIHIgPSB0aGlzLmZpbGxMYXN0KGJ1Zik7XG4gICAgaWYgKHIgPT09IHVuZGVmaW5lZCkgcmV0dXJuICcnO1xuICAgIGkgPSB0aGlzLmxhc3ROZWVkO1xuICAgIHRoaXMubGFzdE5lZWQgPSAwO1xuICB9IGVsc2Uge1xuICAgIGkgPSAwO1xuICB9XG4gIGlmIChpIDwgYnVmLmxlbmd0aCkgcmV0dXJuIHIgPyByICsgdGhpcy50ZXh0KGJ1ZiwgaSkgOiB0aGlzLnRleHQoYnVmLCBpKTtcbiAgcmV0dXJuIHIgfHwgJyc7XG59O1xuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSB1dGY4RW5kO1xuXG4vLyBSZXR1cm5zIG9ubHkgY29tcGxldGUgY2hhcmFjdGVycyBpbiBhIEJ1ZmZlclxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUudGV4dCA9IHV0ZjhUZXh0O1xuXG4vLyBBdHRlbXB0cyB0byBjb21wbGV0ZSBhIHBhcnRpYWwgbm9uLVVURi04IGNoYXJhY3RlciB1c2luZyBieXRlcyBmcm9tIGEgQnVmZmVyXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5maWxsTGFzdCA9IGZ1bmN0aW9uIChidWYpIHtcbiAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkge1xuICAgIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZCwgMCwgdGhpcy5sYXN0TmVlZCk7XG4gICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpO1xuICB9XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZCwgMCwgYnVmLmxlbmd0aCk7XG4gIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDtcbn07XG5cbi8vIENoZWNrcyB0aGUgdHlwZSBvZiBhIFVURi04IGJ5dGUsIHdoZXRoZXIgaXQncyBBU0NJSSwgYSBsZWFkaW5nIGJ5dGUsIG9yIGFcbi8vIGNvbnRpbnVhdGlvbiBieXRlLiBJZiBhbiBpbnZhbGlkIGJ5dGUgaXMgZGV0ZWN0ZWQsIC0yIGlzIHJldHVybmVkLlxuZnVuY3Rpb24gdXRmOENoZWNrQnl0ZShieXRlKSB7XG4gIGlmIChieXRlIDw9IDB4N0YpIHJldHVybiAwO2Vsc2UgaWYgKGJ5dGUgPj4gNSA9PT0gMHgwNikgcmV0dXJuIDI7ZWxzZSBpZiAoYnl0ZSA+PiA0ID09PSAweDBFKSByZXR1cm4gMztlbHNlIGlmIChieXRlID4+IDMgPT09IDB4MUUpIHJldHVybiA0O1xuICByZXR1cm4gYnl0ZSA+PiA2ID09PSAweDAyID8gLTEgOiAtMjtcbn1cblxuLy8gQ2hlY2tzIGF0IG1vc3QgMyBieXRlcyBhdCB0aGUgZW5kIG9mIGEgQnVmZmVyIGluIG9yZGVyIHRvIGRldGVjdCBhblxuLy8gaW5jb21wbGV0ZSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3Rlci4gVGhlIHRvdGFsIG51bWJlciBvZiBieXRlcyAoMiwgMywgb3IgNClcbi8vIG5lZWRlZCB0byBjb21wbGV0ZSB0aGUgVVRGLTggY2hhcmFjdGVyIChpZiBhcHBsaWNhYmxlKSBhcmUgcmV0dXJuZWQuXG5mdW5jdGlvbiB1dGY4Q2hlY2tJbmNvbXBsZXRlKHNlbGYsIGJ1ZiwgaSkge1xuICB2YXIgaiA9IGJ1Zi5sZW5ndGggLSAxO1xuICBpZiAoaiA8IGkpIHJldHVybiAwO1xuICB2YXIgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMTtcbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgaWYgKC0taiA8IGkgfHwgbmIgPT09IC0yKSByZXR1cm4gMDtcbiAgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMjtcbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgaWYgKC0taiA8IGkgfHwgbmIgPT09IC0yKSByZXR1cm4gMDtcbiAgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkge1xuICAgICAgaWYgKG5iID09PSAyKSBuYiA9IDA7ZWxzZSBzZWxmLmxhc3ROZWVkID0gbmIgLSAzO1xuICAgIH1cbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vIFZhbGlkYXRlcyBhcyBtYW55IGNvbnRpbnVhdGlvbiBieXRlcyBmb3IgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciBhc1xuLy8gbmVlZGVkIG9yIGFyZSBhdmFpbGFibGUuIElmIHdlIHNlZSBhIG5vbi1jb250aW51YXRpb24gYnl0ZSB3aGVyZSB3ZSBleHBlY3Rcbi8vIG9uZSwgd2UgXCJyZXBsYWNlXCIgdGhlIHZhbGlkYXRlZCBjb250aW51YXRpb24gYnl0ZXMgd2UndmUgc2VlbiBzbyBmYXIgd2l0aFxuLy8gYSBzaW5nbGUgVVRGLTggcmVwbGFjZW1lbnQgY2hhcmFjdGVyICgnXFx1ZmZmZCcpLCB0byBtYXRjaCB2OCdzIFVURi04IGRlY29kaW5nXG4vLyBiZWhhdmlvci4gVGhlIGNvbnRpbnVhdGlvbiBieXRlIGNoZWNrIGlzIGluY2x1ZGVkIHRocmVlIHRpbWVzIGluIHRoZSBjYXNlXG4vLyB3aGVyZSBhbGwgb2YgdGhlIGNvbnRpbnVhdGlvbiBieXRlcyBmb3IgYSBjaGFyYWN0ZXIgZXhpc3QgaW4gdGhlIHNhbWUgYnVmZmVyLlxuLy8gSXQgaXMgYWxzbyBkb25lIHRoaXMgd2F5IGFzIGEgc2xpZ2h0IHBlcmZvcm1hbmNlIGluY3JlYXNlIGluc3RlYWQgb2YgdXNpbmcgYVxuLy8gbG9vcC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0V4dHJhQnl0ZXMoc2VsZiwgYnVmLCBwKSB7XG4gIGlmICgoYnVmWzBdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICBzZWxmLmxhc3ROZWVkID0gMDtcbiAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICB9XG4gIGlmIChzZWxmLmxhc3ROZWVkID4gMSAmJiBidWYubGVuZ3RoID4gMSkge1xuICAgIGlmICgoYnVmWzFdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICAgIHNlbGYubGFzdE5lZWQgPSAxO1xuICAgICAgcmV0dXJuICdcXHVmZmZkJztcbiAgICB9XG4gICAgaWYgKHNlbGYubGFzdE5lZWQgPiAyICYmIGJ1Zi5sZW5ndGggPiAyKSB7XG4gICAgICBpZiAoKGJ1ZlsyXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgICAgIHNlbGYubGFzdE5lZWQgPSAyO1xuICAgICAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBBdHRlbXB0cyB0byBjb21wbGV0ZSBhIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyIHVzaW5nIGJ5dGVzIGZyb20gYSBCdWZmZXIuXG5mdW5jdGlvbiB1dGY4RmlsbExhc3QoYnVmKSB7XG4gIHZhciBwID0gdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkO1xuICB2YXIgciA9IHV0ZjhDaGVja0V4dHJhQnl0ZXModGhpcywgYnVmLCBwKTtcbiAgaWYgKHIgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHI7XG4gIGlmICh0aGlzLmxhc3ROZWVkIDw9IGJ1Zi5sZW5ndGgpIHtcbiAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCBwLCAwLCB0aGlzLmxhc3ROZWVkKTtcbiAgICByZXR1cm4gdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCB0aGlzLmxhc3RUb3RhbCk7XG4gIH1cbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgYnVmLmxlbmd0aCk7XG4gIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDtcbn1cblxuLy8gUmV0dXJucyBhbGwgY29tcGxldGUgVVRGLTggY2hhcmFjdGVycyBpbiBhIEJ1ZmZlci4gSWYgdGhlIEJ1ZmZlciBlbmRlZCBvbiBhXG4vLyBwYXJ0aWFsIGNoYXJhY3RlciwgdGhlIGNoYXJhY3RlcidzIGJ5dGVzIGFyZSBidWZmZXJlZCB1bnRpbCB0aGUgcmVxdWlyZWRcbi8vIG51bWJlciBvZiBieXRlcyBhcmUgYXZhaWxhYmxlLlxuZnVuY3Rpb24gdXRmOFRleHQoYnVmLCBpKSB7XG4gIHZhciB0b3RhbCA9IHV0ZjhDaGVja0luY29tcGxldGUodGhpcywgYnVmLCBpKTtcbiAgaWYgKCF0aGlzLmxhc3ROZWVkKSByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSk7XG4gIHRoaXMubGFzdFRvdGFsID0gdG90YWw7XG4gIHZhciBlbmQgPSBidWYubGVuZ3RoIC0gKHRvdGFsIC0gdGhpcy5sYXN0TmVlZCk7XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIDAsIGVuZCk7XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjgnLCBpLCBlbmQpO1xufVxuXG4vLyBGb3IgVVRGLTgsIGEgcmVwbGFjZW1lbnQgY2hhcmFjdGVyIGlzIGFkZGVkIHdoZW4gZW5kaW5nIG9uIGEgcGFydGlhbFxuLy8gY2hhcmFjdGVyLlxuZnVuY3Rpb24gdXRmOEVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyAnXFx1ZmZmZCc7XG4gIHJldHVybiByO1xufVxuXG4vLyBVVEYtMTZMRSB0eXBpY2FsbHkgbmVlZHMgdHdvIGJ5dGVzIHBlciBjaGFyYWN0ZXIsIGJ1dCBldmVuIGlmIHdlIGhhdmUgYW4gZXZlblxuLy8gbnVtYmVyIG9mIGJ5dGVzIGF2YWlsYWJsZSwgd2UgbmVlZCB0byBjaGVjayBpZiB3ZSBlbmQgb24gYSBsZWFkaW5nL2hpZ2hcbi8vIHN1cnJvZ2F0ZS4gSW4gdGhhdCBjYXNlLCB3ZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBuZXh0IHR3byBieXRlcyBpbiBvcmRlciB0b1xuLy8gZGVjb2RlIHRoZSBsYXN0IGNoYXJhY3RlciBwcm9wZXJseS5cbmZ1bmN0aW9uIHV0ZjE2VGV4dChidWYsIGkpIHtcbiAgaWYgKChidWYubGVuZ3RoIC0gaSkgJSAyID09PSAwKSB7XG4gICAgdmFyIHIgPSBidWYudG9TdHJpbmcoJ3V0ZjE2bGUnLCBpKTtcbiAgICBpZiAocikge1xuICAgICAgdmFyIGMgPSByLmNoYXJDb2RlQXQoci5sZW5ndGggLSAxKTtcbiAgICAgIGlmIChjID49IDB4RDgwMCAmJiBjIDw9IDB4REJGRikge1xuICAgICAgICB0aGlzLmxhc3ROZWVkID0gMjtcbiAgICAgICAgdGhpcy5sYXN0VG90YWwgPSA0O1xuICAgICAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTtcbiAgICAgICAgdGhpcy5sYXN0Q2hhclsxXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gICAgICAgIHJldHVybiByLnNsaWNlKDAsIC0xKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgdGhpcy5sYXN0TmVlZCA9IDE7XG4gIHRoaXMubGFzdFRvdGFsID0gMjtcbiAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjE2bGUnLCBpLCBidWYubGVuZ3RoIC0gMSk7XG59XG5cbi8vIEZvciBVVEYtMTZMRSB3ZSBkbyBub3QgZXhwbGljaXRseSBhcHBlbmQgc3BlY2lhbCByZXBsYWNlbWVudCBjaGFyYWN0ZXJzIGlmIHdlXG4vLyBlbmQgb24gYSBwYXJ0aWFsIGNoYXJhY3Rlciwgd2Ugc2ltcGx5IGxldCB2OCBoYW5kbGUgdGhhdC5cbmZ1bmN0aW9uIHV0ZjE2RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSB7XG4gICAgdmFyIGVuZCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDtcbiAgICByZXR1cm4gciArIHRoaXMubGFzdENoYXIudG9TdHJpbmcoJ3V0ZjE2bGUnLCAwLCBlbmQpO1xuICB9XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBiYXNlNjRUZXh0KGJ1ZiwgaSkge1xuICB2YXIgbiA9IChidWYubGVuZ3RoIC0gaSkgJSAzO1xuICBpZiAobiA9PT0gMCkgcmV0dXJuIGJ1Zi50b1N0cmluZygnYmFzZTY0JywgaSk7XG4gIHRoaXMubGFzdE5lZWQgPSAzIC0gbjtcbiAgdGhpcy5sYXN0VG90YWwgPSAzO1xuICBpZiAobiA9PT0gMSkge1xuICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDJdO1xuICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICB9XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGksIGJ1Zi5sZW5ndGggLSBuKTtcbn1cblxuZnVuY3Rpb24gYmFzZTY0RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSByZXR1cm4gciArIHRoaXMubGFzdENoYXIudG9TdHJpbmcoJ2Jhc2U2NCcsIDAsIDMgLSB0aGlzLmxhc3ROZWVkKTtcbiAgcmV0dXJuIHI7XG59XG5cbi8vIFBhc3MgYnl0ZXMgb24gdGhyb3VnaCBmb3Igc2luZ2xlLWJ5dGUgZW5jb2RpbmdzIChlLmcuIGFzY2lpLCBsYXRpbjEsIGhleClcbmZ1bmN0aW9uIHNpbXBsZVdyaXRlKGJ1Zikge1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xufVxuXG5mdW5jdGlvbiBzaW1wbGVFbmQoYnVmKSB7XG4gIHJldHVybiBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgc3R5bGVzSW5Eb20gPSB7fTtcblxudmFyIGlzT2xkSUUgPSBmdW5jdGlvbiBpc09sZElFKCkge1xuICB2YXIgbWVtbztcbiAgcmV0dXJuIGZ1bmN0aW9uIG1lbW9yaXplKCkge1xuICAgIGlmICh0eXBlb2YgbWVtbyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG4gICAgICAvLyBAc2VlIGh0dHA6Ly9icm93c2VyaGFja3MuY29tLyNoYWNrLWU3MWQ4NjkyZjY1MzM0MTczZmVlNzE1YzIyMmNiODA1XG4gICAgICAvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXG4gICAgICAvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcbiAgICAgIC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIvaXNzdWVzLzE3N1xuICAgICAgbWVtbyA9IEJvb2xlYW4od2luZG93ICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2IpO1xuICAgIH1cblxuICAgIHJldHVybiBtZW1vO1xuICB9O1xufSgpO1xuXG52YXIgZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gZ2V0VGFyZ2V0KCkge1xuICB2YXIgbWVtbyA9IHt9O1xuICByZXR1cm4gZnVuY3Rpb24gbWVtb3JpemUodGFyZ2V0KSB7XG4gICAgaWYgKHR5cGVvZiBtZW1vW3RhcmdldF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB2YXIgc3R5bGVUYXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7IC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG5cbiAgICAgIGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuICAgICAgICAgIC8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXG4gICAgICAgICAgc3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgc3R5bGVUYXJnZXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xuICAgIH1cblxuICAgIHJldHVybiBtZW1vW3RhcmdldF07XG4gIH07XG59KCk7XG5cbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyhsaXN0LCBvcHRpb25zKSB7XG4gIHZhciBzdHlsZXMgPSBbXTtcbiAgdmFyIG5ld1N0eWxlcyA9IHt9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXTtcbiAgICB2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcbiAgICB2YXIgY3NzID0gaXRlbVsxXTtcbiAgICB2YXIgbWVkaWEgPSBpdGVtWzJdO1xuICAgIHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdO1xuICAgIHZhciBwYXJ0ID0ge1xuICAgICAgY3NzOiBjc3MsXG4gICAgICBtZWRpYTogbWVkaWEsXG4gICAgICBzb3VyY2VNYXA6IHNvdXJjZU1hcFxuICAgIH07XG5cbiAgICBpZiAoIW5ld1N0eWxlc1tpZF0pIHtcbiAgICAgIHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7XG4gICAgICAgIGlkOiBpZCxcbiAgICAgICAgcGFydHM6IFtwYXJ0XVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3R5bGVzO1xufVxuXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IHN0eWxlc1tpXTtcbiAgICB2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcbiAgICB2YXIgaiA9IDA7XG5cbiAgICBpZiAoZG9tU3R5bGUpIHtcbiAgICAgIGRvbVN0eWxlLnJlZnMrKztcblxuICAgICAgZm9yICg7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICBkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcbiAgICAgIH1cblxuICAgICAgZm9yICg7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcGFydHMgPSBbXTtcblxuICAgICAgZm9yICg7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuICAgICAgfVxuXG4gICAgICBzdHlsZXNJbkRvbVtpdGVtLmlkXSA9IHtcbiAgICAgICAgaWQ6IGl0ZW0uaWQsXG4gICAgICAgIHJlZnM6IDEsXG4gICAgICAgIHBhcnRzOiBwYXJ0c1xuICAgICAgfTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcbiAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcblxuICBpZiAodHlwZW9mIG9wdGlvbnMuYXR0cmlidXRlcy5ub25jZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgbm9uY2UgPSB0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gIT09ICd1bmRlZmluZWQnID8gX193ZWJwYWNrX25vbmNlX18gOiBudWxsO1xuXG4gICAgaWYgKG5vbmNlKSB7XG4gICAgICBvcHRpb25zLmF0dHJpYnV0ZXMubm9uY2UgPSBub25jZTtcbiAgICB9XG4gIH1cblxuICBPYmplY3Qua2V5cyhvcHRpb25zLmF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHN0eWxlLnNldEF0dHJpYnV0ZShrZXksIG9wdGlvbnMuYXR0cmlidXRlc1trZXldKTtcbiAgfSk7XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zLmluc2VydCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9wdGlvbnMuaW5zZXJ0KHN0eWxlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdGFyZ2V0ID0gZ2V0VGFyZ2V0KG9wdGlvbnMuaW5zZXJ0IHx8ICdoZWFkJyk7XG5cbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnQnIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcbiAgICB9XG5cbiAgICB0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICB9XG5cbiAgcmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpIHtcbiAgLy8gaXN0YW5idWwgaWdub3JlIGlmXG4gIGlmIChzdHlsZS5wYXJlbnROb2RlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG59XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cblxuXG52YXIgcmVwbGFjZVRleHQgPSBmdW5jdGlvbiByZXBsYWNlVGV4dCgpIHtcbiAgdmFyIHRleHRTdG9yZSA9IFtdO1xuICByZXR1cm4gZnVuY3Rpb24gcmVwbGFjZShpbmRleCwgcmVwbGFjZW1lbnQpIHtcbiAgICB0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG4gICAgcmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XG4gIH07XG59KCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xuICB2YXIgY3NzID0gcmVtb3ZlID8gJycgOiBvYmouY3NzOyAvLyBGb3Igb2xkIElFXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqL1xuXG4gIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuICAgIHZhciBjaGlsZE5vZGVzID0gc3R5bGUuY2hpbGROb2RlcztcblxuICAgIGlmIChjaGlsZE5vZGVzW2luZGV4XSkge1xuICAgICAgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuICAgIH1cblxuICAgIGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgc3R5bGUuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGUuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VG9UYWcoc3R5bGUsIG9wdGlvbnMsIG9iaikge1xuICB2YXIgY3NzID0gb2JqLmNzcztcbiAgdmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuICB2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuICBpZiAobWVkaWEpIHtcbiAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoJ21lZGlhJywgbWVkaWEpO1xuICB9XG5cbiAgaWYgKHNvdXJjZU1hcCAmJiBidG9hKSB7XG4gICAgY3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIi5jb25jYXQoYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSwgXCIgKi9cIik7XG4gIH0gLy8gRm9yIG9sZCBJRVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cblxuXG4gIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChzdHlsZS5maXJzdENoaWxkKSB7XG4gICAgICBzdHlsZS5yZW1vdmVDaGlsZChzdHlsZS5maXJzdENoaWxkKTtcbiAgICB9XG5cbiAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgfVxufVxuXG52YXIgc2luZ2xldG9uID0gbnVsbDtcbnZhciBzaW5nbGV0b25Db3VudGVyID0gMDtcblxuZnVuY3Rpb24gYWRkU3R5bGUob2JqLCBvcHRpb25zKSB7XG4gIHZhciBzdHlsZTtcbiAgdmFyIHVwZGF0ZTtcbiAgdmFyIHJlbW92ZTtcblxuICBpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcbiAgICB2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcbiAgICBzdHlsZSA9IHNpbmdsZXRvbiB8fCAoc2luZ2xldG9uID0gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcbiAgICB1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIGZhbHNlKTtcbiAgICByZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIHN0eWxlID0gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuICAgIHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZSwgb3B0aW9ucyk7XG5cbiAgICByZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuICAgIH07XG4gIH1cblxuICB1cGRhdGUob2JqKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG5ld09iaikge1xuICAgIGlmIChuZXdPYmopIHtcbiAgICAgIGlmIChuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGUob2JqID0gbmV3T2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlKCk7XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChsaXN0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLmF0dHJpYnV0ZXMgPSB0eXBlb2Ygb3B0aW9ucy5hdHRyaWJ1dGVzID09PSAnb2JqZWN0JyA/IG9wdGlvbnMuYXR0cmlidXRlcyA6IHt9OyAvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cbiAgLy8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuXG4gIGlmICghb3B0aW9ucy5zaW5nbGV0b24gJiYgdHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uICE9PSAnYm9vbGVhbicpIHtcbiAgICBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcbiAgfVxuXG4gIHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCwgb3B0aW9ucyk7XG4gIGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucyk7XG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xuICAgIHZhciBtYXlSZW1vdmUgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IHN0eWxlc1tpXTtcbiAgICAgIHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXG4gICAgICBpZiAoZG9tU3R5bGUpIHtcbiAgICAgICAgZG9tU3R5bGUucmVmcy0tO1xuICAgICAgICBtYXlSZW1vdmUucHVzaChkb21TdHlsZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5ld0xpc3QpIHtcbiAgICAgIHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCwgb3B0aW9ucyk7XG4gICAgICBhZGRTdHlsZXNUb0RvbShuZXdTdHlsZXMsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBtYXlSZW1vdmUubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX2RvbVN0eWxlID0gbWF5UmVtb3ZlW19pXTtcblxuICAgICAgaWYgKF9kb21TdHlsZS5yZWZzID09PSAwKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgX2RvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgX2RvbVN0eWxlLnBhcnRzW2pdKCk7XG4gICAgICAgIH1cblxuICAgICAgICBkZWxldGUgc3R5bGVzSW5Eb21bX2RvbVN0eWxlLmlkXTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59OyIsInZhciBzY29wZSA9ICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbCkgfHxcbiAgICAgICAgICAgICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmKSB8fFxuICAgICAgICAgICAgd2luZG93O1xudmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgc2NvcGUsIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgc2NvcGUsIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xufTtcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cbmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHtcbiAgaWYgKHRpbWVvdXQpIHtcbiAgICB0aW1lb3V0LmNsb3NlKCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIFRpbWVvdXQoaWQsIGNsZWFyRm4pIHtcbiAgdGhpcy5faWQgPSBpZDtcbiAgdGhpcy5fY2xlYXJGbiA9IGNsZWFyRm47XG59XG5UaW1lb3V0LnByb3RvdHlwZS51bnJlZiA9IFRpbWVvdXQucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKCkge307XG5UaW1lb3V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jbGVhckZuLmNhbGwoc2NvcGUsIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBzZXRpbW1lZGlhdGUgYXR0YWNoZXMgaXRzZWxmIHRvIHRoZSBnbG9iYWwgb2JqZWN0XG5yZXF1aXJlKFwic2V0aW1tZWRpYXRlXCIpO1xuLy8gT24gc29tZSBleG90aWMgZW52aXJvbm1lbnRzLCBpdCdzIG5vdCBjbGVhciB3aGljaCBvYmplY3QgYHNldGltbWVkaWF0ZWAgd2FzXG4vLyBhYmxlIHRvIGluc3RhbGwgb250by4gIFNlYXJjaCBlYWNoIHBvc3NpYmlsaXR5IGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZVxuLy8gYHNldGltbWVkaWF0ZWAgbGlicmFyeS5cbmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuc2V0SW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuc2V0SW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAodGhpcyAmJiB0aGlzLnNldEltbWVkaWF0ZSk7XG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuY2xlYXJJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLmNsZWFySW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuY2xlYXJJbW1lZGlhdGUpO1xuIiwiXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZGVwcmVjYXRlO1xuXG4vKipcbiAqIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4gKiBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2Uubm9EZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudGhyb3dEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCB0aHJvdyBhbiBFcnJvciB3aGVuIGludm9rZWQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50cmFjZURlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIGludm9rZSBgY29uc29sZS50cmFjZSgpYCBpbnN0ZWFkIG9mIGBjb25zb2xlLmVycm9yKClgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gdGhlIGZ1bmN0aW9uIHRvIGRlcHJlY2F0ZVxuICogQHBhcmFtIHtTdHJpbmd9IG1zZyAtIHRoZSBzdHJpbmcgdG8gcHJpbnQgdG8gdGhlIGNvbnNvbGUgd2hlbiBgZm5gIGlzIGludm9rZWRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gYSBuZXcgXCJkZXByZWNhdGVkXCIgdmVyc2lvbiBvZiBgZm5gXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZSAoZm4sIG1zZykge1xuICBpZiAoY29uZmlnKCdub0RlcHJlY2F0aW9uJykpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChjb25maWcoJ3Rocm93RGVwcmVjYXRpb24nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAoY29uZmlnKCd0cmFjZURlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBgbG9jYWxTdG9yYWdlYCBmb3IgYm9vbGVhbiB2YWx1ZXMgZm9yIHRoZSBnaXZlbiBgbmFtZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29uZmlnIChuYW1lKSB7XG4gIC8vIGFjY2Vzc2luZyBnbG9iYWwubG9jYWxTdG9yYWdlIGNhbiB0cmlnZ2VyIGEgRE9NRXhjZXB0aW9uIGluIHNhbmRib3hlZCBpZnJhbWVzXG4gIHRyeSB7XG4gICAgaWYgKCFnbG9iYWwubG9jYWxTdG9yYWdlKSByZXR1cm4gZmFsc2U7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHZhbCA9IGdsb2JhbC5sb2NhbFN0b3JhZ2VbbmFtZV07XG4gIGlmIChudWxsID09IHZhbCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gU3RyaW5nKHZhbCkudG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnO1xufVxuIiwidmFyIGluZGV4T2YgPSBmdW5jdGlvbiAoeHMsIGl0ZW0pIHtcbiAgICBpZiAoeHMuaW5kZXhPZikgcmV0dXJuIHhzLmluZGV4T2YoaXRlbSk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh4c1tpXSA9PT0gaXRlbSkgcmV0dXJuIGk7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn07XG52YXIgT2JqZWN0X2tleXMgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgaWYgKE9iamVjdC5rZXlzKSByZXR1cm4gT2JqZWN0LmtleXMob2JqKVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgcmVzID0gW107XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHJlcy5wdXNoKGtleSlcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG59O1xuXG52YXIgZm9yRWFjaCA9IGZ1bmN0aW9uICh4cywgZm4pIHtcbiAgICBpZiAoeHMuZm9yRWFjaCkgcmV0dXJuIHhzLmZvckVhY2goZm4pXG4gICAgZWxzZSBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZuKHhzW2ldLCBpLCB4cyk7XG4gICAgfVxufTtcblxudmFyIGRlZmluZVByb3AgPSAoZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnXycsIHt9KTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iaiwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIG5hbWUsIHtcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24ob2JqLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgb2JqW25hbWVdID0gdmFsdWU7XG4gICAgICAgIH07XG4gICAgfVxufSgpKTtcblxudmFyIGdsb2JhbHMgPSBbJ0FycmF5JywgJ0Jvb2xlYW4nLCAnRGF0ZScsICdFcnJvcicsICdFdmFsRXJyb3InLCAnRnVuY3Rpb24nLFxuJ0luZmluaXR5JywgJ0pTT04nLCAnTWF0aCcsICdOYU4nLCAnTnVtYmVyJywgJ09iamVjdCcsICdSYW5nZUVycm9yJyxcbidSZWZlcmVuY2VFcnJvcicsICdSZWdFeHAnLCAnU3RyaW5nJywgJ1N5bnRheEVycm9yJywgJ1R5cGVFcnJvcicsICdVUklFcnJvcicsXG4nZGVjb2RlVVJJJywgJ2RlY29kZVVSSUNvbXBvbmVudCcsICdlbmNvZGVVUkknLCAnZW5jb2RlVVJJQ29tcG9uZW50JywgJ2VzY2FwZScsXG4nZXZhbCcsICdpc0Zpbml0ZScsICdpc05hTicsICdwYXJzZUZsb2F0JywgJ3BhcnNlSW50JywgJ3VuZGVmaW5lZCcsICd1bmVzY2FwZSddO1xuXG5mdW5jdGlvbiBDb250ZXh0KCkge31cbkNvbnRleHQucHJvdG90eXBlID0ge307XG5cbnZhciBTY3JpcHQgPSBleHBvcnRzLlNjcmlwdCA9IGZ1bmN0aW9uIE5vZGVTY3JpcHQgKGNvZGUpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU2NyaXB0KSkgcmV0dXJuIG5ldyBTY3JpcHQoY29kZSk7XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbn07XG5cblNjcmlwdC5wcm90b3R5cGUucnVuSW5Db250ZXh0ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICBpZiAoIShjb250ZXh0IGluc3RhbmNlb2YgQ29udGV4dCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm5lZWRzIGEgJ2NvbnRleHQnIGFyZ3VtZW50LlwiKTtcbiAgICB9XG4gICAgXG4gICAgdmFyIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgIGlmICghaWZyYW1lLnN0eWxlKSBpZnJhbWUuc3R5bGUgPSB7fTtcbiAgICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgXG4gICAgdmFyIHdpbiA9IGlmcmFtZS5jb250ZW50V2luZG93O1xuICAgIHZhciB3RXZhbCA9IHdpbi5ldmFsLCB3RXhlY1NjcmlwdCA9IHdpbi5leGVjU2NyaXB0O1xuXG4gICAgaWYgKCF3RXZhbCAmJiB3RXhlY1NjcmlwdCkge1xuICAgICAgICAvLyB3aW4uZXZhbCgpIG1hZ2ljYWxseSBhcHBlYXJzIHdoZW4gdGhpcyBpcyBjYWxsZWQgaW4gSUU6XG4gICAgICAgIHdFeGVjU2NyaXB0LmNhbGwod2luLCAnbnVsbCcpO1xuICAgICAgICB3RXZhbCA9IHdpbi5ldmFsO1xuICAgIH1cbiAgICBcbiAgICBmb3JFYWNoKE9iamVjdF9rZXlzKGNvbnRleHQpLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHdpbltrZXldID0gY29udGV4dFtrZXldO1xuICAgIH0pO1xuICAgIGZvckVhY2goZ2xvYmFscywgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoY29udGV4dFtrZXldKSB7XG4gICAgICAgICAgICB3aW5ba2V5XSA9IGNvbnRleHRba2V5XTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIHZhciB3aW5LZXlzID0gT2JqZWN0X2tleXMod2luKTtcblxuICAgIHZhciByZXMgPSB3RXZhbC5jYWxsKHdpbiwgdGhpcy5jb2RlKTtcbiAgICBcbiAgICBmb3JFYWNoKE9iamVjdF9rZXlzKHdpbiksIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgLy8gQXZvaWQgY29weWluZyBjaXJjdWxhciBvYmplY3RzIGxpa2UgYHRvcGAgYW5kIGB3aW5kb3dgIGJ5IG9ubHlcbiAgICAgICAgLy8gdXBkYXRpbmcgZXhpc3RpbmcgY29udGV4dCBwcm9wZXJ0aWVzIG9yIG5ldyBwcm9wZXJ0aWVzIGluIHRoZSBgd2luYFxuICAgICAgICAvLyB0aGF0IHdhcyBvbmx5IGludHJvZHVjZWQgYWZ0ZXIgdGhlIGV2YWwuXG4gICAgICAgIGlmIChrZXkgaW4gY29udGV4dCB8fCBpbmRleE9mKHdpbktleXMsIGtleSkgPT09IC0xKSB7XG4gICAgICAgICAgICBjb250ZXh0W2tleV0gPSB3aW5ba2V5XTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZm9yRWFjaChnbG9iYWxzLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICghKGtleSBpbiBjb250ZXh0KSkge1xuICAgICAgICAgICAgZGVmaW5lUHJvcChjb250ZXh0LCBrZXksIHdpbltrZXldKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgICBcbiAgICByZXR1cm4gcmVzO1xufTtcblxuU2NyaXB0LnByb3RvdHlwZS5ydW5JblRoaXNDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBldmFsKHRoaXMuY29kZSk7IC8vIG1heWJlLi4uXG59O1xuXG5TY3JpcHQucHJvdG90eXBlLnJ1bkluTmV3Q29udGV4dCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdmFyIGN0eCA9IFNjcmlwdC5jcmVhdGVDb250ZXh0KGNvbnRleHQpO1xuICAgIHZhciByZXMgPSB0aGlzLnJ1bkluQ29udGV4dChjdHgpO1xuXG4gICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgZm9yRWFjaChPYmplY3Rfa2V5cyhjdHgpLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBjb250ZXh0W2tleV0gPSBjdHhba2V5XTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbn07XG5cbmZvckVhY2goT2JqZWN0X2tleXMoU2NyaXB0LnByb3RvdHlwZSksIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgZXhwb3J0c1tuYW1lXSA9IFNjcmlwdFtuYW1lXSA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICAgIHZhciBzID0gU2NyaXB0KGNvZGUpO1xuICAgICAgICByZXR1cm4gc1tuYW1lXS5hcHBseShzLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgIH07XG59KTtcblxuZXhwb3J0cy5pc0NvbnRleHQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHJldHVybiBjb250ZXh0IGluc3RhbmNlb2YgQ29udGV4dDtcbn07XG5cbmV4cG9ydHMuY3JlYXRlU2NyaXB0ID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5TY3JpcHQoY29kZSk7XG59O1xuXG5leHBvcnRzLmNyZWF0ZUNvbnRleHQgPSBTY3JpcHQuY3JlYXRlQ29udGV4dCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdmFyIGNvcHkgPSBuZXcgQ29udGV4dCgpO1xuICAgIGlmKHR5cGVvZiBjb250ZXh0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICBmb3JFYWNoKE9iamVjdF9rZXlzKGNvbnRleHQpLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBjb3B5W2tleV0gPSBjb250ZXh0W2tleV07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gY29weTtcbn07XG4iLCJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuXHRpZiAoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcblx0XHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XG5cdH1cblx0cmV0dXJuIG1vZHVsZTtcbn07XG4iLCJpbXBvcnQgKiBhcyBoYW5kVHJhY2sgZnJvbSAnaGFuZHRyYWNranMnO1xuaW1wb3J0ICcuL3N0eWxlLmNzcyc7XG5cbmNvbnN0IHZpZGVvID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzcmN2aWRlb1wiKTtcbmNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY2FudmFzXCIpO1xuY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5jb25zdCB0cmFja0J1dHRvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidHJhY2tcIik7XG5jb25zdCBwb2ludGVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJwb2ludGVyXCIpO1xubGV0IHVwZGF0ZU5vdGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInVwZGF0ZW5vdGVcIik7XG5sZXQgbG9nID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJsb2dcIik7XG5cblxubGV0IGlzVmlkZW8gPSBmYWxzZTtcbmxldCBtb2RlbCA9IG51bGw7XG5sZXQgbGFzdE1pZFggPSAtMTAwO1xubGV0IGxhc3RNaWRZID0gLTEwMDtcblxuY29uc3QgbW9kZWxQYXJhbXMgPSB7XG4gICAgZmxpcEhvcml6b250YWw6IHRydWUsICAgLy8gZmxpcCBlLmcgZm9yIHZpZGVvICBcbiAgICBtYXhOdW1Cb3hlczogMSwgICAgICAgIC8vIG1heGltdW0gbnVtYmVyIG9mIGJveGVzIHRvIGRldGVjdFxuICAgIGlvdVRocmVzaG9sZDogMC41LCAgICAgIC8vIGlvVSB0aHJlc2hvbGQgZm9yIG5vbi1tYXggc3VwcHJlc3Npb25cbiAgICBzY29yZVRocmVzaG9sZDogMC42LCAgICAvLyBjb25maWRlbmNlIHRocmVzaG9sZCBmb3IgcHJlZGljdGlvbnMuXG59XG5cbmZ1bmN0aW9uIHN0YXJ0VmlkZW8oKSB7XG4gICAgaGFuZFRyYWNrLnN0YXJ0VmlkZW8odmlkZW8pLnRoZW4oZnVuY3Rpb24gKHN0YXR1cykge1xuICAgICAgICBjb25zb2xlLmxvZyhcInZpZGVvIHN0YXJ0ZWRcIiwgc3RhdHVzKTtcbiAgICAgICAgaWYgKHN0YXR1cykge1xuICAgICAgICAgICAgdXBkYXRlTm90ZS5pbm5lclRleHQgPSBcIlZpZGVvIHN0YXJ0ZWQuIE5vdyB0cmFja2luZ1wiXG4gICAgICAgICAgICBpc1ZpZGVvID0gdHJ1ZVxuICAgICAgICAgICAgcnVuRGV0ZWN0aW9uKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVwZGF0ZU5vdGUuaW5uZXJUZXh0ID0gXCJQbGVhc2UgZW5hYmxlIHZpZGVvXCJcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiB0b2dnbGVWaWRlbygpIHtcbiAgICBpZiAoIWlzVmlkZW8pIHtcbiAgICAgICAgdXBkYXRlTm90ZS5pbm5lclRleHQgPSBcIlN0YXJ0aW5nIHZpZGVvXCJcbiAgICAgICAgc3RhcnRWaWRlbygpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHVwZGF0ZU5vdGUuaW5uZXJUZXh0ID0gXCJTdG9wcGluZyB2aWRlb1wiXG4gICAgICAgIGhhbmRUcmFjay5zdG9wVmlkZW8odmlkZW8pXG4gICAgICAgIGlzVmlkZW8gPSBmYWxzZTtcbiAgICAgICAgdXBkYXRlTm90ZS5pbm5lclRleHQgPSBcIlZpZGVvIHN0b3BwZWRcIlxuICAgIH1cbn1cblxudHJhY2tCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uICgpIHtcbiAgICB0b2dnbGVWaWRlbygpO1xufSk7XG5cbmZ1bmN0aW9uIG1vdmVDdXJzb3IoeCwgeSkge1xuICAgIHBvaW50ZXIuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgcG9pbnRlci5zdHlsZS5sZWZ0ID0gKHggLSBwb2ludGVyLmNsaWVudFdpZHRoIC8gMikgKyAncHgnO1xuICAgIHBvaW50ZXIuc3R5bGUudG9wID0gKHkgLSBwb2ludGVyLmNsaWVudEhlaWdodCAvIDIpICsgJ3B4JztcblxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUHJlZGljdGlvbihwcmVkaWN0aW9uKSB7XG4gICAgY29uc3QgW3gsIHksIHdpZHRoLCBoZWlnaHRdID0gcHJlZGljdGlvbi5iYm94O1xuICAgIGxldCBtaWRYID0gTWF0aC5yb3VuZCh4ICsgKHdpZHRoIC8gMikpO1xuICAgIGxldCBzY3JlZW5YID0gTWF0aC5yb3VuZChkb2N1bWVudC5ib2R5LmNsaWVudFdpZHRoICogKG1pZFggLyB2aWRlby53aWR0aCkpO1xuICAgIGxldCBtaWRZID0gTWF0aC5yb3VuZCh5ICsgKGhlaWdodCAvIDIpKTtcbiAgICBsZXQgc2NyZWVuWSA9IE1hdGgucm91bmQoZG9jdW1lbnQuYm9keS5jbGllbnRIZWlnaHQgKiAobWlkWSAvIHZpZGVvLmhlaWdodCkpO1xuICAgIGxvZy5pbm5lclRleHQgKz0gYHNjb3JlOiAke01hdGgucm91bmQocHJlZGljdGlvbi5zY29yZSl9ICh4LHkpOiAoJHttaWRYfSwke21pZFl9KSBcbiAgICBkaWZmOiAoJHtsYXN0TWlkWCAtIG1pZFh9LCR7bGFzdE1pZFkgLSBtaWRZfSlcXG5gO1xuICAgIC8vIGNvbnNvbGUubG9nKCdkb2M6ICcsIGRvY3VtZW50LmJvZHkuY2xpZW50V2lkdGgsIGRvY3VtZW50LmJvZHkuY2xpZW50SGVpZ2h0KTtcbiAgICAvLyBjb25zb2xlLmxvZygndmlkOiAnLCB4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAvLyBjb25zb2xlLmxvZygnc2NlZW46ICcsIHNjcmVlblgsIHNjcmVlblkpO1xuICAgIGxhc3RNaWRYID0gbWlkWDtcbiAgICBsYXN0TWlkWSA9IG1pZFk7XG4gICAgbW92ZUN1cnNvcihzY3JlZW5YLCBzY3JlZW5ZKTtcblxufVxuZnVuY3Rpb24gcnVuRGV0ZWN0aW9uKCkge1xuICAgIG1vZGVsLmRldGVjdCh2aWRlbykudGhlbihwcmVkaWN0aW9ucyA9PiB7XG5cbiAgICAgICAgbW9kZWwucmVuZGVyUHJlZGljdGlvbnMocHJlZGljdGlvbnMsIGNhbnZhcywgY29udGV4dCwgdmlkZW8pO1xuICAgICAgICBjb25zb2xlLmxvZyhwcmVkaWN0aW9ucyk7XG5cbiAgICAgICAgaWYgKHByZWRpY3Rpb25zWzBdKSB7XG4gICAgICAgICAgICBwcm9jZXNzUHJlZGljdGlvbihwcmVkaWN0aW9uc1swXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVmlkZW8pIHtcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShydW5EZXRlY3Rpb24pO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbi8vIExvYWQgdGhlIG1vZGVsLlxuaGFuZFRyYWNrLmxvYWQobW9kZWxQYXJhbXMpLnRoZW4obG1vZGVsID0+IHtcbiAgICAvLyBkZXRlY3Qgb2JqZWN0cyBpbiB0aGUgaW1hZ2UuXG4gICAgbW9kZWwgPSBsbW9kZWxcbiAgICB1cGRhdGVOb3RlLmlubmVyVGV4dCA9IFwiTG9hZGVkIE1vZGVsIVwiXG4gICAgdHJhY2tCdXR0b24uZGlzYWJsZWQgPSBmYWxzZVxufSk7XG4iLCJ2YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vc3R5bGUuY3NzXCIpO1xuXG5pZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbn1cblxudmFyIG9wdGlvbnMgPSB7fVxuXG5vcHRpb25zLmluc2VydCA9IFwiaGVhZFwiO1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5pZiAoY29udGVudC5sb2NhbHMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbn1cbiIsIi8qIChpZ25vcmVkKSAqLyIsIi8qIChpZ25vcmVkKSAqLyIsIi8qIChpZ25vcmVkKSAqLyIsIi8qIChpZ25vcmVkKSAqLyJdLCJzb3VyY2VSb290IjoiIn0=